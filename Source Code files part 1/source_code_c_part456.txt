annel::ChannelJoinRequest: "
					"already joined to channel"));
			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join a private channel that they are not
		 *	admitted to.  Reject the request without further processing.
		 */
		WARNING_OUT (("PrivateChannel::ChannelJoinRequest: "
				"rejecting attempt to join private channel"));
		pOrigAtt->ChannelJoinConfirm(RESULT_NOT_ADMITTED, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to disband a
 *		private channel that it previously created.  If the requesting user is
 *		the private channel manager, then the request will be processed.  If
 *		this is not the Top Provider, the request will be forwarded upward.
 */
Void	PrivateChannel::ChannelDisbandRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID)
{
	CUidList				user_id_list;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"disbanding channel = %04X", Channel_ID));

			/*
			 *	Go construct lists of the current unique local and remote
			 *	attachments.  These lists will be used to transmit the proper
			 *	channel expel and channel disband indications.
			 */
			BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	It is also necessary to send the disband indication to the
			 *	channel manager, if it is valid and in the sub-tree of this
			 *	provider.  Determine what attachment leads to the channel
			 *	manager, and make sure that attachment is in the remote
			 *	attachment list, if valid.
			 */
			if (ValidateUserID(m_uidChannelManager))
			{
				PChannel		lpChannel;
				if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
                {
				    pAtt = lpChannel->GetAttachment();
				    if (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment())
				    {
					    if (remote_attachment_list.Find(pAtt) == FALSE)
					    {
						    remote_attachment_list.Append(pAtt);
						}
				    }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::ChannelDisbandRequest: can't locate channel"));
                }
			}

			/*
			 *	Loop through the local attachment list sending channel expel
			 *	indications to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

				/*
				 *	Send the expel indication to the locally attached user.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
			}

			/*
			 *	Loop through the remote attachment list sending channel disband
			 *	indications to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Send the disband indication to the remotely attached
				 *	provider.
				 */
				pAtt->ChannelDisbandIndication(Channel_ID);
			}

			/*
			 *	Set m_uidChannelManager to 0 and clear the authorized user list as
			 *	an indicator that this private channel object is no longer
			 *	valid, and cannot be used.  The next time the domain object
			 *	calls IsValid, it will return FALSE allowing the domain object
			 *	to delete this object.
			 */
			m_uidChannelManager = 0;
			m_AuthorizedUserList.Clear();
		}
		else
		{
			/*
			 *	Set a flag indicating that a disband request has been sent
			 *	upward.  This flag will be used to prevent a disband indication
			 *	from being sent to the channel manager as it flows back down
			 *	the domain tree.
			 */
			m_fDisbandRequestPending = TRUE;

			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel disband
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelDisbandRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelDisbandRequest(uidInitiator, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to disband a private channel that they are not
		 *	the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelDisbandRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it decides
 *		to delete a private channel from the domain.  It travels downward to
 *		all attachments and connections that contain an admitted user or the
 *		channel manager in their sub-tree.
 */
Void	PrivateChannel::ChannelDisbandIndication (
				ChannelID)
{
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_list;

	TRACE_OUT (("PrivateChannel::ChannelDisbandIndication: "
			"disbanding channel = %04X", Channel_ID));

	/*
	 *	Build the lists of unique local and remote attachments.  These lists
	 *	will be used to issue the appropriate indications.
	 */
	BuildAttachmentLists (&m_AuthorizedUserList, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	It is also necessary to send the disband indication to the channel
	 *	manager, if it is valid and in the sub-tree of this provider.
	 *	Determine what attachment leads to the channel manager, and make sure
	 *	that attachment is in the remote attachment list, if valid.
	 */
	if (ValidateUserID(m_uidChannelManager))
	{
		PChannel		lpChannel;
		if (NULL != (lpChannel = m_pChannelList2->Find(m_uidChannelManager)))
        {
		    pAtt = lpChannel->GetAttachment();
		    if ((m_fDisbandRequestPending == FALSE) ||
			    (m_pAttachmentList->Find(pAtt) && pAtt->IsConnAttachment()))
			{
			    if (remote_attachment_list.Find(pAtt) == FALSE)
			    {
				    remote_attachment_list.Append(pAtt);
				}
		    }
        }
        else
        {
            ERROR_OUT(("PrivateChannel::ChannelDisbandIndication: can't locate channel"));
        }
    }

	/*
	 *	Loop through the local attachment list sending channel expel indications
	 *	to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&m_AuthorizedUserList, pAtt, &user_id_list);

		/*
		 *	Send the expel indication to the locally attached user.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_list);
	}

	/*
	 *	Loop through the remote attachment list sending channel disband
	 *	indications to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Send the disband indication to the remotely attached provider.
		 */
		pAtt->ChannelDisbandIndication(Channel_ID);
	}

	/*
	 *	Set m_uidChannelManager to 0 and clear the authorized user list as an
	 *	indicator that this private channel object is no longer valid, and
	 *	cannot be used.  The next time the domain object calls IsValid, it will
	 *	return FALSE allowing the domain object to delete this object.
	 */
	m_uidChannelManager = 0;
	m_AuthorizedUserList.Clear();
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to expand the authorized user list of that channel.  If
 *		this is the Top Provider, then the request can be handled locally.
 *		Otherwise, it must be forwarded upward to the Top Provider.
 */
Void	PrivateChannel::ChannelAdmitRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (IsTopProvider())
		{
        	CAttachmentList     local_attachment_list;
        	CAttachmentList     remote_attachment_list;
        	CAttachment        *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"admitting users to channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be admitted, adding all
			 *	valid users to the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	Make sure that the user ID corresponds to a valid user in
				 *	the domain.
				 */
				if (ValidateUserID(uid))
				{
					/*
					 *	If the user is not already in the authorized user list,
					 *	then add it.
					 */
					if (m_AuthorizedUserList.Find(uid) == FALSE)
					{
						m_AuthorizedUserList.Append(uid);
						admitted_id_list.Append(uid);
					}
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate admit indications.  This prevents the
			 *	transmission of an admit indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an admit
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the admit indication to the named attachment.
				 */
				pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel admit
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelAdmitRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelAdmitRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelAdmitRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a channel admit indication from the manager of a private channel.  This
 *		indication is broadcast downward to all providers that contain an
 *		admitted user somewhere in their sub-tree.  A side-effect of this
 *		indication is that a private channel will be created in the information
 *		base if one does not already exist.
 */
Void	PrivateChannel::ChannelAdmitIndication (
				PConnection,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				admitted_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelAdmitIndication: "
			"admitting users to channel = %04X", (UINT) Channel_ID));

	/*
	 *	Iterate through the list of users to be admitted, adding all
	 *	valid users to the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Make sure that the user ID corresponds to a valid user in
		 *	the domain.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	If the user is not already in the authorized user list,
			 *	then add it.
			 */
			if (m_AuthorizedUserList.Find(uid) == FALSE)
			{
				m_AuthorizedUserList.Append(uid);
				admitted_id_list.Append(uid);
			}
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate admit indications.  This prevents the
	 *	transmission of an admit indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&admitted_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an admit
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&admitted_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the admit indication to the named attachment.
		 */
		pAtt->ChannelAdmitIndication(uidInitiator, Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to shrink the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	PrivateChannel::ChannelExpelRequest (
				CAttachment *,
				UserID				uidInitiator,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID  				uid;
	CUidList				expelled_id_list;
	CUidList				user_id_subset;

	/*
	 *	Check to see if the requesting user is the channel manager.  Only
	 *	process the request if it is.
	 */
	if (uidInitiator == m_uidChannelManager)
	{
		/*
		 *	See if this is the Top Provider.  If it is, then the request can
		 *	be processed locally.  Otherwise, pass the request upward toward
		 *	the Top Provider.
		 */
		if (m_pConnToTopProvider == NULL)
		{
        	CAttachmentList         local_attachment_list;
        	CAttachmentList         remote_attachment_list;
        	CAttachment            *pAtt;

			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"expelling users from channel = %04X", Channel_ID));

			/*
			 *	Iterate through the list of users to be expelled, removing all
			 *	valid users from the local authorized user list.
			 */
			user_id_list->Reset();
			while (NULL != (uid = user_id_list->Iterate()))
			{
				/*
				 *	If the user is in the authorized user list, then remove it.
				 */
				if (m_AuthorizedUserList.Find(uid))
				{
					m_AuthorizedUserList.Remove(uid);
					expelled_id_list.Append(uid);
				}
			}

			/*
			 *	Build lists of unique attachments which can then be used to
			 *	issue the appropriate expel indications.  This prevents the
			 *	transmission of an expel indication to the same attachment more
			 *	than once.
			 */
			BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
					&remote_attachment_list);

			/*
			 *	Iterate through the local attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			local_attachment_list.Reset();
			while (NULL != (pAtt = local_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

				/*
				 *	Since this is a locally attached user, it is necessary to
				 *	simulate a channel leave request from the user, indicating
				 *	the fact that it can no longer use the channel.
				 */
				ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
			}

			/*
			 *	Iterate through the remote attachment list issuing an expel
			 *	indication to each attachment contained therein.
			 */
			remote_attachment_list.Reset();
			while (NULL != (pAtt = remote_attachment_list.Iterate()))
			{
				/*
				 *	Get the next attachment from the list and build a list of
				 *	the users that lie in the direction of that attachment.
				 */
				BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

				/*
				 *	Send the expel indication to the named attachment.
				 */
				pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the request toward
			 *	the Top Provider.  This will result in a channel expel
			 *	indication at a future time.
			 */
			TRACE_OUT (("PrivateChannel::ChannelExpelRequest: "
					"forwarding request to Top Provider"));
			m_pConnToTopProvider->ChannelExpelRequest(uidInitiator, Channel_ID, user_id_list);
		}
	}
	else
	{
		/*
		 *	Someone is trying to admit users to a private channel that they are
		 *	not the channel manager for.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::ChannelExpelRequest: "
				"ignoring request from non-channel manager"));
	}
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a request from the manager of a private channel to reduce the
 *		authorized user list.  It travels downward to all attachments and
 *		connections that contain an admitted user or the channel manager in
 *		their sub-tree.
 */
Void	PrivateChannel::ChannelExpelIndication (
				PConnection,
				ChannelID,
				CUidList           *user_id_list)
{
	UserID					uid;
	CUidList				expelled_id_list;
	CAttachmentList         local_attachment_list;
	CAttachmentList         remote_attachment_list;
	CAttachment            *pAtt;
	CUidList				user_id_subset;

	TRACE_OUT (("PrivateChannel::ChannelExpelIndication: "
			"expelling users from channel = %04X", Channel_ID));

	/*
	 *	Iterate through the list of users to be expelled, removing all
	 *	valid users from the local authorized user list.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	If the user is in the authorized user list, then remove it.
		 */
		if (m_AuthorizedUserList.Find(uid))
		{
			m_AuthorizedUserList.Remove(uid);
			expelled_id_list.Append(uid);
		}
	}

	/*
	 *	Build lists of unique attachments which can then be used to
	 *	issue the appropriate expel indications.  This prevents the
	 *	transmission of an expel indication to the same attachment more
	 *	than once.
	 */
	BuildAttachmentLists (&expelled_id_list, &local_attachment_list,
			&remote_attachment_list);

	/*
	 *	Iterate through the local attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	local_attachment_list.Reset();
	while (NULL != (pAtt = local_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);

		/*
		 *	Since this is a locally attached user, it is necessary to
		 *	simulate a channel leave request from the user, indicating
		 *	the fact that it can no longer use the channel.
		 */
		ChannelLeaveRequest(pAtt, (CChannelIDList *) &user_id_subset);
	}

	/*
	 *	Iterate through the remote attachment list issuing an expel
	 *	indication to each attachment contained therein.
	 */
	remote_attachment_list.Reset();
	while (NULL != (pAtt = remote_attachment_list.Iterate()))
	{
		/*
		 *	Get the next attachment from the list and build a list of
		 *	the users that lie in the direction of that attachment.
		 */
		BuildUserIDList(&expelled_id_list, pAtt, &user_id_subset);

		/*
		 *	Send the expel indication to the named attachment.
		 */
		pAtt->ChannelExpelIndication(Channel_ID, &user_id_subset);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to send data
 *		to other users who are joined to a specified channel.  This routine
 *		is executed in the case that it is a private channel.  It verifies
 *		that the user is authorized to use the channel before allowing the data
 *		to be sent.
 */
Void	PrivateChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	UserID  uidInitiator;

	uidInitiator = data_packet->GetInitiator();
	if ((uidInitiator == m_uidChannelManager) || m_AuthorizedUserList.Find(uidInitiator))
	{
		/*
		 *	The channel usage is authorized, so forward the request to the
		 *	base class implementation for processing.
		 */
		Channel::SendDataRequest(pOrigAtt, type, data_packet);
	}
	else
	{
		/*
		 *	Someone is trying to send data on a private channel that they are
		 *	not authorized to use.  Ignore the request.
		 */
		WARNING_OUT (("PrivateChannel::SendDataRequest: "
				"ignoring request from non-authorized user"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called whenever another member function of this class
 *		wants to check and see if a specified user is still valid in the
 *		domain channel list.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user being checked out.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    PrivateChannel::ValidateUserID (
					UserID			user_id)
{
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			return TRUE;
	}

	return FALSE;
}

/*
 *	Void	BuildAttachmentLists ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of unique attachments that
 *		lead to the users in the specified list.  It builds two attachment
 *		lists.  The first has an entry for each unique local attachment.  The
 *		second for each remote attachment.  The key to each list is the
 *		attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		local_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			local attachments.
 *		remote_attachment_list (i)
 *			This is the dictionary that is to contain the list of unique
 *			remote attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildAttachmentLists (
				CUidList                *user_id_list,
				CAttachmentList         *local_attachment_list,
				CAttachmentList         *remote_attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a dictionary of local
	 *	attachments (those leading to locally attached users) and a dictionary
	 *	of remote attachments (those leading to remotely connected providers).
	 *	These dictionaries will be used by this provider to issue various
	 *	indications downward, without sending multiple indications to the same
	 *	attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel		lpChannel;
			/*
			 *	Determine which attachment leads to the user in question.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    CAttachment *pAtt = lpChannel->GetAttachment();
			    /*
			     *	This module builds separate lists for those users that are
			     *	attached locally and those attached remotely.
			     */
                if (m_pAttachmentList->Find(pAtt))
                {
			        if (pAtt->IsUserAttachment())
			        {
				        /*
				         *	This attachment is a local one (meaning that it leads to a
				         *	locally attached user, rather than another MCS provider).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (local_attachment_list->Find(pAtt) == FALSE)
					        local_attachment_list->Append(pAtt);
			        }
			        else
			        {
				        /*
				         *	This attachment is a remote one (meaning that it leads to
				         *	another MCS provider, rather than a locally attached user).
				         *	Check to see if this attachment has already been put into
				         *	the dictionary while processing a previous user ID.
				         */
				        if (remote_attachment_list->Find(pAtt) == FALSE)
					        remote_attachment_list->Append(pAtt);
			        }
                }
                else
                {
                    ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't find this attachment=0x%p", pAtt));
                }
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildAttachmentLists: can't locate channel"));
            }
        }
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildAttachmentLists: "
					"ERROR - user ID not valid"));
		}
	}
}

/*
 *	Void	BuildUserIDList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called upon to build a list of all users in the
 *		specified list that are in the direction of the specified attachment.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is the list of users for which the list is to be built.
 *		attachment (i)
 *			This is the attachment that the caller wishes to have a list of
 *			user IDs for.
 *		user_id_subset (o)
 *			This is the subset of the passed in user IDs that are in the
 *			direction of the specified attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	PrivateChannel::BuildUserIDList (
				CUidList               *user_id_list,
				CAttachment            *pAtt,
				CUidList               *user_id_subset)
{
	UserID				uid;

	/*
	 *	Clear out the subset list, so that we start fresh.
	 */
	user_id_subset->Clear();

	/*
	 *	Loop through the specified user list, checking to see which users
	 *	lie in the direction of the specified attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			PChannel	lpChannel;
			/*
			 *	Check to see if this user is the direction of the specified
			 *	attachment.  If it is, then put it into the user ID subset that
			 *	we are building.
			 */
			if (NULL != (lpChannel = m_pChannelList2->Find(uid)))
            {
			    if (lpChannel->GetAttachment () == pAtt)
				    user_id_subset->Append(uid);
            }
            else
            {
                ERROR_OUT(("PrivateChannel::BuildUserIDList: can't locate channel"));
            }
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT (("PrivateChannel::BuildUserIDList: "
					"ERROR - user ID not valid"));
		}
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\regitem.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	regitem.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegItem.  This 
 *		class manages the data associated with a Registry Item.  Registry Items
 *		are	used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Protected Instance Variables:
 *		m_eItemType
 *			Variable used to indicate whether this registry item is a Channel,
 *			Token, Parameter, or none of these.
 *		m_nChannelID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Channel ID.
 *		m_nTokenID
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Token ID.
 *		m_poszParameter
 *			Variable used to hold the value for the registry item when it
 *			assumes the form of a Parameter.
 *		m_RegItemPDU
 *			Storage for the "PDU" form of the registry item.
 *		m_fValidRegItemPDU
 *			Flag indicating that the internal "PDU" registry item has been
 *			filled in.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryItem structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "ms_util.h"
#include "regitem.h"

/*
 * This macro is used to ensure that the Parameter contained in the Registry
 * Item does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_PARAMETER_LENGTH		64

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegItem object from
 *		an "API" GCCRegistryItem.
 */
CRegItem::
CRegItem(PGCCRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->item_type)
    {
    case GCC_REGISTRY_CHANNEL_ID:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->channel_id;
        break;
    case GCC_REGISTRY_TOKEN_ID:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->token_id;
        break;
    case GCC_REGISTRY_PARAMETER:
		/*
		 * Check to make sure the parameter string does not violate the imposed
		 * ASN.1 constraint.
		 */
		if (registry_item->parameter.length > MAXIMUM_PARAMETER_LENGTH)
		{
			ERROR_OUT(("CRegItem::CRegItem: Error: parameter exceeds allowable length"));
			*pRetCode = GCC_INVALID_REGISTRY_ITEM;
		}
		else
		{
			m_eItemType = GCC_REGISTRY_PARAMETER;
			if (NULL == (m_poszParameter = ::My_strdupO2(
								registry_item->parameter.value,
								registry_item->parameter.length)))
			{
				*pRetCode = GCC_ALLOCATION_FAILURE;
			}
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This constructor is used to create an CRegItem object from
 *		a "PDU" RegistryItem.
 */
CRegItem::
CRegItem(PRegistryItem registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 * Check to see what type of registry item exists.  Save the registry item
	 * in the internal structure.
	 */
    switch (registry_item->choice)
    {
    case CHANNEL_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_CHANNEL_ID;
		m_nChannelID = registry_item->u.channel_id;
        break;
    case TOKEN_ID_CHOSEN:
		m_eItemType = GCC_REGISTRY_TOKEN_ID;
		m_nTokenID = registry_item->u.token_id;
        break;
    case PARAMETER_CHOSEN:
		m_eItemType = GCC_REGISTRY_PARAMETER;
		if (NULL == (m_poszParameter = ::My_strdupO2(
							registry_item->u.parameter.value,
							registry_item->u.parameter.length)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
        break;
    default:
		m_eItemType = GCC_REGISTRY_NONE;
        break;
	}
}

/*
 *	CRegItem()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegItem object
 *		from another CRegItem object.
 */
CRegItem::
CRegItem(CRegItem *registry_item, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','I')),
    m_fValidRegItemPDU(FALSE),
    m_cbDataSize(0),
    m_poszParameter(NULL)
{
	*pRetCode = GCC_NO_ERROR;

	/*
	 *	Copy pertinent information from the source object's instance variables.
	 */
	m_eItemType = registry_item->m_eItemType;
	m_nChannelID = registry_item->m_nChannelID;
	m_nTokenID = registry_item->m_nTokenID;
	if (NULL != registry_item->m_poszParameter)
	{
		if (NULL == (m_poszParameter = ::My_strdupO(registry_item->m_poszParameter)))
		{
			*pRetCode = GCC_ALLOCATION_FAILURE;
		}
	}
}

/*
 *	~CRegItem()
 *
 *	Public Function Description
 *		The CRegItem destructor has no cleanup responsibilities since
 *		no memory is explicitly allocated by this class.
 *
 */
CRegItem::
~CRegItem(void)
{
	delete m_poszParameter;
}

/*
 *	LockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine locks the registry item data and determines the amount of
 *		memory referenced by the "API" registry item data structure.
 */
UINT CRegItem::
LockRegistryItemData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry item
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" RegistryItem structure.  Force the size to be on an 
		 * even four-byte boundary.
		 */
		m_cbDataSize = 0;

		if (m_eItemType == GCC_REGISTRY_PARAMETER)
        {
			m_cbDataSize = m_poszParameter->length;
        }

		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry item data in the form of an "API" 
 *		GCCRegistryItem.  This routine is called after "locking" the registry 
 *		item data.
 */
UINT CRegItem::
GetGCCRegistryItemData(PGCCRegistryItem registry_item, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;
	
	/*
	 * If the registry item data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Otherwise, report that the 
	 * registry item has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written into the memory
		 * provided.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" registry item structure and copy any octet string
		 * data into the output memory block if the registry item is of type
		 * "parameter".
		 */ 
        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			registry_item->item_type = GCC_REGISTRY_CHANNEL_ID;
			registry_item->channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			registry_item->item_type = GCC_REGISTRY_TOKEN_ID;
			registry_item->token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			registry_item->item_type = GCC_REGISTRY_PARAMETER;
			/*
			 * Fill in the length and pointer of the parameter octet string.
			 */
			registry_item->parameter.length = m_poszParameter->length;
			registry_item->parameter.value = memory;
			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the allocated memory.
			 */		
			::CopyMemory(memory, m_poszParameter->value, m_poszParameter->length);
		    break;
        default:
			registry_item->item_type = GCC_REGISTRY_NONE;
            break;
		}
	}
	else
	{
		ERROR_OUT(("CRegItem::GetGCCRegistryItemData Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnlockRegistryItemData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry item once the lock count reaches zero.
 */
void CRegItem::
UnLockRegistryItemData(void)
{
    Unlock();
}

/*
 *	GetRegistryItemDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		"RegistryItemInfo" structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryItem" structure is 
 *		returned.
 */
void CRegItem::
GetRegistryItemDataPDU(PRegistryItem registry_item)
{
	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegItemPDU == FALSE)
	{
		m_fValidRegItemPDU = TRUE;

        switch (m_eItemType)
        {
        case GCC_REGISTRY_CHANNEL_ID:
			m_RegItemPDU.choice = CHANNEL_ID_CHOSEN;
			m_RegItemPDU.u.channel_id = m_nChannelID;
            break;
        case GCC_REGISTRY_TOKEN_ID:
			m_RegItemPDU.choice = TOKEN_ID_CHOSEN;
			m_RegItemPDU.u.token_id = m_nTokenID;
            break;
        case GCC_REGISTRY_PARAMETER:
			m_RegItemPDU.choice = PARAMETER_CHOSEN;
			/*
			 * Fill in the "PDU" parameter string.
			 */
			m_RegItemPDU.u.parameter.length = m_poszParameter->length;
			::CopyMemory(m_RegItemPDU.u.parameter.value, m_poszParameter->value, m_RegItemPDU.u.parameter.length);
            break;
        default:
			m_RegItemPDU.choice = VACANT_CHOSEN;
            break;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_item = m_RegItemPDU;
}

/*
 *	FreeRegistryItemDataPDU ();
 *
 *	Public Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 */
void CRegItem::
FreeRegistryItemDataPDU(void)
{
	if (m_fValidRegItemPDU)
	{
		/*
		 * No memory is specifically allocated to hold "PDU" data so just set
		 * the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegItemPDU = FALSE;
	}
}


GCCError CRegItem::
CreateRegistryItemData(PGCCRegistryItem *ppRegItem)
{
    GCCError rc;

    DebugEntry(CRegItem::CreateRegistryItemData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbItemSize = ROUNDTOBOUNDARY(sizeof(GCCRegistryItem));
    UINT cbDataSize = LockRegistryItemData() + cbItemSize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegItem = (PGCCRegistryItem) pData;
        ::ZeroMemory(pData, cbItemSize);

        pData += cbItemSize;
        GetGCCRegistryItemData(*ppRegItem, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegItem::CreateRegistryItemData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryItemData();

    DebugExitINT(CRegItem::CreateRegistryItemData, rc);
    return rc;
}


/*
 *	IsThisYourTokenID ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 */


/*
 *	operator= ()
 *
 *	Public Function Description:
 *		This routine is used to assign the value of one CRegItem object
 * 		to another.
 */
void CRegItem::operator= (const CRegItem& registry_item_data)	
{
	/*
	 * Free any PDU allocated data so that any subsequent calls to retrieve the
	 * PDU data will cause the PDU structure to be rebuilt.
	 */
	if (m_fValidRegItemPDU)
    {
		FreeRegistryItemDataPDU();
    }

	m_eItemType = registry_item_data.m_eItemType;
	m_nChannelID = registry_item_data.m_nChannelID;
	m_nTokenID = registry_item_data.m_nTokenID;
	if (NULL != registry_item_data.m_poszParameter)
	{
		m_poszParameter = ::My_strdupO(registry_item_data.m_poszParameter);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\socket.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*	Socket.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the implementation of our socket constructor/destructor functions.
 *
 */
#include "socket.h"
#include "plgxprt.h"

/* Size of listen queue */
#define	LISTEN_QUEUE_SIZE	3

/* External definitions */
extern HWND					TCP_Window_Handle;
extern PTransportInterface	g_Transport;

/*	
 *	void CreateAndConfigureListenSocket (VOID)
 *	
 *	Functional Description
 *		This function sets up a listening socket.
 *	returns INVALID_SOCKET if there is any error.
 */
SOCKET CreateAndConfigureListenSocket (VOID)
{
	SOCKADDR_IN		socket_control;
	SOCKET Socket;

	// Create the listening socket.
	Socket = socket (AF_INET, SOCK_STREAM, 0);

	if (Socket == INVALID_SOCKET) {
		WARNING_OUT (("Socket: error creating listening socket (errno = %d)", WSAGetLastError()));
		goto Error;
	}

	// The listen socket only waits for FD_ACCEPT msgs.
	ASSERT(TCP_Window_Handle);
	if (WSAAsyncSelect (Socket,
						TCP_Window_Handle,
						WM_SOCKET_NOTIFICATION,
						FD_ACCEPT) != 0)	{

		WARNING_OUT (("CreateAndConfigureListenSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
		goto Error;
	}
	
	/*
	 * Load the socket control structure with the parameters necessary.
	 *	- Internet socket
	 *	- Let it assign any address to this socket
	 *	- Assign our port number
	 */
	socket_control.sin_family = AF_INET;
	socket_control.sin_addr.s_addr = INADDR_ANY;
	socket_control.sin_port = htons ( TCP_PORT_NUMBER );

	/* Issue the bind call */
	if (bind (Socket, (LPSOCKADDR) &socket_control, sizeof(SOCKADDR_IN)) != 0) {
		WARNING_OUT (("Socket::Listen: bind failed:  Unable to use WinSock"));
		goto Error;
	}

	/*
	 * Issue a listen to WinSock to tell it we are willing to accept calls.
	 * This is a non-blocking listen, therefore we will receive FD_ACCEPT
	 * if someone is trying to call us.
	 */
	if (listen (Socket, LISTEN_QUEUE_SIZE) != 0) {
		WARNING_OUT (("Socket::Listen: listen failed:  Unable to use WinSock"));
		goto Error;
	}
	ASSERT(Socket != INVALID_SOCKET);

	return Socket;

Error:

    if (INVALID_SOCKET != Socket)
    {
        ::closesocket(Socket);
    }

	return INVALID_SOCKET;
}


/*
 *	PSocket	newSocket (SOCKET socket_number)
 *
 *	Functional Description:
 *		This is a constructor for the Socket object.  It allocates the
 *		send and receive buffers and sets up internal variables.
 */
PSocket	newSocket(TransportConnection XprtConn, PSecurityContext pSC)
{
    if (IS_SOCKET(XprtConn))
    {
        return ::newSocketEx(XprtConn, pSC);
    }
    return g_pSocketList->FindByTransportConnection(XprtConn, TRUE);
}


PSocket	newPluggableSocket(TransportConnection XprtConn)
{
    PSocket pSocket = ::newSocketEx(XprtConn, NULL);
    if (NULL != pSocket)
    {
    	g_pSocketList->SafeAppend(pSocket);
    }
    return pSocket;
}


PSocket	newSocketEx(TransportConnection XprtConn, PSecurityContext pSC)
{
    BOOL fRet;
	DBG_SAVE_FILE_LINE
	PSocket pSocket = new CSocket(&fRet, XprtConn, pSC);
	if (NULL != pSocket)
	{
	    if (fRet)
	    {
	        return pSocket;
	    }
	    pSocket->Release();
	}
	ERROR_OUT(("newSocket: Unable to allocate memory for Socket struct, pSocket=0x%x", pSocket));
	return NULL;
}


CSocket::CSocket(BOOL *_pfRet, TransportConnection _XprtConn, PSecurityContext _pSC)
:
    CRefCount(MAKE_STAMP_ID('S','o','c','k')),
    State(IS_SOCKET(_XprtConn) ? NOT_CONNECTED : SOCKET_CONNECTED),
    SecState((NULL == _pSC) ? SC_UNDETERMINED : SC_SECURE),
    pSC(_pSC),
    Max_Packet_Length(DEFAULT_MAX_X224_SIZE),
    Current_Length(0),
    Data_Indication_Buffer(NULL),
    Data_Indication_Length(0),
    Read_State(READ_HEADER),
    X224_Length(0),
    bSpaceAllocated(FALSE),
    Data_Memory(NULL),
    fExtendedX224(FALSE),
    fIncomingSecure(FALSE),
    XprtConn(_XprtConn)
{
    // assume failure
    *_pfRet = FALSE;

    // zero out sub structures
    ::ZeroMemory(&X224_Header, sizeof(X224_Header));
    ::ZeroMemory(&Retry_Info, sizeof(Retry_Info));
	Remote_Address[0] = '\0';

    if (IS_SOCKET(XprtConn))
    {
    	if (INVALID_SOCKET == XprtConn.nLogicalHandle)
    	{
    		/* Create a STREAM socket (fully reliable, full duplex, and sequenced) */
    		if ((XprtConn.nLogicalHandle = ::socket(AF_INET, SOCK_STREAM, 0))
    		    == INVALID_SOCKET)
    		{
    			ERROR_OUT (("CSocket: error acquiring INET socket # (errno = %d)", WSAGetLastError()));
    			return;
    		}
    	}

    	/* Enable Tx and Rx messages to the window */
    	ASSERT(TCP_Window_Handle);
    	if (::WSAAsyncSelect(XprtConn.nLogicalHandle, TCP_Window_Handle,
    	        WM_SOCKET_NOTIFICATION, 
    			FD_READ | FD_WRITE | FD_CLOSE | FD_CONNECT) != 0)
        {
    		WARNING_OUT (("CSocket: Error on WSAAsyncSelect = %d", WSAGetLastError()));
    	}
	}
    else
    {
        ASSERT(IS_PLUGGABLE(XprtConn));
        CPluggableConnection *p = ::GetPluggableConnection(this);
        if (NULL == p)
        {
    		ERROR_OUT(("newSocket: Unable to find plugable transport (%d, %d)",
    		        XprtConn.eType, XprtConn.nLogicalHandle));
    		return;
        }
    }

    // success
    *_pfRet = TRUE;
}


/*
 *	void freeSocket (PSocket, TransportConnection)
 *
 *	Functional Description:
 *		This is a destructor for the Socket object.  It frees the send
 *		and receive buffers and connection structure.
 *		It will also cleanup the listening socket. In this case, 
 *		"pSocket" is set to NULL and "trash_packets" should be set to TRUE.
 */
void freeSocket(PSocket pSocket, TransportConnection XprtConn)
{
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != g_pSocketList)
        {
            g_pSocketList->SafeRemove(pSocket);
        }
        freeSocketEx(pSocket, XprtConn);
    }
}


void freeListenSocket(TransportConnection XprtConn)
{
    ASSERT(IS_SOCKET(XprtConn));
    freeSocketEx(NULL, XprtConn);
}


void freePluggableSocket(PSocket pSocket)
{
    freeSocketEx(pSocket, pSocket->XprtConn);
    if (NULL != g_pSocketList)
    {
        g_pSocketList->SafeRemove(pSocket);
    }
}


void freeSocketEx(PSocket pSocket, TransportConnection XprtConn)
{
	// Either "pSocket" is NULL, or the socket is not invalid.
    #ifdef _DEBUG
    if (IS_SOCKET(XprtConn))
    {
        if (NULL != pSocket)
        {
	        ASSERT(INVALID_SOCKET != pSocket->XprtConn.nLogicalHandle);
	    }
	    else
	    {
	        // it is a listen socket
	        ASSERT(INVALID_SOCKET != XprtConn.nLogicalHandle);
	    }
	}
	#endif

	// Determine the socket number to use... Either the socket is the
	// socket indicated in the PSocket structure, or it is a structure-less
	// listen socket. Note: both cannot be valid!

    if (IS_SOCKET(XprtConn))
    {
    	SOCKET socket = (pSocket) ? pSocket->XprtConn.nLogicalHandle : XprtConn.nLogicalHandle;
        XprtConn.nLogicalHandle = socket;

    	/* Disable notifications to our window */
    	if (::IsWindow(TCP_Window_Handle))
    	{
    	    ::WSAAsyncSelect(socket, TCP_Window_Handle, 0, 0);
    	}
    }

	if (pSocket != NULL)
	{
	    pSocket->Release();
	}
	else
	{
		// This is the listening socket
		::ShutdownAndClose (XprtConn, FALSE, 0);
	}
}


CSocket::~CSocket(void)
{
	switch (State)
	{
	case SOCKET_CONNECTED:
	// case WAITING_FOR_DISCONNECT:
		/* All physically connected states issue a shutdown() first */
		::ShutdownAndClose(XprtConn, TRUE, SD_BOTH);
		break;

	case X224_CONNECTED:
		// Shutdown disable reception only.
		::ShutdownAndClose(XprtConn, TRUE, SD_RECEIVE);
		break;

	default:
		::ShutdownAndClose(XprtConn, FALSE, 0);
		break;
	}

	/* Free the structures */
	FreeTransportBuffer();
	delete pSC;
}


void CSocket::FreeTransportBuffer(void)
{
    if (NULL != Data_Memory)
    {
        ::FreeMemory(Data_Memory);
        Data_Memory = NULL;
        Data_Indication_Buffer = NULL;
    }
}



void CSocketList::SafeAppend(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    if (! Find(pSocket))
    {
        Append(pSocket);
    }
    ::LeaveCriticalSection(&g_csTransport);
}


BOOL CSocketList::SafeRemove(PSocket pSocket)
{
    ::EnterCriticalSection(&g_csTransport);
    BOOL fRet = Remove(pSocket);
    ::LeaveCriticalSection(&g_csTransport);
    return fRet;
}


PSocket CSocketList::FindByTransportConnection(TransportConnection XprtConn, BOOL fNoAddRef)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            if (! fNoAddRef)
            {
                pSocket->AddRef();
            }
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}


PSocket CSocketList::RemoveByTransportConnection(TransportConnection XprtConn)
{
    PSocket pSocket;
    ::EnterCriticalSection(&g_csTransport);
    Reset();
    while (NULL != (pSocket = Iterate()))
    {
        if (IS_SAME_TRANSPORT_CONNECTION(pSocket->XprtConn, XprtConn))
        {
            Remove(pSocket);
            break;
        }
    }
    ::LeaveCriticalSection(&g_csTransport);
    return pSocket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\t120app.h ===
#ifndef _T120_APPLET_SAP_
#define _T120_APPLET_SAP_

/*
 * include files 
 */
#include "it120app.h"
#include "appsap.h"

class CApplet;

typedef enum
{
    APPSESS_INITIALIZED,
    APPSESS_ATTACH_USER_REQ,
    APPSESS_ATTACH_USER_CON,
    APPSESS_JOIN_MY_CHANNEL_REQ,
    APPSESS_JOIN_MY_CHANNEL_CON,
    APPSESS_JOIN_STATIC_CHANNEL_REQ,
    APPSESS_JOIN_STATIC_CHANNEL_CON, // may go back to APPSESS_JOIN_STATIC_CHANNEL_REQ
    APPSESS_INACTIVELY_ENROLL_REQ,
    APPSESS_INACTIVELY_ENROLL_CON,
    APPSESS_RESOURCE_REQ,
    APPSESS_RESOURCE_CON, // may go back to APPSESS_RESOURCE_REQ
    APPSESS_ACTIVELY_ENROLL_REQ,
    APPSESS_ACTIVELY_ENROLL_CON,
    APPSESS_JOINED,
    APPSESS_LEAVING,
    APPSESS_LEFT,
}
    APPLET_SESSION_STATE;


typedef enum
{
    NONE_CHOSEN,
    ERROR_CHOSEN,
    RESULT_CHOSEN,
}
    SESSION_ERROR_TYPE;


typedef enum
{
    DCJS_INITIALIZED,
    DCJS_RETRIEVE_ENTRY_REQ,
    DCJS_RETRIEVE_ENTRY_CON,
    DCJS_EXISTING_CHANNEL_JOIN_REQ,
    DCJS_EXISTING_CHANNEL_JOIN_CON,
    DCJS_NEW_CHANNEL_JOIN_REQ,
    DCJS_NEW_CHANNEL_JOIN_CON,
    DCJS_REGISTER_CHANNEL_REQ,
    DCJS_REGISTER_CHANNEL_CON,
}
    DYNCHNL_JOIN_STATE;


class CAppletSession : public IT120AppletSession, public CRefCount
{
    friend class CApplet;
    friend void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CAppletSession(CApplet *, T120ConfID);
    ~CAppletSession(void);

    /* exit the conference */

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_SESSION_CB pfnCallback,
                    IN      LPVOID  pAppletContext,
                    IN      LPVOID  pSessionContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* basic info */

    STDMETHOD_(T120ConfID, GetConfID) (THIS) { return m_nConfID; }

    STDMETHOD_(BOOL, IsThisNodeTopProvider) (THIS);

    STDMETHOD_(T120NodeID, GetTopProvider) (THIS);

    /* join/leave */

    STDMETHOD_(T120Error, Join) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, Leave) (THIS);

    /* send data */

    STDMETHOD_(T120Error, AllocateSendDataBuffer) (THIS_
                IN      ULONG,
                OUT     void **);

    STDMETHOD_(void, FreeSendDataBuffer) (THIS_
                IN      void *);

    STDMETHOD_(T120Error, SendData) (THIS_
                IN      DataRequestType,
                IN      T120ChannelID,
                IN      T120Priority,
                IN		LPBYTE,
                IN		ULONG,
                IN		SendDataFlags);

    /* ------ ADVANCED METHODS ---- */

    STDMETHOD_(T120Error, InvokeApplet) (THIS_
                IN      GCCAppProtEntityList *,
                IN      GCCSimpleNodeList *,
                OUT     T120RequestTag *);

    STDMETHOD_(T120Error, InquireRoster) (THIS_
                IN      GCCSessionKey *);

    /* ------ registry services ------ */

    STDMETHOD_(T120Error, RegistryRequest) (THIS_
                IN      T120RegistryRequest *);

    /* ------ channel services ------ */

    STDMETHOD_(T120Error, ChannelRequest) (THIS_
                IN      T120ChannelRequest *);

    /* ------ token services ------ */

    STDMETHOD_(T120Error, TokenRequest) (THIS_
                IN      T120TokenRequest *);

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void MCSCallback(T120AppletSessionMsg *);

    BOOL IsJoining(void);

    //
    // handy functions for the join process
    //
    void SetTempMsg(T120AppletSessionMsg *pMsg) { m_pTempMsg = pMsg; }
    void ClearTempMsg(void) { m_pTempMsg = NULL; }
    void HandleAttachUserConfirm(void);
    void HandleJoinChannelConfirm(void);
    void HandleEnrollConfirm(void);
    void HandleRegisterChannelConfirm(void);
    void HandleRetrieveEntryConfirm(void);
	void HandleTokenGrabConfirm(void);

private:

    void ClearError(void) { m_eErrorType = NONE_CHOSEN; }
    void SetError(T120Error err) { m_eErrorType = ERROR_CHOSEN; m_Error.eError = err; }
    void SetError(T120Result res) { m_eErrorType = RESULT_CHOSEN; m_Error.eResult = res; }

    void SetState(APPLET_SESSION_STATE eState);
    APPLET_SESSION_STATE GetState(void) { return m_eState; }

    void SendMCSMessage(T120AppletSessionMsg *);
    void SendCallbackMessage(T120AppletSessionMsg *);

    T120Error DoEnroll(BOOL fEnroll, BOOL fEnrollActively = FALSE);
    void DoJoinStaticChannels(void);
    void DoResourceRequests(void);
    void DoJoinDynamicChannels(BOOL fInitState);
    void DoJoined(void);
	void DoGrabTokenRequest(void);

    void AbortJoin(void);
    void SendJoinResult(T120Result eResult = T120_RESULT_SUCCESSFUL, T120Error eErrorCode = T120_NO_ERROR);

    void FreeJoinRequest(BOOL fZeroOut);

private:

    // remmember the context
    LPVOID                  m_pAppletContext; 
    LPVOID                  m_pSessionContext; 
    LPFN_APPLET_SESSION_CB  m_pfnCallback;

    // parent applet object
    CApplet                *m_pApplet;

    // tentative sap pointers
    IMCSSap                *m_pMCSAppletSAP;

    // information about myself
    T120ConfID              m_nConfID;
    T120UserID              m_uidMyself;
    T120SessionID           m_sidMyself;
    T120EntityID            m_eidMyself;
    T120NodeID              m_nidMyself;

    // join state
    APPLET_SESSION_STATE    m_eState;
    ULONG                   m_nArrayIndex;

    // error handling
    SESSION_ERROR_TYPE      m_eErrorType;
    union
    {
        T120Error   eError;
        T120Result  eResult;
    }                       m_Error;

    // join conference request copy
    T120JoinSessionRequest  m_JoinRequest; // valid during join session
    BOOL                    m_fMCSFreeDataIndBuffer;

    // dynamic channels join state
    BOOL                    m_fFirstRoster;
    DYNCHNL_JOIN_STATE      m_eDynamicChannelJoinState;
    T120AppletSessionMsg   *m_pTempMsg;
};


class CSessionList : public CList
{
    DEFINE_CLIST(CSessionList, CAppletSession*)
    CAppletSession *FindByConfID(T120ConfID);
};


class CApplet : public IT120Applet, public CRefCount
{
    friend void CALLBACK GCC_SapCallback(GCCAppSapMsg *);

public:

    CApplet(T120Error *);
    ~CApplet(void);

    STDMETHOD_(void, ReleaseInterface) (THIS);

    STDMETHOD_(void, Advise) (THIS_
                    IN      LPFN_APPLET_CB  pfnCallback,
                    IN      LPVOID          pAppletContext);

    STDMETHOD_(void, Unadvise) (THIS);

    /* ------ Auto Join ------ */

    STDMETHOD_(T120Error, RegisterAutoJoin) (THIS_
                    IN      T120JoinSessionRequest *);

    STDMETHOD_(void, UnregisterAutoJoin) (THIS);

    /* ------ Session ------ */

    STDMETHOD_(T120Error, CreateSession) (THIS_
                    OUT     IT120AppletSession **,
                    IN      T120ConfID);


    void SendCallbackMessage(T120AppletMsg *pMsg);

    IGCCAppSap *GetAppSap(void) { return m_pAppSap; }

    void RegisterSession(CAppletSession *p) { m_SessionList.Append(p); }
    void UnregisterSession(CAppletSession *p) { m_SessionList.Remove(p); }

    CAppletSession *FindSessionByConfID(T120ConfID nConfID) { return m_SessionList.FindByConfID(nConfID); }

protected:

    void GCCCallback(T120AppletSessionMsg *);
    void HandleAutoJoin(T120ConfID);

private:

    LPFN_APPLET_CB          m_pfnCallback;
    LPVOID                  m_pAppletContext;
    IGCCAppSap             *m_pAppSap;
    CSessionList            m_SessionList;

    // for auto join
    T120JoinSessionRequest *m_pAutoJoinReq;
    CAppletSession         *m_pAutoAppletSession;
};


#endif // _T120_APPLET_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\spacket.cpp ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#include "precomp.h"

// Constructor for the SimplePacket class.

SimplePacket::SimplePacket(BOOL fPacketDirectionUp)
: 
	lLock (1),
	Packet_Direction_Up (fPacketDirectionUp)
{
}

// Destructor for the SimplePacket class
SimplePacket::~SimplePacket (void)
{
}

/*
 *	Unlock ()
 *
 *	Public
 *
 */
Void SimplePacket::Unlock ()
{
	/*
	 * Check to make sure that the packet is locked before allowing it to
	 * be unlocked.
	 */
	ASSERT (lLock > 0);

	/*
	 * If the lock count has reached zero, it is necessary to perform
	 * a suicide check.  This method will determine if there is any need
	 * to continue to exist.
	 */
	if (InterlockedDecrement(&lLock) == 0)
		delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\t120app.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


void CALLBACK MCS_SapCallback(UINT, LPARAM, LPVOID);
void CALLBACK GCC_SapCallback(GCCAppSapMsg *);


T120Error WINAPI T120_CreateAppletSAP
(
    IT120Applet **ppApplet
)
{
    if (NULL != ppApplet)
    {
        *ppApplet = NULL;
        if (NULL != g_pGCCController)
        {
            T120Error rc;
            DBG_SAVE_FILE_LINE
            CApplet *pApplet = new CApplet(&rc);
            if (NULL != pApplet)
            {
                if (T120_NO_ERROR == rc)
                {
                    *ppApplet = (IT120Applet *) pApplet;
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("T120_CreateAppletSAP: CApplet failed, rc=%u", rc));
                pApplet->Release();
                return rc;
            }

            ERROR_OUT(("T120_CreateAppletSAP: cannot create CApplet"));
            return T120_ALLOCATION_FAILURE;
        }

        WARNING_OUT(("T120_CreateAppletSAP: GCC Provider is not initialized."));
        return T120_NOT_INITIALIZED;
    }

    ERROR_OUT(("T120_CreateAppletSAP: callback pfn null"));
    return T120_INVALID_PARAMETER;
}


/* ------ interface methods for applet session ------ */


CAppletSession::CAppletSession
(
    CApplet        *pApplet,
    T120ConfID      nConfID
)
:
    CRefCount(MAKE_STAMP_ID('A','p','p','S')),
    m_pApplet(pApplet),
    m_pAppletContext(NULL),
    m_pSessionContext(NULL),
    m_pfnCallback(NULL),
    m_pMCSAppletSAP(NULL),
    m_nConfID(nConfID),
    m_uidMyself(0),
    m_sidMyself(0),
    m_eidMyself(0),
    m_nidMyself(0),
    m_eState(APPSESS_INITIALIZED),
    m_nArrayIndex(0),
    m_eErrorType(NONE_CHOSEN),
    m_eDynamicChannelJoinState(DCJS_INITIALIZED),
    m_fMCSFreeDataIndBuffer(0),
    m_fFirstRoster(FALSE),
    m_pTempMsg(NULL)
{
    ASSERT(0 != m_nConfID);
    ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    m_pApplet->RegisterSession(this);
}


CAppletSession::~CAppletSession(void)
{
    m_pApplet->UnregisterSession(this);

    FreeJoinRequest(FALSE);

    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pSessionContext);
}


void CAppletSession::FreeJoinRequest(BOOL fZeroOut)
{
    delete [] m_JoinRequest.aResourceReqs;

    if (fZeroOut)
    {
        ::ZeroMemory(&m_JoinRequest, sizeof(m_JoinRequest));
    }
}


void CAppletSession::ReleaseInterface(void)
{
    ASSERT(NULL != g_pGCCController);

    Leave();

    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;

    Release();
}


void CAppletSession::Advise
(
    LPFN_APPLET_SESSION_CB  pfnCallback,
    LPVOID                  pAppletContext,
    LPVOID                  pSessionContext
)
{
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;
    m_pSessionContext = pSessionContext;
}


void CAppletSession::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;
    m_pSessionContext = NULL;
}


BOOL CAppletSession::IsThisNodeTopProvider(void)
{
    return m_pApplet->GetAppSap()->IsThisNodeTopProvider(m_nConfID);
}


T120NodeID CAppletSession::GetTopProvider(void)
{
    return m_pApplet->GetAppSap()->GetTopProvider(m_nConfID);
}


T120Error CAppletSession::Join
(
    T120JoinSessionRequest    *pReq
)
{
    ASSERT(0 != m_nConfID);
    if (NULL != g_pGCCController->GetConfObject(m_nConfID))
    {
        T120Error rc = T120_NO_ERROR;

		// remember the join request, shallow structure copy
		m_JoinRequest = *pReq;

        // we need to duplicate the resource requests because we put the results in place.
        // we have to do this in order to support multiple conferences simultaneously
		if (NULL != pReq->aResourceReqs && 0 != pReq->cResourceReqs)
		{
		    DBG_SAVE_FILE_LINE
		    m_JoinRequest.aResourceReqs = new T120ResourceRequest[m_JoinRequest.cResourceReqs];
		    if (NULL != m_JoinRequest.aResourceReqs)
		    {
		        ::CopyMemory(m_JoinRequest.aResourceReqs, pReq->aResourceReqs,
							sizeof(T120ResourceRequest) * m_JoinRequest.cResourceReqs);
		    }
		    else
		    {
		        ERROR_OUT(("CAppletSession::Join: can't create resource requests"));
		        rc = T120_ALLOCATION_FAILURE;
		    }
		}

        // attach user now
        if (T120_NO_ERROR == rc)
        {
            m_fFirstRoster = FALSE;
            m_fMCSFreeDataIndBuffer = (pReq->dwAttachmentFlags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

            SetState(APPSESS_ATTACH_USER_REQ);
            rc = ::MCS_AttachRequest(&m_pMCSAppletSAP,
                                     (LPBYTE) &m_nConfID, sizeof(m_nConfID),
                                     MCS_SapCallback,
                                     this,
                                     pReq->dwAttachmentFlags);
            ASSERT(T120_NO_ERROR == rc);
        }

        if (T120_NO_ERROR == rc)
        {
            return T120_NO_ERROR;
        }

        FreeJoinRequest(TRUE);
        return rc;
    }

    return GCC_INVALID_CONFERENCE;
}


void CAppletSession::Leave(void)
{
    if (APPSESS_LEAVING != m_eState && APPSESS_LEFT != m_eState)
    {
        APPLET_SESSION_STATE eOldState = m_eState;
        m_eState = APPSESS_LEAVING;

        switch (eOldState)
        {
        case APPSESS_INACTIVELY_ENROLL_REQ:
        case APPSESS_INACTIVELY_ENROLL_CON:
        case APPSESS_RESOURCE_REQ:
        case APPSESS_RESOURCE_CON:
        case APPSESS_ACTIVELY_ENROLL_REQ:
        case APPSESS_ACTIVELY_ENROLL_CON:
        case APPSESS_JOINED:
        default:

            // un-enroll
            DoEnroll(FALSE);
            // fall through

        case APPSESS_ATTACH_USER_REQ:
        case APPSESS_ATTACH_USER_CON:
        case APPSESS_JOIN_MY_CHANNEL_REQ:
        case APPSESS_JOIN_MY_CHANNEL_CON:
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
        case APPSESS_JOIN_STATIC_CHANNEL_CON:

            if (NULL != m_pMCSAppletSAP)
            {
                m_pMCSAppletSAP->ReleaseInterface();
                m_pMCSAppletSAP = NULL;
            }

            // fall through

        case APPSESS_INITIALIZED:
            m_fMCSFreeDataIndBuffer = 0;
            break;
        }

        m_eState = APPSESS_LEFT;
        m_fFirstRoster = FALSE;
    }

    FreeJoinRequest(TRUE);
}


T120Error CAppletSession::AllocateSendDataBuffer
(
    ULONG       cbBufSize,
    void      **ppBuf
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->GetBuffer(cbBufSize, ppBuf);
    }
    return T120_NOT_INITIALIZED;
}


void CAppletSession::FreeSendDataBuffer
(
    void       *pBuf
)
{
    if (NULL != m_pMCSAppletSAP && (! m_fMCSFreeDataIndBuffer))
    {
        m_pMCSAppletSAP->FreeBuffer(pBuf);
    }
    else
    {
        ASSERT(0);
    }
}


T120Error CAppletSession::SendData
(
    DataRequestType             eReqType,
    T120ChannelID               nChannelID,
    T120Priority                ePriority,
    LPBYTE                      pbBuf,
    ULONG                       cbBufSize,
    SendDataFlags               eBufSource
)
{
    if (NULL != m_pMCSAppletSAP)
    {
        return m_pMCSAppletSAP->SendData(eReqType,
                                        nChannelID,
                                        (Priority) ePriority,
                                        pbBuf,
                                        cbBufSize,
                                        eBufSource);
    }
    return T120_NOT_INITIALIZED;
}


T120Error CAppletSession::InvokeApplet
(
    GCCAppProtEntityList   *pApeList,
    GCCSimpleNodeList      *pNodeList,
    T120RequestTag         *pnReqTag
)
{
    return m_pApplet->GetAppSap()->AppInvoke(m_nConfID, pApeList, pNodeList, pnReqTag);
}


T120Error CAppletSession::InquireRoster
(
    GCCSessionKey         *pSessionKey
)
{
    return m_pApplet->GetAppSap()->AppRosterInquire(m_nConfID, pSessionKey, NULL);
}


T120Error CAppletSession::RegistryRequest
(
    T120RegistryRequest     *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        IGCCAppSap *pAppSap = m_pApplet->GetAppSap();
        ASSERT(NULL != pAppSap);
        GCCRegistryKey *pKey = pReq->pRegistryKey;
        switch (pReq->eCommand)
        {
        case APPLET_REGISTER_CHANNEL:
            rc = pAppSap->RegisterChannel(m_nConfID, pKey, pReq->nChannelID);
            break;
        case APPLET_ASSIGN_TOKEN:
            rc = pAppSap->RegistryAssignToken(m_nConfID, pKey);
            break;
        case APPLET_SET_PARAMETER:
            rc = pAppSap->RegistrySetParameter(m_nConfID, pKey,
                                    pReq->Param.postrValue, pReq->Param.eModifyRights);
            break;
        case APPLET_RETRIEVE_ENTRY:
            rc = pAppSap->RegistryRetrieveEntry(m_nConfID, pKey);
            break;
        case APPLET_DELETE_ENTRY:
            rc = pAppSap->RegistryDeleteEntry(m_nConfID, pKey);
            break;
        case APPLET_ALLOCATE_HANDLE:
            rc = pAppSap->RegistryAllocateHandle(m_nConfID, pReq->cHandles);
            break;
        case APPLET_MONITOR:
            rc = pAppSap->RegistryMonitor(m_nConfID, pReq->fEnableDelivery, pKey);
            break;
        default:
            ERROR_OUT(("CAppletSession::RegistryRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::ChannelRequest
(
    T120ChannelRequest      *pReq
)
{
    T120Error rc;
    if (NULL != pReq)
    {
        T120ChannelID chid = pReq->nChannelID;
        switch (pReq->eCommand)
        {
        case APPLET_JOIN_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelJoin(chid);
            break;
        case APPLET_LEAVE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelLeave(chid);
            break;
        case APPLET_CONVENE_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelConvene();
            break;
        case APPLET_DISBAND_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelDisband(chid);
            break;
        case APPLET_ADMIT_CHANNEL:
            rc = m_pMCSAppletSAP->ChannelAdmit(chid, pReq->aUsers, pReq->cUsers);
            break;
        default:
            ERROR_OUT(("CAppletSession::ChannelRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


T120Error CAppletSession::TokenRequest
(
    T120TokenRequest        *pReq
)
{
    //T120TokenID             nTokenID;
    //T120UserID              uidGiveTo;

    T120Error rc;
    if (NULL != pReq)
    {
        T120TokenID tid = pReq->nTokenID;
        switch (pReq->eCommand)
        {
        case APPLET_GRAB_TOKEN:
            rc = m_pMCSAppletSAP->TokenGrab(tid);
            break;
        case APPLET_INHIBIT_TOKEN:
            rc = m_pMCSAppletSAP->TokenInhibit(tid);
            break;
        case APPLET_GIVE_TOKEN:
            rc = m_pMCSAppletSAP->TokenGive(tid, pReq->uidGiveTo);
            break;
        case APPLET_GIVE_TOKEN_RESPONSE:
            rc = m_pMCSAppletSAP->TokenGiveResponse(tid, pReq->eGiveResponse);
            break;
        case APPLET_PLEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenPlease(tid);
            break;
        case APPLET_RELEASE_TOKEN:
            rc = m_pMCSAppletSAP->TokenRelease(tid);
            break;
        case APPLET_TEST_TOKEN:
            rc = m_pMCSAppletSAP->TokenTest(tid);
            break;
        default:
            ERROR_OUT(("CAppletSession::TokenRequest: invalid command=%u", (UINT) pReq->eCommand));
            rc = T120_INVALID_PARAMETER;
            break;
        }
    }
    else
    {
        rc = T120_INVALID_PARAMETER;
    }
    return rc;
}


/* ------ private methods ------ */


void CAppletSession::SendCallbackMessage
(
    T120AppletSessionMsg          *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CAppletSession::SendMCSMessage
(
    T120AppletSessionMsg    *pMsg
)
{
    ASSERT(NULL != pMsg);
    if (NULL != m_pfnCallback)
    {
        pMsg->nConfID = m_nConfID;
        pMsg->pAppletContext = m_pAppletContext;
        pMsg->pSessionContext = m_pSessionContext;
        (*m_pfnCallback)(pMsg);
    }
    else
    {
        if (pMsg->eMsgType == MCS_UNIFORM_SEND_DATA_INDICATION ||
            pMsg->eMsgType == MCS_SEND_DATA_INDICATION)
        {
            if (! m_fMCSFreeDataIndBuffer)
            {
                WARNING_OUT(("CAppletSession::SendMCSMessage: send data ind, free ptr=0x%x, len=%d", pMsg->SendDataInd.user_data.value, pMsg->SendDataInd.user_data.length));
                FreeSendDataBuffer(pMsg->SendDataInd.user_data.value);
            }
        }
    }
}


void CAppletSession::MCSCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    // dispatch the message depeneding on whether we are still in the join process or not
    if (IsJoining())
    {
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case MCS_ATTACH_USER_CONFIRM:
            HandleAttachUserConfirm();
            break;

        case MCS_CHANNEL_JOIN_CONFIRM:
            HandleJoinChannelConfirm();
            break;

        case MCS_TOKEN_GRAB_CONFIRM:
        	HandleTokenGrabConfirm();
            break;

        }
    }
    else
    {
        SendMCSMessage(pMsg);
    }
}


void CAppletSession::GCCCallback
(
    T120AppletSessionMsg   *pMsg
)
{
    if (IsJoining())
    {
        // remember the current GCC applet SAP message
        SetTempMsg(pMsg);

        switch (pMsg->eMsgType)
        {
        case GCC_ENROLL_CONFIRM:
            HandleEnrollConfirm();
            break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
            if (! m_fFirstRoster)
            {
                if (APPSESS_INACTIVELY_ENROLL_CON == m_eState)
                {
                    DoResourceRequests();
                }
                m_fFirstRoster = TRUE;
            }
            break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
            HandleRegisterChannelConfirm();
            break;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
            HandleRetrieveEntryConfirm();
            break;
        }
    }
    else
    {
        SendCallbackMessage(pMsg);
    }
}


void CAppletSession::SetState(APPLET_SESSION_STATE eNewState)
{
#ifdef _DEBUG
    if (APPSESS_LEAVING != eNewState)
    {
        switch (m_eState)
        {
        case APPSESS_INITIALIZED:
            ASSERT(APPSESS_ATTACH_USER_REQ == eNewState);
            break;
        // attach user
        case APPSESS_ATTACH_USER_REQ:
            ASSERT(APPSESS_ATTACH_USER_CON == eNewState);
            break;
        case APPSESS_ATTACH_USER_CON:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_REQ == eNewState);
            break;
        // join my channel
        case APPSESS_JOIN_MY_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_MY_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_MY_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // join static channels
        case APPSESS_JOIN_STATIC_CHANNEL_REQ:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_CON == eNewState);
            break;
        case APPSESS_JOIN_STATIC_CHANNEL_CON:
            ASSERT(APPSESS_JOIN_STATIC_CHANNEL_REQ == eNewState ||
                   APPSESS_INACTIVELY_ENROLL_REQ == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_INACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_INACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // do resource requests
        case APPSESS_RESOURCE_REQ:
            ASSERT(APPSESS_RESOURCE_CON == eNewState ||
                   APPSESS_ACTIVELY_ENROLL_REQ == eNewState);
            break;
        case APPSESS_RESOURCE_CON:
            ASSERT(APPSESS_RESOURCE_REQ == eNewState);
            break;
        // enroll applet in order to do resource requests
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(APPSESS_ACTIVELY_ENROLL_CON == eNewState);
            break;
        case APPSESS_ACTIVELY_ENROLL_CON:
            ASSERT(APPSESS_JOINED == eNewState);
            break;
        // done with the join process
        case APPSESS_JOINED:
            ASSERT(APPSESS_LEAVING == eNewState);
            break; 
        case APPSESS_LEAVING:
            ASSERT(APPSESS_LEFT == eNewState);
            break; 
        default:
            ASSERT(0);
            break;
        } // switch
    } // if
#endif

    m_eState = eNewState;
}


BOOL CAppletSession::IsJoining(void)
{
    return (APPSESS_INITIALIZED < m_eState && m_eState < APPSESS_JOINED);
}


void CAppletSession::HandleAttachUserConfirm(void)
{
    if (MCS_ATTACH_USER_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        SetState(APPSESS_ATTACH_USER_CON);
        if (RESULT_SUCCESSFUL == m_pTempMsg->AttachUserConfirm.eResult)
        {
            m_uidMyself = m_pTempMsg->AttachUserConfirm.nUserID;

            // join my channel
            SetState(APPSESS_JOIN_MY_CHANNEL_REQ);
            T120Error rc = m_pMCSAppletSAP->ChannelJoin(m_uidMyself);
            if (T120_NO_ERROR == rc)
            {
                return;
            }
            SetError(rc);
            AbortJoin();
        }
        else
        {
            SetError(m_pTempMsg->AttachUserConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleAttachUserConfirm: expecting attach user confirm, invalid msg type=%u",
                    m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleTokenGrabConfirm(void)
{
    if (MCS_TOKEN_GRAB_CONFIRM == m_pTempMsg->eMsgType)
    {
        BOOL fImmediateNotification = m_JoinRequest.aResourceReqs[m_nArrayIndex].fImmediateNotification;
        ASSERT(IsJoining());
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
        	ASSERT(APPLET_GRAB_TOKEN_REQUEST == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);
            // remember the notification message if needed
            if (fImmediateNotification)
            {
                AddRef();
                SendMCSMessage(m_pTempMsg);
                if (0 == Release())
                {
                    WARNING_OUT(("CAppletSession::HandleTokenGrabConfirm: involuntary exit"));
                    return;
                }
            }

        	SetState(APPSESS_RESOURCE_CON);
            if (RESULT_SUCCESSFUL != m_pTempMsg->TokenConfirm.eResult)
            {
        	    m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID = 0; // do not grab it
            }
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleTokenGrabConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
}


void CAppletSession::HandleJoinChannelConfirm(void)
{
    if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
    {
        ASSERT(IsJoining());
        if (RESULT_SUCCESSFUL == m_pTempMsg->ChannelConfirm.eResult)
        {
            T120ChannelID nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;

            switch (GetState())
            {
            case APPSESS_JOIN_MY_CHANNEL_REQ:
                if (nChannelID == m_uidMyself)
                {
                    SetState(APPSESS_JOIN_MY_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_JOIN_STATIC_CHANNEL_REQ:
                if (nChannelID == m_JoinRequest.aStaticChannels[m_nArrayIndex])
                {
                    SetState(APPSESS_JOIN_STATIC_CHANNEL_CON);
                    DoJoinStaticChannels();
                }
                else
                {
                    ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown channel join confirm, chid=%x", (UINT) nChannelID));
                }
                break;

            case APPSESS_RESOURCE_REQ:
            	// SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
                break;

            default:
                ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: unknown state=%u", (UINT) GetState()));
                break;
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: mcs_result=%u", (UINT) m_pTempMsg->ChannelConfirm.eResult));
            SetError(m_pTempMsg->ChannelConfirm.eResult);
            AbortJoin();
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleJoinChannelConfirm: invalid msg type=%u", (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleEnrollConfirm(void)
{
    if (GCC_ENROLL_CONFIRM == m_pTempMsg->eMsgType)
    {
        m_sidMyself = m_pTempMsg->AppEnrollConfirm.sidMyself;
        m_eidMyself = m_pTempMsg->AppEnrollConfirm.eidMyself;
        m_nidMyself = m_pTempMsg->AppEnrollConfirm.nidMyself;

        switch (GetState())
        {
        case APPSESS_ACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_ACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                SetState(APPSESS_JOINED);
                SendJoinResult(GCC_RESULT_SUCCESSFUL);
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        case APPSESS_INACTIVELY_ENROLL_REQ:
            ASSERT(m_pTempMsg->AppEnrollConfirm.nConfID == m_nConfID);
            SetState(APPSESS_INACTIVELY_ENROLL_CON);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->AppEnrollConfirm.nResult)
            {
                // DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::HandleEnrollConfirm: gcc_result=%u", (UINT) m_pTempMsg->AppEnrollConfirm.nResult));
                SetError(m_pTempMsg->AppEnrollConfirm.nResult);
                AbortJoin();
            }
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleEnrollConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting enroll confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRegisterChannelConfirm(void)
{
    if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRegisterChannelConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting channel register confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}


void CAppletSession::HandleRetrieveEntryConfirm(void)
{
    if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
    {
        switch (GetState())
        {
        case APPSESS_RESOURCE_REQ:
            DoResourceRequests();
            break;

        default:
            ERROR_OUT(("CAppletSession::HandleRetrieveEntryConfirm: unknown state=%u", (UINT) GetState()));
            break;
        }
    }
    else
    {
        ERROR_OUT(("CAppletSession::HandleEnrollConfirm: expecting entry retrieve confirm, invalid msg type=%u",
                (UINT) m_pTempMsg->eMsgType));
    }
}




T120Error CAppletSession::DoEnroll
(
    BOOL        fEnroll,
    BOOL        fEnrollActively
)
{
    T120Error rc;
    T120RequestTag tag;
    GCCEnrollRequest Req;

    Req.pSessionKey = &m_JoinRequest.SessionKey;
    Req.fEnrollActively = fEnrollActively;
    Req.nUserID = m_uidMyself;
    Req.fConductingCapable = m_JoinRequest.fConductingCapable;
    Req.nStartupChannelType = m_JoinRequest.nStartupChannelType;
    Req.cNonCollapsedCaps = m_JoinRequest.cNonCollapsedCaps;
    Req.apNonCollapsedCaps = m_JoinRequest.apNonCollapsedCaps;
    Req.cCollapsedCaps = m_JoinRequest.cCollapsedCaps;
    Req.apCollapsedCaps = m_JoinRequest.apCollapsedCaps;
    Req.fEnroll = fEnroll;

    rc = m_pApplet->GetAppSap()->AppEnroll(m_nConfID, &Req, &tag);
    if (GCC_NO_ERROR == rc)
	{
		return GCC_NO_ERROR;
	}

	if (fEnroll)
	{
	    WARNING_OUT(("CAppletSession::DoEnroll: AppEnroll failed, rc=%u", (UINT) rc));
	    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == rc);
		SetError(rc);
		AbortJoin();
	}
	else
	{
		// doing nothing because we don't care we fail to unenroll...
	}
    return rc;
}


void CAppletSession::DoJoinStaticChannels(void)
{
    T120Error rc;
    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_JOIN_MY_CHANNEL_CON:
        m_nArrayIndex = 0;
        break;
    case APPSESS_JOIN_STATIC_CHANNEL_CON:
        m_nArrayIndex++;
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinStaticChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cStaticChannels &&
        NULL != m_JoinRequest.aStaticChannels)
    {
        SetState(APPSESS_JOIN_STATIC_CHANNEL_REQ);
        rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aStaticChannels[m_nArrayIndex]);
        if (T120_NO_ERROR == rc)
		{
			return;
		}

		ERROR_OUT(("CAppletSession::DoJoinStaticChannels: ChannelJoin failed, rc=%u", (UINT) rc));
        SetError(rc);
        AbortJoin();
    }
    else
    {
		m_nArrayIndex = 0;
        if (m_JoinRequest.cResourceReqs == 0)
        {
            SetState(APPSESS_ACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, TRUE);
        }
        else
        {
            SetState(APPSESS_INACTIVELY_ENROLL_REQ);
            DoEnroll(TRUE, FALSE);
        }
    }
}


void CAppletSession::DoResourceRequests(void)
{
    //T120Error rc;
    BOOL fInitResourceState = FALSE;
    //ULONG i;

    ASSERT(IsJoining());

    // set up array index
    switch (GetState())
    {
    case APPSESS_INACTIVELY_ENROLL_CON:
        m_nArrayIndex = 0;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    case APPSESS_RESOURCE_REQ:
        // do nothing
        break;
    case APPSESS_RESOURCE_CON:
        m_nArrayIndex++;
        fInitResourceState = TRUE;
        SetState(APPSESS_RESOURCE_REQ);
        break;
    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: invalid state=%u", (UINT) GetState()));
        break;
    }

    if (m_nArrayIndex < m_JoinRequest.cResourceReqs)
    {
        ASSERT(NULL != m_JoinRequest.aResourceReqs);
        switch (m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand)
        {
		case APPLET_GRAB_TOKEN_REQUEST:
			DoGrabTokenRequest();
			break;
        case APPLET_JOIN_DYNAMIC_CHANNEL:
            DoJoinDynamicChannels(fInitResourceState);
            break;
        default:
            ERROR_OUT(("CAppletSession::DoResourceRequests: should not get here, state=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand));
            break;
        }
    }
    else
    {
        SetState(APPSESS_ACTIVELY_ENROLL_REQ);
        DoEnroll(TRUE, TRUE);
    }
}

void CAppletSession::DoGrabTokenRequest(void)
{
    T120TokenRequest        Req;

    Req.eCommand = APPLET_GRAB_TOKEN;
    Req.nTokenID = m_JoinRequest.aResourceReqs[m_nArrayIndex].nTokenID;
	TokenRequest(&Req);
}

void CAppletSession::DoJoinDynamicChannels(BOOL fInitState)
{
    T120Error rc;
    //ULONG i;

    ASSERT(IsJoining());
    ASSERT(APPLET_JOIN_DYNAMIC_CHANNEL == m_JoinRequest.aResourceReqs[m_nArrayIndex].eCommand);

    if (fInitState)
    {
        m_eDynamicChannelJoinState = DCJS_INITIALIZED;
    }

    switch (m_eDynamicChannelJoinState)
    {
    case DCJS_INITIALIZED:
        // clean up all the dynamic channel id
        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = 0;

        // start the first dynamic channel negotiation process
        // SetState(APPSESS_JOIN_DYNAMIC_CHANNEL_REQ);
        m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_REQ;
        rc = m_pApplet->GetAppSap()->RegistryRetrieveEntry(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey);
        if (T120_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
            SetError(rc);
            AbortJoin();
        }
        break;

    case DCJS_EXISTING_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            if (m_pTempMsg->ChannelConfirm.nChannelID == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID)
            {
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_CON;
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: unknown channel join confirm, chid=%x",
                            (UINT) m_pTempMsg->ChannelConfirm.nChannelID));
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_NEW_CHANNEL_JOIN_REQ:
        if (MCS_CHANNEL_JOIN_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_CON;
            // remember the channel id
            m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->ChannelConfirm.nChannelID;
            // try to register this channel
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_REQ;
            rc = m_pApplet->GetAppSap()->RegisterChannel(m_nConfID,
                        &m_JoinRequest.aResourceReqs[m_nArrayIndex].RegKey,
                        m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            if (T120_NO_ERROR != rc)
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: RegistryRetrieveEntry failed, rc=%u", (UINT) rc));
                SetError(rc);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel join confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

   case DCJS_RETRIEVE_ENTRY_REQ:
        if (GCC_RETRIEVE_ENTRY_CONFIRM == m_pTempMsg->eMsgType)
        {
            m_eDynamicChannelJoinState = DCJS_RETRIEVE_ENTRY_CON;
            ASSERT(m_nConfID == m_pTempMsg->RegistryConfirm.nConfID);
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(0 != m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                // remember the existing channel ID
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join this channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(%u) failed, rc=%u",
                        (UINT) m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID, (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ASSERT(GCC_RESULT_ENTRY_DOES_NOT_EXIST == m_pTempMsg->RegistryConfirm.nResult);
                ASSERT(0 == m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                // allocate a new channel
                m_eDynamicChannelJoinState = DCJS_NEW_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(0);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting entry retrieve confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    case DCJS_REGISTER_CHANNEL_REQ:
        if (GCC_REGISTER_CHANNEL_CONFIRM == m_pTempMsg->eMsgType)
        {
            ASSERT(0 != m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
            m_eDynamicChannelJoinState = DCJS_REGISTER_CHANNEL_CON;
            if (GCC_RESULT_SUCCESSFUL == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                ASSERT(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID == m_pTempMsg->RegistryConfirm.pRegItem->channel_id);
                SetState(APPSESS_RESOURCE_CON);
                DoResourceRequests();
            }
            else
            if (GCC_RESULT_ENTRY_ALREADY_EXISTS == m_pTempMsg->RegistryConfirm.nResult)
            {
                ASSERT(GCC_REGISTRY_CHANNEL_ID == m_pTempMsg->RegistryConfirm.pRegItem->item_type);
                // leave the old channel (DON'T CARE ABOUT THE CONFIRM)
                rc = m_pMCSAppletSAP->ChannelLeave(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                ASSERT(T120_NO_ERROR == rc);
                // remember the new channel id
                m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID = m_pTempMsg->RegistryConfirm.pRegItem->channel_id;
                // join the new channel
                m_eDynamicChannelJoinState = DCJS_EXISTING_CHANNEL_JOIN_REQ;
                rc = m_pMCSAppletSAP->ChannelJoin(m_JoinRequest.aResourceReqs[m_nArrayIndex].nChannelID);
                if (T120_NO_ERROR != rc)
                {
                    ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, rc=%u", (UINT) rc));
                    SetError(rc);
                    AbortJoin();
                }
            }
            else
            {
                ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: ChannelJoin(0) failed, result=%u",
                            (UINT) m_pTempMsg->RegistryConfirm.nResult));
                SetError(m_pTempMsg->RegistryConfirm.nResult);
                AbortJoin();
            }
        }
        else
        {
            ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: expecting channel register confirm, invalid msg type=%u",
                        (UINT) m_pTempMsg->eMsgType));
        }
        break;

    default:
        ERROR_OUT(("CAppletSession::DoJoinDynamicChannels: should not get here, state=%u", (UINT) m_eDynamicChannelJoinState));
        break;
    }
}


void CAppletSession::AbortJoin(void)
{
    T120Result eResult = T120_RESULT_CHECK_T120_ERROR;
    T120Error eError = T12_ERROR_CHECK_T120_RESULT;

    switch (m_eErrorType)
    {
    case NONE_CHOSEN:
        ERROR_OUT(("CAppletSession::AbortJoin: NON_CHOSEN, impossible"));
        break;
    case ERROR_CHOSEN:
        eError = m_Error.eError;
        break;
    case RESULT_CHOSEN:
        eResult = m_Error.eResult;
        break;
    default:
        ERROR_OUT(("CAppletSession::AbortJoin: invalid err type=%u", (UINT) m_eErrorType));
        break;
    }

    // let's debug why the join process is aborted.
    WARNING_OUT(("CAppletSession::AbortJoin: eResult=%u, eError=%u", eResult, eError));
    ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == eError ||
           T12_ERROR_CHECK_T120_RESULT == eError);

    SendJoinResult(eResult, eError);
}


void CAppletSession::SendJoinResult(T120Result eResult, T120Error eError)
{
    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));

    Msg.eMsgType = T120_JOIN_SESSION_CONFIRM;
    Msg.nConfID = m_nConfID;
    Msg.JoinSessionConfirm.eResult = eResult;
    Msg.JoinSessionConfirm.eError = eError;
    Msg.JoinSessionConfirm.pIAppletSession = (IT120AppletSession *) this;

    if (T120_RESULT_SUCCESSFUL == eResult)
    {
        Msg.JoinSessionConfirm.uidMyself = m_uidMyself;
        Msg.JoinSessionConfirm.sidMyself = m_sidMyself;
        Msg.JoinSessionConfirm.eidMyself = m_eidMyself;
        Msg.JoinSessionConfirm.nidMyself = m_nidMyself;
        Msg.JoinSessionConfirm.cResourceReqs = m_JoinRequest.cResourceReqs;
        Msg.JoinSessionConfirm.aResourceReqs = m_JoinRequest.aResourceReqs;
    }

    SendCallbackMessage(&Msg);
}



CApplet::CApplet
(
    T120Error   *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('C','A','p','l')),
    m_pfnCallback(NULL),
    m_pAppletContext(NULL),
    m_pAppSap(NULL),
    m_pAutoJoinReq(NULL),
    m_pAutoAppletSession(NULL)
{
    *pRetCode = ::GCC_CreateAppSap(&m_pAppSap, this, GCC_SapCallback);
}


CApplet::~CApplet(void)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    ASSERT(NULL == m_pAppSap);
}


void CApplet::ReleaseInterface(void)
{
	Unadvise();

    if (NULL != m_pAppSap)
    {
        m_pAppSap->ReleaseInterface();
        m_pAppSap = NULL;
    }

    Release();
}


void CApplet::Advise
(
    LPFN_APPLET_CB      pfnCallback,
    LPVOID              pAppletContext
)
{
    ASSERT(NULL == m_pfnCallback);
    ASSERT(NULL == m_pAppletContext);
    m_pfnCallback = pfnCallback;
    m_pAppletContext = pAppletContext;

	// this may incur permit to enroll indication
	g_pGCCController->RegisterApplet(this);
}


void CApplet::Unadvise(void)
{
    m_pfnCallback = NULL;
    m_pAppletContext = NULL;

    if (g_pGCCController)
    {
        g_pGCCController->UnregisterApplet(this);
    }
}


T120Error CApplet::RegisterAutoJoin
(
    T120JoinSessionRequest *pReq
)
{
    m_pAutoJoinReq = pReq;
    return T120_NO_ERROR;
}


void CApplet::UnregisterAutoJoin(void)
{
    m_pAutoJoinReq = NULL;
}


T120Error CApplet::CreateSession
(
    IT120AppletSession    **ppSession,
    T120ConfID              nConfID
)
{
    if (NULL != ppSession)
    {
        if (NULL != g_pGCCController->GetConfObject(nConfID))
        {
            if (! FindSessionByConfID(nConfID))
            {
                DBG_SAVE_FILE_LINE
                *ppSession = (IT120AppletSession *) new CAppletSession(this, nConfID);
                if (NULL != *ppSession)
                {
                    return T120_NO_ERROR;
                }

                ERROR_OUT(("CApplet::CreateSession: cannot create CAppletSession"));
                return T120_ALLOCATION_FAILURE;
            }

            WARNING_OUT(("CApplet::CreateSession: session already exists for nConfID=%u", (UINT) nConfID));
            return GCC_CONFERENCE_ALREADY_EXISTS;
        }

        WARNING_OUT(("CApplet::CreateSession: invalid conf, nConfID=%u", (UINT) nConfID));
        return GCC_INVALID_CONFERENCE;
    }

    ERROR_OUT(("CApplet::CreateSession: ppSession is null"));
    return T120_INVALID_PARAMETER;
}


void CApplet::SendCallbackMessage(T120AppletMsg *pMsg)
{
    if (NULL != m_pfnCallback)
    {
        pMsg->pAppletContext = m_pAppletContext;
        (*m_pfnCallback)(pMsg);
    }
}


void CApplet::GCCCallback
(
    T120AppletSessionMsg    *pMsg
)
{
    T120ConfID nConfID = pMsg->nConfID;
    ASSERT(0 != nConfID);

    if (GCC_PERMIT_TO_ENROLL_INDICATION == pMsg->eMsgType)
    {
        T120AppletMsg *p = (T120AppletMsg *) pMsg;
        if (p->PermitToEnrollInd.fPermissionGranted && NULL != m_pAutoJoinReq)
        {
            HandleAutoJoin(nConfID);
        }
        else
        {
            if (! p->PermitToEnrollInd.fPermissionGranted)
            {
                CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
                if (NULL != pAppletSession)
                {
                    if (pAppletSession->IsJoining())
                    {
                        pAppletSession->SetError(GCC_CONFERENCE_NOT_ESTABLISHED);
                        pAppletSession->AbortJoin();
                    }
                }
            }
            SendCallbackMessage(p);
        }
    }
    else
    {
        CAppletSession *pAppletSession = FindSessionByConfID(nConfID);
        if (NULL != pAppletSession)
        {
            pAppletSession->GCCCallback(pMsg);
        }
        else
        {
            WARNING_OUT(("GCC_SapCallback: cannot find a session (%u) for this gcc message (%u)",
                        (UINT) nConfID, (UINT) pMsg->eMsgType));
        }
    }
}


void CALLBACK AutoJoinCallbackProc
(
    T120AppletSessionMsg *pMsg
)
{
    switch (pMsg->eMsgType)
    {
    case T120_JOIN_SESSION_CONFIRM:
        if (NULL != pMsg->pAppletContext)
        {
            pMsg->pSessionContext = NULL;
            ((CApplet *) pMsg->pAppletContext)->SendCallbackMessage((T120AppletMsg *) pMsg);
        }
        break;

    default:
        ERROR_OUT(("AutoJoinCallbackProc: invalid msg type=%u", pMsg->eMsgType));
        break;
    }
}


void CApplet::HandleAutoJoin
(
    T120ConfID      nConfID
)
{
    DBG_SAVE_FILE_LINE
    CAppletSession *pSession = new CAppletSession(this, nConfID);
    if (NULL != pSession)
    {
        T120Error rc;
        pSession->Advise(AutoJoinCallbackProc, this, pSession);
        rc = pSession->Join(m_pAutoJoinReq);
        if (rc != T120_NO_ERROR)
        {
            delete pSession;
        }
    }
}




CAppletSession * CSessionList::FindByConfID
(
    T120ConfID      nConfID
)
{
    CAppletSession *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->GetConfID() == nConfID)
        {
            return p;
        }
    }
    return NULL;
}



void CALLBACK GCC_SapCallback
(
    GCCAppSapMsg   *_pMsg
)
{
    T120AppletSessionMsg *pMsg = (T120AppletSessionMsg *) _pMsg;
    CApplet *pApplet = (CApplet *) pMsg->pAppletContext;
    ASSERT(NULL != pApplet);

    pApplet->GCCCallback(pMsg);
}


void CALLBACK MCS_SapCallback
(
    UINT            nMsg,
    LPARAM          Param1,
    LPVOID          Param2
)
{
    CAppletSession *pAppletSession = (CAppletSession *) Param2;
    ASSERT(NULL != pAppletSession);

    T120AppletSessionMsg Msg;
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = (T120MessageType) nMsg;
    // Msg.pAppletContext = NULL;
    // Msg.pSessionContext = NULL;
    // Msg.nConfID = 0;

    // construct MCS message
    switch (Msg.eMsgType)
    {
    // send data
    case MCS_SEND_DATA_INDICATION:
    case MCS_UNIFORM_SEND_DATA_INDICATION:
        Msg.SendDataInd = * (SendDataIndicationPDU *) Param1;
        break;

   // channel confirm
    case MCS_CHANNEL_JOIN_CONFIRM:
    case MCS_CHANNEL_CONVENE_CONFIRM:
        Msg.ChannelConfirm.eResult = (T120Result) HIWORD(Param1);
        Msg.ChannelConfirm.nChannelID = LOWORD(Param1);
        break;
    // channel indication
    case MCS_CHANNEL_LEAVE_INDICATION:
    case MCS_CHANNEL_DISBAND_INDICATION:
    case MCS_CHANNEL_ADMIT_INDICATION:
    case MCS_CHANNEL_EXPEL_INDICATION:
        Msg.ChannelInd.nChannelID = LOWORD(Param1);
        Msg.ChannelInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // token confirm
    case MCS_TOKEN_GRAB_CONFIRM:
    case MCS_TOKEN_INHIBIT_CONFIRM:
    case MCS_TOKEN_GIVE_CONFIRM:
    case MCS_TOKEN_RELEASE_CONFIRM:
    case MCS_TOKEN_TEST_CONFIRM:
        Msg.TokenConfirm.nTokenID = LOWORD(Param1);
        Msg.TokenConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    // token indication
    case MCS_TOKEN_GIVE_INDICATION:
    case MCS_TOKEN_PLEASE_INDICATION:
    case MCS_TOKEN_RELEASE_INDICATION:
        Msg.TokenInd.nTokenID = LOWORD(Param1);
        Msg.TokenInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    // user
    case MCS_ATTACH_USER_CONFIRM:
        Msg.AttachUserConfirm.nUserID = LOWORD(Param1);
        Msg.AttachUserConfirm.eResult = (T120Result) HIWORD(Param1);
        break;
    case MCS_DETACH_USER_INDICATION:
        Msg.DetachUserInd.nUserID = LOWORD(Param1);
        Msg.DetachUserInd.eReason = (T120Reason) HIWORD(Param1);
        break;
    default:
        WARNING_OUT(("MCS_SapCallback: Ignore MCS message, type=%u", Msg.eMsgType));
        break;
    }

    pAppletSession->MCSCallback(&Msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\sap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	sap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CBaseSap.  This class is an
 *		abstract base class for objects that act as Service Access Points (SAPs)
 *		to external applications or the node controller.
 *
 *		This class has two main responsibilities. First, it handles many of the
 *		administrative tasks that are common to all types of SAPs.  These
 *		include handling command target registration responsibilities and
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application
 *		SAPs (CAppSap class).
 *
 *	Protected Member Functions:
 *		AddToMessageQueue
 *			This routine is used to place messages into the queue of messages
 *			to be sent to applications or the node controller.
 *		CreateDataToBeDeleted
 *			This routine is used to create a structure which holds message data
 *			to be delivered to applications or the node controller.
 *		CopyDataToGCCMessage
 *			This routine is	used to fill in the messages to be delivered to
 *			applications or the node controller with the necessary data.
 *		FreeCallbackMessage
 *			This is a virtual function which is used to free up any data which
 *			was allocated in order to send a callback message.  This function
 *			is overloaded in CControlSAP to free messages which were sent to the
 *			node controller.  It is overloaded in CAppSap to free messages sent
 *			to applications.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */


#include "ms_util.h"
#include "sap.h"
#include "conf.h"
#include "gcontrol.h"
#include "ernccm.hpp"


/*
 *	The node controller SAP handle is always 0.
 */
#define NODE_CONTROLLER_SAP_HANDLE						0

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern HINSTANCE g_hDllInst;
extern char g_szGCCWndClassName[24];


/*
 *	CBaseSap::CBaseSap()
 *
 *	Public Function Description
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 */
#ifdef SHIP_BUILD
CBaseSap::CBaseSap(void)
:
    CRefCount(),
#else
CBaseSap::CBaseSap(DWORD dwStampID)
:
    CRefCount(dwStampID),
#endif
    m_nReqTag(GCC_INVALID_TAG)
{
    //
    // LONCHANC: We have to create the hidden window first
    // because we may need to post PermissionToEnrollIndication
    // to this window for Chat and File Transfer.
    //

    ASSERT(g_szGCCWndClassName[0] == 'G' &&
           g_szGCCWndClassName[1] == 'C' &&
           g_szGCCWndClassName[2] == 'C');
    //
    // Create a hidden window for confirm and indication.
    // CAppSap or CControlSAP should check for the value of m_hwndNotify.
    //
    m_hwndNotify = CreateWindowA(g_szGCCWndClassName, NULL, WS_POPUP,
                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL, NULL, g_hDllInst, NULL);

    ASSERT(NULL != m_hwndNotify);
}

CBaseSap::~CBaseSap(void)
{
    //
    // Destroy window and unregister window class
    //
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
    }
}


BOOL CBaseSap::IsThisNodeTopProvider(GCCConfID nConfID)
{
    BOOL   fRet;
    CConf  *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        fRet = pConf->IsConfTopProvider();
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}


GCCNodeID CBaseSap::GetTopProvider(GCCConfID nConfID)
{
    GCCNodeID uRet;
    CConf     *pConf;
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        uRet = pConf->GetTopProvider();
    }
    else
    {
        uRet = 0;
    }
    return uRet;
}


/*
 *	ConfRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm.
 */
GCCError CBaseSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsgEx **ppMsgEx)
{
	GCCError  rc;
    CConf     *pConf;

    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConfRosterInquireRequest(this, ppMsgEx);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CBaseSap::ConfRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
            // goto MyExit;
        }
	}
	else
    {
        WARNING_OUT(("CBaseSap::ConfRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }

	return rc;
}

/*
 *	GCCError   AppRosterInquire()
 *
 *	Public Function Description
 *		This routine is used to retrieve a list of application rosters.  This
 *		function just passes this request to the controller via an owner
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 */
GCCError CBaseSap::
AppRosterInquire(GCCConfID          nConfID,
                 GCCSessionKey      *pSessionKey,
                 GCCAppSapMsgEx     **ppMsgEx) // nonzero for sync operation

{
	GCCError  rc;
    CConf     *pConf;

    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        WARNING_OUT(("CBaseSap::AppRosterInquire: invalid conf ID=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
    }
	else
	{
        CAppRosterMsg  *pAppRosterMsg;
		rc = pConf->AppRosterInquireRequest(pSessionKey, &pAppRosterMsg);
        if (GCC_NO_ERROR == rc)
        {
            AppRosterInquireConfirm(nConfID, pAppRosterMsg, GCC_RESULT_SUCCESSFUL, ppMsgEx);
            pAppRosterMsg->Release();
        }
        else
        {
            ERROR_OUT(("CBaseSap::AppRosterInquire: can't inquire app roster, rc=%u", (UINT) rc));
        }
	}

	return rc;
}

/*
 *	ConductorInquire()
 *
 *	Public Function Description
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 */
GCCError CBaseSap::ConductorInquire(GCCConfID nConfID)
{
    GCCError    rc;
    CConf       *pConf;

	/*
	**	Make sure the conference exists in the internal list before forwarding
	**	the call on to the conference object.
	*/
	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		rc = pConf->ConductorInquireRequest(this);
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
	}

	return rc;
}

/*
 *	AppInvoke()
 *
 *	Public Function Description
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 */
GCCError CBaseSap::
AppInvoke(GCCConfID             nConfID,
          GCCAppProtEntityList  *pApeList,
          GCCSimpleNodeList     *pNodeList,
          GCCRequestTag         *pnReqTag)
{
	GCCError							rc = GCC_NO_ERROR;
	CInvokeSpecifierListContainer		*invoke_list;
	UINT								i;
	CConf       *pConf;

    DebugEntry(CBaseSap::AppInvoke);

    if (NULL == pApeList || NULL == pNodeList || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    *pnReqTag = GenerateRequestTag();

	if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
		if (pApeList->cApes != 0)
		{
			/*
			**	Create an object which is used to hold the list of application
			**	invoke specifiers.
			*/
			DBG_SAVE_FILE_LINE
			invoke_list = new CInvokeSpecifierListContainer(
									pApeList->cApes,
									pApeList->apApes,
									&rc);
			if ((invoke_list != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				**	Here we must check the destination node list for invalid
				**	node IDs.
				*/
				for (i = 0; i < pNodeList->cNodes; i++)
				{
					if (pNodeList->aNodeIDs[i] < MINIMUM_USER_ID_VALUE)
					{
						rc = GCC_INVALID_MCS_USER_ID;
						goto MyExit;
					}
				}

				/*
				**	If no error has occurred, send the request on to the
				**	command target (conference) object.
				*/
				rc = pConf->AppInvokeRequest(invoke_list, pNodeList, this, *pnReqTag);

				/*
				**	Free here instead of delete in case the object
				**	must persist.
				*/
				invoke_list->Release();
			}
			else if (invoke_list == NULL)
			{
				ERROR_OUT(("CBaseSap::AppInvoke: Error creating new AppInvokeSpecList"));
				rc = GCC_ALLOCATION_FAILURE;
				// goto MyExit;
			}
			else
			{
				invoke_list->Release();
			}
		}
		else
		{
			rc = GCC_BAD_NUMBER_OF_APES;
			// goto MyExit;
		}
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
		// goto MyExit;
	}

MyExit:

    DebugExitINT(CBaseSap::AppInvoke, rc);
	return rc;
}


GCCRequestTag CBaseSap::GenerateRequestTag(void)
{
    GCCRequestTag nNewReqTag;

    ASSERT(sizeof(GCCRequestTag) == sizeof(LONG));

    nNewReqTag = ++m_nReqTag;
    if (GCC_INVALID_TAG == nNewReqTag)
    {
        nNewReqTag = ++m_nReqTag;
    }

    // we only take the lower word
    return (nNewReqTag & 0x0000FFFFL);
}




//
// SapNotifyWndProc() is used to notify the sap clients (app in app sap,
// node controller in control sap) in their respective thread.
// The window handle is in CSap::m_hwndNotify.
//
LRESULT CALLBACK
SapNotifyWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    LRESULT wnd_rc = 0;

    if (CSAPMSG_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE)
    {
        ASSERT(CSAPMSG_BASE + MSG_RANGE == CSAPCONFIRM_BASE);
        if (uMsg < CSAPMSG_BASE + MSG_RANGE)
        {
            if (((CControlSAP *) lParam) == g_pControlSap)
            {
                g_pControlSap->NotifyProc((GCCCtrlSapMsgEx *) wParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, lParam=0x%p, g_pControlSap=0x%p",
                            uMsg, lParam, g_pControlSap));
            }
        }
        else
        {
            ASSERT(CSAPCONFIRM_BASE <= uMsg && uMsg < CSAPCONFIRM_BASE + MSG_RANGE);
            if (NULL != g_pControlSap)
            {
                g_pControlSap->WndMsgHandler(uMsg, wParam, lParam);
            }
            else
            {
                WARNING_OUT(("SapNotifyWndProc: invalid control sap, uMsg=%u, wParam=0x%x, lParam=0x%x",
                            uMsg, (UINT) wParam, (UINT) lParam));
            }
        }
    }
    else
    if (ASAPMSG_BASE <= uMsg && uMsg < ASAPMSG_BASE + MSG_RANGE)
    {
        ASSERT(uMsg == ASAPMSG_BASE + (UINT) ((GCCAppSapMsgEx *) wParam)->Msg.eMsgType);
        ((CAppSap *) lParam)->NotifyProc((GCCAppSapMsgEx *) wParam);
    }
    else
    if (CONFMSG_BASE <= uMsg && uMsg < CONFMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != ((CConf *) lParam))
        {
            ((CConf *) lParam)->WndMsgHandler(uMsg);
        }
        else
        {
            ERROR_OUT(("SapNotifyWndProc: invalid conf object, uMsg=%u, lParam=0x%x",
                        uMsg, (UINT) lParam));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (GCTRLMSG_BASE <= uMsg && uMsg < GCTRLMSG_BASE + MSG_RANGE)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        if (((GCCController *) lParam) == g_pGCCController)
        {
            g_pGCCController->WndMsgHandler(uMsg);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid gcc controller, uMsg=%u, lParam=0x%p, g_pGCCController=0x%p",
                        uMsg, lParam, g_pGCCController));
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }
    else
    if (MCTRLMSG_BASE <= uMsg && uMsg < MCTRLMSG_BASE + MSG_RANGE)
    {	
    	void CALLBACK MCSCallBackProcedure (UINT, LPARAM, PVoid);
    	MCSCallBackProcedure (uMsg - MCTRLMSG_BASE, lParam, NULL);
    	/*
    	 *	If the msg contains user data, we need to unlock the
    	 *	memory with it.
    	 */
    	UnlockMemory ((PMemory) wParam);
    }
    else
    if (NCMSG_BASE <= uMsg && uMsg < NCMSG_BASE + MSG_RANGE)
    {
        if (((DCRNCConferenceManager *) wParam) == g_pNCConfMgr)
        {
            g_pNCConfMgr->WndMsgHandler(uMsg, lParam);
        }
        else
        {
            WARNING_OUT(("SapNotifyWndProc: invalid NC ConfMgr, uMsg=%u, lParam=0x%p, g_pNCConfMgr=0x%p",
                        uMsg, lParam, g_pNCConfMgr));
        }
    }
    else
    {
        switch (uMsg)
        {
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return wnd_rc;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\tprtctrl.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

#include <datguids.h>
#include <nmqos.h>
#include <t120qos.h>
#include "tprtsec.h"
#include <tsecctrl.h>
#include <tprtntfy.h>
#include "cnpcoder.h"
#include "plgxprt.h"

// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT


/*    Tprtctrl.cpp
 *
 *    Copyright (c) 1996 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains the TCP transport and all connections.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;
extern PTransportInterface    g_Transport;
extern SOCKET                Listen_Socket;
extern SOCKET                Listen_Socket_Secure;
extern CRITICAL_SECTION        csQOS;
extern CPluggableTransport *g_pPluggableTransport;

extern PController            g_pMCSController;
extern CCNPCoder            *g_CNPCoder;
extern HWND                 TCP_Window_Handle;

BOOL FindSocketNumber(DWORD dwGCCID, SOCKET * socket_number);

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];

// The external MCS Controller object
extern PController    g_pMCSController;

// plugable transport prototypes
int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);
int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *pnLastError);


/*
 *    void QoSLock(Void)
 *
 *    Functional Description:
 *        This function locks the QoS data
 *        All other reader or writer threads will be blocked.
 */
void QoSLock(Void)
{
    EnterCriticalSection(&csQOS);
}

/*
 *    void    QoSUnlock(Void)
 *
 *    Functional Description:
 *        This function unlocks the QoS data
 *        Waiting reader or writer threads will be unblocked.
 */
void QoSUnlock(Void)
{
    LeaveCriticalSection(&csQOS);
}

/*
 *    TransportError    ConnectRequest (    TransportAddress    transport_address,
 *                                        BOOL                fSecure
 *                                        PTransportConnection         pXprtConn)
 *
 *    Functional Description:
 *        This function initiates a connection.  It passes the transport address
 *        to the TCP transport.  It will either deny the request or accept the
 *        request and call us back when the physical connection is established.
 *
 *        We return the transport connection handle in the transport_connection
 *        address.  Although we return this transport number to the user, it
 *        is not ready for data transfer until the user receives the
 *        TRANSPORT_CONNECT_INDICATION and responds with a ConnectResponse() call.
 *        At that point, the transport connection is up and running.
 */
TransportError    ConnectRequest (TransportAddress    transport_address,
                                BOOL                fSecure,
                 /* out */       PTransportConnection         pXprtConn)
{
    TransportError rc = TRANSPORT_NO_ERROR;
    PSocket        pSocket;
    PSecurityContext pSC = NULL;
    ULong        address;
    SOCKADDR_IN    sin;
    CPluggableConnection *p = NULL;

    // initialize transport connection
    UINT nPluggableConnID = ::GetPluggableTransportConnID(transport_address);
    if (nPluggableConnID)
    {
        p = ::GetPluggableConnection(nPluggableConnID);
        if (NULL != p)
        {
            pXprtConn->eType = p->GetType();
            pXprtConn->nLogicalHandle = nPluggableConnID;
            ASSERT(IS_PLUGGABLE(*pXprtConn));
        }
        else
        {
            return TRANSPORT_NO_SUCH_CONNECTION;
        }
    }
    else
    {
        pXprtConn->eType = TRANSPORT_TYPE_WINSOCK;
        pXprtConn->nLogicalHandle = INVALID_SOCKET;
    }

    // we are connecting X224...
    ::OnProtocolControl(*pXprtConn, PLUGXPRT_CONNECTING);

    // Try to prepare a security context object if we're told to do so.
    if ( fSecure )
    {
        // If we're trying to connect securely but can't, fail
        if ( NULL == g_Transport->pSecurityInterface )
        {
            WARNING_OUT(("Placing secure call failed: no valid security interface"));
            return TRANSPORT_SECURITY_FAILED;
        }

        DBG_SAVE_FILE_LINE
        if (NULL != (pSC = new SecurityContext(g_Transport->pSecurityInterface,
                                                transport_address)))
        {
            if ( TPRTSEC_NOERROR != pSC->Initialize(NULL,0))
            {
                // If we can't init a security context, fail
                delete pSC;
                pSC = NULL;
                WARNING_OUT(("Placing secure call failed: could not initialize security context"));
                return TRANSPORT_SECURITY_FAILED;
            }
        }
    }

    /* Create and Initialize the Socket object */
    pSocket = newSocket(*pXprtConn, pSC);
    if( pSocket == NULL )
        return (TRANSPORT_MEMORY_FAILURE);

    pSocket->SecState = ( NULL == pSC ) ? SC_NONSECURE : SC_SECURE;

    if (IS_SOCKET(*pXprtConn))
    {
        u_short uPort = TCP_PORT_NUMBER;
        TCHAR szAddress[MAXIMUM_IP_ADDRESS_SIZE];
        lstrcpyn(szAddress, transport_address, MAXIMUM_IP_ADDRESS_SIZE);
        LPTSTR pszSeparator = (LPTSTR)_StrChr(szAddress, _T(':'));
        if (NULL != pszSeparator)
        {
            uPort = (u_short)DecimalStringToUINT(CharNext(pszSeparator));
            *pszSeparator = _T('\0');
        }

        /* Convert the ascii string into an Internet Address */
        if ((address = inet_addr(szAddress)) == INADDR_NONE)
        {
            WARNING_OUT (("ConnectRequest: %s is an invalid host addr", szAddress));
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }

        lstrcpyn (pSocket->Remote_Address, transport_address, MAXIMUM_IP_ADDRESS_SIZE);

        /*
         * Load the socket control structure with the parameters necessary.
         *
         *    - Internet socket
         *    - Let it assign any address to this socket
         *    - Assign our port number (depending on secure/nonsecure call!)
         */
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = address;
        sin.sin_port = htons (uPort);

        /* Attempt a connection to the remote site */
        TRACE_OUT (("ConnectRequest: Issuing connect: address = %s", transport_address));
        if (::connect(pSocket->XprtConn.nLogicalHandle, (const struct sockaddr *) &sin, sizeof(sin)) == 0)
        {
            TRACE_OUT (("ConnectRequest:   State = SOCKET_CONNECTED..."));
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (WSAGetLastError() == WSAEWOULDBLOCK)
        {
            /* If the error message is WSAEWOULDBLOCK, we must wait for the FD_CONNECT. */
            TRACE_OUT (("ConnectRequest:   State = WAITING_FOR_CONNECTION..."));
            pSocket -> State = WAITING_FOR_CONNECTION;
            /* Add socket to connection list */
            // bugbug: we may fail to insert.
            g_pSocketList->SafeAppend(pSocket);
            // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECT_PENDING, IDS_NULL_STRING);
        }
        else
        {
            WARNING_OUT (("ConnectRequest: Connect Failed error = %d",WSAGetLastError()));

            /* The connect() call failed, close the socket and notify the owner    */
            // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_READY, IDS_NULL_STRING);
            ::ShutdownAndClose(pSocket->XprtConn, FALSE, 2);
            rc = TRANSPORT_CONNECT_REQUEST_FAILED;
            goto Bail;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(*pXprtConn));
        g_pSocketList->SafeAppend(pSocket);
        if (IS_PLUGGABLE_X224(*pXprtConn))
        {
           ::SendX224ConnectRequest(pSocket->XprtConn);
        }
        else
        if (IS_PLUGGABLE_PSTN(*pXprtConn))
        {
            rc = p->TConnectRequest();
            ASSERT(TRANSPORT_NO_ERROR == rc);
        }
    }

Bail:

    ASSERT(NULL != pSocket);
    if (TRANSPORT_NO_ERROR == rc)
    {
        *pXprtConn = pSocket->XprtConn;
    }
    else
    {
        ::freeSocket(pSocket, *pXprtConn);
    }

    return rc;
}


/*
 *    BOOL ConnectResponse (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function is called by the user in response to a
 *        TRANSPORT_CONNECT_INDICATION callback from us.  By making this call the
 *        user is accepting the call.  If the user does not want to accept the
 *        call, he should call DisconnectRequest();
 */
BOOL ConnectResponse (TransportConnection XprtConn)
{
    PSocket    pSocket;

    TRACE_OUT (("ConnectResponse(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    /* If this is an invalid handle, return error */
    if(NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        BOOL fRet;
        if (pSocket->State == SOCKET_CONNECTED)
        {
            /* We do not change this state in ANY other place BECAUSE  it breaks the connect request*/
            pSocket->State = X224_CONNECTED;
            fRet = TRUE;
        }
        else
        {
            ERROR_OUT(("ConnectResponse: Illegal ConnectResponse packet"));
            fRet = FALSE;
        }
        pSocket->Release();
        return fRet;
    }
    return FALSE;
}

#ifdef TSTATUS_INDICATION
/*
 *    Void    SendStatusMessage (    PChar RemoteAddress,
 *                                TransportState State,
 *                                 UInt message_id)
 *
 *    Functional Description:
 *        This function is called to send a status indication to the user. The
 *        specific text of the message is contained in a string resource.
 */
Void SendStatusMessage(    PChar RemoteAddress,
                          TransportState    state,
                          UInt                message_id)
{
    TransportStatus transport_status;
    char            sTransport[80] = "";
    char            message[80] = "";

    if( message_id == IDS_NULL_STRING )
        message[0] = '\000';
    else
        LoadString(
                (HINSTANCE) g_hDllInst,
                (UINT) message_id,
                (LPSTR) message,
                (int) sizeof(message) );

     /*
     **    We issue a callback to the user to notify him of the message
     */
    transport_status.device_identifier = "";
    transport_status.remote_address = RemoteAddress;
    transport_status.message = message;
    transport_status.state = state;

    g_pMCSController->HandleTransportStatusIndication(&transport_status);
}
#endif


/*
 *    Void    SendX224ConnectRequest(TransportConnection XprtConn)
 *
 *    Functional Description:
 *        This function is called upon receipt of the FD_CONNECT from Winsock.
 *        It indicates that the physical connection is established, and sends
 *        the X224 connection request packet.
 */
void SendX224ConnectRequest(TransportConnection XprtConn)
{
    PSocket            pSocket;

    static X224_CR_FIXED cr_fixed =
    {
        { 3, 0, 0, UNK },
        UNK,
        { CONNECTION_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
    };

    TRACE_OUT(("SendX224ConnectRequest"));

    CNPPDU                  cnp_pdu;
    ConnectRequestPDU_reliableSecurityProtocols_Element cnp_cr_rsp_element;
    LPBYTE                  pbToSendBuf = NULL;
    UINT                    cbToSendBuf = 0;
    LPBYTE                  encoded_pdu;
    UINT                    encoded_pdu_length;

    TransportError          error;

    cnp_pdu.choice = connectRequest_chosen;
    cnp_pdu.u.connectRequest.bit_mask = 0;
    cnp_pdu.u.connectRequest.protocolIdentifier = t123AnnexBProtocolId;
    cnp_pdu.u.connectRequest.reconnectRequested = FALSE;

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* If this is an invalid handle, return */
    if (NULL == (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        return;

    if (IS_SOCKET(pSocket->XprtConn))
    {
        if (pSocket -> State != WAITING_FOR_CONNECTION)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }
    else
    {
        ASSERT(IS_PLUGGABLE(pSocket->XprtConn));
        if (X224_CONNECTED == pSocket->State)
        {
            // after query remote, we need to reset the state back to socket connected
            pSocket->State = SOCKET_CONNECTED;
        }
        if (SOCKET_CONNECTED != pSocket->State)
        {
            ERROR_OUT (("SendX224ConnectRequest: Illegal Socket State"));
            goto MyExit;
        }
    }

    // If there is a security context associated with this socket, we
    // are settting up for a secure call and will indicate that in the CNP
    // portion of the packet
    if (NULL != pSocket->pSC)
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting secure connection"));

        cnp_pdu.u.connectRequest.bit_mask |= reliableSecurityProtocols_present;
        cnp_cr_rsp_element.next = NULL;
        cnp_cr_rsp_element.value.choice = gssApiX224_chosen;
        cnp_pdu.u.connectRequest.reliableSecurityProtocols = &cnp_cr_rsp_element;
    }
    else
    {
        TRACE_OUT(("SendX224ConnectRequest: requesting NON-secure connection"));
    }

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
        goto MyExit;
    }

    pSocket -> State = SOCKET_CONNECTED;

    /* X224 header */
    cr_fixed.conn.msbSrc = (UChar) (XprtConn.nLogicalHandle >> 8);
    cr_fixed.conn.lsbSrc = (UChar) XprtConn.nLogicalHandle;

    cbToSendBuf = sizeof(X224_CR_FIXED)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
    cr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    cr_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON)+sizeof(X224_TPDU_INFO)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length);
    ASSERT ( cbToSendBuf <= 128);
    DBG_SAVE_FILE_LINE
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224ConnectRequest: failed to allocate memory"));
        goto MyExit;
    }

    {
        LPBYTE pbTemp = pbToSendBuf;
        memcpy(pbTemp, (LPBYTE) &cr_fixed, sizeof(cr_fixed));
        pbTemp += sizeof(cr_fixed);

        {
            X224_TPDU_INFO x224_tpdu_info = { TPDU_SIZE, 1, DEFAULT_TPDU_SIZE };
            memcpy(pbTemp, (LPBYTE) &x224_tpdu_info, sizeof(x224_tpdu_info));
            pbTemp += sizeof(x224_tpdu_info);
        }

        {
            X224_VARIABLE_INFO x224_var_info = { T_SELECTOR, (UChar)encoded_pdu_length };
            memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));   // bug: error handling
            pbTemp += sizeof(x224_var_info);
            memcpy(pbTemp, encoded_pdu, encoded_pdu_length);
        }
    }

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
    error = FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
    ASSERT (TRANSPORT_NO_ERROR == error);

    delete [] pbToSendBuf;

MyExit:

    pSocket->Release();
}



/*
 *    Void    SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
 *
 *    Functional Description:
 *        This function is called upon receipt of the X224 connection request
 *        packet. It indicates that the remote side wants to establish a
 *        logical connection, and sends the X224 connection response packet.
 *
 *    Return value:
 *        TRUE, if everything went ok.
 *        FALSE, otherwise (this implies a Disconnect will be issued for the socket).
 */
// LONCHANC: "remote" is from the X.224 ConnectRequest
BOOL SendX224ConnectConfirm (PSocket pSocket, unsigned int remote)
{
    //PUChar            ptr;
    LPBYTE                  pbToSendBuf = NULL;
    UINT            cbToSendBuf = 0;
    LPBYTE                  encoded_pdu = NULL;
    UINT                    encoded_pdu_length = 0;
    CNPPDU                  cnp_pdu;
    BOOL            fAcceptSecure = FALSE;
    BOOL            fRequireSecure = FALSE;

    TRACE_OUT(("SendX224ConnectConfirm"));

    {
        RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

        switch (re.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY))
        {
            case DISABLED_POL_SECURITY:
                break;

            case REQUIRED_POL_SECURITY:
                fAcceptSecure = TRUE;
                fRequireSecure = TRUE;
                break;

            default:
                fAcceptSecure = TRUE;
                break;
        }
    }

        static X224_CC_FIXED cc_fixed =
        {
            { 3, 0, 0, UNK },    // RFC1006 header
            UNK,
            { CONNECTION_CONFIRM_PACKET, UNK, UNK, UNK, UNK, 0 } // common info
        };

    // Sanity check field sizes... these need to conform to protocol
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);
    ASSERT (sizeof(X224_CONNECT_COMMON) == 6);
    ASSERT (sizeof(X224_TPDU_INFO) == 3);

    /* X224 header */
    cc_fixed.conn.msbDest = (UChar) (remote >> 8);
    cc_fixed.conn.lsbDest = (UChar) remote;
    cc_fixed.conn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    cc_fixed.conn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = connectConfirm_chosen;
    cnp_pdu.u.connectConfirm.bit_mask = 0;
    cnp_pdu.u.connectConfirm.protocolIdentifier = t123AnnexBProtocolId;

    if ( pSocket->fExtendedX224 )
    {
        TRACE_OUT(("SendX224ConnectConfirm reply using extended X224"));

        if ( pSocket->fIncomingSecure )
        {
            TRACE_OUT(("SendX224ConnectConfirm: reply to secure call request"));

            // Security not even initialized?
            if ( NULL == g_Transport->pSecurityInterface )
            {
                WARNING_OUT(("Can't accept secure call: no sec interface"));
            }
            // Registry indicates no secure calls? If we're in the service
            // then security is always 'on'.
            else if    ( !g_Transport->pSecurityInterface->IsInServiceContext() &&
                !fAcceptSecure)
            {
                WARNING_OUT(("Can't accept secure call: security disabled"));
            }
            else    // OK to take secure call
            {
                TRACE_OUT(("Creating security context for incoming call on socket (%d, %d).", pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle ));
                if ( NULL != (pSocket->pSC =
                    new SecurityContext(g_Transport->pSecurityInterface, "")))
                {
                    // Indicate we're ready for a secure call in the CC packet
                    cnp_pdu.u.connectConfirm.bit_mask |=
                        ConnectConfirmPDU_reliableSecurityProtocol_present;
                    cnp_pdu.u.connectConfirm.reliableSecurityProtocol.choice =
                        gssApiX224_chosen;
                    pSocket->SecState = SC_SECURE;
                }
                else
                {
                    ERROR_OUT(("Error creating sec context on received call"));
                    // We will report no-support for security in our CC
                    pSocket->SecState = SC_NONSECURE;
                }
            }
        }
        else if (    // Incoming call is not secure, but not downlevel

                // Running as a service?
                g_Transport->bInServiceContext ||
                fRequireSecure)
        {
            WARNING_OUT(("Can't accept non-secure call in RDS, or if security required"));
            return FALSE;
        }
        else
        {
            pSocket->SecState = SC_NONSECURE;
        }

                if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                                         CNPPDU_PDU,
                                         PACKED_ENCODING_RULES,
                                         &encoded_pdu,
                                         &encoded_pdu_length))
                {
                    ERROR_OUT(("SendX224ConnectRequest: Can't encode cnp pdu"));
                    return FALSE;
                }

                cbToSendBuf = sizeof(X224_CC_FIXED)+sizeof(X224_VARIABLE_INFO)+encoded_pdu_length;
                cc_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
                cc_fixed.HeaderSize = (UChar)(sizeof(X224_CONNECT_COMMON) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
                ASSERT( cbToSendBuf <= 128 );
                pbToSendBuf = new BYTE[cbToSendBuf];
                if (NULL == pbToSendBuf)
                {
                    ERROR_OUT(("SendX224ConnectConfirm: failed to allocate memory"));
                    return FALSE;
                }

                PBYTE pbTemp = pbToSendBuf;
                memcpy(pbTemp, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
                pbTemp += sizeof(cc_fixed);

                X224_VARIABLE_INFO x224_var_info = { T_SELECTOR_2 /*0xc2*/, (UChar)encoded_pdu_length };
                memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
                pbTemp += sizeof(x224_var_info);

                memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

                g_CNPCoder->FreeEncoded(encoded_pdu);
    }
    else    // Incoming call is downlevel
    {
        if ( g_Transport->bInServiceContext || fRequireSecure)
        {
            WARNING_OUT(("Can't accept downlevel call in RDS or if security required"));
            return FALSE;
        }

        pSocket->SecState = SC_NONSECURE;

        // Downlevel: send packet w/out TSELECTOR variable portion
        cc_fixed.rfc.lsbPacketSize = sizeof(X224_CC_FIXED);
        cc_fixed.HeaderSize = sizeof(X224_CONNECT_COMMON);
        cbToSendBuf = sizeof(X224_CC_FIXED);
                pbToSendBuf = new BYTE[cbToSendBuf];
                memcpy(pbToSendBuf, (LPBYTE) &cc_fixed, sizeof(cc_fixed));
    }

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
    FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
        delete [] pbToSendBuf;
    return TRUE;
}

BOOL SendX224DisconnectRequest(PSocket pSocket, unsigned int remote, USHORT usReason)
{
    LPBYTE      pbToSendBuf = NULL;
    UINT    cbToSendBuf = 0;
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
    CNPPDU      cnp_pdu;
    LPBYTE      encoded_pdu = NULL;
    UINT        encoded_pdu_length = 0;

    TRACE_OUT(("SendX224DisconnectRequest"));

    static X224_DR_FIXED dr_fixed =
    {
        { 3, 0, 0, UNK },   // RFC1006 header
        UNK,
        { DISCONNECT_REQUEST_PACKET, UNK, UNK, UNK, UNK, 0 },
    };

    ASSERT (pSocket->fExtendedX224);
    ASSERT (sizeof(RFC_HEADER) == 4);
    ASSERT (sizeof(X224_DATA_PACKET) == 7);

    ::OnProtocolControl(pSocket->XprtConn, PLUGXPRT_DISCONNECTING);

    dr_fixed.disconn.msbDest = (UChar) (remote >> 8);
    dr_fixed.disconn.lsbDest = (UChar) remote;
    dr_fixed.disconn.msbSrc = (UChar) (pSocket->XprtConn.nLogicalHandle >> 8);
    dr_fixed.disconn.lsbSrc = (UChar) pSocket->XprtConn.nLogicalHandle;

    cnp_pdu.choice = disconnectRequest_chosen;
    cnp_pdu.u.disconnectRequest.bit_mask = 0;
    cnp_pdu.u.disconnectRequest.disconnectReason.choice = usReason;

    if (! g_CNPCoder->Encode((LPVOID) &cnp_pdu,
                             CNPPDU_PDU,
                             PACKED_ENCODING_RULES,
                             &encoded_pdu,
                             &encoded_pdu_length))
    {
        ERROR_OUT(("SendX224DisconnectRequest: Can't encode cnp pdu"));
        return FALSE;
    }

    cbToSendBuf = sizeof(X224_DR_FIXED) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length;
    dr_fixed.rfc.lsbPacketSize = (UChar)cbToSendBuf;
    dr_fixed.HeaderSize = (UChar)(sizeof(X224_DISCONN) + sizeof(X224_VARIABLE_INFO) + encoded_pdu_length);
    ASSERT( cbToSendBuf <= 128 );
    pbToSendBuf = new BYTE[cbToSendBuf];
    if (NULL == pbToSendBuf)
    {
        ERROR_OUT(("SendX224DisconnectRequest: failed to allocate memory"));
        return FALSE;
    }
    LPBYTE pbTemp = pbToSendBuf;
    memcpy(pbTemp, (LPBYTE) &dr_fixed, sizeof(dr_fixed));
    pbTemp += sizeof(dr_fixed);
    X224_VARIABLE_INFO x224_var_info = { 0xe0, (UChar)encoded_pdu_length };
    memcpy(pbTemp, (LPBYTE) &x224_var_info, sizeof(x224_var_info));
    pbTemp += sizeof(x224_var_info);
    memcpy(pbTemp, encoded_pdu, encoded_pdu_length);

    g_CNPCoder->FreeEncoded(encoded_pdu);

    /* Attempt to send data out the socket */
#ifdef DEBUG
    TransportError error =
#endif // DEBUG
        FlushSendBuffer(pSocket, pbToSendBuf, cbToSendBuf);
#ifdef  DEBUG
    ASSERT (TRANSPORT_NO_ERROR == error);
#endif  // DEBUG
    return TRUE;
}

/*
 *    void    ContinueAuthentication (PSocket pSocket)
 *
 *    Functional Description:
 */
void ContinueAuthentication (PSocket pSocket)
{
    ULong                packet_size;
    PUChar                Buffer;
    PSecurityContext    pSC = pSocket->pSC;

    if (NULL != pSC) {

        TRACE_OUT(("ContinueAuthentication: sending data packet"));

        ASSERT(NULL != pSC->GetTokenBuf());
        ASSERT(0 != pSC->GetTokenSiz());

        /* We send an X224 data */
        packet_size = sizeof(X224_DATA_PACKET) + pSC->GetTokenSiz();
        DBG_SAVE_FILE_LINE
        Buffer = new UChar[packet_size];
        if (NULL != Buffer)
        {
            memcpy(Buffer + sizeof(X224_DATA_PACKET),
                    pSC->GetTokenBuf(),
                    pSC->GetTokenSiz());

            /* X224 header */
            memcpy (Buffer, g_X224Header, sizeof(X224_DATA_PACKET));
            AddRFCSize (Buffer, packet_size);

            /* Attempt to send data out the socket */
#ifdef DEBUG
            TransportError error = FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
            ASSERT (TRANSPORT_NO_ERROR == error);
#else  // DEBUG
            FlushSendBuffer(pSocket, (LPBYTE) Buffer, packet_size);
#endif  // DEBUG
            delete [] Buffer;
        }
        else {
            // bugbug: what do we need to do in case of a mem alloc failure?
            WARNING_OUT (("ContinueAuthentication: memory allocation failure."));
        }
    }
    else {
        ERROR_OUT(("ContinueAuthentication called w/ bad socket"));
    }
}

/*
 *    The following function processes the variable part of incoming X.224
 *    CONNECT_REQUEST and CONNECT_CONFIRM PDUs.
 *    For now, it can only process Max PDU size and security T_SELECTOR requests.
 */
BOOL ProcessX224ConnectPDU (PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
/* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;

        /*
         *    Check the packet to see if it contains a valid TPDU_SIZE part.  If it
         *    does, we need to reset the max packet size for this socket.
         */
        if (TPDU_SIZE == pX224VarInfo->InfoType) {
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                X224_TPDU_INFO        *pX224TpduSize;
/* return to normal alignment */
#pragma pack()
            pX224TpduSize = (X224_TPDU_INFO *) CP_ptr;
            ASSERT (pX224TpduSize->InfoSize == 1);
            if (pX224TpduSize->Info != DEFAULT_TPDU_SIZE) {

                // We do not accept too small PDU sizes
                if ((pX224TpduSize->Info < LOWEST_TPDU_SIZE) && (pX224TpduSize->Info < HIGHEST_TPDU_SIZE))
                {
                  if (NULL != pNotify)
                    *pNotify = TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU;
                  return FALSE;
                }
                pSocket->Max_Packet_Length = (1 << pX224TpduSize->Info);
            }
        }
        /*
         *    Check the packet to see if it contains a valid
         *    TSELECTOR variable portion. If so, make sure it's security related
         *    and include one in the reply
         */
        else if (T_SELECTOR == pX224VarInfo->InfoType || T_SELECTOR_2 == pX224VarInfo->InfoType)
                {
                    // Try to decode
                    LPVOID pdecoding_buf = NULL;
                    UINT decoding_len = 0;
                    LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
                    if ( g_CNPCoder->Decode (pbEncoded_data,
                                             pX224VarInfo->InfoSize,
                                             CNPPDU_PDU, PACKED_ENCODING_RULES,
                                             (LPVOID *) &pdecoding_buf, &decoding_len))
                    {
                        bSecurityInfoFound = TRUE;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    CNPPDU        *pCnp_pdu;
/* return to normal alignment */
#pragma pack()
                        pCnp_pdu = (CNPPDU *) pdecoding_buf;
                        if (pSocket->Read_State == CONNECTION_REQUEST) {
                            TRACE_OUT(("CR packet using TSELECTOR extension"));
                            pSocket->fExtendedX224 = TRUE;
                            if (pCnp_pdu->u.connectRequest.bit_mask & reliableSecurityProtocols_present)
                            {
                                PConnectRequestPDU_reliableSecurityProtocols pRSP = pCnp_pdu->u.connectRequest.reliableSecurityProtocols;
                                if (gssApiX224_chosen == pRSP->value.choice)
                                {
                                    pSocket->fIncomingSecure = TRUE;
                                }
                            }
                        }
                        else {
                            ASSERT (pSocket->Read_State == CONNECTION_CONFIRM);
                            if ((NULL != pSC) && (pSC->ContinueNeeded())) {
                                ConnectConfirmPDU *pCnpCc = &pCnp_pdu->u.connectConfirm;
                                if ((pCnpCc->bit_mask & ConnectConfirmPDU_reliableSecurityProtocol_present )
                                    && gssApiX224_chosen == pCnpCc->reliableSecurityProtocol.choice)
                                {
                                    // Everything is OK, we got an extended X224 response
                                    // to our secure CR.
                                    ContinueAuthentication(pSocket);
                                }
                                else {
                                    WARNING_OUT(("No-support response to secure call attempt"));
                                    if (NULL != pNotify)
                                        *pNotify = TPRT_NOTIFY_REMOTE_NO_SECURITY;
                                    return FALSE;
                                }
                            }
                        }
                    }
                    g_CNPCoder->FreeDecoded(CNPPDU_PDU, pdecoding_buf);
        }
        else {
            ERROR_OUT (("ProcessX224ConnectPDU: Received X.224 Connect packet with unrecognizable parts."));
        }

        // Adjust the pointer and length and the X.224 CR packet.
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        //x5:223196 - fix AV when invalid PDU is processed
        if(CP_length < length)
        {
            CP_length = 0;
            *pNotify = TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU;
            break;
        }
        CP_ptr += length;
        CP_length -= length;
    }

    if (bSecurityInfoFound == FALSE) {
        if ((pSocket->Read_State == CONNECTION_CONFIRM) && (pSC != NULL) && pSC->ContinueNeeded()) {
            WARNING_OUT(("Downlevel response to secure call attempt"));
            if (NULL != pNotify)
              *pNotify = TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY;
            return FALSE;
        }
    }

    return TRUE;
}

void ProcessX224DisconnectPDU(PSocket pSocket, PUChar CP_ptr, UINT CP_length, ULONG *pNotify)
{
    UChar                length;
    BOOL                bSecurityInfoFound = FALSE;
    PSecurityContext     pSC = pSocket->pSC;

    /* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_VARIABLE_INFO        *pX224VarInfo;
    /* return to normal alignment */
#pragma pack()

    while (CP_length > 0) {
        pX224VarInfo = (X224_VARIABLE_INFO *) CP_ptr;
        if ( 0xe0 == pX224VarInfo->InfoType) {
            LPVOID pdecoding_buf = NULL;
            UINT decoding_len = 0;
            LPBYTE pbEncoded_data = CP_ptr + sizeof(X224_VARIABLE_INFO);
            if ( g_CNPCoder->Decode (pbEncoded_data,
                                     pX224VarInfo->InfoSize,
                                     CNPPDU_PDU, PACKED_ENCODING_RULES,
                                     (LPVOID *) &pdecoding_buf, &decoding_len))
            {
#pragma pack(1)
                CNPPDU        *pCnp_pdu;
                /* return to normal alignment */
#pragma pack()
                pCnp_pdu = (CNPPDU *) pdecoding_buf;
                if (disconnectRequest_chosen == pCnp_pdu->choice)
                {
                    switch (pCnp_pdu->u.disconnectRequest.disconnectReason.choice)
                    {
                    case securityDenied_chosen:
                        *pNotify = TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY;
                        break;
                    default:
                        *pNotify = TPRT_NOTIFY_OTHER_REASON;
                        break;
                    }
                }
            }
            g_CNPCoder->FreeDecoded(decoding_len, pdecoding_buf);
        }
        length = pX224VarInfo->InfoSize + sizeof(X224_VARIABLE_INFO);
        CP_ptr += length;
        //x5:223196 - fix AV when invalid PDU is processed
        if(CP_length < length)
        {
            CP_length = 0;
            *pNotify = TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU;
            break;
        }
        CP_length -= length;
    }
}


/*
 *    void DisconnectRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function closes the socket and deletes its connection node.
 */
void DisconnectRequest (TransportConnection    XprtConn,
                        ULONG            ulNotify)
{
    PSocket    pSocket;

    TRACE_OUT(("DisconnectRequest"));

    /* If the transport connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn, TRUE)))
    {
        // LONCHANC: cannot do Remove in the above line because PurgeRequest() uses it again.
        ::PurgeRequest(XprtConn);

        // SendStatusMessage (pSocket -> Remote_Address, TSTATE_NOT_CONNECTED, IDS_NULL_STRING);
        if (IS_PLUGGABLE_PSTN(XprtConn))
        {
            CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
            if (NULL != p)
            {
                p->TDisconnectRequest();
            }
        }

        /* Free the structures and close the socket */
        TransportConnection XprtConn2 = XprtConn;
        if (IS_SOCKET(XprtConn2))
        {
            XprtConn2.nLogicalHandle = INVALID_SOCKET;
        }
        ::freeSocket(pSocket, XprtConn2);

        // Free up QoS resources if this disconnect was the
        // last connected socket.
        MaybeReleaseQoSResources();

        // Notify the user
        if (TPRT_NOTIFY_NONE != ulNotify && g_Transport)
        {
            TRACE_OUT (("TCP Callback: g_Transport->DisconnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

            /* We issue a callback to the user to notify him of the message */
            g_Transport->DisconnectIndication(XprtConn, ulNotify);
        }
    }
    else
    {
        WARNING_OUT(("DisconnectRequest: logical handle (%d, %d) not found",
                XprtConn.eType, XprtConn.nLogicalHandle));
    }

    ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTED);
}

typedef enum {
    RECVRET_CONTINUE = 0,
    RECVRET_NON_FATAL_ERROR,
    RECVRET_DISCONNECT,
    RECVRET_NO_PLUGGABLE_CONNECTION,
} RecvReturn;

/* RecvReturn        Call_recv (PSocket pSocket)
 *
 * Functional Description:
 *        This function calls recv once and checks for errors coming from the
 *        recv call.  It knows about the socket's state from the "pSocket" argument
 *        and uses this info to create the arguments for the recv call.
 *
 * Return value:
 *        Continue, if everything went ok and we have new data
 *        Non_Fatal_Error, if no real error has happenned, but we did not recv all data we asked for
 *        Disconnect, if a real error has occurred, or the other side has disconnected.
 */
RecvReturn Call_recv (PSocket pSocket)
{
    PUChar        buffer;
    int            length;
    int            bytes_received;
    BOOL        bAllocationOK;
    RecvReturn    rrCode = RECVRET_NON_FATAL_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("Call_recv"));

    if (READ_HEADER != pSocket->Read_State)
    {
        // Verify packet size is within acceptable limits (64K)
        ASSERT((0 < pSocket->X224_Length) && (pSocket->X224_Length <= 65536));
        if((pSocket->X224_Length <= 0) || (65536 < pSocket->X224_Length))
        {
            rrCode = RECVRET_DISCONNECT;
            goto ExitLabel;
        }

        // Compute how much data we have to read from this X.224 pkt.
        length = pSocket->X224_Length - sizeof(X224_DATA_PACKET);

        // Space allocation
        if (! pSocket->bSpaceAllocated)
        {
            // We need to allocate the space for the recv call.
            if (NULL == pSocket->Data_Indication_Buffer)
            {
                DBG_SAVE_FILE_LINE
                pSocket->Data_Memory = AllocateMemory (
                                NULL, pSocket->X224_Length,
                                ((READ_DATA == pSocket->Read_State) ?
                                RECV_PRIORITY : HIGHEST_PRIORITY));
                // Leave space for the X.224 header in the newly allocated data buffer
                pSocket->Data_Indication_Length = sizeof (X224_DATA_PACKET);
                bAllocationOK = (pSocket->Data_Memory != NULL);
            }
            else
            {
                // This is an MCS PDU broken up in many X.224 packets.
                ASSERT (READ_DATA == pSocket->Read_State);
                bAllocationOK = ReAllocateMemory (&(pSocket->Data_Memory), length);
            }

            // Check whether the allocations were successful.
            if (bAllocationOK)
            {
                pSocket->bSpaceAllocated = TRUE;
                pSocket->Data_Indication_Buffer = pSocket->Data_Memory->GetPointer();
                /*
                 *    If this is an X.224 CONNECT_REQUEST or CONNECT_CONFIRM packet,
                 *    we need to copy the first 7 bytes into the buffer for the whole
                 *    packet.
                 */
                if (READ_DATA != pSocket->Read_State)
                {
                    memcpy ((void *) pSocket->Data_Indication_Buffer,
                            (void *) &(pSocket->X224_Header),
                            sizeof(X224_DATA_PACKET));
                }
            }
            else
            {
                /*
                 *    We will retry the operation later.
                 */
                WARNING_OUT (("Call_recv: Buffer allocation failed."));
                g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
                goto ExitLabel;
            }
        }
        buffer = pSocket->Data_Indication_Buffer + pSocket->Data_Indication_Length;
    }
    else
    {
        buffer = (PUChar) &(pSocket->X224_Header);
        length = sizeof(X224_DATA_PACKET);
    }

    // Adjust "buffer" and "length" for data already read from the current X.224 pkt.
    buffer += pSocket->Current_Length;
    length -= pSocket->Current_Length;

    ASSERT (length > 0);

    if (IS_SOCKET(pSocket->XprtConn))
    {
        // Issue the recv call.
        bytes_received = recv (pSocket->XprtConn.nLogicalHandle, (char *) buffer, length, 0);
    }
    else
    {
        bytes_received = ::X224Recv(pSocket, buffer, length, &plug_rc);
    }

    if (bytes_received == length)
    {
        TRACE_OUT (("Call_recv: Received %d bytes on socket (%d, %d).", bytes_received,
                            pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We have received the whole X.224 packet.
        if (READ_HEADER != pSocket->Read_State)
        {
            pSocket->Data_Indication_Length += pSocket->X224_Length - sizeof(X224_DATA_PACKET);
        }
        // Reset the current length variable for the next Call_recv().
        pSocket->Current_Length = 0;
        rrCode = RECVRET_CONTINUE;
    }
    // Handle errors
    else
    if (bytes_received == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            if(WSAGetLastError() == WSAEWOULDBLOCK)
            {
                TRACE_OUT(("Call_recv: recv blocked on socket (%d, %d).",
                        pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
        else
        {
            if (PLUGXPRT_RESULT_SUCCESSFUL == plug_rc)
            {
                // do nothing, treat it as WSAEWOULDBLOCK
            }
            else
            {
                 /* If the error is not WOULD BLOCK, we have a real error. */
                WARNING_OUT (("Call_recv: Error %d on recv. Socket: (%d, %d). Disconnecting...",
                            WSAGetLastError(), pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
                rrCode = RECVRET_DISCONNECT;
            }
        }
    }
    else
    if (bytes_received > 0)
    {
        TRACE_OUT(("Call_recv: Received %d bytes out of %d bytes requested on socket (%d, %d).",
                    bytes_received, length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        // We received only part of what we wanted.  We retry later.
        pSocket->Current_Length += bytes_received;
    }
    else
    {
        WARNING_OUT(("Call_recv: Socket (%d, %d) has been gracefully closed.",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        rrCode = RECVRET_DISCONNECT;
    }

ExitLabel:
    return rrCode;
}


int X224Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    TRACE_OUT(("X224Recv"));

    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        return ::SubmitPluggableRead(pSocket, buffer, length, plug_rc);
    }

    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        return Q922Recv(pSocket, buffer, length, plug_rc);
    }

    ERROR_OUT(("X224Recv: invalid plugable type (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


int Q922Recv(PSocket pSocket, LPBYTE buffer, int length, PLUGXPRT_RESULT *plug_rc)
{
    ERROR_OUT(("Q922Recv: NYI (%d, %d)",
                pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
    return SOCKET_ERROR;
}


typedef enum {
    FreeX224AndExit,
    ErrorExit,
    ImmediateExit
} ExitWay;


/*
 *    void    ReadRequest ( TransportConnection )
 *
 *    Functional Description:
 *        This function will attempt to read and process a full X.224 packet.
 *        However, it may only be able to read part of a packet or fail to
 *        process it at this time.  In this case, it must keep enough state
 *        info for the next entrance into this function, to be able to handle
 *        the partly-received or unprocessed X.224 packet.
 */
void ReadRequest (TransportConnection XprtConn)
{
    PSocket                pSocket;
    ExitWay                ew = ImmediateExit;
    RecvReturn            rrCode;
    ULONG               ulNotify = TPRT_NOTIFY_OTHER_REASON;

    TRACE_OUT(("ReadRequest"));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        ERROR_OUT(("ReadRequest: PSTN should not be here"));
        return;
    }

    /* If the transport connection handle is not registered, return */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        if (pSocket->State != WAITING_FOR_CONNECTION)
        {
            PSecurityContext     pSC = pSocket->pSC;
            /*
             *    If we haven't read the header of the incoming packet yet,
             *    we need to read it into the header space
             */
            if (READ_HEADER == pSocket->Read_State)
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We need to allocate the space for the rest of the X.224 packet.
                    pSocket->bSpaceAllocated = FALSE;

                    // Find the length of the X.224 packet.
                    pSocket->X224_Length = (pSocket->X224_Header.rfc.msbPacketSize << 8) +
                                            pSocket->X224_Header.rfc.lsbPacketSize;
                    /*
                     *    We have the whole X.224 header. Compute the next state,
                     *    based on the packet type.
                     */
                    switch (pSocket->X224_Header.PacketType)
                    {
                    case DATA_PACKET:
                        pSocket->Read_State = READ_DATA;
                        break;

                    case CONNECTION_CONFIRM_PACKET:
                        if (pSocket->State != X224_CONNECTED)
                        {
                            pSocket->Read_State = CONNECTION_CONFIRM;
                        }
                        else
                        {
                            ERROR_OUT (("ReadRequest: Received X.224 CONNECTION_CONFIRM packet while already connected!! Socket: (%d, %d).",
                                        XprtConn.eType, XprtConn.nLogicalHandle));
                            ew = ErrorExit;
                        }
                        break;

                    case CONNECTION_REQUEST_PACKET:
                        // we just received a X224 Connect request
                        pSocket->Read_State = CONNECTION_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTING);
                        break;

                    case DISCONNECT_REQUEST_PACKET:
                        // we just received a X224 Disconnect request
                        pSocket->Read_State = DISCONNECT_REQUEST;
                        ::OnProtocolControl(XprtConn, PLUGXPRT_DISCONNECTING);
                        break;

                    default:
                        // We have lost sync with the remote side.
                        ERROR_OUT (("ReadRequest: Bad X.224 packet on socket (%d, %d). Disconnecting...", XprtConn.eType, XprtConn.nLogicalHandle));
                        ew = ErrorExit;
                        break;
                    }
                }
                else
                if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if ((READ_DATA <= pSocket->Read_State) &&
                (CONNECTION_REQUEST >= pSocket->Read_State))
            {
                rrCode = Call_recv (pSocket);
                if (RECVRET_CONTINUE == rrCode)
                {
                    // We now have the whole X.224 packet.

                    switch (pSocket->Read_State)
                    {
                    case READ_DATA:
                        // Check whether this is the final X.224 packet
                        if (pSocket->X224_Header.FinalPacket & EOT_BIT)
                        {
                            // If we're waiting for a security data packet we will process
                            // this internally without passing it up to the transport
                            // client.
                            if (NULL != pSC)
                            {
                                if (pSC->WaitingForPacket())
                                {
                                    TransportSecurityError SecErr;

                                    SecErr = pSC->AdvanceState((PBYTE) pSocket->Data_Indication_Buffer +
                                                            sizeof(X224_DATA_PACKET),
                                                        pSocket->Data_Indication_Length -
                                                            sizeof(X224_DATA_PACKET));

                                    if (TPRTSEC_NOERROR != SecErr)
                                    {
                                        // Something has gone wrong. Need to disconnect
                                        delete pSC;
                                        pSocket->pSC = NULL;
                                        ulNotify = TPRT_NOTIFY_AUTHENTICATION_FAILED;
                                        ew = ErrorExit;
                                        break;
                                    }

                                    if (pSC->ContinueNeeded())
                                    {
                                        // We need to send out another token
                                        // bugbug: what should we do if this fails?
                                        ContinueAuthentication(pSocket);
                                    }

                                    if (pSC->StateComplete())
                                    {
                                        // We're connected... inform the client
                                        TRACE_OUT(("deferred g_Transport->ConnectConfirm"));
                                        g_Transport->ConnectConfirm(XprtConn);
                                    }
                                    ew = FreeX224AndExit;
                                    break;
                                }

                                // We must decrypt the data (in place)
                                TRACE_OUT(("Decrypting received data"));

                                if (! pSC->Decrypt(pSocket->Data_Indication_Buffer +
                                                        sizeof(X224_DATA_PACKET),
                                                    pSocket->Data_Indication_Length -
                                                        sizeof(X224_DATA_PACKET)))
                                {
                                    TRACE_OUT(("Sending %d bytes to application",
                                                pSocket->Data_Indication_Length - sizeof(X224_DATA_PACKET)));
                                }
                                else
                                {
                                    ERROR_OUT(("Error decrypting packet"));
                                    ew = ErrorExit;
                                    break;
                                }
                            }
                            pSocket->Read_State = DATA_READY;
                        }
                        else
                        {
                            // This and the next X.224 packets are part of a bigger MCS data PDU.
                            ASSERT (NULL == pSC);
                            pSocket->Read_State = READ_HEADER;
                        }
                        break;

                    case CONNECTION_CONFIRM:
                        {
                            TRACE_OUT(("ReadRequest: X224 CONNECTION_CONFIRM_PACKET received"));
                                BOOL    bCallback = ((NULL == pSC) || (! pSC->ContinueNeeded()));

                            // Process the CC packet.
                            if (FALSE == ProcessX224ConnectPDU (pSocket,
                                                pSocket->Data_Indication_Buffer + sizeof(X224_CONNECT),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            // Issue the callback if the CC was not on a secure connection
                            // Otherwise, we don't notify the transport client yet... still need to
                            // exchange security information. TRANSPORT_CONNECT_CONFIRM will
                            // be sent when the final security data token is received and
                            // processed.
                            if (bCallback)
                            {
                                TRACE_OUT (("TCP Callback: g_Transport->ConnectConfirm (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                                /* We issue a callback to the user to notify him of the message */
                                g_Transport->ConnectConfirm(XprtConn);
                            }
                            pSocket->State = X224_CONNECTED;
                            ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                            ew = FreeX224AndExit;
                        }
                        break;

                    case CONNECTION_REQUEST:
                        {
                                UINT             remote;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
                                X224_CONNECT        *pConnectRequest;
/* return to normal alignment */
#pragma pack()
                            /* Grab the remote connection ID */
                            TRACE_OUT (("ReadRequest: X224 CONNECTION_REQUEST_PACKET received"));
                            pConnectRequest = (X224_CONNECT *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pConnectRequest->conn.msbSrc) << 8;
                            remote |= pConnectRequest->conn.lsbSrc;

                            if (FALSE == ProcessX224ConnectPDU (pSocket, (PUChar) (pConnectRequest + 1),
                                                pSocket->X224_Length - sizeof (X224_CONNECT), &ulNotify))
                            {
                                ew = ErrorExit;
                                break;
                            }

                            if (::SendX224ConnectConfirm(pSocket, remote))
                            {
                                // success
                                if (IS_PLUGGABLE(pSocket->XprtConn))
                                {
                                    pSocket->State = SOCKET_CONNECTED;
                                    g_Transport->ConnectIndication(XprtConn);
                                    ASSERT(X224_CONNECTED == pSocket->State);
                                }
                                ::OnProtocolControl(XprtConn, PLUGXPRT_CONNECTED);
                                ew = FreeX224AndExit;
                            }
                            else
                            {
                                if (pSocket->fExtendedX224)
                                {
                                    ::SendX224DisconnectRequest(pSocket, remote, securityDenied_chosen);
                                }
                                ew = ErrorExit;
                            }
                        }
                        break;

                    case DISCONNECT_REQUEST:
                        {
                            UINT               remote;
                            X224_DR_FIXED      *pX224_DR_fixed;

                            TRACE_OUT(("ReadRequest: X224 DISCONNECT_REQUEST_PACKET received"));
                            pX224_DR_fixed = (X224_DR_FIXED *) pSocket->Data_Indication_Buffer;
                            remote = ((unsigned int) pX224_DR_fixed->disconn.msbSrc) << 8;
                            remote |= pX224_DR_fixed->disconn.lsbSrc;

                            ProcessX224DisconnectPDU(pSocket, pSocket->Data_Indication_Buffer + sizeof(X224_DR_FIXED),
                                                     pSocket->X224_Length - sizeof(X224_DR_FIXED), &ulNotify);
                            ew = ErrorExit;
                        }
                        break;
                    }
                }
                else if (RECVRET_DISCONNECT == rrCode)
                {
                    ew = ErrorExit;
                }
            }

            if (DATA_READY == pSocket->Read_State)
            {
                TransportData        transport_data;

                // Fill in the callback structure.
                transport_data.transport_connection = XprtConn;
                transport_data.user_data = pSocket->Data_Indication_Buffer;
                transport_data.user_data_length = pSocket->Data_Indication_Length;
                transport_data.memory = pSocket->Data_Memory;

                /*
                 *    If there is an incoming security context associated with this
                 *  socket, we must adjust pointer by header and overall size by header and
                 *    trailer.
                 */
                if (NULL != pSC)
                {
                    transport_data.user_data += pSC->GetStreamHeaderSize();
                    transport_data.user_data_length -= (pSC->GetStreamHeaderSize() +
                                                        pSC->GetStreamTrailerSize());
                }

                if (TRANSPORT_NO_ERROR == g_Transport->DataIndication(&transport_data))
                {
                    TRACE_OUT (("ReadRequest: %d bytes were accepted from socket (%d, %d)",
                                transport_data.user_data_length, XprtConn.eType, XprtConn.nLogicalHandle));
                    // Prepare for the next X.224 packet
                    pSocket->Read_State = READ_HEADER;
                    pSocket->Data_Indication_Buffer = NULL;
                    pSocket->Data_Memory = NULL;
                }
                else
                {
                    WARNING_OUT(("ReadRequest: Error on g_Transport->DataIndication from socket (%d, %d)",
                                XprtConn.eType, XprtConn.nLogicalHandle));
                }
            }
        }
        else
        {
            WARNING_OUT (("ReadRequest: socket (%d, %d) is in WAITING_FOR_CONNECTION state.", XprtConn.eType, XprtConn.nLogicalHandle));
        }
    }
    else
    {
        WARNING_OUT (("ReadRequest: socket (%d, %d) can not be found.", XprtConn.eType, XprtConn.nLogicalHandle));
    }

    switch (ew)
    {
    case FreeX224AndExit:
        if (NULL != pSocket)
        {
            // Free the buffers we have allocated.
            pSocket->FreeTransportBuffer();
            // Prepare for the next X.224 packet
            pSocket->Read_State = READ_HEADER;
        }
        break;

    case ErrorExit:
        // We get here only if we need to disconnect the socket (because of an error)
        ASSERT(TPRT_NOTIFY_NONE != ulNotify);
        ::DisconnectRequest(XprtConn, ulNotify);
        break;
    }

    if (NULL != pSocket)
    {
        pSocket->Release(); // offset the previous AddRef.
    }
}


/*
 *    TransportError    FlushSendBuffer ( PSocket pSocket )
 *
 *    Functional Description:
 *        This function sends any pending data through the transport.
 */
TransportError    FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length)
{
    int     bytes_sent = SOCKET_ERROR;
    PLUGXPRT_RESULT plug_rc = PLUGXPRT_RESULT_SUCCESSFUL;

    TRACE_OUT(("FlushSendBuffer"));

    /* send the data */
    if (IS_SOCKET(pSocket->XprtConn))
    {
        bytes_sent = ::send(pSocket->XprtConn.nLogicalHandle, (PChar) buffer,
                            (int) length, 0);
    }
    else
    if (IS_PLUGGABLE_X224(pSocket->XprtConn))
    {
        bytes_sent = ::SubmitPluggableWrite(pSocket, buffer, length, &plug_rc);
    }
    else
    if (IS_PLUGGABLE_PSTN(pSocket->XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(pSocket);
        if (NULL != p)
        {
            bytes_sent = p->TDataRequest(buffer, length, &plug_rc);
        }
        else
        {
            plug_rc = PLUGXPRT_RESULT_WRITE_FAILED;
        }
    }

    if (bytes_sent == SOCKET_ERROR)
    {
        if (IS_SOCKET(pSocket->XprtConn))
        {
            /* If the error is not WOULD BLOCK, it is a real error! */
            if (::WSAGetLastError() != WSAEWOULDBLOCK)
            {
                WARNING_OUT (("FlushSendBuffer: Error %d on write", ::WSAGetLastError()));

                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }
        else
        {
            // do nothing if it is WSAEWOULDBLOCK
            if (PLUGXPRT_RESULT_SUCCESSFUL != plug_rc)
            {
                 /* Notify the owner of the broken connection */
                WARNING_OUT (("FlushSendBuffer: Sending up DISCONNECT_INDICATION"));
                // SendStatusMessage (pSocket -> Remote_Address,  TSTATE_REMOVED, IDS_NULL_STRING);
                ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                return (TRANSPORT_WRITE_QUEUE_FULL);
            }
        }

        bytes_sent = 0;
    }

     /* If the transport layer did not accept the data, its write buffers are full */
    if (bytes_sent != (int) length)
    {
        ASSERT (bytes_sent == 0);
        TRACE_OUT(("FlushSendBuffer: returning TRANSPORT_WRITE_QUEUE_FULL"));
        return (TRANSPORT_WRITE_QUEUE_FULL);
    }

    // Increment our counter of bytes sent since last QoS notification
    if (bytes_sent)
    {
           QoSLock();
           g_dwSentSinceLastQoS += bytes_sent;
           QoSUnlock();
    }

    TRACE_OUT (("FlushSendBuffer: %d bytes sent on Socket (%d, %d).",
                length, pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));

    return (TRANSPORT_NO_ERROR);
}



/*
 *    SegmentX224Data
 *
 *    This function segments outgoing data into X.224 packets of the appropriate size.
 *    It should not be called in a NM to NM call or in a call when we have negotiated an
 *    X.224 max PDU size of at least the size of a max MCS PDU.  NM attempts to negotiate
 *    X.224 sizes of 8K, but will accept anything the other side proposes.
 *    This function does memcpy's so it will slow us down sending data.
 *
 *    The 2 buffers specified by "ptr1" and "ptr2" and their lengths are used to create
 *    one stream of X.224 bytes.  The function will return TRANSPORT_WRITE_QUEUE_FULL if
 *    it fails to allocate the necessary amount of memory.
 */
TransportError SegmentX224Data (PSocket pSocket,
                                LPBYTE *pPtr1,     UINT *pLength1,
                                LPBYTE Ptr2,     UINT Length2)
{
    TransportError        TransError;
    UINT                length;
    LPBYTE                ptr1 = *pPtr1 + sizeof (X224_DATA_PACKET);
    UINT                length1 = *pLength1 - sizeof (X224_DATA_PACKET);
    LPBYTE                ptr;
    UINT                max_pdu_length = pSocket->Max_Packet_Length;
    X224_DATA_PACKET    l_X224Header = {3, 0, (UChar) (max_pdu_length >> 8), (UChar) (max_pdu_length & 0xFF),
                                        2, DATA_PACKET, 0};
    UINT                last_length;
/* This structure must be accessed using byte-alignment */
#pragma pack(1)
    X224_DATA_PACKET    *pX224Data;
/* return to normal alignment */
#pragma pack()


    ASSERT(! IS_PLUGGABLE_PSTN(pSocket->XprtConn));

    // Calculate how much space we need.
    length = *pLength1 + Length2;
    ASSERT (pSocket->Max_Packet_Length < length);
    ASSERT (pSocket->Max_Packet_Length > sizeof(X224_DATA_PACKET));

    max_pdu_length -= sizeof (X224_DATA_PACKET);
    /*
     *    Calculate the space we need to allocate.  Notice that the data already
     *    contains one X.224 header.
     */
    length += (length / max_pdu_length) * sizeof (X224_DATA_PACKET);
    *pPtr1 = Allocate (length);

    if (*pPtr1 != NULL) {
        TransError = TRANSPORT_NO_ERROR;
        ptr = *pPtr1;

        // Go through the 1st buffer.
        while (length1 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > length1) ? length1 : max_pdu_length);
            memcpy (ptr, ptr1, length);
            last_length = length;

            // Advance pointers
            ptr1 += length;
            ptr += length;
            length1 -= length;
        }

        // If there is space in the current X.224 PDU, we need to use it.
        length = max_pdu_length - length;
        if (length > 0 && Length2 > 0) {
            if (length > Length2)
                length = Length2;
            memcpy (ptr, Ptr2, length);
            last_length += length;
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Go through the 2nd buffer.
        while (Length2 > 0) {
            // Copy the X.224 header.
            memcpy (ptr, &l_X224Header, sizeof(X224_DATA_PACKET));
            pX224Data = (X224_DATA_PACKET *) ptr;
            ptr += sizeof (X224_DATA_PACKET);

            // Copy data
            length = ((max_pdu_length > Length2) ? Length2 : max_pdu_length);
            memcpy (ptr, Ptr2, length);
            last_length = length;

            // Advance pointers
            Ptr2 += length;
            ptr += length;
            Length2 -= length;
        }

        // Prepare for return
        *pLength1 = (UINT)(ptr - *pPtr1);

        // Set the last X.224 header
        last_length += sizeof(X224_DATA_PACKET);
        pX224Data->FinalPacket = EOT_BIT;
        pX224Data->rfc.msbPacketSize = (UChar) (last_length >> 8);
        pX224Data->rfc.lsbPacketSize = (UChar) (last_length & 0xFF);
    }
    else {
        ERROR_OUT (("SegmentX224Data: Failed to allocate memory of length %d.", length));
        TransError = TRANSPORT_WRITE_QUEUE_FULL;
    }

    return TransError;
}

/*
 *    SendSecureData
 *
 *    This function segments secure data into X.224 packets, if needed, and flushes them through
 *    the transport.  "pBuf" and "cbBuf" provide the encrypted data buffer and length.
 */
TransportError SendSecureData (PSocket pSocket, LPBYTE pBuf, UINT cbBuf)
{
    TransportError        TransError;
    LPBYTE                pBuf_Copy = pBuf;
    UINT                cbBuf_Copy = cbBuf;

    // Do we need to segment the data into X.224 packets?
    if (pSocket->Max_Packet_Length >= cbBuf) {
        TransError = TRANSPORT_NO_ERROR;
    }
    else {
        TransError = SegmentX224Data (pSocket, &pBuf, &cbBuf, NULL, 0);
    }

    // Flush the data, if everything OK so far.
    if (TRANSPORT_NO_ERROR == TransError)
        TransError = FlushSendBuffer (pSocket, pBuf, cbBuf);

    // If we segmented the data, we need to free the segmented buffer.
    if (pBuf != pBuf_Copy)
        Free(pBuf);

    // If there are errors, we need to store the decrypted data for the next time, so don't free it.
    if (TRANSPORT_NO_ERROR == TransError) {
        LocalFree(pBuf_Copy);
    }

    return TransError;
}

/*
 *    TransportError    DataRequest (    TransportConnection    XprtConn,
 *                                    PSimplePacket    packet)
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 *        If the user_data_length is zero, and we have no pending data,
 *        it sends a keep-alive (zero-length) packet.
 */
TransportError    DataRequest (TransportConnection    XprtConn,
                            PSimplePacket    packet)
{
    PSocket            pSocket;
    LPBYTE            ptr1, ptr2;
    UINT            length1, length2;
    TransportError    TransError = TRANSPORT_NO_ERROR;

    TRACE_OUT(("DataRequest: packet=0x%x", packet));

    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        // First, we need to handle the retry operations.
        if (NULL != pSocket->pSC) {
                LPBYTE lpBuf;
            /*
             *    Check to see whether we have already encrypted, but not sent
             *    the last piece of data.
             */
            lpBuf = pSocket->Retry_Info.sbiBufferInfo.lpBuffer;
            if (NULL != lpBuf) {
                TransError = SendSecureData (pSocket, lpBuf,
                                            pSocket->Retry_Info.sbiBufferInfo.uiLength);

                if (TransError == TRANSPORT_NO_ERROR) {
                    TRACE_OUT(("DataRequest: Sent previously-encrypted piece of data."));
                    pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
                }
            }
        }
        else {
                PDataPacket        pdpPacket = pSocket->Retry_Info.pUnfinishedPacket;

            // Check to see whether we have half-sent the last packet.
            if (NULL  != pdpPacket) {
                /*
                 *    We need to send the rest of the unfinished packet,
                 *    before we can go on.  The 1st part of the packet
                 *    must have already been sent.
                 */
                // The packet's encoded data must be in 2 buffers.
                ASSERT (TRUE == pdpPacket->IsEncodedDataBroken());

                TransError = FlushSendBuffer (pSocket, pdpPacket->GetUserData(),
                                            pdpPacket->GetUserDataLength());
                if (TransError == TRANSPORT_NO_ERROR) {
                    pdpPacket->Unlock();
                    TRACE_OUT(("DataRequest: 2nd part of data packet was sent out in separate request"));
                    pSocket->Retry_Info.pUnfinishedPacket = NULL;
                }
            }
        }

        if ((TransError == TRANSPORT_NO_ERROR) && (packet != NULL)) {

            // Now, let's try to send this new packet.
            ptr1 = packet->GetEncodedData();
            length1 = packet->GetEncodedDataLength();

            /*
             *    We need to find out whether the packet to send is a
             *    DataPacket or a Packet object.  If it's a DataPacket, the
             *    encoded data may not be contiguous (may be broken in 2 parts)
             */
            if ((packet->IsDataPacket()) &&
                ((PDataPacket) packet)->IsEncodedDataBroken()) {
                // the data to send is broken into 2 parts.
                ptr2 = ((PDataPacket) packet)->GetUserData();
                length2 = ((PDataPacket) packet)->GetUserDataLength();
            }
            else {
                // the data to send is contiguous.
                ptr2 = NULL;
                length2 = 0;
            }

            if (NULL != pSocket->pSC) {
                    LPBYTE     pBuf;
                    UINT     cbBuf;

                TRACE_OUT(("Encrypting %d bytes of outgoing data",
                            (length1 + length2) - sizeof(X224_DATA_PACKET)));

                if (!pSocket->pSC->Encrypt(ptr1 + sizeof(X224_DATA_PACKET),
                                            length1 - sizeof(X224_DATA_PACKET),
                                            ptr2, length2, &pBuf, &cbBuf))
                {

                    ASSERT (TransError == TRANSPORT_NO_ERROR);

                    TransError = SendSecureData (pSocket, pBuf, cbBuf);
                    if (TRANSPORT_NO_ERROR != TransError) {
                        TRACE_OUT(("DataRequest: Failed to send encrypted data. Keeping buffer for retry."));
                        pSocket->Retry_Info.sbiBufferInfo.lpBuffer = pBuf;
                        pSocket->Retry_Info.sbiBufferInfo.uiLength = cbBuf;
                        // The caller needs to remove the packet from its queue.
                        TransError = TRANSPORT_NO_ERROR;
                    }
                }
                else
                {
                    WARNING_OUT (("DataRequest: Encryption failed. Disconnecting..."));
                    ::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
                    TransError = TRANSPORT_MEMORY_FAILURE;
                }
            }
            else {
                BOOL        bNeedToFree = FALSE;
                // Do we need to segment the data into X.224 packets?
                if (pSocket->Max_Packet_Length >= length1 + length2)
                    ;
                else {
                    TransError = SegmentX224Data (pSocket, &ptr1, &length1, ptr2, length2);
                    if (TRANSPORT_NO_ERROR == TransError) {
                        // The data is now contiguous
                        ptr2 = NULL;
                        bNeedToFree = TRUE;
                    }
                }

                // Flush the data, if everything OK so far.
                if (TRANSPORT_NO_ERROR == TransError)
                    TransError = FlushSendBuffer (pSocket, ptr1, length1);

                // Free the temporary X.224 buffer if we need to.
                if (bNeedToFree)
                    Free(ptr1);

                if (TRANSPORT_NO_ERROR == TransError) {
                    // If there is more, send it, too.
                    if (NULL != ptr2) {
                        TransError = FlushSendBuffer (pSocket, ptr2, length2);
                        if (TRANSPORT_NO_ERROR != TransError) {
                            /*
                             *    We need to keep the partial packet to send it later.
                             *    Notice we have already sent a part of this packet.
                             */
                            ASSERT (pSocket->Retry_Info.pUnfinishedPacket == NULL);
                            pSocket->Retry_Info.pUnfinishedPacket = (PDataPacket) packet;
                            packet->Lock();

                            // Return success.
                            TransError = TRANSPORT_NO_ERROR;
                        }
                    }
                }
            }
        }

        pSocket->Release();
    }
    else {
        TransError = TRANSPORT_NO_SUCH_CONNECTION;
        WARNING_OUT (("DataRequest: Attempt to send to unknown transport connection (%d, %d)",
                    XprtConn.eType, XprtConn.nLogicalHandle));
    }

    return TransError;
}


/*
 *    void PurgeRequest (TransportConnection    XprtConn)
 *
 *    Functional Description:
 *        This function purges the outbound packets for the given transport
 *        connection.
 */
void PurgeRequest (TransportConnection XprtConn)
{

    PSocket pSocket;

    TRACE_OUT (("In PurgeRequest for transport connection (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));

    if (IS_PLUGGABLE_PSTN(XprtConn))
    {
        CPluggableConnection *p = ::GetPluggableConnection(XprtConn.nLogicalHandle);
        if (NULL != p)
        {
            p->TPurgeRequest();
        }
    }
    else
    /* If the logical connection handle is not registered, return error */
    if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
    {
        /* Purge the pending data stored in the socket struct */
        if (NULL != pSocket->pSC) {
            if (NULL != pSocket->Retry_Info.sbiBufferInfo.lpBuffer) {
                TRACE_OUT (("PurgeRequest: Purging data packet for secure connection"));
                LocalFree (pSocket->Retry_Info.sbiBufferInfo.lpBuffer);
                pSocket->Retry_Info.sbiBufferInfo.lpBuffer = NULL;
            }
        }
        pSocket->Release();
    }
}


/*
 *    void    EnableReceiver (Void)
 *
 *    Functional Description:
 *        This function allows packets to be sent to the user application.
 */
void EnableReceiver (void)
{
    PSocket            pSocket;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

    TRACE_OUT(("EnableReceiver"));

    if (NULL != g_pLegacyTransport)
    {
        g_pLegacyTransport->TEnableReceiver();
    }

    /* Go thru all the sockets and enable receiving */
    while (NULL != (pSocket = Connection_List_Copy.Get()))
    {
        /*
         *    If we had failed to deliver a data pkt to MCS before, we need
         *    an extra ReadRequest to recv and keep the FD_READ msgs coming.
         */
        if (DATA_READY == pSocket->Read_State)
        {
            ::ReadRequest(pSocket->XprtConn);
        }

        TRACE_OUT (("EnableReceiver: Calling ReadRequestEx on socket (%d, %d)",
                    pSocket->XprtConn.eType, pSocket->XprtConn.nLogicalHandle));
        ::ReadRequestEx(pSocket->XprtConn);
    }
}


/*
 *    TransportError    ShutdownAndClose (TransportConnection , BOOL fShutdown, int how)
 *
 *    Functional Description
 *        This function shuts down the socket and closes it.
 *
 */
void ShutdownAndClose (TransportConnection XprtConn, BOOL fShutdown, int how)
{
    if (IS_SOCKET(XprtConn))
    {
        int error;

        if (fShutdown)
        {
            error = ::shutdown(XprtConn.nLogicalHandle, how);

            ASSERT(error != SOCKET_ERROR);
#ifdef DEBUG
            if(error == SOCKET_ERROR)
            {
                error = WSAGetLastError();
                WARNING_OUT (("ShutdownAndClose: shutdown returned %d", error));
            }
#endif // DEBUG
        }

        error = ::closesocket(XprtConn.nLogicalHandle);

#ifdef DEBUG
        if(error == SOCKET_ERROR)
        {
            WARNING_OUT(("ShutdownAndClose: closesocket returned %d", WSAGetLastError()));
        }
#endif // DEBUG
    }
}


/*
 *    TransportError GetLocalAddress (TransportConnection    XprtConn,
 *                                    TransportAddress    address,
 *                                    int *        size)
 *
 *    Functional Description:
 *        This function retrieves the local IP address associated with the given
 *        connection. It returns TRANSPORT_NO_SUCH_CONNECTION if the address is
 *        not available. If the address is available, the size parameter specifies
 *        the size of the address buffer on entry, and it is filled in with the size
 *        used for the address on exit.
 */
TransportError GetLocalAddress(    TransportConnection    XprtConn,
                                TransportAddress    address,
                                int *                size)
{
    SOCKADDR_IN        socket_control;
    PChar             szTemp;
    int                Length;
    TransportError    error = TRANSPORT_NO_SUCH_CONNECTION;

    if (NULL != g_pSocketList->FindByTransportConnection(XprtConn, TRUE))
    {
        if (IS_SOCKET(XprtConn))
        {
            /* Get the local name for the socket */
            Length = sizeof(socket_control);
            if (getsockname(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &Length) == 0) {
                /* Convert it to an IP address string */
                szTemp = inet_ntoa(socket_control.sin_addr);

                ASSERT (szTemp);
                Length = (int) strlen(szTemp) + 1;

                ASSERT (*size >= Length);
                ASSERT (address);

                /* Copy it to the buffer */
                lstrcpyn((PChar)address, szTemp, Length);
                *size = Length;

                error = TRANSPORT_NO_ERROR;
            }
        }
        else
        {
            ASSERT(IS_PLUGGABLE(XprtConn));

            // string should look like "xprt: 1"
            char szConnStr[T120_CONNECTION_ID_LENGTH];
            Length = ::CreateConnString((UINT)XprtConn.nLogicalHandle, szConnStr);
            if (*size > ++Length)
            {
                ::lstrcpyn(address, szConnStr, Length+1);
                *size = Length;
                error = TRANSPORT_NO_ERROR;
                TRACE_OUT (("GetLocalAddress: plugable connection local address (%s)", address));
            }
            else
            {
                ERROR_OUT(("GetLocalAddress: buffer too small, given=%d, required=%d", *size, Length));
                error = TRANSPORT_BUFFER_TOO_SMALL;
            }
        }
    }

#ifdef DEBUG
    if (error != TRANSPORT_NO_ERROR)
        WARNING_OUT (("GetLocalAddress: Failure to obtain local address (%d)", WSAGetLastError()));
#endif // DEBUG

    return (error);
}


/*
 *    void    AcceptCall (BOOL fSecure)
 *
 *    Functional Description:
 *        This function calls Winsock to answer an incoming call.
 */

void AcceptCall (TransportConnection XprtConn)
{
    PSocket            pSocket;
    PSecurityContext pSC = NULL;
    SOCKADDR_IN        socket_control;
    int                size;

    TRACE_OUT(("AcceptCall"));

    if (IS_SOCKET(XprtConn))
    {
        ASSERT(XprtConn.nLogicalHandle == Listen_Socket);
        ASSERT (Listen_Socket != INVALID_SOCKET);

        /* Call accept() to see if anyone is calling us */
        size = sizeof (socket_control);
        XprtConn.nLogicalHandle = ::accept ( Listen_Socket,
                                (struct sockaddr *) &socket_control, &size);

        /* Note that we expect accept to complete immediately */
        if (XprtConn.nLogicalHandle == INVALID_SOCKET)
        {
            ERROR_OUT (("AcceptCall: Error on accept = %d", WSAGetLastError()));
            // SendStatusMessage ("", TSTATE_NOT_READY, IDS_NULL_STRING);
            return;
        }
    }

    /* If the accept() received an incoming call, create a connection and notify our owner object. */
    pSocket = newSocket(XprtConn, NULL);
    if( pSocket == NULL )
    {
         /* Close the socket */
         ::ShutdownAndClose(XprtConn, TRUE, 2);
        return;
    }

    pSocket -> State = SOCKET_CONNECTED;

    if (IS_SOCKET(XprtConn))
    {
        /* Issue the getpeername() function to get the remote user's address */
        size = sizeof (socket_control);
        if (::getpeername(XprtConn.nLogicalHandle, (LPSOCKADDR) &socket_control, &size) == 0)
        {
            lstrcpyn (
                pSocket -> Remote_Address,
                inet_ntoa (socket_control.sin_addr),
                MAXIMUM_IP_ADDRESS_SIZE-1);
            pSocket -> Remote_Address[MAXIMUM_IP_ADDRESS_SIZE - 1] = NULL;
        }

        // SendStatusMessage(pSocket -> Remote_Address, TSTATE_CONNECTED, IDS_NULL_STRING);
    }

    /* Add to connection list */
    // bugbug: we fail to insert.
    g_pSocketList->SafeAppend(pSocket);

    /* Notify the user */
    TRACE_OUT (("TCP Callback: g_Transport->ConnectIndication (%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
    /* We issue a callback to the user to notify him of the message */
    g_Transport->ConnectIndication(XprtConn);
}


//
// ReadRequestEx() is for the plugable transport.
// Since we do not have the FD_ACCEPT notifcation, we try to make sure
// we have a valid transport connection for every read...
// The following piece of code is derived from AcceptCall().
//
void ReadRequestEx(TransportConnection XprtConn)
{
    if (! IS_PLUGGABLE_PSTN(XprtConn))
    {
        ::ReadRequest(XprtConn);
    }
}

/*
 *    LRESULT    WindowProcedure (
 *                            HWND         window_handle,
 *                            UINT        message,
 *                            WPARAM         wParam,
 *                            LPARAM        lParam)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by Windows when we dispatch a TCP message from the
 *        event loop above.  It gives us a chance to process the incoming socket messages.
 */
LRESULT    WindowProcedure (HWND         window_handle,
                         UINT        message,
                         WPARAM        wParam,
                         LPARAM        lParam)
{
    TransportConnection XprtConn;
    UShort        error;
    UShort        event;
    //PSocket        pSocket;

    switch (message)
    {
#ifndef NO_TCP_TIMER
    case WM_TIMER:
        {
             /*
             **    We are currently using a slow timer to keep reading even when
             ** FD_READ msgs get lost (this happens on Win95).
             **
             */
            if (NULL != g_Transport) {
                TRACE_OUT(("MSMCSTCP: WM_TIMER"));
                EnableReceiver ();
            }
        }
        break;
#endif    /* NO_TCP_TIMER */

    case WM_SOCKET_NOTIFICATION:
        {
            /* This message is generated by WinSock */
            event = WSAGETSELECTEVENT (lParam);
            error = WSAGETSELECTERROR (lParam);

            SET_SOCKET_CONNECTION(XprtConn, wParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT (("TCP: error %d on socket (%d). Event: %d", error, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_CLOSE when the socket is closed by the remote site. */
            if (event & FD_CLOSE)
            {
                TRACE_OUT (("TCP: FD_CLOSE(%d)", XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;
            }

            /* We get FD_READ when there is data available for us to read. */
            if (event & FD_READ)
            {
                // TRACE_OUT(("MSMCSTCP: FD_READ(%d)", (UINT) wParam));
                ::ReadRequest(XprtConn);
            }

            /* We get FD_ACCEPT when a remote site is connecting with us */
            if (event & FD_ACCEPT)
            {
                TRACE_OUT (("TCP: FD_ACCEPT(%d)", XprtConn.nLogicalHandle));

                /* Note that we always accept calls. Disconnect cancels them. */
                TransportConnection XprtConn2;
                SET_SOCKET_CONNECTION(XprtConn2, Listen_Socket);
                ::AcceptCall(XprtConn2);
            }

            /* We get FD_CONNECT when our connect completes */
            if (event & FD_CONNECT)
            {
                TRACE_OUT (("TCP: FD_CONNECT(%d)", XprtConn.nLogicalHandle));
                ::SendX224ConnectRequest(XprtConn);
            }

            /* We get FD_WRITE when there is space available to write data to WinSock */
            if (event & FD_WRITE)
            {
                /*
                 *    We need to send a BUFFER_EMPTY_INDICATION to the connection associated
                 *    with the socket
                 */
                TRACE_OUT (("TCP: FD_WRITE(%d)", XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT (("TCP: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
            }
        }
        break;

    case WM_PLUGGABLE_X224:
        // for low level read and write,
        {
            XprtConn.eType = (TransportType) PLUGXPRT_WPARAM_TO_TYPE(wParam);
            XprtConn.nLogicalHandle = PLUGXPRT_WPARAM_TO_ID(wParam);
            ASSERT(IS_PLUGGABLE(XprtConn));

            event = PLUGXPRT_LPARAM_TO_EVENT(lParam);
            error = PLUGXPRT_LPARAM_TO_ERROR(lParam);

            /* We disconnect whenever a socket command generates an error message */
            if (error)
            {
                WARNING_OUT(("PluggableWndProc: error %d on socket (%d, %d). Event: %d",
                         error, XprtConn.eType, XprtConn.nLogicalHandle, event));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                ::PluggableShutdown(XprtConn);
                break;
            }

            switch (event)
            {
            case PLUGXPRT_EVENT_READ:
                 TRACE_OUT(("PluggableWndProc: READ(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_EVENT_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::PluggableWriteTheFirst(XprtConn);
                break;

            case PLUGXPRT_EVENT_CLOSE:
                TRACE_OUT(("PluggableWndProc: CLOSE(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::DisconnectRequest(XprtConn, TPRT_NOTIFY_OTHER_REASON);
                break;

            case PLUGXPRT_HIGH_LEVEL_READ:
                TRACE_OUT(("PluggableWndProc: READ_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                ::ReadRequestEx(XprtConn);
                break;

            case PLUGXPRT_HIGH_LEVEL_WRITE:
                TRACE_OUT(("PluggableWndProc: WRITE_NEXT(%d, %d)", XprtConn.eType, XprtConn.nLogicalHandle));
                // We need to flush the socket's pending data first.
                if (TRANSPORT_NO_ERROR == ::DataRequest(XprtConn, NULL))
                {
                    TRACE_OUT(("PluggableWndProc: Sending BUFFER_EMPTY_INDICATION to transport."));
                    g_Transport->BufferEmptyIndication(XprtConn);
                }
                break;

            default:
                ERROR_OUT(("PluggableWndProc: unknown event=%d.", event));
                break;
            }
        }
        break;

    case WM_PLUGGABLE_PSTN:
        {
            extern void HandlePSTNCallback(WPARAM wParam, LPARAM lParam);
            HandlePSTNCallback(wParam, lParam);
        }
        break;

    default:
        {
             /*
             **    The message is not related to WinSock messages, so let
             **    the default window procedure handle it.
             */
            return (DefWindowProc (window_handle, message, wParam, lParam));
        }
    }

    return (0);
}

//  GetSecurityInfo() takes a connection_handle and returns the security information associated with
//  it.
//
//    Returns TRUE if we can either find the information or we are not directly connected to the node
//    represented by this connection handle.
//
//    Returns FALSE if we are directly connected but for some reason could not get the info -- this
//    result should be viewed as suspicious.
BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket pSocket;
    SOCKET socket_number;

    if (g_pMCSController->FindSocketNumber(connection_handle, &socket_number))
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfo: queried non-secure socket %d", socket_number));
            }

            pSocket->Release();
        }
        else
        {
            WARNING_OUT(("GetSecurityInfo: socket %d not found", socket_number ));
        }
        return fRet;
    }
    // In this case we are not directly connected, so will return length of NOT_DIRECTLY_CONNECTED
    // but positive return value.
    *pcbInfo = NOT_DIRECTLY_CONNECTED;
    return TRUE;
}

//     GetSecurityInfoFromGCCID() takes a GCCID and returns the security information associated with
//    it.
//
//    Returns TRUE if either (1) we successfully retrieve the information from a transport-level
//    connection, or (2) we find that we are not directly connected to the node with this GCCID.
//
//    Returns FALSE if we are directly connected but cannot retrieve the info, or some other error
//    occurs.  A FALSE return value should be treated as a security violation.

BOOL WINAPI T120_GetSecurityInfoFromGCCID(DWORD dwGCCID, PBYTE pInfo, PDWORD pcbInfo)
{
    PSocket            pSocket;

    SOCKET socket_number;
    if ( NULL != dwGCCID )
    {
        // Get the user info for a remote connection
        ConnectionHandle connection_handle;
        BOOL fConnected = FindSocketNumber(dwGCCID, &socket_number);
        if (fConnected == FALSE) {
            (* pcbInfo) = 0;
            return TRUE;
        }

        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, socket_number);

        BOOL fRet = FALSE;
        if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
        {
            if (NULL != pSocket->pSC)
            {
                fRet = pSocket->pSC->GetUserCert(pInfo, pcbInfo);
            }
            else
            {
                WARNING_OUT(("GetSecurityInfoFromGCCID: queried non-secure socket %d", socket_number));
            }
            pSocket->Release();
        }
        else
        {
            ERROR_OUT(("GetSecurityInfoFromGCCID: socket %d not found", socket_number ));
        }
        return fRet;
    }
    else
    {
        // Get the user info for the local user
        if ( NULL != g_Transport && NULL != g_Transport->pSecurityInterface )
            return g_Transport->pSecurityInterface->GetUserCert( pInfo, pcbInfo );
        else
            return FALSE;
    }
}

DWORD WINAPI T120_TprtSecCtrl ( DWORD dwCode, DWORD_PTR dwParam1, DWORD_PTR dwParam2 )
{
    DWORD    dwRet = TPRTSEC_NOERROR;
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

    switch ( dwCode )
    {
        case TPRTCTRL_SETX509CREDENTIALS:
            //
            // Security.  Create transport interface if we don't have one.
            // Update credentials if we do.
            //
            if (!g_Transport->pSecurityInterface)
            {
                g_Transport->pSecurityInterface =
                    new SecurityInterface(g_Transport->bInServiceContext);

                if ( TPRTSEC_NOERROR !=
                    g_Transport->pSecurityInterface->Initialize())
                {
                    delete g_Transport->pSecurityInterface;
                    g_Transport->pSecurityInterface = NULL;
                    dwRet = TPRTSEC_SSPIFAIL;
                }
            }
            else
            {
                //
                // dwParam1 points to an encoded X509 cert
                // create credentials from it.
                //
                dwRet = g_Transport->pSecurityInterface->
                            InitializeCreds((PCCERT_CONTEXT)dwParam1);
            }
            return dwRet;
            break;

        case TPRTCTRL_GETX509CREDENTIALS:
            if ( g_Transport->pSecurityInterface )
            {
                DWORD cb;
                PBYTE pb;

                if ( g_Transport->pSecurityInterface->GetUserCert( NULL, &cb))
                {
                    if ( pb = (PBYTE)CoTaskMemAlloc ( cb ))
                    {
                        if(g_Transport->pSecurityInterface->GetUserCert(pb,&cb))
                        {
                            *((PBYTE *)dwParam1) = pb;
                            *((PDWORD)dwParam2) = cb;
                            dwRet = TPRTSEC_NOERROR;
                        }
                        else
                            CoTaskMemFree(pb);
                    }
                }
            }
            else
            {
                ERROR_OUT(("TPRTCTRL_GETX509CREDENTIALS w/ no infc"));
                dwRet = TPRTSEC_SSPIFAIL;
            }
            return dwRet;
            break;
        default:
            ERROR_OUT(("TprtSecCtrl: unrecognized command code"));
            return 0;
    }
    ASSERT(FALSE); // Should not reach this
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\t120qos.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

#include <initguid.h>
#include <datguids.h>
#include <nmqos.h>
#include <t120qos.h>


/*	T120qos.cpp
 *
 *	Copyright (c) 1997 by Microsoft Corporation
 *
 *	Abstract:
 *
 *	Global Variables:
 *
 *  g_pIQoS - Global interface pointer to QoS interface
 *  g_dwLastQoSCB - timestamp of last QoS notification obtained via GetTickCount
 *  g_dwSentSinceLastQoS - bytes sent since last QoS notification (or epoch)
 *
 */



// IQOS interface pointer and resources request

LPIQOS				g_pIQoS = NULL;
T120RRQ g_aRRq;

// Global last QoS notification time stamp
DWORD g_dwLastQoSCB = 0;
DWORD g_dwSentSinceLastQoS = 0;
BOOL g_fResourcesRequested = FALSE;

// NOTE: Since connections through this transport typically
// consist of a single socket connection, followed by
// disconnection, followed by multiple connections, the
// following heuristic count is used to prevent on-off-on
// initialization of QoS at the time the first call is started.
// It represents the minimum number of socket connections that
// must be initiated (without an intervening disconnect of all
// connected sockets) before QoS initialization takes place.
#define MIN_CONNECTION_COUNT 	(DEFAULT_NUMBER_OF_PRIORITIES - 1)

WORD g_wConnectionCount = 0;

// extern from transprt.cpp to detect no connections

///// QOS related stuff ///////////////////////////////////


HRESULT CALLBACK QosNotifyDataCB (
		LPRESOURCEREQUESTLIST lpResourceRequestList,
		DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
	int iBWUsageId;

	for (i=0, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++) {

		if (lpResourceRequestList->aRequests[i].resourceID ==
					RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
	}

	if (iBWUsageId != -1L) {

		QoSLock();


		// Calculate effective bits-per second rate:
		//
		// 1000 milliseconds per second
		// 8 bits per byte
		//

		int nEffRate = MulDiv ( g_dwSentSinceLastQoS, 1000 * 8,
									GetTickCount() - g_dwLastQoSCB );

		// Report bandwidth usage to QoS:
		//

		// Are we using less than the available bandwidth?

		if ( ( nEffRate ) <
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin )
		{
			// Request our effective usage
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin = nEffRate;
		}
		else
		{
			// Request everything by not modifying nUnitsMin
			;
		}

		g_dwLastQoSCB = GetTickCount();
		g_dwSentSinceLastQoS = 0;

		QoSUnlock();
	}

	return hr;
}


VOID InitializeQoS( VOID )
{
	DWORD dwRes;
	HRESULT hRet;

	// Already initialized?
	if ( g_fResourcesRequested )
		return;


	// If the number of connections has not reached the
	// trigger count, defer QoS initialization (see MIN_CONNECTION_COUNT
	// comment above)

	if ( g_wConnectionCount < MIN_CONNECTION_COUNT )
	{
		g_wConnectionCount++;
		return;
	}

	// Initialize QoS. If it fails, that's Ok, we'll do without it.
	// No need to set the resource ourselves, this now done by the UI

	if (NULL == g_pIQoS)
	{
		if (0 != (hRet = CoCreateInstance(	CLSID_QoS,NULL,
									CLSCTX_INPROC_SERVER,
									IID_IQoS,
									(void **) &g_pIQoS)))
		{
			WARNING_OUT (("Unable to initalize QoS: %x", hRet));
			g_pIQoS = (LPIQOS)NULL;
			// Tolerate failure, operate w/o QoS
			return;
		}
	}

	// Initialize our request for bandwidth usage.
	g_aRRq.cResourceRequests = 1;
	g_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
	g_aRRq.aResourceRequest[0].nUnitsMin = 0;

	// Register with the QoS module. Even if this call fails,
	// that's Ok, we'll do without the QoS support

	dwRes = (HRESULT)g_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_T120DATA,
		(LPRESOURCEREQUESTLIST)&g_aRRq, QosNotifyDataCB, NULL );

	if ( 0 == dwRes )
	{
		g_fResourcesRequested = TRUE;
	}
}


VOID DeInitializeQoS( VOID )
{
	if (NULL != g_pIQoS)
	{
		if ( g_fResourcesRequested )
		{
			g_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_T120DATA,
								(LPRESOURCEREQUESTLIST)&g_aRRq);
			g_fResourcesRequested = FALSE;
		}
		g_wConnectionCount = 0;
		g_pIQoS->Release();
		g_pIQoS = NULL;
	}
}

VOID MaybeReleaseQoSResources( VOID )
{
	if (g_pSocketList->IsEmpty())
	{
		if (NULL != g_pIQoS)
		{
			if ( g_fResourcesRequested )
			{
				g_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_T120DATA,
									(LPRESOURCEREQUESTLIST)&g_aRRq);
				g_fResourcesRequested = FALSE;
			}
		}
		g_wConnectionCount = 0;
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\tprtntfy.h ===
#ifndef _TPRT_NOTIFY_
#define _TPRT_NOTIFY_

#define TPRT_NOTIFY_NONE                                0
#define TPRT_NOTIFY_OTHER_REASON                        1
#define TPRT_NOTIFY_REMOTE_NO_SECURITY        	        2
#define TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY           3
#define TPRT_NOTIFY_INCOMPATIBLE_T120_TPDU              4
#define TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY		5
#define TPRT_NOTIFY_AUTHENTICATION_FAILED		6

#endif // _TPRT_NOTIFY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\token.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	token.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Token class.  It contains all
 *		code necessary to implement tokens as defined in the MCS specification.
 *
 *		Whenever a user allocates a token (by grabbing or inhibiting it), one
 *		of these objects is created (if domain parameters allow it).  This
 *		object then handles all requests related to that token ID.  It also
 *		issues confirms back to the originators of those requests.
 *
 *		This class includes code to maintain a list of user IDs that
 *		correspond to the current "owners" of the token.  A user is said to
 *		own a token if it has it grabbed or inhibited.  This code implements
 *		the rules concerning who can grab or inhibit tokens at any given
 *		time (which is affected by current state).
 *
 *		This class also contains the code that allows a current grabber of
 *		the token to give it away to another user in the domain.
 *
 *		This class also includes code to merge itself upward during a domain
 *		merge operation.
 *
 *	Private Instance Variables:
 *		Token_ID
 *			This is the token ID for the token that this object represents.
 *		m_pDomain
 *			This is a pointer to the local provider (the domain that owns this
 *			token).  This field is used when a command is issued on behalf of
 *			this provider.
 *		m_pConnToTopProvider
 *			This is the top provider of the current domain.
 *		m_pChannelList2
 *			This is the channel list that is maintained by the domain.  It is
 *			used by this class to perform validation of user IDs.
 *		m_pAttachmentList
 *			This is the attachment list that is maintained by the domain.  It is
 *			used by this class to determine what users are locally attached,
 *			when it becomes necessary to send certain indications.
 *		Token_State
 *			This contains the current state of the token, which will be one of
 *			the following: available; grabbed; inhibited; giving; or given.
 *		m_uidGrabber
 *			This is the user that current has the token grabbed.  This variable
 *			is only valid in the grabbed and giving states.
 *		m_InhibitorList
 *			This is a list of users that have the token inhibited.  This
 *			list is only valid when the token is in the inhibited state.
 *		m_uidRecipient
 *			This is the user to whom the token is being given.  This variable
 *			is only valid in the giving or given states.
 *
 *	Private Member Functions:
 *		ValidateUserID
 *			This function is used to verify that a specified user is valid in
 *			the sub-tree of the local provider.
 *		GetUserAttachment
 *			This function is used to determine which attachment leads to a
 *			particular attachment.
 *		IssueTokenReleaseIndication
 *			This function is used to issue a token release indication to a
 *			specified user.  It first checks to see if the user is locally
 *			attached, and if so, it sends the indication.
 *		BuildAttachmentList
 *			This function is used to build a list of unique attachments to
 *			send please indications to.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "token.h"


/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the token class.  It does nothing more than
 *		set the initial states of instance variables.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(TOKEN_AVAILABLE)
{
	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Mark the token as available for use.
	 */
}

/*
 *	Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is an alternate constructor for the token class.  It is used when
 *		creating a token during a merge operation.  It accepts a current state
 *		as well as a list of current owners  as parameters.
 */
Token::Token (
		TokenID				token_id,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		TokenState			token_state,
		UserID				grabber,
		CUidList           *inhibitor_list,
		UserID				recipient)
:
	m_InhibitorList(),
	Token_ID(token_id),
	m_pDomain(local_provider),
	m_pConnToTopProvider(top_provider),
	m_pChannelList2(channel_list),
	m_pAttachmentList(attachment_list),
	Token_State(token_state)
{
	UserID		uid;

	/*
	 *	Save all parameters in their associated instance variables for later
	 *	use.
	 */

	/*
	 *	Indicate the current state of the token (as passed in).
	 */

	/*
	 *	Depending on token state, copy the pertinent information into local
	 *	instance variables.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			m_uidGrabber = grabber;
			break;

		case TOKEN_INHIBITED:
			{
				/*
				 *	Add all user IDs in the inhibitor list to the local
				 *	inhibitor list.
				 */
				inhibitor_list->Reset();
				while (NULL != (uid = inhibitor_list->Iterate()))
				{
					m_InhibitorList.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			m_uidGrabber = grabber;
			m_uidRecipient = recipient;
			break;

		case TOKEN_GIVEN:
			m_uidRecipient = recipient;
			break;
	}
}

/*
 *	~Token ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the token destructor.  It iterates through its current owner
 *		list, issuing TokenReleaseIndications to any owners that correspond
 *		to locally attached users.
 */
Token::~Token ()
{
	/*
	 *	Depending on the current state of the token, release resources and
	 *	issue release indications to all owners.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID	uid;
				/*
				 *	Iterate through the current inhibitor list, to make sure
				 *	that everyone is properly informed of the demise of this
				 *	token.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					IssueTokenReleaseIndication(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Send a release indication to the grabber, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidGrabber);

			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.  Note that this will not be sent in the case where
			 *	the grabber and the recipient are one and the same.  This
			 *	prevents the sending of two release indications to the same
			 *	user for the same token.
			 */
			if (m_uidGrabber != m_uidRecipient)
				IssueTokenReleaseIndication (m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Send a release indication to the recipient, if it is locally
			 *	attached.
			 */
			IssueTokenReleaseIndication (m_uidRecipient);
			break;
	}
}


/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function checks the validity of each of its owners.  It then
 *		returns TRUE if there are any valid owners left.  FALSE otherwise.
 */
BOOL    Token::IsValid ()
{
	BOOL    		valid;

	/*
	 *	We must check for the validity of this token.  How this is checked for
	 *	is a function of token state.  So switch on the state.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	When a token is grabbed, the grabber must be in the sub-tree
			 *	of the current provider.  If this is not true, then mark the
			 *	token as available (which will cause it to be deleted).
			 */
			if (ValidateUserID (m_uidGrabber) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_INHIBITED:
			{
				UserID			uid;
				CUidList		deletion_list;
				/*
				 *	Iterate through the current inhibitor list of this token,
				 *	checking to make sure that each user is still valid.  Each
				 *	one that is not will be put into a deletion list (it is
				 *	invalid to remove items from a list while using an iterator
				 *	on the list).
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					if (ValidateUserID(uid) == FALSE)
						deletion_list.Append(uid);
				}

				/*
				 *	Iterate through the deletion list that was built above,
				 *	removing each contained user from the token's inhibitor
				 *	list.  These correspond to users that have detached from the
				 *	domain for one reason or another.
				 */
				deletion_list.Reset();
				while (NULL != (uid = deletion_list.Iterate()))
				{
					m_InhibitorList.Remove(uid);
				}
			}

			/*
			 *	Check to see if there are any inhibitors left.  If not, then
			 *	we must change the state of the token to available (which will
			 *	cause it to be deleted).
			 */
			if (m_InhibitorList.IsEmpty())
				Token_State = TOKEN_AVAILABLE;
			break;

		case TOKEN_GIVING:
			/*
			 *	When a token is in the giving state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token MUST change state.  The state it changes to depends on
			 *	whether or not the grabber is in the sub-tree of the current
			 *	provider.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
			{
				/*
				 *	The recipient of the token is gone.  Check to see if the
				 *	grabber is in the sub-tree of this provider.
				 */
				if (ValidateUserID (m_uidGrabber) == FALSE)
				{
					/*
					 *	The grabber is not in the sub-tree of this provider,
					 *	meaning that the token is no longer valid.
					 */
					Token_State = TOKEN_AVAILABLE;
				}
				else
				{
					/*
					 *	The grabber is in the sub-tree of this provider, so the
					 *	token state will transition back to grabbed.
					 */
					Token_State = TOKEN_GRABBED;

					/*
					 *	If this is the top provider, it is necessary to issue a
					 *	give confirm to the grabber telling it that the give
					 *	failed.
					 */
					if (m_pConnToTopProvider == NULL)
					{
						/*
						 *	Find out what attachment leads to the current
						 *	grabber of the token, and issue the appropriate
						 *	token give confirm.
						 */
						CAttachment *pAtt = GetUserAttachment(m_uidGrabber);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(RESULT_NO_SUCH_USER, m_uidGrabber, Token_ID,
						                           TOKEN_SELF_GRABBED);
						}
					}
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	When a token is in the given state, the recipient must be in
			 *	the sub-tree of the current provider.  If it is not, then the
			 *	token is no longer valid, and should transition to the
			 *	available state.
			 */
			if (ValidateUserID (m_uidRecipient) == FALSE)
				Token_State = TOKEN_AVAILABLE;
			break;
	}

	/*
	 *	Check to see if the token is still in use.  If it is marked as
	 *	available, then it is not, and we will return FALSE.
	 */
	if (Token_State != TOKEN_AVAILABLE)
		valid = TRUE;
	else
		valid = FALSE;

	return (valid);
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function tells the token object to pack its state into a merge
 *		request and send it to the specified provider.
 */
Void	Token::IssueMergeRequest ()
{
	TokenAttributes			merge_token;
	CTokenAttributesList	merge_token_list;
	CTokenIDList			purge_token_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Check the state to make sure that the token really is in use.  If
		 *	the state is set to available, then do not issue a merge request.
		 */
		if (Token_State != TOKEN_AVAILABLE)
		{
			/*
			 *	Fill in a token attributes structure to represent the state of
			 *	this token.  Then put it into the merge token list in
			 *	preparation for issuing the merge request.
			 */
			merge_token.token_state = Token_State;
			switch (Token_State)
			{
				case TOKEN_GRABBED:
					merge_token.u.grabbed_token_attributes.token_id = Token_ID;
					merge_token.u.grabbed_token_attributes.grabber = m_uidGrabber;
					break;

				case TOKEN_INHIBITED:
					merge_token.u.inhibited_token_attributes.token_id =
							Token_ID;
					merge_token.u.inhibited_token_attributes.inhibitors =
							&m_InhibitorList;
					break;

				case TOKEN_GIVING:
					merge_token.u.giving_token_attributes.token_id = Token_ID;
					merge_token.u.giving_token_attributes.grabber = m_uidGrabber;
					merge_token.u.giving_token_attributes.recipient = m_uidRecipient;
					break;

				case TOKEN_GIVEN:
					merge_token.u.given_token_attributes.token_id = Token_ID;
					merge_token.u.given_token_attributes.recipient = m_uidRecipient;
					break;
			}
			merge_token_list.Append(&merge_token);

			/*
			 *	Send the resulting merge request to the indicated provider.
			 */
			m_pConnToTopProvider->MergeTokensRequest(&merge_token_list, &purge_token_list);
		}
		else
		{
			/*
			 *	Report that the token is not in use, but do NOT send a merge
			 *	request.
			 */
			TRACE_OUT(("Token::IssueMergeRequest: token not in use"));
		}
	}
}

/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to grab a token.  The request
 *		will either succeed or fail depending on the current state of the token.
 *		Either way, a confirm will be sent to the user originating the request.
 */
Void	Token::TokenGrabRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Change the state to grabbed, and mark the
				 *	initiator as the grabber.
				 */
				Token_State = TOKEN_GRABBED;
				m_uidGrabber = uidInitiator;

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_GRABBED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is already grabbed, then we must fail the
				 *	request.  However, we need to determine if the token is
				 *	grabbed by the same user who is currently requesting it, or
				 *	another user.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	If the token is inhibited, this request can still succeed if
				 *	the only inhibitor is the user that is attempting to grab
				 *	the token.  Check to see if this is the case.
				 */
				if (m_InhibitorList.Find(uidInitiator))
				{
					if (m_InhibitorList.GetCount() == 1)
					{
						/*
						 *	The user attempting to grab the token is the only
						 *	inhibitor, so convert the state to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
						m_uidGrabber = uidInitiator;
						m_InhibitorList.Clear();

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_SELF_GRABBED;
					}
					else
					{
						/*
						 *	The token is inhibited by at least one other user,
						 *	so the grab request must fail.
						 */
						result = RESULT_TOKEN_NOT_AVAILABLE;
						token_status = TOKEN_SELF_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The token is not inhibited by the requestor, so it must
					 *	be inhibited by someone else.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then a grab request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token grab confirm to the initiating user.
		 */
		pOrigAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGrabRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenGrabRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenGrabConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_GRABBED;
			m_uidGrabber = uidInitiator;
			m_InhibitorList.Clear();
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGrabConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGrabConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user tries to inhibit a token.  The
 *		request will either succeed or fail depending on the current state of
 *		the token.  Either way, a confirm will be sent to the user originating
 *		the request.
 */
Void	Token::TokenInhibitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	Since the token is available, the request automatically
				 *	succeeds.  Set the token state to inhibited, and add the
				 *	initiator to the list of inhibitors.
				 */
				Token_State = TOKEN_INHIBITED;
				m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GRABBED:
				/*
				 *	If the token is grabbed, this request can still succeed if
				 *	the grabber is the user that is attempting to inhibit the
				 *	token.  Check to see if this is the case.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber is attempting to convert the state
					 *	of the token to inhibited.  This is valid, so set the
					 *	state appropriately.
					 */
					Token_State = TOKEN_INHIBITED;
					m_InhibitorList.Append(uidInitiator);

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_SELF_INHIBITED;
				}
				else
				{
					/*
					 *	The token is grabbed by someone else, so the inhibit
					 *	request must fail.
					 */
					result = RESULT_TOKEN_NOT_AVAILABLE;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is already inhibited, but this is okay.  Add this
				 *	user to the list of inhibitors (if it is not already there).
				 */
				if (m_InhibitorList.Find(uidInitiator) == FALSE)
					m_InhibitorList.Append(uidInitiator);

				result = RESULT_SUCCESSFUL;
				token_status = TOKEN_SELF_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	If the token is in the process of being given from one to
				 *	another, then an inhibit request must fail.  All we need to
				 *	figure out is the proper token status to report.
				 */
				result = RESULT_TOKEN_NOT_AVAILABLE;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If the originator is NULL, then this inhibit request is happening as
		 *	part of a merge operation, in which case we do NOT want to send a
		 *	token inhibit confirm.  Otherwise we do send one.
		 */
		if (pOrigAtt != NULL)
		{
			pOrigAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenInhibitRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenInhibitRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenInhibitConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Force this token to conform to the results of this confirm.
			 */
			Token_State = TOKEN_INHIBITED;
			if (m_InhibitorList.Find(uidInitiator) == FALSE)
				m_InhibitorList.Append(uidInitiator);
		}

		/*
		 *	Determine what attachment leads to the initiator, and issue the
		 *	token confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenInhibitConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenInhibitConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when one user asks to give a token to another
 *		user.
 */
Void	Token::TokenGiveRequest (
				CAttachment        *pOrigAtt,
				PTokenGiveRecord	pTokenGiveRec)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this provider is the Top Provider.  If so, then process
	 *	this request here.  Otherwise, forward the request upward.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		UserID		uidInitiator = pTokenGiveRec->uidInitiator;
		UserID		receiver_id = pTokenGiveRec->receiver_id;
		/*
		 *	Determine what state we are, which greatly affects how we process
		 *	the request.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use, and therefore cannot be given by
				 *	anyone to anyone.  So fail this request.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	Check to see if the requestor really is the grabber of this
				 *	token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	Check to see if the intended recipient is a valid user
					 *	in the domain.
					 */
					if (ValidateUserID (receiver_id) )
					{
						/*
						 *	Everything checks out.  Set the result to success
						 *	to disable transmission of the give confirm below.
						 *	Change the state of the token to giving, and
						 *	save the ID of the intended recipient.  Then issue
						 *	the give indication toward the recipient.
						 */
						result = RESULT_SUCCESSFUL;
						Token_State = TOKEN_GIVING;
						m_uidRecipient = receiver_id;

						CAttachment *pAtt = GetUserAttachment(receiver_id);
						ASSERT (Token_ID == pTokenGiveRec->token_id);
						if (pAtt)
						{
						    pAtt->TokenGiveIndication(pTokenGiveRec);
						}
					}
					else
					{
						/*
						 *	The recipient does not exist in the domain, so
						 *	fail the request.
						 */
						result = RESULT_NO_SUCH_USER;
						token_status = TOKEN_SELF_GRABBED;
					}
				}
				else
				{
					/*
					 *	The requestor does not own the token, so the request
					 *	must fail.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	Inhibited tokens cannot be given by anyone to anyone.  So
				 *	fail this request with the proper status.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (m_InhibitorList.Find(uidInitiator) )
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	This token is already in the process of being given.  So
				 *	this request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	If necessary, issue a token give confirm to the initiating user.
		 */
		if (result != RESULT_SUCCESSFUL)
		{
			pOrigAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	Forward this request upward towards the Top Provider.
		 */
		TRACE_OUT(("Token::TokenGiveRequest: forwarding request to Top Provider"));
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		m_pConnToTopProvider->TokenGiveRequest(pTokenGiveRec);
	}
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to a user that
 *		another user is trying to give them a token.
 */
Void	Token::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	UserID				receiver_id;

	receiver_id = pTokenGiveRec->receiver_id;
	/*
	 *	Make sure that the receiver ID is valid, since we must forward this
	 *	indication in the direction of that user.  If it is not valid, ignore
	 *	this indication.
	 */
	if (ValidateUserID (receiver_id) )
	{
		/*
		 *	Force this token to conform to the state implied by this indication.
		 */
		Token_State = TOKEN_GIVING;
		m_uidGrabber = pTokenGiveRec->uidInitiator;
		m_InhibitorList.Clear();
		m_uidRecipient = receiver_id;

		/*
		 *	Determine what attachment leads to the recipient, and forward the
		 *	indication in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(receiver_id);
		ASSERT (Token_ID == pTokenGiveRec->token_id);
		if (pAtt)
		{
		    pAtt->TokenGiveIndication(pTokenGiveRec);
		}
	}
	else
	{
		/*
		 *	The recipient is not in the sub-tree of this provider.  So ignore
		 *	this indication.
		 */
		ERROR_OUT(("Token::TokenGiveIndication: invalid receiver ID"));
	}
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a potential recipient decides whether or
 *		not to accept an offered token.
 */
Void	Token::TokenGiveResponse (
				Result				result,
				UserID				receiver_id,
				TokenID)
{
	UserID			uidInitiator;
	TokenStatus		token_status;

	/*
	 *	Process the response according to the current state of this token.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
		case TOKEN_GRABBED:
		case TOKEN_INHIBITED:
			/*
			 *	The token is not in the process of being given to anyone, so
			 *	this response must be ignored.
			 */
			break;

		case TOKEN_GIVING:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Save the ID of the initiator, for use in issuing a give
				 *	confirm (if necessary).
				 */
				uidInitiator = m_uidGrabber;

				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  It must either revert to
					 *	being grabbed by the donor, or deleted, depending on
					 *	whether or not the donor is in the sub-tree of this
					 *	provider.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	The donor is in the sub-tree of this provider, so
						 *	change the state of the token back to grabbed.
						 */
						Token_State = TOKEN_GRABBED;
					}
					else
					{
						/*
						 *	The donor is not in the sub-tree of this provider,
						 *	so the token will be marked as available (which
						 *	will cause it to be deleted).
						 */
						Token_State = TOKEN_AVAILABLE;
					}
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider == NULL)
				{
					/*
					 *	If the donor is still a valid user in the domain, a
					 *	token give confirm must be issued in its direction.
					 */
					if (ValidateUserID(uidInitiator))
					{
						/*
						 *	Determine which attachment leads to the donor, and
						 *	issue the token give confirm.
						 */
						if (uidInitiator == m_uidGrabber)
							token_status = TOKEN_SELF_GRABBED;
						else
							token_status = TOKEN_OTHER_GRABBED;

						CAttachment *pAtt = GetUserAttachment(uidInitiator);
						if (pAtt)
						{
						    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
						}
					}
				}
				else
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;

		case TOKEN_GIVEN:
			/*
			 *	The token is being given to someone.  Check to see if this is
			 *	the proper recipient.  If not, don't do anything.
			 */
			if (receiver_id == m_uidRecipient)
			{
				/*
				 *	Check to see if the token was accepted.  A result of
				 *	anything but successful would indicate that it was not.
				 */
				if (result == RESULT_SUCCESSFUL)
				{
					/*
					 *	The token was accepted by the intended recipient.
					 *	Change the state of the token to being grabbed by the
					 *	receiver.
					 */
					Token_State = TOKEN_GRABBED;
					m_uidGrabber = receiver_id;
				}
				else
				{
					/*
					 *	The token was not accepted.  Since the donor has
					 *	already relinquished control of the token, the token
					 *	will marked as available (which will cause it to be
					 *	deleted).
					 */
					Token_State = TOKEN_AVAILABLE;
				}

				/*
				 *	Check to see if this is the Top Provider.
				 */
				if (m_pConnToTopProvider != NULL)
				{
					/*
					 *	If this is not the Top Provider, then the valid give
					 *	response must be forwarded to the Top Provider.
					 */
					m_pConnToTopProvider->TokenGiveResponse(result, receiver_id, Token_ID);
				}
			}
			break;
	}
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a potential giver of a token is told whether
 *		or not the token was successfully given to the intended recipient.
 */
Void	Token::TokenGiveConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	The token should be in the grabbed state, or else this confirm
		 *	was generated in error.
		 */
		if (Token_State == TOKEN_GRABBED)
		{
			/*
			 *	Check to see if this request was successful.
			 */
			if (result == RESULT_SUCCESSFUL)
			{
				/*
				 *	If this token is marked as being owned by the initiator of
				 *	the give, but the status indicates that the token is now
				 *	owned by someone else (as a result of the successful give),
				 *	then release the token.*
				 */
				if ((uidInitiator == m_uidGrabber) &&
						(token_status == TOKEN_OTHER_GRABBED))
					Token_State = TOKEN_AVAILABLE;
			}
		}
		else
		{
			/*
			 *	The token is in an invalid state.  Report the error, but do
			 *	not change the state of the token.
			 */
			ERROR_OUT(("Token::TokenGiveConfirm: invalid token state"));
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenGiveConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenGiveConfirm: invalid initiator ID"));
	}
}

/*
 *	Void		TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask all current owners
 *		of a token to relinquish their ownership.
 */
Void	Token::TokenPleaseRequest (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
        CAttachmentList         attachment_list;
        CAttachment            *pAtt;
		/*
		 *	Determine the state of the token, to determine who to send the
		 *	please indication to.  Each state will place the appropriate user
		 *	IDs in the please indication list.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				break;

			case TOKEN_GRABBED:
				/*
				 *	Put the grabber into the list.
				 */
				please_indication_list.Append(m_uidGrabber);
				break;

			case TOKEN_INHIBITED:
				{
					UserID		uid;
					/*
					 *	Put all current inhibitors into the list.
					 */
					m_InhibitorList.Reset();
					while (NULL != (uid = m_InhibitorList.Iterate()))
					{
						please_indication_list.Append(uid);
					}
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	Put the grabber into the list.  And if the recipient is
				 *	different from the grabber, put it in as well.  Remember
				 *	that it is valid for someone to give a token to themselves.
				 */
				please_indication_list.Append(m_uidGrabber);
				if (m_uidGrabber != m_uidRecipient)
					please_indication_list.Append(m_uidRecipient);
				break;

			case TOKEN_GIVEN:
				/*
				 *	Put the recipient into the list.
				 */
				please_indication_list.Append(m_uidRecipient);
				break;
		}

		/*
		 *	Build lists of unique attachments that lead to the users in the
		 *	please indication list (built above).
		 */
		BuildAttachmentList (&please_indication_list, &attachment_list);

		/*
		 *	Iterate through the newly created attachment list, issuing token
		 *	please indications to all attachments contained therein.
		 */
		attachment_list.Reset();
		while (NULL != (pAtt = attachment_list.Iterate()))
		{
			pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
		}
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenPleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenPleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void		TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called in order to deliver a message to all current
 *		owners of a token that someone else wishes to own the token.
 */
Void	Token::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID)
{
	CUidList				please_indication_list;
	CAttachmentList         attachment_list;
    CAttachment            *pAtt;

	/*
	 *	Determine the state of the token, to determine who to forward the
	 *	please indication to.  Each state will place the appropriate user
	 *	IDs in the please indication list.
	 */
	switch (Token_State)
	{
		case TOKEN_AVAILABLE:
			break;

		case TOKEN_GRABBED:
			/*
			 *	Put the grabber into the list.
			 */
			please_indication_list.Append(m_uidGrabber);
			break;

		case TOKEN_INHIBITED:
			{
				UserID		uid;
				/*
				 *	Put all current inhibitors into the list.
				 */
				m_InhibitorList.Reset();
				while (NULL != (uid = m_InhibitorList.Iterate()))
				{
					please_indication_list.Append(uid);
				}
			}
			break;

		case TOKEN_GIVING:
			/*
			 *	Put the grabber into the list.  And if the recipient is
			 *	different from the grabber, put it in as well.  Remember
			 *	that it is valid for someone to give a token to themselves.
			 */
			please_indication_list.Append(m_uidGrabber);
			if (m_uidGrabber != m_uidRecipient)
				please_indication_list.Append(m_uidRecipient);
			break;

		case TOKEN_GIVEN:
			/*
			 *	Put the recipient into the list.
			 */
			please_indication_list.Append(m_uidRecipient);
			break;
	}

	/*
	 *	Build lists of unique attachments that lead to the users in the
	 *	please indication list (built above).
	 */
	BuildAttachmentList (&please_indication_list, &attachment_list);

	/*
	 *	Iterate through the newly created attachment list, issuing token
	 *	please indications to all attachments contained therein.
	 */
	attachment_list.Reset();
	while (NULL != (pAtt = attachment_list.Iterate()))
	{
		pAtt->TokenPleaseIndication(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wished to release a token.  If the
 *		requesting user really is an owner of the token, the request will
 *		succeed.  Otherwise it will fail.  Either way, an appropriate token
 *		release confirm will be issued.
 */
Void	Token::TokenReleaseRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	Result			result;
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	Determine the current state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	If the token is available, then the requestor cannot be an
				 *	owner.  This means that the request must fail.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is in the grabbed state.  See if the requesting
				 *	user is the one who has it grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The current grabber of the token wishes to release it.
					 *	Set the state back to available, and send the
					 *	appropriate token release confirm.
					 */
					Token_State = TOKEN_AVAILABLE;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_NOT_IN_USE;
				}
				else
				{
					/*
					 *	Someone is trying to release someone elses token.  This
					 *	request must fail.  Send the appropriate token release
					 *	confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_GRABBED;
				}
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is in the inhibited state.  See if the requesting
				 *	user is one of the inhibitors.
				 */
				if (m_InhibitorList.Remove(uidInitiator))
				{
					/*
					 *	The user is an inhibitor.  Remove the user from the
					 *	list.  Then check to see if this has resulted in an
					 *	"ownerless" token.
					 */
					if (m_InhibitorList.IsEmpty())
					{
						/*
						 *	The token has no other inhibitors.  Return the token
						 *	to the available state, and issue the appropriate
						 *	token release confirm.
						 */
						Token_State = TOKEN_AVAILABLE;

						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_NOT_IN_USE;
					}
					else
					{
						/*
						 *	There are still other inhibitors of the token.
						 *	Simply issue the appropriate token release confirm.
						 */
						result = RESULT_SUCCESSFUL;
						token_status = TOKEN_OTHER_INHIBITED;
					}
				}
				else
				{
					/*
					 *	The user attempting to release the token is not one of
					 *	the inhibitors.  Therefore the request must fail.  Issue
					 *	the appropriate token release indication.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					token_status = TOKEN_OTHER_INHIBITED;
				}
				break;

			case TOKEN_GIVING:
				/*
				 *	See if the requestor is the current owner of the token.
				 */
				if (uidInitiator == m_uidGrabber)
				{
					/*
					 *	The token must transition to the given state.  This
					 *	state indicates that if the recipient rejects the offer
					 *	or detaches, the token will be freed instead of
					 *	returning to the grabbed state.  Issue the appropriate
					 *	release confirm.
					 */
					Token_State = TOKEN_GIVEN;

					result = RESULT_SUCCESSFUL;
					token_status = TOKEN_OTHER_GIVING;
				}
				else
				{
					/*
					 *	If the requestor is not the current owner, then this
					 *	request must fail.  We first need to determine the
					 *	proper token status, and then issue the confirm.
					 */
					result = RESULT_TOKEN_NOT_POSSESSED;
					if (uidInitiator == m_uidRecipient)
						token_status = TOKEN_SELF_RECIPIENT;
					else
						token_status = TOKEN_OTHER_GIVING;
				}
				break;

			case TOKEN_GIVEN:
				/*
				 *	When the token is in the given state, there is no true
				 *	owner (only a pending owner).  This request must therefore
				 *	fail.  We first need to determine the proper token status,
				 *	and then issue the confirm.
				 */
				result = RESULT_TOKEN_NOT_POSSESSED;
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the token release confirm to the initiator.
		 */
		pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenReleaseRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenReleaseConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID (uidInitiator) )
	{
		/*
		 *	Check to see if this request was successful.
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Process the confirm according to current state.
			 */
			switch (Token_State)
			{
				case TOKEN_AVAILABLE:
					break;

				case TOKEN_GRABBED:
					/*
					 *	If the grabber has released the token, then is becomes
					 *	available.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_AVAILABLE;
					break;

				case TOKEN_INHIBITED:
					/*
					 *	If an inhibitor releases the token, then remove it from
					 *	the list.  If there are no more entries in the list,
					 *	then the token becomes available.
					 */
					if (m_InhibitorList.Remove(uidInitiator))
					{
						if (m_InhibitorList.IsEmpty())
							Token_State = TOKEN_AVAILABLE;
					}
					break;

				case TOKEN_GIVING:
					/*
					 *	If the grabber releases the token, then it transitions
					 *	to an intermediate state.  This state indicates that
					 *	if the recipient rejects the token, it will be freed
					 *	instead of returning to the grabbed state.
					 */
					if (uidInitiator == m_uidGrabber)
						Token_State = TOKEN_GIVEN;
					break;

				case TOKEN_GIVEN:
					break;
			}
		}

		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenReleaseConfirm(result, uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The only action is to issue a token test confirm containing
 *		the state information.
 */
Void	Token::TokenTestRequest (
				CAttachment        *pAtt,
				UserID				uidInitiator,
				TokenID)
{
	TokenStatus		token_status;

	/*
	 *	Check to see if this is the Top Provider.
	 */
	if (m_pConnToTopProvider == NULL)
	{
		/*
		 *	Determine the state of the token before proceeding.
		 */
		switch (Token_State)
		{
			case TOKEN_AVAILABLE:
				/*
				 *	The token is not in use.
				 */
				token_status = TOKEN_NOT_IN_USE;
				break;

			case TOKEN_GRABBED:
				/*
				 *	The token is grabbed.  See if the originating user is the
				 *	grabber.  If so, return the state as self grabbed.  If not,
				 *	return the state as other grabbed.
				 */
				if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GRABBED;
				else
					token_status = TOKEN_OTHER_GRABBED;
				break;

			case TOKEN_INHIBITED:
				/*
				 *	The token is inhibited.  See if the originating user is one
				 *	of the inhibitors.  If so, return the state as self
				 *	inhibited.  If not, return the state as other inhibited.
				 */
				if (m_InhibitorList.Find(uidInitiator))
					token_status = TOKEN_SELF_INHIBITED;
				else
					token_status = TOKEN_OTHER_INHIBITED;
				break;

			case TOKEN_GIVING:
				/*
				 *	The token is being given from one user to another.  See if
				 *	the requestor is one of the users involved.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else if (uidInitiator == m_uidGrabber)
					token_status = TOKEN_SELF_GIVING;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;

			case TOKEN_GIVEN:
				/*
				 *	The token has been given from one user to another.  See if
				 *	the requestor is the receiver.
				 */
				if (uidInitiator == m_uidRecipient)
					token_status = TOKEN_SELF_RECIPIENT;
				else
					token_status = TOKEN_OTHER_GIVING;
				break;
		}

		/*
		 *	Issue the test confirm with the appropriate status information.
		 */
		pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
	}
	else
	{
		/*
		 *	Forward the request toward the top provider.
		 */
		TRACE_OUT(("Token::TokenTestRequest: forwarding request to Top Provider"));
		m_pConnToTopProvider->TokenTestRequest(uidInitiator, Token_ID);
	}
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called as a part of sending a response to a user for
 *		a previous request.  It tells the user the result of the request.
 */
Void	Token::TokenTestConfirm (
				UserID				uidInitiator,
				TokenID,
				TokenStatus			token_status)
{
	/*
	 *	Make sure that the initiator ID is valid, since we must forward this
	 *	confirm in the direction of that user.  If it is not valid, ignore
	 *	this confirm.
	 */
	if (ValidateUserID(uidInitiator))
	{
		/*
		 *	Determine what attachment leads to the initiator, and forward the
		 *	confirm in that direction.
		 */
		CAttachment *pAtt = GetUserAttachment(uidInitiator);
		if (pAtt)
		{
		    pAtt->TokenTestConfirm(uidInitiator, Token_ID, token_status);
		}
	}
	else
	{
		/*
		 *	The initiator is not in the sub-tree of this provider.  So ignore
		 *	this confirm.
		 */
		ERROR_OUT(("Token::TokenReleaseConfirm: invalid initiator ID"));
	}
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to verify the existence of the specified user
 *		in the sub-tree of this provider.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to validate.
 *
 *	Return Value:
 *		TRUE if the user is valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    Token::ValidateUserID (
					UserID			user_id)
{
	/*
	 *	Initialize the return value to FALSE, indicating that if any of the
	 *	following checks fail, the ID does NOT refer to a valid user ID.
	 */
	BOOL    	valid=FALSE;
	PChannel	channel;

	/*
	 *	First check to see if the user ID is in the channel list at all.  This
	 *	prevents an attempt to read an invalid entry from the dictionary.
	 */
	if (NULL != (channel = m_pChannelList2->Find(user_id)))
	{
		/*
		 *	We know that the ID is in the dictionary, but we don't know for sure
		 *	whether or not it is a user ID channel.  So check this.  If it is a
		 *	user channel, then set the valid flag to TRUE.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
			valid = TRUE;
	}

	return (valid);
}

/*
 *	PCommandTarget	GetUserAttachment ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the specified
 *		user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to find the attachment
 *			for.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user.
 *
 *	Side Effects:
 *		None.
 */
CAttachment *Token::GetUserAttachment (
						UserID				user_id)
{
	PChannel		lpChannel;
	/*
	 *	Read and return a pointer to the attachment that leads to the
	 *	specified user.  Note that this routine does NOT check to see if the
	 *	user is in the channel list.  It assumes that the user is known to
	 *	be valid BEFORE this routine is called.
	 */
	return ((NULL != (lpChannel = m_pChannelList2->Find(user_id))) ?
            lpChannel->GetAttachment() :
            NULL);
}

/*
 *	Void	IssueTokenReleaseIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to issue a token release indication to a
 *		particular user.  It first check to make sure that the user id valid,
 *		and that it is a local user.
 *
 *	Formal Parameters:
 *		user_id (i)
 *			This is the ID of the user the caller wishes to send a token
 *			release indication to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::IssueTokenReleaseIndication (
				UserID			user_id)
{
	/*
	 *	Make sure that the specified user exists in the sub-tree of this
	 *	provider.
	 */
	if (ValidateUserID (user_id) )
	{
		/*
		 *	Determine which attachment leads to the grabber.
		 */
		CAttachment *pAtt = GetUserAttachment(user_id);

		/*
		 *	Is this attachment a local one?  If so, then issue a token
		 *	release indication to let the user know that the token has
		 *	been taken away.
		 */
		if ( ( pAtt != NULL ) && m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
		{
		    PUser pUser = (PUser) pAtt;
			pUser->TokenReleaseIndication(REASON_TOKEN_PURGED, Token_ID);
		}
	}
}

/*
 *	Void	BuildAttachmentList ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function builds a list of unique attachments out of the list of
 *		user IDs that is poassed in.  This is done to insure that no given
 *		attachment receives more than one indication, even when there are more
 *		than one user in the same direction.
 *
 *	Formal Parameters:
 *		user_id_list (i)
 *			This is a list of user IDs that the caller wishes to send a token
 *			please indication to.
 *		attachment_list (i)
 *			This is the list that all unique attachments will be added to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Token::BuildAttachmentList (
				CUidList                *user_id_list,
				CAttachmentList         *attachment_list)
{
	UserID				uid;

	/*
	 *	Loop through the passed in user ID list building a list of unique
	 *	attachments.  This will be used to send indications downward without
	 *	sending one twice over the same attachment.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Check to see if the user ID refers to a valid user in the sub-tree
		 *	of this provider.
		 */
		if (ValidateUserID(uid))
		{
			/*
			 *	Determine which attachment leads to the user in question.  Then
			 *	check to see if it is already in the attachment list.  If not,
			 *	then put it there.
			 */
			CAttachment *pAtt = GetUserAttachment(uid);
			if (attachment_list->Find(pAtt) == FALSE)
				attachment_list->Append(pAtt);
		}
		else
		{
			/*
			 *	This user ID does not correspond to a valid user in the sub-tree
			 *	of this provider.  Therefore, discard the ID.
			 */
			ERROR_OUT(("Token::BuildAttachmentList: user ID not valid"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\tprtsec.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);

// #define FORCE_SSL3_NEGOTIATION

#include "tprtsec.h"
#include "nmmkcert.h"

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

/*    Tprtsec.cpp
 *
 *    Copyright (c) 1997 by Microsoft Corporation
 *
 *    Abstract:
 *        This module maintains security for the TCP transport.
 *
 */

/* External definitions */
extern HINSTANCE            g_hDllInst;

/*
 *    The following array contains a template for the X.224 data header.
 *    The 5 of the 7 bytes that it initializes are actually sent to the
 *    wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *    The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];


#ifdef DEBUG
//#define TESTHACKS // DANGER! don't turn on in public build!
//#define DUMP
//#define DUMPCERTS
//#undef TRACE_OUT
//#define TRACE_OUT WARNING_OUT
#endif //DEBUG

#define    SZSECPKG    UNISP_NAME_A

#define    ISC_REQ_FLAGS (    ISC_REQ_SEQUENCE_DETECT |\
                        ISC_REQ_REPLAY_DETECT |\
                        ISC_REQ_CONFIDENTIALITY |\
                        ISC_REQ_EXTENDED_ERROR |\
                        ISC_REQ_ALLOCATE_MEMORY |\
                        ISC_REQ_STREAM)

#define    ASC_REQ_FLAGS (    ASC_REQ_SEQUENCE_DETECT |\
                        ASC_REQ_REPLAY_DETECT |\
                        ASC_REQ_CONFIDENTIALITY |\
                        ASC_REQ_EXTENDED_ERROR |\
                        ASC_REQ_ALLOCATE_MEMORY |\
                        ASC_REQ_MUTUAL_AUTH |\
                        ASC_REQ_STREAM)


#if defined(DUMP) || defined(DUMPCERTS)

#define MAX_DUMP_BYTES    512

void dumpbytes(PSTR szComment, PBYTE p, int cb)
{
    int i,j;
    char buf[80];
    char buf2[80];
    DWORD dwCheckSum = 0;
    int cbShow = min(MAX_DUMP_BYTES,cb);

    for (i=0; i<cb; i++)
        dwCheckSum += p[i];

    wsprintf(buf,"%s (%d bytes, checksum %x):",
        szComment? szComment : "unknown", cb, dwCheckSum);
    OutputDebugString(buf);
    WARNING_OUT(("%s",buf));
    OutputDebugString("\n\r");

    for (i=0; i<cbShow/16; i++)
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat ( buf, "\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow%16 )
    {
        wsprintf(buf, "%08x: ", (DWORD) &p[(i*16)] );
        for (j=0; j<cbShow%16; j++)
        {
            wsprintf(buf2," %02x", (int) (unsigned char) p[(i*16)+j] );
            lstrcat ( buf, buf2 );
        }
        WARNING_OUT(("%s",buf));
        lstrcat(buf,"\n\r");
        OutputDebugString(buf);
    }
    if ( cbShow < cb )
    {
        OutputDebugString("...\n\r");
        WARNING_OUT(("..."));
    }
}
#endif //DUMP or DUMPCERTS


///////////////////////////////////////////////////////////////////////////
// Security Interface
///////////////////////////////////////////////////////////////////////////




SecurityInterface::SecurityInterface(BOOL bService) :
                LastError(TPRTSEC_NOERROR),
                bInboundCredentialValid(FALSE),
                bOutboundCredentialValid(FALSE),
                m_pbEncodedCert(NULL),
                m_cbEncodedCert(0),
                hSecurityDll(NULL),
                pfnTable(NULL),
                bInServiceContext(bService)
{
}

SecurityInterface::~SecurityInterface(VOID)
{
    if ( pfnTable && bInboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hInboundCredential );
    }

    if ( pfnTable && bOutboundCredentialValid )
    {
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );
    }

    if ( NULL != m_pbEncodedCert )
    {
        delete m_pbEncodedCert;
    }

    if ( NULL != hSecurityDll )
    {
        FreeLibrary( hSecurityDll );
    }
}

#ifdef DUMPCERTS
VOID DumpCertStore ( SecurityInterface * pSI, char * sz, HCERTSTORE hStore)
{
    WARNING_OUT(("************ %s *************", sz));
    PCCERT_CONTEXT pC = NULL;
    int i = 0;
    char buf[256];

    while ( pC = CertEnumCertificatesInStore(
                                    hStore, (PCERT_CONTEXT)pC ))
    {
        WARNING_OUT(("----------- Entry %d: ----------------", i));

        // Dump stuff in pC->pCertInfo
        //DWORD                       dwVersion;
        //CRYPT_INTEGER_BLOB          SerialNumber;
        //CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
        //CERT_NAME_BLOB              Issuer;
        //FILETIME                    NotBefore;
        //FILETIME                    NotAfter;
        //CERT_NAME_BLOB              Subject;
        //CERT_PUBLIC_KEY_INFO        SubjectPublicKeyInfo;
        //CRYPT_BIT_BLOB              IssuerUniqueId;
        //CRYPT_BIT_BLOB              SubjectUniqueId;
        //DWORD                       cExtension;
        //PCERT_EXTENSION             rgExtension;

        WARNING_OUT(("dwVersion: %x", pC->pCertInfo->dwVersion));

        dumpbytes("SerialNumber",
            pC->pCertInfo->SerialNumber.pbData,
            pC->pCertInfo->SerialNumber.cbData );

        WARNING_OUT(("SignatureAlgorithm (name): %s",
            pC->pCertInfo->SignatureAlgorithm.pszObjId ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Issuer,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Issuer: %s", buf ));

        WARNING_OUT(("NotBefore: %x,%x",
            pC->pCertInfo->NotBefore.dwLowDateTime,
            pC->pCertInfo->NotBefore.dwHighDateTime ));
        WARNING_OUT(("NotAfter: %x,%x",
            pC->pCertInfo->NotAfter.dwLowDateTime,
            pC->pCertInfo->NotAfter.dwHighDateTime ));

        CertNameToStr( pC->dwCertEncodingType, &pC->pCertInfo->Subject,
            CERT_X500_NAME_STR, buf, sizeof(buf) );
        WARNING_OUT(("Subject: %s", buf ));

        WARNING_OUT(("<stuff omitted for now>"));

        dumpbytes("IssuerUniqueId",
            pC->pCertInfo->IssuerUniqueId.pbData,
            pC->pCertInfo->IssuerUniqueId.cbData );

        dumpbytes("SubjectUniqueId",
            pC->pCertInfo->SubjectUniqueId.pbData,
            pC->pCertInfo->SubjectUniqueId.cbData );

        WARNING_OUT(("cExtension: %x", pC->pCertInfo->cExtension ));
        WARNING_OUT(("<stuff omitted for now>"));

        i++;
    }
}
#endif // DUMPCERTS

TransportSecurityError SecurityInterface::InitializeCreds(
                        PCCERT_CONTEXT pCertContext )
{
    SECURITY_STATUS ss;
    SCHANNEL_CRED CredData;

    CredHandle hNewInboundCred;
    CredHandle hNewOutboundCred;

    //
    // Are we going to create new creds or just clean up?
    //

    if ( NULL != pCertContext )
    {
        ZeroMemory(&CredData, sizeof(CredData));
        CredData.dwVersion = SCHANNEL_CRED_VERSION;

        #ifdef FORCE_SSL3_NEGOTIATION
        CredData.grbitEnabledProtocols = SP_PROT_SSL3_CLIENT |
                                    SP_PROT_SSL3_SERVER;
        #endif // FORCE_SSL3_NEGOTIATION

        CredData.dwFlags = SCH_CRED_NO_SERVERNAME_CHECK |
                            SCH_CRED_NO_DEFAULT_CREDS |
                            SCH_CRED_MANUAL_CRED_VALIDATION;

        CredData.cCreds = 1;
        CredData.paCred = &pCertContext;

        // Acquire client and server credential handles

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_INBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewInboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (inbound) failed %lx", ss));
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        ss = pfnTable->AcquireCredentialsHandle (
            NULL,
            SZSECPKG,
            SECPKG_CRED_OUTBOUND,
            NULL,
            &CredData,
            NULL,
            NULL,
            &hNewOutboundCred,
            &tsExpiry );

        if ( SEC_E_OK != ss )
        {
            WARNING_OUT(("AcquireCredentialsHandle (outbound) failed %lx", ss));
            pfnTable->FreeCredentialHandle( &hNewInboundCred );
            LastError = TPRTSEC_SSPIFAIL;
            goto error;
        }

        // Empty the SSL cache
        if (pfn_SslEmptyCache)
        {
            pfn_SslEmptyCache();
        }

        // This member can be called even when we're already initialized, as
        // when the user chooses a different cert and we need to build new
        // credentials based on it. Clear out the old information as necessary:

        if ( NULL != m_pbEncodedCert )
        {
            delete m_pbEncodedCert;
            m_pbEncodedCert = NULL;
        }
    }

    if ( bInboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hInboundCredential );

    if ( bOutboundCredentialValid )
        pfnTable->FreeCredentialHandle ( &hOutboundCredential );

    if ( NULL != pCertContext )
    {
        hInboundCredential = hNewInboundCred;
        hOutboundCredential = hNewOutboundCred;
        bInboundCredentialValid = TRUE;
        bOutboundCredentialValid = TRUE;

        //
        // Save the cert name for later use
        //

        ASSERT( NULL == m_pbEncodedCert );
        m_pbEncodedCert = new BYTE[pCertContext->cbCertEncoded];

        if ( NULL == m_pbEncodedCert )
        {
            ERROR_OUT(("Error allocating data for encoded Cert"));
            goto error;
        }

        memcpy( m_pbEncodedCert, pCertContext->pbCertEncoded,
                                pCertContext->cbCertEncoded );

        ASSERT(pCertContext->cbCertEncoded);
        m_cbEncodedCert = pCertContext->cbCertEncoded;
    }
    else
    {
        bInboundCredentialValid = FALSE;
        bOutboundCredentialValid = FALSE;
    }

    LastError = TPRTSEC_NOERROR;

error:

    return LastError;
}

TransportSecurityError SecurityInterface::Initialize(VOID)
{
    TRACE_OUT(("Initializing security interface"));

    // Load the security provider DLL

    hSecurityDll = NmLoadLibrary("SCHANNEL",TRUE);

    if ( !hSecurityDll )
    {
        ERROR_OUT(("Loadlib schannel.dll failed"));
        LastError = TPRTSEC_NODLL;
        goto error;
    }

    // Get the initialization entrypoint
    pfnInitSecurityInterface = (INIT_SECURITY_INTERFACE)GetProcAddress(
                                hSecurityDll,
                                SECURITY_ENTRYPOINT );

    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SECURITY_ENTRYPOINT));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

    // Get the SSPI function table
    pfnTable = (*pfnInitSecurityInterface)();

    if ( NULL == pfnTable )
    {
        ERROR_OUT(("InitializeSecurityProvider failed"));
        LastError = TPRTSEC_SSPIFAIL;
        goto error;
    }

    pfn_SslEmptyCache = (PFN_SSL_EMPTY_CACHE)GetProcAddress(hSecurityDll, SZ_SSLEMPTYCACHE);
    if ( NULL == pfnInitSecurityInterface )
    {
        ERROR_OUT(("GetProcAddr %s failed", SZ_SSLEMPTYCACHE));
        LastError = TPRTSEC_NOENTRYPT;
        goto error;
    }

error:

    return LastError;
}

BOOL SecurityInterface::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    if ( NULL == m_pbEncodedCert)
    {
        WARNING_OUT(("GetUserCert: no encoded certname"));
        return FALSE;
    }

    ASSERT(m_cbEncodedCert > 0);

    if ( NULL == pInfo )
    {
        // Caller wants to know how much to allocate
        ASSERT(pcbInfo);
        *pcbInfo = m_cbEncodedCert;
        return TRUE;
    }

    if ( *pcbInfo < m_cbEncodedCert )
    {
        ERROR_OUT(("GetUserCert: insufficient buffer (%ld) %ld required",
            *pcbInfo, m_cbEncodedCert ));
        return FALSE;
    }

    memcpy ( (PCHAR)pInfo, m_pbEncodedCert, m_cbEncodedCert );
    *pcbInfo = m_cbEncodedCert;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// Security Context
///////////////////////////////////////////////////////////////////////////





SecurityContext::SecurityContext(PSecurityInterface pSI, LPCSTR szHostName) :
                    scstate(SECCTX_STATE_NEW),
                    fContinueNeeded(FALSE),
                    LastError(TPRTSEC_NOERROR),
                    bContextHandleValid(FALSE)
{
    ASSERT(pSI);
    ASSERT(szHostName);

    pSecurityInterface = pSI;

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = 0;

    if ( NULL != szHostName )
    {
        StringCchPrintf( szTargetName, CCHMAX(szTargetName), "%s:%x%x", szHostName,
            pSI->hOutboundCredential.dwUpper,
            pSI->hOutboundCredential.dwLower);
        TRACE_OUT(("SecurityContext::SecurityContext: targ %s",szTargetName));
    }
    ASSERT(pSecurityInterface);
}

SecurityContext::~SecurityContext(VOID)
{
    ASSERT(pSecurityInterface);
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        ASSERT(pSecurityInterface->pfnTable);

        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }
    if ( bContextHandleValid )
    {
        pSecurityInterface->pfnTable->DeleteSecurityContext(&hContext);
    }
}


TransportSecurityError SecurityContext::InitContextAttributes(VOID)
{
    SECURITY_STATUS ss;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes returned [%x]", ss));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    else
    {
        ASSERT (Sizes.cbHeader + Sizes.cbTrailer <= PROTOCOL_OVERHEAD_SECURITY);
        TRACE_OUT(("QueryContextAttributes returned header=%d trailer=%d",
                        Sizes.cbHeader, Sizes.cbTrailer));
    }

    #ifdef DEBUG //////////////////////////////////////////////////////////
    SecPkgContext_KeyInfo KeyInfo;

    ss = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo );
    if (ss != ERROR_SUCCESS)
    {
        ERROR_OUT(("QueryContextAttributes (KEY_INFO) failed %x", ss));
    }
    else
    {
        WARNING_OUT(("KEY INFO: Sign:%s Encrypt:%s Keysize:%d",
                    KeyInfo.sSignatureAlgorithmName,
                    KeyInfo.sEncryptAlgorithmName,
                    KeyInfo.KeySize ));
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sSignatureAlgorithmName );
        pSecurityInterface->pfnTable->FreeContextBuffer(
                    KeyInfo.sEncryptAlgorithmName );
    }

    #endif //DEBUG ///////////////////////////////////////////////////////

    return TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Initialize(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;
    DWORD dwReqFlags;

    TRACE_OUT(("SecurityContext Initialize (%x,%d)", pData, cbData));

    fContinueNeeded = FALSE;

    ASSERT(pSecurityInterface);
    ASSERT(SECCTX_STATE_INIT == scstate || SECCTX_STATE_NEW == scstate);

    if ( !pSecurityInterface->bOutboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no outbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    if ( SECCTX_STATE_INIT == scstate)
    {
        ASSERT(NULL != pData);
        ASSERT(0 != cbData);

        if ( NULL == pData || 0 == cbData )
        {
            ERROR_OUT(("Second initialize call with no data"));
            return LastError = TPRTSEC_INVALID_PARAMETER;
        }

        // Build the input buffer descriptor

        InputBufferDescriptor.cBuffers = 2;
        InputBufferDescriptor.pBuffers = InBuffers;
        InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

        InBuffers[0].BufferType = SECBUFFER_TOKEN;
        InBuffers[0].cbBuffer = cbData;
        InBuffers[0].pvBuffer = pData;

        InBuffers[1].BufferType = SECBUFFER_EMPTY;
        InBuffers[1].cbBuffer = 0;
        InBuffers[1].pvBuffer = NULL;
    }
    else
    {
        ASSERT(NULL == pData);
        ASSERT(0 == cbData);
    }

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    dwReqFlags = ISC_REQ_FLAGS;

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        if (SECCTX_STATE_INIT == scstate)
        {
            dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                                    InBuffers[0].cbBuffer);
        }
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }


    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

#ifdef ALLOW_NON_AUTHENTICATED_CLIENTS
    if ( SEC_I_INCOMPLETE_CREDENTIALS == ss )
    {
        WARNING_OUT(("InitializeSecurityContext:SEC_I_INCOMPLETE_CREDENTIALS"));

        dwReqFlags |= ISC_REQ_USE_SUPPLIED_CREDS;

        ss = pSecurityInterface->pfnTable->InitializeSecurityContext(
                &(pSecurityInterface->hOutboundCredential),
                SECCTX_STATE_INIT == scstate ?  &hContext : NULL,
                szTargetName, // TargetName
                dwReqFlags,
                0, // Reserved
                SECURITY_NATIVE_DREP,
                SECCTX_STATE_INIT == scstate ?  &InputBufferDescriptor : NULL,
                0,        // reserved
                &hContext,
                &OutputBufferDescriptor,
                &ContextAttributes,
                &Expiration );
    }
#endif // ALLOW_NON_AUTHENTICATED_CLIENTS

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss && NULL != OutBuffers[0].pvBuffer )
        {
            ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_INIT == scstate);

            TRACE_OUT(("Initialize: SEC_I_CONTINUE_NEEDED"));
            scstate = SECCTX_STATE_INIT;
        }
        else
        {
            ERROR_OUT(("Initialize failed: %x in state %d",(DWORD)ss,scstate));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {
        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("INITIALIZE OK"));

        scstate = SECCTX_STATE_INIT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::Accept(PBYTE pData, DWORD cbData)
{
    SECURITY_STATUS ss;

    fContinueNeeded = FALSE;

    ASSERT(SECCTX_STATE_NEW == scstate || SECCTX_STATE_ACCEPT == scstate);

    if ( !pSecurityInterface->bInboundCredentialValid )
    {
        WARNING_OUT(("SecurityContext::Initialize: no inbound cred"));
        return TPRTSEC_SSPIFAIL;
    }

    // Check to see if the required data is present
    if ( NULL == pData || 0 == cbData )
    {
        ERROR_OUT(("Accept: no data"));
        return LastError = TPRTSEC_INVALID_PARAMETER;
    }

    // Build the input buffer descriptor

    InputBufferDescriptor.cBuffers = 2;
    InputBufferDescriptor.pBuffers = InBuffers;
    InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].cbBuffer = cbData;
    InBuffers[0].pvBuffer = pData;

    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[1].cbBuffer = 0;
    InBuffers[1].pvBuffer = NULL;

    // Build the output buffer descriptor

    OutputBufferDescriptor.cBuffers = 1;
    OutputBufferDescriptor.pBuffers = OutBuffers;
    OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    // If there's a output buffer from a previous call, free it here
    if ( NULL != OutBuffers[0].pvBuffer )
    {
        pSecurityInterface->pfnTable->FreeContextBuffer(OutBuffers[0].pvBuffer);
    }

    while ( 1 )
    {
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer = 0;
        OutBuffers[0].pvBuffer = NULL;

        #ifdef DUMP
        dumpbytes("input token", (unsigned char *)InBuffers[0].pvBuffer,
                                        InBuffers[0].cbBuffer);
        #endif //DUMP

        ss = pSecurityInterface->pfnTable->AcceptSecurityContext(
                    &(pSecurityInterface->hInboundCredential),
                    SECCTX_STATE_NEW == scstate ?  NULL : &hContext,
                    &InputBufferDescriptor,
                    ASC_REQ_FLAGS,
                    SECURITY_NATIVE_DREP,
                    &hContext, // receives new context handle
                    &OutputBufferDescriptor, // receives output security token
                    &ContextAttributes,        // receives context attributes
                    &Expiration );            // receives expiration time

        // Some security providers don't process all the packet data
        // in one call to SCA - readjust the input buffers with the offset
        // returned in the extra buffer and iterate as necessary

        if (( SEC_I_CONTINUE_NEEDED == ss
            && NULL == OutBuffers[0].pvBuffer )
            && SECBUFFER_EXTRA == InBuffers[1].BufferType
            && 0 != InBuffers[1].cbBuffer )
        {
            InBuffers[0].pvBuffer = (PBYTE)(InBuffers[0].pvBuffer) +
                        ( InBuffers[0].cbBuffer - InBuffers[1].cbBuffer );
            InBuffers[0].BufferType = SECBUFFER_TOKEN;
            InBuffers[0].cbBuffer = InBuffers[1].cbBuffer;

            InBuffers[1].BufferType = SECBUFFER_EMPTY;
            InBuffers[1].cbBuffer = 0;
            InBuffers[1].pvBuffer = NULL;

            continue;
        }
        break;
    }

    #ifdef DUMP
    if ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss )
    {
        dumpbytes("output token",
            (unsigned char *)OutBuffers[0].pvBuffer,
            OutBuffers[0].cbBuffer);
    }
    #endif //DUMP

    if ( SEC_E_OK != ss )
    {
        if ( SEC_I_CONTINUE_NEEDED == ss )
        {
            TRACE_OUT(("Accept: SEC_I_CONTINUE_NEEDED"));

            scstate = SECCTX_STATE_ACCEPT;
        }
        else
        {
            ERROR_OUT(("AcceptSecurityContext failed: %x", (DWORD)ss));
            return LastError = TPRTSEC_SSPIFAIL;
        }
    }
    else
    {

        //  We're almost done,
        //  find the header and trailer sizes
        //

        if ( TPRTSEC_NOERROR != InitContextAttributes() )
            return LastError;

        if ( !Verify() )
            return LastError = TPRTSEC_SSPIFAIL;

        TRACE_OUT(("ACCEPT OK"));

        scstate = SECCTX_STATE_ACCEPT_COMPLETE;
    }

    // If there is an output buffer, set the flag to get it sent accross
    if ( ( SEC_E_OK == ss || SEC_I_CONTINUE_NEEDED == ss ) &&
                                NULL != OutBuffers[0].pvBuffer )
    {
        fContinueNeeded = TRUE;
    }

    bContextHandleValid = TRUE;
    return LastError = TPRTSEC_NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
// Encrypt()
//
// Description:
//    Encrypts a packet to be sent using SSL/PCT by calling SealMessage().
//
// Parameters:
//    phContext         - security context handle returned from InitiateSecConnection
//    pBufIn1, pBufIn2  - buffers to be encrypted
//    cbBufIn1,cbBufIn2    - lengths of buffers to be encrypted
//    ppBufOut          - allocated encrypted buffer, to be freed by caller
//    pcbBufOut         - length of encrypted buffer
//
// Return:
//    TransprotSecurityError
//
TransportSecurityError SecurityContext::Encrypt(
                  LPBYTE      pBufIn1,
                  UINT        cbBufIn1,
                  LPBYTE      pBufIn2,
                  UINT        cbBufIn2,
                  LPBYTE     *ppBufOut,
                  UINT        *pcbBufOut)
{
    SECURITY_STATUS           scRet = ERROR_SUCCESS;
    SecBufferDesc             Buffer;
    SecBuffer                 Buffers[4];
    UINT                      cbBufInTotal;
    LPBYTE                      pbTemp;

    // pBufIn2 and cbBufIn2 maybe NULL and 0, respectively.
    ASSERT(pBufIn1);
    ASSERT(cbBufIn1);
    ASSERT(ppBufOut);
    ASSERT(pcbBufOut);

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    *pcbBufOut = 0;
    cbBufInTotal = cbBufIn1 + cbBufIn2;

    // We allocate a buffer to hold the (larger) encrypted data.
    // This must be freed by the caller!
    // christts: The buffer will now also hold the X.224 header.
    if (NULL == (*ppBufOut = (LPBYTE)LocalAlloc(0, cbBufInTotal
                                + Sizes.cbHeader + Sizes.cbTrailer +
                                sizeof(X224_DATA_PACKET))))
        return LastError = TPRTSEC_NOMEM;

    pbTemp = *ppBufOut + sizeof(X224_DATA_PACKET);

    //
    // prepare data for SecBuffer
    //
    Buffers[0].pvBuffer = pbTemp;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_STREAM_HEADER;

    Buffers[1].pvBuffer = pbTemp + Sizes.cbHeader;
    // Copy the user's data
    CopyMemory(Buffers[1].pvBuffer, pBufIn1, cbBufIn1);
    if (NULL != pBufIn2) {
        CopyMemory((PVoid) ((PUChar) (Buffers[1].pvBuffer) + cbBufIn1),
                    pBufIn2, cbBufIn2);
    }
    Buffers[1].cbBuffer = cbBufInTotal;
    Buffers[1].BufferType = SECBUFFER_DATA;

    Buffers[2].pvBuffer = pbTemp + Sizes.cbHeader + cbBufInTotal;
    Buffers[2].cbBuffer = Sizes.cbTrailer;
    Buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;

    Buffers[3].pvBuffer = NULL;
    Buffers[3].cbBuffer = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    #ifdef DUMP
    dumpbytes("data BEFORE encryption", (PBYTE)Buffers[1].pvBuffer,
                    Buffers[1].cbBuffer);
    #endif // DUMP

    // Call the semi-documented SealMessage function (Reserved3)

    scRet = ((SEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved3)(
        &hContext, 0, &Buffer, 0);


    if (scRet != ERROR_SUCCESS)
    {
        //
        // Map the SSPI error.
        //
        ERROR_OUT(("SealMessage failed: %x", scRet));
        LocalFree(*ppBufOut);
        return LastError = TPRTSEC_SSPIFAIL;
    }

    // We also have to add the X.224 header.
    *pcbBufOut = cbBufInTotal + Sizes.cbHeader + Sizes.cbTrailer + sizeof(X224_DATA_PACKET);
    memcpy (*ppBufOut, g_X224Header, sizeof(X224_DATA_PACKET));
    AddRFCSize(*ppBufOut, *pcbBufOut);

    #ifdef TESTHACKS
    // Inject an error...
    if (GetAsyncKeyState(VK_CONTROL)&0x8000) {
        OutputDebugString("*** INJECTING ERROR IN OUTGOING PACKET ***\n\r");
        pbTemp[(*pcbBufOut - sizeof(X224_DATA_PACKET))/2] ^= 0x55;
    }
    #endif //TESTHACKS

    #ifdef DUMP
    dumpbytes("data AFTER encryption",  pbTemp, *pcbBufOut - sizeof(X224_DATA_PACKET));
    #endif // DUMP

    TRACE_OUT(("SealMessage returned Buffer = %p, EncryptBytes = %d, UnencryptBytes = %d", pbTemp,
                *pcbBufOut - sizeof(X224_DATA_PACKET), cbBufInTotal));

    return LastError = TPRTSEC_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
//
// Decrypt
//
// Description:
//    Decrypts a buffer received using SCHANNEL by calling UnsealMessage().
//
// Parameters:
//    pBuf      - buffer to be decrypted
//    cbBufIn       - length of buffer to be decrypted
//
TransportSecurityError SecurityContext::Decrypt( PBYTE pBuf, DWORD cbBuf)
{
    SecBufferDesc   Buffer;
    SecBuffer       Buffers[4];
    DWORD           scRet = ERROR_SUCCESS;
    SecBuffer * pDataBuffer;
    int i;

    LastError = TPRTSEC_SSPIFAIL;

    ASSERT(SECCTX_STATE_INIT_COMPLETE == scstate ||
            SECCTX_STATE_ACCEPT_COMPLETE == scstate);
    if (SECCTX_STATE_INIT_COMPLETE != scstate &&
        SECCTX_STATE_ACCEPT_COMPLETE != scstate)
        return LastError = TPRTSEC_INCOMPLETE_CONTEXT;

    ASSERT(!IsBadWritePtr(pBuf,cbBuf));

    #ifdef TESTHACKS
    // Inject an error...
    if ( GetAsyncKeyState(VK_SHIFT) & 0x8000 ) {
        OutputDebugString("*** INJECTING ERROR IN INCOMING PACKET ***\n\r");
        pBuf[cbBuf/2] ^= 0x55;
    }
    #endif //TESTHACKS

    //
    // prepare data the SecBuffer for a call to SSL/PCT decryption code.
    //
    Buffers[0].pvBuffer   = pBuf;
    Buffers[0].cbBuffer      = cbBuf;

    Buffers[0].BufferType = SECBUFFER_DATA;

    Buffers[1].pvBuffer   = NULL;
    Buffers[1].cbBuffer   = 0;
    Buffers[1].BufferType = SECBUFFER_EMPTY;
    Buffers[2].pvBuffer   = NULL;
    Buffers[2].cbBuffer   = 0;
    Buffers[2].BufferType = SECBUFFER_EMPTY;
    Buffers[3].pvBuffer   = NULL;
    Buffers[3].cbBuffer   = 0;
    Buffers[3].BufferType = SECBUFFER_EMPTY;

    Buffer.cBuffers = 4;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    // Call the semi-documented UnsealMessage function (Reserved4)

    #ifdef DUMP
    dumpbytes("data BEFORE decryption:", (PBYTE)Buffers[0].pvBuffer,
                                        Buffers[0].cbBuffer);
    #endif // DUMP

    scRet = ((UNSEAL_MESSAGE_FN)pSecurityInterface->pfnTable->Reserved4)(
        &hContext, &Buffer, 0, NULL);

    pDataBuffer = NULL;

    for( i=0; i<4; i++ )
    {
        if ( NULL == pDataBuffer && SECBUFFER_DATA == Buffers[i].BufferType )
        {
            pDataBuffer = &Buffers[i];
        }
    }

    if ( NULL == pDataBuffer )
    {
        ERROR_OUT(("Unseal: no data buffer found"));
        return LastError = TPRTSEC_SSPIFAIL;
    }

    #ifdef DUMP
    dumpbytes("data AFTER decryption:", (PBYTE)pDataBuffer->pvBuffer,
                                        pDataBuffer->cbBuffer);
    #endif // DUMP

    if (scRet != ERROR_SUCCESS)
    {
        ERROR_OUT(("UnsealMessage failed with [%x]", scRet));
        return LastError = TPRTSEC_SSPIFAIL;
    }
    return LastError = TPRTSEC_NOERROR;
}


TransportSecurityError SecurityContext::AdvanceState(PBYTE pIncomingData,
                                                    DWORD cbBuf)
{
    TRACE_OUT(("AdvanceState: state %d using data %x (%d)",
        scstate, pIncomingData, cbBuf ));

    switch ( scstate )
    {
        case SECCTX_STATE_INIT:
            if ( TPRTSEC_NOERROR != Initialize( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Initialize failed in INIT"));
                goto error;
            }
            break;

        case SECCTX_STATE_ACCEPT:
        case SECCTX_STATE_NEW:
            if ( TPRTSEC_NOERROR != Accept( pIncomingData, cbBuf ) )
            {
                WARNING_OUT(("AdvanceState: Accept failed in ACCEPT or NEW"));
                goto error;
            }
            break;

        case SECCTX_STATE_INIT_COMPLETE:
        case SECCTX_STATE_ACCEPT_COMPLETE:
        case SECCTX_STATE_ERROR:
        default:
            ERROR_OUT(("AdvanceState: called in unexpected state %d"));
            goto error;

    }
    return LastError = TPRTSEC_NOERROR;

error:

    scstate = SECCTX_STATE_ERROR;
    return LastError;
}

#define CHECKFLAGS  (CERT_STORE_REVOCATION_FLAG |\
                CERT_STORE_SIGNATURE_FLAG |\
                CERT_STORE_TIME_VALIDITY_FLAG)

BOOL SecurityContext::Verify(VOID)
{
    BOOL fRet = TRUE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL, pIssuerCert = NULL, pCACert = NULL;
    DWORD dwFlags;
    HCERTSTORE hStore = NULL;
    HCERTSTORE hCAStore = NULL;
    RegEntry rePol(POLICIES_KEY, HKEY_LOCAL_MACHINE);
    CHAR * pIssuer = NULL;

    ASSERT( NULL != pSecurityInterface );

    // Get the subject cert context
    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes (REMOTE_CERT_CONTEXT) failed"));
        goto error;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto error;
    }

    // Open the root store for certificate verification
    hStore = CertOpenSystemStore(0, "Root");

    if( NULL == hStore )
    {
        ERROR_OUT(("Couldn't open root certificate store"));
        goto error;
    }

    dwFlags = CHECKFLAGS;

    // Get the issuer of this cert

    pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCert,
                        NULL,
                        &dwFlags );

    // If the issuer of the certificate cannot be found in the root store,
    // check the CA store iteratively until we work our way back to a root
    // certificate

    pCACert = pCert;

    while ( NULL == pIssuerCert )
    {
        PCCERT_CONTEXT pTmpCert;

        if ( NULL == hCAStore )
        {
            hCAStore = CertOpenSystemStore(0, "CA");

            if ( NULL == hCAStore )
            {
                ERROR_OUT(("Couldn't open CA certificate store"));
                goto error;
            }
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pTmpCert = CertGetIssuerCertificateFromStore(
                        hCAStore,
                        pCACert,
                        NULL,
                        &dwFlags );

        if ( NULL == pTmpCert )
        {
            TRACE_OUT(("Issuer not found in CA store either"));
            break;
        }

        if ( pCACert != pCert )
            CertFreeCertificateContext(pCACert);
        pCACert = pTmpCert;

        if ((( CERT_STORE_REVOCATION_FLAG & dwFlags ) &&
             !( CERT_STORE_NO_CRL_FLAG & dwFlags )) ||
             ( CERT_STORE_SIGNATURE_FLAG & dwFlags ) ||
             ( CERT_STORE_TIME_VALIDITY_FLAG & dwFlags ))
        {
            TRACE_OUT(("Problem with issuer in CA store: %x", dwFlags));
            break;
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pIssuerCert = CertGetIssuerCertificateFromStore(
                        hStore,
                        pCACert,
                        NULL,
                        &dwFlags );

    }

    if ( pCACert != pCert )
        CertFreeCertificateContext ( pCACert );

    if ( NULL == pIssuerCert )
    {
        WARNING_OUT(("Verify: Can't find issuer in store"));
    }

    // Check certificate

    if ( NULL != pIssuerCert && 0 != dwFlags )
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            WARNING_OUT(("Verify: Signature invalid"));
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            WARNING_OUT(("Verify: Cert expired"));
        }
        if ( dwFlags & CERT_STORE_REVOCATION_FLAG )
        {
            if (!(dwFlags & CERT_STORE_NO_CRL_FLAG))
            {
                WARNING_OUT(("Verify: Cert revoked"));
            }
            else
            {
                // We have no CRL for this issuer, do not
                // treat as revoked by default:
                dwFlags &= ~CERT_STORE_REVOCATION_FLAG;
            }
        }
    }

    //
    // Check for no-incomplete-certs policy
    //

    if (( NULL == pIssuerCert || ( 0 != ( CHECKFLAGS & dwFlags ))) &&
        rePol.GetNumber( REGVAL_POL_NO_INCOMPLETE_CERTS,
                                DEFAULT_POL_NO_INCOMPLETE_CERTS ))
    {
        WARNING_OUT(("Verify: policy prevents cert use"));
        fRet = FALSE;
        goto error;
    }

    //
    // Is there a mandatory issuer?
    //

    if ( lstrlen(rePol.GetString( REGVAL_POL_ISSUER )))
    {
        DWORD cbIssuer;

        //
        // Get the issuer information
        //

        cbIssuer = CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            NULL, 0);

        if ( 0 == cbIssuer )
        {
            ERROR_OUT(("GetUserInfo: no issuer string"));
            fRet = FALSE;
            goto error;
        }

        pIssuer = new CHAR[cbIssuer + 1];

        if ( NULL == pIssuer )
        {
            ERROR_OUT(("GetUserInfo: error allocating issuer name"));
        }

        if ( 0 >= CertNameToStr (
                            pCert->dwCertEncodingType,
                            &pCert->pCertInfo->Issuer,
                            CERT_FORMAT_FLAGS,
                            pIssuer, cbIssuer+1))
        {
            ERROR_OUT(("GetUserInfo: error getting issuer string"));
            fRet = FALSE;
            goto error;
        }

        if ( lstrcmp ( rePol.GetString(REGVAL_POL_ISSUER),
            pIssuer ))
        {
            WARNING_OUT(("Issuer (%s) didn't match policy (%s)",
                pIssuer, rePol.GetString(REGVAL_POL_ISSUER)));
            fRet = FALSE;
        }
    }

error:

    if ( NULL != hStore )
    {
        CertCloseStore(hStore, 0);
    }

    if ( NULL != hCAStore )
    {
        CertCloseStore(hCAStore, 0);
    }

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    if ( NULL != pIssuerCert )
    {
        CertFreeCertificateContext ( pIssuerCert );
    }

    if ( NULL != pIssuer )
    {
        delete [] pIssuer;
    }

    return fRet;
}


BOOL SecurityContext::GetUserCert(PBYTE pInfo, PDWORD pcbInfo)
{
    BOOL fRet = FALSE;
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL;

    ASSERT( NULL != pSecurityInterface );

    //
    // Get the certificate from the context
    //

    sc = pSecurityInterface->pfnTable->QueryContextAttributes(&hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        (PVOID)&pCert );

    if ( SEC_E_OK != sc )
    {
        ERROR_OUT(("QueryContextAttributes failed"));
        goto cleanup;
    }

    if ( NULL == pCert )
    {
        // The caller is not authenticated
        WARNING_OUT(("No remote cred data"));
        goto cleanup;
    }


    if ( NULL != pInfo && *pcbInfo >= pCert->cbCertEncoded )
    {
        memcpy ( pInfo, pCert->pbCertEncoded, pCert->cbCertEncoded );
    }
    *pcbInfo = pCert->cbCertEncoded;

    fRet = TRUE;

cleanup:

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\tprtctrl.h ===
/*	Tprtctrl.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the transport for Winsock over TCP.
 *
 *		This module controls making and breaking socket connections. When the
 *		transport creates or detects a connection, Transprt.cpp is notified.
 *		It then instantiates a connection object which tracks the socket until
 *		it is destroyed.  The TCP stack notifies Transprt.cpp when a socket
 *		connection is up and running. It also notifies us if the link is broken
 *		for some reason. As a result, the Tprtctrl module will notify the user
 *		of new or broken connections.
 *
 *		When the user wants to make a data request of a specific transport
 *		connection, this module maps the connection id to a socket number.  The
 *		data request is passed on to TCP.  Data Indications are passed
 *		to the user by ReadRequest().
 *
 *	USER CALLBACKS:
 *		The user communicates with this DLL by making calls directly to the
 *		DLL.  The DLL communicates with the user by issuing callbacks.
 *		The TInitialize() call accepts as a parameter, a callback address and
 *		a user defined variable.  When a significant event occurs in the DLL,
 *		the DLL will jump to the callback address.  The first parameter of
 *		the callback is the message.  This could be a CONNECT_INDICATION, 
 *		DISCONNECT_INDICATION, or any number of significant events.  The
 *		second parameter is a message specific parameter.  The third 
 *		parameter is the user defined variable that was passed in during
 *		the TInitialize() function.  See the MCATTPRT.h interface file
 *		for a complete description of the callback messages.
 *
 *	MAKING A CALL:
 *		After the initialization has been done, the user will eventually,
 *		want to attempt a connection. The user issues a TConnectRequest() call 
 *		with the IP address of the remote location. The connection request 
 *		is passed on to the Winsock layer. It eventually issues FD_CONNECT to
 *		our window to say that the connection was successful.
 *
 *	RECEIVING A CALL:
 *		If we receive a call from a remote location, Winsock notifies
 *		us with FD_ACCEPT.  We then create a new connection object
 *		associated with the new socket.
 *
 *	SENDING PACKETS:
 *		To send data to the remote location, use the DataRequest() function
 *		call.  This module will pass the packet to the socket that it is
 *		associated with.  The send may actually occur after the call has 
 *		returned to the user.
 *
 *	RECEIVING PACKETS:
 *		The user receives packets by DATA_INDICATION callbacks.  When Winsock
 *		notifies us with a FD_READ, we issue a recv() to receive any new
 *		packets. If a packet is complete, we issue a DATA_INDICATION
 *		callback to the user with the socket handle, the address 
 *		of the packet, and the packet length.
 *
 *	DISCONNECTING A TRANSPORT:
 *		To disconnect a transport connection, use the DisconnectRequest()
 *		function.  After the link has been brought down, we perform a 
 *		callback to the user to verify the disconnect.
 *
 */
#ifndef	_TRANSPORT_CONTROLLER_
#define	_TRANSPORT_CONTROLLER_

/* Header for a RFC1006 packet */
typedef struct _rfc_tag
{
	UChar	Version;		/* Should be RFC1006_VERSION_NUMBER (3) */
	UChar	Reserved;		/* Must be 0x00 */
	UChar	msbPacketSize;	/* msb of packet size, including RFC header */
	UChar	lsbPacketSize;	/* lsb of packet size, including RFC header */
} RFC_HEADER;

/* Header for X224 data packet */
typedef struct _data_packet_tag
{
	RFC_HEADER	rfc;		/* RFC1006 packet header */
	UChar	HeaderSize;		/* Must be 0x02, for data packets */
	UChar	PacketType;		/* Must be DATA_PACKET, for data packets */
	UChar	FinalPacket;	/* EOT_BIT or 0 */
} X224_DATA_PACKET;

#include "socket.h"

/* Connection Info (used for both CONNECTION_REQUEST and CONNECTION_CONFIRM) */
typedef struct _connect_common_tag
{
	UChar	PacketType;		/* CONNECTION_REQUEST_PACKET or CONFIRM_PACKET */
	UChar	msbDest;		/* msb of destination-side (answering) socket id */
	UChar	lsbDest;		/* lsb of destination-side (answering) socket id */
	UChar	msbSrc;			/* msb of source-side (initiating) socket id */
	UChar	lsbSrc;			/* lsb of source-side (initiating) socket id */
	UChar	DataClass;		/* Must be 0x00 */
} X224_CONNECT_COMMON;

/* Transport variable field info type and size. */
typedef struct _t_variable_field_info
{
	UChar	InfoType;
	UChar	InfoSize;
} X224_VARIABLE_INFO;

/* TPDU Arbitration Info (not used with CONNECTION_CONFIRM) */
typedef struct _tpdu_info_tag
{
	UChar	InfoType;		/* Must be TPDU_SIZE (192) */
	UChar	InfoSize;		/* Must be 1 */
	UChar	Info;			/* Requested PDU Size (default: 10, or 1K bytes) */
} X224_TPDU_INFO;

/* Minimal Connection Request/Confirm packet */
typedef struct _connect_tag
{
	RFC_HEADER			rfc;	/* RFC1006 packet header */
	UChar	HeaderSize;			
	X224_CONNECT_COMMON	conn;	/* Connection Info */
} X224_CONNECT;

typedef X224_CONNECT X224_CR_FIXED;
typedef X224_CONNECT X224_CC_FIXED;

typedef struct _disconnect_info_tag
{
	UChar	PacketType;		/* Must be DISCONNECT_REQUEST_PACKET */
	UChar	msbDest;		
	UChar	lsbDest;
	UChar	msbSrc;
	UChar	lsbSrc;
	UChar	reason;			/* DR Reason Code */
} X224_DISCONN;

typedef struct _disconnect_request_fixed
{
    RFC_HEADER      rfc;
    UChar           HeaderSize;
    X224_DISCONN    disconn;
} X224_DR_FIXED;

#define X224_SIZE_OFFSET		2

#define	UNK					0	// Used to initialize fields in static
								// data structures that will be initialized
								// later.

/* 2^DEFAULT_TPDU_SIZE is the default X224 packet size we request */
#define DEFAULT_TPDU_SIZE		13	/* 2^13 is 8K packet size */
#define	LOWEST_TPDU_SIZE		7	/* 2^7 is 128 bytes */
#define	HIGHEST_TPDU_SIZE		20	/* 2^20 is ... too big */
#define	DEFAULT_MAX_X224_SIZE	(1 << DEFAULT_TPDU_SIZE)

/* Function definitions */
TransportError	ConnectRequest (TransportAddress transport_address, BOOL fSecure, PTransportConnection pXprtConn);
BOOL			ConnectResponse (TransportConnection XprtConn);
void			DisconnectRequest (TransportConnection XprtConn, ULONG ulNotify);
TransportError	DataRequest (	TransportConnection	XprtConn,
								PSimplePacket	packet);
void 			SendX224ConnectRequest (TransportConnection);
void			EnableReceiver (Void);
void			PurgeRequest (TransportConnection	XprtConn);
void 			AcceptCall (TransportType);
void 			AcceptCall (TransportConnection);
void 			ReadRequest(TransportConnection);
void            ReadRequestEx(TransportConnection);
TransportError	FlushSendBuffer(PSocket pSocket, LPBYTE buffer, UINT length);
#ifdef TSTATUS_INDICATION
Void 			SendStatusMessage(	PChar RemoteAddress,
					  				TransportState state,
					  				UInt message_id);
#endif
void			QoSLock(Void);
void			QoSUnlock(Void);
void 			ShutdownAndClose (TransportConnection, BOOL fShutdown, int how );
TransportError 	GetLocalAddress(TransportConnection	XprtConn,
								TransportAddress	address,
								int	*	size);
								
/* The TCP message window procedure (processes all Windows messages) */
LRESULT 		WindowProcedure (HWND, UINT, WPARAM, LPARAM);

/* RFC definitions */
#define	RFC1006_VERSION_NUMBER		3
#define RFC1006_VERSION_SHIFTED_LEFT	0x03000000L		/* Optimizes AddRFCHeader */

/* Packet types */
#define	CONNECTION_REQUEST_PACKET	0xe0
#define	CONNECTION_CONFIRM_PACKET	0xd0
#define	DISCONNECT_REQUEST_PACKET	0x80
#define	ERROR_PACKET				0x70
#define	DATA_PACKET					0xf0

#define	TPDU_SIZE					0xc0
#define T_SELECTOR					0xc1
#define T_SELECTOR_2                                    0xc2
/* X224 definitions */
#define	EOT_BIT						0x80

/* Macro to fill-in RFC header at specified buffer location */
#define	AddRFCSize(ptr, size)	{ \
	ASSERT((size) < 65536L ); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET] = (BYTE) ((size) >> 8); \
	((LPBYTE) (ptr))[X224_SIZE_OFFSET + 1] = (BYTE) (size); }

#endif	/* _TRANSPORT_CONTROLLER_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\translat.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	translat.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Reason and Result Translator
 *		Class. 
 *
 *	Caveats:
 *		None. 
 *
 *	Author:
 *		jbo
 */


#include "pdutypes.h"
#include "translat.h"


/*
 *	TranslateGCCResultToCreateResult ()
 *
 *	Public Function Description:
 */
ConferenceCreateResult
TranslateGCCResultToCreateResult ( GCCResult gcc_result )
{
	ConferenceCreateResult	create_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		create_result = CCRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		create_result = CCRS_USER_REJECTED;
		break;

	case GCC_RESULT_RESOURCES_UNAVAILABLE:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;

	case GCC_RESULT_SYMMETRY_BROKEN:
		create_result = REJECTED_FOR_SYMMETRY_BREAKING;
		break;

	case GCC_RESULT_LOCKED_NOT_SUPPORTED:
		create_result = LOCKED_CONFERENCE_NOT_SUPPORTED;
		break;

	default:
		create_result = RESOURCES_NOT_AVAILABLE;
		break;
	}

	return (create_result);
}


/*
 *	TranslateGCCResultToQueryResult ()
 *
 *	Public Function Description:
 */
ConferenceQueryResult
TranslateGCCResultToQueryResult ( GCCResult gcc_result )
{
	ConferenceQueryResult	query_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		query_result = CQRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		query_result = CQRS_USER_REJECTED;
		break;

	default:
		query_result = CQRS_USER_REJECTED;
		break;
	}

	return (query_result);
}


/*
 *	TranslateGCCResultToJoinResult ()
 *
 *	Public Function Description:
 */
ConferenceJoinResult
TranslateGCCResultToJoinResult ( GCCResult gcc_result )
{
	ConferenceJoinResult	join_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	join_result = CJRS_RESULT_SUCCESS;
        break;

	case GCC_RESULT_USER_REJECTED:
    	join_result = CJRS_USER_REJECTED;
        break;

    case GCC_RESULT_INVALID_CONFERENCE:
    	join_result = INVALID_CONFERENCE;
        break;

    case GCC_RESULT_INVALID_PASSWORD:
    	join_result = INVALID_PASSWORD;
        break;

    case GCC_RESULT_INVALID_CONVENER_PASSWORD:
    	join_result = INVALID_CONVENER_PASSWORD;
    	break;

    case GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED:
    	join_result = CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case GCC_RESULT_INVALID_CHALLENGE_RESPONSE:
    	join_result = INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	join_result = INVALID_CONFERENCE;
    	break;
    }

    return (join_result);
}


/*
 *	TranslateGCCResultToInviteResult ()
 *
 *	Public Function Description:
 */
ConferenceInviteResult
TranslateGCCResultToInviteResult ( GCCResult gcc_result )
{
	ConferenceInviteResult	invite_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		invite_result = CIRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_USER_REJECTED:
		invite_result = CIRS_USER_REJECTED;
		break;

	default:
		invite_result = CIRS_USER_REJECTED;
		break;
	}

	return (invite_result);
}


/*
 *	TranslateGCCResultToRegistryResp ()
 *
 *	Public Function Description:
 */
RegistryResponseResult
TranslateGCCResultToRegistryResp ( GCCResult gcc_result )
{
	RegistryResponseResult			registry_response_result;

    switch (gcc_result)
    {
	case GCC_RESULT_SUCCESSFUL:
    	registry_response_result = RRRS_RESULT_SUCCESSFUL;
        break;

    case GCC_RESULT_INDEX_ALREADY_OWNED:
    	registry_response_result = BELONGS_TO_OTHER;
    	break;

    case GCC_RESULT_REGISTRY_FULL:
    	registry_response_result = TOO_MANY_ENTRIES;
        break;

    case GCC_RESULT_INCONSISTENT_TYPE:
    	registry_response_result = INCONSISTENT_TYPE;
        break;

    case GCC_RESULT_ENTRY_DOES_NOT_EXIST:
    	registry_response_result = ENTRY_NOT_FOUND;
        break;

    case GCC_RESULT_ENTRY_ALREADY_EXISTS:
    	registry_response_result = ENTRY_ALREADY_EXISTS;
        break;

    case GCC_RESULT_INVALID_REQUESTER:
		registry_response_result = RRRS_INVALID_REQUESTER;
        break;

    default:
		registry_response_result = RRRS_INVALID_REQUESTER;//jbo default???????
    	break;
    }

    return (registry_response_result);
}


/*
 *	TranslateCreateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateCreateResultToGCCResult ( ConferenceCreateResult create_result )
{
	GCCResult	gcc_result;
  
	switch (create_result)
	{
	case CCRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CCRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	case RESOURCES_NOT_AVAILABLE:
		gcc_result = GCC_RESULT_RESOURCES_UNAVAILABLE;
		break;

	case REJECTED_FOR_SYMMETRY_BREAKING:
		gcc_result = GCC_RESULT_SYMMETRY_BROKEN;
		break;

	case LOCKED_CONFERENCE_NOT_SUPPORTED:
		gcc_result = GCC_RESULT_LOCKED_NOT_SUPPORTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateQueryResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult 
TranslateQueryResultToGCCResult ( ConferenceQueryResult query_result )
{
	GCCResult	gcc_result;
  
	switch (query_result)
	{
	case CQRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CQRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateJoinResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateJoinResultToGCCResult ( ConferenceJoinResult join_result )
{
	GCCResult	gcc_result;

    switch (join_result)
    {
	case CJRS_RESULT_SUCCESS:
    	gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

    case CJRS_USER_REJECTED:
    	gcc_result = GCC_RESULT_USER_REJECTED;
        break;

    case INVALID_CONFERENCE:
		gcc_result = GCC_RESULT_INVALID_CONFERENCE;
        break;

    case INVALID_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_PASSWORD;
        break;

    case INVALID_CONVENER_PASSWORD:
    	gcc_result = GCC_RESULT_INVALID_CONVENER_PASSWORD;
    	break;

    case CHALLENGE_RESPONSE_REQUIRED:
    	gcc_result = GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED;
    	break;

    case INVALID_CHALLENGE_RESPONSE:
    	gcc_result = GCC_RESULT_INVALID_CHALLENGE_RESPONSE;
    	break;

    default:
    	gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
    	break;
    }

    return (gcc_result);
}


/*
 *	TranslateInviteResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateInviteResultToGCCResult ( ConferenceInviteResult invite_result )
{
	GCCResult	gcc_result;
  
	switch (invite_result)
	{
	case CIRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;
		
	case CIRS_USER_REJECTED:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;

	default:
		gcc_result = GCC_RESULT_USER_REJECTED;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateRegistryRespToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateRegistryRespToGCCResult ( RegistryResponseResult response_result )
{
	GCCResult 	gcc_result;
	
	switch (response_result)
    {
	case RRRS_RESULT_SUCCESSFUL:
		gcc_result = GCC_RESULT_SUCCESSFUL;
        break;

	case BELONGS_TO_OTHER:
		gcc_result = GCC_RESULT_INDEX_ALREADY_OWNED;
       	break;

	case TOO_MANY_ENTRIES:
		gcc_result = GCC_RESULT_REGISTRY_FULL;
        break;

	case INCONSISTENT_TYPE:
		gcc_result = GCC_RESULT_INCONSISTENT_TYPE;
    	break;

    case ENTRY_NOT_FOUND:
    	gcc_result = GCC_RESULT_ENTRY_DOES_NOT_EXIST;
        break;

    case ENTRY_ALREADY_EXISTS:
    	gcc_result = GCC_RESULT_ENTRY_ALREADY_EXISTS;
        break;

    case RRRS_INVALID_REQUESTER:
    	gcc_result = GCC_RESULT_INVALID_REQUESTER;
        break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;//jbo default ???????
		break;
     }

	return (gcc_result);
}


/*
 *	TranslateTerminateRqReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateRqReasonToGCCReason ( ConferenceTerminateRequestReason reason )
{
	GCCReason	gcc_reason;

	switch (reason)
	{
	case CTRQ_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTRQ_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_ERROR_TERMINATION;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToTerminateRqReason ()
 *
 *	Public Function Description:
 */
ConferenceTerminateRequestReason
TranslateGCCReasonToTerminateRqReason ( GCCReason gcc_reason )
{
	ConferenceTerminateRequestReason	reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTRQ_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTRQ_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTRQ_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateEjectIndReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateEjectIndReasonToGCCReason ( ConferenceEjectIndicationReason eject_reason )
{
	GCCReason	gcc_reason;

	switch (eject_reason)
	{
	case CEIN_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case HIGHER_NODE_DISCONNECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_DISCONNECTED;
		break;

	case HIGHER_NODE_EJECTED:
		gcc_reason = GCC_REASON_HIGHER_NODE_EJECTED;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectIndicationReason
TranslateGCCReasonToEjectInd ( GCCReason gcc_reason )
{
	ConferenceEjectIndicationReason	eject_reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		eject_reason = CEIN_USER_INITIATED;
		break;

	case GCC_REASON_HIGHER_NODE_DISCONNECTED:
		eject_reason = HIGHER_NODE_DISCONNECTED;
		break;

	case GCC_REASON_HIGHER_NODE_EJECTED:
		eject_reason = HIGHER_NODE_EJECTED;
		break;

	default:
		eject_reason = CEIN_USER_INITIATED;
		break;
	}

	return (eject_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateEjectResultToGCCResult ( ConferenceEjectResult eject_result )
{
	GCCResult	gcc_result;

	switch (eject_result)
	{
	case CERS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CERS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case CERS_INVALID_NODE:
		gcc_result = GCC_RESULT_INVALID_NODE;
		break;

	default:
		gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceEjectResult
TranslateGCCResultToEjectResult ( GCCResult gcc_result )
{
	ConferenceEjectResult	eject_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		eject_result = CERS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		eject_result = CERS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NODE:
		eject_result = CERS_INVALID_NODE;
		break;

	default:
		eject_result = CERS_INVALID_NODE;
		break;
	}

	return (eject_result);
}


/*
 *	TranslateTerminateInReasonToGCCReason ()
 *
 *	Public Function Description:
 */
GCCReason
TranslateTerminateInReasonToGCCReason ( ConferenceTerminateIndicationReason reason )
{
	GCCReason		gcc_reason;

	switch (reason)
	{
	case CTIN_REASON_USER_INITIATED:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;

	case CTIN_TIMED_CONFERENCE_TERMINATE:
		gcc_reason = GCC_REASON_TIMED_TERMINATION;
		break;

	default:
		gcc_reason = GCC_REASON_USER_INITIATED;
		break;
	}

	return (gcc_reason);
}


/*
 *	TranslateGCCReasonToEjectInd ()
 *
 *	Public Function Description:
 */
ConferenceTerminateIndicationReason
TranslateGCCReasonToTerminateInReason ( GCCReason gcc_reason )
{
	ConferenceTerminateIndicationReason		reason;

	switch (gcc_reason)
	{
	case GCC_REASON_USER_INITIATED:
		reason = CTIN_REASON_USER_INITIATED;
		break;

	case GCC_REASON_TIMED_TERMINATION:
		reason = CTIN_TIMED_CONFERENCE_TERMINATE;
		break;

	default:
		reason = CTIN_REASON_USER_INITIATED;
		break;
	}

	return (reason);
}


/*
 *	TranslateGCCResultToTerminateResult ()
 *
 *	Public Function Description:
 */
ConferenceTerminateResult
TranslateGCCResultToTerminateResult ( GCCResult gcc_result )
{
	ConferenceTerminateResult	result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		result = CTRS_RESULT_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		result = CTRS_INVALID_REQUESTER;
		break;

	default:
		result = CTRS_INVALID_REQUESTER;
		break;
	}

	return (result);
}


/*
 *	TranslateTerminateResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateTerminateResultToGCCResult ( ConferenceTerminateResult result )
{
	GCCResult	gcc_result;

	switch (result)
	{
	case CTRS_RESULT_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CTRS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}


/*
 *	TranslateGCCResultToLockResult ()
 *
 *	Public Function Description:
 */
ConferenceLockResult
TranslateGCCResultToLockResult ( GCCResult gcc_result )
{
	ConferenceLockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CLRS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_LOCKED:
		return_value = CLRS_ALREADY_LOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CLRS_INVALID_REQUESTER;
		break;

	default:
		return_value = CLRS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateLockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateLockResultToGCCResult ( ConferenceLockResult result )
{
	GCCResult	return_value;

	switch (result)
	{
	case CLRS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CLRS_ALREADY_LOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_LOCKED;
		break;

	case CLRS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToUnlockResult ()
 *
 *	Public Function Description:
 */
ConferenceUnlockResult
TranslateGCCResultToUnlockResult ( GCCResult gcc_result )
{
	ConferenceUnlockResult	return_value;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		return_value = CURS_SUCCESS;
		break;

	case GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED:
		return_value = CURS_ALREADY_UNLOCKED;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		return_value = CURS_INVALID_REQUESTER;
		break;

	default:
		return_value = CURS_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateUnlockResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateUnlockResultToGCCResult ( ConferenceUnlockResult result )
{
	GCCResult		return_value;

	switch (result)
	{
	case CURS_SUCCESS:
		return_value = GCC_RESULT_SUCCESSFUL;
		break;

	case CURS_ALREADY_UNLOCKED:
		return_value = GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED;
		break;

	case CURS_INVALID_REQUESTER:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;

	default:
		return_value = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return return_value;
}


/*
 *	TranslateGCCResultToAddResult ()
 *
 *	Public Function Description:
 */
ConferenceAddResult
TranslateGCCResultToAddResult ( GCCResult gcc_result )
{
	ConferenceAddResult	add_result;

	switch (gcc_result)
	{
	case GCC_RESULT_SUCCESSFUL:
		add_result = CARS_SUCCESS;
		break;

	case GCC_RESULT_INVALID_REQUESTER:
		add_result = CARS_INVALID_REQUESTER;
		break;

	case GCC_RESULT_INVALID_NETWORK_TYPE:
		add_result = INVALID_NETWORK_TYPE;
		break;

	case GCC_RESULT_INVALID_NETWORK_ADDRESS:
		add_result = INVALID_NETWORK_ADDRESS;
		break;

	case GCC_RESULT_ADDED_NODE_BUSY:
		add_result = ADDED_NODE_BUSY;
		break;

	case GCC_RESULT_NETWORK_BUSY:
		add_result = NETWORK_BUSY;
		break;

	case GCC_RESULT_NO_PORTS_AVAILABLE:
		add_result = NO_PORTS_AVAILABLE;
		break;

	case GCC_RESULT_CONNECTION_UNSUCCESSFUL:
		add_result = CONNECTION_UNSUCCESSFUL;
		break;

	default:
		add_result = CARS_INVALID_REQUESTER;
		break;
	}

	return (add_result);
}


/*
 *	TranslateAddResultToGCCResult ()
 *
 *	Public Function Description:
 */
GCCResult
TranslateAddResultToGCCResult ( ConferenceAddResult add_result )
{
	GCCResult	gcc_result;

	switch (add_result)
	{
	case CARS_SUCCESS:
		gcc_result = GCC_RESULT_SUCCESSFUL;
		break;

	case CARS_INVALID_REQUESTER:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;

	case INVALID_NETWORK_TYPE:
		gcc_result = GCC_RESULT_INVALID_NETWORK_TYPE;
		break;

	case INVALID_NETWORK_ADDRESS:
		gcc_result = GCC_RESULT_INVALID_NETWORK_ADDRESS;
		break;

	case ADDED_NODE_BUSY:
		gcc_result = GCC_RESULT_ADDED_NODE_BUSY;
		break;

	case NETWORK_BUSY:
		gcc_result = GCC_RESULT_NETWORK_BUSY;
		break;

	case NO_PORTS_AVAILABLE:
		gcc_result = GCC_RESULT_NO_PORTS_AVAILABLE;
		break;

	case CONNECTION_UNSUCCESSFUL:
		gcc_result = GCC_RESULT_CONNECTION_UNSUCCESSFUL;
		break;

	default:
		gcc_result = GCC_RESULT_INVALID_REQUESTER;
		break;
	}

	return (gcc_result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\tptif.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*
 *	tptif.cpp
 *
 *	Copyright (c) 1996-1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the implementation module for the TCP TransportInterface class.
 *		It implements the Win32 TCP transport stack.
 *		This file contains all of the public functions needed to use
 *		the TCP stack.
 *
 *		It uses owner callbacks to forward transport events upward to interested
 *		parties.  It has one default callback to handle
 *		events for unregistered transport connections (such as incoming connect
 *		indications).  It also maintains an array of callbacks so that events
 *		for a particular transport connection can be routed appropriately.
 *
 *		X.214 INTERFACE
 *	
 *		You will notice that many of the entry points to this DLL were taken
 *		from the X.214 service definition.  These entry points are consistent
 *		with the DataBeam Transport DLLs.  This gives the user application
 *		a consistent interface.
 *
 *  Protected Instance Variables:
 *		m_TrnsprtConnCallbackList2
 *			This is the dictionary containg the addresses of the callbacks for
 *			each transport connection.
 *
 *	Private Member Functions:
 *		CreateConnectionCallback
 *			This function creates a new entry in the callback list.
 *		ConnectIndication
 *			Handles TRANSPORT_CONNECT_INDICATION messages from the transport
 *			layer.
 *		ConnectConfirm
 *			Handles TRANSPORT_CONNECT_CONFIRM messages from the transport
 *			layer.
 *		DisconnectIndication
 *			Handles TRANSPORT_DISCONNECT_INDICATION messages from the transport
 *			layer.
 *		DataIndication
 *			Handles TRANSPORT_DATA_INDICATION messages from the transport
 *			layer.
 *
 *	Global Variables:
 *
 *	Transport					- Address of this object (used by tprtctrl.cpp)
 *	g_pSocketList    			- List of all active connection structures.
 *	Listen_Socket				- The listening socket number.
 *
 *	Caveats:
 *		This code is NOT portable.  It is very specific to the Windows
 *		operating system.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	External Interfaces
 */

#include <nmqos.h>
#include <t120qos.h>
#include <tprtntfy.h>
#include "plgxprt.h"

/* This is the number of the buckets for the socket dictionary */
#define NUMBER_OF_SOCKET_BUCKETS                8

PTransportInterface	g_Transport = NULL;
CSocketList        *g_pSocketList = NULL;   // key=socket_number, data=pSocket
SOCKET				Listen_Socket = INVALID_SOCKET;

CRITICAL_SECTION	csQOS;

// The external MCS Controller object
extern PController	g_pMCSController;
extern CPluggableTransport *g_pPluggableTransport;

/*
 *	TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class constructor.
 *
 *		Note that this version of the constructor is specific to 32-bit
 *		Windows.
 */
TransportInterface::TransportInterface (
		HANDLE						transport_transmit_event,
		PTransportInterfaceError	transport_interface_error) :
		Transport_Transmit_Event (transport_transmit_event),
		m_TrnsprtConnCallbackList2()
{
		TransportInterfaceError		tcp_error = TRANSPORT_INTERFACE_NO_ERROR;
		//WORD 						version_requested;
		//int							error;
		WSADATA						wsa_data;
		RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);

	TRACE_OUT(("TCP Initialization..."));

	// Initialize QoS.
	InitializeCriticalSection(&csQOS);
	
    ASSERT(NULL == g_pSocketList);
	DBG_SAVE_FILE_LINE
	g_pSocketList = new CSocketList(NUMBER_OF_SOCKET_BUCKETS);
	if (g_pSocketList == NULL)
	{
		WARNING_OUT (("TransportInterface::TransportInterface:  Unable to allocate socket dictionary."));
		tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
	}

	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {		
		/* WSAStartup() must be called to initialize WinSock */
		WORD version_requested = MAKEWORD (1,1);
		int error = WSAStartup (version_requested, &wsa_data);
		ASSERT(error == 0);
		if (error) {
			WARNING_OUT (("ThreadFunction: WSAStartup returned error %d", error));
			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
		}
		else {
			/* Print out the developer of this version of WinSock */
			TRACE_OUT (("TransportInterface::TransportInterface: WinSock implementation by %s", &wsa_data.szDescription));
		}
	}

	bInServiceContext = !!::FindAtomA("NMSRV_ATOM");

	if ( bInServiceContext ||
        (re.GetNumber(REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY) != DISABLED_POL_SECURITY))
	{
		DBG_SAVE_FILE_LINE
		pSecurityInterface = new SecurityInterface(bInServiceContext);

		if ( TPRTSEC_NOERROR != pSecurityInterface->Initialize())
		{
			WARNING_OUT(("Creating security interface failed!"));
			delete pSecurityInterface;
			pSecurityInterface = NULL;
		}
	}
	else
		pSecurityInterface = NULL;

	/* Initialize the listen socket. This socket will wait for incoming calls */
	if (tcp_error == TRANSPORT_INTERFACE_NO_ERROR) {

		// Listen on standard socket
		Listen_Socket = CreateAndConfigureListenSocket();

		if ( INVALID_SOCKET == Listen_Socket ) {
			ERROR_OUT(("TransportInterface::TransportInterface: Error - could not initialize listen socket"));
			tcp_error = TRANSPORT_INTERFACE_INITIALIZATION_FAILED;
		}
	}

	*transport_interface_error = tcp_error;
}


void CloseListenSocket(void)
{
	if (Listen_Socket != INVALID_SOCKET)
    {
        TransportConnection XprtConn;
        SET_SOCKET_CONNECTION(XprtConn, Listen_Socket);
		::freeListenSocket(XprtConn);
		Listen_Socket = INVALID_SOCKET;
	}
}


/*
 *	~TransportInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the class destructor.  It unloads the DLL (if necessary).
 */
TransportInterface::~TransportInterface ()
{
    PSocket                     pSocket;

	TRACE_OUT (("Cleaning up the TCP transport..."));

	/* Delete all of the Logical Connection Structures */
    if (g_pSocketList != NULL)
	{
        ::EnterCriticalSection(&g_csTransport);
        CSocketList     Connection_List_Copy (*g_pSocketList);
        ::LeaveCriticalSection(&g_csTransport);

		while (NULL != (pSocket = Connection_List_Copy.Get()))
		{
		    // LONCHANC: cannot remove pSocket out of the list now
		    // because DisconnectRequest() uses it.

			/* Disconnect, trash packets, and delete the first connection in the list */
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_NONE);
		}

        ::EnterCriticalSection(&g_csTransport);
		delete g_pSocketList;
        g_pSocketList = NULL;
        ::LeaveCriticalSection(&g_csTransport);
	}

	/* Close the listening socket */
    ::CloseListenSocket();

	delete pSecurityInterface;

	/* Force Winsock to cleanup immediately */
	WSACleanup();
	
	// Clean up QoS
	DeleteCriticalSection(&csQOS);

	TRACE_OUT (("TCP Transport has been cleaned up."));
	
}

/*
 *	TransportInterfaceError 	RegisterTransportConnection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to register a callback for a particular
 *		transport connection.  This will usually be done for incoming
 *		connections, when you know the transport connection handle BEFORE
 *		registering the callback.
 */
TransportInterfaceError TransportInterface::RegisterTransportConnection (
								TransportConnection		XprtConn,
								PConnection				owner_object,
								BOOL					bNoNagle)
{
	TransportInterfaceError 	return_value;

	/*
	 *	Check to see if the transport connection in question exists.  If
	 *	it does, then remove it and add it again with the new owner.
	 *	If not, fail the call.
	 */
	if (m_TrnsprtConnCallbackList2.RemoveEx(XprtConn))
	{
		/*
		 *	Get the address of the associated connection callback structure.
		 *	Then put the new callback information into it.
		 */
		TRACE_OUT (("TransportInterface::RegisterTransportConnection: "
				"registering new owner"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, XprtConn);

        if (IS_SOCKET(XprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::RegisterTransportConnection: disabling Nagle for socket (%d, %d)", 
    						XprtConn.eType, XprtConn.nLogicalHandle));
    			::setsockopt(XprtConn.nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}
		}
		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is no entry in the callback list for the specified transport
		 *	connection.  Since this function is only used to replace callback
		 *	information for existing connections, it is necessary to fail the
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::RegisterTransportConnection: "
				"no such connection"));
		return_value = TRANSPORT_INTERFACE_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

#ifdef NM_RESET_DEVICE
/*
 *	TransportError 	ResetDevice ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function merely makes the call to the transport DLL if the
 *		library was successfully loaded.
 */
TransportError 	TransportInterface::ResetDevice (
						PChar			device_identifier)
{
	PSocket pSocket;
	PChar 	Remote_Address;

    ::EnterCriticalSection(&g_csTransport);
    CSocketList     Connection_List_Copy (*g_pSocketList);
    ::LeaveCriticalSection(&g_csTransport);

	while (NULL != (pSocket = Connection_List_Copy.Get()))
	{
		Remote_Address = pSocket->Remote_Address;
		if(Remote_Address && (strcmp(Remote_Address, device_identifier) == 0))
		{
			::DisconnectRequest(pSocket->XprtConn, TPRT_NOTIFY_OTHER_REASON);
			break;
		}
	}

	return (TRANSPORT_NO_ERROR);
}
#endif // NM_RESET_DEVICE

/*
 *	TransportError 	ConnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		After checking to make sure that the library was loaded properly, this
 *		routine takes the steps required to create a new transport connection.
 */
TransportError 	TransportInterface::ConnectRequest (
					TransportAddress		transport_address,
					BOOL					fSecure,
					BOOL					bNoNagle,
					PConnection				owner_object,
					PTransportConnection	pXprtConn)
{
	TransportError 			return_value;
	TransportInterfaceError	transport_interface_error;

	TRACE_OUT (("TransportInterface::ConnectRequest"));
	/*
	 *	Issue a call to the Transport's ConnectRequest API routine.  Note that
	 *	this MUST be done first since one of the return values is the
	 *	transport connection handle of the newly created connection.
	 *	Also note that this is a non-blocking call, so what we have done
	 *	is begun the process of forming a connection.  The connection
	 *	cannot be used until a connect confirm is received.
	 */
	return_value = ::ConnectRequest(transport_address, fSecure, pXprtConn);
			
	if (return_value == TRANSPORT_NO_ERROR) {
		/*
		 *	If the call to create the connection was successful, then
		 *	put a new entry into the callback list.  This entry will
		 *	contain the callback information provided as parameters to
		 *	this routine.
		 */
		transport_interface_error = CreateConnectionCallback (
					*pXprtConn, owner_object);
        if (IS_SOCKET(*pXprtConn))
        {
    		if (bNoNagle)
    		{
    			// We need to disable the Nagle algorithm
    			TRACE_OUT(("TransportInterface::ConnectRequest: disabling Nagle for socket (%d, %d)", 
    						pXprtConn->eType, pXprtConn->nLogicalHandle));
    			::setsockopt(pXprtConn->nLogicalHandle, IPPROTO_TCP, TCP_NODELAY,
    						(const char *) &bNoNagle, sizeof(BOOL));
    		}

#ifdef DEBUG
		    if (TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS == 
			    transport_interface_error) {
			    /*
			     *	The transport connection handle returned from the
			     *	transport layer is the same as one we already have
			     *	listed.  We will therefore terminate the existing
			     *	connection (since its integrity appears to have been
			     *	compromised).  We will also fail this request.
			     */
			    WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
						    "ERROR - duplicate connections"));

			    // This should NOT be happenning!!!
			    ASSERT (FALSE);

		    }
		    else {
			    /*
			     *	Everything worked fine, so do nothing.
			     */
			    TRACE_OUT (("DLLTransportInterface::ConnectRequest: "
						    "callback added to list"));
		    }
#endif // DEBUG
		}
	}
	else
	{
		/*
		 *	The call to TConnectRequest failed.  Report it and let the
		 *	error fall through.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectRequest: "
					"TConnectRequest failed"));
	}

	return (return_value);
}

/*
 *	void DisconnectRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called to break an existing transport
 *		connection.  After checking to make sure that the transport connection
 *		is valid, it passes the call onto the DLL and removes the transport
 *		connection from the local callback list.
 */
void TransportInterface::DisconnectRequest (TransportConnection	transport_connection)
{
	TRACE_OUT (("TransportInterface::DisconnectRequest"));

	if (m_TrnsprtConnCallbackList2.RemoveEx(transport_connection))
    {
		::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
	else
    {
		TRACE_OUT (("DLLTransportInterface::DisconnectRequest: the specified connection can not be found"));
	}
}

/*
 *	BOOL GetSecurity ()
 *
 *	Public
 *
 *	Functional Description:
 */
BOOL TransportInterface::GetSecurity (TransportConnection XprtConn)
{
	PSocket			pSocket;

	if (NULL != (pSocket = g_pSocketList->FindByTransportConnection(XprtConn)))
	{
	    BOOL fRet = (pSocket->pSC != NULL);
	    pSocket->Release();
	    return fRet;
	}
	ERROR_OUT(("GetSecurity: could not find socket"));
	return FALSE; // Err on the safe side
}

/*
 *	Void ReceiveBufferAvailable ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void TransportInterface::ReceiveBufferAvailable ()
{		
	TRACE_OUT(("TransportInterface::ReceiveBufferAvailable"));

	// Reset the controller's wait info
	g_pMCSController->HandleTransportWaitUpdateIndication(FALSE);

    TReceiveBufferAvailable();

	// Poll all the transport connections
	EnableReceiver ();
}



/*
 *	Void	ConnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect indication from the
 *		transport layer.  Normally this involves putting a new entry in the
 *		callback list, and forwarding the connect indication to the default
 *		owner object.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the new connection.  This includes: the logical handle of the new
 *			connection; and the handle of the physical connection which will
 *			carry the new connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectIndication (
				TransportConnection	transport_connection)
{
	TransportInterfaceError		transport_interface_error;
	PConnection					pConnection;

	/*
	 *	Put the new connection into the callback list.
	 */
	transport_interface_error = CreateConnectionCallback (transport_connection,
														 NULL);

	switch (transport_interface_error)
	{
		case TRANSPORT_INTERFACE_NO_ERROR:
			/*
			 *	Everything worked fine, so do forward the indication to the
			 *	default owner object.
			 */
			TRACE_OUT (("DLLTransportInterface::ConnectIndication: "
					"calling ConnectResponse."));
			::ConnectResponse (transport_connection);
			break;

		case TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS:
			/*
			 *	The transport connection handle sent by the transport layer is
			 *	the same as one we already have listed.  We will therefore
			 *	terminate the existing connection (since its integrity appears
			 *	to have been compromised).
			 */
			WARNING_OUT (("DLLTransportInterface::ConnectIndication: "
					"ERROR - duplicate connections. Connection: %d", transport_connection));
			::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);

			/*
			 *	Get the callback information for the previously existing
			 *	connection.  Then delete it.
			 */
			if (NULL != (pConnection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
            {
                if (LPVOID_NULL != (LPVOID) pConnection)
                {
        			/*
        			 *	Let the former owner of the connection know that it has been
        			 *	terminated.
        			 */
			        ULONG ulReason = TPRT_NOTIFY_NONE;
			        pConnection->HandleDisconnectIndication(transport_connection, &ulReason);
                }
                else
                {
                    ERROR_OUT(("TransportInterface::ConnectIndication: null pConnection"));
                }
            }
			break;
	}
}

/*
 *	Void	ConnectConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a connect confirm frmo the
 *		transport layer.  Assuming that the connect confirm is the result of
 *		a previously outstanding connect request. everything will be processed
 *		normally, and the confirm will forwarded to the object that originated
 *		the request.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being confirmed.  This includes: the logical handle
 *			of the connection; and the handle of the physical connection which
 *			is carrying the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::ConnectConfirm (
				TransportConnection	transport_connection)
{
	PConnection			connection;

	/*
	 *	Since a connect confirm should only result from an earlier connect
	 *	request, the transport connection handle SHOULD already be in the
	 *	callback list.  If it is, then process this confirm normally.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the Connection List.
		 *	Then invoke the callback, passing the message and parameter to it.
		 */
		TRACE_OUT (("DLLTransportInterface::ConnectConfirm: forwarding CONNECT_CONFIRM"));

		if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleConnectConfirm(transport_connection);
		}
	}
	else
	{
		/*
		 *	This transport connection handle is invalid.  It is therefore
		 *	necessary to terminate the connection, and otherwise ignore the
		 *	confirm.
		 */
		WARNING_OUT (("DLLTransportInterface::ConnectConfirm: "
			"terminating unknown connection %d", transport_connection));
		// ::DisconnectRequest (transport_connection, TPRT_NOTIFY_NONE);
	}
}

/*
 *	Void	DisconnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a disconnect indication from the
 *		transport layer.  If the specified transport connection exists, it will
 *		be removed, and the object that owns it will be informed of the loss.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection being disconnected.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::DisconnectIndication (
				TransportConnection			transport_connection,
				ULONG                       ulReason)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.RemoveEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT (("DLLTransportInterface::DisconnectIndication: "
				"forwarding DISCONNECT_INDICATION"));

        if (LPVOID_NULL != (LPVOID) connection)
        {
			// The owner is a Connection object.
			connection->HandleDisconnectIndication(transport_connection, &ulReason);
		}
		else
        {
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDisconnectIndication(transport_connection, &ulReason);
		}
	}
	else
	{
		/*
		 *	We have received a disconnect indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		WARNING_OUT (("DLLTransportInterface::DisconnectIndication: "
				"disconnect on unknown connection"));
	}
}

/*
 *	TransportError	DataIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a data indication from the
 *		transport layer.  If the transport connection is properly registered,
 *		the data will be forwarded to the object that owns the connection.
 *
 *	Formal Parameters:
 *		transport_data (i)
 *			This is the address of a structure that contains information about
 *			the data in the indication.  This includes what transport
 *			connection the data was received on, as well as the address and
 *			length of the data itself.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			This indicates that the data was processed.
 *		TRANSPORT_READ_QUEUE_FULL
 *			This means that the transport layer should try resending the data
 *			during the next heartbeat.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportError	TransportInterface::DataIndication (PTransportData transport_data)
{
	PConnection				connection;
	TransportError			return_value = TRANSPORT_NO_ERROR;

	/*
	 *	If the transport connection is in the callback list, then send the
	 *	data to the registered callback.  If it is not in the Connection
	 *	List, then ignore the data (we have nowhere to send it).
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_data->transport_connection)))
	{
		if (LPVOID_NULL != (LPVOID) connection)
		{
			// The owner is a Connection object.
			return_value = connection->HandleDataIndication(transport_data, 
										transport_data->transport_connection);
		}
		else
		{
			// The owner is the MCS Controller
			g_pMCSController->HandleTransportDataIndication(transport_data);
		}

		/*
		 *	If we fail to deliver the data indication, we need to set the amount
		 *	of data available to be received and notify the controller to 
		 *	retry the operation later.
		 */		
		if (TRANSPORT_NO_ERROR != return_value)
		{
			g_pMCSController->HandleTransportWaitUpdateIndication(TRUE);
		}
	}
	else
	{
		/*
		 *	We have received data on an unknown transport connection.
		 *	Ignore the indication.
		 */
		WARNING_OUT (("TransportInterface::DataIndication: data on unknown connection"));
		return_value = TRANSPORT_NO_SUCH_CONNECTION;
	}
	
	return (return_value);
}

/*
 *	Void	BufferEmptyIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function handles the reception of a buffer-empty indication from the
 *		transport layer.  If the specified transport connection exists, the object
 *		that owns it will be notified that it can proceed sending data on the 
 *		transport connection.
 *
 *	Formal Parameters:
 *		transport_identifier (i)
 *			This is a pointer to a structure that contains information about
 *			the connection.  This includes: the logical
 *			handle of the connection; and the handle of the physical connection
 *			which carried the connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	TransportInterface::BufferEmptyIndication (
				TransportConnection			transport_connection)
{
	PConnection			connection;

	/*
	 *	It should only be possible to receive a disconnect on a transport
	 *	connection that we already know about.  Therefore, the transport
	 *	connection handle SHOULD already be in the list.  Check this.
	 */
	if (NULL != (connection = m_TrnsprtConnCallbackList2.FindEx(transport_connection)))
	{
		/*
		 *	Get the address of the callback structure from the callback list.
		 *	Then delete it from the list.
		 */
		TRACE_OUT(("DLLTransportInterface::BufferEmptyIndication: "
				"forwarding BUFFER_EMPTY_INDICATION"));
		
		/*
		 *	Forward the disconnect indication to the owner of this transport
		 *	connection.
		 */
		if (LPVOID_NULL != (LPVOID) connection)
        {
			connection->HandleBufferEmptyIndication(transport_connection);
        }
	}
	else
	{
		/*
		 *	We have received a buffer empty indication on an unknown transport
		 *	connection.  Ignore it.
		 */
		TRACE_OUT (("TransportInterface::BufferEmptyIndication: "
				"indication on unknown connection"));
	}
}

/*
 *	TransportInterfaceError 	CreateConnectionCallback ()
 *
 *	Protected
 *
 *	Functional Description:
 *		This private member function is used to create new entries in the
 *		callback list.  Each entry consists of a pointer to a structure that
 *		contains the address of the object that "owns" the transport connection,
 *		as well as the message index to be used for the owner callbacks.
 *
 *		This routine allocates the memory used to hold the callback information,
 *		and puts it in the callback list if everything is successful.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the specified transport connection.
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
 *			This value indicates that the request was unsuccessful because the
 *			specified transport connection already exists in the callback list
 *			(it is an error to try and create an entry for the same transport
 *			connection more than once).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
TransportInterfaceError TransportInterface::CreateConnectionCallback (
								TransportConnection		transport_connection,
								PConnection				owner_object)
{
	TransportInterfaceError 	return_value;

	/*
	 *	See if there is already an entry in the callback list for the specified
	 *	transport connection.  If there is, then abort this request before
	 *	doing anything.
	 */
	if (m_TrnsprtConnCallbackList2.FindEx(transport_connection) == FALSE)
	{
		/*
		 *	Put the callback information into the newly allocated
		 *	structure.  Then put the structure into the callback list.
		 */
		TRACE_OUT (("TransportInterface::CreateConnectionCallback: "
					"adding new callback object"));

        m_TrnsprtConnCallbackList2.AppendEx(owner_object ? owner_object : (PConnection) LPVOID_NULL, transport_connection);

		return_value = TRANSPORT_INTERFACE_NO_ERROR;
	}
	else
	{
		/*
		 *	There is already an entry in the callback list for the specified
		 *	transport connection.  It is therefore necessary to fail this
		 *	request.
		 */
		WARNING_OUT (("TransportInterface::CreateConnectionCallback: "
				"callback already exists"));
		return_value = TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS;
	}

	return (return_value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\comport.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Comport.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the ComPort class.  This class
 *        controls a specific Windows Comm port.  The main purpose of this class
 *        is to put the Windows specific comm calls in one class.
 *
 *    Private Instance Variables:
 *        m_hCommLink                    -    Handle  returned by Windows    when you open
 *                                    a com port
 *        Tx_Buffer_Size            -    Output buffer size, Win32 buffer
 *        Byte_Count                -    Represents total number of bytes transmitted
 *                                    over the comm port
 *        Last_Byte_Count            -    We have a timer that expires every X
 *                                    seconds.  It reports the total number of
 *                                    bytes transmitted if Last_Byte_Count is not
 *                                    equal to the Byte_Count.  This reduces the
 *                                    number of prints that occur
 *        m_cbReadBufferSize        -    Buffer size of the ComPort's internal
 *                                    buffer size.
 *         m_pbReadBuffer                -    Address of our own internal buffer.
 *        m_nReadBufferOffset        -    Keeps track of the number of bytes read
 *                                    by the user via DataIndication calls.
 *        m_cbRead                -    Number of bytes read via the last Windows
 *                                    ReadFile() call.
 *        m_hevtPendingWrite                -    Event object used with Windows WriteFile()
 *                                    call.
 *        m_hevtPendingRead                -    Event object used with Windows ReadFile()
 *                                    call.
 *        Write_Event_Object        -    Pointer to EventObject structure used with
 *                                    the WriteFile() call.
 *        Read_Event_Object        -    Pointer to EventObject structure used with
 *                                    the ReadFile() call.
 *        RLSD_Event_Object        -    Pointer to EventObject structure used with
 *                                    the WaitCommEvent() call.
 *        m_WriteOverlapped        -    Overlapped I/O structure used with the
 *                                    Write event.
 *        m_ReadOverlapped            -    Overlapped I/O structure used with the
 *                                    Read event.
 *        Event_Mask                -    Windows mask that specifies the events
 *                                    that we are interested in.
 *        Read_Active                -    TRUE if a ReadFile() function is active.
 *        Write_Active            -    TRUE if a WriteFile() function is active.
 *        Higher_Layer            -    Pointer to higher ProtocolLayer layer
 *        Port_Configuration        -    Pointer to PortConfiguration structure.
 *        Default_Com_Timeouts    -    This structure holds the Com timeout values
 *                                    that Win32 had set as the default values.
 *                                    When we are finished with the port, we
 *                                    will restore these values
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */
#include "comport.h"

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                ULONG                handle,
 *                 PPortConfiguration    port_configuration,
 *                PhysicalHandle        physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the constructor for the ComPort class.  It initializes internal
 *        variables from the configuration file.
 */
ComPort::ComPort
(
    TransportController        *owner_object,
    ULONG                       message_base,
    PLUGXPRT_PARAMETERS        *pParams,
    PhysicalHandle              hCommLink, // physical handle
    HANDLE                      hevtClose
)
:
    m_hCommLink(hCommLink),
    m_hevtClose(hevtClose),
    m_hevtPendingRead(NULL),
    m_hevtPendingWrite(NULL),
    m_hCommLink2(NULL), // two places can call Release, one in main thread, the other in worker thread by write event
    m_cRef(2),
    m_fClosed(FALSE)
{
    m_pController = owner_object;
    m_nMsgBase = message_base;
    Automatic_Disconnect = FALSE;
    Count_Errors_On_ReadFile = 0;

	m_hevtPendingRead = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	m_hevtPendingWrite = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	ASSERT(m_hevtPendingRead && m_hevtPendingWrite);

    ::ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));
    m_ReadOverlapped.hEvent = m_hevtPendingRead;

    ::ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.hEvent = m_hevtPendingWrite;

     /*
     **    Initialize internal variables
     */
    Byte_Count = 0;
    Last_Byte_Count = 0;

    m_pbReadBuffer = NULL;
    Read_Active = FALSE;
    m_nReadBufferOffset = 0;
    Read_Event_Object = NULL;

    Write_Active = FALSE;
    Write_Event_Object = NULL;

    DCB dcb;
    ::ZeroMemory(&dcb, sizeof(dcb));
    if (::GetCommState(m_hCommLink, &dcb))    // address of communications properties structure
    {
        Baud_Rate = dcb.BaudRate;
    }
    else
    {
        Baud_Rate = DEFAULT_BAUD_RATE;
    }

    // default settings
    Call_Control_Type = DEFAULT_PSTN_CALL_CONTROL;
    Tx_Buffer_Size = DEFAULT_TX_BUFFER_SIZE;
    Rx_Buffer_Size = DEFAULT_RX_BUFFER_SIZE;
    m_cbReadBufferSize = DEFAULT_INTERNAL_RX_BUFFER_SIZE;

    // get new parameters
    if (NULL != pParams)
    {
        if (PSTN_PARAM__CALL_CONTROL & pParams->dwFlags)
        {
            Call_Control_Type = pParams->eCallControl;
        }
        if (PSTN_PARAM__READ_FILE_BUFFER_SIZE & pParams->dwFlags)
        {
            if (1024 <= pParams->cbReadFileBufferSize)
            {
                m_cbReadBufferSize = pParams->cbReadFileBufferSize;
            }
        }
        if (PSTN_PARAM__PHYSICAL_LAYER_SEND_BUFFER_SIZE & pParams->dwFlags)
        {
            if (DEFAULT_TX_BUFFER_SIZE <= pParams->cbPhysicalLayerSendBufferSize)
            {
                Tx_Buffer_Size = pParams->cbPhysicalLayerSendBufferSize;
            }
        }
        if (PSTN_PARAM__PHSYICAL_LAYER_RECV_BUFFER_SIZE & pParams->dwFlags)
        {
            if (1024 <= pParams->cbPhysicalLayerReceiveBufferSize)
            {
                Rx_Buffer_Size = pParams->cbPhysicalLayerReceiveBufferSize;
            }
        }
    }
}


/*
 *    ComPort::~ComPort (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the Comport class. It releases all memory
 *        that was used by the class and deletes all timers.  It also closes the
 *        com port
 */
typedef BOOL (WINAPI *LPFN_CANCEL_IO) (HANDLE);
ComPort::~ComPort(void)
{
    // hopefully the worker thread is able to clean up all the read and write operations
    delete [] m_pbReadBuffer;
    m_pbReadBuffer = NULL;
}


LONG ComPort::Release(void)
{
    Close ();

    HINSTANCE hLib = NmLoadLibrary("kernel32.dll", TRUE);
    if (NULL != hLib)
    {
        LPFN_CANCEL_IO pfnCancelIo = (LPFN_CANCEL_IO) ::GetProcAddress(hLib, "CancelIo");
        if (NULL != pfnCancelIo)
        {
            (*pfnCancelIo)(m_hCommLink2);
        }
        ::FreeLibrary(hLib);
    }

    COMMTIMEOUTS    com_timeouts, com_timeouts_save;
    if (::GetCommTimeouts(m_hCommLink2, &com_timeouts_save))
    {
        /*
        **    We are setting these timeout values to 0 because we were
        **    getting a VxD fault under Windows 95 when they were set to
        **    their normal values.
        */
        ::ZeroMemory(&com_timeouts, sizeof(com_timeouts));
        ::SetCommTimeouts(m_hCommLink2, &com_timeouts);

        /*
        **    Abort any ReadFile() or WriteFile() operations
        */
        ::PurgeComm(m_hCommLink2, PURGE_TXABORT | PURGE_RXABORT);

        /*
        **    Set the timeouts to their original state
        */
        ::SetCommTimeouts(m_hCommLink2, &com_timeouts_save);
    }

    // decrement the reference count
    if (! ::InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


/*
 *    ComPortError    ComPort::Open (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function opens the comm port and configures it with the values
 *        found in the configuration object.
 */
ComPortError ComPort::Open(void)
{
    BOOL            fRet;
    ComPortError    rc;

    TRACE_OUT(("ComPort:: TX size = %d  RX size = %d Int Rx Size = %d",
                Tx_Buffer_Size, Rx_Buffer_Size, m_cbReadBufferSize));

    if (NULL == m_hevtPendingRead || NULL == m_hevtPendingWrite)
    {
        ERROR_OUT(("ComPort: Error create pending read/write events"));
        ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
        return (COMPORT_INITIALIZATION_FAILED);
    }

    // allocate read buffer
    TRACE_OUT(("Comport: Internal Rx Buffer Size = %ld", m_cbReadBufferSize));
    DBG_SAVE_FILE_LINE
    m_pbReadBuffer = new BYTE[m_cbReadBufferSize];
    m_nReadBufferOffset = 0;
    if (m_pbReadBuffer == NULL)
    {
        ERROR_OUT(("ComPort: Error allocating memory = %d", ::GetLastError()));
        ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
        return (COMPORT_INITIALIZATION_FAILED);
    }

     /*
     **    Issue a read to the com port.
     **    We are going to continue to issue Readfile() calls
     **    until we get into a wait state.  99.9999% of the
     **    time, we will only issue the first ReadFile() and
     **    it will immediately block waiting for data.
     */
    while (1)
    {
        m_cbRead = 0;
        fRet = ::ReadFile(m_hCommLink, m_pbReadBuffer, m_cbReadBufferSize, &m_cbRead, &m_ReadOverlapped);
        if (! fRet)
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_IO_PENDING)
            {
                Read_Active = TRUE;
                break;
            }
            else
            {
                ERROR_OUT(("ComPort: Error on ReadFile = %d", dwErr));
                ReportInitializationFailure(COMPORT_INITIALIZATION_FAILED);
                return (COMPORT_INITIALIZATION_FAILED);
            }
        }
    }

     /*
     **    If this is a synchronous read, wait for the event object to be
     **    set before returning.
     */
    if (Call_Control_Type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL)
    {
        ::WaitForSingleObject(m_hevtPendingRead, SYNCHRONOUS_WRITE_TIMEOUT*10);
        fRet = GetOverlappedResult(m_hCommLink, &m_ReadOverlapped, &m_cbRead, FALSE);
        if (! fRet)
        {
            ::PurgeComm(m_hCommLink, PURGE_RXABORT);
        }
    }

     /*
     **    Create and fill in the EventObject.  It is then
     **    appended to the PSTN Event_List so that the EventManager
     **    can wait for the event to occur.
     */
    DBG_SAVE_FILE_LINE
    Read_Event_Object = new EventObject;
    Read_Event_Object -> event = m_hevtPendingRead;
    Read_Event_Object -> delete_event = FALSE;
    Read_Event_Object -> comport = this;
    Read_Event_Object -> hCommLink = m_hCommLink;
    Read_Event_Object -> event_type = READ_EVENT;
    g_pPSTNEventList->append((DWORD_PTR) Read_Event_Object);
    g_fEventListChanged = TRUE;

    Write_Active = FALSE;

     /*
     **    Create and fill in the EventObject.  It is then
     **    appended to the PSTN Event_List so that the EventManager
     **    can wait for the event to occur.
     */
    DBG_SAVE_FILE_LINE
    Write_Event_Object = new EventObject;
    Write_Event_Object -> event = m_hevtPendingWrite;
    Write_Event_Object -> delete_event =  FALSE;
    Write_Event_Object -> comport = this;
    Write_Event_Object -> hCommLink = m_hCommLink;
    Write_Event_Object -> event_type = WRITE_EVENT;
    g_pPSTNEventList->append((DWORD_PTR) Write_Event_Object);
    g_fEventListChanged = TRUE;

    return (COMPORT_NO_ERROR);
}


/*
 *    ComPortError    ComPort::Close (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function makes the necessary Windows calls to close the Com
 *        port.  It first clears the DTR signal to notify the modem.
 */
ComPortError ComPort::Close(void)
{
    if (! m_fClosed)
    {
        m_fClosed = TRUE;

        /*
        **    Reset the Activity flags.
        */
        Write_Active = FALSE;
        Read_Active = FALSE;

        // we do not close the handle here, T.120 will do it.
        m_hCommLink2 = m_hCommLink;
        m_hCommLink = INVALID_HANDLE_VALUE;

         /*
         **    Notify the event manager that these events need to be deleted.
         **    It is important for the event manager to realize that when the
         **    delete_event is set to TRUE, he can no longer access this object.
         */
        if (Write_Event_Object != NULL)
        {
            ::CloseHandle(Write_Event_Object->event);
            g_pPSTNEventList->remove((DWORD_PTR) Write_Event_Object);
            delete Write_Event_Object;
        }

        if (Read_Event_Object != NULL)
        {
            Read_Event_Object -> delete_event = TRUE;
            ::SetEvent(m_hevtPendingRead);
        }

        // let the worker thread to pick up the work
        ::Sleep(50);
    }

    return COMPORT_NO_ERROR;
}


/*
 *    ComPortError    ComPort::Reset (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function clears the DTR signal on the Com port.
 */
ComPortError ComPort::Reset(void)
{
    return COMPORT_NO_ERROR;
}


/*
 *    ComPortError    ComPort::ReleaseReset (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function releases the previous reset.  It set the DTR signal on
 *        the com port.
 */
ComPortError ComPort::ReleaseReset(void)
{
    return COMPORT_NO_ERROR;
}


/*
 *    ULONG    ComPort::GetBaudRate (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the baud rate of the port
 */


/*
 *    ProtocolLayerError    ComPort::DataRequest (
 *                                    ULONG,
 *                                    LPBYTE    buffer_address,
 *                                    ULONG    length,
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to send data out the port in an asynchronous
 *        manner.  In other words, we will return from the function before all
 *        of the bytes are actually written to the modem.
 */
ProtocolLayerError ComPort::DataRequest(ULONG_PTR,
                                LPBYTE        buffer_address,
                                ULONG         length,
                                ULONG        *bytes_accepted)
{
    return WriteData(FALSE, buffer_address, length, bytes_accepted);
}

/*
 *    ProtocolLayerError    ComPort::SynchronousDataRequest (
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to send data out the port in a synchronous
 *        manner.  In other words, we will not return from the function until
 *        all of the bytes are actually written to the modem or a timeout occurs.
 */
ProtocolLayerError ComPort::SynchronousDataRequest(
                                LPBYTE        buffer_address,
                                ULONG         length,
                                ULONG        *bytes_accepted)
{
    return WriteData(TRUE, buffer_address, length, bytes_accepted);
}


/*
 *    ProtocolLayerError    ComPort::WriteData (
 *                                    BOOL    synchronous,
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted)
 *
 *    Functional Description
 *        This function makes the Win32 calls to write data to the port.
 *
 *    Formal Parameters
 *        synchronous        -    (i)    TRUE, if we should wait for the write to
 *                                complete before returning.
 *        buffer_address    -    (i)    Address of the data to write.
 *        length            -    (i)    Length of the data to write.
 *        bytes_accepted    -    (i)    Actually number of bytes written.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Port not open
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *
 *    Side Effects
 *        None.
 *
 *    Caveats
 *        None
 */
ProtocolLayerError ComPort::WriteData
(
    BOOL            synchronous,
    LPBYTE          buffer_address,
    ULONG           length,
    PULong          bytes_accepted
)
{
    COMSTAT         com_status;
    ULONG           com_error;

    ULONG           byte_count;
    ULONG           bytes_written;
    BOOL            fRet;

    *bytes_accepted = 0;
    if (m_hCommLink == INVALID_HANDLE_VALUE)
    {
        return (PROTOCOL_LAYER_ERROR);
    }

    if (Write_Active)
    {
        return (PROTOCOL_LAYER_NO_ERROR);
    }

     /*
     **    Determine the amount of space left in the buffer
     */
    ::ZeroMemory(&com_status, sizeof(com_status));
    ::ClearCommError(m_hCommLink, &com_error, &com_status);

    if (length > (Tx_Buffer_Size - com_status.cbOutQue))
    {
        byte_count = Tx_Buffer_Size - com_status.cbOutQue;
    }
    else
    {
        byte_count = length;
    }

    ::ZeroMemory(&m_WriteOverlapped, sizeof(m_WriteOverlapped));
    m_WriteOverlapped.hEvent = m_hevtPendingWrite;
    fRet = ::WriteFile(m_hCommLink, buffer_address, byte_count, &bytes_written, &m_WriteOverlapped);

     /*
     **    If this is a synchronous write, wait for the event object to be
     **    set before returning.
     */
    if (synchronous)
    {
        ::WaitForSingleObject(m_hevtPendingWrite, SYNCHRONOUS_WRITE_TIMEOUT);
        fRet = ::GetOverlappedResult(m_hCommLink, &m_WriteOverlapped, &bytes_written, FALSE);
        if (! fRet)
        {
            WARNING_OUT(("ComPort::WriteData: purge comm"));
            ::PurgeComm(m_hCommLink, PURGE_TXABORT);
        }
        ::ResetEvent(m_WriteOverlapped.hEvent);
    }

    if (! fRet)
    {
        if (::GetLastError () == ERROR_IO_PENDING)
        {
            Write_Active = TRUE;
            *bytes_accepted = byte_count;
            Byte_Count += byte_count;
        }
        else
        {
            TRACE_OUT(("ComPort: DataRequest: Error on WriteFile = %d", ::GetLastError()));
        }
    }
    else
    {
        if (bytes_written != byte_count)
        {
            TRACE_OUT(("ComPort: DataRequest: Error on WriteFile  bytes written != bytes requested"));
        }
        *bytes_accepted = byte_count;

         /*
         **    Increment Byte_Count
         */
        Byte_Count += bytes_written;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::RegisterHigherLayer (
 *                                    ULONG,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *    higher_layer)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object that wants to receive the data
 *        read from the com port.
 */
ProtocolLayerError ComPort::RegisterHigherLayer(ULONG_PTR, PMemoryManager,
                                IProtocolLayer *pMux)
{
    m_pMultiplexer = pMux;
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::RemoveHigherLayer (
 *                                    USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object that no longer wants to receive
 *        the data from the com port.
 */
ProtocolLayerError ComPort::RemoveHigherLayer(ULONG_PTR)
{
    m_pMultiplexer = NULL;
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to take the data that we have received from
 *        the port and pass it on up to the registered layer.
 */
ProtocolLayerError ComPort::PollReceiver(void)
{
    BOOL    issue_read = FALSE;
    ULONG   bytes_accepted;
    BOOL    fRet;

    if (m_pMultiplexer == NULL || m_hCommLink == INVALID_HANDLE_VALUE)
    {
        return (PROTOCOL_LAYER_ERROR);
    }

     /*
     **    This event can occur if we have completed a read but the higher layers
     **    have not accepted all of the data.  So, before we issue another
     **    ReadFile() we are going to send the pending data on up.
     */
    if (! Read_Active)
    {
        if (m_cbRead)
        {
            m_pMultiplexer->DataIndication(m_pbReadBuffer, m_cbRead - m_nReadBufferOffset, &bytes_accepted);
            if (bytes_accepted > (m_cbRead - m_nReadBufferOffset))
            {
                ERROR_OUT(("ComPort:  PollReceiver1: ERROR: Higher layer accepted too many bytes"));
            }

            m_nReadBufferOffset += bytes_accepted;
            if (m_nReadBufferOffset == m_cbRead)
            {
                issue_read = TRUE;
                m_cbRead = 0;
                m_nReadBufferOffset = 0;
            }
        }
        else
        {
            issue_read = TRUE;
        }
    }

     /*
     **    Issue a ReadFile () and process any data received.
     */
    while (issue_read)
    {
        m_cbRead = 0;
        m_nReadBufferOffset = 0;
        ::ZeroMemory(&m_ReadOverlapped, sizeof(m_ReadOverlapped));
        m_ReadOverlapped.hEvent = m_hevtPendingRead;
        fRet = ::ReadFile(m_hCommLink, m_pbReadBuffer, m_cbReadBufferSize, &m_cbRead, &m_ReadOverlapped);
        if (! fRet)
        {
            if (::GetLastError() == ERROR_IO_PENDING)
            {
                Read_Active = TRUE;
            }
            else
            {
                WARNING_OUT(("ComPort: Error on ReadFile = %d", ::GetLastError()));
                if (Count_Errors_On_ReadFile++ == DEFAULT_COUNT_OF_READ_ERRORS)
                {
                    WARNING_OUT(("ComPort: %d Errors on ReadFile, closing the connection", Count_Errors_On_ReadFile));
                    Close();
                    return (PROTOCOL_LAYER_ERROR);
                }
            }
            issue_read = FALSE;
        }
        else
        {
            if (m_pMultiplexer != NULL)
            {
                m_pMultiplexer->DataIndication(m_pbReadBuffer, m_cbRead, &bytes_accepted);
                if (bytes_accepted > m_cbRead)
                {
                    ERROR_OUT(("ComPort:  PollReceiver: ERROR: Higher layer accepted too many bytes"));
                }
                m_nReadBufferOffset += bytes_accepted;
                if (m_nReadBufferOffset != m_cbRead)
                {
                    issue_read = FALSE;
                }
            }
            else
            {
                issue_read = FALSE;
            }
        }
    }
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::GetParameters (
 *                                    ULONG,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by an object to determine the maximum packet
 *        size that this object expects.  It also queries the number of bytes
 *        it should skip on the front of a packet and append to the end of a
 *        packet.  The ComPort object is a stream device, so these parameters
 *        don't really matter.
 */
ProtocolLayerError ComPort::GetParameters
(
    USHORT *    max_packet_size,
    USHORT *    prepend,
    USHORT *    append
)
{
     /*
     **    max_packet_size set to 0xffff means that this object receives
     **    data in a stream format rather than a packet format.  It does
     **    group data into packets, it handles data a byte at a time.
     **    Therefore, when a higher layer issues a DataRequest() to this
     **    object, it may not accept the whole data block, it may only
     **    accept part of it.
     **
     **    prepend is set to 0 because this object does not prepend any
     **    data to the beginning of a DataRequest() packet.
     **
     **    append is set to 0 because this object does not append any
     **    data to the end of a DataRequest() packet.
     */
    *max_packet_size = 0xffff;
    *prepend = 0;
    *append = 0;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    ComPort::ReportInitializationFailure (
 *                        PChar    error_message)
 *
 *    Functional Description
 *        This routine simply reports an error to the user and closes the
 *        Windows comm port.  It does absolutely nothing if the Physical
 *        API is disabled.
 *
 *    Formal Parameters
 *        error_message    (i)    -    Pointer to error message
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None.
 *
 *    Caveats
 *        None
 */
void ComPort::ReportInitializationFailure(ComPortError rc)
{
    ERROR_OUT(("ComPort:: IO failure, rc=%d", rc));
}


/*
 *    BOOL    ComPort::ProcessReadEvent (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when a READ event is actually set.  This means
 *        that the read operation has completed or an error occured.
 */
BOOL ComPort::ProcessReadEvent(void)
{
    BOOL fRet = FALSE;

    if (Read_Active)
    {
        if (WAIT_OBJECT_0 == ::WaitForSingleObject(m_hevtPendingRead, 0))
        {
            fRet = GetOverlappedResult(m_hCommLink, &m_ReadOverlapped, &m_cbRead, FALSE);
            if (fRet && m_cbRead == 0)
            {
                fRet = FALSE;
            }

            Read_Active = FALSE;
            ::ResetEvent(m_hevtPendingRead);
        }
    }
    else
    {
        ::ResetEvent(m_hevtPendingRead);
    }

    return fRet;
}


/*
 *    BOOL    ComPort::ProcessWriteEvent (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when a WRITE event is actually set.  This means
 *        that the write operation has completed or an error occured.
 */
BOOL ComPort::ProcessWriteEvent(void)
{
    ULONG  bytes_written;
    BOOL   fRet = FALSE;

    if (Write_Active)
    {
        if (WAIT_OBJECT_0 == ::WaitForSingleObject(m_hevtPendingWrite, 0))
        {
            fRet = ::GetOverlappedResult(m_hCommLink, &m_WriteOverlapped, &bytes_written, FALSE);
            if (! fRet)
            {
                DWORD dwErr = ::GetLastError();
                if (ERROR_IO_PENDING == dwErr)
                {
                    TRACE_OUT(("ProcessWriteEvent: still pending"));
                }
                else
                {
                    WARNING_OUT(("ProcessWriteEvent: ERROR = %d", dwErr));
                }
            }
            Write_Active = FALSE;
            ::ResetEvent(m_hevtPendingWrite);
        }
    }
    else
    {
        ::ResetEvent(m_hevtPendingWrite);
    }

    return fRet;
}


/*
 *    ProtocolLayerError    ComPort::DataIndication (
 *                                    LPBYTE,
 *                                    ULONG,
 *                                    PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::DataIndication(LPBYTE, ULONG, PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::DataRequest (
 *                                    ULONG,
 *                                    PMemory,
 *                                    PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::DataRequest(ULONG_PTR, PMemory, PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    ComPort::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT,
 *                                    USHORT *,
 *                                    USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is not used.  It is only here because we inherit from
 *        ProtocolLayer.
 */
ProtocolLayerError ComPort::PollTransmitter(ULONG_PTR, USHORT, USHORT *, USHORT *)
{
    return (PROTOCOL_LAYER_ERROR);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\comport.h ===
/*    Comport.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the ComPort class.  This class is the
 *        interface to the Win32 Comm port.
 *
 *        If this class is instantiated in in-band call control mode, it will
 *        open the Windows port and set it up properly.  It will use the
 *        configuration data from the Configuration object.  Refer to the MCAT
 *        Developer's Toolkit Manual for a complete listing of the configurable
 *        items.
 *
 *        If this class is instantiated in out-of-band mode, it is passed a
 *        file handle.  It assumes that this port has been properly initialized.
 *        It get the configuration data that it needs from the port_configuration
 *        structure passed in.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */
#ifndef _T123_COM_PORT_H_
#define _T123_COM_PORT_H_


 /*
 **    Return values from this class
 */
typedef enum
{
    COMPORT_NO_ERROR,
    COMPORT_INITIALIZATION_FAILED,
    COMPORT_NOT_OPEN,
    COMPORT_ALREADY_OPEN,
    COMPORT_READ_FAILED,
    COMPORT_WRITE_FAILED,
    COMPORT_CONFIGURATION_ERROR
}
    ComPortError, * PComPortError;

 /*
 **    Miscellaneous Definitions
 */
#define OUTPUT_FLOW_CONTROL     0x0001
#define INPUT_FLOW_CONTROL      0x0002

#define DEFAULT_PATH            "."
#define DEFAULT_MODEM_TYPE      ""

#define DEFAULT_COM_PORT        2

#define DEFAULT_BAUD_RATE       9600

#define DEFAULT_PARITY                          NOPARITY
#define DEFAULT_DATA_BITS                       8
#define DEFAULT_STOP_BITS                       1
#define DEFAULT_FLOW_CONTROL                    OUTPUT_FLOW_CONTROL
// #define DEFAULT_TX_BUFFER_SIZE                  0
#define DEFAULT_TX_BUFFER_SIZE                  1024
#define DEFAULT_RX_BUFFER_SIZE                  10240
#define DEFAULT_READ_INTERVAL_TIMEOUT           10
#define DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER   0
#define DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT     100
// #define DEFAULT_INTERNAL_RX_BUFFER_SIZE         1024
#define DEFAULT_INTERNAL_RX_BUFFER_SIZE         DEFAULT_RX_BUFFER_SIZE
#define DEFAULT_COUNT_OF_READ_ERRORS            10
#define DEFAULT_BYTE_COUNT_INTERVAL             0

#define COM_TRANSMIT_BUFFER                     0x0001
#define COM_RECEIVE_BUFFER                      0x0002

#define SYNCHRONOUS_WRITE_TIMEOUT               500
#define MODEM_IDENTIFIER_STRING_LENGTH          16
#define COMPORT_IDENTIFIER_STRING_LENGTH        16


class ComPort : public IProtocolLayer
{
public:

    ComPort(TransportController    *owner_object,
            ULONG                   message_base,
            PLUGXPRT_PARAMETERS    *pParams,
            PhysicalHandle          physical_handle,
            HANDLE                  hevtClose);

    virtual ~ComPort(void);
    LONG    Release(void);

    ComPortError Open(void);
    ComPortError Close(void);
    ComPortError Reset(void);
    ComPortError ReleaseReset(void);

    ULONG GetBaudRate(void) { return Baud_Rate; }

    ProtocolLayerError  SynchronousDataRequest(
                            LPBYTE           buffer,
                            ULONG            length,
                            ULONG           *bytes_accepted);

    BOOL        ProcessReadEvent(void);
    BOOL        ProcessWriteEvent(void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR         identifier,
                            LPBYTE            buffer_address,
                            ULONG            length,
                            PULong            bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR         identifier);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *            max_packet_size,
                            USHORT *            prepend,
                            USHORT *            append);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            PMemory        memory,
                            PULong         bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR       identifier,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);

    PLUGXPRT_PSTN_CALL_CONTROL GetCallControlType(void) { return Call_Control_Type; }
    BOOL PerformAutomaticDisconnect(void) { return Automatic_Disconnect; }
    BOOL IsWriteActive(void) { return Write_Active; }


private:

    ProtocolLayerError  WriteData(
                            BOOL        synchronous,
                            LPBYTE      buffer_address,
                            ULONG       length,
                            PULong      bytes_accepted);

    void                ReportInitializationFailure(ComPortError);

private:

    LONG                    m_cRef;
    BOOL                    m_fClosed;
    TransportController    *m_pController; // owner object
    ULONG                   m_nMsgBase;
    BOOL                    Automatic_Disconnect;
    PLUGXPRT_PSTN_CALL_CONTROL         Call_Control_Type;
    DWORD                   Count_Errors_On_ReadFile;

    ULONG                   Baud_Rate;
    ULONG                   Tx_Buffer_Size;
    ULONG                   Rx_Buffer_Size;
    ULONG                   Byte_Count;
    ULONG                   Last_Byte_Count;

    ULONG                   m_nReadBufferOffset;
    DWORD                   m_cbRead;
    ULONG                   m_cbReadBufferSize;
    LPBYTE                  m_pbReadBuffer;

    HANDLE                  m_hCommLink;
    HANDLE                  m_hCommLink2;
    HANDLE                  m_hevtClose;
    HANDLE                  m_hevtPendingRead;
    HANDLE                  m_hevtPendingWrite;

    PEventObject            Write_Event_Object;
    PEventObject            Read_Event_Object;

    OVERLAPPED              m_WriteOverlapped;
    OVERLAPPED              m_ReadOverlapped;

    DWORD                   Event_Mask;
    BOOL                    Read_Active;
    BOOL                    Write_Active;

    IProtocolLayer         *m_pMultiplexer; // higher layer
};
typedef    ComPort *    PComPort;

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                PChar                port_string,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                BOOL            automatic_disconnect,
 *                PhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This is a constructor for the ComPort class.  It initializes internal
 *        variables from the configuration object.  It opens the Win32 comm port
 *        and initializes it properly.
 *
 *    Formal Parameters
 *        transport_resources (i) -    Pointer to TransportResources structure.
 *        port_string            (i)    -    String specifing the configuration heading
 *                                    to use.
 *        owner_object        (i)    -    Pointer to object that owns this object.
 *                                    If this object needs to contact its owner,
 *                                    it calls the OwnerCallback function.
 *        message_base        (i)    -    When this object issues an OwnerCallback,
 *                                    it should OR the message_base with the
 *                                    actual message.
 *        automatic_disconnect(i)    -    This object, at some point, will be asked
 *                                    if it should break its physical connection
 *                                    if the logical connections are broken.  The
 *                                    owner of this object is telling it how to
 *                                    respond.
 *        physical_handle        (i)    -    This is the handle associated with this
 *                                    ComPort.  When the ComPort registers an
 *                                    event to be monitored, it includes its
 *                                    physical_handle.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPort::ComPort (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                ULONG                message_base,
 *                ULONG                handle,
 *                PPortConfiguration    port_configuration,
 *                PhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This is a constructor for the ComPort class.  It initializes internal
 *        variables from the port_configuration structure.  It uses the file
 *        handle passed in and prepares to send and receive data.
 *
 *    Formal Parameters
 *        transport_resources (i) -    Pointer to TransportResources structure.
 *        owner_object        (i)    -    Pointer to object that owns this object.
 *                                    If this object needs to contact its owner,
 *                                    it calls the OwnerCallback function.
 *        message_base        (i)    -    When this object issues an OwnerCallback,
 *                                    it should OR the message_base with the
 *                                    actual message.
 *        handle                (i)    -    File handle to be used as the comm port.
 *        port_configuration    (i)    -    Pointer to PortConfiguration structure.
 *        physical_handle        (i)    -    This is the handle associated with this
 *                                    ComPort.  When the ComPort registers an
 *                                    event to be monitored, it includes its
 *                                    physical_handle.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPort::~Comport (void)
 *
 *    Functional Description
 *        This is the destructor for the Comport class. It releases all memory
 *        that was used by the class and deletes all timers
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Open (void);
 *
 *    Functional Description
 *        This function opens the comm port and configures it with the values
 *        found in the configuration object.  It uses the Physical_API_Enabled
 *        flag in the g_TransportResource structure to determine if it needst to
 *        open the comm port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COM_NO_ERROR                -    Successful open and configuration
 *        COM_INITIALIZATION_FAILED    -    One of many problems could have
 *                                        occurred.  For example, the com
 *                                        port is open by another application
 *                                        or one of the parameters in the
 *                                        configuration file is improper.
 *
 *                                        When this error occurs, a callback is
 *                                        made to the user that indicates there
 *                                        is an error condition.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Close (void);
 *
 *    Functional Description
 *        If the Physical API is not enabled, this function makes the necessary
 *        calls to close the Comm    Windows port.  It first clears the DTR signal
 *        to haugup the modem.
 *
 *        Regardless of the Physical API being enabled, it also flushes the comm
 *        buffers.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com Port closed successfully
 *         COMPORT_NOT_OPEN    -    Com Port is not open, we can't close it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::Reset (void);
 *
 *    Functional Description
 *        This function clears the DTR signal on the Com port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com port reset
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::ReleaseReset (void);
 *
 *    Functional Description
 *        This function releases the previous reset.  It sets the DTR signal on
 *        the com port.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Com port reset
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ComPortError    ComPort::FlushBuffers (
 *                                USHORT    buffer_mask)
 *
 *    Functional Description
 *        This function issues the Windows cals to flush the input and/or
 *        output buffers.
 *
 *    Formal Parameters
 *        buffer_mask    -    (i)        If COM_TRANSMIT_BUFFER is set, we flush the
 *                                output buffer.
 *                                If COM_RECEIVE_BUFFER is set, we flush the
 *                                input buffer.
 *
 *    Return Value
 *        COMPORT_NO_ERROR    -    Successful operation
 *         COMPORT_NOT_OPEN    -    Com port is not open, we can't access it
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ULONG    ComPort::GetBaudRate (void);
 *
 *    Functional Description
 *        This function returns the baud rate of the port
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        Baud rate of the port.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::SynchronousDataRequest (
 *                                    FPUChar        buffer_address,
 *                                    ULONG        length,
 *                                    FPULong        bytes_accepted)
 *
 *    Functional Description:
 *        This function is called to send data out the port in a synchronous
 *        manner.  In other words, we will not return from the function until
 *        all of the bytes are actually written to the modem or a timeout occurs.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Address of buffer to write.
 *        length            (i)    -    Length of buffer
 *        bytes_accepted    (o)    -    Number of bytes actually written
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    Success
 *        PROTOCOL_LAYER_ERROR    -    Failure
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessReadEvent (void)
 *
 *    Functional Description:
 *        This function is called when a READ event is actually set.  This means
 *        that the read operation has completed or an error occured.
 *
 *    Formal Parameters
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessWriteEvent (
 *                            HANDLE    event);
 *
 *    Functional Description:
 *        This function is called when a WRITE event is actually set.  This means
 *        that the write operation has completed or an error occured.
 *
 *    Formal Parameters
 *        event    (i)        -    Object event that occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::ProcessControlEvent (void)
 *
 *    Functional Description:
 *        This function is called when a CONTROL event is actually set.  This
 *        means that the CONTROL operation has occured.  In our case the RLSD
 *        signal has changed.
 *
 *    Formal Parameters
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::DataRequest (
 *                                    ULONG    identifier,
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::RegisterHigherLayer (
 *                                    ULONG            identifier,
 *                                    PMemoryManager    memory_manager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  When this object needs to send a packet up, it calls
 *        the higher_layer with a Data Indication
 *
 *    Formal Parameters
 *        identifier        (i)    -    Unique identifier of the higher layer.  If we
 *                                were doing multiplexing at this layer, this
 *                                would have greater significance.
 *        memory_manager    (i)    -    Pointer to outbound memory manager
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Error occured on registration
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    DataLink::RemoveHigherLayer (
 *                                    ULONG);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  If the higher layer removes itself from us, we have
 *        no place to send incoming data
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::PollReceiver (
 *                                    ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the DataLink a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::GetParameters (
 *                                    ULONG    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend_size,
 *                                    USHORT *    append_size);
 *
 *    Functional Description:
 *        This function returns the maximum packet size that it can handle via
 *        its DataRequest() function.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Not used
 *        max_packet_size    (o)    -    Address to return max. packet size in.
 *        prepend_size    (o)    -    Return number of bytes prepended to each packet
 *        append_size        (o)    -    Return number of bytes appended to each packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    BOOL    ComPort::PerformAutomaticDisconnect (void)
 *
 *    Functional Description:
 *        This function returns TRUE if we want to terminate a physical connection
 *        as soon as the logical connections are disconnected.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE    -    If we want to drop the physical connection after all
 *                    logical connections are dropped.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    DataLink::DataRequest (
 *                                    ULONG        identifier,
 *                                    PMemory        memory,
 *                                    PULong         bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (i)    -    Pointer to memory object
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Not supported.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::DataIndication (
 *                                    LPBYTE        buffer_address,
 *                                    ULONG        length,
 *                                    PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function will never be called.  It is only here because this
 *        class inherits from ProtocolLayer.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        memory            (i)    -    Pointer to memory object
 *        bytes_accepted    (o)    -    Number of bytes accepted by the DataLink.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR    -    Not supported.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ComPort::PollTransmitter (
 *                                    ULONG        identifier,
 *                                    USHORT        data_to_transmit,
 *                                    USHORT *        pending_data,
 *                                    USHORT *        holding_data);
 *
 *    Functional Description
 *        This function does nothing.
 *
 *    Formal Parameters
 *        None used.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\crc.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	crc.cpp
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the CRC class.
 *
 *	Private Instance Variables:
 *		CRC_Table[] 	-	Look-up table for pre-calc CRC values.
 *		CRC_Poly 		-	The algorithm's polynomial.
 *		CRC_Init 		-	Initial register value.
 *		CRC_Check_Value -	The value to compare the resulting received CRC.
 *		Invert 			-	Determines wether to invert the CRC value before 
 *							sending.
 *		CRC_Register 	-	CRC register during execution.
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Marvin Nicholson
 */
#include "crc.h"



/*  CRC::CRC()
 *
 *  Public 
 *
 *	Functional Description:
 *  	The constructor fo CRC class initializes some member variables.
 */
CRC::CRC()
{

	CRC_Width = 16;    /* Width of the CRC register. */
	CRC_Poly = 0x8408; /* Polynomial used in generating the CRC. */
	CRC_Init = 0xFFFF; /* Initial value of the CRC register. */
	Invert = TRUE;     /* Enables 1's complement of CRC */

	if (Invert)
	{
       /*
        *  If using 1's complement use this value to check incoming
        *  CRC.
        */
       CRC_Check_Value = 0xF0B8;
    }
	else
	{
        /*
         *  If not inverting CRC on transmittion, use this value to
         *  check received CRC.
         */
       CRC_Check_Value = 0x0000;
    }

	CRCTableGenerator (CRC_Poly);
}


/*  CRC::~CRC()
 *
 *  Public
 *
 *	Functional Description:
 *  This is the destructor for the CRC class.
 */
CRC::~CRC()
{
}


/* ULONG CRC::OldCRCGenerator(HPUChar block_adr, ULONG block_len)
 *
 * Public
 *
 *	Functional Description:
 * 		This routine computes the CRC value using standard bit-shifting.
 */
ULONG CRC::OldCRCGenerator (
			LPBYTE block_adr,
            ULONG block_len)
{
	Int 	i;
	UChar	input_byte;
	USHORT	byte_count;

	CRC_Register = (USHORT) CRC_Init;
	byte_count = 0;
	while(byte_count < block_len)
	{
		input_byte = *(block_adr + byte_count);
		CRC_Register ^= input_byte;
		for(i=0; i<8; i++)
		{
			if(CRC_Register & 1)
			{
				CRC_Register >>= 1;
				CRC_Register ^= (USHORT) CRC_Poly;
			}
			else
				CRC_Register >>= 1;
		}
		byte_count++;
	}
	if (Invert)
		return (CRC_Register ^ 0xFFFF);
	else
		return (CRC_Register);
}


/* ULONG CRC::CRCGenerator(HPUChar block_adr, ULONG block_len)
 *
 * Public
 *
 *	Functional Descriprion:
 * 		This routine computes the CRC value using a look-up table.
 */
ULONG CRC::CRCGenerator(
			LPBYTE block_adr,
            ULONG block_len)
{

	CRC_Register = (USHORT) CRC_Init;

	while(block_len--)
	{
		CRC_Register = 
			CRC_Table[(UChar) (((UChar) CRC_Register) ^ *block_adr++)] ^ 
			(CRC_Register >> 8);
	}
	if (Invert)
		return (CRC_Register ^ 0xFFFF);
	else
		return (CRC_Register);
}


/*	
 *	USHORT CRC::CRCTableValue(
 *					Int index,
 *   	            ULONG poly)
 *
 *	Functional Description
 *		This function generates a value that goes in the CRC_Table
 *
 *	Formal Parameters
 *		index	(i)	-	Index into the table
 *		poly	(i)	-	Polynomial used to generate the value
 *
 *	Return Value
 *		Value generated.
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
USHORT CRC::CRCTableValue(
				Int index,
                ULONG poly)
{
	Int i;
	ULONG r;
	ULONG inbyte = (ULONG) index;

	r = inbyte;
	for(i=0; i<8; i++)
	{
		if (r & 1)
			r = (r >> 1) ^ poly;
		else
			r >>= 1;
	}
	return ((USHORT) r);
}


/*	
 *	void CRC::CRCTableGenerator (ULONG poly)
 *
 *	Functional Description
 *		This function generates the CRC table 
 *
 *	Formal Parameters
 *		poly	(i)	-	Polynomial used to generate the table
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
void CRC::CRCTableGenerator (ULONG poly)
{
	Int i;

	for(i=0; i<CRC_TABLE_SIZE; i++)
		CRC_Table[i] = CRCTableValue(i,poly);
}

/* BOOL CRC::CheckCRC(HPUChar block_adr, ULONG block_len)
 *
 * Public 
 *
 *	Functional Description:
 * 		This routine computes the CRC of a datablock and its associated CRC and
 * 		returns a TRUE value if the resulting CRC value is 0x0000
 * 		or 0xF0B8.
 */
BOOL CRC::CheckCRC(
				LPBYTE	block_adr,
                ULONG 	block_len)
{
	CRC_Register = (USHORT) CRC_Init;

	while(block_len--)
	{
		CRC_Register = 
			CRC_Table[(UChar) (((UChar) CRC_Register) ^ *block_adr++)] ^ 
			(CRC_Register >> 8);
	}
	if (CRC_Register == CRC_Check_Value)
		return TRUE;
	else
		return FALSE;
}


/*
 *	void	CRC::GetOverhead (
 *				USHORT	maximum_packet,
 *				USHORT *	new_maximum_packet)
 *
 * Public 
 *
 *	Functional Description:
 * 		This routine adds the number of overhead bytes generated by a CRC to
 *		the packet size passed in.
 */
void	CRC::GetOverhead (
			USHORT	maximum_packet,
			USHORT *	new_maximum_packet)
{
	*new_maximum_packet = maximum_packet + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\framer.h ===
/*    Framer.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the packet frame base class.  This class defines the behavior
 *        for other packet framers that inherit from this class.  Some packet
 *        framing definitions can be found in RFC1006 and Q.922
 *    
 *    Caveats:
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _PACKET_FRAME_H_
#define _PACKET_FRAME_H_


typedef enum
{
    PACKET_FRAME_NO_ERROR,
    PACKET_FRAME_DEST_BUFFER_TOO_SMALL,
    PACKET_FRAME_PACKET_DECODED,
    PACKET_FRAME_ILLEGAL_FLAG_FOUND,
    PACKET_FRAME_FATAL_ERROR
}
    PacketFrameError;


class PacketFrame
{
public:

        virtual    PacketFrameError    PacketEncode (
                                        PUChar        source_address, 
                                        UShort        source_length,
                                        PUChar        dest_address,
                                        UShort        dest_length,
                                        DBBoolean    prepend_flag,
                                        DBBoolean    append_flag,
                                        PUShort        packet_size) = 0;
                                    
        virtual    PacketFrameError    PacketDecode (
                                        PUChar        source_address,
                                        UShort        source_length,
                                        PUChar        dest_address,
                                        UShort        dest_length,
                                        PUShort        bytes_accepted,
                                        PUShort        packet_size,
                                        DBBoolean    continue_packet) = 0;
        virtual    Void                GetOverhead (
                                        UShort        original_packet_size,
                                        PUShort        max_packet_size) = 0;


};
typedef    PacketFrame    *    PPacketFrame;

#endif


/*    
 *    PacketFrameError    PacketFrame::PacketEncode (
 *                                        PUChar        source_address, 
 *                                        UShort        source_length,
 *                                        PUChar        dest_address,
 *                                        UShort        dest_length,
 *                                        DBBoolean    packet_start,
 *                                        DBBoolean    packet_end,
 *                                        PUShort        packet_size) = 0;
 *
 *    Functional Description
 *        This function receives takes the source data and encodes it.
 *
 *    Formal Parameters
 *        source_address    - (i)    Address of source buffer
 *        source_length    - (i)    Length of source buffer
 *        dest_address    - (i)    Address of destination buffer.
 *        dest_length        - (i)    Length of destination buffer.
 *        packet_start    - (i)    This is the beginning of a packet.
 *        packet_end        - (i)    This is the end of a packet.
 *        packet_size        - (o)    Size of packet after encoding
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error
 *        PACKET_FRAME_FATAL_ERROR            -    Fatal error during encode
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    Self-explanatory
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PacketFrame::PacketDecode (
 *                                        PUChar        source_address,
 *                                        UShort        source_length,
 *                                        PUChar        dest_address,
 *                                        UShort        dest_length,
 *                                        PUShort        bytes_accepted,
 *                                        PUShort        packet_size,
 *                                        DBBoolean    continue_packet) = 0;
 *
 *    Functional Description
 *        This function takes the stream data passed in and decodes it into a
 *        packet
 *        
 *    Formal Parameters
 *        source_address    - (i)    Address of source buffer.  If this parm is 
 *                                NULL, continue using the current address.
 *        source_length    - (i)    Length of source buffer
 *        dest_address    - (i)    Address of destination buffer.  If this address
 *                                is NULL, continue using current buffer.
 *        dest_length        - (i)    Length of destination buffer.
 *        bytes_accepted    - (o)    Number of bytes processed before return
 *        packet_size        - (o)    Size of packet after decoding
 *        continue_packet    - (i)    Restart decoding
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error
 *        PACKET_FRAME_FATAL_ERROR            -    Fatal error during encode
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    Self-explanatory
 *        PACKET_FRAME_PACKET_DECODED            -    Self-explanatory
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    Void    PacketFrame::GetOverhead (
 *                            UShort    original_packet_size,
 *                            PUShort    max_packet_size) = 0;
 *
 *    Functional Description
 *        This returns the new maximum packet size
 *
 *    Formal Parameters
 *        original_packet_size    - (i)
 *        max_packet_size            - (o)    new maximum packet size
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR    -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\userchnl.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	userchnl.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the UserChannel class.  It contains
 *		the code that distinguishes this class from that of its parent, Channel.
 *
 *		The main difference between this class and that of its parent is how
 *		the join and data requests are handled.  There is also a new instance
 *		variable that keeps track of what attachment leads to the user being
 *		represented by this class.  Merge requests are also generated as is
 *		appropriate for a user channel
 *
 *		The data primitives are overridden, allowing this object to decide
 *		not to send data upward, if it is known that the user lies in the
 *		sub-tree of this provider.
 *
 *	Private Instance Variables:
 *		m_pUserAttachment
 *			This is a pointer to the attachment that leads to the user being
 *			represented by this object.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include "userchnl.h"


/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for UserChannel objects.  It creates
 *		an object with all instance variable initialized, but with no
 *		attachments (i.e. the user is not joined to the channel automatically).
 *
 *		Note that most instance variable initialization is done by invoking the
 *		equivalent constructor in the base class.
 *
 *		Upon successful completion, an attach user confirm is automtically
 *		issued to the new user.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list),
    m_pUserAttachment(user_attachment)
{
	/*
	 *	Issue an attach user confirm to the new user.
	 */
	m_pUserAttachment->AttachUserConfirm(RESULT_SUCCESSFUL, channel_id);
}

/*
 *	UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a secondary constructor that is only used during merge
 *		operations.  The intent of this constructor is to create an equivalent
 *		object without issuing any of the confirms.
 *
 *		Note that the additional constructor allows for the creator to specify
 *		that the user is to be already joined to the channel upon creation.
 *		The value of user_attachment and attachment should either be the same
 *		or attachment should be NULL.
 */
UserChannel::UserChannel (
		ChannelID			channel_id,
		CAttachment        *user_attachment,
		PDomain             local_provider,
		PConnection         top_provider,
		CChannelList2      *channel_list,
		CAttachmentList    *attachment_list,
		PConnection         pConn)
:
    Channel(channel_id, local_provider, top_provider, channel_list, attachment_list, pConn),
    m_pUserAttachment(user_attachment)
{
}

/*
 *	~UserChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This destructor does nothing more than clear the joined attachment list.
 *		This is important because it prevents the base class destructor from
 *		trying to issue channel leave indications to the user if the user is
 *		locally attached.
 */
UserChannel::~UserChannel ()
{
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		Objects of this class are always user channels, so simply return
 *		USER_CHANNEL.
 */
Channel_Type		UserChannel::GetChannelType ()
{
	return (USER_CHANNEL);
}

/*
 *	BOOL    IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		User ID channels are always valid, so return TRUE.
 */
BOOL    UserChannel::IsValid ()
{
	return (TRUE);
}

/*
 *	CAttachment *GetAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		Return the pointer to the attachment leading to the user.
 */
CAttachment	*UserChannel::GetAttachment(void)
{
	return m_pUserAttachment;
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to cause the Channel object to issue a
 *		merge request to the pending top provier.
 */
Void	UserChannel::IssueMergeRequest ()
{
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_attributes.channel_type = USER_CHANNEL;
		if (m_JoinedAttachmentList.IsEmpty() == FALSE)
			channel_attributes.u.user_channel_attributes.joined = TRUE;
		else
			channel_attributes.u.user_channel_attributes.joined = FALSE;
		channel_attributes.u.user_channel_attributes.user_id = Channel_ID;

		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function overrides the base class implementation.  The main
 *		difference is that this implementation only allows a user to join
 *		their own channel.  No one else is allowed to join it.
 *
 *		Also, since it is possible to have a user channel object with no one
 *		joined to it, this request will be forwarded upward to the Top
 *		Provider from here (unless this is the Top Provider).
 */
Void	UserChannel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	See if the requesting user ID is the same as that of the user this
	 *	UserChannel object represents.
	 */
	if (uidInitiator == Channel_ID)
	{
		/*
		 *	See if the user is already joined to the channel.
		 */
		if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
		{
			/*
			 *	The user is not joined to the channel.  If this is the Top
			 *	Provider, then the request can be processed here.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Add the user to its own channel, and issue a successful
				 *	channel join confirm to the user.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"user joining own user ID channel = %04X",
						uidInitiator));

				m_JoinedAttachmentList.Append(pOrigAtt);
	
				pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the join request
				 *	upward to the Top Provider.
				 */
				TRACE_OUT (("UserChannel::ChannelJoinRequest: "
						"forwarding join request to Top Provider"));

				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, Channel_ID);
			}
		}
		else
		{
			/*
			 *	The user is already joined to their channel.  Go ahead and
			 *	issue a successful channel join confirm.
			 */
			WARNING_OUT (("UserChannel::ChannelJoinRequest: "
					"user already joined to own user channel"));

			pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
		}
	}
	else
	{
		/*
		 *	Someone is trying to join someone elses channel.  This is not
		 *	valid.  Reject the request without further processing.
		 */
		WARNING_OUT (("UserChannel::ChannelJoinRequest: "
				"rejecting attempt to join someone elses user channel"));

		pOrigAtt->ChannelJoinConfirm(RESULT_OTHER_USER_ID, uidInitiator, channel_id, 0);
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.  Note that data
 *		is NEVER sent upward, since the user (who is the only one who can be
 *		joined to this channel) is in the sub-tree of this provider.  This helps
 *		to optimize network traffic.
 */
Void	UserChannel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());

	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments (except for one from whence the data came).
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (pAtt != pOrigAtt)
		{
			pAtt->SendDataIndication(type, data_packet);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\userdata.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);

/* 
 *	userdata.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CUserDataListContainer. CUserDataListContainer
 *		objects are used to maintain user data elements. A user data element
 *		consists of an Object Key and an optional octet string.  The Object
 *		Key data is maintained internally by this class by using an
 *		CObjectKeyContainer container.  The optional octet string data is maintained
 *		internally through the use of a Rogue Wave string container.
 *
 *	Protected Instance Variables:
 *		m_UserDataItemList
 *			List of structures used to hold the user data internally.
 *		m_pSetOfUserDataPDU
 *			Storage for the "PDU" form of the user data.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCUserData structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "userdata.h"
#include "clists.h"

USER_DATA::~USER_DATA(void)
{
	if (NULL != key)
    {
        key->Release();
    }
	delete poszOctetString;
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object
 *		from "API" data.  The constructor immediately copies the user data 
 *		passed in as a list of "GCCUserData" structures into it's internal form
 *		where a Rogue Wave container holds the data in the form of 
 *		USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(UINT cMembers, PGCCUserData *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = CopyUserDataList(cMembers, user_data_list);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object 
 *		from data passed in as a "PDU" SetOfUserData structure.  The user
 *		data is copied into it's internal form where a Rogue Wave container 
 *		holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(PSetOfUserData set_of_user_data, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	/*
	 * Copy the user data into the internal structures.
	 */
	*pRetCode = UnPackUserDataFromPDU(set_of_user_data);
}

/*
 *	CUserDataListContainer()
 *
 *	Public Function Description
 *		This CUserDataListContainer copy constructor is used to create a CUserDataListContainer 
 *		object from	another CUserDataListContainer object.  The constructor immediately
 *		copies the user data passed in into it's internal form where a Rogue 
 *		Wave list holds the data in the form of USER_DATA structures.
 */
CUserDataListContainer::
CUserDataListContainer(CUserDataListContainer *user_data_list, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('U','r','D','L')),
    m_UserDataItemList(DESIRED_MAX_USER_DATA_ITEMS),
    m_cbDataSize(0),
    m_pSetOfUserDataPDU(NULL)
{
	GCCError		rc;
	USER_DATA       *user_data_info_ptr;
	USER_DATA       *lpUsrDataInfo;

	/*
	 * Set up an iterator for the internal list of "info" structures in the
	 * CUserDataListContainer object to be copied.
	 */
	user_data_list->m_UserDataItemList.Reset();

	/*
	 * Copy each USER_DATA structure contained in the CUserDataListContainer object to
	 * be copied.
	 */
	while (NULL != (lpUsrDataInfo = user_data_list->m_UserDataItemList.Iterate()))
	{
		/*
		 * Create a new USER_DATA structure to hold each element of the new
		 * CUserDataListContainer object.  Report an error if creation of this structure
		 * fails.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Go ahead and insert the pointer to the USER_DATA structure
			 * into the internal Rogue Wave list.
			 */
			m_UserDataItemList.Append(user_data_info_ptr);

			/*
			 * Create a new CObjectKeyContainer object to hold the "key" using the 
			 * copy constructor for the CObjectKeyContainer class.  Check to be sure
			 * construction of the object is successful.  Note that validation
			 * of the object key data is not done here since this would be done
			 * when the original CUserDataListContainer object was created.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(lpUsrDataInfo->key, &rc);
			if ((NULL != user_data_info_ptr->key) && (GCC_NO_ERROR == rc))
			{
    			/*
    			 * If an octet string exists, create a new Rogue Wave string to hold
    			 * the octet string portion	of the "key" and copy the octet string 
    			 * from the old CUserDataListContainer object into the new USER_DATA 
    			 * structure.
    			 */
    			if (lpUsrDataInfo->poszOctetString != NULL)
    			{
    				if (NULL == (user_data_info_ptr->poszOctetString =
    									::My_strdupO(lpUsrDataInfo->poszOctetString)))
    				{
    					ERROR_OUT(("UserData::UserData: can't create octet string"));
    					rc = GCC_ALLOCATION_FAILURE;
    					goto MyExit;
    				}
    			}
    			else
    			{
    				ASSERT(NULL == user_data_info_ptr->poszOctetString);
    			}
			}
            else
			{
				ERROR_OUT(("UserData::UserData: Error creating new ObjectKeyData"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
		else
		{
			ERROR_OUT(("UserData::UserData: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

    rc = GCC_NO_ERROR;

MyExit:

    *pRetCode = rc;
}

/*
 *	~CUserDataListContainer()
 *
 *	Public Function Description
 *		This is the destructor for the CUserDataListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 */
CUserDataListContainer::
~CUserDataListContainer(void)
{
	/*
	 * Free any PDU data which may have not been freed.
	 */
	if (m_pSetOfUserDataPDU)
    {
		FreeUserDataListPDU();
    }

	/*
	 * Set up an iterator to use for iterating through the internal Rogue
	 * Wave list of USER_DATA structures.
	 */
	USER_DATA  *pUserDataItem;
	m_UserDataItemList.Reset();
	while (NULL != (pUserDataItem = m_UserDataItemList.Iterate()))
	{
		/*
		 * Delete any memory being referenced in the USER_DATA structure.
		 */
		delete pUserDataItem;
	}
}


/*
 *	LockUserDataList ()
 *
 *	Public Function Description:
 *		This routine locks the user data list and determines the amount of
 *		memory referenced by the "API" user data list structures.
 */
UINT CUserDataListContainer::
LockUserDataList(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data.  Otherwise, just increment the 
	 * lock count.
	 */
	if (Lock() == 1)
	{
		USER_DATA *lpUsrDataInfo;
		/*
		 * Set aside memory to hold the pointers to the GCCUserData structures
		 * as well as the structures themselves.  The "sizeof" the structure 
		 * must be rounded to an even four-byte boundary.
		 */
		m_cbDataSize = m_UserDataItemList.GetCount() * 
				(sizeof(PGCCUserData) + ROUNDTOBOUNDARY(sizeof(GCCUserData)) );

		m_UserDataItemList.Reset();
	 	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Lock the data for the object keys, adding the amount of memory
			 * necessary to hold the object key data to the total memory size.
			 */
			m_cbDataSize += lpUsrDataInfo->key->LockObjectKeyData();

			/*
			 * Check to see if this user data element contains the optional
			 * user data octet string.  Add the space to hold it if it exists.
			 */
			if (lpUsrDataInfo->poszOctetString != NULL)
			{
				/*
				 * Since the user data structure contains a pointer to a
				 * OSTR structure, we must add the amount of memory
				 * needed to hold the structure as well as the string data.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * The data referenced by the octet string is just the byte
				 * length of the octet string.
				 */
				m_cbDataSize += ROUNDTOBOUNDARY(lpUsrDataInfo->poszOctetString->length);
			}
		}
	}

	return m_cbDataSize;
}

/*
 *	GetUserDataList	()
 *
 *	Public Function Description:
 *		This routine retrieves user data elements contained in the user data
 *		object and returns them in the "API" form of a list of pointers to 
 *		"GCCUserData" structures.  The number of user data elements contained 
 *		in this object is also returned.
 */
UINT CUserDataListContainer::
GetUserDataList(USHORT *number_of_members, PGCCUserData **user_data_list, LPBYTE memory)
{
	UINT			cbDataSizeToRet = 0;
	UINT			data_length = 0;
	Int				user_data_counter = 0;
	PGCCUserData	user_data_ptr;
	
	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		USER_DATA  *lpUsrDataInfo;
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the number of user data entities and save a pointer to the 
		 * memory location passed in.  This is where the pointers to the 
		 * GCCUserData structures will be written.  The actual structures will 
		 * be written into memory immediately following the list of pointers.
		 */
		*number_of_members = (USHORT) m_UserDataItemList.GetCount();

		*user_data_list = (PGCCUserData *)memory;

		/*
		 * Save the amount of memory needed to hold the list of pointers
		 * as well as the actual user data structures.
		 */
		data_length = m_UserDataItemList.GetCount() * sizeof(PGCCUserData);

		/*
		 * Move the memory pointer past the list of user data pointers.  This 
		 * is where the first user data structure will be written.
		 */
		memory += data_length;

		/*
		 * Iterate through the internal list of USER_DATA structures,
		 * building "API" GCCUserData structures in memory.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			/*
			 * Save the pointer to the user data structure in the list 
			 * of pointers.
			 */
			user_data_ptr = (PGCCUserData)memory;
			(*user_data_list)[user_data_counter++] = user_data_ptr;

			/*
			 * Move the memory pointer past the user data structure.  This is 
			 * where the object key data and octet string data will be written.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCUserData));

			/*
			 * Fill in the user data structure starting with the object key.
			 */
			data_length = lpUsrDataInfo->key->GetGCCObjectKeyData(&user_data_ptr->key, memory);

			/*
			 * Move the memory pointer past the object key data.  This is 
			 * where the octet string structure will be written, if it exists.
			 * If the octet string does exist, save the memory pointer in the 
			 * user data structure's octet string pointer and fill in the 
			 * elements of the octet string structure.  Otherwise, set the
			 * octet string pointer to NULL.
			 */
			memory += data_length;

			if (lpUsrDataInfo->poszOctetString == NULL)
            {
				user_data_ptr->octet_string = NULL;
            }
			else
			{
				user_data_ptr->octet_string = (LPOSTR) memory;

				/*
				 * Move the memory pointer past the octet string structure.  
				 * This is where the actual string data for the octet string 
				 * will be written.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));

				/*
				 * Write the octet string data into memory and set the octet 
				 * string structure pointer and length.
				 */
				user_data_ptr->octet_string->length =
					lpUsrDataInfo->poszOctetString->length;
				user_data_ptr->octet_string->value = (LPBYTE)memory;

				/*
				 * Now copy the octet string data from the internal Rogue Wave
				 * string into the object key structure held in memory.
				 */		
				::CopyMemory(memory, lpUsrDataInfo->poszOctetString->value,
							lpUsrDataInfo->poszOctetString->length);

				/*
				 * Move the memory pointer past the octet string data.
				 */
				memory += ROUNDTOBOUNDARY(user_data_ptr->octet_string->length);
			}
		}
	}
	else
	{
    	*user_data_list = NULL;
		*number_of_members = 0;
		ERROR_OUT(("CUserDataListContainer::GetUserDataList: Error Data Not Locked"));
	}
	
	return cbDataSizeToRet;
}

/*
 *	UnLockUserDataList	()
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeUserDataList.  If so, the object will automatically delete
 *		itself.
 */
void CUserDataListContainer::
UnLockUserDataList(void)
{
	USER_DATA  *user_data_info_ptr;

	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock any memory locked for the CObjectKeyContainer objects in the
		 * internal USER_DATA structures.
		 */
		m_UserDataItemList.Reset();
		while (NULL != (user_data_info_ptr = m_UserDataItemList.Iterate()))
		{
			/*
			 * Unlock any CObjectKeyContainer memory being referenced in the 
			 * USER_DATA structure.
			 */
			if (user_data_info_ptr->key != NULL)
			{
				user_data_info_ptr->key->UnLockObjectKeyData ();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetUserDataPDU	()
 *
 *	Public Function Description:
 *		This routine converts the user data from it's internal form of a list
 *		of USER_DATA structures into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SetOfUserData" structure is 
 *		returned.
 */
GCCError CUserDataListContainer::
GetUserDataPDU(PSetOfUserData *set_of_user_data)
{
	GCCError				rc = GCC_NO_ERROR;
	PSetOfUserData			new_pdu_user_data_ptr;
	PSetOfUserData			old_pdu_user_data_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (NULL == m_pSetOfUserDataPDU)
	{
		USER_DATA  *lpUsrDataInfo;

		/*
		 * Iterate through the list of USER_DATA structures, converting 
		 * each into "PDU" form and saving the pointers in the linked list of 
		 * "SetsOfUserData".
		 */
		m_UserDataItemList.Reset();
		while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_pdu_user_data_ptr = new SetOfUserData;

			/*
			 * If an allocation failure occurs, call the routine which will
			 * iterate through the list freeing any data which had been
			 * allocated.
			 */
			if (new_pdu_user_data_ptr == NULL)
			{
				ERROR_OUT(("CUserDataListContainer::GetUserDataPDU: Allocation error, cleaning up"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			//
			// Ensure everything is clean.
			//
			::ZeroMemory(new_pdu_user_data_ptr, sizeof(SetOfUserData));

			/*
			 * The first time through, set the PDU structure pointer equal
			 * to the first SetOfUserData created.  On subsequent loops, set
			 * the structure's "next" pointer equal to the new structure.
			 */
			if (m_pSetOfUserDataPDU == NULL)
			{
				m_pSetOfUserDataPDU = new_pdu_user_data_ptr;
			}
			else
            {
				old_pdu_user_data_ptr->next = new_pdu_user_data_ptr;
            }

			old_pdu_user_data_ptr = new_pdu_user_data_ptr;

			/*
			 * Initialize the new "next" pointer to NULL and convert the
			 * user data element.
			 */
			new_pdu_user_data_ptr->next = NULL;

			if (ConvertUserDataInfoToPDUUserData(lpUsrDataInfo, new_pdu_user_data_ptr) != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::GetUserDataPDU: can't convert USER_DATA to PDU"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}
		}

		if (GCC_NO_ERROR != rc)
		{
			FreeUserDataListPDU();
			ASSERT(NULL == m_pSetOfUserDataPDU);
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*set_of_user_data = m_pSetOfUserDataPDU;

	return rc;
}

/*
 *	FreeUserDataListPDU	()
 *
 *	Public Function Description:
 *		This routine frees any data which was allocated as a result of a call
 *		to "GetUserDataPDU" which was called in order to build up a "PDU"
 *		structure holding the user data.
 */
void CUserDataListContainer::
FreeUserDataListPDU(void)
{
	PSetOfUserData		pdu_user_data_set;
	PSetOfUserData		next_pdu_user_data_set;
	USER_DATA           *lpUsrDataInfo;

	/*
	 * Check to make sure "PDU" data has been allocated for this object.
	 */
	if (NULL != m_pSetOfUserDataPDU)
	{
		pdu_user_data_set = m_pSetOfUserDataPDU;
        m_pSetOfUserDataPDU = NULL; // so no one can use it now.

		/*
		 * Loop through the list, freeing the user data associated with 
		 * each structure contained in the list.
		 */
		while (pdu_user_data_set != NULL)
		{
			next_pdu_user_data_set = pdu_user_data_set->next;
			delete pdu_user_data_set;
			pdu_user_data_set = next_pdu_user_data_set;
		}
	}
	else
	{
		TRACE_OUT(("CUserDataListContainer::FreeUserDataListPDU: Error PDU data not allocated"));
	}

	/*
	 * Iterate through the internal list, telling each CObjectKeyContainer object
	 * to free any PDU data which it has allocated.
	 */
	m_UserDataItemList.Reset();
	while (NULL != (lpUsrDataInfo = m_UserDataItemList.Iterate()))
	{
		if (lpUsrDataInfo->key != NULL)
        {
			lpUsrDataInfo->key->FreeObjectKeyDataPDU();
        }
	}
}

/*
 *	GCCError	CopyUserDataList ( 	UINT					number_of_members,
 *									PGCCUserData	*		user_data_list)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine copies the user data passed in as "API" data into it's
 *		internal form where the Rogue Wave m_UserDataItemList holds the data
 *		in the form of USER_DATA structures.
 *
 *	Formal Parameters:
 *		number_of_members	(i) The number of elements in the user data list.
 *		user_datalist		(i)	The list holding the user data to store.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
CopyUserDataList(UINT number_of_members, PGCCUserData *user_data_list)
{
	GCCError				rc = GCC_NO_ERROR;
	USER_DATA			    *user_data_info_ptr;
	UINT					i;
	LPOSTR      			octet_string_ptr;

	/*
	 * Return an error if no user data is passed in.
	 */
	if (number_of_members == 0)
		return (GCC_BAD_USER_DATA);

	for (i = 0; i < number_of_members; i++)
	{
		/*
		 * Create a new "info" structure to hold the user data internally.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr = new USER_DATA;
		if (user_data_info_ptr != NULL)
		{
		    user_data_info_ptr->poszOctetString = NULL;

			/*
			 * Create a new CObjectKeyContainer object which will be used to store
			 * the "key" portion of the object data internally.
			 */
    		DBG_SAVE_FILE_LINE
			user_data_info_ptr->key = new CObjectKeyContainer(&user_data_list[i]->key, &rc);
			if (user_data_info_ptr->key == NULL)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else if (rc != GCC_NO_ERROR)
			{
				ERROR_OUT(("UserData::CopyUserDataList: Error creating new CObjectKeyContainer - bad data"));
				goto MyExit;
    		}

			/*
			 * Store the optional user data octet string in the list.
			 */
			octet_string_ptr = user_data_list[i]->octet_string;

			if ((octet_string_ptr != NULL) && (rc == GCC_NO_ERROR))
			{
				/*
				 * Create a new Rogue Wave string container to hold the
				 * octet string.
				 */
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
									octet_string_ptr->value,
									octet_string_ptr->length)))
				{	
					ERROR_OUT(("UserData::CopyUserDataList: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}
		else
		{
			ERROR_OUT(("UserData::CopyUserDataList: can't create USER_DATA"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		/*
		 * Insert the pointer to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	UnPackUserDataFromPDU (PSetOfUserData		set_of_user_data)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine unpacks the user data from the "PDU" form into the
 *		internal form which is maintained as a Rogue Wave list of USER_DATA
 *		structures.
 *
 *	Formal Parameters:
 *		set_of_user_data	(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
UnPackUserDataFromPDU(PSetOfUserData set_of_user_data)
{
	PSetOfUserData		pUserData;
	GCCError			rc = GCC_NO_ERROR;

    for (pUserData = set_of_user_data; NULL != pUserData; pUserData = pUserData->next)
	{ 
		/*
		 * Convert the user data elements into the internal format which
		 * is a USER_DATA structure and insert the pointers to the 
		 * USER_DATA structures into the m_UserDataItemList.
		 */  
		if (ConvertPDUDataToInternal(pUserData) != GCC_NO_ERROR)
		{
			ERROR_OUT(("CUserDataListContainer::UnPackUserDataFromPDU: Error converting PDU data to internal"));
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}
	}

	return rc;
}

/*
 *	GCCError	ConvertPDUDataToInternal ( PSetOfUserData		user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts an individual user data element from the "PDU" 
 *		structure form into	the internal form which is a USER_DATA	
 *		structure.
 *
 *	Formal Parameters:
 *		user_data_ptr		(i) The "PDU" user data list to copy.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertPDUDataToInternal(PSetOfUserData user_data_ptr)
{
	USER_DATA   		*user_data_info_ptr;
	GCCError			rc = GCC_NO_ERROR;

	DBG_SAVE_FILE_LINE
	user_data_info_ptr = new USER_DATA;
	if (user_data_info_ptr != NULL)
	{
	    user_data_info_ptr->poszOctetString = NULL;

		/*
		 * Create a new CObjectKeyContainer object which will be used to store the
		 * "key" portion of the user data internally.  If an error occurs
		 * constructing the key report it.  Otherwise, check for any user data
		 * which may need to be stored.	 Note that any error in creating the 
		 * CObjectKeyContainer object is reported as an allocation failure.  An error
		 * could occur if a bad object	key was received as PDU data but this 
		 * would have originated from some other provider since we validate all
		 * object keys created locally.  We therefore report it as an allocation
		 * failure.
		 */
		DBG_SAVE_FILE_LINE
		user_data_info_ptr->key = new CObjectKeyContainer(&user_data_ptr->user_data_element.key, &rc);
		if ((user_data_info_ptr->key == NULL) || (rc != GCC_NO_ERROR))
		{
			ERROR_OUT(("UserData::ConvertPDUDataToInternal: Error creating new CObjectKeyContainer"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
		else
		{
			/*
			 * The object key was successfully saved so store any actual user 
			 * data in the list if it is present.
			 */
			if (user_data_ptr->user_data_element.bit_mask & USER_DATA_FIELD_PRESENT)
			{
				if (NULL == (user_data_info_ptr->poszOctetString = ::My_strdupO2(
								user_data_ptr->user_data_element.user_data_field.value,
								user_data_ptr->user_data_element.user_data_field.length)))
				{	
					ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create octet string"));
					rc = GCC_ALLOCATION_FAILURE;
					goto MyExit;
				}
			}
			else
			{
				ASSERT(NULL == user_data_info_ptr->poszOctetString);
			}
		}

		/*
		 * Initialize the structure pointers to NULL and insert the pointer
		 * to the USER_DATA structure into the Rogue Wave list.
		 */
		m_UserDataItemList.Append(user_data_info_ptr);
	}
	else
	{
		ERROR_OUT(("UserData::ConvertPDUDataToInternal: can't create USER_DATA"));
		rc = GCC_ALLOCATION_FAILURE;
		// goto MyExit;
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete user_data_info_ptr;
    }

	return rc;
}

/*
 *	GCCError	ConvertUserDataInfoToPDUUserData (	
 *									USER_DATA		*user_data_info_ptr,
 *									PSetOfUserData		pdu_user_data_ptr)
 *
 *	Private member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine converts the user data from the internal form which is a 
 *		USER_DATA structure into the "PDU" structure form "SetOfUserData".
 *
 *	Formal Parameters:
 *		user_data_info_ptr	(i) The internal user data structure to convert.
 *		pdu_user_data_ptr	(o)	The structure to hold the PDU data after
 *									conversion.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PARAMETER			-	The internal key pointer was
 *												corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
GCCError CUserDataListContainer::
ConvertUserDataInfoToPDUUserData(USER_DATA *user_data_info_ptr, PSetOfUserData pdu_user_data_ptr)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize the user data bit mask to zero.
	 */
	pdu_user_data_ptr->user_data_element.bit_mask = 0;

	/*
	 * Fill in the octet string pointer and length if the octet string 
	 * exists.  Set the bit mask indicating that the string exists.
	 */
	if (user_data_info_ptr->poszOctetString != NULL)
	{
		pdu_user_data_ptr->user_data_element.user_data_field.value =
				user_data_info_ptr->poszOctetString->value;
		pdu_user_data_ptr->user_data_element.user_data_field.length =
				user_data_info_ptr->poszOctetString->length;

		pdu_user_data_ptr->user_data_element.bit_mask |= USER_DATA_FIELD_PRESENT;
	}
	
	/*
	 * Fill in the object key data.
	 */
	if (user_data_info_ptr->key != NULL)
	{
		/*
		 * Retrieve the "PDU" object key data from the internal CObjectKeyContainer
		 * object.
		 */
		if (user_data_info_ptr->key->GetObjectKeyDataPDU (
				&pdu_user_data_ptr->user_data_element.key) != GCC_NO_ERROR)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("UserData::ConvertUserDataInfoToPDUUserData: no valid UserDataInfo key"));
		rc = GCC_INVALID_PARAMETER;
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\user.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	user.cpp
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the User class.  Objects of this
 *		class represent the attachment between a user application and an MCS
 *		domain.  It "talks" to the application through an application interface
 *		object, which is identified to it as a constructor parameter.  Since
 *		this class inherits from CommandTarget, it can talk to the domain
 *		object using the MCS command language defined therein.  The domain
 *		object to which it must attach is another constructor parameter.
 *
 *		When one of these objects is first created, it must register its
 *		presence with both the application interface object above it, and the
 *		domain object below it.  To register with the application interface
 *		object it sends it a registration message through the owner callback.
 *		To register with the domain object, it issues an attach user request
 *		on behalf of the application that created this attachment.
 *
 *		This module contains code to perform three different tasks: accept
 *		T.122 requests and responses from the user application and forward them
 *		to the domain as MCS commands; accept MCS commands from the domain and
 *		forward them to the application as T.122 primitives; and buffer those
 *		indications and confirms until the controller allocates a time slice in
 *		which to send them.
 *
 *		T.122 requests and responses come from the application interface as
 *		public member functions whose name is prefixed with "MCS" (for example,
 *		"MCSChannelJoinRequest").  After validation, the equivalent MCS command
 *		(whose name does NOT begin with "MCS") is sent to the domain object.
 *
 *		MCS commands come from the domain object as public member functions that
 *		are inherited from CommandTarget and overridden by this class.  The
 *		names of these functions are NOT prefixed with "MCS".  Any MCS commands
 *		that do not map to (or can be converted to) T.122 primitives are simply
 *		not overridden.  The default behavior of these functions ,as defined in
 *		the CommandTarget class, is to return an error.
 *
 *		Indication and confirm primitives are buffered by objects of this class
 *		before being sent to the application.  This allows the controller more
 *		flexibility in the timing of events in the system.  This is done by
 *		allocating a structure to hold the information associated with the
 *		primitive, and then putting a pointer to that structure into a linked
 *		list.  When the command comes to flush this message queue, the
 *		primitives are sent to the application interface object through the
 *		owner callback, and the structures are released.
 *
 *	Private Instance Variables:
 *		m_pDomain
 *			This is a pointer to the domain, to which this user is (or wishes
 *			to be) attached.
 *		User_ID
 *			This is the user ID assigned to this user attachment.  This is
 *			guaranteed to be unique ONLY within this domain.  Note that a value
 *			of 0 (zero) indicates that this user is not yet attached to the
 *			domain.  This is set by a successful attach user confirm, and the
 *			user application should wait until that confirm is received before
 *			trying to invoke any other MCS services.
 *		Merge_In_Progress
 *			This is a boolean flag that indicates whether or not the attached
 *			Domain object is in the merge state.  When in the merge state it
 *			is invalid to send it any MCS commands.
 *		Deletion_Pending
 *			This is a boolean flag that indicates whether or not an internally
 *			requested deletion is pending.  This is used by the destructor to
 *			determine if a deletion was requested by the object itself, or is
 *			simply an asynchronous event.
 *		Maximum_User_Data_Length
 *			This is the maximum amount of user data that can be placed into
 *			a single MCS PDU.  This number is derived from the arbitrated
 *			maximum MCS PDU size (minus enough space for overhead bytes).
 *
 *	Private Member Functions:
 *		ValidateUserRequest
 *			This member function is called each time the user application makes
 *			a request.  It checks the current state of the system to see if
 *			conditions are such that the request can be processed at the
 *			current time.
 *		PurgeMessageQueue
 *			This member function walks through the current message queue,
 *			freeing all resources held therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

 #include "omcscode.h"

#define USER_MSG_BASE       WM_APP

/*
 *	bugbug:
 *	The following constant is only used to cover a bug in NM 2.0 for backward
 *	compatibility purposes.  NM 2.0 can not accept MCS data PDUs with more than
 *	4096 bytes of user data.  Because of the Max MCS PDU size we negotiate (4128),
 *	even in NM 2.0, we should have been able to send 4120 bytes.  But NM 2.0 chokes
 *	in this case.
 *	The constant should eliminated after NM 3.0.
 */
#define		BER_PROTOCOL_EXTRA_OVERHEAD		24

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder				*g_MCSCoder;
// The external MCS Controller object
extern PController				g_pMCSController;
// The global MCS Critical Section
extern CRITICAL_SECTION 		g_MCS_Critical_Section;
// The DLL's HINSTANCE
extern HINSTANCE 				g_hDllInst;
// Class name for windows used by MCS attachments.
static char						s_WindowClassName[CLASS_NAME_LENGTH];


// Initialization of the class's static variables.
CTimerUserList2* User::s_pTimerUserList2 = NULL;
HINSTANCE		 User::s_hInstance = NULL;

/*
 *	BOOL		InitializeClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function initializes the class's static variables.  It is
 *	called during the MCS Controller's construction.
 */
BOOL User::InitializeClass (void)
{
		BOOL		bReturnValue;
		WNDCLASS	window_class;

	DBG_SAVE_FILE_LINE
	s_pTimerUserList2 = new CTimerUserList2();
	bReturnValue = (s_pTimerUserList2 != NULL);

	if (bReturnValue) {
		//	Construct the window class name
		wsprintf (s_WindowClassName, "MCS Window %x %x", GetCurrentProcessId(), GetTickCount());

		/*
		 *	Fill out a window class structure in preparation for registering
		 *	the window with Windows.  Note that since this is a hidden
		 *	window, most of the fields can be set to NULL or 0.
		 */
		ZeroMemory (&window_class, sizeof(WNDCLASS));
		window_class.lpfnWndProc	= UserWindowProc;
		window_class.hInstance		= s_hInstance = g_hDllInst;
		window_class.lpszClassName	= s_WindowClassName;

		/*
		 *	Register the class with Windows so that we can create a window
		 *	for use by this portal.
		 */
		if (RegisterClass (&window_class) == 0)
		{
			ERROR_OUT (("InitWindowPortals: window class registration failed. Error: %d", GetLastError()));
			bReturnValue = FALSE;
		}
	}
	else {
		ERROR_OUT(("User::InitializeClass: Failed to allocate timer dictionary."));
	}

	return bReturnValue;
}


/*
 *	void		CleanupClass ()
 *
 *	Public, static
 *
 *	Functional Description
 *
 *	This function cleans up the class's static variables.  It is
 *	called when the MCS Controller is deleted.
 */
void User::CleanupClass (void)
{
	delete s_pTimerUserList2;
	UnregisterClass (s_WindowClassName, s_hInstance);
}

/*
 *	MCSError	MCS_AttachRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This API entry point is used to attach to an existing domain.  Once
 *		attached, a user application can utilize the services of MCS.  When
 *		a user application is through with MCS, it should detach from the domain
 *		by calling MCSDetachUserRequest (see below).
 */
MCSError WINAPI MCS_AttachRequest (IMCSSap **			ppIMCSSap,
							DomainSelector		domain_selector,
							UINT,                                   // domain_selector_length
							MCSCallBack			user_callback,
							PVoid				user_defined,
							UINT				flags)
{
	MCSError				return_value = MCS_NO_ERROR;
	AttachRequestInfo		attach_request_info;
	PUser					pUser;

	TRACE_OUT(("AttachUserRequest: beginning attachment process"));
	ASSERT (user_callback);

	// Initialize the interface ptr.
	*ppIMCSSap = NULL;
	
	/*
	 *	Pack the attach parameters into a structure since they will not fit
	 *	into the one parameter we have available in the owner callback.
	 */
	attach_request_info.domain_selector = (GCCConfID *) domain_selector;
	attach_request_info.ppuser = &pUser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	if (g_pMCSController != NULL) {

		/*
		 *	Send an attach user request message to the controller through its
		 *	owner callback function.
		 */
		return_value = g_pMCSController->HandleAppletAttachUserRequest(&attach_request_info);
		if (return_value == (ULong) MCS_NO_ERROR)
		{
			// Set the returned interface ptr
			*ppIMCSSap = (IMCSSap *) pUser;

			/*
			 *	If the request was accepted, then register
			 *	the new user attachment.  Note that there
			 *	is still no user ID associated with this
			 *	attachment, since the attach user confirm
			 *	has not yet been received.
			 */
			pUser->RegisterUserAttachment (user_callback, user_defined,
											flags);
		}
	}
	else {
		ERROR_OUT(("MCS_AttachRequest: MCS Provider is not initialized."));
		return_value = MCS_NOT_INITIALIZED;
	}
	/*
	 *	Leave the critical section before returning.
	 */
	LeaveCriticalSection (& g_MCS_Critical_Section);
	
	return (return_value);
}


/*
 *	User ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the user class.  It initializes all instance
 *		variables (mostly with passed in information).  It then registers its
 *		presence with the application interface object, so that user requests
 *		and responses will get here okay.  Finally, it issues an attach user
 *		request to the domain to start the attachment process.
 */
User::User (PDomain		pDomain,
			PMCSError	pError)
:
    CAttachment(USER_ATTACHMENT),
	m_pDomain(pDomain),
	Deletion_Pending (FALSE),
	User_ID (0),
	Merge_In_Progress (FALSE),
	m_DataPktQueue(),
	m_PostMsgPendingQueue(),
	m_DataIndMemoryBuf2(),
	CRefCount(MAKE_STAMP_ID('U','s','e','r'))
{
	DomainParameters		domain_parameters;

	g_pMCSController->AddRef();
	/*
	 * We now need to create the window that the MCS Provider
	 * will use to deliver MCS messages to the attachment.
	 * These messages are indications and confirms.
	 */
	m_hWnd = CreateWindow (s_WindowClassName,
							NULL,
							WS_POPUP,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							CW_USEDEFAULT,
							NULL,
							NULL,
							g_hDllInst,
							NULL);

	if (m_hWnd != NULL) {
		/*
		 *	Call the domain object to find out the current domain parameters.
		 *	From this, set the maximum user data length appropriately.
		 */
		m_pDomain->GetDomainParameters (&domain_parameters, NULL, NULL);
		Maximum_User_Data_Length = domain_parameters.max_mcspdu_size -
									(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
									BER_PROTOCOL_EXTRA_OVERHEAD);
		TRACE_OUT (("User::User: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

		/*
		 *	Use the specified domain parameters to set the type of encoding rules
		 *	to be used.
		 */
		ASSERT (domain_parameters.protocol_version == PROTOCOL_VERSION_PACKED);

		/*
		 *	Send an attach user request to the specified domain.
		 */
		m_pDomain->AttachUserRequest (this);
		*pError = MCS_NO_ERROR;
	}
	else {
		*pError = MCS_ALLOCATION_FAILURE;
	}
}

/*
 *	~User ()
 *
 *	Public
 *
 *	Functional Description:
 *		
 */
User::~User ()
{
	PDataPacket packet;
	while (NULL != (packet = m_PostMsgPendingQueue.Get()))
	{
		packet->Unlock();
    }

	if (m_hWnd) {
		// Destroy the window; we do not need it anymore
		DestroyWindow (m_hWnd);
	}
	g_pMCSController->Release();
}

/*
 *	MCSError	GetBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function allocates an MCS buffer for a user attachment.
 *		Because this function allocates a buffer for the user and a Memory
 *		object that immediately precedes the buffer, after the user fills in
 *		the buffer with data and gives it to MCS to send, it needs to specify the
 *		right flags in the SendData request API.
 */

MCSError User::GetBuffer (UINT	size, PVoid	*pbuffer)
{

	MCSError				return_value;
	PMemory					memory;

	EnterCriticalSection (& g_MCS_Critical_Section);
	
	/*
	 *	This request may be a retry from a previous request which
	 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
	 *	buffer retry info structure since resource levels will be
	 *	checked in this function anyway.
	 */
	if (m_BufferRetryInfo != NULL) {
		KillTimer (NULL, m_BufferRetryInfo->timer_id);
		s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
		delete m_BufferRetryInfo;
		m_BufferRetryInfo = NULL;
		
	}

	// Allocate the memory
	DBG_SAVE_FILE_LINE
	memory = AllocateMemory (NULL, size + MAXIMUM_PROTOCOL_OVERHEAD,
							 SEND_PRIORITY);
							
	LeaveCriticalSection (& g_MCS_Critical_Section);

	if (NULL != memory) {
		// the allocation succeeded.
		ASSERT ((PUChar) memory + sizeof(Memory) == memory->GetPointer());
		*pbuffer = (PVoid) (memory->GetPointer() + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_NO_ERROR;
	}
	else {
		// the allocation failed.
		TRACE_OUT (("User::GetBuffer: Failed to allocate data buffer."));
		CreateRetryTimer (size + MAXIMUM_PROTOCOL_OVERHEAD);
		return_value = MCS_TRANSMIT_BUFFER_FULL;
	}
	return (return_value);
}

/*
 *	MCSError	FreeBuffer ()
 *
 *	Public
 *
 *	Functional Description:
 */

void User::FreeBuffer (PVoid	buffer_ptr)
{
		PMemory		memory;

	ASSERT (m_fFreeDataIndBuffer == FALSE);

	/*
	 *	Attempt to find the buffer in the m_DataIndDictionary dictionary.
	 *	This is where irregular data indications go.
	 */
	if (NULL == (memory = m_DataIndMemoryBuf2.Remove(buffer_ptr)))
    {
		memory = GetMemoryObject(buffer_ptr);
    }

	// Free the memory.
	EnterCriticalSection (& g_MCS_Critical_Section);
	FreeMemory (memory);
	LeaveCriticalSection (& g_MCS_Critical_Section);
}

/*
 *	Void	CreateRetryTimer
 *
 *	Private
 *
 *	Functional Description
 *		This functions creates a timer in response to a failure to
 *		allocate memory for the send data that the user is trying to
 *		send.  The timer will fire off periodically so that this code
 *		will remember to check the memory levels and provide an
 *		MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
 *
 *	Return Value:
 *		None.
 *
 *	Side effects:
 *		The timer is created.
 */

Void User::CreateRetryTimer (ULong size)
{
	UINT_PTR timer_id;
			
	timer_id = SetTimer (NULL, 0, TIMER_PROCEDURE_TIMEOUT, (TIMERPROC) TimerProc);
	if (timer_id != 0) {
		DBG_SAVE_FILE_LINE
		m_BufferRetryInfo = new BufferRetryInfo;

		if (m_BufferRetryInfo != NULL) {
			m_BufferRetryInfo->user_data_length = size;
			m_BufferRetryInfo->timer_id = timer_id;

			s_pTimerUserList2->Append(timer_id, this);
		}
		else {
			ERROR_OUT (("User::CreateRetryTimer: Failed to allocate BufferRetryInfo struct."));
			KillTimer (NULL, timer_id);
		}
	}
	else {
		/*
		 *	This is a bad error, The notification to the user when buffers
		 *	are available will be lost.  Hopefully, the user will try again
		 *	later.
		 */
		WARNING_OUT(("User::CreateRetryTimer: Could not SetTimer."));
	}
}

/*
 *	MCSError	ReleaseInterface ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when a user wishes to detach from the domain.
 *		It kicks off the process of detaching, and seeing that this object
 *		is properly deleted.
 */
MCSError	User::ReleaseInterface ()
{
	CUidList		deletion_list;
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Check to see if there is a merge operation in progress before proceeding
	 *	with the request.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	If deletion is not already pending, then it is necessary for us
		 *	to tell the domain that we are leaving.
		 */
		if (Deletion_Pending == FALSE)
		{
			/*
			 *	If we are already attached, user ID will not be 0, and we
			 *	should send a detach user request.  If user ID IS 0, then we
			 *	are not yet attached to the domain, so a disconnect provider
			 *	ultimatum is used instead.
			 */
			if (User_ID != 0)
			{
				deletion_list.Append(User_ID);
				m_pDomain->DetachUserRequest (this,
							REASON_USER_REQUESTED, &deletion_list);
				User_ID = 0;
			}
			else
				m_pDomain->DisconnectProviderUltimatum (this,
							REASON_USER_REQUESTED);

			/*
			 *	Set the flag that will cause the object to be deleted during
			 *	the next call to FlushMessageQueue.
			 */
			Deletion_Pending = TRUE;
		}

		/*
		 *	Empty out the message queue (the application should receive no
		 *	messages once the attachment has been deleted).
		 */
		PurgeMessageQueue ();

		// Cleanup timers and retry structures;
		if (m_BufferRetryInfo != NULL) {
			s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
			KillTimer (NULL, m_BufferRetryInfo->timer_id);
			delete m_BufferRetryInfo;
			m_BufferRetryInfo = NULL;
		}

		return_value = MCS_NO_ERROR;

		// Release can release the MCS Controller, so, we have to exit the CS now.
		LeaveCriticalSection (& g_MCS_Critical_Section);
		
		/*
		 *	Release this object. Note that the object may be deleted
		 *	here, so, we should not access any member variables after this
		 *	call.
		 */
		Release();
	}
	else
	{
		LeaveCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 */
		WARNING_OUT (("User::ReleaseInterface: "
				"merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

#define CHANNEL_JOIN		0
#define CHANNEL_LEAVE		1
#define CHANNEL_CONVENE		2
#define CHANNEL_DISBAND		3

/*
 *	MCSError	ChannelJLCD ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join/leave/convene/disband
 *		a channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJLCD (int type, ChannelID channel_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR) {
		switch (type) {
		case CHANNEL_JOIN:
			m_pDomain->ChannelJoinRequest (this, User_ID, channel_id);
			break;
		case CHANNEL_LEAVE:
			{
				CChannelIDList	deletion_list;
				deletion_list.Append(channel_id);
				m_pDomain->ChannelLeaveRequest (this, &deletion_list);
			}
			break;
		case CHANNEL_CONVENE:
			m_pDomain->ChannelConveneRequest (this, User_ID);
			break;
		case CHANNEL_DISBAND:
			m_pDomain->ChannelDisbandRequest (this, User_ID, channel_id);
			break;
		}
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	ChannelJoin ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to join a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelJoin (ChannelID channel_id)
{
	return (ChannelJLCD (CHANNEL_JOIN, channel_id));
}

/*
 *	MCSError	ChannelLeave ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to leave a
 *		channel.  If the user is attached to the domain, the request will be
 *		repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelLeave (ChannelID	channel_id)
{
	return (ChannelJLCD (CHANNEL_LEAVE, channel_id));
}

/*
 *	MCSError	ChannelConvene ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to convene a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelConvene ()
{
	return (ChannelJLCD (CHANNEL_CONVENE, 0));
}

/*
 *	MCSError	ChannelDisband ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to disband a
 *		private channel.  If the user is attached to the domain, the request
 *		will be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::ChannelDisband (
					ChannelID			channel_id)
{
	return (ChannelJLCD (CHANNEL_DISBAND, channel_id));
}

/*
 *	MCSError	ChannelAdmit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to admit more
 *		users to a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelAdmit (
					ChannelID			channel_id,
					PUserID				user_id_list,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Verify that the value of each user ID included in the user ID list is
	 *	a valid value.  Otherwise, fail the call.
	 */
	for (count = 0; count < user_id_count; count++)
	{
		if (user_id_list[count] > 1000) {
			// add the UserID into the singly-linked list.
			local_user_id_list.Append(user_id_list[count]);
		}
		else {
			return_value = MCS_INVALID_PARAMETER;
			break;
		}
	}

	if (return_value == MCS_NO_ERROR) {

		EnterCriticalSection (& g_MCS_Critical_Section);
	
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR)
		{
			m_pDomain->ChannelAdmitRequest (this, User_ID, channel_id,
												&local_user_id_list);
		}

		LeaveCriticalSection (& g_MCS_Critical_Section);
	}

	return (return_value);
}

#ifdef USE_CHANNEL_EXPEL_REQUEST
/*
 *	MCSError	MCSChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to expel
 *		users from a private channel for which it is manager.  If the user is
 *		attached to the domain, the request will be repackaged as an MCS command
 *		and sent to the domain object.
 */
MCSError	User::ChannelExpel (
					ChannelID			channel_id,
					PMemory				memory,
					UINT				user_id_count)
{
	UINT			count;
	CUidList		local_user_id_list;
	MCSError		return_value;
	PUserID			user_id_list = (PUserID) memory->GetPointer();

	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		/*
		 *	Repack the user ID list into an S-list before sending it on.
		 */
		for (count=0; count < user_id_count; count++)
			local_user_id_list.append ((DWORD) user_id_list[count]);

		m_pDomain->ChannelExpelRequest (this, User_ID, channel_id,
				&local_user_id_list);
	}

	if (return_value != MCS_DOMAIN_MERGING)
		FreeMemory (memory);

	return (return_value);
}
#endif // USE_CHANNEL_EXPEL_REQUEST

/*
 *	MCSError	SendData ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to send data
 *		on a channel.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 *
 *		Note that this version of the send data request assumes that the user
 *		data has not already been segmented.  This is the function that
 *		performs the segmentation.
 */
MCSError	User::SendData (DataRequestType		request_type,
							ChannelID			channel_id,
							Priority			priority,
							unsigned char *		user_data,
							ULong		 		user_data_length,
							SendDataFlags		flags)
{
	MCSError			return_value = MCS_NO_ERROR;
	ULong				i, request_count, user_packet_length;
	PDataPacket			packet;
	ASN1choice_t		choice;
	UINT				type;
	PUChar				data_ptr = user_data;
	PacketError			packet_error;
	Segmentation		segmentation;
	PMemory				memory;
	PDataPacket			*packets;

	/*
	 *	Calculate how many different MCS packets are going to be generated.
	 *	Remember that if the size of the request exceeds the maximum allowed
	 *	value, we will segment the data into multiple smaller pieces.
	 */
	request_count = ((user_data_length + (Maximum_User_Data_Length - 1)) /
					Maximum_User_Data_Length);

	/*
	 *	Allocate the array of PDataPackets, before we get the critical section.
	 */
	if (request_count == 1) {
		packets = &packet;
		packet = NULL;
	}
	else {
		DBG_SAVE_FILE_LINE
		packets = new PDataPacket[request_count];
		if (packets == NULL) {
			ERROR_OUT (("User::SendData: Failed to allocate packet array."));
			return_value = MCS_TRANSMIT_BUFFER_FULL;
		}
		else {
			ZeroMemory ((PVoid) packets, request_count * sizeof(PDataPacket));
		}
	}

	if (MCS_NO_ERROR == return_value) {
		// Set the choice and type variables for all the DataPackets.
		if (NORMAL_SEND_DATA == request_type) {
			choice = SEND_DATA_REQUEST_CHOSEN;
			type = MCS_SEND_DATA_INDICATION;
		}
		else {
			choice = UNIFORM_SEND_DATA_REQUEST_CHOSEN;
			type = MCS_UNIFORM_SEND_DATA_INDICATION;
		}
					
		EnterCriticalSection (& g_MCS_Critical_Section);

		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();
	
		/*
		 *	Check to see if there is a merge operation in progress before proceeding
		 *	with the request.
		 */
		if (MCS_NO_ERROR == return_value) {

			/*
			 *	This request may be a retry from a previous request which
			 *	returned MCS_TRANSMIT_BUFFER_FULL.  If so, delete the associated
			 *	buffer retry info structure since resource levels will be
			 *	checked in this function anyway.
			 */
			if (m_BufferRetryInfo != NULL) {
                s_pTimerUserList2->Remove(m_BufferRetryInfo->timer_id);
				KillTimer (NULL, m_BufferRetryInfo->timer_id);
				delete m_BufferRetryInfo;
				m_BufferRetryInfo = NULL;
			}

			/*
			 *	Depending on the "flags" argument, we either have
			 *	to allocate the buffer space and copy the data into
			 *	it, or just create a Memory object for the supplied
			 *	buffer.
			 */
			if (flags != APP_ALLOCATION) {
		
				ASSERT (flags == MCS_ALLOCATION);
				/*
				 *	The buffer was allocated by MCS, thru an
				 *	MCSGetBufferRequest call.  So, the Memory object
				 *	must preceed the buffer.	
				 */
				 memory = GetMemoryObject (user_data);
				 ASSERT (SIGNATURE_MATCH(memory, MemorySignature));
			}
			else
				memory = NULL;

			/*
			 *	We now attempt to allocate all data packets at once.
			 *	We need to do that before starting to send them, because
			 *	the request has to be totally successful or totally fail.
			 *	We can not succeed in sending a part of the request.
			 */
			for (i = 0; (ULong) i < request_count; i++) {
				// take care of segmentation flags
				if (i == 0)
					// first segment
					segmentation = SEGMENTATION_BEGIN;
				else
					segmentation = 0;
				if (i == request_count - 1) {
					// last segment
					segmentation |= SEGMENTATION_END;
					user_packet_length = user_data_length - (ULong)(data_ptr - user_data);
				}
				else {
					user_packet_length = Maximum_User_Data_Length;
				}

				// Now, create the new DataPacket.
				DBG_SAVE_FILE_LINE
				packets[i] = new DataPacket (choice, data_ptr, user_packet_length,
									 (UINT) channel_id, priority,
									 segmentation, (UINT) User_ID,
									 flags, memory, &packet_error);

				// Make sure the allocation succeeded
				if ((packets[i] == NULL) || (packet_error != PACKET_NO_ERROR)) {
					/*
					 *	The allocation of the packet failed.  We must therefore
					 *	return a failure to the user application.
					 */
					WARNING_OUT (("User::SendData: data packet allocation failed"));
					return_value = MCS_TRANSMIT_BUFFER_FULL;
					break;
				}
					
				// Adjust the user data ptr
				data_ptr += Maximum_User_Data_Length;
			}

			if (return_value == MCS_NO_ERROR) {
				// We now can send the data.
				// Forward all the data packets to the appropriate places.
				for (i = 0; i < request_count; i++) {
					/*
					 *	Send the successfully created packet to the domain
					 *	for processing.
					 */
					m_pDomain->SendDataRequest (this, (UINT) type, packets[i]);

					/*
					 *	Enable the packet to free itself.  Note that it will not
					 *	actually do so until everyone that is using it is through
					 *	with it.  Also, if nobody has locked it so far,
					 *	it will be deleted.
					 */
					packets[i]->Unlock ();
				}
			}
			else {
				// some packet allocation failed
				for (i = 0; i < request_count; i++)
					delete packets[i];
			}
		}
		if (request_count > 1)
			delete [] packets;
	}

	if (MCS_TRANSMIT_BUFFER_FULL == return_value) {
		CreateRetryTimer(user_data_length + request_count * MAXIMUM_PROTOCOL_OVERHEAD);
	}
	else if (MCS_NO_ERROR == return_value) {
		FreeMemory (memory);
	}

	LeaveCriticalSection (& g_MCS_Critical_Section);
	return (return_value);
}

#define GRAB		0
#define INHIBIT		1
#define	PLEASE		2
#define RELEASE		3
#define TEST		4

/*
 *	MCSError	TokenGIRPT ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab/inhibit/request/release/test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGIRPT (int type, TokenID	token_id)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		switch (type) {
		case GRAB:
			m_pDomain->TokenGrabRequest (this, User_ID, token_id);
			break;
		case INHIBIT:
			m_pDomain->TokenInhibitRequest (this, User_ID, token_id);
			break;
		case PLEASE:
			m_pDomain->TokenPleaseRequest (this, User_ID, token_id);
			break;
		case RELEASE:
			m_pDomain->TokenReleaseRequest (this, User_ID, token_id);
			break;
		case TEST:
			m_pDomain->TokenTestRequest (this, User_ID, token_id);
			break;
		}
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenGrab ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to grab
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGrab (TokenID				token_id)
{
	return (TokenGIRPT (GRAB, token_id));
}

/*
 *	MCSError	TokenInhibit ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to inhibit
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenInhibit (TokenID				token_id)
{
	return (TokenGIRPT (INHIBIT, token_id));
}

/*
 *	MCSError	TokenGive ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to give away
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenGive (TokenID token_id, UserID receiver_id)
{
	MCSError		return_value;
	TokenGiveRecord TokenGiveRec;

	if (receiver_id > 1000) {
		// Fill in the TokenGive command structure.
		TokenGiveRec.uidInitiator = User_ID;
		TokenGiveRec.token_id = token_id;
		TokenGiveRec.receiver_id = receiver_id;

		EnterCriticalSection (& g_MCS_Critical_Section);
		/*
		 *	Verify that current conditions are appropriate for a request to be
		 *	accepted from a user attachment.
		 */
		return_value = ValidateUserRequest ();

		if (return_value == MCS_NO_ERROR) {	
			m_pDomain->TokenGiveRequest (this, &TokenGiveRec);
		}
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
	else {
		ERROR_OUT(("User::TokenGive: Invalid UserID for receiver."));
		return_value = MCS_INVALID_PARAMETER;
	}

	return (return_value);
}

/*
 *	MCSError	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to respond to
 *		a previously received token give indication.  If the user is attached to
 *		the domain, the request will be repackaged as an MCS command and sent to
 *		the domain object.
 */
MCSError	User::TokenGiveResponse (TokenID token_id, Result result)
{
	MCSError		return_value;

	EnterCriticalSection (& g_MCS_Critical_Section);
	/*
	 *	Verify that current conditions are appropriate for a request to be
	 *	accepted from a user attachment.
	 */
	return_value = ValidateUserRequest ();

	if (return_value == MCS_NO_ERROR)
	{
		m_pDomain->TokenGiveResponse (this, result, User_ID, token_id);
	}
	LeaveCriticalSection (& g_MCS_Critical_Section);

	return (return_value);
}

/*
 *	MCSError	TokenPlease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to be given
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenPlease (TokenID				token_id)
{
	return (TokenGIRPT (PLEASE, token_id));
}

/*
 *	MCSError	TokenRelease ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to release
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenRelease (TokenID	token_id)
{
	return (TokenGIRPT (RELEASE, token_id));
}

/*
 *	MCSError	TokenTest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the user application wishes to test
 *		a token.  If the user is attached to the domain, the request will
 *		be repackaged as an MCS command and sent to the domain object.
 */
MCSError	User::TokenTest (TokenID	token_id)
{
	return (TokenGIRPT (TEST, token_id));
}

/*
 *	MCSError	ValidateUserRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this user is not yet attached to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
MCSError	User::ValidateUserRequest ()
{
	MCSError		return_value = MCS_NO_ERROR;

	/*
	 *	Check to see if there is a merge operation in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure the user is attached to the domain.
		 */
		if (User_ID == 0)
		{
			/*
			 *	The user is not yet attached to the domain.  So fail the request
			 *	without passing it on to the domain object.
			 */
			TRACE_OUT (("User::ValidateUserRequest: user not attached"));
			return_value = MCS_USER_NOT_ATTACHED;
		}
	}
	else
	{
		/*
		 *	This operation could not be processed at this time due to a merge
		 *	operation in progress at the local provider.
		 *
		 *	NOTE for JASPER:
		 *	Jasper probably will need to wait on an event handle here, which will be
		 *	set when the main MCS thread receives all the merging PDUs that get us out
		 *	of the merging state.  Since the only MCS client for Jasper is the GCC,
		 *	it should be ok to block the client (GCC) while the merging goes on.
		 */
		WARNING_OUT (("User::ValidateUserRequest: merge in progress"));
		return_value = MCS_DOMAIN_MERGING;
	}

	return (return_value);
}

/*
 *	Void	RegisterUserAttachment ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method registers a user attachment with the User object.
 */
void User::RegisterUserAttachment (MCSCallBack	mcs_callback,
									PVoid		user_defined,
									UINT		flags)
{
	TRACE_OUT (("User::RegisterUserAttachment: user handle = %p", this));

	/*
	 *	Fill in all of the members of the User object.
	 */
	m_MCSCallback = mcs_callback;
	m_UserDefined = user_defined;
	m_BufferRetryInfo = NULL;
	m_fDisconnectInDataLoss = (flags & ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
	m_fFreeDataIndBuffer = (flags & ATTACHMENT_MCS_FREES_DATA_IND_BUFFER);

	// Increase the ref count to indicate that the client is now using the object.
	AddRef();
}

/*
 *	Void	SetDomainParameters ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is used to set the current value of the instance variable
 *		that holds the maximum user data field length.
 */
void	User::SetDomainParameters (
				PDomainParameters		domain_parameters)
{
	/*
	 *	Set the maximum user data length instance variable to conform to the
	 *	maximum PDU size within the attached domain (minus some overhead to
	 *	allow for protocol bytes).
	 */
	Maximum_User_Data_Length = domain_parameters->max_mcspdu_size -
								(MAXIMUM_PROTOCOL_OVERHEAD_MCS +
								BER_PROTOCOL_EXTRA_OVERHEAD);
	TRACE_OUT (("User::SetDomainParameters: "
			"maximum user data length = %ld", Maximum_User_Data_Length));

	/*
	 *	Use the specified domain parameters to set the type of encoding rules
	 *	to be used.
	 */
	ASSERT (domain_parameters->protocol_version == PROTOCOL_VERSION_PACKED);
}

/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called during a domain merge operation when there is
 *		a conflict in the use of channels.  The former Top Provider responds
 *		by issuing this command, which causes all users of the channel to be
 *		expelled from it.  Additionally, if the channel corresponds to a user
 *		ID channel, that user is purged from the network.
 */
void	User::PurgeChannelsIndication (
				CUidList           *purge_user_list,
				CChannelIDList *)
{
	/*
	 *	Issue a DetachUserIndication to each user contained in the purge user
	 *	list.
	 */
	DetachUserIndication(REASON_PROVIDER_INITIATED, purge_user_list);
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function will be called when the domain determines the need to
 *		tear down quickly.  This call simulates the reception of a detach user
 *		indication (if the user is already attached), or an unsuccessful
 *		attach user confirm (if the user is not yet attached).  In either
 *		case, the user attachment will be eliminated by this call.
 */
void	User::DisconnectProviderUltimatum (
				Reason				reason)
{
	CUidList		deletion_list;

	if (User_ID != 0)
	{
		/*
		 *	If the user is already attached, simulate a detach user indication
		 *	on the local user ID.
		 */
		deletion_list.Append(User_ID);
		DetachUserIndication(reason, &deletion_list);
	}
	else
	{
		/*
		 *	If the user is not yet attached, simulate an unsuccessful attach
		 *	user confirm.
		 */
		AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
	}
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to the attach user
 *		request that was sent by this object when it was first created.  This
 *		call will contain the result of that attachment operation.  If the
 *		result is successful, this call will also contain the user ID for this
 *		attachment.
 */
void	User::AttachUserConfirm (
				Result				result,
				UserID				uidInitiator)
{
	LPARAM		parameter;

	if (Deletion_Pending == FALSE)
	{
		ASSERT (User_ID == 0);
		
		/*
		 *	If the result is successful, set the user ID of this user
		 *	object to indicate its new status.
		 */
		if (result == RESULT_SUCCESSFUL)
			User_ID = uidInitiator;
		else
			Deletion_Pending = TRUE;

		parameter = PACK_PARAMETER (uidInitiator, result);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::AttachUserConfirm: Failed to post msg to application. Error: %d",
						GetLastError()));
			if (result != RESULT_SUCCESSFUL)
				Release();
		}
	}
	else {
		Release();
	}
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain whenever a user leaves the domain
 *		(voluntarily or otherwise).  Furthermore, if a user ID in the indication
 *		is the same as the local user ID, then this user is being involuntarily
 *		detached.
 */
Void	User::DetachUserIndication (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID				uid;
	LPARAM				parameter;
	BOOL				bPostMsgResult;

	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Iterate through the list of users to be deleted.
		 */
		user_id_list->Reset();
		while (NULL != (uid = user_id_list->Iterate()))
		{
			parameter = PACK_PARAMETER(uid, reason);

			/*
			 *	Post the user message to the application.
			 */
			bPostMsgResult = PostMessage (m_hWnd, USER_MSG_BASE + MCS_DETACH_USER_INDICATION,
		 								  (WPARAM) this, parameter);
			if (! bPostMsgResult) {
				WARNING_OUT (("User::DetachUserIndication: Failed to post msg to application. Error: %d",
							GetLastError()));
			}
			
			/*
			 *	If this indication is deleting this user attachment, then
			 *	set the deletion pending flag, and break out of the loop.
			 */
			if (User_ID == uid)
			{
				m_originalUser_ID = User_ID;
				User_ID = 0;
				Deletion_Pending = TRUE;
				if (! bPostMsgResult)
					Release();
				break;
			}
		}
	}
	else {
		/*
		 *	The user has already called ReleaseInterface().  If the
		 *	Indication is for this attachment, we have to release and
		 *	probably, delete the object.
		 */
		if (user_id_list->Find(User_ID)) {
			Release();
		}
	}
}

/*
 *	Void	ChannelJLCDAEConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a channel confirm/indication message
 *		to the user application.  It handles ChannelJoinConfirms,
 *		ChannelLeaveIndications, ChannelConveneConfirms, ChannelDisbandIndications
 *		and ChannelExpelIndications.
 */
Void	User::ChannelConfInd (	UINT		type,
								ChannelID	channel_id,
								UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (channel_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::ChannelConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}


/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		join request.  This call contains the result of the join request, as
 *		well as the channel that has just been joined.
 */
Void	User::ChannelJoinConfirm (
				Result				result,
				UserID,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_JOIN_CONFIRM, channel_id, (UINT) result);
}


/*
 *	Void	ChannelLeaveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	User::ChannelLeaveIndication (
				Reason				reason,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_LEAVE_INDICATION, channel_id, (UINT) reason);
}

/*
 *	Void		ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous channel
 *		convene request.  This call contains the result of the request, as
 *		well as the channel that has just been convened.
 */
Void	User::ChannelConveneConfirm (
				Result				result,
				UserID,
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_CONVENE_CONFIRM, channel_id, (UINT) result);
}

/*
 *	Void		ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when MCS disbands an existing
 *		private channel.
 */
Void	User::ChannelDisbandIndication (
				ChannelID			channel_id)
{
	ChannelConfInd (MCS_CHANNEL_DISBAND_INDICATION, channel_id, REASON_CHANNEL_PURGED);
}

/*
 *	Void		ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is admitted to a
 *		private channel.
 */
Void	User::ChannelAdmitIndication (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_ADMIT_INDICATION, channel_id, (UINT) uidInitiator);
}

/*
 *	Void		ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user is expelled from a
 *		private channel.
 */
Void	User::ChannelExpelIndication (
				ChannelID			channel_id,
				CUidList *)
{
	ChannelConfInd (MCS_CHANNEL_EXPEL_INDICATION, channel_id, REASON_USER_REQUESTED);
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when data needs to sent to the
 *		user on a channel that the user has joined.
 */
Void	User::SendDataIndication (
				UINT				message_type,
				PDataPacket			packet)
{	
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	Lock the packet object to indicate that we wish to have future
		 *	access to the decoded data that it contains.  Then get the
		 *	address of the decoded data structure.
		 */
		packet->Lock ();
		packet->SetMessageType(message_type);

        // flush packets in the pending queue
    	PDataPacket pkt;
    	while (NULL != (pkt = m_PostMsgPendingQueue.PeekHead()))
    	{
    		if (::PostMessage(m_hWnd, USER_MSG_BASE + pkt->GetMessageType(),
    		                  (WPARAM) this, (LPARAM) pkt))
    		{
    		    // remove the item just posted
    		    m_PostMsgPendingQueue.Get();
    		}
    		else
    		{
    		    // fail to post pending ones, just append the new one and bail out.
    		    m_PostMsgPendingQueue.Append(packet);
    		    return;
    		}
        }

		/*
		 *	Post the user message to the application.
		 */
		if (! ::PostMessage(m_hWnd, USER_MSG_BASE + message_type,
		                    (WPARAM) this, (LPARAM) packet))
		{
		    // fail to post pending ones, just append the new one and bail out.
		    m_PostMsgPendingQueue.Append(packet);
		    return;
		}
	}
}

/*
 *	Void	TokenConfInd ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called to post a token confirm/indication message
 *		to the user application.
 */
Void	User::TokenConfInd (UINT		type,
							TokenID		token_id,
							UINT		arg16)
{
	LPARAM		parameter;

	ASSERT (HIWORD(arg16) == 0);
	
	if (Deletion_Pending == FALSE)
	{
		parameter = PACK_PARAMETER (token_id, arg16);

		/*
		 *	Post the user message to the application.
		 */
		if (! PostMessage (m_hWnd, USER_MSG_BASE + type,
							(WPARAM) this, parameter)) {
			WARNING_OUT (("User::TokenConfInd: Failed to post msg to application. Type: %d. Error: %d",
						type, GetLastError()));
		}
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		grab request.  This call contains the result of the grab request, as
 *		well as the token that has just been grabbed.
 */
Void	User::TokenGrabConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GRAB_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		inhibit request.  This call contains the result of the inhibit request,
 *		as well as the token that has just been inhibited.
 */
Void	User::TokenInhibitConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_INHIBIT_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when another user attempts to
 *		give this user a token.
 */
Void	User::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	TokenConfInd (MCS_TOKEN_GIVE_INDICATION, pTokenGiveRec->token_id,
				  (UINT) pTokenGiveRec->uidInitiator);
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		give request.  This call contains the result of the give request.
 */
Void	User::TokenGiveConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_GIVE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain when a user somewhere in the
 *		domain issues a token please request for a token that is currently
 *		owned by this user.
 */
Void	User::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_PLEASE_INDICATION, token_id, (UINT) uidInitiator);
}

/*
 *	Void	TokenReleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This command is called when a token is being purged from the lower
 *		domain after a new connection is established.  It causes the indication
 *		to be forwarded to the user application, letting it know that it no
 *		longer owns the token.
 */
Void	User::TokenReleaseIndication (
				Reason				reason,
				TokenID				token_id)
{
	TokenConfInd (MCS_TOKEN_RELEASE_INDICATION, token_id, (UINT) reason);
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		release request.  This call contains the result of the release request,
 *		as well as the token that has just been released.
 */
Void	User::TokenReleaseConfirm (
				Result				result,
				UserID,
				TokenID				token_id,
				TokenStatus)
{
	TokenConfInd (MCS_TOKEN_RELEASE_CONFIRM, token_id, (UINT) result);
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by the domain in response to a previous token
 *		test request.  This call contains the result of the test request,
 *		as well as the token that has just been tested.
 */
Void	User::TokenTestConfirm (
				UserID,
				TokenID				token_id,
				TokenStatus			token_status)
{
	TokenConfInd (MCS_TOKEN_TEST_CONFIRM, token_id, (UINT) token_status);
}

/*
 *	Void	MergeDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called by domain upon entering or leaving a domain
 *		merger state.
 */
Void	User::MergeDomainIndication (
				MergeStatus			merge_status)
{
	if (Deletion_Pending == FALSE)
	{
		/*
		 *	If the merge operation is starting, set a boolean flag
		 *	indicating that this object should reject all user activity.
		 *	Otherwise, reset the flag.
		 */
		if (merge_status == MERGE_DOMAIN_IN_PROGRESS)
		{
			TRACE_OUT (("User::MergeDomainIndication: entering merge state"));
			Merge_In_Progress = TRUE;
		}
		else
		{
			TRACE_OUT (("User::MergeDomainIndication: leaving merge state"));
			Merge_In_Progress = FALSE;
		}
	}
}

/*
 *	Void	PurgeMessageQueue ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called to purge all current entries from the message
 *		queue, freeing up resources correctly (to prevent leaks).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		This function should only be called in the client's thread's context.
 */
Void	User::PurgeMessageQueue ()
{
	MSG				msg;
	PDataPacket		packet;
	HWND			hWnd;

	// First, unlock the packets in the list of pending data indications
	while (NULL != (packet = m_DataPktQueue.Get()))
		packet->Unlock();

	// Keep a copy of the attachment's HWND to destroy it later.
	hWnd = m_hWnd;
	m_hWnd = NULL;
		
	/*
	 *	This loop calls PeekMessage to go through all the messages in the thread's
	 *	queue that were posted by the main MCS thread.  It removes these
	 *	messages and frees the resources that they consume.
	 */
	while (PeekMessage (&msg, hWnd, USER_MSG_BASE, USER_MSG_BASE + MCS_LAST_USER_MESSAGE,
						PM_REMOVE)) {

		if (msg.message == WM_QUIT) {
			// Repost the quit
			PostQuitMessage (0);
			break;
		}
		
		/*
		 *	If this is a data indication message, we need to unlock
		 *	the packet associated with this message.
		 */
		else if ((msg.message == USER_MSG_BASE + MCS_SEND_DATA_INDICATION) ||
			(msg.message == USER_MSG_BASE + MCS_UNIFORM_SEND_DATA_INDICATION)) {
			((PDataPacket) msg.lParam)->Unlock ();
		}
		else if (((msg.message == USER_MSG_BASE + MCS_ATTACH_USER_CONFIRM) &&
					((Result) HIWORD(msg.lParam) != RESULT_SUCCESSFUL)) ||
			((msg.message == USER_MSG_BASE + MCS_DETACH_USER_INDICATION) &&
			(m_originalUser_ID == (UserID) LOWORD(msg.lParam)))) {
			ASSERT (this == (PUser) msg.wParam);
			Release();
			break;
		}
	}

	// Destroy the window; we do not need it anymore
	DestroyWindow (hWnd);
}

void User::IssueDataIndication (
					UINT				message_type,
					PDataPacket			packet)
{
		LPARAM					parameter;
		PMemory					memory;
		BOOL					bIssueCallback = TRUE;
		BOOL					bBufferInPacket = TRUE;
		PUChar					data_ptr;
		SendDataIndicationPDU	send_data_ind_pdu;
		
	switch (packet->GetSegmentation()) {
	case SEGMENTATION_BEGIN | SEGMENTATION_END:
		parameter = (LPARAM) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
							u.send_data_indication);
		data_ptr = packet->GetUserData();
		memory = packet->GetMemory();
		break;
		
	case SEGMENTATION_END:
	{
		/*
		 *	We now have to collect all the individual packets from m_DataPktQueue
		 *	that go with this MCS Data PDU and sent them as a single data indication
		 *	using a buffer large enough for all the data.
		 */
		/*
		 *	First, find out the size of the large buffer we need to allocate.
		 *	Note that we make a copy of the original m_DataPktList and operate
		 *	on the copy, since we need to remove items from the original list.
		 */
			CDataPktQueue			PktQ(&m_DataPktQueue);
			UINT					size;
			PDataPacket				data_pkt;
			PUChar					ptr;
#ifdef DEBUG
			UINT uiCount = 0;
#endif // DEBUG
		
		size = packet->GetUserDataLength();
		PktQ.Reset();
		while (NULL != (data_pkt = PktQ.Iterate()))
		{
			if (packet->Equivalent (data_pkt)) {
#ifdef DEBUG
				if (uiCount == 0) {
					ASSERT (data_pkt->GetSegmentation() == SEGMENTATION_BEGIN);
				}
//				else {
//					ASSERT (data_pkt->GetSegmentation() == 0);
//				}
				uiCount++;
#endif // DEBUG
				size += data_pkt->GetUserDataLength();
				// Remove from the original list, since we are processing the callback.
				m_DataPktQueue.Remove(data_pkt);
			}
		}
		// Allocate the memory we need.
		DBG_SAVE_FILE_LINE
		memory = AllocateMemory (NULL, size);
		if (memory != NULL) {
			bBufferInPacket = FALSE;
			// Copy the individual indications into the large buffer.
			data_ptr = ptr = memory->GetPointer();
			PktQ.Reset();
			/*
			 *	We need to enter the MCS critical section, because
			 *	we are unlocking packets.
			 */
			EnterCriticalSection (& g_MCS_Critical_Section);
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (packet->Equivalent (data_pkt)) {
					size = data_pkt->GetUserDataLength();
					memcpy ((void *) ptr,
							(void *) data_pkt->GetUserData(),
							size);
					ptr += size;
					data_pkt->Unlock();
				}
			}
			// Leave the MCS critical section
			LeaveCriticalSection (& g_MCS_Critical_Section);
			
			// Copy the last indication into the large buffer.
			memcpy ((void *) ptr,
					(void *) packet->GetUserData(),
					packet->GetUserDataLength());

			/*
			 *	Prepare the SendDataIndicationPDU structure for the client.
			 *	Notice that we can use the first 8 bytes from the decoded
			 *	structure of the current "packet" to fill in the first bytes from
			 *	it.
			 */
			memcpy ((void *) &send_data_ind_pdu,
					(void *) &(((PDomainMCSPDU) (packet->GetDecodedData()))->
								u.send_data_indication), 8);
			send_data_ind_pdu.segmentation = SEGMENTATION_BEGIN | SEGMENTATION_END;
			send_data_ind_pdu.user_data.length = memory->GetLength();
			send_data_ind_pdu.user_data.value = data_ptr;
			parameter = (ULONG_PTR) &send_data_ind_pdu;
		}
		else {
			/*
			 *	We have failed to issue the data indication callback to the client.
			 *	The user attachment has been compromised.  If the attachment can not
			 *	live with this loss, we have to detach them from the conference.
			 */
			ERROR_OUT (("User::IssueDataIndication: Memory allocation failed for segmented buffer of size %d.",
						size));
			bIssueCallback = FALSE;
			
			// Clean up after the failure
			EnterCriticalSection (& g_MCS_Critical_Section);
			PktQ.Reset();
			while (NULL != (data_pkt = PktQ.Iterate()))
			{
				if (m_fDisconnectInDataLoss ||
					(packet->Equivalent (data_pkt))) {
					data_pkt->Unlock();
				}
			}
			packet->Unlock();
			LeaveCriticalSection (& g_MCS_Critical_Section);

			// Disconnect if the client wants us to.
			if (m_fDisconnectInDataLoss) {
				// Clear the list of the already-cleared pending packets. We will soon get a ReleaseInterface().
				m_DataPktQueue.Clear();
				
				ERROR_OUT(("User::IssueDataIndication: Disconnecting user because of data loss..."));
				/*
				 *	Send a detach user indication directly to the user application.
				 *	Note that this cannot go through the queue, due to the memory
				 *	failure.
				 */
				(*m_MCSCallback) (MCS_DETACH_USER_INDICATION,
								PACK_PARAMETER (User_ID, REASON_PROVIDER_INITIATED),
								m_UserDefined);

			}
		}
		break;
	}
	
	case SEGMENTATION_BEGIN:
	case 0:
		// Append the packet to the list of packets for send.
		m_DataPktQueue.Append(packet);
		bIssueCallback = FALSE;
		break;
		
	default:
		ASSERT (FALSE);
		ERROR_OUT(("User::IssueDataIndication: Processed packet with invalid segmentation field."));
		bIssueCallback = FALSE;
		break;
	}

	if (bIssueCallback) {
		/*
		 *	If the client has advised the server not to free the data, we have to
		 *	lock the buffer.
		 */
		if (m_fFreeDataIndBuffer == FALSE) {
			if (bBufferInPacket)
				LockMemory (memory);
				
			// Enter the data indication info in a dictionary, for the Free request.
			if (GetMemoryObject(data_ptr) != memory)
            {
				m_DataIndMemoryBuf2.Append((LPVOID) data_ptr, memory);
            }
		}
		
		/*
		 *	Issue the callback. The callee can not refuse to process this.
		 */
		(*m_MCSCallback) (message_type, parameter, m_UserDefined);

		/*
		 *	If the client has advised the server to free the data indication buffer
		 *	after delivering the callback, we must do so.
		 */
		if (m_fFreeDataIndBuffer) {
			if (bBufferInPacket == FALSE)
				FreeMemory (memory);
		}

		// To unlock a packet, we need to enter the MCS CS.
		EnterCriticalSection (& g_MCS_Critical_Section);
		packet->Unlock();
		LeaveCriticalSection (& g_MCS_Critical_Section);
	}
}	
	

/*
 *	LRESULT		UserWindowProc ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the window procedure that will be used by all internally
 *		created windows.  A hidden window is created internally when the
 *		application attaches to an MCS domain.  This technique insures
 *		that callbacks are delivered to the owner in the same thread that
 *		initially created the attachment.
 */
LRESULT CALLBACK	UserWindowProc (
							HWND		window_handle,
							UINT		message,
							WPARAM		word_parameter,
							LPARAM		long_parameter)
{
		UINT		mcs_message;
		//PDataPacket	packet;
		PUser		puser;
		
	if ((message >= USER_MSG_BASE) && (message < USER_MSG_BASE + MCS_LAST_USER_MESSAGE)) {
		// This is an MCS msg going to the user application.

		// Compute the MCS msg type
		mcs_message = message - USER_MSG_BASE;

		// Retrieve the pointer to the User (interface) object.
		puser = (PUser) word_parameter;
        if (NULL != puser)
        {
    		/*
    		 *	Find out whether this is a data indication. If it is, set the
    		 *	packet variable.
    		 */
    		if ((mcs_message == MCS_SEND_DATA_INDICATION) ||
    			(mcs_message == MCS_UNIFORM_SEND_DATA_INDICATION)) {
    			puser->IssueDataIndication (mcs_message, (PDataPacket) long_parameter);
    		}
    		else {
    			/*
    			 *	Issue the callback. Notice that the callee can not refuse
    			 *	to process this.
    			 */
    			(*(puser->m_MCSCallback)) (mcs_message, long_parameter, puser->m_UserDefined);
    		}

    		/*
    		 *	We may need to release the User object.  This is the Server
    		 *	side release.
    		 */
    		if (((mcs_message == MCS_ATTACH_USER_CONFIRM) &&
    					((Result) HIWORD(long_parameter) != RESULT_SUCCESSFUL)) ||
    			((mcs_message == MCS_DETACH_USER_INDICATION) &&
    					(puser->m_originalUser_ID == (UserID) LOWORD(long_parameter)))) {
    			puser->Release();
    		}
        }
        else
        {
            ERROR_OUT(("UserWindowProc: null puser"));
        }
		return (0);
	}
	else {
		/*
		 *	Invoke the default window message handler to handle this
		 *	message.
		 */
		return (DefWindowProc (window_handle, message, word_parameter,
								long_parameter));
	}
}


/*
 *	Void	CALLBACK TimerProc (HWND, UINT, UINT, DWORD
 *
 *	Public
 *
 *	Functional Description:
 *		This is the timer procedure.  Timer messages will be routed to this
 *		function as a result of timer events which have been set up to recheck
 *		resource levels.  This would happen following a call to either
 *		MCSSendDataRequest or MCSUniformSendDataRequest which resulted in a
 *		return value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void	CALLBACK TimerProc (HWND, UINT, UINT timer_id, DWORD)
{
	PUser				puser;

	/*
	 *	Enter the critical section which protects global data.
	 */
	EnterCriticalSection (& g_MCS_Critical_Section);

	/*
	 *	First, we must find which user owns this timer.  We will do this by
	 *	searching through the Static_User_List.
	 */
	if (NULL == (puser = User::s_pTimerUserList2->Find(timer_id)))
	{
		WARNING_OUT (("TimerProc: no user owns this timer - deleting timer"));
		KillTimer (NULL, timer_id);
		goto Bail;
	}

	/*
	 *	Make sure that this user is actively attached.  If not, then kill the
	 *	timer and delete the user's buffer retry info structure.
	 */
    if ((puser->User_ID == 0) || puser->Deletion_Pending)
	{
		WARNING_OUT (("TimerProc: user is not attached - deleting timer"));
		goto CleanupBail;
	}

	/*
	 *	If we don't have retryinfo just get out of here.
	 */
	 if(puser->m_BufferRetryInfo == NULL)
	 {
		WARNING_OUT (("TimerProc: user does not have buffer retry info - deleting timer"));
		goto CleanupBail;
	 }

	/*
	 *	We have identified a valid owner of this timer.
	 *	Verify that there is enough memory for the
	 *	required size before proceeding.  Note that since there
	 *	can be multiple processes allocating from the same memory
	 *	at the same time, this call does not guarantee
	 *	that that the allocations will succeed.
	 */
	if (GetFreeMemory (SEND_PRIORITY) < puser->m_BufferRetryInfo->user_data_length)
	{
		TRACE_OUT (("TimerProc: not enough memory buffers of required size"));
		goto Bail;
	}

	/*
	 *	If the routine gets this far, then an adequate level of resources
	 *	now exists.
	 */

	/*
	 *	Issue an MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION to the user.
	 */
	TRACE_OUT(("TimerProc: Delivering MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION callback."));
//	(*(puser->m_MCSCallback)) (MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,
//								0, puser->m_UserDefined);

	
	if(!PostMessage (puser->m_hWnd, USER_MSG_BASE + MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION,(WPARAM) puser, 0))
	{
		ERROR_OUT (("TimerProc: Failed to post msg to application. Error: %d", GetLastError()));
	}


CleanupBail:
	KillTimer (NULL, timer_id);
	delete puser->m_BufferRetryInfo;
	puser->m_BufferRetryInfo = NULL;
	User::s_pTimerUserList2->Remove(timer_id);

Bail:
	// Leave the attachment's critical section
	LeaveCriticalSection (& g_MCS_Critical_Section);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\fsdiag2.h ===
// fsdiag.h


#ifndef	_FSDIAG2_H_
#define	_FSDIAG2_H_

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

#if defined(_DEBUG)

VOID T120DiagnosticCreate(VOID);
VOID T120DiagnosticDestroy(VOID);

#define TRACE_OUT_EX(z,s)	(MLZ_TraceZoneEnabled(z) || MLZ_TraceZoneEnabled(MLZ_FILE_ZONE))  ? (MLZ_TraceOut s) : 0

#else

#define T120DiagnosticCreate()
#define T120DiagnosticDestroy()
#define DEBUG_FILEZONE(z)

#define TRACE_OUT_EX(z,s)

#endif // _DEBUG


#ifdef _DEBUG

enum
{
    ZONE_T120_T123PSTN = BASE_ZONE_INDEX,
};

extern UINT MLZ_FILE_ZONE;

#define DEBUG_FILEZONE(z)  static UINT MLZ_FILE_ZONE = (z)

#endif // _DEBUG

#endif // _FSDIAG_


// lonchanc: this must be outside the _FSDIAG_ protection.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA)

static const PSTR c_apszDbgZones[] =
{
	"T.123",				// debug zone module name
	DEFAULT_ZONES
    TEXT("T123 PSTN"),      // ZONE_T120_T123PSTN
};

UINT MLZ_FILE_ZONE = ZONE_T120_T123PSTN;

#endif // _DEBUG && INIT_DBG_ZONE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\hash2.h ===
/*	hash.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a dictionary data structure.
 *	Both the key and the value in a dictionary entry are DWORD values.  So, for example, if the
 *  value is really a pointer it has to be converted into a DWORD before being passed into a
 *  member dictionary function.
 *
 */


#ifndef _HASH2_H_
#define _HASH2_H_

#include <windows.h>

#define DEFAULT_NUMBER_OF_BUCKETS	3


typedef enum {
	DWORD_DICTIONARY,			/* The key is a 32-bit unsigned value */
	STRING_DICTIONARY,			/* The key is a NULL-terminated string that is being pointed by
								 * the "key" field in the structure below */
	LENGTH_STRING_DICTIONARY	/* The key is a string with a specific length.  The "key" field
								 * in the structure below, points to memory space containing
								 * the length and a string of that length. */
} DictionaryType;


typedef struct _dictionary_item {
	DWORD_PTR					key;	// The key value, or a pointer to a string (depending on the dictionary type)
	DWORD_PTR					value;	// This is always a 32-bit unsigned value
	struct _dictionary_item		*next;	// Pointer to the next structure in the dictionary bucket
} DICTIONARY_ITEM, *PDICTIONARY_ITEM;


class DictionaryClass
{

public:
	DictionaryClass (ULONG num_of_buckets, DictionaryType dtype = DWORD_DICTIONARY);
	DictionaryClass (const DictionaryClass& original);
	~DictionaryClass ();
	BOOL insert (DWORD_PTR new_key, DWORD_PTR new_value, ULONG length = 0);
	void remove (DWORD_PTR Key, ULONG length = 0);
	BOOL find (DWORD_PTR Key, PDWORD_PTR pValue = NULL, ULONG length = 0);
	BOOL isEmpty ();
	void clear ();
	ULONG entries () {
		return (3 * NumOfBuckets - ItemCount + NumOfExternItems);
	};
	BOOL iterate (PDWORD_PTR pValue = NULL, PDWORD_PTR pKey = NULL);
	void reset () { pCurrent = NULL; };		// Resets the dictionary iterator


private:
	DWORD hashFunction (DWORD_PTR key);
	int LengthStrcmp (DWORD_PTR DictionaryKey, DWORD_PTR ChallengeKey, ULONG length);

	ULONG				 NumOfBuckets;		// Number of dictionary buckets.  Specified during object construction.
	DWORD   			 dwNormalSize;		// Initial space allocated for the dictionary
	PDICTIONARY_ITEM	*Buckets;			// Address of the Buckets array
	PDICTIONARY_ITEM	*ItemArray;			// Pointer to the array of initially allocated dictionary items
	ULONG		 		 ItemCount;			// Number of dictionary items left in the ItemArray
	PDICTIONARY_ITEM	 pCurrent;			// Points to the current dictionary item while we iterate through the dictionary
	ULONG				 ulCurrentBucket;	// Id of the current bucket while we iterate
	DictionaryType		 Type;				// Dictionary type
	ULONG				 NumOfExternItems;	// Number of external dictionary items

};

typedef DictionaryClass * PDictionaryClass;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\memory2.h ===
/*
 *	memory.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Memory class.  Instances of this
 *		class are used to pass data around the system.
 *
 *		Each instance of this class maintains two pointers.  The first is a
 *		pointer to the reference data (or the source data) which this object
 *		is responsible for representing.  The second is a pointer to a copy
 *		buffer, which is a piece of allocated memory that a Memory object
 *		can copy the data into if necessary.
 *
 *		When a Memory object is created, both of these addresses are passed
 *		in to it.  It does not, however, copy the data from the reference
 *		buffer to the copy buffer just yet.  If anyone asks the address of the
 *		buffer, it will simply return the reference pointer.  However, the
 *		first time the buffer is locked, the data will be copied from the
 *		reference buffer to the copy buffer for safe keeping.  In essence,
 *		the lock function tells the Memory object that someone is interested
 *		in the data for longer than the reference buffer will remain valid.
 *
 *		After the object is locked, a call to retrieve a memory pointer will
 *		result in the copy pointer being returned.
 *
 *		Each time the lock function is called, a lock count is incremented.
 *		The copy operation only takes place the first time the buffer is
 *		locked, however.
 *
 *		In addition to maintaining a lock count, this object keeps a flag
 *		indicating whether or not it has been freed by the allocator.  This
 *		freeing really means that the object is enabled to be freed as soon
 *		as the lock count hits zero.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY2_H_
#define	_MEMORY2_H_

/*
 *	FreeStack
 *	This is a list container that can be used to hold memory addresses.
 *	This structure is used to keep information about each free stack.  There
 *	is one free stack for each size block being maintained by each memory
 *	manager.
 */
typedef	struct
{
	ULong		block_size;
	ULong		total_block_count;
	ULong		current_block_count;
	ULong		block_stack_offset;
} FreeStack;
typedef	FreeStack *				PFreeStack;

/*
 *	This type is used to represent a block number in the memory manager.  This
 *	is essentially an index used to uniquely identify each block being
 *	maintained by an instance of this class.
 */
typedef	ULong					BlockNumber;
typedef	BlockNumber *			PBlockNumber;

#define	INVALID_BLOCK_NUMBER	0xffffffffL

/*
 *	This type is used to determine when a memory object should be destroyed.
 *	When a memory object is created, this field is set by the owner.  The owner
 *	can then ask for the value of this field at any time to help determine when
 *	the object should be destroyed.  Essentially, this field indicates whether
 *	the global lock count for the memory this object represents should be used
 *	to determine when this object should be destroyed.
 */
typedef	enum
{
	MEMORY_LOCK_NORMAL,
	MEMORY_LOCK_IGNORED
} MemoryLockMode;

/*
 *	This is the class definition for the Memory class.
 */
class Memory;
typedef	Memory *		PMemory;

class Memory
{
	public:
						Memory (PUChar			reference_ptr,
								ULong			length,
								PUChar			copy_ptr,
								BlockNumber		block_number,
								MemoryLockMode	memory_lock_mode);
		virtual			~Memory () { };
		PUChar			GetPointer ()
						{
							return (Copy_Ptr);
						}
		ULong			GetLength ()
						{
							return (Length);
						}
		BlockNumber		GetBlockNumber ()
						{
							return (Block_Number);
						}
		MemoryLockMode	GetMemoryLockMode ()
						{
							return (Memory_Lock_Mode);
						}

	private:

		ULong			Length;
		PUChar			Copy_Ptr;
		BlockNumber		Block_Number;
		MemoryLockMode	Memory_Lock_Mode;
};


/*
 *	Memory (
 *			PUChar		reference_ptr,
 *			ULong		length,
 *			PUChar		copy_ptr,
 *			PFreeStack	free_stack,
 *			BlockNumber	block_number)
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  All it does is
 *		initialize the instance variable with the passed in values.
 *
 *	Formal Parameters:
 *		reference_ptr (i)
 *			This is a pointer to the data that is to represented by this
 *			Memory object.
 *		length (i)
 *			This is the length of the reference buffer.
 *		copy_ptr (i)
 *			This is the address of an allocated buffer that the Memory object
 *			can use to preserve the contents of the reference buffer if a lock
 *			operation occurs.
 *		free_stack (i)
 *			This is a pointer to a list container that the allocated memory
 *			block came from.  This field is not used internally, and is only
 *			held here in order to improve the performance of the memory
 *			manager that is using Memory objects.
 *		block_number (i)
 *			This is the block number for the memory block that is represented
 *			by this object.  This field is not used internally, and is only
 *			held here in order to improve the performance of the memory
 *			manager that is using Memory objects.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Memory ()
 *
 *	Functional Description:
 *		This is the destructor for the Memory class.  It does nothing at this
 *		time.  Note that it is the responsibility of the memory manager that
 *		is using Memory objects to free up the memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetLength ()
 *
 *	Functional Description:
 *		This function retrieves the length of the data being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The length of the data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BlockNumber		GetBlockNumber ()
 *
 *	Functional Description:
 *		This function retrieves the block number of the block that is being
 *		represented by this object.  This allows the memory manager to put the
 *		memory block back into the stack very efficiently.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The block number of the internal memory block.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\hash2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);
/*	hash.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a dictionary data structure.
 *
 */


#define MyMalloc(size)	LocalAlloc (LMEM_FIXED, (size))
#define MyFree(ptr)		LocalFree ((HLOCAL) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))


/*  Function:  Constructor
 *
 *	Parameters:
 *		num_of_buckets:		Number of buckets in the dictionary
 *		dtype:				Dictionary type
 *
 *	Return value:
 *		None
 */

DictionaryClass::DictionaryClass (ULONG num_of_buckets, DictionaryType dtype) :
	Type (dtype), NumOfExternItems (0)
{
	DWORD				i;	
	PDICTIONARY_ITEM	p;	// Goes through the initially allocated dictionary items to initialize the stack

	NumOfBuckets = Max (num_of_buckets, DEFAULT_NUMBER_OF_BUCKETS);

	/* Allocate the space needed for the dictionary */
	dwNormalSize = NumOfBuckets * (4 * sizeof (PDICTIONARY_ITEM) + 3 * sizeof (DICTIONARY_ITEM));
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	/* Initialize the Buckets */
	for (i = 0; i < NumOfBuckets; i++)
		Buckets[i] = NULL;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array.
	 * This is a stack of pointers to the real dictionary items. The stack is initialized with
	 * the addresses of the dictionary items
	 */

	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = p++;
}


/*  Function:  Copy Constructor
 *
 *	Parameters:
 *		original:	The original dictionary to make a copy of
 *
 *	Return value:
 *		None
 *
 *	Note:
 *		This copy constructor will work ONLY for DWORD_DICTIONARY dictionaries.
 *		It will NOT work for the string dictionary types.
 */


DictionaryClass::DictionaryClass (const DictionaryClass& original)
{
	DWORD			 i;
	PDICTIONARY_ITEM p, q, r;

	NumOfBuckets = original.NumOfBuckets;
	Type = original.Type;
	NumOfExternItems = original.NumOfExternItems;

	// Allocate the space needed for the dictionary
	dwNormalSize = original.dwNormalSize;
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array */
	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	// Traverse the whole original hash sturcture to create the copy
	// p: goes through the original items
	// q: goes through current instance's items and initializes them
	// r: remembers the previous item in the new instance so that its "next" field could be set

	q = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (q--, i = 0; i < NumOfBuckets; i++) {
		for (r = NULL, p = original.Buckets[i]; p != NULL; p = p->next) {
			
			// Check if there are unused items in the current dictionary
			if (ItemCount <= 0) {
				q = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
				if (q == NULL)
					break;
			}
			else {
				ItemCount--;
				q++;
			}

			q->value = p->value;
			q->key = p->key;
			if (p == original.Buckets[i])
				Buckets[i] = q;
			else
				r->next = q;
			r = q;
		}

		// Set the "next" field for the last item in the bucket
		if (r == NULL)
			Buckets[i] = NULL;
		else
			r->next = NULL;
	}

	// Initialize the rest of the ItemArray array
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = q++;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */


DictionaryClass::~DictionaryClass ()
{
	DWORD			 i;
	DWORD_PTR  		 dwOffset;		// Offset of the dictionary item.  If the offset does not indicate
									// that the item is from the initially allocated array, it has to
									// be freed.
	PDICTIONARY_ITEM p, q;

	if (Buckets != NULL) {

		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++)
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset < dwNormalSize)
					p = p->next;
				else {
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
					
		MyFree (Buckets);
		Buckets = NULL;
	}
}


/*  Function:  hashFunction
 *
 *	Parameters:
 *		key:	The key value
 *
 *	Return value:
 *		An integer in the range [0..NumOfBuckets-1] that indicates the bucket used for the "key".
 *
 */


DWORD DictionaryClass::hashFunction (DWORD_PTR key)
{
	if (Type >= STRING_DICTIONARY)
		return (*((unsigned char *) key) % NumOfBuckets);
	return (DWORD)(key % NumOfBuckets);
}


/*  Function:  LengthStrcmp
 *
 *	Parameters:
 *		DictionaryKey:	Pointer to dictionary storage that keeps a length-sensitive string (which
 *						is a length followed by a string of that length.
 *		ChallengeKey:	Pointer to the length-sensitive key that is compared with the "DictionaryKey"
 *		length:			The length of the "ChallengeKey" string
 *
 *	Return value:
 *		0 if the "DictionaryKey" and "ChallengeKey" strings are the same. 1, otherwise.
 *
 *	Note:
 *		This function is only used for dictionaries of type LENGTH_STRING_DICTIONARY.
 */

int DictionaryClass::LengthStrcmp (DWORD_PTR DictionaryKey, DWORD_PTR ChallengeKey, ULONG length)
{
	ULONG					 i;
	char					*pDictionaryChar;	// Goes through the dictionary key string
	char					*pChallengeChar;	// Goes through the challenge string

	// Compare the lengths first
	if (length != * (ULONG *) DictionaryKey)
		return 1;

	// Now, compare the strings themselves
	pDictionaryChar	= (char *) (DictionaryKey + sizeof (ULONG));
	pChallengeChar = (char *) ChallengeKey;
	for (i = 0; i < length; i++)
		if (*pDictionaryChar++ != *pChallengeChar++)
			return 1;

	return 0;
}


/*  Function:  insert
 *		Inserts (key, value) pair in the dictionary
 *
 *	Parameters:
 *		new_key:	The new key that has to be inserted in the dictionary
 *		new_value:	The value associated with the "new_key"
 *		length:		Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the new key
 *
 *	Return value:
 *		TRUE, if the operation succeeds, FALSE, otherwise.
 *
 *	Note:
 *		If the "new_key" is already in the dictionary, the (new_key, new_value) pair is NOT
 *		inserted (the dictionary remains the same), and the return value is TRUE.
 */


BOOL DictionaryClass::insert (DWORD_PTR new_key, DWORD_PTR new_value, ULONG length)
{
	PDICTIONARY_ITEM	pNewItem;			// Points to the allocated new dictionary item
	PDICTIONARY_ITEM	p;					// Goes through the bucket for the "new_key", searching for "new_key"
	DWORD				hash_val;			// The bucket ID for "new_key"
	BOOL				bIsNative = TRUE;	// TRUE, if the new allocated dictionary item is from the cache, FALSE otherwise

	if (Buckets == NULL)
		return FALSE;

	// Find if the item is already in the bucket, and if it's not, where it will get added.
	p = Buckets[hash_val = hashFunction (new_key)];

	ASSERT (hash_val < NumOfBuckets);

	if (p != NULL) {
		switch (Type) {
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key) && p->next != NULL; p = p->next);
			if (0 == lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; LengthStrcmp (p->key, new_key, length) && p->next != NULL; p = p->next);
			if (0 == LengthStrcmp (p->key, new_key, length)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		default:
			ASSERT (length == 0);
			for (; p->key != new_key && p->next != NULL; p = p->next);
			if (p->key == new_key) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		}
	}

	// Allocate the new item
	if (ItemCount > 0)
		pNewItem = ItemArray[--ItemCount];		// from the cache
	else {										// the cache is empty, we have to malloc the new item
		pNewItem = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
		if (pNewItem == NULL)
			return FALSE;
		bIsNative = FALSE;
		NumOfExternItems++;
	}

	ASSERT (pNewItem != NULL);

	// Fill in the "key" field of the new item
	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		pNewItem->key = (DWORD_PTR) MyMalloc ((lstrlen ((LPCTSTR) new_key) + 1) * sizeof(TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		lstrcpy ((LPTSTR) pNewItem->key, (LPCTSTR) new_key);
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		pNewItem->key = (DWORD_PTR) MyMalloc (sizeof (ULONG) + length * sizeof (TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		* ((ULONG *) (pNewItem->key)) = length;
		memcpy ((void *) (pNewItem->key + sizeof (ULONG)), (void *) new_key, length * sizeof (TCHAR));
		break;

	default:
		ASSERT (length == 0);
		pNewItem->key = new_key;
		break;
	}

	// Fill in the rest of the fields of the new item
	pNewItem->value = new_value;
	pNewItem->next = NULL;

	// Insert the item in its bucket
	if (p == NULL) {
		Buckets[hash_val] = pNewItem;
		return TRUE;
	}
	p->next = pNewItem;

	return TRUE;
}


/*  Function:  remove
 *		Removes (key, value) pair from the dictionary
 *
 *	Parameters:
 *		Key:	The key that has to be removed from the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the "Key"
 *
 *	Return value:
 *		None.
 *
 */

void DictionaryClass::remove (DWORD_PTR Key, ULONG length)
{
	PDICTIONARY_ITEM	p, q;		// They go through the dictionary items in "Key"'s bucket.
									// p: points to the current dictionary item in the bucket
									// q: points to the previous item
	DWORD				hash_val;	// The bucket ID for "Key"
	
	if (Buckets == NULL)
		return;

	// Find the item in the dictionary
	p = Buckets [hash_val = hashFunction (Key)];

	ASSERT (hash_val < NumOfBuckets);

	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		for (q = NULL; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); q = p, p = p->next) ;
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		for (q = NULL; p != NULL && LengthStrcmp (p->key, Key, length); q = p, p = p->next) ;
		break;

	default:
		ASSERT (length == 0);
		for (q = NULL; p != NULL && p->key != Key; q = p, p = p->next);
		break;
	}

	// Remove the item
	if (p == NULL)
		return;

	if (q == NULL)
		Buckets[hash_val] = p->next;
	else
		q->next = p->next;

	// Free the item found
	ASSERT (p != NULL);

	if (Type >= STRING_DICTIONARY)
		MyFree (p->key);
	hash_val = (DWORD)((PBYTE) p - (PBYTE) Buckets);
	if (hash_val < dwNormalSize)
		ItemArray[ItemCount++] = p;
	else {
		MyFree (p);
		NumOfExternItems--;
	}
}


/* Function:  find
 *		Looks up the key in the dictionary
 *
 * Parameters
 *		Key:	The key to lookup
 *		pValue: Pointer to receive the value associated with "Key"
 *				It can be NULL, if we just try to find whether "Key" is in the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of "Key"
 *
 * Return value:
 *		FALSE, if "Key" is not found in the dictionary
 *		TRUE, otherwise.
 */

BOOL DictionaryClass::find (DWORD_PTR Key, PDWORD_PTR pValue, ULONG length)
{
	PDICTIONARY_ITEM	p;		// Goes through the dictionary items in "Key"'s bucket.

	if (Buckets == NULL) {
		if (pValue != NULL)
			*pValue = 0;
		return FALSE;
	}

	// Find the item in the dictionary
	p = Buckets [hashFunction (Key)];

	switch (Type) {
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		for (; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = p->next) ;
		break;

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		for (; p != NULL && LengthStrcmp (p->key, Key, length); p = p->next) ;
		break;

	default:
		ASSERT (length == 0);
		for (; p != NULL && p->key != Key; p = p->next);
		break;
	}

	if (p == NULL) {
		// we did not find the "Key"
		if (pValue != NULL)
			*pValue = 0;
		return FALSE;
	}

	// "Key" was found
	if (pValue != NULL)
		*pValue = p->value;
	return TRUE;

}


/* Function:  iterate
 *		Iterates through the items of a dictionary.  It remembers where it has
 *		stopped during the last call and starts from there.
 *
 * Parameters
 *		pValue:	Pointer to DWORD that will hold the next value from the dictionary.
 *				It can be NULL.
 *		pKey:	Pointer to DWORD or unsigned short value to receive the key associated with the value.
 *				It can be NULL.
 *
 * Return value:
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey and *pValue are valid
 *
 */

BOOL DictionaryClass::iterate (PDWORD_PTR pValue, PDWORD_PTR pKey)
{

	if (Buckets == NULL)
		return FALSE;

	if (pCurrent == NULL)
		// start from the 1st item in the dictionary
		pCurrent = Buckets[ulCurrentBucket = 0];
	else
		pCurrent = pCurrent->next;

	// Advance "pCurrent" until it's not NULL, or we reach the end of the dictionary.
	for (; ulCurrentBucket < NumOfBuckets; pCurrent = Buckets[++ulCurrentBucket]) {
		if (pCurrent != NULL) {
			// we found the next item
			if (pKey)
				*pKey = pCurrent->key;
			if (pValue)
				*pValue = pCurrent->value;
			return TRUE;
		}
	}

	pCurrent = NULL;
	return FALSE;
}


/* Function:  isEmpty
 *
 * Parameters
 *		None.
 *
 * Return value:
 *		TRUE, if the dictionary is empty.  FALSE, otherwise.
 *
 */

BOOL DictionaryClass::isEmpty (void)
{
	DWORD i;

	if (Buckets == NULL)
		return TRUE;

	for (i = 0; i < NumOfBuckets; i++)
		if (Buckets[i] != NULL)
			return FALSE;

	return TRUE;
}


/* Function:  clear
 *		Clears up the dictionary.  No (key, value) pairs are left in the dictionary.
 *
 * Parameters:
 *		None.
 *
 * Return value:
 *		None.
 *
 */

void DictionaryClass::clear (void)
{

	DWORD			 i;			// Goes through the "Buckets" array
	DWORD_PTR		 dwOffset;	// The offset of a dictionary item is used to determine
								// whether it's a native item (that needs to be returned to the cache),
								// or not (and needs to be freed).
	PDICTIONARY_ITEM p, q;		// Go through the items in a bucket

	if (Buckets != NULL) {
		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++) {
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);

				// Compute the offset of the current dictionary item
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset < dwNormalSize)
					p = p->next;
				else {
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
			Buckets[i] = NULL;
		}

		// Initialize the class iterator
		pCurrent = NULL;

		/* Initialize the Dictionary items array */
		ItemCount = 3 * NumOfBuckets;
		p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
		for (i = 0; i < ItemCount; i++)
			ItemArray[i] = p++;

		NumOfExternItems = 0;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\memmgr2.cpp ===
#include "precomp.h"
/*
 *	memmgr.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MemoryManager class.  This
 *		file contains the code necessary to allocate and distribute memory
 *		in the form of Memory objects.
 *
 *	Protected Instance Variables:
 *		Memory_Buffer
 *			This is the base address for the large memory buffer that the
 *			Memory Manager object allocates during instantiation.  This is
 *			remembered so that the buffer can be freed when the Memory Manager
 *			object is destroyed.
 *		Memory_Information
 *			This is a pointer to the structure in memory that contains general
 *			information about the memory being managed by this object.
 *
 *	Protected Member Functions:
 *		ReleaseMemory
 *			This is a private function releases memory used by a Memory object
 *			by putting it back into the proper free stack list.
 *		CalculateMemoryBufferSize
 *		AllocateMemoryBuffer
 *		InitializeMemoryBuffer
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

DWORD MemoryManager::dwSystemPageSize = 0;

/*
 *	MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the default constructor for this class.  It does nothing and
 *		only exists to allow classes to derive from this one without having to
 *		invoke the defined constructor.
 */
MemoryManager::MemoryManager () :
		pExternal_Block_Information (NULL), fIsSharedMemory (TRUE),
		bAllocs_Restricted (TRUE), Max_External_Blocks (0)
{
}

/*
 *	MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the MemoryManager class.  It calculates
 *		how much total memory will be required to hold all the blocks
 *		asked for in the memory template array that is passed in.  It then
 *		allocates all of that memory in one operating system call.  It then
 *		builds a set of free stacks, each of which contains all the blocks
 *		of a particular size.
 */
MemoryManager::MemoryManager (
		PMemoryTemplate		memory_template,
		ULong				memory_count,
		PMemoryManagerError	memory_manager_error,
		ULong				ulMaxExternalBlocks,
		BOOL			bAllocsRestricted) :
		bAllocs_Restricted (bAllocsRestricted),
		fIsSharedMemory (FALSE), Max_External_Blocks (0)
{
	ULong		memory_buffer_size;

    *memory_manager_error = MEMORY_MANAGER_NO_ERROR;

	/*
	 *	Calculate the amount of memory required for this memory manager
	 *	(including all management structures).
	 */
	memory_buffer_size = CalculateMemoryBufferSize (memory_template,
			memory_count, NULL);

	/*
	 *	Allocate the memory buffer.
	 */
	AllocateMemoryBuffer (memory_buffer_size);

	/*
	 *	If the allocation succeeded, then initialize the memory buffer so that
	 *	it can be used.
	 */
	if (Memory_Buffer != NULL)
	{
		/*
		 *	Initialize the External block information dictionary.
		 *	This is only for allocations that do not come from preallocated
		 *	buffers.
		 */
		if (ulMaxExternalBlocks > 0) {
			pExternal_Block_Information = new BlockInformationList (ulMaxExternalBlocks / 3);

			if (NULL != pExternal_Block_Information) {
				Max_External_Blocks = ulMaxExternalBlocks;
			}
			else
			{
				/*
				 *	We were unable to allocate memory for the pre-allocated
		 		 *	memory pool.
			 	 */
				ERROR_OUT(("MemoryManager::MemoryManager: "
						"failed to allocate the external block information dictionary"));
				*memory_manager_error = MEMORY_MANAGER_ALLOCATION_FAILURE;
			}
		}

		if (*memory_manager_error != MEMORY_MANAGER_ALLOCATION_FAILURE) {
			/*
			 *	Initialize the memory buffer.  Note that no error can occur doing
			 *	this, since the allocation has already succeeded.
			 */
			InitializeMemoryBuffer (memory_template, memory_count);

			/*
			 *	Indicate that no error occured.
			 */
			TRACE_OUT(("MemoryManager::MemoryManager: allocation successful"));
			TRACE_OUT(("MemoryManager::MemoryManager: Allocated %d memory blocks", GetBufferCount()));
			*memory_manager_error = MEMORY_MANAGER_NO_ERROR;
		}
	}
	else
	{
		/*
		 *	We were unable to allocate memory for the pre-allocated
		 *	memory pool.
		 */
		ERROR_OUT(("MemoryManager::MemoryManager: allocation failed"));
		*memory_manager_error = MEMORY_MANAGER_ALLOCATION_FAILURE;
	}
}

/*
 *	~MemoryManager ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Memory Manager class.  It frees up the
 *		memory allocated for the memory pool (if any).
 */
MemoryManager::~MemoryManager ()
{
	PBlockInformation	lpBlockInfo;
	/*
	 *	Iterate through the external block information list, deleting all
	 *	block information structures contained therein.
	 */
	if (NULL != pExternal_Block_Information)
	{
		pExternal_Block_Information->reset();
		while (pExternal_Block_Information->iterate ((PDWORD_PTR) &lpBlockInfo))
		{
			delete lpBlockInfo;
	    }

		delete pExternal_Block_Information;
	}

	/*
	 *	Free up the memory buffer (if there is one).
	 */
	if (Memory_Buffer != NULL)
	{
		LocalFree ((HLOCAL) Memory_Buffer);
		Memory_Buffer = NULL;
	}
}

/*
 *	PMemory		AllocateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to allocate a Memory object from the Memory
 *		Manager object.
 */
PMemory		MemoryManager::AllocateMemory (
					PUChar				reference_ptr,
					ULong				length,
					MemoryLockMode		memory_lock_mode)
{
	PFreeStack			free_stack;
	ULong				count;
	PBlockNumber		block_stack;
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr = NULL;
	PMemory				memory = NULL;

	// TRACE_OUT(("MemoryManager::AllocateMemory: Remaining %d memory blocks", GetBufferCount()));
						
	/*
	 *	If the application requests a block of size zero (0), then simply
	 *	return a NULL without allocating a block.
	 */
	if (length != 0)
	{
		/*
		 *	Walk through the free stack list look for a free stack that meets
		 *	the following two allocation criteria:
		 *
		 *	1.	It must contain blocks that are big enough to hold the
		 *		reference data.  This is why it is important for the block
		 *		sizes to be specified in ascending order in the constructor.
		 *		This code checks for a block that is big enough starting at the
		 *		beginning.  By putting them in ascending order, you are insured
		 *		that the smallest available block will be used.
		 *	2.	It must have enough free blocks left to allow the allocation.
		 *		This is where priority is used.  Right now it is very simple:
		 *		the allocation will succeed if the number of available blocks
		 *		is greater than the passed in priority (which is why a lower
		 *		number actually reflects a higher priority).
		 */
		free_stack = Free_Stack;
		for (count = 0; count < Free_Stack_Count; count++)
		{
			/*
			 *	Check and see if the blocks in this free stack are big enough
			 *	to hold the reference data.  If so, are there enough to satisfy
			 *	this allocation (taking memory priority into consideration).
			 */
			if ((length <= free_stack->block_size) &&
				(free_stack->current_block_count > 0))
			{
				/*
				 *	Calculate the address of the next available block number
				 *	within the block stack.  Then read the block number and
				 *	advance the block stack offset to point to the next block.
				 */
				block_stack = (PBlockNumber) (Memory_Buffer +
						free_stack->block_stack_offset);
				block_number = *block_stack;
				free_stack->block_stack_offset += sizeof (BlockNumber);

				/*
				 *	Calculate the address of the appropriate block information
				 *	structure.  Make sure that the lock count for the newly
				 *	allocated block is zero, and the block is not marked as
				 *	freed.
				 */
				block_information = (PBlockInformation) (Block_Information +
						(sizeof (BlockInformation) * block_number));
				ASSERT (block_information->flags & FREE_FLAG);
				block_information->length = length;
				block_information->lock_count = 0;
				block_information->flags &= (~FREE_FLAG);

				/*
				 *	Decrement the number of blocks remaining, within this free stack.
				 */
				free_stack->current_block_count--;

				/*
				 *	Calculate the address of the newly allocated block.  Then
				 *	break out of the allocation loop to go use the block.
				 */
				copy_ptr = (PUChar) (Memory_Buffer +
						block_information->block_offset);

				ASSERT(copy_ptr != Memory_Buffer);


				/*
				 *	If this is a shared memory manager, and the block is not
				 *	committed, we need to commit the block.
				 */
				if ((TRUE == fIsSharedMemory) && (0 == (block_information->flags & COMMIT_FLAG))) {

					ASSERT ((free_stack->block_size % dwSystemPageSize) == 0);
					ASSERT ((((DWORD_PTR) copy_ptr) % dwSystemPageSize) == 0);

					PUChar temp = (PUChar) VirtualAlloc ((LPVOID) copy_ptr, free_stack->block_size,
														 MEM_COMMIT, PAGE_READWRITE);
					block_information->flags |= COMMIT_FLAG;

					ASSERT (temp == copy_ptr);
					ASSERT (temp != NULL);

					if (copy_ptr != temp) {
						TRACE_OUT((">>>>>#### Copy_ptr: %p, Temp: %p, Committed?: %d",
	        					copy_ptr, temp, block_information->flags & COMMIT_FLAG));
						TRACE_OUT((">>>>>#### Size: %d, Req. length: %d",
    		    				free_stack->block_size, length));
						copy_ptr = NULL;
					}
				}
				break;
			}

			/*
			 *	Point to the next entry in the free stack list.
			 */
			free_stack++;
		}

		/*
		 *	If the memory allocation failed and it's for local memory,
		 *	attempt to allocate external memory to hold the block.
		 */
		if ((copy_ptr == NULL) &&
			((FALSE == bAllocs_Restricted) ||
			((NULL != pExternal_Block_Information) &&
			(Max_External_Blocks > pExternal_Block_Information->entries()))))
		{

			ASSERT (FALSE == fIsSharedMemory);
			/*
			 *	Try allocating from system memory.  Set the free stack to NULL
			 *	to indicate that this block did NOT come from one of our free
			 *	stacks.
			 */
			copy_ptr = (PUChar) LocalAlloc (LMEM_FIXED, length);

			if (copy_ptr != NULL)
			{
				/*
				 *	Allocate a block information structure to hold relevant
				 *	information about this externally allocated block.
				 */
				block_information = new BlockInformation;

				if (block_information != NULL)
				{
					/*
					 *	Fill in the block information structure.  Block offset
					 *	is irrelevant for an externally allocated block.  A
					 *	newly allocated block has a lock count of zero, and
					 *	is not freed.
					 */
					block_information->length = length;
					block_information->lock_count = 0;
					block_information->flags = COMMIT_FLAG;

					/*
					 *	Put the block information structure into a dictionary
					 *	for future use.  This is only necessary for externally
					 *	allocated blocks, since the block information structures
					 *	for internal blocks are in the memory buffer.
					 */
					pExternal_Block_Information->insert ((DWORD_PTR) copy_ptr, (DWORD_PTR) block_information);

					/*
					 *	Set block number to be an
					 *	invalid value to indicate that this block is NOT in
					 *	the internally managed memory buffer.
					 */
					block_number = INVALID_BLOCK_NUMBER;
				}
				else
				{
					/*
					 *	We were unable to allocate the space for the block
					 *	information structure, so we must free the externally
					 *	memory we just allocated.
					 */
					LocalFree ((HLOCAL) copy_ptr);
					copy_ptr = NULL;
				}
			}
		}

		/*
		 *	If there was a block available for the allocation, it is still
		 *	necessary to create the Memory object that will hold the block.
		 */
		if (copy_ptr != NULL)
		{
			ASSERT (block_information->flags == COMMIT_FLAG);
			/*
			 *	Create the Memory object.  If it fails, then cleanly release
			 *	the memory that was to be used for this block.
			 */
			memory = new Memory (reference_ptr, length, copy_ptr,
			    				 block_number, memory_lock_mode);

			if (memory == NULL)
			{
				/*
				 *	If the free stack for the memory is not NULL, then it is
				 *	an internally managed block.  Otherwise, this was an
				 *	externally allocated block that resulted from a critical
				 *	allocation above.
				 */
				if (INVALID_BLOCK_NUMBER != block_number)
				{
					/*
					 *	Adjust the block stack offset to point to the previous
					 *	entry in the list.  Note that it is not necessary to
					 *	put the block number into the list since it still there
					 *	from when we pulled it out above.
					 */
					free_stack->block_stack_offset -= sizeof (BlockNumber);

					/*
					 *	Indicate that the block is currently freed.  Note that
					 *	it is not necessary to calculate the address of the
					 *	block information structure since we did this above.
					 */
					block_information->flags |= FREE_FLAG;

					/*
					 *	Decrement the block counter to indicate that there
					 *	is another block in this free stack.
					 */
					free_stack->current_block_count++;
				}
				else
				{
					/*
					 *	This block was externally allocated, so it must be
					 *	externally freed.  Also eliminate the block information
					 *	structure associated with this memory block.
					 */
					pExternal_Block_Information->remove ((DWORD_PTR) copy_ptr);
					delete block_information;
					LocalFree ((HLOCAL) copy_ptr);
				}
			}
		}
	}
	else
	{
		/*
		 *	The application has attempted to allocate a block of size zero.
		 *	It is necessary to fail the request.
		 */
		ERROR_OUT(("MemoryManager::AllocateMemory: attempt to allocate zero-length block"));
	}

	/*
	 *	Decrement the number of blocks remaining
	 *	in this memory manager as a whole.
	 */
	if ((TRUE == bAllocs_Restricted) && (memory != NULL))
		Memory_Information->current_block_count--;

	return (memory);
}

/*
 *	Void	FreeMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to release a previously allocated Memory object.
 */
Void	MemoryManager::FreeMemory (
				PMemory		memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	/*
	 *	Make sure that the indicated memory block has not already been
	 *	freed.
	 */
	if ((block_information->flags & FREE_FLAG) == 0)
	{
		/*
		 *	Mark the memory block as being freed.
		 */
		block_information->flags |= FREE_FLAG;

		/*
		 *	If the lock count for this block has reached zero, we can free
		 *	the block for re-use.  We can also delete the memory object, as it
		 *	is no longer needed.
		 */
		if (block_information->lock_count == 0)
		{
			ReleaseMemory (memory);
			delete memory;
		}
		else
		{
			/*
			 *	If the lock count has not yet reached zero, check to see if the
			 *	memory object is to be deleted anyway.  If the memory lock mode
			 *	is set to "IGNORED", then delete the memory object immediately.
			 */
			if (memory->GetMemoryLockMode () == MEMORY_LOCK_IGNORED)
				delete memory;
		}
	}
	else
	{
		/*
		 *	The memory block has already been freed, so this call will be
		 *	ignored.
		 */
		ERROR_OUT(("MemoryManager::FreeMemory: memory block already freed"));
	}
}

/*
 *	PMemory		CreateMemory ()
 *
 *	Public
 *
 *	Functional Description:
 */
PMemory		MemoryManager::CreateMemory (
					BlockNumber		block_number,
					MemoryLockMode	memory_lock_mode)
{
	ULong				total_block_count = 0;
	PFreeStack			free_stack;
	ULong				count;
	PBlockInformation	block_information;
	PUChar				copy_ptr;
	PMemory				memory = NULL;

	/*
	 *	Make sure that this block number lies within the range handled by
	 *	this memory manager.
	 */
	if (block_number < Memory_Information->total_block_count)
	{
		/*
		 *	We must first walk through the free stack list to determine which
		 *	free stack the specified block is in.  Start by pointing to the
		 *	first free stack.
		 */
		free_stack = Free_Stack;
		for (count = 0; count < Free_Stack_Count; count++)
		{
			/*
			 *	Update the counter which keeps track of how many blocks are
			 *	represented by this free stack and the ones already processed.
			 *	This is used to determine if the specified block number is in
			 *	this free stack.
			 */
			total_block_count += free_stack->total_block_count;

			/*
			 *	Is the block in this free stack?
			 */
			if (block_number < total_block_count)
			{
				/*
				 *	Yes it is.  Claculate the address of the block information
				 *	structure for this block.  Then calculate the address of
				 *	the actual block based on the address of the local memory
				 *	buffer.
				 */
				block_information = (PBlockInformation) (Block_Information +
						(sizeof (BlockInformation) * block_number));
				copy_ptr = (PUChar) (Memory_Buffer +
						block_information->block_offset);
				ASSERT (block_information->flags & COMMIT_FLAG);

				/*
				 *	Create a memory object to represent this block.
				 */
				memory = new Memory (NULL, block_information->length, copy_ptr,
									 block_number, memory_lock_mode);

				if (memory == NULL)
				{
					/*
					 *	Allocation of the memory object failed, so we cannot
					 *	create a memory block at this time.
					 */
					ERROR_OUT(("MemoryManager::CreateMemory: memory object allocation failed"));
				}
				break;
			}

			/*
			 *	The block was not in the last free stack, so point to the
			 *	next one.
			 */
			free_stack++;
		}
	}
	else
	{
		/*
		 *	The specified block number is out of range for this memory manager.
		 *	The request must therefore fail.
		 */
		ERROR_OUT(("MemoryManager::CreateMemory: block number out of range"));
	}

	return (memory);
}


/*
 *	Void	LockMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to lock a Memory object.
 */
Void	MemoryManager::LockMemory (
				PMemory		memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	ASSERT (block_information->flags & COMMIT_FLAG);
	/*
	 *	Increment the lock count for the specified memory block.
	 */
	block_information->lock_count++;

}

/*
 *	Void	UnlockMemory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to unlock a previously locked Memory object.
 */
Void	MemoryManager::UnlockMemory (
				PMemory	memory)
{
	BlockNumber			block_number;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
	}
	else
	{
		/*
		 *	This is externally allocated memory, so it must be handled
		 *	differently.  Ask the memory block what the copy pointer is, and
		 *	use that to look up the address of the block information structure.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
	}

	ASSERT (block_information->flags & COMMIT_FLAG);
	/*
	 *	Make sure that the lock isn't already zero before proceeding.
	 */
	if (block_information->lock_count > 0)
	{
		/*
		 *	Decrement the lock count for the specified memory block.
		 */
		block_information->lock_count--;

		/*
		 *	If the lock count has reached zero and the memory block is
		 *	marked as being freed, then we can free the block for re-use.
		 */
		if ((block_information->lock_count == 0) &&
				(block_information->flags & FREE_FLAG))
		{
			ReleaseMemory (memory);

			/*
			 *	We have now released the memory buffer, so we must check to
			 *	see if we are supposed to destroy the memory object itself.
			 */
			if (memory->GetMemoryLockMode () == MEMORY_LOCK_NORMAL)
				delete memory;
		}
	}
	else
	{
		/*
		 *	The specified block has a lock count of zero already, so ignore
		 *	this call.
		 */
		ERROR_OUT(("MemoryManager::UnlockMemory: memory block already unlocked"));
	}
}

/*
 *	ULong	GetBufferCount ()
 *
 *	Public
 *
 *	Functional Description:
 */
ULong	MemoryManager::GetBufferCount (
						ULong				length)
{
	PFreeStack		free_stack;
	ULong			count;
	ULong			buffer_count;

	if (FALSE == bAllocs_Restricted)
		return (LARGE_BUFFER_COUNT);

	buffer_count = Memory_Information->current_block_count;
	free_stack = Free_Stack;
	for (count = 0; count < Free_Stack_Count; count++)
	{
		/*
		 *	Check and see if the blocks in this free stack are smaller than
		 *	the specified length.  If yes, we need to deduct these buffers.
		 *	Otherwise, we can stop deducting.
		 */
		if (length > free_stack->block_size) {
			buffer_count -= free_stack->current_block_count;

			/*
			 *	Point to the next entry in the free stack list.
			 */
			free_stack++;
		}
		else
			break;
	}

	return (buffer_count);
}

/*
 *	Void	ReleaseMemory (
 *					PMemory		memory)
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to release a Memory object, and free the memory
 *		it represents back to the available pool.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	MemoryManager::ReleaseMemory (
				PMemory		memory)
{
	PFreeStack			free_stack;
	BlockNumber			block_number;
	PBlockNumber		block_stack;
	PBlockInformation	block_information;
	PUChar				copy_ptr;

	/*
	 *	Ask the specified memory object what block number it represents.
	 */
	block_number = memory->GetBlockNumber ();

	/*
	 *	Use the block number to determine if this is an internally
	 *	allocated memory block, or an externally allocated one.
	 */
	if (block_number != INVALID_BLOCK_NUMBER)
	{
		/*
		 *	From that, calculate the address of the block information structure.
		 */
		 block_information = (PBlockInformation) (Block_Information +
				(sizeof (BlockInformation) * block_number));
				
		/*
		 *	Get the address of the free stack from which this block came.
		 */
		free_stack = (PFreeStack) (Memory_Buffer + block_information->free_stack_offset);

		/*
		 *	Adjust the block stack offset to point to the previous element,
		 *	and then use it to calculate an address and put the block number
		 *	there.  This effectively "pushes" the block number onto the stack.
		 */
		free_stack->block_stack_offset -= sizeof (BlockNumber);
		block_stack = (PBlockNumber) (Memory_Buffer +
				free_stack->block_stack_offset);
		*block_stack = block_number;

		/*
		 *	Indicate that this block is freed.
		 */
		block_information->flags = FREE_FLAG | COMMIT_FLAG;

		/*
		 *	Increment the counter indicating the number of available blocks
		 *	in this free stack.
		 */
		free_stack->current_block_count++;
	}
	else
	{
		/*
		 *	Since the block was allocated from system memory, thats where it
		 *	needs to go back to.
		 */
		copy_ptr = memory->GetPointer ();
		pExternal_Block_Information->find ((DWORD_PTR) copy_ptr, (PDWORD_PTR) &block_information);
		pExternal_Block_Information->remove ((DWORD_PTR) copy_ptr);
		delete block_information;
		LocalFree ((HLOCAL) copy_ptr);
	}

	/*
	 *	Increment the number of blocks available in this memory manager as a whole.
	 */
	if (TRUE == bAllocs_Restricted)
		Memory_Information->current_block_count++;
}

/*
 *	ULong	CalculateMemoryBufferSize (
 *					PMemoryTemplate		memory_template,
 *					ULong				memory_count,
 *					ULong	*			pulCommittedBytes)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function is used to calculate how much memory will be
 *		required in order to manage the number of memory blocks specified in
 *		the passed in memory template.  Note that this total includes the size
 *		of the memory blocks as well as the amount of memory used for management
 *		functions.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is an array of structures that identify the blocks to be
 *			managed by this object.
 *		memory_count
 *			This is the number of entries in the above array.
 *		pulCommittedBytes
 *			If fIsSharedMemory == FALSE, this can be NULL.  Otherwise, it is
 *			used to return the size of the total memory we need to commit
 *			when the manager is getting initialized.
 *
 *	Return Value:
 *		The required size of the memory buffer for this object.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

ULong	MemoryManager::CalculateMemoryBufferSize (
				PMemoryTemplate		memory_template,
				ULong				memory_count,
 				ULong	*			pulCommittedBytes)
{
	ULong			memory_buffer_size;
	PMemoryTemplate	pMemTemplate;
	ULong			memory_per_block;

	/*
	 *	Claculate the amount of memory that will be required to hold the
	 *	memory information structure and the free stacks.
	 */
	memory_buffer_size = (sizeof (MemoryInformation) +
			(sizeof (FreeStack) * memory_count));

	if (FALSE == fIsSharedMemory) {
		/*
		 *	Add in the amount of memory the block stacks, the block information
		 *	structures, and the memory blocks themselves will take up.
		 */
		for (pMemTemplate = memory_template; pMemTemplate - memory_template < (int) memory_count; pMemTemplate++)
		{
			/*
			 *	The amount of memory required for each managed block of memory can
			 *	be calculated as a sum of the following:
			 *
			 *	1.	sizeof (BlockNumber) - This is the amount of space taken by the
			 *			block number in the block stack.
			 *	2.	sizeof (BlockInformation) - Every managed block of memory has
			 *			a BlockInformation structure associated with it.
			 *	3.	block_size - The actual size of the block.  This is provided
			 *			in the memory template.
			 */
			memory_per_block = sizeof (BlockNumber) + sizeof (BlockInformation) +
										pMemTemplate->block_size;
			memory_buffer_size += (memory_per_block * pMemTemplate->block_count);
		}
	}

	/*
	 *	For shared memory, we need to do a few more extra things:
	 *
	 *	Blocks of size greater or equal to the system's page, need to
	 *	start on a page boundary. In addition, they can be expanded to
	 *	end at a page boundary, too.
	 */
	else {
	
			ULong	reserved_buffer_size = 0;
			ULong	temp;
			
		for (pMemTemplate = memory_template; pMemTemplate - memory_template < (int) memory_count; pMemTemplate++) {		
			if (dwSystemPageSize <= pMemTemplate->block_size) {
				pMemTemplate->block_size = EXPAND_TO_PAGE_BOUNDARY(pMemTemplate->block_size);
				reserved_buffer_size += pMemTemplate->block_count * pMemTemplate->block_size;
			}
			memory_per_block = sizeof (BlockNumber) + sizeof (BlockInformation) +
								pMemTemplate->block_size;
			memory_buffer_size += memory_per_block * pMemTemplate->block_count;
		}
		*pulCommittedBytes = memory_buffer_size - reserved_buffer_size;
		temp = EXPAND_TO_PAGE_BOUNDARY(*pulCommittedBytes);
		temp -= (*pulCommittedBytes);
		*pulCommittedBytes += temp;
		memory_buffer_size += temp;
		ASSERT (*pulCommittedBytes <= memory_buffer_size);
		ASSERT ((memory_buffer_size % dwSystemPageSize) == 0);
		ASSERT ((*pulCommittedBytes % dwSystemPageSize) == 0);
		ASSERT ((reserved_buffer_size % dwSystemPageSize) == 0);
	}

	return (memory_buffer_size);
}


/*
 *	Void	AllocateMemoryBuffer (
 *					ULong		memory_buffer_size)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function allocates the memory that is managed by an instance
 *		of MemoryManager.  It does this using the standard Malloc macro.
 *
 *	Formal Parameters:
 *		memory_buffer_size
 *			The size of the buffer to be allocated.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The instance variable Memory_Buffer is set to the address of the
 *		allocated block of memory.  If it is NULL after the return from this
 *		call, that indicates that the memory could not be allocated.
 *
 *	Caveats:
 *		None.
 */
Void	MemoryManager::AllocateMemoryBuffer (
				ULong		memory_buffer_size)
{
	TRACE_OUT(("MemoryManager::AllocateMemoryBuffer: allocating %ld bytes", memory_buffer_size));
	if (memory_buffer_size != 0)
		Memory_Buffer = (HPUChar) LocalAlloc (LMEM_FIXED, memory_buffer_size);
	else
		Memory_Buffer = NULL;
}


/*
 *	Void	InitializeMemoryBuffer (
 *					PMemoryTemplate		memory_template,
 *					ULong				memory_count)
 *
 *	Protected
 *
 *	Functional Description:
 *		This member function is used to initialize the memory buffer for use.
 *		This primarily includes filling in the management structures that lie
 *		at the beginning of the allocated memory block, so that allocations
 *		can take place.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is an array of structures that identify the blocks to be
 *			managed by this object.
 *		memory_count
 *			This is the number of entries in the above array.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

Void	MemoryManager::InitializeMemoryBuffer (
				PMemoryTemplate		memory_template,
				ULong				memory_count)
{
	ULong				block_count = 0;
	ULong				index;
	ULong				memory_information_size;
	ULong				free_stack_size;
	ULong				free_stack_offset;
	ULong				block_stack_size;
	ULong				block_information_size;
	PFreeStack			free_stack;
	PBlockNumber		block_stack;
	PBlockInformation	block_information;
	ULong				block_stack_offset;
	BlockNumber			block_number;
	ULong				block_offset;
	ULong				block_size;
	ULong				count;
	BOOL			fIsFirstTime;

	/*
	 *	Walk through the memory template calculating how many memory blocks
	 *	exist (regardless of size).
	 */
	for (index = 0; index < memory_count; index++)
		block_count += memory_template[index].block_count;

	/*
	 *	Calculate the amount of memory required to hold all the various sections
	 *	of data in the memory buffer.
	 */
	memory_information_size = sizeof (MemoryInformation);
	free_stack_size = sizeof (FreeStack) * memory_count;
	block_stack_size = sizeof (BlockNumber) * block_count;
	block_information_size = sizeof (BlockInformation) * block_count;

	/*
	 *	Initialize all elements of the memory information structure.
	 *	Note that all offsets in this structure are from the beginning of the
	 *	memory buffer.
	 */
	Memory_Information = (PMemoryInformation) Memory_Buffer;
	Memory_Information->free_stack_offset = memory_information_size;
	Memory_Information->free_stack_count = memory_count;
	Memory_Information->block_information_offset =
			memory_information_size + free_stack_size + block_stack_size;
	Memory_Information->total_block_count = block_count;
	if (TRUE == bAllocs_Restricted) {
		// The current_block_count is only needed when allocations are restricted.
		Memory_Information->current_block_count = block_count + Max_External_Blocks;
	}

	/*
	 *	Now initialize the instance variables that point to each list within
	 *	the memory buffer.  These instance variables are later used to resolve
	 *	all other offsets.
	 */
	Free_Stack = (PFreeStack) (Memory_Buffer + memory_information_size);
	Free_Stack_Count = memory_count;
	Block_Information = (Memory_Buffer +
			Memory_Information->block_information_offset);

	/*
	 *	This loop walks through the memory template array again, this time
	 *	filling in the contents of the free stacks, the blocks stacks, and
	 *	the block information structures.
	 */
	fIsFirstTime = TRUE;
	free_stack = Free_Stack;
	free_stack_offset = memory_information_size;
	block_stack_offset = memory_information_size + free_stack_size;
	block_stack = (PBlockNumber) (Memory_Buffer + block_stack_offset);
	block_information = (PBlockInformation) Block_Information;
	block_number = 0;
	block_offset = block_stack_offset + block_stack_size + block_information_size;

	for (index = 0; index < memory_count; index++)
	{
		/*
		 *	Get the block size and count from the template entry.
		 */
		block_size = memory_template[index].block_size;
		block_count = memory_template[index].block_count;

		/*
		 *	Initialize the free stack for this block size, and then point to
		 *	the next free stack in the list.
		 */
		free_stack->block_size = block_size;
		free_stack->total_block_count = block_count;
		free_stack->current_block_count = block_count;
		(free_stack++)->block_stack_offset = block_stack_offset;

		/*
		 *	Adjust the block stack offset to point to the first block number
		 *	of the next free stack (skip past all of the block numbers for
		 *	this free stack).
		 */
		block_stack_offset += (sizeof (BlockNumber) * block_count);

		/*
		 *	The following happens only once in this loop:
		 *	When the memory manager manages shared memory and
		 *	The block size becomes FOR THE 1ST TIME, bigger than
		 *	the page size, then, we need to jump to the next page
		 *	boundary.
		 */
		if ((TRUE == fIsSharedMemory) && (TRUE == fIsFirstTime)
			&& (block_size >= dwSystemPageSize)) {
			fIsFirstTime = FALSE;
			block_offset = EXPAND_TO_PAGE_BOUNDARY(block_offset);
		}
		
		/*
		 *	Initialize the block list for this block size.  Also, increment
		 *	the total number of buffers for each block that is segmented
		 *	off.
		 */
		for (count = 0; count < block_count; count++)
		{
			/*
			 *	Put the block number for this block into the current block
			 *	stack.  Increment both the block stack pointer and the block
			 *	number.
			 */
			*(block_stack++) = block_number++;

			/*
			 *	Fill in the block information structure for this block.  Then
			 *	increment the block information pointer to point to the next
			 *	entry in the list.
			 */
#ifdef _DEBUG
			if ((TRUE == fIsSharedMemory) && (block_size >= dwSystemPageSize)) {
				ASSERT ((block_size % dwSystemPageSize) == 0);
				ASSERT ((block_offset % dwSystemPageSize) == 0);
			}
#endif
			block_information->block_offset = block_offset;
			block_information->free_stack_offset = free_stack_offset;
			if ((TRUE == fIsSharedMemory) && (block_size >= dwSystemPageSize))
				block_information->flags = FREE_FLAG;
			else
				block_information->flags = FREE_FLAG | COMMIT_FLAG;
			block_information++;

			/*
			 *	Adjust the block offset to point to the next block.
			 */
			block_offset += block_size;
		}
		
		free_stack_offset += sizeof (FreeStack);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\memmgr2.h ===
/*
 *	memmgr.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MemoryManager class.  This class
 *		is used to efficiently manage the passing of data through a system.
 *		There are two primary techniques it uses to accomplish the goal of
 *		efficiency:
 *
 *		1.	Use of locally managed "blocked" memory.  When this class is
 *			instantiated, it allocates a large block of memory which it then
 *			chops up into various size blocks.  These blocks are then used
 *			to hold data, rather than having to do system calls every time
 *			some memory is needed.
 *
 *		2.	Use of a "copy on lock" algorithm.  When memory is first
 *			allocated, the source data is NOT yet copied to it.  Copy
 *			operations will implicitly use the reference rather than copying
 *			the data.  If the data needs to be retained longer than the
 *			expected life-span of the reference, then a Lock command can be
 *			sent to the block to cause it to be copied.
 *
 *		When an object needs to allocate memory to hold some data, it calls
 *		an allocate function within an object of this class.  Assuming that
 *		the request can be satisfied, a pointer to a Memory object is returned.
 *		This Memory object remembers two addresses: the address of the reference
 *		buffer (where the source data is); and the address of the copy buffer
 *		(which is the buffer allocated to hold the data).  As mentioned above,
 *		the data is NOT copied to the copy buffer as part of the allocation
 *		process.  The data is not copied until the Memory object is locked
 *		for the first time.
 *
 *		Objects of this class keep a list of available buffers.  There is one
 *		list for each size block that is available.  One of the constructor
 *		parameters can be used to control how much data is allocated up front,
 *		and what size blocks it is chopped up into.  This makes this class very
 *		flexible in how it can be used.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY_MANAGER2_H_
#define	_MEMORY_MANAGER2_H_


/*
 *	These are the errors that can be returned from some of the memory manager
 *	member functions.
 */
typedef	enum
{
	MEMORY_MANAGER_NO_ERROR,
	MEMORY_MANAGER_ALLOCATION_FAILURE,
	MEMORY_MANAGER_INVALID_PARAMETER
} MemoryManagerError;
typedef	MemoryManagerError *		PMemoryManagerError;

/*
 *	An array of this structure is passed into the constructor to define the
 *	number and size of blocks to be created by this object.
 */
typedef	struct
{
	ULong		block_size;
	ULong		block_count;
} MemoryTemplate;
typedef	MemoryTemplate *			PMemoryTemplate;

/*
 *	This structure is used to maintain general information about the shared
 *	memory region that has to be shared between all users of it.
 */
typedef	struct
{
	ULong		free_stack_offset;
	ULong		free_stack_count;
	ULong		block_information_offset;
	ULong		total_block_count;
	ULong		current_block_count;
} MemoryInformation;
typedef	MemoryInformation *			PMemoryInformation;

/*
 *	This structure is used to keep information about each memory block that is
 *	being managed by an instance of this class.
 */
typedef	struct
{
	ULong		block_offset;
	ULong		length;
	ULong		free_stack_offset;
	ULong		lock_count;
	ULong		flags;
} BlockInformation;
typedef	BlockInformation *			PBlockInformation;

/*
 *	These are the masks for manipulating the flags of a BlockInformation structure
 */
#define		FREE_FLAG		0x1
#define		COMMIT_FLAG		0x2

/*
 *	The following are definitions for macros used to handle space and space
 *	requirements in relation to page boundaries in the system.
 */
#define EXPAND_TO_PAGE_BOUNDARY(p)	(((p) + dwSystemPageSize - 1) & (~ (dwSystemPageSize - 1)))

/*
 *	The following number is used when the caller asks for the number of buffers remaining
 *	within a Memory Manager where allocations are not restricted.  The intention is 
 *	that this number is very large and enough for the caller to think that all its 
 *	allocation requests will succeed.
 */
#define LARGE_BUFFER_COUNT			0x1000
 
/*
 *	These typedefs define a container that is used to hold block information
 *	structure pointers.  This is used to hold information about blocks that
 *	are externally allocated, but are managed by this class.
 */
typedef	DictionaryClass				BlockInformationList;

/*
 *	This is the class definition for the MemoryManager class.
 */
class MemoryManager
{
	public:
							MemoryManager ();
							MemoryManager (
									PMemoryTemplate		memory_template,
									ULong				memory_count,
									PMemoryManagerError	memory_manager_error,
									ULong				ulMaxExternalBlocks,
									BOOL			bAllocsRestricted = TRUE);
		virtual				~MemoryManager ();
		virtual PMemory		AllocateMemory (
									PUChar				reference_ptr,
									ULong				length,
									MemoryLockMode		memory_lock_mode =
															MEMORY_LOCK_NORMAL);
		virtual Void		FreeMemory (
									PMemory				memory);
		virtual	PMemory		CreateMemory (
									BlockNumber			block_number,
									MemoryLockMode		memory_lock_mode =
															MEMORY_LOCK_NORMAL);
		virtual Void		LockMemory (
									PMemory				memory);
		virtual Void		UnlockMemory (
									PMemory				memory);
				ULong		GetBufferCount ()
							{
								return((bAllocs_Restricted) ? Memory_Information->current_block_count : LARGE_BUFFER_COUNT);
							};
		virtual	ULong		GetBufferCount (
									ULong				length);

	private:
				Void		ReleaseMemory (
									PMemory				memory);

	protected:
				ULong		CalculateMemoryBufferSize (
									PMemoryTemplate		memory_template,
									ULong				memory_count,
 									ULong	*			pulCommittedBytes);
				Void		AllocateMemoryBuffer (
									ULong				memory_buffer_size);
				Void		InitializeMemoryBuffer (
									PMemoryTemplate		memory_template,
									ULong				memory_count);

		static DWORD			dwSystemPageSize;
		HPUChar					Memory_Buffer;
		PMemoryInformation		Memory_Information;
		PFreeStack				Free_Stack;
		ULong					Free_Stack_Count;
		HPUChar					Block_Information;
		BlockInformationList   *pExternal_Block_Information;
		ULong					Max_External_Blocks;
		BOOL				fIsSharedMemory;
		BOOL				bAllocs_Restricted;
};
typedef	MemoryManager *		PMemoryManager;

/*
 *	MemoryManager (
 *			PMemoryTemplate		memory_template,
 *			USHORT				memory_count,
 *			PMemoryManagerError	memory_manager_error)
 *
 *	Functional Description:
 *		This is the constructor for the MemoryManager class.  It uses the
 *		information in the specified memory templates to allocate a block
 *		of memory and chop it up into fixed size pieces.  It then puts
 *		these pieces into a set of free block lists, so that it can allocate
 *		memory on an as needed basis.
 *
 *	Formal Parameters:
 *		memory_template
 *			This is the base address of an array of memory template structures.
 *			Each element of this structure specifies how many blocks of a
 *			specified block size should be allocated.  The constructor scans
 *			the array, totaling the required memory, and then makes one memory
 *			allocation call.  It then chops the memory as specified by the
 *			memory templates.  It is VERY important the memory templates be
 *			specified in ascending order of block sizes.  In other words,
 *			smaller blocks should be specified first.
 *		memory_count
 *			This simply indicates how mamy memory templates there are in the
 *			list.
 *		memory_manager_error
 *			This is the return value from the constructor.  If anything besides
 *			MEMORY_MANAGER_NO_ERROR is returned, the object was not able to
 *			initialize itself properly, and should be destroyed immediately
 *			without being used.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~MemoryManager ()
 *
 *	Functional Description:
 *		This is the destructor for the MemoryManager class.  It frees up all
 *		resources being used by the Memory Manager object, including the
 *		memory block allocated to hold all user data.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PMemory			AllocateMemory (
 *							PUChar				address,
 *							ULong				length)
 *
 *	Functional Description:
 *		This function is used to allocate a piece of memory from the Memory
 *		Manager object.  Note that the return value is not a pointer to the
 *		memory, but rather, a pointer to a Memory object.  The memory object
 *		contains a buffer that is large enough to handle the reference data.
 *
 *		Note that the reference data is not automatically copied into the
 *		copy buffer of the Memory object.  This copy operation does not occur
 *		until the first time the Memory object is locked (through a Memory
 *		Manager call, as defined below).
 *
 *
 *	Formal Parameters:
 *		address
 *			This is the address of the reference data (or the source data).
 *		length
 *			This is the length of the reference data.
 *
 *	Return Value:
 *		A pointer to a Memory object if the request is successful.
 *		NULL otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			FreeMemory (
 *						PMemory		memory)
 *
 *	Functional Description:
 *		This function is used to free a previously allocated Memory object.
 *		Note that if the lock count of the Memory object is not 0 (zero), the
 *		object will not actually be freed yet.  This call merely enables the
 *		object to be freed (when the lock count does hit 0).
 *
 *		In summary, for a Memory object to actually be freed, two conditions
 *		must exist simultaneously: the Memory object must have been freed
 *		with a call to this function; and the lock count must hit zero.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being freed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			LockMemory (
 *						PMemory		memory)
 *
 *	Functional Description:
 *		This function is sued to lock an existing Memory object.  A locked
 *		Memory object will not be freed until the lock count hits zero.
 *
 *		When the lock count transitions from 0 to 1, the reference data is
 *		copied into the internal copy buffer.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being locked.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			UnlockMemory (
 *							PMemory	memory)
 *
 *	Functional Description:
 *		This function is used to unlock a Memory object that was previously
 *		locked.  Each time an object is unlocked, the lock count is decremented.
 *		When the lock count hits zero, the memory will be freed if-and-only-if
 *		the FreeMemory call has also been made.  In essence, for a Memory
 *		object to be freed, a call to FreeMemory must have been made, AND the
 *		lock count must be zero.
 *
 *	Formal Parameters:
 *		memory
 *			This is a pointer to the Memory object being unlocked.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetBufferCount ()
 *
 *	Functional Description:
 *		This function is used to determine the total number of available
 *		buffers that remain in the pool.  This should be used to determine
 *		general resource levels only.  It cannot be used to determine whether
 *		or not there is a buffer of a particular size.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The total number of buffers available (regardless of size).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetBufferCount (
 *						ULong	buffer_size)
 *
 *	Functional Description:
 *		This function is used to determine the number of X size buffers 
 *		that remain in the pool. 
 *
 *	Formal Parameters:
 *		buffer_size
 *			The buffer size that we want to count.
 *
 *	Return Value:
 *		The number of 'buffer_size' buffers available.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\memory2.cpp ===
#include "precomp.h"
/*
 *	memory.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Memory class.  Instances of
 *		this class represent chunks of data that are passed through a system.
 *		This class is particularly useful in cases where a memory buffer
 *		needs to be used in several different places, none of which know
 *		about each other.  This is because this class encapsulates things
 *		like lock counts, which are useful for holding memory until
 *		everyone that needs it is through.
 *
 *		Note that this class does NOT do memory management.  It is told by
 *		a higher level memory manager where its buffers are, etc.  For this
 *		reason, this class does not do any platform specific calls.
 *
 *	Private Instance Variables:
 *		Length
 *			This is the length of the reference buffer.
 *		Copy_Ptr
 *			This is the address of the allocated buffer that this object
 *			uses.
 *		Free_Stack
 *			This is a pointer to the free stack list from which the copy
 *			buffer was allocated.  This is held within this object as a
 *			convenience to the memory manager, allowing it to return the
 *			buffer to the free pool more quickly and easily.
 *		Block_Number
 *			This is the block number of the memory block that this object
 *			represents.  This is held within this object as a convenience to
 *			the memory manager, allowing it to return the buffer to the free
 *			pool more quickly and easily.
 *		Memory_Lock_Mode
 *			This fields indicates whether this memory object should be destroyed
 *			only when the lock count on the memory buffer reaches zero (NORMAL),
 *			or whether its okay to destroy immediately when the memory block is
 *			freed (IGNORED).
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */



/*
 *	Memory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  It just initializes
 *		all instance variable, based on the passed in values.
 */
Memory::Memory (
		PUChar			reference_ptr,
		ULong			length,
		PUChar			copy_ptr,
		BlockNumber		block_number,
		MemoryLockMode	memory_lock_mode) :
				Length (length), Copy_Ptr (copy_ptr), 
				Block_Number (block_number), Memory_Lock_Mode (memory_lock_mode)
{
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\mplex.h ===
/*    Mplex.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the multiplexer class.  It inherits from the ProtocolLayer
 *        class which means it is one of the layers in a Transport stack.  This
 *        class has these capabilities:
 *
 *            1.  It takes stream data from the lower layer and packetizes it.
 *                If the lower layer gives us data in a stream format, we run it
 *                through a packet framer to build up a packet.  This class uses
 *                a framer object passed in by the constructor.  When data is
 *                received from the lower layer, the data is given to the framer
 *                object.  The framer notifies us of a complete packet.  The
 *                framer could be any type of framer (i.e RFC1006, flagged data
 *                with bit or byte stuffing, ...).  If no framer is passed in by
 *                the constructor, we assume that the data is being received in
 *                packets.
 *
 *                A packet received from the higher layer is run through the
 *                framer to encode the data.  It is then fed to the lower layer
 *                in a stream fashion.
 *
 *            2.  It multiplexes multiple higher layers.  It currently assumes the
 *                incoming packets are in Q.922 packet format.  Each higher layer
 *                is identified by its DLCI.  This class is capable of looking at
 *                the packet and determining the DLCI and thus where to route it.
 *
 *                Since this is a multiplexer, we receive packets for many
 *                different stacks and we do not buffer them if the higher layer
 *                is not ready for them.  If it attempts to send the packet to the
 *                higher layer and it does not accept it, it may trash it.  This
 *                must be done in order to maintain the other transport
 *                connections.  If necessary, in the future, we could buffer
 *                packets at this layer.
 *
 *            3.  This class receives a CRC object during construction (if it is
 *                NULL, no CRC is necessary).  The object runs a packet thru the
 *                CRC generator and attaches it to the end of the packet.  On the
 *                reception of a packet from a lower layer, we check the CRC for
 *                validity.
 *
 *    Caveats:
 *        1.  If a framer exists, it assumes the packet is in Q.922 format
 *        2.  This class is currently Q.922 oriented as far as finding the
 *            packet identifier (DLCI).  This will be fixed in the future.
 *
 *    Authors:
 *        James W. Lawwill
 */
#ifndef _MULTIPLEXER_H_
#define _MULTIPLEXER_H_

#include "q922.h"

#define MULTIPLEXER_MAXIMUM_PACKET_SIZE     1024
#define TRANSPORT_HASHING_BUCKETS            3

 /*
 **    If the identifier (DLCI) contained by the packet is not legal, the following
 **    identifier is returned
 */
#define    ILLEGAL_DLCI    0xffff

 /*
 **    Multiplexer return codes
 */
typedef enum
{
    MULTIPLEXER_NO_ERROR
}
    MultiplexerError;

typedef struct
{
    IProtocolLayer     *q922;
    PMemoryManager      data_request_memory_manager;
}
    MPlexStruct, * PMPlexStruct;

class Multiplexer : public IProtocolLayer
{
public:

    Multiplexer(T123               *owner_object,
                ComPort            *lower_layer,
                PhysicalHandle      lower_layer_identifier,
                USHORT              message_base,
                PPacketFrame        framer,
                PCRC                crc,
                BOOL               *initialized);
    virtual ~Multiplexer(void);


    MultiplexerError    ConnectRequest (void);
    MultiplexerError    DisconnectRequest (void);


    /*
    **    Functions overridden from the ProtocolLayer object
    */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     dlci,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     dlci,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR        dlci,
                            PMemoryManager    memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    dlci);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     dlci,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *        max_packet_size,
                            USHORT *        prepend_bytes,
                            USHORT *        append_bytes);

private:

    void                SendDataToHigherLayer (
                            LPBYTE    buffer_address,
                            USHORT    buffer_length);
    DLCI                GetDLCI (
                            LPBYTE    buffer_address,
                            USHORT    buffer_size);

private:

    DictionaryClass     Q922_Layers;

    T123               *m_pT123; // owner object
    ComPort            *m_pComPort; // lower layer
    PhysicalHandle      m_hCommLink; // physical handle
    USHORT              m_nMsgBase;
    USHORT              Maximum_Packet_Size;
    USHORT              Packet_Size;

    LPBYTE              Data_Request_Buffer;
    PMemory             Data_Request_Memory_Object;
    DLCI                Data_Request_DLCI;
    USHORT              Data_Request_Length;
    USHORT              Data_Request_Offset;

    LPBYTE              Data_Indication_Buffer;
    USHORT              Data_Indication_Length;
    BOOL                Data_Indication_Ready;

    PPacketFrame        Framer;
    PCRC                CRC;
    USHORT              CRC_Size;

    BOOL                Decode_In_Progress;
    BOOL                Disconnect;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    Multiplexer::Multiplexer (
 *                    IObject *                object_owner,
 *                       IProtocolLayer *        lower_layer,
 *                       ULONG                identifier,
 *                    USHORT                message_base,
 *                    PPacketFrame        framer,
 *                    PCRC                crc,
 *                    BOOL *                initialized);
 *
 *    Functional Description
 *        This is the constructor for the Multiplexer layer
 *
 *    Formal Parameters
 *        object_owner    - (i)    Address of owner object.
 *        lower_layer        - (i)    Address of the layer below the multiplexer
 *        identifier        - (i)    A lower layer identifier that is passed to the
 *                                lower layer with each call to it.  The
 *                                identifier tells the lower layer which "channel"
 *                                to use.
 *        message_base    - (i)    Message identifier that is passed back to the
 *                                owner object during a callback
 *        framer            - (i)    Address of a framer object
 *        crc                - (i)    Address of a crc object
 *        initialized        - (o)    Set to TRUE if the multiplexer initialized OK
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    Multiplexer::~Multiplexer (void)
 *
 *    Functional Description
 *        This is the destructor for the Multiplexer layer.  It removes itself
 *        from the lower layer and frees all buffers and filters (i.e. framer)
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    MultiplexerError    Multiplexer::ConnectRequest (void);
 *
 *    Functional Description
 *        This function issues an immediate NEW_CONNECTION message to the owner
 *        of this object.  If this was a more sophisticated layer, it would
 *        communicate with the remote multiplexer layer to establish itself.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    MultiplexerError    Multiplexer::DisconnectRequest (void);
 *
 *    Functional Description
 *        This function removes its connection with the lower layer and does
 *        a BROKEN_CONNECTION callback to the owner object
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataRequest (
 *                                        ULONG        identifier,
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataRequest (
 *                                        ULONG        identifier,
 *                                        PMemory        memory,
 *                                        PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (o)    -    Pointer to memory object holding the packet
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.  If this multiplexer is being used as a stream to packet
 *        converter only, the identifer is not used and all data is passed to the
 *        higher layer.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::RemoveHigherLayer (
 *                                        ULONG    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::PollTransmitter (
 *                                        ULONG        identifier,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data);
 *
 *    Functional Description
 *        This function is called to give the Multiplexer a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Multiplexer does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::PollReceiver (
 *                                        ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the Multiplexer a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::GetParameters (
 *                                        ULONG        identifier,
 *                                        USHORT *        max_packet_size,
 *                                        USHORT *        prepend_bytes,
 *                                        USHORT *        append_bytes);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *        prepend_bytes        (o)    -    Returns the Number of bytes prepended by
 *                                    this layer
 *        append_bytes        (o)    -    Returns the Number of bytes appended by
 *                                    this layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\mplex.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Mplex.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Q922 multiplexer class.  This
 *        class multiplexes higher layers to a single lower layer.
 *
 *    Private Instance Variables:
 *        Q922_Layers        -        List of the higher layers we are multiplexing
 *        Owner_Object    -        Address of our owner object.
 *        m_pComPort        -        Address of our lower layer
 *        m_hCommLink-    The identifier we pass to the lower layer.  This
 *                                is how the lower layer identifies us
 *        m_nMsgBase    -        Message base we use for owner callbacks.  The
 *                                owner identifies us by the message base
 *        Maximum_Packet_Size        Maximum packet size we can send to lower layer
 *        Packet_Size        -        Maximum packet size the higher layer can send
 *                                to us
 *        Data_Request_Buffer        Buffer we use for data coming from higher layer
 *        Data_Request_Memory_Object        Memory object used for data transmission
 *        Data_Request_Length        Length of packet from higher layer
 *        Data_Request_Offset        Current offset into packet.  Maintains current
 *                                position as we send to lower layer.
 *        Data_Indication_Buffer    Buffer we use for data coming from lower layer
 *        Data_Indication_Length    Length of packet
 *        Data_Indication_Ready    Flag indicating that packet is ready to send up
 *
 *        Framer            -        Address of packet framer object
 *        CRC                -        Address of crc generator and checker
 *
 *        Decode_In_Progress        Flag telling us if we are in the middle of a
 *                                packet
 *        CRC_Size        -        Number of bytes in the CRC
 *        Disconnect        -        TRUE if a disconnect is pending
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "mplex.h"


/*
 *    Multiplexer::Multiplexer (
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                identifier,
 *                USHORT                message_base,
 *                PPacketFrame        framer,
 *                PCRC                crc,
 *                BOOL *            initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initializes the Q922 multiplexer.
 */
Multiplexer::Multiplexer
(
    T123               *owner_object,
    ComPort            *comport, // lower layer
    PhysicalHandle      physical_handle,
    USHORT              message_base,
    PPacketFrame        framer,
    PCRC                crc,
    BOOL               *initialized
)
:
    Q922_Layers(TRANSPORT_HASHING_BUCKETS)
{
    TRACE_OUT(("Multiplexer::Multiplexer"));

    USHORT                overhead;
    ProtocolLayerError    error;
    USHORT                lower_layer_prepend;
    USHORT                lower_layer_append;

    *initialized = TRUE;

    m_pT123 = owner_object;
    m_pComPort = comport;
    m_hCommLink = physical_handle;
    m_nMsgBase = message_base;
    Framer = framer;
    CRC = crc;
    CRC_Size = 0;

    m_pComPort->GetParameters(
                    &Maximum_Packet_Size,
                    &lower_layer_prepend,
                    &lower_layer_append);

    if (Maximum_Packet_Size == 0xffff)
    {
         /*
         **    The lower layer is a stream device, base the higher maximum packet
         **    size on the Multiplexer max. packet size
         */
        Packet_Size = MULTIPLEXER_MAXIMUM_PACKET_SIZE;
        Maximum_Packet_Size = Packet_Size;

        if (CRC != NULL)
        {
            CRC -> GetOverhead (0, &CRC_Size);
            Maximum_Packet_Size += CRC_Size;
        }

        if (Framer != NULL)
            Framer -> GetOverhead (Maximum_Packet_Size, &Maximum_Packet_Size);
    }
    else
    {
         /*
         **    The lower layer is a packet device, determine the max. packet
         **    size of the higher layer.
         */
        overhead = 0;
        if (Framer != NULL)
            Framer -> GetOverhead (overhead, &overhead);

        if (CRC != NULL)
        {
            CRC -> GetOverhead (0, &CRC_Size);
            overhead += CRC_Size;
        }

        Packet_Size = Maximum_Packet_Size - overhead;
    }

    TRACE_OUT(("MPlex: max_packet = %d", Maximum_Packet_Size));

     /*
     **    Now we have to allocate a buffer for data going to the lower layer
     */
    if (Framer != NULL)
    {
        Data_Request_Buffer = (LPBYTE) LocalAlloc (LMEM_FIXED, Maximum_Packet_Size);
        Data_Indication_Buffer = (LPBYTE) LocalAlloc (LMEM_FIXED, Maximum_Packet_Size);
        if ((Data_Request_Buffer == NULL) ||
            (Data_Indication_Buffer == NULL))
        {
            *initialized = FALSE;
        }
    }

    Data_Request_Length = 0;
    Data_Request_Offset = 0;
    Data_Request_Memory_Object = NULL;

    Data_Indication_Length = 0;
    Data_Indication_Ready = FALSE;


    Decode_In_Progress = FALSE;
    Disconnect = FALSE;

     /*
     **    Register with the lower layer
     */
    error = m_pComPort->RegisterHigherLayer(
                            (ULONG_PTR) m_hCommLink,
                            NULL,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        TRACE_OUT(("Multiplexer: constructor:  Error registering with lower layer"));
    }
}


/*
 *    Multiplexer::~Multiplexer (void);
 *
 *    Public
 *
 *    Functional Description:
 *        Destructor
 */
Multiplexer::~Multiplexer (void)
{
    TRACE_OUT(("Multiplexer::~Multiplexer"));

    PMPlexStruct        lpmpStruct;
     /*
     **    Remove our reference from the lower layer
     */
    m_pComPort->RemoveHigherLayer((ULONG_PTR) m_hCommLink);

    if (Framer != NULL)
    {
        if (Data_Request_Buffer != NULL)
            LocalFree ((HLOCAL) Data_Request_Buffer);
        if (Data_Indication_Buffer != NULL)
            LocalFree ((HLOCAL) Data_Indication_Buffer);
    }
    else
    {
        if (Data_Request_Memory_Object != NULL)
        {
            if (Q922_Layers.find ((DWORD_PTR) Data_Request_DLCI, (PDWORD_PTR) &lpmpStruct))
                lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);
        }
    }

    Q922_Layers.reset();
    while (Q922_Layers.iterate((PDWORD_PTR) &lpmpStruct))
        delete lpmpStruct;

     /*
     **    Delete the Framer that was instantiated by the controller.
     */
    if (Framer != NULL)
        delete Framer;
    if (CRC != NULL)
        delete CRC;
}


/*
 *    MultiplexerError    Multiplexer::ConnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function simply notifies the higher layer that it is ready
 *        for operation
 */
MultiplexerError    Multiplexer::ConnectRequest (void)
{
    TRACE_OUT(("Multiplexer::ConnectRequest"));

    m_pT123->OwnerCallback(m_nMsgBase + NEW_CONNECTION);

     return (MULTIPLEXER_NO_ERROR);
}



/*
 *    MultiplexerError    Multiplexer::DisconnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes itself from the lower layer and notifies the
 *        owner.
 */
MultiplexerError    Multiplexer::DisconnectRequest (void)
{
    TRACE_OUT(("Multiplexer::DisconnectRequest"));

    if (Data_Request_Length == 0)
    {
        m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
    }
    Disconnect = TRUE;

    return (MULTIPLEXER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::PollReceiver (
 *                                        ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        If this function has a packet ready to send to a higher layer, it
 *        attempts to send it.
 */
ProtocolLayerError Multiplexer::PollReceiver(void)
{
    // TRACE_OUT(("Multiplexer::PollReceiver"));

    if (Data_Indication_Ready)
    {
        SendDataToHigherLayer (
            Data_Indication_Buffer,
            Data_Indication_Length);

        Data_Indication_Ready = FALSE;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::PollTransmitter (
 *                                        ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        If we have data to send to the lower layer, we attempt to send it.
 */
ProtocolLayerError    Multiplexer::PollTransmitter (
                                    ULONG_PTR,
                                    USHORT,
                                    USHORT *,
                                    USHORT *)
{
    // TRACE_OUT(("Multiplexer::PollTransmitter"));

    ULONG                bytes_accepted;
    HPUChar                packet_address;
    ProtocolLayerError    return_value = PROTOCOL_LAYER_NO_ERROR;

    if (Data_Request_Length != 0)
    {
        if (Framer != NULL)
        {
            m_pComPort->DataRequest(
                            (ULONG_PTR) m_hCommLink,
                            Data_Request_Buffer + Data_Request_Offset,
                            Data_Request_Length - Data_Request_Offset,
                            &bytes_accepted);
        }
        else
        {
            packet_address = (HPUChar) Data_Request_Memory_Object->GetPointer ();
            m_pComPort->DataRequest(
                            (ULONG_PTR) m_hCommLink,
                            ((LPBYTE) packet_address) + Data_Request_Offset,
                            Data_Request_Length - Data_Request_Offset,
                            &bytes_accepted);
        }

         /*
         **    If the lower layer has accepted all of the packet, reset
         **    our length and offset variables
         */
        if (bytes_accepted <=
            (ULONG) (Data_Request_Length - Data_Request_Offset))
        {
            Data_Request_Offset += (USHORT) bytes_accepted;
            if (Data_Request_Offset == Data_Request_Length)
            {
                Data_Request_Offset = 0;
                Data_Request_Length = 0;
                if (Framer == NULL)
                {
                    PMPlexStruct    lpmpStruct;

                     /*
                     **    Unlock the memory object so that it can be released
                     */

                    if (Q922_Layers.find ((DWORD_PTR) Data_Request_DLCI, (PDWORD_PTR) &lpmpStruct))
                        lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);

                    Data_Request_Memory_Object = NULL;
                }

                 /*
                 **    If the Disconnect is pending, issue the callback
                 */
                if (Disconnect)
                {
                    Disconnect = FALSE;
                    m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
                }
            }
        }
    }
    return (return_value);
}


/*
 *    ProtocolLayerError    Multiplexer::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        PMemoryManager    memory_manager,
 *                                        IProtocolLayer *    q922);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to register an identifier with a higher
 *        layer address.
 */
ProtocolLayerError    Multiplexer::RegisterHigherLayer (
                                    ULONG_PTR            identifier,
                                    PMemoryManager    memory_manager,
                                    IProtocolLayer *    q922)
{
    TRACE_OUT(("Multiplexer::RegisterHigherLayer"));

    DLCI            dlci;
    PMPlexStruct    lpmpStruct;

    dlci = (DLCI) identifier;

    if (Q922_Layers.find ((DWORD) dlci))
        return (PROTOCOL_LAYER_REGISTRATION_ERROR);

    lpmpStruct = new MPlexStruct;
    if (lpmpStruct != NULL)
    {
        Q922_Layers.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpmpStruct);
        lpmpStruct -> q922 = q922;
        lpmpStruct -> data_request_memory_manager = memory_manager;
    }
    else
    {
        return (PROTOCOL_LAYER_ERROR);
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::RemoveHigherLayer (
 *                                        ULONG    identifier);
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes the higher layer from our list
 */
ProtocolLayerError    Multiplexer::RemoveHigherLayer (
                                    ULONG_PTR    identifier)
{
    TRACE_OUT(("Multiplexer::RemoveHigherLayer"));

    DLCI            dlci;
    PMPlexStruct    lpmpStruct;

   dlci = (DLCI) identifier;

    if (Q922_Layers.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct) == FALSE)
        return (PROTOCOL_LAYER_REGISTRATION_ERROR);

    if (Data_Request_Memory_Object != NULL)
    {
        if (Data_Request_DLCI == dlci)
        {
             /*
             **    Unlock the memory object so that it can be released
             */
            lpmpStruct->data_request_memory_manager->UnlockMemory (Data_Request_Memory_Object);

            Data_Request_Offset = 0;
            Data_Request_Length = 0;
            Data_Request_Memory_Object = NULL;
        }
    }

    delete lpmpStruct;
    Q922_Layers.remove ((DWORD) dlci);

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    Multiplexer::GetParameters (
 *                                        ULONG,
 *                                        USHORT *    max_packet_size,
 *                                        USHORT *    prepend_bytes,
 *                                        USHORT *    append_bytes)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum packet size permitted by
 *        the higher layer.
 */
ProtocolLayerError    Multiplexer::GetParameters (
                                    USHORT *    max_packet_size,
                                    USHORT *    prepend_bytes,
                                    USHORT *    append_bytes)
{
    TRACE_OUT(("Multiplexer::GetParameters"));

    *max_packet_size = Packet_Size;
    *prepend_bytes = 0;
    *append_bytes = CRC_Size;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    MultiplexerError    Multiplexer::DataRequest (
 *                                         ULONG        identifier,
 *                                        PMemory        memory,
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes the packet passed in, runs it thru the framer and
 *        CRC, and passes it to the lower layer.
 */
ProtocolLayerError    Multiplexer::DataRequest (
                                    ULONG_PTR    identifier,
                                    PMemory        memory,
                                    PULong        bytes_accepted)
{
    TRACE_OUT(("Multiplexer::DataRequest"));

    USHORT        crc;
    USHORT        pending_data;
    HPUChar        packet_address;
    ULONG        length;
    USHORT        holding_data;
    USHORT        i;
    DLCI        dlci;
    PMPlexStruct lpmpStruct;

    dlci = (DLCI) identifier;

     /*
     **    Set bytes_accepted to 0
     */
    *bytes_accepted = 0;

    if (Data_Request_Length != 0)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    Get the address of the memory block
     */
    packet_address = (HPUChar) memory -> GetPointer ();
    length = memory -> GetLength ();

     /*
     **    Remove the CRC length from the total size of the packet.
     */
    length -= CRC_Size;

    if (length > Packet_Size)
    {
        TRACE_OUT(("MPLEX: DataRequest: Packet too big"));
        return (PROTOCOL_LAYER_PACKET_TOO_BIG);
    }

     /*
     **    Lock the memory object so that it won't be released
     */
    if (Q922_Layers.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct))
         lpmpStruct->data_request_memory_manager->LockMemory (memory);

    if (CRC != NULL)
    {
         /*
         **    Generate the CRC and put it at the end of the packet.
         */
        crc = (USHORT) CRC -> CRCGenerator (
                                (LPBYTE) packet_address, length);
        for (i=0; i<CRC_Size; i++)
            *(packet_address + length + i) = (crc >> (i * 8)) & 0xff;
    }

     /*
     **    Add the CRC size to the packet length.
     */
    length += CRC_Size;

    if (Framer != NULL)
    {
         /*
         **    Use the framer to encode the packet
         */
        Framer -> PacketEncode (
                    (LPBYTE) packet_address,
                    (USHORT) length,
                    Data_Request_Buffer,
                    Maximum_Packet_Size,
                    TRUE,
                    TRUE,
                    &Data_Request_Length);

         /*
         **    If we are using a framer, we can release the memory object
         **    right now.
         */
        lpmpStruct->data_request_memory_manager->UnlockMemory (memory);
        *bytes_accepted = length;
    }
    else
    {

         /*
         **    Save the memory object and the identifier
         */
        Data_Request_DLCI = (DLCI) dlci;
        Data_Request_Memory_Object = memory;
        Data_Request_Length = (USHORT) length;
        *bytes_accepted = length;
    }

     /*
     **    Attempt to send the packet to the lower layer
     */
    PollTransmitter (
        0,
        PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
        &pending_data,
        &holding_data);

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    MultiplexerError    Multiplexer::DataRequest (
 *                                        ULONG,
 *                                        LPBYTE
 *                                          ULONG
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes the packet passed in, runs it thru the framer and
 *        CRC, and passes it to the lower layer.
 */
ProtocolLayerError    Multiplexer::DataRequest (
                                    ULONG_PTR,
                                    LPBYTE,
                                    ULONG,
                                    PULong        bytes_accepted)
{
    *bytes_accepted = 0;
    return (PROTOCOL_LAYER_ERROR);
}



/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                          ULONG        length,
 *                                            PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has data
 *        ready for us.
 */
ProtocolLayerError    Multiplexer::DataIndication (
                                    LPBYTE    buffer_address,
                                    ULONG    length,
                                    PULong     bytes_accepted)
{
//    TRACE_OUT(("Multiplexer::DataIndication"));

    BOOL                process_packet = TRUE;
    USHORT                packet_size;

    LPBYTE                source_address;
    USHORT                source_length;

    LPBYTE                dest_address;
    USHORT                dest_length;
    PacketFrameError    return_value;
    BOOL                crc_valid;
    USHORT                bytes_processed;


    *bytes_accepted = 0;

    if (Framer == NULL)
    {
        *bytes_accepted = length;

         /*
         **    If the framer does NOT exist, the data is coming to us in packet
         **    format
         */
        if (CRC != NULL)
        {
            crc_valid = CRC -> CheckCRC (buffer_address, length);

            if (crc_valid == FALSE)
            {
                TRACE_OUT(("MPLEX: Invalid CRC"));
                return (PROTOCOL_LAYER_NO_ERROR);
            }
            length -= CRC_Size;
        }

        SendDataToHigherLayer (buffer_address, (USHORT) length);
    }
    else
    {
         /*
         **    A framer exists; the lower layer is giving us the data
         **    in a stream fashion
         */
        Data_Indication_Ready = FALSE;

        source_address = buffer_address;
        source_length = (USHORT) length;

        while (process_packet)
        {
            if (Decode_In_Progress)
            {
                dest_length = 0;
                dest_address = NULL;
            }
            else
            {
                dest_address = Data_Indication_Buffer;
                dest_length = Maximum_Packet_Size;
            }

             /*
             **    Pass the data to the framer to decode it.
             */
            return_value = Framer -> PacketDecode (
                                        source_address,
                                        source_length,
                                        dest_address,
                                        dest_length,
                                        &bytes_processed,
                                        &packet_size,
                                        Decode_In_Progress);

            source_address = NULL;

            switch (return_value)
            {
                case PACKET_FRAME_NO_ERROR:
                     /*
                     **    A complete packet was not found by the decoder
                     */
                    Decode_In_Progress = TRUE;
                    Data_Indication_Ready = FALSE;
                    process_packet = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_PACKET_DECODED:
                     /*
                     **    Complete packet found, check the CRC, and pass it to
                     **    the higher layer.
                     */
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;

                    if (CRC != NULL)
                    {
                        if (packet_size <= CRC_Size)
                            break;

                        crc_valid = CRC -> CheckCRC (
                                            Data_Indication_Buffer,
                                            packet_size);
                        if (crc_valid == FALSE)
                        {
                            TRACE_OUT(("MPLEX: Invalid CRC: packet_size = %d", packet_size));
                            break;
                        }
                        packet_size -= CRC_Size;
                    }

                    Data_Indication_Ready = TRUE;
                    Data_Indication_Length = packet_size;

                     /*
                     **    Send packet on up
                     */
                    PollReceiver();
                    break;

                case PACKET_FRAME_DEST_BUFFER_TOO_SMALL:
                     /*
                     **    The packet received is too big for our buffer.
                     **    This sometimes occurs if a trailing flag is lost
                     **    during transmission
                     */
                    TRACE_OUT(("PACKET_FRAME_DEST_BUFFER_TOO_SMALL"));
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_ILLEGAL_FLAG_FOUND:
                     /*
                     **    The packet received contained an illegal flag.
                     */
                    Decode_In_Progress = FALSE;
                    *bytes_accepted += bytes_processed;
                    break;

                case PACKET_FRAME_FATAL_ERROR:
                     /*
                     **    Incoming packets do not meet framer requirements.
                     **    Tell the owner object to break the link
                     */
                    m_pT123->OwnerCallback(m_nMsgBase + BROKEN_CONNECTION);
                    process_packet = FALSE;
                    break;

            }
        }
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    Multiplexer::SendDataToHigherLayer (
 *                            LPBYTE        buffer_address,
 *                            USHORT        length)
 *
 *    Functional Description
 *        This function is called to send a packet to the higher layer
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes in packet
 *
 *    Return Value
 *        TRUE     -    The packet was sent to the higher layer
 *        FALSE     -    The packet was NOT sent to the higher layer
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void Multiplexer::SendDataToHigherLayer (
                    LPBYTE    buffer_address,
                    USHORT    buffer_length)
{
    TRACE_OUT(("Multiplexer::SendDataToHigherLayer"));

    DLCI                dlci;
    ProtocolLayerError    error;
    IProtocolLayer *        q922;
    ULONG                bytes_accepted;
    PMPlexStruct        lpmpStruct;


     /*
     **    Find out who the packet is intended for
     */
    dlci = GetDLCI (buffer_address, buffer_length);

    if (Q922_Layers.find((DWORD_PTR) dlci, (PDWORD_PTR) &lpmpStruct))
    {
        q922 = lpmpStruct->q922;
        error = q922 -> DataIndication (
                            buffer_address,
                            buffer_length,
                            &bytes_accepted);

        if (error != PROTOCOL_LAYER_NO_ERROR)
        {
            ERROR_OUT(("Multiplexer: SendDataToHigherLayer: Error occured on data indication to %d", dlci));
        }
        else
        {
            if (bytes_accepted != 0)
            {
                if (bytes_accepted != buffer_length)
                {
                    ERROR_OUT((" Multiplexer: SendDataToHigherLayer:  Error: "
                        "The upper layer thinks he can accept partial packets!!!"));

                }
            }
        }
    }
    else
    {
         /*
         **    Packet can NOT be sent up, trash it.
         */
        WARNING_OUT(("MPLEX: PollReceiver: packet received with illegal DLCI = %d", dlci));
    }
    return;
}



/*
 *    DLCI    Multiplexer::GetDLCI (
 *                            LPBYTE    buffer_address,
 *                            USHORT    length)
 *
 *    Functional Description
 *        This function returns the dlci of the packet.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes in packet
 *
 *    Return Value
 *        dlci
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DLCI    Multiplexer::GetDLCI (
                        LPBYTE    buffer_address,
                        USHORT    buffer_size)
{
    DLCI    dlci;

    if (buffer_size < 2)
        return (ILLEGAL_DLCI);

    dlci = *(buffer_address + ADDRESS_BYTE_HIGH) & 0xfc;
    dlci <<= 2;
    dlci |= ((*(buffer_address + ADDRESS_BYTE_LOW) & 0xf0) >> 4);

    return (dlci);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <databeam.h>

extern "C"
{
    #include "t120.h"
}
#include <memtrack.h>
#include "iplgxprt.h"
#include "fsdiag2.h"
#include "slist2.h"
#include "hash2.h"
#include "object2.h"
#include "memory2.h"  // mcattprt.h needs it
#include "memmgr2.h"
#include "mcattprt.h"
#include "imst123.h"
#include "protocol.h"
#include "timer.h"
#include "framer.h"
#include "crc.h"
#include "random.h"
#include <dllutil.h>


class CTransportInterface;
class TransportController;
class T123;
class CLayerX224;
class CLayerSCF;
class CLayerQ922;
class Multiplexer;
class ComPort;

#include "tprtcore.h"
#include "tprtintf.h"
#include "t123.h"
#include "comport.h"


extern HINSTANCE                   g_hDllInst;
extern CTransportInterface        *g_pTransportInterface;
extern CRITICAL_SECTION            g_csPSTN;
extern Timer                      *g_pSystemTimer;
extern TransportController        *g_pController;
extern HANDLE                      g_hWorkerThread;
extern DWORD                       g_dwWorkerThreadID;
extern HANDLE                      g_hWorkerThreadEvent;
extern HANDLE                      g_hThreadTerminateEvent;
extern DictionaryClass            *g_pComPortList2;
extern SListClass                 *g_pPSTNEventList;
extern TransportCallback           g_pfnT120Notify;
extern void                       *g_pUserData;
extern BOOL                        g_fEventListChanged;


// #undef TRACE_OUT
// #define TRACE_OUT WARNING_OUT


#endif /* _PRECOMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\object2.h ===
/*
 *    object.h
 *
 *    Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for class Object.  This class is the
 *        base class for every class in the MCS system.  It provides the
 *        behaviors that are common to all classes.
 *
 *        This class only three public member functions.  The first is a virtual
 *        destructor.  This destructor does nothing in this class, but it does
 *        virtualize the destructor for all of its descendants.  This allows
 *        an object to be deleted with a pointer to one of its base classes,
 *        while guaranteeing that all appropriate destructors get called.  This
 *        means that any object in the system can be deleted with a pointer to
 *        class Object (this is never really done).
 *
 *        The second member function is a routine that returns the name of the
 *        class.  This allows any object ask another object what the name of
 *        its class is, regardless what class of pointer the object has.  This
 *        could be used in diagnostics, for example.
 *
 *        The last common behavior is by far the most important.  This class
 *        defines a virtual function called OwnerCallback.  Since all classes
 *        in MCS inherit from this class, that means that any object in the
 *        system can potentially receive and process an OwnerCallback call.
 *
 *        Owner callbacks are used when it is necessary for an object to send
 *        messages to any object for which it doesn't know the public interface.
 *        This is most commonly the object that created it (the owner).  A good
 *        example of its use is this.  Object A creates object B.  Object B
 *        performs some operations in the system, and then determines that its
 *        work is through.  It needs to be deleted, but only object A can do that
 *        since it holds the reference to B (unless it has been passed to someone
 *        else).  Owner callbacks allows object B to send a message to object A
 *        asking to be deleted.  Class B does not have to know the public
 *        interface of class A for this to work.  It only has to know that class A
 *        inherits from class Object.
 *
 *        When a class needs to be able to send owner callbacks, these callbacks
 *        become part of the interface of the class.  In this way, these
 *        interfaces are really bi-directional.  They contain a class definition
 *        which defines what messages can be sent to an object of that class.
 *        The owner callbacks defined in the interface file show what messages
 *        can be sent from instances of the class.  When a decision is made for
 *        one class to use another, the using class needs to accept responsibility
 *        for handling any owner callbacks that the used class can generate.
 *
 *        When any class uses a class that can generate owner callbacks, the
 *        using class should override the OwnerCallback member function defined
 *        here.  Failure to handle owner callbacks that are issued by a child
 *        object is a serious design flaw.
 *
 *        This class contains a default implementation of the OwnerCallback
 *        member function.  This default implmentation merely prints an error
 *        reporting an unhandled owner callback.
 *
 *        The exact mechanics behind how the owner callbacks work is discussed
 *        below in the definition of the default handler.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James P. Galvin, Jr.
 */
#ifndef    _OBJECT2_H_
#define    _OBJECT2_H_

/*
 *    This is the class definition of class Object.
 */
class IObject
{
public:

    virtual ~IObject(void) = 0;

    virtual ULONG OwnerCallback(ULONG   message,
                                void   *parameter1 = NULL,
                                void   *parameter2 = NULL,
                                void   *parameter3 = NULL)
    {
        ERROR_OUT(("IObject::OwnerCallback: unattended owner callback"));
        return 0;
    };
};


/*
 *    virtual            ~Object ()
 *
 *    Functional Description:
 *        This is Object class destructor.  It does nothing.  Its purpose is to
 *        virtualize the destructor for all derived classes.  This insures that
 *        when an object is deleted, all proper destructors get executed.
 *
 *    Formal Parameters:
 *        None.
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    ULong        OwnerCallback (
 *                        UShort            message,
 *                        PVoid            parameter1,
 *                        ULong            parameter2)
 *
 *    Functional Description:
 *        This is the default implementation of the owner callback function.
 *        It does nothing except to report that an owner callback was not
 *        properly handled.  This should be seen as a very serious error.
 *        When any class expects to receive owner callbacks, it should override
 *        this function, and provide real behavior.
 *
 *    Formal Parameters:
 *        message
 *            This is the message to processed.  The messages that are valid are
 *            defined as part of the public interface of the class that is
 *            issuing the owner callbacks.  These messages normally range from
 *            0 to N-1 where N is the number of valid callbacks defined.  Note
 *            that when a class needs to be able to issue owner callbacks, it
 *            is given two parameters defining the recipient.  The first is a
 *            pointer to the object (POwnerObject, typedefed above).  The
 *            second is an owner message base.  This is an offset that the
 *            sending class adds to each message that it sends.  This allows
 *            one class to be the recipient of owner callbacks from more than
 *            one class without the messages stepping on one another.  The message
 *            base is simply set to be different for each child class.
 *        parameter1
 *        parameter2
 *            These parameters vary in meaning according to the message being
 *            processed.  The meaning of the parameters is defined in the
 *            interface file of the class issuing the callback.
 *
 *    Return Value:
 *        This is a 32-bit value whose meaning varies acording to the message
 *        being processed.  As with the parameters above, the meaning of the
 *        return value is defined in the interface file of the class that is
 *        issuing the callback.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    ULong        OwnerCallback (
 *                        UShort            message,
 *                        ULong            parameter1,
 *                        ULong            parameter2,
 *                        PVoid            parameter3)
 *
 *    Functional Description:
 *        This is the default implementation of the owner callback function.
 *        It does nothing except to report that an owner callback was not
 *        properly handled.  This should be seen as a very serious error.
 *        When any class expects to receive owner callbacks, it should override
 *        this function, and provide real behavior.
 *
 *        This function has 4 total parameters.  It differs from the other
 *        OwnerCallback function by the number of parameters it takes.  This
 *        alternative function was added because the other OwnerCallback()
 *        function did not allow enough parameter space.  Usually, in a project
 *        you will decide to use either this OwnerCallback() or the other, but
 *        not both.
 *
 *    Formal Parameters:
 *        message
 *            This is the message to processed.  The messages that are valid are
 *            defined as part of the public interface of the class that is
 *            issuing the owner callbacks.  These messages normally range from
 *            0 to N-1 where N is the number of valid callbacks defined.  Note
 *            that when a class needs to be able to issue owner callbacks, it
 *            is given two parameters defining the recipient.  The first is a
 *            pointer to the object (POwnerObject, typedefed above).  The
 *            second is an owner message base.  This is an offset that the
 *            sending class adds to each message that it sends.  This allows
 *            one class to be the recipient of owner callbacks from more than
 *            one class without the messages stepping on one another.  The message
 *            base is simply set to be different for each child class.
 *        parameter1
 *        parameter2
 *        parameter3
 *            These parameters vary in meaning according to the message being
 *            processed.  The meaning of the parameters is defined in the
 *            interface file of the class issuing the callback.
 *
 *    Return Value:
 *        This is a 32-bit value whose meaning varies acording to the message
 *        being processed.  As with the parameters above, the meaning of the
 *        return value is defined in the interface file of the class that is
 *        issuing the callback.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\pstnfram.h ===
/*    PSTNFram.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This function encodes and decodes functions according to the encoding
 *        rules set by the T.123 communications standard for PSTN.  The standard
 *        states that a flag will precede each packet and a flag will be appended 
 *        to the end of each packet.  Therefore no flags are permitted in the body
 *        of the packet.  Flags are replaced by an ESCAPE sequence.  If an ESCAPE 
 *        byte is found in a packet, remove the ESCAPE, and negate the 6th bit of 
 *        the next byte.  
 *    
 *    Caveats:
 *        None
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _PSTN_FRAME_H_
#define _PSTN_FRAME_H_

#include "framer.h"

 /*
 **    Commonly used definitions
 */
#define FLAG                    0x7e
#define ESCAPE                  0x7d
#define COMPLEMENT_BIT          0x20
#define NEGATE_COMPLEMENT_BIT   0xdf


class PSTNFrame : public PacketFrame
{
public:

    PSTNFrame(void);
    virtual ~PSTNFrame(void);

        PacketFrameError    PacketEncode (
                                PUChar        source_address, 
                                UShort        source_length,
                                PUChar        dest_address,
                                UShort        dest_length,
                                DBBoolean    prepend_flag,
                                DBBoolean    append_flag,
                                PUShort        packet_size);
                                
        PacketFrameError    PacketDecode (
                                PUChar        source_address,
                                UShort        source_length,
                                PUChar        dest_address,
                                UShort        dest_length,
                                PUShort        bytes_accepted,
                                PUShort        packet_size,
                                DBBoolean    continue_packet);
        Void                GetOverhead (
                                UShort        original_packet_size,
                                PUShort        max_packet_size);


    private:
        PUChar        Source_Address;
        UShort        Source_Length;

        PUChar        Dest_Address;
        UShort        Dest_Length;

        UShort        Source_Byte_Count;
        UShort        Dest_Byte_Count;

        DBBoolean    Escape_Found;
        DBBoolean    First_Flag_Found;
};
typedef    PSTNFrame    *    PPSTNFrame;

#endif

/*    
 *    PSTNFrame::PSTNFrame (
 *                Void);
 *
 *    Functional Description
 *        This is the constructor for the PSTNFrame class.  It initializes all
 *        internal variables.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PSTNFrame::~PSTNFrame (
 *                    Void);
 *
 *    Functional Description
 *        This is the destructor for the PSTNFrame class.  It does nothing
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PSTNFrame::PacketEncode (
 *                                    PUChar        source_address, 
 *                                    UShort        source_length,
 *                                    PUChar        dest_address,
 *                                    UShort        dest_length,
 *                                    DBBoolean    prepend_flag,
 *                                    DBBoolean    append_flag,
 *                                    PUShort        packet_size);
 *                                    
 *
 *    Functional Description
 *        This function encodes the passed in buffer to meet the T.123 standard.
 *        
 *    Formal Parameters
 *        source_address    (i)    -    Address of the buffer to encode
 *        source_length    (i)    -    Length of the buffer to encode
 *        dest_address    (i)    -    Address of the destination buffer
 *        dest_length        (i)    -    Length of the destination buffer
 *        prepend_flag    (i)    -    DBBoolean that tells us whether or not to put
 *                                a flag at the beginning of the packet
 *        append_flag        (i)    -    DBBoolean that tells us whether or not to put
 *                                a flag at the end of the packet
 *        packet_size        (o)    -    We return this to the user to tell them the new
 *                                size of the packet
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error occured
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    The destination buffer passed
 *                                                in was too small
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    PacketFrameError    PSTNFrame::PacketDecode (
 *                                    PUChar        source_address,
 *                                    UShort        source_length,
 *                                    PUChar        dest_address,
 *                                    UShort        dest_length,
 *                                    PUShort        bytes_accepted,
 *                                    PUShort        packet_size,
 *                                    DBBoolean    continue_packet);
 *                                    
 *    Functional Description
 *        This function takes the input data and decodes it, looking for a
 *        T123 packet.  The user may have to call this function many times
 *        before a packet is pieced together.  If the user calls this function
 *        and and sets either soure_address or dest_address to NULL, it uses
 *        the addresses passed in, the last time this function was called.  If
 *        there is one source buffer to decode, the user can pass that address
 *        in the first time and continue calling the function with NULL as the
 *        source address until the buffer is exhausted.  The user will know the
 *        buffer is exhausted when the return code is simply PACKET_FRAME_NO_ERROR
 *        rather than PACKET_FRAME_PACKET_DECODED.
 *        
 *    Formal Parameters
 *        source_address    (i)    -    Address of the buffer to decode
 *        source_length    (i)    -    Length of the buffer to decode
 *        dest_address    (i)    -    Address of the destination buffer
 *        dest_length        (i)    -    Length of the destination buffer
 *        bytes_accepted    (o)    -    We return the number of source bytes processed
 *        packet_size        (o)    -    We return the size of the packet.  This is only
 *                                valid if the return code is 
 *                                PACKET_FRAME_PACKET_DECODED.
 *        continue_packet    (i)    -    DBBoolean, tells us if we should start by 
 *                                looking for the first flag.  If the user wants
 *                                to abort the current search, use this flag.
 *
 *    Return Value
 *        PACKET_FRAME_NO_ERROR                -    No error occured, source buffer
 *                                                exhausted
 *        PACKET_FRAME_DEST_BUFFER_TOO_SMALL    -    The destination buffer passed
 *                                                in was too small
 *        PACKET_FRAME_PACKET_DECODED            -    Decoding stopped, packet decoded
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    Void    PSTNFrame::GetOverhead (
 *                        UShort        original_packet_size,
 *                        PUShort        max_packet_size);
 *                                    
 *    Functional Description
 *        This function takes the original packet size and returns the maximum
 *        size of the packet after it has been encoded.  Worst case will be
 *        twice as big as it was with two flags.
 *        
 *    Formal Parameters
 *        original_packet_size    (i)    -    Self-explanatory
 *        max_packet_size            (o)    -    Worst case size of the packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\pstnfram.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	PSTNFram.cpp
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the PSTN Frame class.
 *
 *	Private Instance Variables:
 *		All of these variables are used for decoding a packet.
 *		
 *		Source_Address		-	Address of source buffer
 *		Source_Length		-	Length of source buffer
 *
 *		Dest_Address		-	Address of destination buffer
 *		Dest_Length			-	Length of destination buffer
 *
 *		Source_Byte_Count	-	Running Source byte count
 *		Dest_Byte_Count		-	Running Dest byte count
 *
 *		Escape_Found		-	TRUE if the last byte decoded was an ESCAPE
 *		First_Flag_Found	-	TRUE if the first flag has been found
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		James W. Lawwill
 */
#include "pstnfram.h"


/*
 *	PSTNFrame::PSTNFrame (void)
 *
 *	Public
 *
 *	Functional Description:
 *		PSTN Framer constructor.  Initializes internal variable
 */
PSTNFrame::PSTNFrame (void)
{
	Source_Address = NULL;
	Source_Length = 0;

	Dest_Address = NULL;
	Dest_Length = 0;

	Source_Byte_Count = 0;
	Dest_Byte_Count = 0;

	Escape_Found = FALSE;

	First_Flag_Found = FALSE;
}


/*
 *	PSTNFrame::~PSTNFrame(void)
 *
 *	Public
 *
 *	Functional Description:
 *		PSTN Framer destructor.  This routine does nothing
 */
PSTNFrame::~PSTNFrame (void)
{
}


/*
 *	PacketFrameError	PSTNFrame::PacketEncode (
 *									LPBYTE		source_address, 
 *									USHORT		source_length,
 *									LPBYTE		dest_address,
 *									USHORT		dest_length,
 *									BOOL    	prepend_flag,
 *									BOOL    	append_flag,
 *									USHORT *		packet_size)
 *
 *	Public
 *
 *	Functional Description:
 *		This function takes the passed in buffer and encodes it.
 */
PacketFrameError	PSTNFrame::PacketEncode (
								LPBYTE		source_address, 
								USHORT		source_length,
								LPBYTE		dest_address,
								USHORT		dest_length,
								BOOL    	prepend_flag,
								BOOL    	append_flag,
								USHORT *		packet_size)
{
	UChar				input_byte;
	USHORT				byte_count;
	PacketFrameError	return_value = PACKET_FRAME_NO_ERROR;


	 /*
	 **	If the prepend_flag is set, attach a flag to the dest buffer
	 */
	if (prepend_flag)
	{
		*(dest_address++) = FLAG;
		*packet_size = 1;
	}
	else
		*packet_size = 0;

	byte_count = 0;

	 /*
	 **	Go thru each byte looking for a FLAG or an ESCAPE, encode this 
	 **	properly.
	 */
	while ((byte_count < source_length) && 
			(return_value == PACKET_FRAME_NO_ERROR))
	{
		input_byte = *(source_address + byte_count);

		switch (input_byte)
		{
			case FLAG:
			case ESCAPE:
				 /*
				 **	If you find a FLAG or an ESCAPE, put an ESCAPE in the 
				 **	destination buffer and negate the 6th bit of the input_byte
				 **
				 */
				if (((*packet_size) + 2) > dest_length)
				{
					return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
					break;
				}
				*(dest_address++) = ESCAPE;
				*(dest_address++) = input_byte & NEGATE_COMPLEMENT_BIT;
				*packet_size = (*packet_size) +  2;
				break;

			default:
				if (((*packet_size) + 1) > dest_length)
				{
					return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
					break;
				}
				*(dest_address++) = input_byte;
				*packet_size = (*packet_size) +  1;
				break;
		}
		byte_count++;
	}

	 /*
	 **	Put a FLAG on the end of the packet
	 */
	if (append_flag)
	{
		*(dest_address++) = FLAG;
		*packet_size = (*packet_size) + 1;
	}

	return (return_value);
}


/*
 *	PacketFrameError	PSTNFrame::PacketDecode (
 *									LPBYTE		source_address, 
 *									USHORT		source_length,
 *									LPBYTE		dest_address,
 *									USHORT		dest_length,
 *									USHORT *		bytes_accepted,
 *									USHORT *		packet_size,
 *									BOOL    	continue_packet)
 *
 *	Public
 *
 *	Functional Description:
 *		This function decodes the input buffer looking for a packet.
 */
PacketFrameError	PSTNFrame::PacketDecode (
									LPBYTE		source_address, 
									USHORT		source_length,
									LPBYTE		dest_address,
									USHORT		dest_length,
									USHORT *		bytes_accepted,
									USHORT *		packet_size,
									BOOL    	continue_packet)
{
	UChar				input_byte;
	PacketFrameError	return_value = PACKET_FRAME_NO_ERROR;

	*bytes_accepted = 0;
	 /*
	 **	Source address is changing
	 */
	if (source_address != NULL)
	{
		Source_Address = source_address;
		Source_Length = source_length;
		Source_Byte_Count = 0;
	}

	 /*
	 **	Destination address is changing
	 */
	if (dest_address != NULL)
	{
		Dest_Address = dest_address;
		Dest_Length = dest_length;
		Dest_Byte_Count = 0;
	}

	 /*
	 **	Continue working on this packet?
	 */
	if (continue_packet == FALSE)
		Escape_Found = FALSE;

	if (First_Flag_Found == FALSE)
	{
		 /*
		 **	Go thru the input data looking for a starting flag
		 */
		while (Source_Byte_Count < Source_Length)
		{
			if (*(Source_Address + Source_Byte_Count) == FLAG)
			{
				First_Flag_Found = TRUE;
				Source_Byte_Count++;
				*bytes_accepted += 1;
				break;
			}

			Source_Byte_Count++;
			*bytes_accepted += 1;
		}
	}
	
	 /*
	 **	Go thru the input data stream looking for a FLAG or an ESCAPE
	 */
	while ((Source_Byte_Count < Source_Length) && 
			(return_value == PACKET_FRAME_NO_ERROR))
	{
		input_byte = *(Source_Address + Source_Byte_Count);

		if (input_byte == FLAG)
		{
			 /*
			 **	End of packet found
			 */
			Escape_Found = FALSE;
			Source_Byte_Count++;
			*bytes_accepted += 1;

			 /*
			 **	If we find a FLAG but the number of bytes in the dest buffer
			 **	is 0, consider it the first flag in the packet and continue.
			 */
			if (Dest_Byte_Count == 0)
				continue;
			else
			{
				 /*
				 **	End of packet found, set the packet size and break out
				 */
				Dest_Address = NULL;
				*packet_size = Dest_Byte_Count;
				return_value = PACKET_FRAME_PACKET_DECODED;
				break;
			}
		}

		 /*
		 **	If the last byte was an ESCAPE, complement the 6th bit of the input
		 **	byte and continue
		 */
		if (Escape_Found)
		{
			input_byte ^= COMPLEMENT_BIT;
			Escape_Found = FALSE;
		}
		else
		{	
			 /*
			 **	If the input byte is the ESCAPE, set the flag and continue.
			 */
			if (input_byte == ESCAPE)
			{
				Escape_Found = TRUE;
				Source_Byte_Count++;
				*bytes_accepted += 1;
				continue;
			}
		}

		 /*
		 **	Put the input byte into our buffer.
		 */
		if (Dest_Byte_Count < Dest_Length)
		{
			*(Dest_Address + Dest_Byte_Count) = input_byte;
			Dest_Byte_Count++;
		}
		else
		{
			First_Flag_Found = FALSE;
			return_value = PACKET_FRAME_DEST_BUFFER_TOO_SMALL;
		}

		Source_Byte_Count++;
		*bytes_accepted += 1;
	}

	return (return_value);
}


/*
 *	void	PSTNFrame::GetOverhead (
 *						USHORT	original_packet_size,
 *						USHORT *	max_packet_size)
 *
 *	Public
 *
 *	Functional Description:
 *		This function gives the user some idea of the overhead added by this
 *		process.
 */
void	PSTNFrame::GetOverhead (
						USHORT	original_packet_size,
						USHORT *	max_packet_size)
{	
	 /*
	 **	The overhead produced by this framer is 2 times the original packet
	 **	size plus 2 bytes for the flags
	 */
	*max_packet_size = (original_packet_size * 2) + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\protocol.h ===
/*    ProtocolLayer.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the base class and backbone of all of the layers
 *        in a Transport Stack.  This class provides a framework for the basic
 *        operations expected by a layer in a stack.  When all layers inherit
 *        from this class, they can be linked together and none of the layers
 *        needs to know who they are connected with.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#ifndef _PROTOCOL_LAYER_H_
#define _PROTOCOL_LAYER_H_


typedef LEGACY_HANDLE       LogicalHandle;
typedef PHYSICAL_HANDLE     PhysicalHandle;     // hCommLink


/*
 *  TransportPriority is passed in with the TConnectRequest() call.
 *  The user can set the priority of the logical connection.  Valid
 *  priorities are 0-14.
 */
typedef ULONG           TransportPriority;

#define DEFAULT_PSTN_CALL_CONTROL       PLUGXPRT_PSTN_CALL_CONTROL_PORT_HANDLE


typedef enum
{
    PROTOCOL_LAYER_NO_ERROR,
    PROTOCOL_LAYER_REGISTRATION_ERROR,
    PROTOCOL_LAYER_PACKET_TOO_BIG,
    PROTOCOL_LAYER_ERROR
}
    ProtocolLayerError;

 /*
 **    Message structure used by some classes to hold owner callback
 **    messages.  Sometimes they are processed at later times
 */
typedef struct
{
    ULONG    message;
    void    *parameter1;
    void    *parameter2;
    void    *parameter3;
}
    MessageStruct, * PMessageStruct;


 /*
 **    These values make up the data-to-transmit mask.  We need a way to
 **    let the layers know what type of data they can transmit.  The controller
 **    will pass a mask to the layer during the PollTransmitter() call that tells
 **    the layer if it can transmit CONTROL data, USER data, or both.  The layer
 **    will return a mask telling the controller if it needs to send more
 **    CONTROL or USER data.  It will also tell the controller if it sent any
 **    data during the call.
 */
#define PROTOCOL_CONTROL_DATA           0x01
#define PROTOCOL_USER_DATA              0x02
#define PROTOCOL_USER_DATA_ONE_PACKET   0x04
#define PROTOCOL_USER_DATA_TRANSMITTED  0x08

#define DEFAULT_PRIORITY                2

 /*
 **    Messages passed in owner callbacks
 */
typedef enum
{
    NEW_CONNECTION,
    BROKEN_CONNECTION,
    REQUEST_TRANSPORT_CONNECTION,

    TPRT_CONNECT_INDICATION,
    TPRT_CONNECT_CONFIRM,
    TPRT_DISCONNECT_REQUEST,
    TPRT_DISCONNECT_INDICATION,

    NETWORK_CONNECT_INDICATION,
    NETWORK_CONNECT_CONFIRM,
    NETWORK_DISCONNECT_INDICATION,

    DATALINK_ESTABLISH_INDICATION,
    DATALINK_ESTABLISH_CONFIRM,
    DATALINK_RELEASE_INDICATION,
    DATALINK_RELEASE_CONFIRM,

    T123_FATAL_ERROR,
    T123_STATUS_MESSAGE
}
    CallbackMessage;


class IProtocolLayer : public IObject
{
public:

    virtual    ProtocolLayerError    DataRequest (
                                        ULONG_PTR     identifier,
                                        LPBYTE        buffer_address,
                                        ULONG        length,
                                        PULong        bytes_accepted) = 0;
    virtual    ProtocolLayerError    DataRequest (
                                        ULONG_PTR     identifier,
                                        PMemory        memory,
                                        PULong        bytes_accepted) = 0;
    virtual    ProtocolLayerError    DataIndication (
                                        LPBYTE        buffer_address,
                                        ULONG        length,
                                        PULong         bytes_accepted) = 0;
    virtual    ProtocolLayerError    RegisterHigherLayer (
                                        ULONG_PTR     identifier,
                                        PMemoryManager    memory_manager,
                                        IProtocolLayer *    higher_layer) = 0;
    virtual    ProtocolLayerError    RemoveHigherLayer (
                                        ULONG_PTR     identifier) = 0;
    virtual    ProtocolLayerError    PollTransmitter (
                                        ULONG_PTR     identifier,
                                        USHORT        data_to_transmit,
                                        USHORT *        pending_data,
                                        USHORT *        holding_data) = 0;
    virtual    ProtocolLayerError    PollReceiver (void) = 0;
    virtual    ProtocolLayerError    GetParameters (
                                        USHORT *        max_packet_size,
                                        USHORT *        prepend_bytes,
                                        USHORT *        append_bytes) = 0;
    virtual    BOOL            PerformAutomaticDisconnect ()
                                    {
                                        return (TRUE);
                                    };
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataRequest (
 *                                        USHORT        identifier,
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted) = 0;
 *
 *    Functional Description
 *        This function is called by a higher layer to request data to be
 *        sent out.  The function returns the number of bytes accepted from
 *        the packet.  If the layer expects stream data layer, it can accept
 *        part of the packet.  If it is a packet layer, it MUST accept the
 *        full packet of none of the packet.
 *
 *    Formal Parameters
 *        identifier         - (i)    The identifying value of the higher layer
 *        buffer_address    - (i)    Address of the packet.
 *        length            - (i)    Length of the packet
 *        bytes_accepted    - (o)    Number of bytes accepted by the layer.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR            -    No error occured
 *        PROTOCOL_LAYER_ERROR            -    Generic error
 *        PROTOCOL_LAYER_PACKET_TOO_BIG    -    Packet too big
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataRequest (
 *                                        USHORT        identifier,
 *                                        PMemory        memory,
 *                                        PULong        bytes_accepted) = 0;
 *
 *    Functional Description
 *        This function is called by a higher layer to request data to be
 *        sent out.  The function returns the number of bytes accepted from
 *        the packet.  If the layer expects stream data layer, it can accept
 *        part of the packet.  If it is a packet layer, it MUST accept the
 *        full packet of none of the packet.  This function does not accept a
 *        buffer address, but it accepts a memory object.  This object holds the
 *        buffer address and the length.
 *
 *    Formal Parameters
 *        identifier         - (i)    The identifying value of the higher layer
 *        memory            - (i)    Address of memory object
 *        bytes_accepted    - (o)    Number of bytes accepted by the layer.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR            -    No error occured
 *        PROTOCOL_LAYER_ERROR            -    Generic error
 *        PROTOCOL_LAYER_PACKET_TOO_BIG    -    Packet too big
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    ProtocolLayer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::RegisterHigherLayer (
 *                                        USHORT            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocollLayer::RemoveHigherLayer (
 *                                            USHORT    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Illegal identifier
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::PollTransmitter (
 *                                        USHORT        identifier,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data);
 *
 *    Functional Description
 *        This function is called to give the layer a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Identifier to poll
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Multiplexer does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::PollReceiver (
 *                                        USHORT        identifier);
 *
 *    Functional Description
 *        This function is called to give the layer a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    ProtocolLayer::GetParameters (
 *                                        USHORT        identifier,
 *                                        USHORT *        max_packet_size);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    BOOL    ProtocolLayer::PerformAutomaticDisconnect (
 *                                void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can be used to avoid taking down DLCI0 when the number
 *        of logical connections handled by a particular stack goes to zero.
 *        This is a temporary fix that will probably change when the physical
 *        connection buildup process is handled out of band.
 *
 *    Formal Parameters
 *        none
 *
 *    Return Value
 *        TRUE -    The base class always returns TRUE.  This is the default way
 *                for a physical connection layer to work.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */


/*
 *    PChar    ProtocolLayer::GetIdentifier (
 *                            void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the identifier for the protocol layer.  If the
 *        layer does not override this call a NULL pointer will be returned.
 *
 *    Formal Parameters
 *        none
 *
 *    Return Value
 *        A pointer to the identifier of the protocol layer.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\q922.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Q922.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Q.922 Data Link protocol.
 *        Before diving into the code, it is recommended that you read the
 *        Q.922 protocol.
 *
 *    Private Instance Variables:
 *        m_pT123        -    Address of the owner of this object.  Used for
 *                                owner callbacks.
 *        m_pMultiplexer            -    Address of ProtocolLayer below Q922 in the
 *                                stack.
 *        Higher_Layer        -    Address of ProtocolLayer above Q922 in the
 *                                stack.
 *        m_nMsgBase        -    Message base used in owner callbacks.
 *        DLCI                -    DLCI used to identfy Q922 entities.
 *        Link_Originator        -    TRUE if we are the link originators.  If we are,
 *                                we sent out the first SABME packet.
 *        Maximum_Information_Size-
 *                                 Holds the maximum packet size that we support.
 *        SABME_Pending        -    TRUE if we need to initiate the link.
 *        Unnumbered_Acknowledge_Pending    -    TRUE if we need to send out an
 *                                            Unnumbered Ack. packet.  This is
 *                                            done in response to a SABME or DISC.
 *        DISC_Pending        -    TRUE if we need to send out a DISConnect packet.
 *        Unnumbered_PF_State    -    Holds the Poll/Final state of an unnumbered
 *                                 packet.
 *        Final_Packet        -    TRUE if the next Unnumbered Ack. sent out is
 *                                our final packet to transmit before notifying
 *                                the owner that the link is broken.
 *        Data_Indication_Size-    Number of data indication buffers available
 *        Data_Indication        -    Base address of data indication buffers
 *        Data_Indication_Head-    Head of data indication queue
 *        Data_Indication_Tail-    Tail of read data indication queue
 *        Data_Indication_Count-    Number of data indication buffers in use
 *
 *        Data_Request_Size             -    Number of data request buffers
 *        Data_Request_Total_Size      -    Number of data request buffers + maximum
 *                                        number of outstanding packets
 *        Data_Request                 -    Base address of data request buffers
 *        Data_Request_Head             -    Head of data request queue
 *        Data_Request_Tail             -    Tail of data request queue
 *        Data_Request_Count             -    Number of data request buffers in use
 *        Data_Request_Acknowledge_Tail-    Tail of the queue referring to packets
 *                                        that have been acknowledged
 *
 *        Supervisory_Write_Struct     -    Buffer used for supervisory packets
 *        Send_State_Variable            -    This is the sequence number that will
 *                                        be sent in the next information packet
 *                                        to uniquely identify the packet.  The
 *                                        number is between 0 and 127.
 *        Receive_State_Variable        -    Receive Sequence Number.  The expected
 *                                        sequence number of the next Information
 *                                        packet we receive
 *        Acknowledge_State_Variable    -    This is the sequence number that the
 *                                        remote site is expecting in our next
 *                                        information packet
 *        Own_Receiver_Busy            -    If our read buffers are full, we set
 *                                        this flag so that we send a Receiver
 *                                        Not Ready packet to the remote site
 *        Peer_Receiver_Busy            -    Remote site is not ready to receive
 *                                        Information packets
 *
 *        Command_Pending                -    When this flag is set to TRUE, we send
 *                                        a Supervisory/Command packet to the
 *                                        remote site.
 *
 *                                        We need to send a Supervisory/Command
 *                                        packet when our receiver is no longer
 *                                        busy.  This tells the remote site to
 *                                        resume sending Information packets to
 *                                        us.
 *        Poll_Pending                -    This flag tells us to send a Supervisory
 *                                        command to the remote location with the
 *                                        Poll flag set.  This tells the remote
 *                                        site to reply to this command
 *        Final_Pending                -    This flag is set when we need to reply
 *                                        to a remote command
 *        Acknowledge_Pending            -    This flag signals us to send a
 *                                        Supervisory/Response packet to the
 *                                        remote site.
 *        Reject_Pending                -    Signals us to send a Supervisory/
 *                                        Response packet to the remote site
 *                                        indicating that we missed a packet.
 *        Reject_Outstanding            -    Internal flag telling us that our Reject
 *                                        packet has been sent and don't send
 *                                        another one
 *        T200_Timeout                -    Timeout value.  If we send out a packet
 *                                        and expect a response, and T200_Timeout
 *                                        expires, we enter the TIMER_RECOVERY
 *                                        mode.
 *        T200_Handle                    -    Handle to timer event.
 *      T200_Active                    -    Flag that signals if T200 is running
 *        N200_Count                    -    Number of times T200 expires in a row
 *                                        without a response from the remote site.
 *
 *        T203_Timeout                -    Timeout value.  If we don't receive a
 *                                        packet from the remote site in T203
 *                                        time, we enter the TIMER_RECOVERY mode.
 *        T203_Handle                    -    Handle to timer event
 *      T203_Active                    -    Flag that signals if T203 is running.
 *        Maximum_T200_Timeouts        -    Maximum number of T200 timeouts before
 *                                        we consider the link unstable.
 *        Data_Link_Mode                -    Our mode of operation.
 *                                            MULTIPLE_FRAME_ESTABLISHED
 *                                            TIMER_RECOVERY
 *        Link_Stable                    -    Flag that indicates if our current
 *                                        connection is stable.  FALSE if the
 *                                        N200_Count == Maximum number of T200
 *                                        timeouts
 *        Receive_Sequence_Exception    -    Set if we receive an ILLEGAL sequence
 *                                        number
 *        Maximum_Outstanding_Packets    -    Maximum number of packets that we can
 *                                        have out on the line at a time.
 *        Outstanding_Packets            -    Actual number of packets outstanding
 *        Maximum_Outstanding_Bytes    -    Maximum number of bytes that can be
 *                                        on the line at any one time.  It is VERY
 *                                        important to note that using this as a
 *                                        limiting factor on transmission is NOT
 *                                        a protocol defined limit.  This was
 *                                        added to our Q922 because we had
 *                                        problems with some modems that were
 *                                        buffering our Tx data.  Some modems
 *                                        would buffer up to 4K of data.  This is
 *                                        unacceptable to us because our timeouts
 *                                        would expire before the data left the
 *                                        modem.  Using this parameter as a
 *                                        limiting factor validates our timer
 *                                        values.
 *        Outstanding_Bytes            -    Actual number of bytes on the line at
 *                                        the current time.
 *        Total_Retransmitted            -    Number of packets that have been
 *                                        retransmitted.
 *        Data_Request_Memory_Manager    -    Memory manager used for all DataRequests
 *        Lower_Layer_Prepend            -    Number of bytes prepended to each packet
 *                                        by the lower layer
 *        Lower_Layer_Append            -    Number of bytes appended to packet by
 *                                        the lower layer.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */

#include "q922.h"

/*
 *    CLayerQ922::CLayerQ922 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                identifier,
 *                BOOL                link_originator,
 *                USHORT                data_indication_queue_siz,
 *                USHORT                data_request_queue_size,
 *                USHORT                k_factor,
 *                USHORT                max_information_size,
 *                USHORT                t200,
 *                USHORT                call_control_type,
 *                USHORT                max_outstanding_bytes,
 *                PMemoryManager        memory_manager,
 *                BOOL *                initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerQ922 constructor.  This routine initializes all
 *        variables and allocates buffer space.
 */
CLayerQ922::CLayerQ922
(
    T123               *owner_object,
    Multiplexer        *pMux, // lower layer
    USHORT              message_base,
    USHORT              identifier,
    BOOL                link_originator,
    USHORT              data_indication_queue_size,
    USHORT              data_request_queue_size,
    USHORT              k_factor,
    USHORT              max_information_size,
    USHORT              t200,
    USHORT              max_outstanding_bytes,
    PMemoryManager      memory_manager,
    PLUGXPRT_PSTN_CALL_CONTROL call_control_type,
    PLUGXPRT_PARAMETERS *pParams,
    BOOL *              initialized
)
:
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pMultiplexer(pMux)
{
    TRACE_OUT(("CLayerQ922::CLayerQ922"));

    ProtocolLayerError    error;
    USHORT                packet_size;
    USHORT                i;

    DLCI = identifier;
    Link_Originator    = link_originator;

    Maximum_Outstanding_Packets = k_factor;
    T200_Timeout = t200;
    Maximum_Information_Size = max_information_size;
    Maximum_Outstanding_Bytes = max_outstanding_bytes;
    Data_Request_Memory_Manager = memory_manager;

    Higher_Layer = NULL;
    Data_Request = NULL;
    Data_Indication = NULL;
    Data_Indication_Buffer = NULL;
    *initialized = TRUE;

     /*
     **    Find the maximum packet size supported by the lower layer
     */
    m_pMultiplexer->GetParameters(
                    &packet_size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    if (Maximum_Information_Size > packet_size)
        Maximum_Information_Size = packet_size;

    TRACE_OUT(("Q922: DLCI %d: Max information Size = %d", DLCI, Maximum_Information_Size));

     /*
     **    Register with the lower layer
     */
    error = m_pMultiplexer->RegisterHigherLayer(
                            identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        *initialized = FALSE;
        ERROR_OUT(("Q922: DLCI %d: constructor:  Error registering with lower layer", DLCI));
    }

     /*
     **    Allocation of data indication buffers.  Allocate the prescribed number
     */
    Data_Indication_Size = data_indication_queue_size;
    Data_Indication =
        (PDataQueue) LocalAlloc (LMEM_FIXED, (sizeof (DataQueue) * Data_Indication_Size));
    if (Data_Indication != NULL)
    {
        Data_Indication_Buffer = (LPBYTE)
             LocalAlloc (LMEM_FIXED, Maximum_Information_Size * Data_Indication_Size);
        if (Data_Indication_Buffer != NULL)
        {
            for (i=0; i<Data_Indication_Size; i++)
            {
                (Data_Indication + i) -> buffer_address =
                    Data_Indication_Buffer + (i * Maximum_Information_Size);
                (Data_Indication + i) -> length = 0;
            }

        }
        else
            *initialized = FALSE;
    }
    else
        *initialized = FALSE;

     /*
     **    Allocation of data request buffers.  Allocate enough buffers for
     **    outstanding buffers as well as the buffers queued for delivery.
     */
    Data_Request_Size = data_request_queue_size;
    Data_Request_Total_Size = Data_Request_Size + Maximum_Outstanding_Packets;
    Data_Request = (PMemory *)
        LocalAlloc (LMEM_FIXED, (sizeof (PMemory) * Data_Request_Total_Size));
    if (Data_Request == NULL)
        *initialized = FALSE;

     /*
     **    Allocate one buffer for Supervisory data
     */
    T200_Active = FALSE;
    T203_Active = FALSE;

     /*
     **    These veriables need to be set to 0 before we call Reset().  Reset()
     **    will attempt to free any memory block that are in the Data_Request
     **    list.  Since we are just initializing and there aren't any memory
     **    blocks in the array, there aren't any to release.
     */
    Data_Request_Head = 0;
    Data_Request_Tail = 0;
    Data_Request_Count = 0;
    Data_Request_Acknowledge_Tail = 0;

    Reset ();

    T203_Timeout = (call_control_type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL) ?
                    DEFAULT_T203_COMM_TIMEOUT : DEFAULT_T203_TIMEOUT;
    Startup_Maximum_T200_Timeouts = DEFAULT_MAXIMUM_T200_TIMEOUTS;

    if (NULL != pParams)
    {
        if (PSTN_PARAM__MAX_T200_TIMEOUT_COUNT_IN_Q922 & pParams->dwFlags)
        {
            if (Startup_Maximum_T200_Timeouts <= pParams->cMaximumT200TimeoutsInQ922)
            {
                Startup_Maximum_T200_Timeouts = pParams->cMaximumT200TimeoutsInQ922;
            }
        }
        if (PSTN_PARAM__T203_TIMEOUT_IN_Q922 & pParams->dwFlags)
        {
            if (T203_Timeout <= pParams->nT203TimeoutInQ922)
            {
                T203_Timeout = pParams->nT203TimeoutInQ922;
            }
        }
    }

#if 0
    DWORD    dwSiz = 4;
    DWORD    valType = 0;
    HKEY    hkey;
    // If we are using null modem.
    if(call_control_type == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL)
    {
        //
        // Open the registry key that contains the configuration info for number of timeouts
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Conferencing\\Transports\\DIRCB\0", &hkey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkey, "nTimeouts\0", 0, &valType,
                         (LPBYTE)&Startup_Maximum_T200_Timeouts, &dwSiz) != ERROR_SUCCESS || Startup_Maximum_T200_Timeouts < DEFAULT_MAXIMUM_T200_TIMEOUTS)
            {
                Startup_Maximum_T200_Timeouts = DEFAULT_MAXIMUM_T200_TIMEOUTS;
            }
            RegCloseKey(hkey);
        }
    }
#endif

    Link_Maximum_T200_Timeouts = Startup_Maximum_T200_Timeouts;

    Maximum_T200_Timeouts = Startup_Maximum_T200_Timeouts;

     /*
     **    If I am the link originator, enter the AWAITING_ESTABLISHMENT mode and
     **    send out the SABME packet.
     */
    if (Link_Originator)
    {
        SABME_Pending = TRUE;
        Unnumbered_PF_State = UNNUMBERED_PF_SET;
        Data_Link_Mode = AWAITING_ESTABLISHMENT;
    }
    else
    {
         /*
         **    If we are not the link originator, enter the TEI_ASSIGNED mode and
         **    start the T203 timer, if we don't receive a packet in X seconds,
         **    abort the operation
         */
        Data_Link_Mode = TEI_ASSIGNED;
        SABME_Pending = FALSE;
        StartTimerT203 ();
    }

    if (*initialized == FALSE)
    {
        ERROR_OUT(("Q922: DLCI %d:  Init failed", DLCI));
    }

}


/*
 *    CLayerQ922::~CLayerQ922 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerQ922 destructor.  This routine cleans up the mess.
 */
CLayerQ922::~CLayerQ922(void)
{
    TRACE_OUT(("CLayerQ922::~CLayerQ922"));

    BOOL        queue_full;
    PMemory        memory;

    TRACE_OUT(("Q922: Destructor: DLCI = %d  Receive_Sequence_Exception = %d",
        DLCI, Receive_Sequence_Exception));
    TRACE_OUT(("Q922: Destructor: DLCI = %d  Receive_Sequence_Recovery = %d",
        DLCI, Receive_Sequence_Recovery));

    m_pMultiplexer->RemoveHigherLayer (DLCI);

    StopTimerT200 ();
    StopTimerT203 ();

    if (Data_Indication != NULL)
        LocalFree ((HLOCAL) Data_Indication);
    if (Data_Indication_Buffer != NULL)
        LocalFree ((HLOCAL) Data_Indication_Buffer);
    if (Data_Request != NULL)
    {
         /*
         **    Data_Request_Head is the head of the list,
         **    Data_Request_Acknowledge_Tail is the absolute tail of the list.
         **    If the list is full, Data_Request_Head equals
         **    Data_Request_Acknowledge_Tail.  Therefore, we have to check
         **    Data_Request_Count to see if it is full or empty.
         */
        if ((Data_Request_Head == Data_Request_Acknowledge_Tail) &&
            (Data_Request_Count != 0))
        {
            queue_full = TRUE;
        }
        else
            queue_full = FALSE;

         /*
         **    We have to unlock any memory blocks that are in use
         */
        while ((Data_Request_Head != Data_Request_Acknowledge_Tail) || queue_full)
        {
            memory = *(Data_Request + Data_Request_Acknowledge_Tail);

            Data_Request_Memory_Manager -> UnlockMemory (memory);

            if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
            {
                Data_Request_Acknowledge_Tail = 0;
            }

            if (queue_full)
            {
                queue_full = FALSE;
            }
        }
        LocalFree ((HLOCAL) Data_Request);
    }

}


/*
 *    CLayerQ922::Reset (void)
 *
 *    Functional Description:
 *        This function resets the link state variables.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::Reset (void)
{
    TRACE_OUT(("CLayerQ922::Reset"));

    BOOL        queue_full;
    PMemory        memory;

    Data_Indication_Head = 0;
    Data_Indication_Tail = 0;
    Data_Indication_Count = 0;

     /*
     **    Data_Request_Head is the head of the list,
     **    Data_Request_Acknowledge_Tail is the absolute tail of the list.
     **    If the list is full, Data_Request_Head equals
     **    Data_Request_Acknowledge_Tail.  Therefore, we have to check
     **    Data_Request_Count to see if it is full or empty.
     */
    if ((Data_Request_Head == Data_Request_Acknowledge_Tail) &&
        (Data_Request_Count != 0))
    {
        queue_full = TRUE;
    }
    else
        queue_full = FALSE;

     /*
     **    We have to unlock any memory blocks that are in use
     */
    while ((Data_Request_Head != Data_Request_Acknowledge_Tail) || queue_full)
    {
        memory = *(Data_Request + Data_Request_Acknowledge_Tail);

        Data_Request_Memory_Manager -> UnlockMemory (memory);

        if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
            Data_Request_Acknowledge_Tail = 0;

        if (queue_full)
        {
            queue_full = FALSE;
        }
    }

    Data_Request_Head = 0;
    Data_Request_Tail = 0;
    Data_Request_Count = 0;
    Data_Request_Acknowledge_Tail = 0;

    Outstanding_Packets = 0;
    Outstanding_Bytes = 0;
    Total_Retransmitted = 0;

    Send_State_Variable = 0;
    Receive_State_Variable = 0;
    Acknowledge_State_Variable = 0;

    Own_Receiver_Busy = FALSE;
    Peer_Receiver_Busy = FALSE;

    Command_Pending = FALSE;
    Poll_Pending = FALSE;
    Final_Pending = FALSE;
    Acknowledge_Pending = FALSE;
    Reject_Pending = FALSE;
    Reject_Outstanding = FALSE;

    SABME_Pending = FALSE;
    Frame_Reject_Pending = FALSE;
    Unnumbered_Acknowledge_Pending = FALSE;
    DISC_Pending = FALSE;
    Final_Packet = FALSE;
    Disconnected_Mode_Pending = FALSE;


    N200_Count = 0;
    Link_Stable = TRUE;

    Receive_Sequence_Exception = 0;
    Receive_Sequence_Recovery = 0;

    StopTimerT200 ();
    StopTimerT203 ();
}


/*
 *    DataLinkError    CLayerQ922::ReleaseRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function sets the necessary flags to terminate the link
 */
DataLinkError    CLayerQ922::ReleaseRequest (void)
{
    TRACE_OUT(("CLayerQ922::ReleaseRequest"));

    if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
        (Data_Link_Mode == TIMER_RECOVERY))
    {
         /*
         **    Queue up the DISC_Pending flag to send out a DISC packet
         */
        DISC_Pending = TRUE;
        Unnumbered_PF_State = UNNUMBERED_PF_SET;
        Data_Link_Mode = AWAITING_RELEASE;

        StopTimerT200 ();
        StopTimerT203 ();
    }
    else
    {
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                               (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
    }

    return (DATALINK_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataIndication (
 *                                LPBYTE        packet_address,
 *                                ULONG        buffer_size,
 *                                PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has a packet to
 *        pass to us.
 */
ProtocolLayerError    CLayerQ922::DataIndication (
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerQ922::DataIndication"));

    BOOL        packet_processed = TRUE;

     /*
     **    The packet MUST be at least UNNUMBERED_HEADER_SIZE or it is
     **    invalid
     */
    if (packet_length < UNNUMBERED_HEADER_SIZE)
    {
        *bytes_accepted = packet_length;
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    if (*(packet_address + CONTROL_BYTE_HIGH) & SUPERVISORY_FRAME_BIT)
    {
        if (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_FRAME_BIT)
        {
             /*
             **    This packet is an unnumbered packet
             */
            switch (*(packet_address + CONTROL_BYTE_HIGH) &
                        UNNUMBERED_COMMAND_MASK)
            {
                case SABME:
                    ProcessSABME (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case UNNUMBERED_ACKNOWLEDGE:
                    ProcessUnnumberedAcknowledge (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case FRAME_REJECT:
                    ProcessFrameReject (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case DISCONNECTED_MODE:
                    ProcessDisconnectMode (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                case DISC:
                    ProcessDISC (
                        packet_address,
                        (USHORT) packet_length);
                    break;

                default:
                    ERROR_OUT(("Q922: DLCI %d:  DataIndication: Illegal Packet: = %d",
                        DLCI, (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_COMMAND_MASK)));
                    break;
            }
        }
        else
        {
             /*
             **    It is only legal to process supervisory frames if we
             **    are in the MULTIPLE_FRAME_ESTABLISHED or TIMER_RECOVERY
             **    modes
             */
            if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
                (Data_Link_Mode == TIMER_RECOVERY))
            {
                switch (*(packet_address + CONTROL_BYTE_HIGH) &
                            SUPERVISORY_COMMAND_MASK)
                {
                    case RECEIVER_READY:
                        ProcessReceiverReady (
                            packet_address,
                            (USHORT) packet_length);
                        break;

                    case RECEIVER_NOT_READY:
                        ProcessReceiverNotReady (
                            packet_address,
                            (USHORT) packet_length);
                        break;

                    case REJECT:
                        ProcessReject (
                            packet_address,
                            (USHORT) packet_length);
                        break;
                }
            }
            else
            {
                ERROR_OUT(("Q922:  DLCI %d: Supervisory packet received in illegal DataLink Mode", DLCI));
#ifdef _MCATIPX
                if (Data_Link_Mode != AWAITING_RELEASE)
                {
                     /*
                     ** This is necessary on an IPX network to notify the remote
                     **    site that this unit is no longer in the conference.  If
                     **    the previous conference ended without going through the
                     **    proper disconnect sequence, the remote site may continue
                     **    to send frames to this site.  In which case, we need to
                     **    notify the remote site that the conference is no longer
                     **    active.  We are doing this by sending out a DISC frame.
                     **    The Q.921 specification does not address this situation.
                     */
                    DISC_Pending = TRUE;
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                }
#endif
            }
        }
    }
    else
    {
         /*
         **    It is only legal to process Information frames if we
         **    are in the MULTIPLE_FRAME_ESTABLISHED or TIMER_RECOVERY
         **    modes
         */
        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
            (Data_Link_Mode == TIMER_RECOVERY))
        {
            packet_processed = ProcessInformationFrame (
                                packet_address,
                                (USHORT) packet_length);
        }
        else
        {
            ERROR_OUT(("Q922:  DLCI %d: Information packet received in illegal DataLink Mode", DLCI));
#ifdef _MCATIPX
            if (Data_Link_Mode != AWAITING_RELEASE)
            {
                 /*
                 ** This is necessary on an IPX network to notify the remote
                 **    site that this unit is no longer in the conference.  If
                 **    the previous conference ended without going through the
                 **    proper disconnect sequence, the remote site may continue
                 **    to send frames to this site.  In which case, we need to
                 **    notify the remote site that the conference is no longer
                 **    active.  We are doing this by sending out a DISC frame.
                 **    The Q.921 specification does not address this situation.
                 */
                DISC_Pending = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
            }
#endif
        }
    }

     /*
     **    After we receive a packet we should start the T203 timer
     **    unless the T200 timer was started during the processing of
     **    the packet
     */
    if  (((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
        (Data_Link_Mode == TIMER_RECOVERY)) &&
        (T200_Active == FALSE) &&
        (DLCI == 0))
    {
        StartTimerT203 ();
    }

    if (packet_processed)
    {
        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
            (Data_Link_Mode == TIMER_RECOVERY))
        {
            N200_Count = 0;
        }
        *bytes_accepted = packet_length;
    }
    else
        *bytes_accepted = 0;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT    data_to_transmit,
 *                                    USHORT *    pending_data,
 *                                    USHORT *    holding_data);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to give us a chance to transmit packets.
 *        The data_to_transmit mask tells us which data to transmit, either
 *        control or user data.
 */
ProtocolLayerError    CLayerQ922::PollTransmitter (
                                ULONG_PTR,
                                USHORT    data_to_transmit,
                                USHORT *    pending_data,
                                USHORT *    holding_data)
{
    // TRACE_OUT(("CLayerQ922::PollTransmitter"));

    *pending_data = 0;

     /*
     **    If we are permitted to transmit data, call ProcessWriteQueue ()
     */
    if ((data_to_transmit & PROTOCOL_CONTROL_DATA) ||
        (data_to_transmit & PROTOCOL_USER_DATA))
    {
        ProcessWriteQueue (data_to_transmit);
    }

     /*
     **    We have to set the pending data variable to reflect which data
     **    we still need to send out
     */
    if (Data_Request_Count != 0)
        *pending_data |= PROTOCOL_USER_DATA;

    if (Poll_Pending || Final_Pending || Command_Pending ||
        (Reject_Pending && (Own_Receiver_Busy == FALSE)) ||
        Acknowledge_Pending || SABME_Pending ||
        Unnumbered_Acknowledge_Pending || Frame_Reject_Pending ||
        DISC_Pending)
    {
        *pending_data |= PROTOCOL_CONTROL_DATA;
    }

    *holding_data = Outstanding_Packets;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataRequest (
 *                                ULONG,
 *                                PMemory        memory,
 *                                PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the higher layer to send a packet to the
 *        remote site.
 */
ProtocolLayerError    CLayerQ922::DataRequest (
                                ULONG_PTR,
                                PMemory        memory,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerQ922::DataRequest"));

    PMemory   * data_request;
    USHORT        trash_word;
    ULONG        packet_length;
    ULONG        information_size;

    *bytes_accepted = 0;

    packet_length = memory -> GetLength ();

     /*
     **    Determine the actual information length
     */
    information_size =
        packet_length - Lower_Layer_Prepend -
        Lower_Layer_Append - DATALINK_PACKET_OVERHEAD;

     /*
     **    See if the information content is too big.
     */
    if (information_size > Maximum_Information_Size)
    {
        TRACE_OUT(("Q922: DLCI %d: DataRequest: Requested packet = %d, max = %d",
            DLCI, information_size, Maximum_Information_Size));
        return (PROTOCOL_LAYER_PACKET_TOO_BIG);
    }

    if (Data_Request_Count < Data_Request_Size)
    {
         /*
         **    Set write_queue to the correct location
         */
        data_request = Data_Request + Data_Request_Head;
        *data_request = memory;

         /*
         **    Lock the memory object so that it won't be released
         */
        Data_Request_Memory_Manager -> LockMemory (memory);
        if (++Data_Request_Head == Data_Request_Total_Size)
            Data_Request_Head = 0;
        Data_Request_Count++;

        *bytes_accepted = packet_length;

         /*
         **    If the higher layer got permission to send data to me, I will
         **    attempt to send it on out
         */
        PollTransmitter (
            0,
            PROTOCOL_USER_DATA | PROTOCOL_CONTROL_DATA,
            &trash_word,
            &trash_word);
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    DataLinkError    CLayerQ922::DataRequest (
 *                                ULONG,
 *                                PMemory        memory,
 *                                PULong        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the higher layer to send a packet to the
 *        remote site.  This type of data passing is NOT supported by this
 *        layer.
 */
ProtocolLayerError    CLayerQ922::DataRequest (
                                ULONG_PTR,
                                LPBYTE,
                                ULONG,
                                PULong    bytes_accepted)
{
    *bytes_accepted = 0;
    return (PROTOCOL_LAYER_ERROR);
}



/*
 *    ProtocolLayerError    CLayerQ922::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description
 *        This function is called to give us a chance to send packets to the
 *        higher layer
 */
ProtocolLayerError CLayerQ922::PollReceiver(void)
{
    ULONG        bytes_accepted;
    PDataQueue    data_indication;

     /*
     **    If I have any packet in my receive buffers that
     **    need to go to higher layers, send them now
     */
    while (Data_Indication_Count != 0)
    {
        data_indication = Data_Indication + Data_Indication_Tail;
        if (Higher_Layer == NULL)
            break;
        Higher_Layer -> DataIndication (
                            data_indication -> buffer_address,
                            data_indication -> length,
                            &bytes_accepted);

        if (bytes_accepted == (data_indication -> length))
        {
            if (++Data_Indication_Tail == Data_Indication_Size)
                Data_Indication_Tail = 0;
            Data_Indication_Count--;

             /*
             **    If we had been in a Receiver Busy mode, exit it
             */
            if (Own_Receiver_Busy)
            {
                Own_Receiver_Busy = FALSE;
                Command_Pending = TRUE;
            }
        }
        else
            break;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    void    CLayerQ922::ProcessWriteQueue (
 *                        USHORT    data_to_transmit)
 *
 *    Functional Description
 *        This function determines which type of data needs to be sent out, and
 *        sends it.
 *
 *    Formal Parameters
 *        data_to_transmit    (i)    -    Mask telling us which data is allowed to be
 *                                    transmitted
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessWriteQueue (
                    USHORT    data_to_transmit)
{
    // TRACE_OUT(("CLayerQ922::ProcessWriteQueue"));

    BOOL        continue_loop = TRUE;

    while (continue_loop)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_RELEASE:
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                if (SABME_Pending || DISC_Pending || Unnumbered_Acknowledge_Pending ||
                    Disconnected_Mode_Pending || Frame_Reject_Pending)
                {
                    continue_loop = TransmitUnnumberedFrame ();
                }
                else
                {
                    continue_loop = FALSE;
                }
                break;

            default:
                if (Poll_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (COMMAND_FRAME, PF_SET);
                }
                else if (Final_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_SET);
                }
                else if (Command_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (COMMAND_FRAME, PF_RESET);
                }
                else if (Reject_Pending && (Own_Receiver_Busy == FALSE))
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_RESET);
                }
                else if (Unnumbered_Acknowledge_Pending || Frame_Reject_Pending)
                {
                    continue_loop = TransmitUnnumberedFrame ();
                }
                else if ((data_to_transmit & PROTOCOL_USER_DATA) &&
                        (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) &&
                        (Data_Request_Count != 0) &&
                        (Outstanding_Packets < Maximum_Outstanding_Packets) &&
                        (Outstanding_Bytes < Maximum_Outstanding_Bytes) &&
                        (Peer_Receiver_Busy == FALSE))
                {
                    continue_loop = TransmitInformationFrame ();
                }
                else if (Acknowledge_Pending)
                {
                    continue_loop = TransmitSupervisoryFrame (RESPONSE_FRAME, PF_RESET);
                }
                else
                {
                    continue_loop = FALSE;
                }

                if (continue_loop)
                {
                    if ((T200_Active == FALSE) && (DLCI == 0))
                        StartTimerT203 ();
                }
                break;
        }
    }
}


/*
 *    BOOL        CLayerQ922::TransmitUnnumberedFrame ()
 *
 *    Functional Description
 *        This function builds an unnumbered packet and attempts to send it out.
 *        The only packets that can be sent by this function are SABME, DISC, and
 *        an Unnumbered Acknowledge.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE            -    If a packet was transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitUnnumberedFrame ()
{
    TRACE_OUT(("CLayerQ922::TransmitUnnumberedFrame"));

    LPBYTE        packet_address;
    UChar        command;
    ULONG        bytes_written;
    PMemory        memory;
    USHORT        total_length;
    UChar        frame_type;

     /*
     **    Use the Supervisory Buffer to transmit the packet
     */
    total_length = UNNUMBERED_HEADER_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);

    if (memory == NULL)
        return (FALSE);
    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    if (SABME_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting SABME", DLCI));
        command = SABME;
        frame_type = COMMAND_FRAME;
    }
    else if (DISC_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting DISC", DLCI));
        command = DISC;
        frame_type = COMMAND_FRAME;
    }
    else if (Unnumbered_Acknowledge_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting UNNUMBERED_ACKNOWLEDGE", DLCI));
        command = UNNUMBERED_ACKNOWLEDGE;
        frame_type = RESPONSE_FRAME;
    }
    else if (Disconnected_Mode_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting DISCONNECTED_MODE", DLCI));
        command = DISCONNECTED_MODE;
        frame_type = RESPONSE_FRAME;
    }
    else if (Frame_Reject_Pending)
    {
        TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Transmitting FRAME_REJECT", DLCI));
        command = FRAME_REJECT;
        frame_type = RESPONSE_FRAME;
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: TransmitUnnumberedFrame: Illegally called function", DLCI));
    }

     /*
     **    Assemble the packet for transmission
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | frame_type | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) =
        command | Unnumbered_PF_State | 0x03;

     /*
     **    Attempt to send the packet to the lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    Data_Request_Memory_Manager -> FreeMemory (memory);

    if (bytes_written == total_length)
    {
        if (SABME_Pending)
        {
             /*
             **    Start the T200 timer after the SABME has been sent
             */
            StartTimerT200 ();
            SABME_Pending = FALSE;
        }
        else if (DISC_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket DISC sent", DLCI));

             /*
             **    Start the T200 timer after the DISC has been sent
             */
            DISC_Pending = FALSE;
            StartTimerT200 ();
            Data_Link_Mode = AWAITING_RELEASE;
        }
        else if (Unnumbered_Acknowledge_Pending)
        {
            Unnumbered_Acknowledge_Pending = FALSE;

            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedAck ack sent", DLCI));

             /*
             **    An Unnumbered Ack packet can be sent in response to two packets,
             **    the SABME or DISC.  If it is in response to a DISC, the
             **    Final_Packet flag is set to TRUE.  Therefore, we need to notify
             **    the owner that the link is terminated.
             */
            if (Final_Packet)
            {
                Final_Packet = FALSE;
                TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedAck: Issuing Release Indication", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
            }
            else
            {
                 /*
                 **    Callback to the controller to let it know that the link is
                 **    established
                 */
                if ((Data_Link_Mode == TEI_ASSIGNED) ||
                    (Data_Link_Mode == AWAITING_ESTABLISHMENT))
                {
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_ESTABLISH_INDICATION,
                                           (void *) DLCI);
                    Maximum_T200_Timeouts = Link_Maximum_T200_Timeouts;

                    if (DLCI == 0)
                        StartTimerT203 ();
                }
                else if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) ||
                    (Data_Link_Mode == TIMER_RECOVERY))
                {
                    if (DLCI == 0)
                        StartTimerT203 ();
                }
            }
        }
        else if (Disconnected_Mode_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket Disconnected Mode sent", DLCI));
            Disconnected_Mode_Pending = FALSE;
        }
        else if (Frame_Reject_Pending)
        {
            TRACE_OUT(("Q922: DLCI %d: TransmitUnnumberedPacket Frame Reject sent", DLCI));
            Frame_Reject_Pending = FALSE;
            m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                   (void *) DLCI, (void *) DATALINK_RECEIVE_SEQUENCE_EXCEPTION);
        }
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::TransmitSupervisoryFrame (
 *                        UChar    frame_type,
 *                        UChar    poll_final_bit)
 *
 *    Functional Description
 *        This function builds a Supervisory frame based on the
 *        current state of the protocol and the passed-in parameters.
 *
 *    Formal Parameters
 *        frame_type        -    (i)        The frame type can be either COMMAND_FRAME
 *                                    or RESPONSE_FRAME
 *        poll_final_bit    -    (i)        This flag is set in the packet to signal
 *                                    the remote site to respond to this packet.
 *
 *    Return Value
 *        TRUE            -    If a packet was actually transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitSupervisoryFrame (
                        UChar    frame_type,
                        UChar    poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame"));

    LPBYTE        packet_address;
    UChar        command;
    ULONG        bytes_written;
    USHORT        total_length;
    PMemory        memory;

     /*
     **    Transmit the packet using the Supervisory buffer
     */
    total_length = DATALINK_PACKET_OVERHEAD + Lower_Layer_Prepend +
                    Lower_Layer_Append;

     /*
     **    Get a memory object from the memory manager
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return (FALSE);
    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    if (Own_Receiver_Busy)
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: RECEIVER_NOT_READY"));
        command = RECEIVER_NOT_READY;
    }
    else if (Reject_Pending)
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: REJECT"));
        command = REJECT;
    }
    else
    {
        TRACE_OUT(("CLayerQ922::TransmitSupervisoryFrame: RECEIVER_READY"));
        command = RECEIVER_READY;
    }

     /*
     **    Set up the header including the Receive_State_Variable which
     **    indicates the next packet we expect to receive.
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | frame_type | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) = CONTROL_MSB | command;
    *(packet_address + CONTROL_BYTE_LOW) =
        (Receive_State_Variable << 1) | poll_final_bit;

     /*
     **    Send the packet to the lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    Data_Request_Memory_Manager -> FreeMemory (memory);

    if (bytes_written == total_length)
    {

        if (command == REJECT)
            Reject_Pending = FALSE;

        if (frame_type == COMMAND_FRAME)
        {
            Command_Pending = FALSE;

            if (poll_final_bit == PF_SET)
            {
                Poll_Pending = FALSE;

                 /*
                 **    If we are currently in a TIMER_RECOVERY mode, we
                 **    need to continue to set the T200 timer to make sure
                 **    that they receive this packet.
                 */
                if (Data_Link_Mode == TIMER_RECOVERY)
                    StartTimerT200 ();
            }
        }
        else
        {
            if (poll_final_bit == PF_SET)
                Final_Pending = FALSE;
        }
        Acknowledge_Pending = FALSE;
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::TransmitInformationFrame (void)
 *
 *    Functional Description
 *        This function builds an Information frame from its data request buffer.
 *        If applicable, it starts the T200 timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRUE            -    If a packet was actually transmitted
 *        FALSE            -    If a packet was not transmitted
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::TransmitInformationFrame (void)
{
    TRACE_OUT(("CLayerQ922::TransmitInformationFrame"));

    PMemory     *    data_request;
    LPBYTE        packet_address;
    ULONG        total_length;
    PMemory        memory;
    ULONG        bytes_written;


     /*
     **    Get the address of the next memory object
     */
    data_request = Data_Request + Data_Request_Tail;
    memory = *data_request;
    packet_address = memory -> GetPointer ();
    total_length = memory -> GetLength ();
    packet_address += Lower_Layer_Prepend;

     /*
     **    Set up the packet header
     */
    *(packet_address + ADDRESS_BYTE_HIGH) =
        (ADDRESS_HIGH(DLCI)) | COMMAND_FRAME | ADDRESS_MSB;
    *(packet_address + ADDRESS_BYTE_LOW)  = (ADDRESS_LOW(DLCI)) | ADDRESS_LSB;
    *(packet_address + CONTROL_BYTE_HIGH) = (Send_State_Variable << 1);
    *(packet_address + CONTROL_BYTE_LOW) = (Receive_State_Variable << 1);

     /*
     **    Send packet to lower layer
     */
    m_pMultiplexer->DataRequest(DLCI, memory, (PULong) &bytes_written);
    if (bytes_written == total_length)
    {
        if (++Data_Request_Tail == Data_Request_Total_Size)
            Data_Request_Tail = 0;
        Data_Request_Count--;

        Outstanding_Packets++;
        Outstanding_Bytes += (USHORT) total_length;

         /*
         **    If this is the packet that the remote site is expecting,
         **    start the T200 timeout.
         */
        if (Send_State_Variable == Acknowledge_State_Variable)
            StartTimerT200 ();
        Send_State_Variable = ((Send_State_Variable + 1) % SEQUENCE_MODULUS);

        Acknowledge_Pending = FALSE;
        return (TRUE);
    }
    else
        return (FALSE);
}


/*
 *    void    CLayerQ922::ProcessSABME (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes the SABME packet received from the remote
 *        site.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        Puts us in AWAITING_ESTABLISHMENT mode
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessSABME (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessSABME"));

    BOOL            command_frame;
    BOOL            poll_final_bit;
    USHORT            status;

    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: SABME received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address,
                &command_frame,
                &poll_final_bit);

     /*
     **    The SABME packet can ONLY be a COMMAND, it can not be a RESPONSE
     */
    if (command_frame == FALSE)
    {
        TRACE_OUT(("Q922: DLCI %d: SABME RESPONSE received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                 /*
                 **    If we are already in this mode, remain here and respond with
                 **    an unnumbered ack packet.
                 */
                Reset ();
                Unnumbered_Acknowledge_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                if (Send_State_Variable == Acknowledge_State_Variable)
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessSABME: in MULTIPLE_FRAME mode: Able to recover", DLCI));
                    Send_State_Variable = 0;
                    Receive_State_Variable = 0;
                    Acknowledge_State_Variable = 0;
                    StopTimerT200 ();

                    Unnumbered_Acknowledge_Pending = TRUE;
                    if (poll_final_bit)
                        Unnumbered_PF_State = UNNUMBERED_PF_SET;
                    else
                        Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                }
                else
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessSABME: Illegal packet mode = %d", DLCI, Data_Link_Mode));
                    Data_Link_Mode = TEI_ASSIGNED;
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                           (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                }
                break;

            case AWAITING_RELEASE:
                Disconnected_Mode_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessUnnumberAcknowledge (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes an unnumbered acknowledge packet.  This packet is
 *        received in response to a SABME or DISC packet that we sent out.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessUnnumberedAcknowledge (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessUnnumberedAcknowledge"));

    BOOL            command_frame;
    BOOL            poll_final_bit;
    ULONG_PTR            disconnect_reason;
    USHORT            status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        ERROR_OUT(("Q922: DLCI %d: Unnumbered ACK received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address,
                &command_frame,
                &poll_final_bit);

     /*
     **    Unnumbered Ack packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        ERROR_OUT(("Q922: DLCI %d: Unnumbered Ack COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_ESTABLISHMENT:
                if (poll_final_bit)
                {
                     /*
                     **    If we are awaiting establishment and we receive a UA
                     **    to our SABME, enter the MULTIPLE_FRAME_ESTABLISHED mode.
                     */
                    Reset ();
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                    Maximum_T200_Timeouts = Link_Maximum_T200_Timeouts;

                    StopTimerT200 ();
                    if (DLCI == 0)
                        StartTimerT203 ();

                     /*
                     **    Callback to the controller
                     */
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_ESTABLISH_CONFIRM,
                                           (void *) DLCI);
                }
                break;

            case AWAITING_RELEASE:
                if (Unnumbered_Acknowledge_Pending == FALSE)
                {
                    TRACE_OUT(("Q922: DLCI %d: ProcessUnnumberedAck: Issuing Release Indication", DLCI));
                    if (Receive_Sequence_Exception != 0)
                        disconnect_reason = DATALINK_RECEIVE_SEQUENCE_EXCEPTION;
                    else
                        disconnect_reason = DATALINK_NORMAL_DISCONNECT;

                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                                           (void *) DLCI, (void *) disconnect_reason);
                }
                StopTimerT200 ();
                break;

            case TEI_ASSIGNED:
                TRACE_OUT(("Q922: DLCI %d: Illegal Unnumbered Ack", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                WARNING_OUT(("Q922: DLCI %d: ProcessUnnumberedAcknowledge: Illegal packet", DLCI));
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessDisconnectMode (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes a Disconnect Mode packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessDisconnectMode (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessDisconnectMode"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: Unnumbered ACK received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    DM packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        TRACE_OUT(("Q922: DLCI %d: DM COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case AWAITING_ESTABLISHMENT:
                if (poll_final_bit && Link_Originator)
                {
                    Reset ();
                    Data_Link_Mode = TEI_ASSIGNED;

                    StopTimerT200 ();

                     /*
                     **    Callback to the controller
                     */
                    TRACE_OUT(("Q922: DLCI %d: ProcessDisconnectMode: Releasing connection", DLCI));
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                           (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
                }
                break;

            case AWAITING_RELEASE:
                if (poll_final_bit)
                {
                    Reset ();
                    Data_Link_Mode = TEI_ASSIGNED;

                    StopTimerT200 ();

                     /*
                     **    Callback to the controller
                     */
                    TRACE_OUT(("Q922: DLCI %d: ProcessDisconnectMode: A_R: Releasing connection", DLCI));
                    m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_CONFIRM,
                                           (void *) DLCI, (void *) DATALINK_NORMAL_DISCONNECT);
                }
                break;

            case TEI_ASSIGNED:
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                TRACE_OUT(("Q922: DLCI %d: ProcessDM:  Illegal packet", DLCI));
                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED, NULL);
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessDISC (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes a DISC packet.  We respond to this packet with
 *        an Unnumbered Ack packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessDISC (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessDISC"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != UNNUMBERED_HEADER_SIZE)
    {
        TRACE_OUT(("Q922: DLCI %d: DISC received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    TRACE_OUT(("Q922: DLCI %d:  DISCONNECT received", DLCI));
    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    The DISC packet can ONLY be a COMMAND, it can not be a RESPONSE
     */
    if (command_frame == FALSE)
    {
        TRACE_OUT(("Q922: DLCI %d: DISC RESPONSE received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
                Disconnected_Mode_Pending = TRUE;
                if (poll_final_bit)
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                else
                    Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case AWAITING_RELEASE:
                Unnumbered_Acknowledge_Pending = TRUE;
                Final_Packet = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;

            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                Unnumbered_Acknowledge_Pending = TRUE;
                Final_Packet = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_RESET;
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessFrameReject (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length);
 *
 *    Functional Description
 *        This function decodes the Frame Reject packet.  We currently don't fully
 *        support this packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessFrameReject (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessFrameReject"));

    BOOL        command_frame;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length < UNNUMBERED_HEADER_SIZE)
    {
        ERROR_OUT(("Q922: DLCI %d: Frame Reject received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParseUnnumberedPacketHeader (
                packet_address, &command_frame, &poll_final_bit);

     /*
     **    The FRMR packet can ONLY be a RESPONSE, it can not be a COMMAND
     */
    if (command_frame)
    {
        ERROR_OUT(("Q922: DLCI %d: FRMR COMMAND received: Illegal packet", DLCI));
        return;
    }

    if (status == DATALINK_NO_ERROR)
    {
        switch (Data_Link_Mode)
        {
            case TEI_ASSIGNED:
            case AWAITING_ESTABLISHMENT:
            case AWAITING_RELEASE:
            case MULTIPLE_FRAME_ESTABLISHED:
            case TIMER_RECOVERY:
                ERROR_OUT(("Q922: DLCI %d ProcessFrameReject:  Illegal packet", DLCI));

                m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                                       (void *) DLCI, (void *) DATALINK_ILLEGAL_PACKET_RECEIVED);
                break;
        }
    }
}


/*
 *    void    CLayerQ922::ProcessReceiverReady (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Ready packet that is in the
 *        input buffer.  From the packet, we get the packet sequence
 *        number that the remote site is expecting.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReceiverReady (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReceiverReady"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: Receiver Ready received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

        Peer_Receiver_Busy = FALSE;

         /*
         **    If the remote site is expecting a packet sequence number
         **    that is not equal to our Acknowledge_State_Variable,
         **    update it
         */
        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
        {
            if (Acknowledge_State_Variable != receive_sequence_number)
            {
                UpdateAcknowledgeState (receive_sequence_number);

                 /*
                 **    If we have received the last acknowledge,
                 **    stop the T200 timer
                 */
                if (Acknowledge_State_Variable == Send_State_Variable)
                    StopTimerT200 ();
                else
                    StartTimerT200 ();
            }
        }
        else
        {
             /*
             **    If we are in TIMER_RECOVERY mode, update the
             **    Acknowledge_State_Variable and resend the packets
             **    that need to be sent.
             */
            UpdateAcknowledgeState (receive_sequence_number);

            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StopTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessReceiverReady: Error Processing packet", DLCI));
    }
}


/*
 *    void    CLayerQ922::ProcessReceiverNotReady (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Not Ready packet that
 *        is in the input buffer.  This packet notifies us that the
 *        remote site does not have room for Information packets.
 *        As a result of this packet, we won't send any more packets
 *        until the remote site sends us a Receiver Ready packet.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReceiverNotReady (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReceiverNotReady"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        TRACE_OUT(("Q922: DLCI %d: Receiver Not Ready received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

         /*
         **    Set the Peer_Receiver_Busy flag so that we don't send
         **    out any information packets.
         */
        Peer_Receiver_Busy = TRUE;

        UpdateAcknowledgeState (receive_sequence_number);

        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
            StartTimerT200 ();
        else
        {
             /*
             **    If we are in TIMER_RECOVERY state, exit TIMER_RECOVERY
             **    state and update the acknowledge state.
             */
            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StartTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessNotReceiverReady: Error Processing packet", DLCI));
    }
}


/*
 *    void    CLayerQ922::ProcessReject (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function decodes the Receiver Reject packet that
 *        is in the input buffer.  This packet indicates that the
 *        remote site needs us to retransmit some packets.  It sends
 *        the next packet sequence number that it expects.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ProcessReject (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessReject"));

    BOOL        command_frame;
    UChar        receive_sequence_number;
    BOOL        poll_final_bit;
    USHORT        status;

     /*
     **    This packet MUST be the correct length or it is an error
     */
    if (packet_length != DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: REJECT received: Illegal packet length = %d", DLCI, packet_length));
        return;
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (command_frame && poll_final_bit)
        {
            Final_Pending = TRUE;
        }

        Peer_Receiver_Busy = FALSE;

         /*
         **    Update the Acknowledge_State_Variable and prepare to
         **    resend the packets that weren't acknowledged.
         */
        UpdateAcknowledgeState (receive_sequence_number);

        if (Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED)
        {
            ResetSendState ();

            StopTimerT200 ();
        }
        else
        {
            if ((command_frame == FALSE) && poll_final_bit)
            {
                ResetSendState ();

                StopTimerT200 ();

                if (Data_Link_Mode != AWAITING_RELEASE)
                    Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessReject: Error Processing packet", DLCI));
    }
}


/*
 *    BOOL        CLayerQ922::ProcessInformationFrame (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length)
 *
 *    Functional Description
 *        This function processes the information packet.  It checks
 *        to see if it has the expected sequence number.  If it does,
 *        it puts it into the queue which will be read by the user.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of packet
 *        packet_length    (i)    -    Length of packet
 *
 *    Return Value
 *        TRUE        -    If the packet was processed
 *        FALSE        -    If the packet was not processed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerQ922::ProcessInformationFrame (
                        LPBYTE    packet_address,
                        USHORT    packet_length)
{
    TRACE_OUT(("CLayerQ922::ProcessInformationFrame"));

    BOOL            command_frame;
    UChar            receive_sequence_number;
    BOOL            poll_final_bit;
    USHORT            status;
    PDataQueue        read_queue;
    UChar            send_sequence_number;

    BOOL            packet_accepted;
    ULONG            bytes_accepted;

    if (packet_length < DATALINK_PACKET_OVERHEAD)
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformationFrame: Invalid packet length = %d",
            DLCI, packet_length-DATALINK_PACKET_OVERHEAD));
        return (FALSE);
    }

    if (packet_length > (DATALINK_PACKET_OVERHEAD + Maximum_Information_Size))
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformationFrame:  Invalid information length = %d",
            DLCI, packet_length - DATALINK_PACKET_OVERHEAD));
        return (FALSE);
    }

     /*
     **    If there isn't a place to put the packet, return FALSE
     */
    if ((Data_Indication_Count == Data_Indication_Size) ||
        Own_Receiver_Busy || (Higher_Layer == NULL))
    {
        return (FALSE);
    }

    status = ParsePacketHeader (
                packet_address,
                packet_length,
                &command_frame,
                &receive_sequence_number,
                &poll_final_bit);

    if (status == DATALINK_NO_ERROR)
    {
        if (poll_final_bit && command_frame)
        {
            Final_Pending = TRUE;
        }

        if ((Data_Link_Mode == MULTIPLE_FRAME_ESTABLISHED) &&
                (Peer_Receiver_Busy == FALSE))
        {
             /*
             **    If the remote site does NOT acknowledge the last packet
             **    that we sent out, Update the Acknowledge State variable
             **    by calling UpdateAcknowledgeState()
             */
            if (Acknowledge_State_Variable != receive_sequence_number)
            {
                UpdateAcknowledgeState (receive_sequence_number);

                 /*
                 **    If the received acknowledge, reflects the last
                 **    packet transmitted, stop the T200 timer.
                 */
                if (Acknowledge_State_Variable == Send_State_Variable)
                    StopTimerT200 ();
                else
                    StartTimerT200 ();
            }
        }
        else
        {
             /*
             **    If this is an I-Frame RESPONSE, exit the TIMER_RECOVERY
             **    state
             */
            UpdateAcknowledgeState (receive_sequence_number);

            if ((Data_Link_Mode == TIMER_RECOVERY) && (command_frame == FALSE)
                && poll_final_bit)
            {
                ResetSendState();

                Data_Link_Mode = MULTIPLE_FRAME_ESTABLISHED;
                StopTimerT200 ();
            }
        }


        send_sequence_number = (*(packet_address + CONTROL_BYTE_HIGH) >> 1);

         /*
         **    If this is the packet that we are waiting for,
         **    give it to the Transport Layer.
         */
        if (send_sequence_number == Receive_State_Variable)
        {
             /*
             **    Try to send the packet to the higher layer,
             **    if it accepts it, we won't have to copy it.
             */
            packet_accepted = FALSE;
            if (Data_Indication_Count == 0)
            {
                Higher_Layer -> DataIndication (
                                packet_address + DATALINK_PACKET_OVERHEAD,
                                packet_length - DATALINK_PACKET_OVERHEAD,
                                &bytes_accepted);
                if (bytes_accepted ==
                    (ULONG) (packet_length - DATALINK_PACKET_OVERHEAD))
                {
                    packet_accepted = TRUE;
                }
            }

             /*
             **    If the higher layer did not accept it, copy it into our
             **    Data Indication queue.
             */
            if (packet_accepted == FALSE)
            {
                read_queue = Data_Indication + Data_Indication_Head;
                memcpy ((PVoid) read_queue->buffer_address,
                        (PVoid) (packet_address + DATALINK_PACKET_OVERHEAD),
                        packet_length - DATALINK_PACKET_OVERHEAD);
                read_queue->length = packet_length-DATALINK_PACKET_OVERHEAD;

                if (++Data_Indication_Head == Data_Indication_Size)
                    Data_Indication_Head = 0;
                if (++Data_Indication_Count == Data_Indication_Size)
                {
                    Own_Receiver_Busy = TRUE;
                    TRACE_OUT(("Q922: DLCI %d: Own Receiver Busy", DLCI));
                }
            }

            Receive_State_Variable =
                ((Receive_State_Variable + 1) % SEQUENCE_MODULUS);

            Acknowledge_Pending = TRUE;
            Reject_Outstanding = FALSE;
        }
        else
        {
             /*
             **    If we were not expecting this packet, send a REJECT
             **    packet to the remote site.
             */
            if (Reject_Outstanding == FALSE)
            {
                Reject_Pending = TRUE;
                Reject_Outstanding = TRUE;
            }
        }
    }
    else
    {
        ERROR_OUT(("Q922: DLCI %d: ProcessInformation: Error Processing packet", DLCI));
    }

    return (TRUE);
}


/*
 *    DataLinkError    CLayerQ922::ParsePacketHeader (
 *                                LPBYTE        packet_address,
 *                                USHORT        packet_length,
 *                                BOOL *        command_frame,
 *                                LPBYTE        receive_sequence_number,
 *                                BOOL *        poll_final_bit)
 *
 *    Functional Description
 *        This function decodes the packet header looking for three
 *        things:
 *
 *            1.  Is the packet a command frame?
 *            2.  What is the sequence number in the packet?
 *            3.  Does the packet require a respones?
 *
 *    Formal Parameters
 *        packet_address            -    (i)    Address of the new packet
 *        packet_length            -    (i)    Length of the new packet
 *        command_frame            -    (o)    Address of variable, it is set to TRUE
 *                                        if it is a COMMAND frame and FALSE if
 *                                        it is a RESPONSE frame
 *        receive_sequence_number    -    (o)    Address of variable, it holds the
 *                                        sequence number in the packet
 *        poll_final_bit            -    (o)    Address of variable, it is set to TRUE
 *                                        if we need to respond to the packet and
 *                                        FALSE if we don't
 *
 *    Return Value
 *        DATALINK_RECEIVE_SEQUENCE_VIOLATION    -
 *        DATALINK_NO_ERROR                    -
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DataLinkError    CLayerQ922::ParsePacketHeader (
                            LPBYTE        packet_address,
#ifdef _DEBUG
                            USHORT        packet_length,
#else
                            USHORT,
#endif
                            BOOL *        command_frame,
                            LPBYTE        receive_sequence_number,
                            BOOL *        poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::ParsePacketHeader"));

    DataLinkError    return_value = DATALINK_NO_ERROR;
    UChar            receive_sequence;
    UChar            send_state_sequence;

    if (*(packet_address + ADDRESS_BYTE_HIGH) & COMMAND_BIT)
        *command_frame = FALSE;
    else
        *command_frame = TRUE;

    *receive_sequence_number = (*(packet_address + CONTROL_BYTE_LOW) >> 1);

    if (*(packet_address + CONTROL_BYTE_LOW) & POLL_FINAL_BIT)
        *poll_final_bit = TRUE;
    else
        *poll_final_bit = FALSE;

    if (*receive_sequence_number < Acknowledge_State_Variable)
        receive_sequence = *receive_sequence_number + SEQUENCE_MODULUS;
    else
        receive_sequence = *receive_sequence_number;
    if (Send_State_Variable < Acknowledge_State_Variable)
        send_state_sequence = Send_State_Variable + SEQUENCE_MODULUS;
    else
        send_state_sequence = Send_State_Variable;

     /*
     **    Illegal Condition:  The remote site is acknowledging a
     **        packet that is not in the range of transmitted packets
     */
    if (receive_sequence > send_state_sequence)
    {
        TRACE_OUT(("Q922: DLCI %d: ParsePacketHeader:  Receive Sequence Exception: length = %d", DLCI, packet_length));
        TRACE_OUT(("Q922: ParsePacketHeader:  receive_sequence = %d", receive_sequence));
        TRACE_OUT(("Q922: ParsePacketHeader:  send_state_sequence = %d", send_state_sequence));
        TRACE_OUT(("Q922: ParsePacketHeader:  Acknowledge_State_Var = %d", Acknowledge_State_Variable));
        TRACE_OUT(("Q922: ParsePacketHeader:  Send_State_Variable = %d", Send_State_Variable));
        TRACE_OUT(("Q922: ParsePacketHeader: in-packet receive_sequence = %d", *receive_sequence_number));
        TRACE_OUT(("Q922: ParsePacketHeader: Data_Request_Count = %d", Data_Request_Count));

         /*
         **    The following piece of code checks the receive sequence number
         **    against our send state sequence number + the number of packets
         **    queued for transmission.  We are doing this to recover from one
         **    of two things:
         **
         **        1.  The T200 timeout value is not long enough.
         **        2.  This Q922 object is not able to check its input
         **            buffers quickly enough to respond to the remote site's
         **            command.  If the machine is overloaded with work to
         **            process, this error can occur.
         **
         **    We are checking to see if we are receiving an acknowledge
         **    for a packet that we have already transmitted once.  When we
         **    are in this out-of-sync state, it is possible to transmit an
         **    information packet, timeout, and receive a supervisory packet
         **    that does not acknowledge the last packet.  As a consequence,
         **    we reset our Send_State_Variable, so that we have no knowledge
         **    of transmitting the information packet.  We then may receive
         **    an acknowledge for the information packet, but we don't realize
         **    that we ever transmitted it.  This results in a Receive Sequence
         **    Exception.
         **
         **    To guard against this, we are checking to see if this acknowledge
         **    COULD be valid.  If it could be valid, we are processing it
         **    normally except for the receive sequence value.  We are setting
         **    the receive_sequence_number to that last good acknowledgement and
         **    we will eventually re-transmit the packet.  We also send up a
         **    warning to the node controller.
         **
         **    If the acknowledge is not possibly in our range of packets, we
         **    treat it as a real Receive Sequence Exception and break the link.
         */
        if (receive_sequence <= (send_state_sequence + Data_Request_Count))
        {
            *receive_sequence_number = Acknowledge_State_Variable;
            Receive_Sequence_Recovery++;

            TRACE_OUT(("Q922: ParsePacketHeader:  Attempting recovery from this exception"));
            TRACE_OUT(("Q922: ParsePacketHeader:  Recovery = %d", Receive_Sequence_Recovery));

             /*
             **    Let the user know that there is a problem
             */
            m_pT123->OwnerCallback(m_nMsgBase + T123_STATUS_MESSAGE,
                                   (void *) DLCI, (void *) DATALINK_TIMING_ERROR);
        }
        else
        {
            TRACE_OUT(("Q922: ParsePacketHeader:  CAN NOT recover from this exception"));
            Receive_Sequence_Exception++;
            DISC_Pending = TRUE;
            Unnumbered_PF_State = UNNUMBERED_PF_RESET;
            return_value = DATALINK_RECEIVE_SEQUENCE_VIOLATION;
        }
    }

    return (return_value);
}


/*
 *    DataLinkError    CLayerQ922::ParseUnnumberedPacketHeader (
 *                                BOOL *        command_frame,
 *                                LPBYTE        receive_sequence_number,
 *                                BOOL *        poll_final_bit)
 *
 *    Functional Description
 *        This function decodes the packet header looking for three
 *        things:
 *
 *            1.  Is the packet a command frame?
 *            2.  What is the sequence number in the packet?
 *            3.  Does the packet require a respone?
 *
 *    Formal Parameters
 *        command_frame            -    (o)    Address of variable, it is set to TRUE
 *                                        if it is a COMMAND frame and FALSE if
 *                                        it is a RESPONSE frame
 *        receive_sequence_number    -    (o)    Address of variable, it holds the
 *                                        sequence number in the packet
 *        poll_final_bit            -    (o)    Address of variable, it is set to TRUE
 *                                        if we need to respond to the packet and
 *                                        FALSE if we don't
 *
 *    Return Value
 *        DATALINK_RECEIVE_SEQUENCE_VIOLATION    -
 *        DATALINK_NO_ERROR                    -
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DataLinkError    CLayerQ922::ParseUnnumberedPacketHeader (
                            LPBYTE        packet_address,
                            BOOL *        command_frame,
                            BOOL *        poll_final_bit)
{
    TRACE_OUT(("CLayerQ922::ParseUnnumberedPacketHeader"));

    if (*(packet_address + ADDRESS_BYTE_HIGH) & COMMAND_BIT)
        *command_frame = FALSE;
    else
        *command_frame = TRUE;

    if (*(packet_address + CONTROL_BYTE_HIGH) & UNNUMBERED_PF_SET)
        *poll_final_bit = TRUE;
    else
        *poll_final_bit = FALSE;

    return (DATALINK_NO_ERROR);
}


/*
 *    void    CLayerQ922::UpdateAcknowledgeState (
 *                        UChar    sequence_number)
 *
 *    Functional Description
 *        This function updates Acknowledge_State_Variable.  The parameter
 *        passed in is the sequence number of a packet that the remote site has
 *        successfully received.  By receiving this sequence number, we can
 *        remove the packet from our write queue as well as any packet that
 *        was transmitted before that packet.
 *
 *    Formal Parameters
 *        sequence_number    -    (i)    Sequence number of packet successfully
 *                                received by the remote site.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::UpdateAcknowledgeState (
                    UChar    sequence_number)
{
    TRACE_OUT(("CLayerQ922::UpdateAcknowledgeState"));

    UChar        packets_acknowledged;
    USHORT        count;
    PMemory        memory;
    ULONG        total_length;

    if (Acknowledge_State_Variable != sequence_number)
    {
         /*
         **    Find the number of packets acknowledged by this sequence
         **    number.  If the remote site receives X packets successfully,
         **    the next time the remote site transmits, it will send out an
         **    acknowledge for the LAST packet received.  All packets
         **    received before it are acknowledged by default.
         */
        if (sequence_number < Acknowledge_State_Variable)
        {
            packets_acknowledged = ((sequence_number + SEQUENCE_MODULUS) -
                    Acknowledge_State_Variable);
        }
        else
        {
            packets_acknowledged =
                (sequence_number - Acknowledge_State_Variable);
        }

         /*
         **    Go thru each of the packets acknowledged and Unlock the memory
         **    object associated with it.  This will free the memory.
         */
        for (count=0; count < packets_acknowledged; count++)
        {
            memory = *(Data_Request + Data_Request_Acknowledge_Tail);
            total_length = memory -> GetLength ();

            Outstanding_Packets--;
            Outstanding_Bytes -= (USHORT) total_length;

            Data_Request_Memory_Manager -> UnlockMemory (memory);

            if (++Data_Request_Acknowledge_Tail == Data_Request_Total_Size)
                Data_Request_Acknowledge_Tail = 0;
        }

        Acknowledge_State_Variable = sequence_number;
    }
}


/*
 *    void    CLayerQ922::ResetSendState (void)
 *
 *    Functional Description
 *        This function is called when we need to retransmit packets.
 *        The Send_State_Variable is reset to equal the
 *        Acknowledge_State_Variable.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::ResetSendState (void)
{
    TRACE_OUT(("CLayerQ922::ResetSendState"));

     /*
     **    Reset the Send_State_Variable so that we resend packets.
     */
    if (Send_State_Variable != Acknowledge_State_Variable)
    {
        Total_Retransmitted += (DWORD) Outstanding_Packets;
        TRACE_OUT(("Q922: DLCI %d: retransmitting %d packets -- Total = %ld",
                DLCI, Outstanding_Packets, Total_Retransmitted));

        Data_Request_Tail = Data_Request_Acknowledge_Tail;
        Data_Request_Count += Outstanding_Packets;

        Outstanding_Packets = 0;
        Outstanding_Bytes = 0;

        Send_State_Variable = Acknowledge_State_Variable;
    }
}


/*
 *    void    CLayerQ922::StartTimerT200 (void)
 *
 *    Functional Description
 *        This function starts the T200 timer.  This timer us started when
 *        we send a packet and expect a response.  If the response is not
 *        received within the T200 time span.  The timer expires and we
 *        enter a TIMER_RECOVERY state.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StartTimerT200 (void)
{
    TRACE_OUT(("CLayerQ922::StartTimerT200"));

    if (T200_Active)
    {
        StopTimerT200 ();
    }

    if (T203_Active)
    {
        StopTimerT203 ();
    }

	if(g_pSystemTimer)
	{
		T200_Handle = g_pSystemTimer->CreateTimerEvent(T200_Timeout,
                                                   TIMER_EVENT_ONE_SHOT,
                                                   this,
                                                   (PTimerFunction) &CLayerQ922::T200Timeout);
	}

    T200_Active = TRUE;
}


/*
 *    void    CLayerQ922::StopTimerT200 (void)
 *
 *    Functional Description
 *        This function stops the T200 timer.  If we receive a response
 *        to a packet before the T200 timer expires, this function is
 *        called.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StopTimerT200 (void)
{
    TRACE_OUT(("CLayerQ922::StopTimerT200"));

    if (T200_Active)
    {
        if (g_pSystemTimer && g_pSystemTimer->DeleteTimerEvent(T200_Handle) != TIMER_NO_ERROR)
        {
            TRACE_OUT(("Q922: StopTimerT200: DLCI %d: Illegal Timer handle = %d", DLCI, T200_Handle));
        }
        T200_Active = FALSE;
    }
}


/*
 *    void    CLayerQ922::T200Timeout (
 *                        TimerEventHandle)
 *
 *    Functional Description
 *        This function is called by the timer class when the T200
 *        timer expires.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void CLayerQ922::T200Timeout(TimerEventHandle)
{
    TRACE_OUT(("CLayerQ922::T200Timeout"));

    BOOL send_disconnect = FALSE;

    T200_Active = FALSE;
    N200_Count++;

    TRACE_OUT(("Q922::T200Timeout: %d DLCI: Timer Recovery: N200_Count = %x", DLCI, N200_Count));

    if ((Maximum_T200_Timeouts != 0xffff) &&
        (N200_Count >= Maximum_T200_Timeouts))
    {
        Link_Stable = FALSE;
        send_disconnect = TRUE;
    }

    switch  (Data_Link_Mode)
     {
        case TEI_ASSIGNED:
            break;

        case AWAITING_ESTABLISHMENT:
            if (! Link_Stable)
            {
                break;
            }
            if (Link_Originator)
            {
                SABME_Pending = TRUE;
                Unnumbered_PF_State = UNNUMBERED_PF_SET;
            }
            break;

        case AWAITING_RELEASE:
            if (Final_Packet)
            {
                send_disconnect = TRUE;
            }
            else
            {
                if (! Link_Stable)
                {
                    send_disconnect = TRUE;
                }
                else
                {
                    DISC_Pending = TRUE;
                    Unnumbered_PF_State = UNNUMBERED_PF_SET;
                }
            }
            break;

        default:
            if (! Link_Stable)
            {
                TRACE_OUT(("Q922: DLCI %d T200 Timeout: Broken Connection", DLCI));
                Reset ();
                Data_Link_Mode = TEI_ASSIGNED;
            }
            else
            {
                Data_Link_Mode = TIMER_RECOVERY;
                Poll_Pending = TRUE;
                StartTimerT200 ();
            }
    }

     /*
     **    Notify the owner that the link is unstable
     */
    if (send_disconnect)
    {
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                               (void *) DLCI, (void *) DATALINK_REMOTE_SITE_TIMED_OUT);
    }
}


/*
 *    void    CLayerQ922::StartTimerT203 (void)
 *
 *    Functional Description
 *        This function starts the T203 timer.  This function is called
 *        when the T200 timer is not active.  The T203 timer expires
 *        when we don't receive a packet from the remote site in T203
 *        seconds.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StartTimerT203 (void)
{
    TRACE_OUT(("CLayerQ922::StartTimerT203"));

    if (T203_Timeout == 0)
    {
        return;
    }

    if (T203_Active)
    {
        StopTimerT203 ();
    }
	if(g_pSystemTimer)
	{
		T203_Handle = g_pSystemTimer->CreateTimerEvent(
                    T203_Timeout, TIMER_EVENT_ONE_SHOT, this,
                    (PTimerFunction) &CLayerQ922::T203Timeout);
	}

    T203_Active = TRUE;
}


/*
 *    void    CLayerQ922::StopTimerT203 (void)
 *
 *    Functional Description
 *        This function stops the T203 timer.  If we receive a packet
 *        while the T203 packet is active, this function is called.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::StopTimerT203 (void)
{
    TRACE_OUT(("CLayerQ922::StopTimerT203"));

    if (T203_Active && g_pSystemTimer)
    {
        g_pSystemTimer->DeleteTimerEvent(T203_Handle);
        T203_Active = FALSE;
    }
}


/*
 *    void    CLayerQ922::T203Timeout (
 *                        TimerEventHandle)
 *
 *    Functional Description
 *        This function is called by the timer class when the T203
 *        timer expires.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerQ922::T203Timeout (TimerEventHandle)
{
    TRACE_OUT(("CLayerQ922::T203Timeout"));

    T203_Active = FALSE;

    if (Data_Link_Mode == TEI_ASSIGNED)
    {
        TRACE_OUT(("Q922: DLCI %d: T203 Timeout: Releasing connection", DLCI));
        m_pT123->OwnerCallback(m_nMsgBase + DATALINK_RELEASE_INDICATION,
                               (void *) DLCI, (void *) DATALINK_REMOTE_SITE_TIMED_OUT);
        return;
    }

    StartTimerT200 ();

    Data_Link_Mode = TIMER_RECOVERY;
    Poll_Pending = TRUE;
}

/*
 *    ProtocolLayerError    CLayerQ922::GetParameters (
 *                                    USHORT,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum packet size permitted by
 *        the higher layer.
 */
ProtocolLayerError    CLayerQ922::GetParameters (
                                USHORT *    packet_size,
                                USHORT *    prepend,
                                USHORT *    append)
{
    TRACE_OUT(("CLayerQ922::GetParameters"));

    *prepend = DATALINK_PACKET_OVERHEAD + Lower_Layer_Prepend;
    *append = Lower_Layer_Append;
    *packet_size = Maximum_Information_Size;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
 *                                    USHORT,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to register an identifier with a higher
 *        layer address.
 */
ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
                                ULONG_PTR,
                                PMemoryManager,
                                IProtocolLayer *    higher_layer)
{
    TRACE_OUT(("CLayerQ922::RegisterHigherLayer"));

    Higher_Layer = higher_layer; // CLayerSCF or CLayerX224
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
 *                                    USHORT);
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes the higher layer from our list
 */
ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
                                ULONG_PTR)
{
    TRACE_OUT(("CLayerQ922::RemoveHigherLayer"));

    Higher_Layer = NULL;
    return (PROTOCOL_LAYER_NO_ERROR);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\scf.h ===
/*    SCF.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class represents the Network layer in the T.123 Transport stack.
 *        This layer communicates over the DataLink layer (DLCI 0).  It sends the
 *        necessary packets to start a connection.  It is also responsible for
 *        disconnecting the connection.
 *
 *        During arbitration of a connection, SCF arbitrates priority and DataLink
 *        parameters.  SCF instantiates a SCFCall object for each active logical
 *        connection.  Remotely initiated calls are placed in the
 *        Remote_Call_Reference array while locally initiated calls are kept in
 *        the Call_Reference array.
 *
 *        This class inherits from ProtocolLayer although it assumes that it does
 *        not have a higher layer to pass packets to.  The T.123 document is clear
 *        about that during the user data transmission, this layer has no purpose.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _SCF_H_
#define _SCF_H_

#include "q922.h"
#include "scfcall.h"

 /*
 **    SCF Errors
 */
typedef enum
{
    SCF_NO_ERROR,
    SCF_NO_SUCH_DLCI,
    SCF_CONNECTION_FULL,
    SCF_MEMORY_ALLOCATION_ERROR
}
    SCFError;


#define TRANSPORT_HASHING_BUCKETS   3

 /*
 **    Offsets into packet
 */
#define PROTOCOL_DISCRIMINATOR      0
#define LENGTH_CALL_REFERENCE       1
#define CALL_REFERENCE_VALUE        2

 /*
 **    Supported commands
 */
#define NO_PACKET               0x00
#define CONNECT                 0x07
#define CONNECT_ACKNOWLEDGE     0x0f
#define SETUP                   0x05
#define RELEASE_COMPLETE        0x5a

 /*
 **    Unsupported commands as stated by T.123
 */
#define RELEASE             0x4d
#define ALERTING            0x01
#define CALL_PROCEEDING     0x02
#define PROGRESS            0x03
#define DISCONNECT          0x45
#define SEGMENT             0x40
#define STATUS              0x5d
#define STATUS_ENQUIRY      0x55

 /*
 **    Packet Elements, not all of these are supported.
 */
#define BEARER_CAPABILITY               0x04
#define DLCI_ELEMENT                    0x19
#define END_TO_END_DELAY                0x42
#define LINK_LAYER_CORE_PARAMETERS      0x48
#define LINK_LAYER_PROTOCOL_PARAMETERS  0x49
#define X213_PRIORITY                   0x50
#define CALLING_PARTY_SUBADDRESS        0x6d
#define CALLED_PARTY_SUBADDRESS         0x71
#define CAUSE                           0x08

#define EXTENSION                       0x80

 /*
 **    Remote Call Reference
 */
#define REMOTE_CALL_REFERENCE           0x80

 /*
 **    Bearer Capability definitions
 */
#define CODING_STANDARD                     0
#define INFORMATION_TRANSFER_CAPABILITY     0x08
#define TRANSFER_MODE                       0x20
#define LAYER_2_IDENT                       0x40
#define USER_INFORMATION_LAYER_2            0x0e

 /*
 **    DLCI element
 */
#define PREFERRED_EXCLUSIVE         0x40

 /*
 **    Link Layer Core Parameters
 */
#define FMIF_SIZE                   0x09
#define THROUGHPUT                  0x0a
#define MINIMUM_THROUGHPUT          0x0b
#define COMMITTED_BURST_SIZE        0x0d
#define EXCESS_BURST_SIZE           0x0e

 /*
 **    Link Layer Protocol Parameters
 */
#define TRANSMIT_WINDOW_SIZE_IDENTIFIER     0x07
#define RETRANSMISSION_TIMER_IDENTIFIER     0x09

 /*
 **    Q.850 Error messages, these are the only 2 errors we currently support
 */
#define    REQUESTED_CHANNEL_UNAVAILABLE    0x2c
#define NORMAL_USER_DISCONNECT              0x1f

 /*
 **    Single Octet information elements
 */
#define    SINGLE_OCTET_ELEMENT_MASK        0x80
#define    Q931_PROTOCOL_DISCRIMINATOR      0x08
#define    CALL_REFERENCE_ORIGINATOR        0x80
#define    CALL_ORIGINATOR_MASK             0x7f

 /*
 **    T303 is the timeout allowed from the time we send the SETUP until we receive
 **    a response
 */
#define DEFAULT_T303_TIMEOUT            30000
 /*
 **    T313 is the timeout allowed from the time we send the CONNECT until we
 **    receive a response
 */
#define DEFAULT_T313_TIMEOUT            30000



class CLayerSCF : public IProtocolLayer
{
public:

    CLayerSCF(
        T123               *owner_object,
        CLayerQ922         *lower_layer,
        USHORT              message_base,
        USHORT              identifier,
        BOOL                link_originator,
        PDataLinkParameters datalink,
        PMemoryManager      memory_manager,
        BOOL *              initialized);

    virtual ~CLayerSCF(void);

    SCFError        ConnectRequest (
                        DLCI                dlci,
                        TransportPriority    priority);
    SCFError        DisconnectRequest (
                        DLCI    dlci);
    SCFError        ConnectResponse (
                        CallReference    call_reference,
                        DLCI            dlci,
                        BOOL        valid_dlci);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    dr_memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    identifier);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     identifier,
                            USHORT        data_to_transmit,
                            USHORT *        pending_data,
                            USHORT *        holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *        max_packet_size,
                            USHORT *        prepend,
                            USHORT *        append);

    ULONG OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

private:

    CallReference        GetNextCallReference (void);

    void                ProcessMessages (void);

private:

    DictionaryClass       Remote_Call_Reference;
    DictionaryClass       Call_Reference;
    DictionaryClass       DLCI_List;
    SListClass            Message_List;

    T123                 *m_pT123; // owner object
    CLayerQ922           *m_pQ922; // lower layer
    USHORT                m_nMsgBase;
    USHORT                Identifier;
    USHORT                Link_Originator;
    USHORT                Maximum_Packet_Size;
    DataLinkParameters    DataLink_Struct;
    PMemoryManager        Data_Request_Memory_Manager;
    USHORT                Lower_Layer_Prepend;
    USHORT                Lower_Layer_Append;
    USHORT                Call_Reference_Base;
};
typedef    CLayerSCF *        PSCF;

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    CLayerSCF::CLayerSCF (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            IProtocolLayer *        lower_layer,
 *            USHORT                message_base,
 *            USHORT                identifier,
 *            BOOL            link_originator,
 *            PChar                config_file,
 *            PDataLinkParameters    datalink,
 *            PMemoryManager        memory_manager,
 *            BOOL *            initialized);
 *
 *    Functional Description
 *        This is the constructor for the SCF Network layer.  It registers itself
 *        with the lower so that incoming data will be received properly.
 *
 *    Formal Parameters
 *        transport_resources    (i) -    Pointer to TransportResources structure.
 *        owner_object    (i) -    Address of the object that owns this object
 *        lower_layer        (i) -    Address of the layer below us.
 *        message_base    (i) -    Message base used in owner callbacks.
 *        identifier        (i) -    This objects identification number.  Passed to
 *                                lower layer to identify us (DLCI 0).
 *        link_originator    (i) -    BOOL, TRUE if we started the link
 *        config_file        (i) -    Address of the configuration path string
 *        datalink        (i) -    Address structure holding the DataLink
 *                                arbitratable parameters.
 *        memory_manager    (i) -    Address of the memory manager
 *        initialized        (o) -    Address of BOOL, we set it to TRUE if it
 *                                worked
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    CLayerSCF::~CLayerSCF (void);
 *
 *    Functional Description
 *        This is the destructor for the SCF Network layer.  We do our
 *        cleanup in here
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    SCFError    CLayerSCF::ConnectRequest (
 *                        DLCI    dlci,
 *                        USHORT    priority)
 *
 *    Functional Description
 *        This function initiates a connection with the remote site.  As a result,
 *        we will create a SCFCall and tell it to initiate a connection.
 *
 *    Formal Parameters
 *        dlci        (i) -    Proposed DLCI for the connection
 *        priority    (i) -    Proposed priority for the connection
 *
 *    Return Value
 *        SCF_NO_ERROR    -    No erroro occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    SCFError    CLayerSCF::DisconnectRequest (
 *                        DLCI    dlci);
 *
 *    Functional Description
 *        This function starts the disconnect process.
 *
 *    Formal Parameters
 *        dlci        (i) -    DLCI to disconnect.
 *
 *    Return Value
 *        SCF_NO_ERROR        -    No error occured
 *        SCF_NO_SUCH_DLCI    -    Invalid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    SCFError    CLayerSCF::ConnectResponse (
 *                        CallReference    call_reference,
 *                        DLCI            dlci,
 *                        BOOL        valid_dlci);
 *
 *    Functional Description
 *        This function is called by a higher layer to confirm a connection.  If
 *        the remote site initiates a connection with us, we issue a
 *        NETWORK_CONNECT_INDICATION to the owner object. It responds with this
 *        call to confirm or deny the suggested dlci.
 *
 *    Formal Parameters
 *        call_reference    (i) -    Call reference ID, passed to owner in
 *                                NETWORK_CONNECT_INDICATION
 *        dlci            (i) -    Referenced DLCI
 *        valid_dlci        (i) -    TRUE if the requested DLCI is valid
 *
 *    Return Value
 *        SCF_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::DataRequest (
 *                                ULONG        identifier,
 *                                LPBYTE        buffer_address,
 *                                USHORT        length,
 *                                USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.  For the SCF, this functio is not used
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Multiplexer.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::DataRequest (
 *                                ULONG,
 *                                PMemory,
 *                                USHORT *)
 *
 *    Functional Description
 *        This function is not used.
 *
 *    Formal Parameters
 *        No parameters used
 *
 *    Return Value
 *        PROTOCOL_LAYER_ERROR
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Multiplexer::DataIndication (
 *                                        LPBYTE        buffer_address,
 *                                        USHORT        length,
 *                                        USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
 *                                        ULONG            identifier,
 *                                        IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  In some cases, the identifier is the DLCI number in
 *        the packet.  If this multiplexer is being used as a stream to packet
 *        converter only, the identifer is not used and all data is passed to the
 *        higher layer.  This is a NULL function by SCF
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No higher layer allowed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
 *                                ULONG    identifier);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove the higher layer.
 *        If any more data is received with its identifier on it, it will be
 *        trashed.  This is a NULL function for SCF
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier used to identify the higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    No higher layer allowed
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::PollTransmitter (
 *                                ULONG        identifier,
 *                                USHORT        data_to_transmit,
 *                                USHORT *        pending_data,
 *                                USHORT *        holding_data);
 *
 *    Functional Description
 *        This function is called to give SCF a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     SCF does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicat which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::PollReceiver (
 *                                ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give SCF a chance pass packets
 *        to higher layers.  It is not used in SCF.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerSCF::GetParameters (
 *                                ULONG        identifier,
 *                                USHORT *        max_packet_size,
 *                                USHORT *        prepend,
 *                                USHORT *        append);
 *
 *    Functional Description
 *        This function is called to get the maximum packet size.  This function
 *        is not used in SCF.  It is here because we inherit from ProtocolLayer
 *        and this is a pure virtual function in that class.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        max_packet_size        (o)    -    Returns the maximum packet size
 *        prepend                (o)    -    Number of bytes prepended to a packet
 *        append                (o)    -    Number of bytes appended to a packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Function can not be called
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\scf.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    SCF.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the CLayerSCF class
 *
 *    Private Instance Variables:
 *        Remote_Call_Reference    -    List of active SCFCalls initiated by the
 *                                    remote site
 *        Call_Reference            -    List of active SCFCalls initiated locally
 *        DLCI_List                -    This list matches DLCIs to SCFCalls, its
 *                                    only real purpose is for DisconnectRequest()
 *        Message_List            -    List of OwnerCallback messages that can't
 *                                    be processed immediately.
 *        m_pT123            -    Address of owner object
 *        m_pQ922                -    Address of lower layer
 *        m_nMsgBase            -    Message base passed in by owner.  Used in
 *                                    OwnerCallback
 *        Identifier                -    Identifier passed to lower layer
 *        Link_Originator            -    TRUE if we initiated the connection
 *        Maximum_Packet_Size        -    Maximum packet size transmittable
 *        DataLink_Struct            -    Address of structure holding DataLink parms
 *        Data_Request_Memory_Manager    -    Address of memory manager
 *        Lower_Layer_Prepend        -    Holds number of bytes prepended to packet
 *                                    by the lower layer
 *        Lower_Layer_Append        -    Holds number of bytes appended to packet by
 *                                    the lower layer
 *        Call_Reference_Base        -    This value holds the next call reference
 *                                    number.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "scf.h"


/*
 *    CLayerSCF::CLayerSCF (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            IProtocolLayer *        lower_layer,
 *            USHORT                message_base,
 *            USHORT                identifier,
 *            BOOL                link_originator,
 *            PChar                config_file)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF constructor.  This routine initializes all
 *        variables and allocates buffer space.
 */
CLayerSCF::CLayerSCF
(
    T123                   *owner_object,
    CLayerQ922             *pQ922, // lower layer
    USHORT                  message_base,
    USHORT                  identifier,
    BOOL                    link_originator,
    PDataLinkParameters     datalink_struct,
    PMemoryManager          data_request_memory_manager,
    BOOL  *                 initialized
)
:
    Remote_Call_Reference (TRANSPORT_HASHING_BUCKETS),
    Call_Reference (TRANSPORT_HASHING_BUCKETS),
    DLCI_List (TRANSPORT_HASHING_BUCKETS),
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pQ922(pQ922)
{
    ProtocolLayerError    error;

    TRACE_OUT(("CLayerSCF::CLayerSCF"));

    Link_Originator    = (USHORT)link_originator;
    Identifier = identifier;
    Data_Request_Memory_Manager = data_request_memory_manager;
    Call_Reference_Base = 1;
    *initialized = TRUE;


     /*
     **    Fill in the DataLink_Struct with the proposed values and the default
     **    values
     */
    DataLink_Struct.k_factor = datalink_struct -> k_factor;
    DataLink_Struct.default_k_factor = datalink_struct -> default_k_factor;
    DataLink_Struct.n201 = datalink_struct -> n201;
    DataLink_Struct.default_n201 = datalink_struct -> default_n201;
    DataLink_Struct.t200 = datalink_struct -> t200;
    DataLink_Struct.default_t200 = datalink_struct -> default_t200;

     /*
     **    Find the maximum packet size
     */
    m_pQ922->GetParameters(
                    &Maximum_Packet_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

     /*
     **    Register with the lower layer
     */
    error = m_pQ922->RegisterHigherLayer(
                            Identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        ERROR_OUT(("Multiplexer: constructor:  Error registering with lower layer"));
        *initialized = FALSE;
    }
}


/*
 *    CLayerSCF::~CLayerSCF (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF destructor.  This routine cleans up everything.
 */
CLayerSCF::~CLayerSCF (void)
{
    TRACE_OUT(("CLayerSCF::~CLayerSCF"));

    PMessageStruct    message;
    PSCFCall        lpSCFCall;

    m_pQ922->RemoveHigherLayer(Identifier);

     /*
     **    Delete all locally initiated calls
     */
    Call_Reference.reset();
    while (Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        delete lpSCFCall;
    }

     /*
     **    Delete all remotely initiated calls
     */
    Remote_Call_Reference.reset();
    while (Remote_Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        delete lpSCFCall;
    }

     /*
     **    Delete all passive owner callbacks
     */
    Message_List.reset();
    while (Message_List.iterate ((PDWORD_PTR) &message))
    {
        delete message;
    }
}


/*
 *    CLayerSCF::ConnectRequest (
 *            DLCI                dlci,
 *            TransportPriority    priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connection with the remote site.  As a result,
 *        we will create a SCFCall and tell it to initiate a connection.
 */
SCFError    CLayerSCF::ConnectRequest (
                    DLCI                dlci,
                    TransportPriority    priority)

{
    TRACE_OUT(("CLayerSCF::ConnectRequest"));

    BOOL            initialized;
    CallReference    call_reference;
    SCFError        return_value = SCF_NO_ERROR;
    PSCFCall        lpSCFCall;


     /*
     **    Get the next valid local call reference value.
     */
    call_reference = GetNextCallReference ();

    if (call_reference == 0)
        return (SCF_CONNECTION_FULL);

     /*
     **    Create an SCFCall object to handle this call reference
     */
    DBG_SAVE_FILE_LINE
    lpSCFCall= new SCFCall(this,
                            m_pQ922,
                            call_reference << 8,
                            &DataLink_Struct,
                            Data_Request_Memory_Manager,
                            &initialized);

    if (lpSCFCall != NULL)
    {
        if (initialized)
        {
            Call_Reference.insert ((DWORD_PTR) call_reference, (DWORD_PTR) lpSCFCall);
             /*
             **    Register the DLCI and the call reference
             */
            DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpSCFCall);

            lpSCFCall->ConnectRequest (call_reference, dlci, priority);
        }
        else
        {
            delete lpSCFCall;
            return_value = SCF_MEMORY_ALLOCATION_ERROR;
        }
    }
    else
    {
        return_value = SCF_MEMORY_ALLOCATION_ERROR;
    }

    return (return_value);
}


/*
 *    CLayerSCF::ConnectResponse (
 *            CallReference    call_reference,
 *            DLCI            dlci,
 *            BOOL            valid_dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the CLayerSCF destructor.  This routine cleans up everything.
 */
SCFError    CLayerSCF::ConnectResponse (
                    CallReference    call_reference,
                    DLCI            dlci,
                    BOOL            valid_dlci)

{
    TRACE_OUT(("CLayerSCF::ConnectResponse"));

    PSCFCall        lpSCFCall = NULL;

    if (valid_dlci)
    {
        if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
            DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) lpSCFCall);
    }

	if(NULL != lpSCFCall)
	{
    	lpSCFCall->ConnectResponse (valid_dlci);
	    return (SCF_NO_ERROR);
    }
    return (SCF_NO_SUCH_DLCI);


}


/*
 *    SCFError    CLayerSCF::DisconnectRequest (
 *                        DLCI    dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This function calls the SCFCall associated with the DLCI and starts
 *        the disconnect operation
 */
SCFError    CLayerSCF::DisconnectRequest (
                    DLCI    dlci)

{
    TRACE_OUT(("CLayerSCF::DisconnectRequest"));

    PSCFCall        lpSCFCall;

    if (DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpSCFCall) == FALSE)
        return (SCF_NO_SUCH_DLCI);

    lpSCFCall->DisconnectRequest ();

    return (SCF_NO_ERROR);
}


/*
 *    SCFError    CLayerSCF::DataIndication (
 *                        LPBYTE        packet_address,
 *                        ULONG        buffer_size,
 *                        PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has received a
 *        packet for us to process.
 */
ProtocolLayerError    CLayerSCF::DataIndication (
                            LPBYTE        packet_address,
                            ULONG        packet_length,
                            PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerSCF::DataIndication"));

    BOOL            legal_packet;
    CallReference    call_reference;
    USHORT            length_call_reference;
    USHORT            message_type;
    PSCFCall        call;
    USHORT            remainder_length;
    USHORT            local;
    BOOL            initialized;


    remainder_length = (USHORT) packet_length;
    *bytes_accepted = packet_length;

    if (*(packet_address+PROTOCOL_DISCRIMINATOR) != Q931_PROTOCOL_DISCRIMINATOR)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    Get the call reference value
     */
    call_reference = *(packet_address + CALL_REFERENCE_VALUE);
    if (call_reference == 0)
    {
        ERROR_OUT(("CLayerSCF: DataIndication: illegal call reference value = 0"));
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    length_call_reference = *(packet_address + LENGTH_CALL_REFERENCE);
    packet_address += CALL_REFERENCE_VALUE + length_call_reference;
    remainder_length -= (CALL_REFERENCE_VALUE + length_call_reference);


     /*
     **    Get the message type
     */
    message_type = *(packet_address++);
    remainder_length--;

    switch (message_type)
    {
        case SETUP:
             /*
             **    If the call reference is already active, return error
             */
            if (Remote_Call_Reference.find ((DWORD) call_reference))
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  SETUP: call reference is already active"));
                break;
            }

            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 1)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  SETUP: call reference Originator bit is set incorrectly"));
                break;
            }

             /*
             **    This is a new call reference, create a new SCFCall to handle
             **    the call.  Since the remote site initiated the call, put this
             **    reference in the Remote array
             */
            call= new SCFCall(this,
                                m_pQ922,
                                (call_reference << 8),
                                &DataLink_Struct,
                                Data_Request_Memory_Manager,
                                &initialized);

            if (call != NULL)
            {
                if (initialized)
                {

                    Remote_Call_Reference.insert ((DWORD_PTR) call_reference, (DWORD_PTR) call);
                     /*
                     **    Allow the call to process the SETUP command
                     */
                    legal_packet = call->ProcessSetup (call_reference, packet_address, remainder_length);

                     /*
                     **    If the packet was illegal, remove the reference
                     */
                    if (legal_packet == FALSE) {
                        delete call;
                        Remote_Call_Reference.remove ((DWORD) call_reference);
                    }
                }
                else
                {
                    delete call;
                }
            }
            break;


        case CONNECT:
             /*
             **    The call originator bit must be set to signify that we are
             **    the originators of the call
             */
            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 0)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT: call reference Originator bit is set incorrectly"));
                break;
            }

             /*
             **    If the call reference is not already active, return error
             */
            call_reference &= CALL_ORIGINATOR_MASK;
            if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT: call reference is not already active = %x", call_reference));
                break;
            }

            call->ProcessConnect (packet_address, remainder_length);
            break;

        case CONNECT_ACKNOWLEDGE:
             /*
             **    If the call reference is already active, return error
             */
            if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT_ACK: call reference is not active"));
                break;
            }

             /*
             **    The call originator bit should NOT be set
             */
            if ((call_reference & CALL_REFERENCE_ORIGINATOR) == 1)
            {
                TRACE_OUT(("CLayerSCF: DataIndication:  CONNECT_ACK: call reference Originator bit is set incorrectly"));
                break;
            }

            call->ProcessConnectAcknowledge (packet_address, remainder_length);
            break;

        case RELEASE_COMPLETE:
            local = call_reference & CALL_REFERENCE_ORIGINATOR;
            call_reference &= CALL_ORIGINATOR_MASK;

             /*
             **    If the call is local, check the Call_Reference list for validity
             */
            if (local)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                {
                    TRACE_OUT(("CLayerSCF: DataIndication:  RELEASE_COMPLETE: call reference is not already active"));
                    break;
                }
            }
            else
            {
                 /*
                 **    If the call is remote, check the Call_Reference list for
                 **    validity
                 */
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                {
                    TRACE_OUT(("CLayerSCF: DataIndication:  RELEASE_COMPLETE: call reference is not already active"));
                    break;
                }
            }

            call -> ProcessReleaseComplete (packet_address, remainder_length);
            ProcessMessages ();
            break;

        case DISCONNECT:
        case RELEASE:
        case STATUS:
        case STATUS_ENQUIRY:
            TRACE_OUT(("CLayerSCF:DataIndication: Illegal command received = %x", message_type));

            local = call_reference & CALL_REFERENCE_ORIGINATOR;
            call_reference &= CALL_ORIGINATOR_MASK;

             /*
             **    If the call is local, check the Call_Reference list for validity
             */
            if (local)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                    break;
            }
            else
            {
                 /*
                 **    If the call is remote, check the Call_Reference list for
                 **    validity
                 */
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &call) == FALSE)
                    break;
            }

            call -> DisconnectRequest ();
            break;

        default:
            ERROR_OUT(("CLayerSCF:DataIndication: Unrecognized command received = %x", message_type));
            break;
    }
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::PollTransmitter (
 *                                ULONG,
 *                                USHORT    data_to_transmit,
 *                                USHORT *    pending_data,
 *                                USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function should be called frequently to allow the SCF calls to
 *        transmit packets.
 */
ProtocolLayerError    CLayerSCF::PollTransmitter (
                                ULONG_PTR,
                                USHORT    data_to_transmit,
                                USHORT *    pending_data,
                                USHORT *)
{
    // TRACE_OUT(("CLayerSCF::PollTransmitter"));

    USHORT            local_pending_data;
    PSCFCall        lpSCFCall;

    *pending_data = 0;

     /*
     **    Go through each of the locally originated calls and attempt to transmit
     **    data.
     */
    Call_Reference.reset();
    while (Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        lpSCFCall->PollTransmitter (data_to_transmit, &local_pending_data);
        *pending_data |= local_pending_data;
    }


     /*
     **    Go through each of the remotely originated calls and attempt to transmit
     **    data.
     */
    Remote_Call_Reference.reset();
    while (Remote_Call_Reference.iterate ((PDWORD_PTR) &lpSCFCall))
    {
        lpSCFCall-> PollTransmitter (data_to_transmit, &local_pending_data);
        *pending_data |= local_pending_data;
    }

    ProcessMessages ();

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    SCFError    CLayerSCF::DataRequest (
 *                        ULONG,
 *                        LPBYTE,
 *                        ULONG,
 *                        PULong)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can not be called.  This layer does not permit data
 *        requests from higher layers.
 */
ProtocolLayerError    CLayerSCF::DataRequest (
                            ULONG_PTR,
                            LPBYTE,
                            ULONG,
                            PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}

/*
 *    SCFError    CLayerSCF::DataRequest (
 *                        ULONG,
 *                        PMemory,
 *                        USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function can not be called.  This layer does not permit data
 *        requests from higher layers.
 */
ProtocolLayerError    CLayerSCF::DataRequest (
                            ULONG_PTR,
                            PMemory,
                            PULong)
{
    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    void    CLayerSCF::PollReceiver (
 *                    ULONG)
 *
 *    Public
 *
 *    Functional Description
 *        This function only checks its passive callback list.  If this function
 *        had a higher layer that it was passing data too, it would do that.  But
 *        since it has no higher layer, it doesn't do much.
 */
ProtocolLayerError CLayerSCF::PollReceiver(void)
{
    ProcessMessages ();

    return (PROTOCOL_LAYER_NO_ERROR);
}



/*
 *    CallReference    CLayerSCF::GetNextCallReference ()
 *
 *    Functional Description
 *        This function searches the local call reference list for a valid call
 *        reference number.  If it can not find one, it returns 0.  Valid call
 *        references are 1-127.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Call reference value
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
USHORT    CLayerSCF::GetNextCallReference ()
{
    USHORT    call_reference;

    if (Call_Reference.entries() == 127)
        return (0);

    call_reference = Call_Reference_Base;
    Call_Reference_Base++;
    if (Call_Reference_Base == 128)
        Call_Reference_Base = 1;

    while (Call_Reference.find ((DWORD) call_reference))
    {
        call_reference++;
        if (call_reference == 128)
            call_reference = 1;
    }

    return (call_reference);
}


/*
 *    ULONG    CLayerSCF::OwnerCallback (
 *                    USHORT    message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3)
 *
 *    Functional Description
 *        This function is called by the SCFCall objects when they need to
 *        communicate a message to us.  If the message can not be processed
 *        immediately, it is saved in a message structure and processed at a
 *        later time.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Message dependent
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
ULONG CLayerSCF::OwnerCallback
(
    ULONG       message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("CLayerSCF::OwnerCallback"));

    ULONG                   actual_message;
    CallReference           call_reference;
    PMessageStruct          passive_message;
    PNetworkConnectStruct   connect_struct;
    PSCFCall                lpSCFCall;

     /*
     **    The upper byte of the message is the call reference message that it
     **    represents
     */
    call_reference = (CallReference) (message >> 8);
    actual_message = message & 0xff;

    switch (actual_message)
    {
    case NETWORK_CONNECT_CONFIRM:

         /*
         **    A CONNECT_CONFIRM message is returned by the SCFCall when a call
         **    that we originated, has been established.  We register the
         **    SCFCall with the DLCI and call the owner object.
         */
        connect_struct = (PNetworkConnectStruct) parameter3;
        connect_struct -> call_reference = call_reference;

        if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
        {
            DLCI_List.insert ((DWORD_PTR) connect_struct->dlci, (DWORD_PTR) lpSCFCall);
        }

        m_pT123->OwnerCallback(m_nMsgBase + actual_message, 0, 0, parameter3);
        break;

    case NETWORK_CONNECT_INDICATION:
         /*
         **    A CONNECT_INDICATION message is returned by the SCFCall when the
         **    remote SCF wants to create a new call.  We will call the owner
         **    of this object to see if he will accept the DLCI requested.
         */
        connect_struct = (PNetworkConnectStruct) parameter3;
        connect_struct -> call_reference = call_reference;

        m_pT123->OwnerCallback(m_nMsgBase + actual_message, 0, 0, parameter3);
        break;

    case NETWORK_DISCONNECT_INDICATION:
         /*
         **    This message is received from the SCFCall when one side wants
         **    to terminate the call.  We treat this message differently than
         **    the other messages because it involves the deletion of an
         **    SCFCall object.  Don't forget, if we delete the object and then
         **    return to it at the end of this procedure, a GPF could occur.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (NULL != passive_message)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("CLayerSCF::OwnerCallback: cannot allocate MessageStruct"));
        }
        break;

    default:
        ERROR_OUT(("CLayerSCF: Illegal message: %x", actual_message));
        break;
    }
    return (0);
}


/*
 *    ProtocolLayerError    CLayerSCF::GetParameters (
 *                            USHORT,
 *                            USHORT *,
 *                            USHORT *,
 *                            USHORT *)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::GetParameters (
                            USHORT *,
                            USHORT *,
                            USHORT *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
 *                                USHORT,
 *                                PMemoryManager,
 *                                IProtocolLayer *)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::RegisterHigherLayer (
                            ULONG_PTR,
                            PMemoryManager,
                            IProtocolLayer *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
 *                                USHORT)
 *
 *    Public
 *
 *    Functional Description
 *        This function is not valid in this layer.  It must exist because this
 *        class inherits from inherits from ProtocolLayer and it is a pure virtual
 *        function.
 */
ProtocolLayerError    CLayerSCF::RemoveHigherLayer (
                            ULONG_PTR)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    void CLayerSCF::ProcessMessages ()
 *
 *    Functional Description
 *        This function is called periodically to check its passive messages.
 *        Passive messages occur when the SCF gets a callback but can't process
 *        it immediately.  Therefore, it puts the message and its parameters in
 *        a structure and saves the message for later.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Message dependent
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void CLayerSCF::ProcessMessages ()
{
    // TRACE_OUT(("CLayerSCF::ProcessMessages"));

    PMessageStruct    message;
    CallReference     call_reference;
    ULONG             actual_message;
    USHORT            call_originator;
    USHORT            cause;
    DLCI              dlci;
    BOOL              call_reference_valid;
    void             *parameter1;
    void             *parameter2;
    PSCFCall          lpSCFCall;

     /*
     **    Go thru each message in the list
     */
    while (Message_List.isEmpty() == FALSE)
    {
         /*
         **    Remote the first message from the list
         */
        message = (PMessageStruct) Message_List.get ();

        call_reference = (CallReference) ((message -> message) >> 8);
        actual_message = (message -> message) & 0xff;
        parameter1 = message -> parameter1;
        parameter2 = message -> parameter2;

        switch (actual_message)
        {
        case NETWORK_DISCONNECT_INDICATION:
             /*
             **    This message is received from the SCFCall when one side
             **    wants to terminate the call.  We treat this message
             **    differently than the other messages because it involves the
             **    deletion of an SCFCall object.
             */
            dlci = (DLCI) parameter1;
            call_originator = (USHORT) (((ULONG_PTR) parameter2) >> 16);
            cause = (USHORT) ((ULONG_PTR) parameter2) & 0xffff;

             /*
             **    dlci is 0 if the SCFCall was never assigned a DLCI by the
             **    remote site.
             */
            if (dlci != 0)
                DLCI_List.remove ((DWORD) dlci);

             /*
             **    If the SCFCall was the call originator, its reference is
             **    in Call_Reference, otherwise it is in Remote_Call_Reference.
             **
             **    Check the Call_Reference list to make sure that the
             **    call_reference is valid.  The way passive owner callbacks
             **    work, it is possible to receive a DISCONNECT for a callback
             **    that was already disconnected.
             */
            call_reference_valid = FALSE;
            if (call_originator)
            {
                if (Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
                {
                    delete lpSCFCall;
                    Call_Reference.remove ((DWORD) call_reference);
                    call_reference_valid = TRUE;
                }
            }
            else
            {
                if (Remote_Call_Reference.find ((DWORD_PTR) call_reference, (PDWORD_PTR) &lpSCFCall))
                {
                    delete lpSCFCall;
                    Remote_Call_Reference.remove ((DWORD_PTR) call_reference);
                    call_reference_valid = TRUE;
                }
            }

            if (call_reference_valid)
            {
                 /*
                 **    If the cause of the disconnect was because the Requested
                 **    channel was unavailable, we will tell the owner of this
                 **    layer to retry the connection.
                 */
                if (cause == REQUESTED_CHANNEL_UNAVAILABLE)
                {
                    parameter2 = (void *) ((((ULONG_PTR) call_originator) << 16) | TRUE);
                }
                else
                {
                    parameter2 = (void *) ((((ULONG_PTR) call_originator) << 16) | FALSE);
                }

                 /*
                 **    Let the owner of this object know that a disconnect has
                 **    occured.
                 */
                m_pT123->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                                       parameter1, parameter2);
            }
            break;
        }

         /*
         **    Delete the message structure
         */
        delete message;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\q922.h ===
/*    Q922.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the interface file for the Q.922 data link protocol.
 *        This class handles all error correction over the link.  It also insures
 *        that all packets are sequenced properly.  Its lower layer receives
 *        packets in raw Q922 format.  It is responsible for framing and error
 *        detecting the packets.  Q922 passes packets to its higher layer that
 *        have been sequenced properly.
 *
 *        Q.922 is a full duplex protocol .
 *
 *        This class assumes that the layers above and below it have packet input
 *        and output interfaces.
 *
 *        Read the Q.922 specification before diving into the code.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James P. Galvin
 *        James W. Lawwill
 */

#ifndef _Q922_H_
#define _Q922_H_

 /*
 **    Possible error conditions from this layer
 */
typedef enum
{
    DATALINK_NO_ERROR,
    DATALINK_READ_QUEUE_EMPTY,
    DATALINK_WRITE_QUEUE_FULL,
    DATALINK_RECEIVE_SEQUENCE_VIOLATION
}
    DataLinkError, * PDataLinkError;

 /*
 **    The data link layer can be in the following modes
 */
typedef enum
{
    TEI_ASSIGNED,
    AWAITING_ESTABLISHMENT,
    MULTIPLE_FRAME_ESTABLISHED,
    AWAITING_RELEASE,
    TIMER_RECOVERY
}
    DataLinkMode, * PDataLinkMode;

 /*
 **    Q922 Disconnect Types
 */
typedef enum
{
    DATALINK_NORMAL_DISCONNECT,
    DATALINK_ILLEGAL_PACKET_RECEIVED,
    DATALINK_RECEIVE_SEQUENCE_EXCEPTION,
    DATALINK_REMOTE_SITE_TIMED_OUT
}
    DataLinkDisconnectType, * PDataLinkDisconnectType;

 /*
 **    Q922 Status messages
 */
typedef enum
{
    DATALINK_TIMING_ERROR
}
    DataLinkStatusMessage, * PDataLinkStatusMessage;

 /*
 **    Default packet size
 */
#define    DATALINK_OUTPUT_MAXIMUM_PACKET_SIZE    1024

 /*
 **    Transmit and receive packets are managed via the DataQueue structure
 */
typedef struct
{
    LPBYTE    buffer_address;
    USHORT    length;
}
    DataQueue, * PDataQueue;


 /*
 **    In this implementation of Q922, the DLCI is 10 bits.
 **    For this reason, we will make it a USHORT
 */
typedef    USHORT    DLCI;


 /*
 **    Q922 definitions
 */
#define COMMAND_BIT                     0x02
#define POLL_FINAL_BIT                  0x01

#define RESPONSE_FRAME                  COMMAND_BIT
#define COMMAND_FRAME                   0x00

#define PF_RESET                        0x00
#define PF_SET                          POLL_FINAL_BIT

#define UNNUMBERED_PF_RESET             0x00
#define UNNUMBERED_PF_SET               0x10

#define ADDRESS_BYTE_HIGH               0
#define ADDRESS_BYTE_LOW                1
#define CONTROL_BYTE_HIGH               2
#define CONTROL_BYTE_LOW                3

#define ADDRESS_MSB                     0x00
#define ADDRESS_LSB                     0x01
#define CONTROL_MSB                     0x01
#define ADDRESS_HIGH(X)                 ((X >> 2) & 0xfc)
#define ADDRESS_LOW(X)                  ((X & 0x0f) << 4)

#define UNNUMBERED_HEADER_SIZE          3

#define SUPERVISORY_FRAME_BIT           0x01
#define SUPERVISORY_COMMAND_MASK        0x0c

#define RECEIVER_READY                  0x00
#define RECEIVER_NOT_READY              0x04
#define REJECT                          0x08

#define UNNUMBERED_FRAME_BIT            0x02
#define UNNUMBERED_COMMAND_MASK         0xec

#define SABME                           0x6c
#define UNNUMBERED_ACKNOWLEDGE          0x60
#define FRAME_REJECT                    0x84
#define DISCONNECTED_MODE               0x0c
#define DISC                            0x40

#define SEQUENCE_MODULUS                128
#define RECEIVE_SEQUENCE_VIOLATION      1

 /*
 **    DATALINK_MAXIMUM_PACKET_SIZE = User data + overhead
 */
#define DATALINK_MAXIMUM_PACKET_SIZE    1024

 /*
 **    The maximum Q922 packet overhead is 4 bytes
 */
#define DATALINK_PACKET_OVERHEAD        4

 /*
 **    Default timeouts
 */
#define DEFAULT_T203_COMM_TIMEOUT       600
#define DEFAULT_T203_TIMEOUT            30000
#define DEFAULT_MAXIMUM_T200_TIMEOUTS   5


class CLayerQ922 : public IProtocolLayer
{
public:

    CLayerQ922(
        T123                 *owner_object,
        Multiplexer          *lower_layer,
        USHORT                message_base,
        USHORT                identifier,
        BOOL                  link_originator,
        USHORT                data_indication_queue_size,
        USHORT                data_request_queue_size,
        USHORT                k_factor,
        USHORT                max_packet_size,
        USHORT                t200,
        USHORT                max_outstanding_bytes,
        PMemoryManager        memory_manager,
        PLUGXPRT_PSTN_CALL_CONTROL,
        PLUGXPRT_PARAMETERS *,
        BOOL *                initialized);

    virtual ~CLayerQ922(void);

    DataLinkError    ReleaseRequest (void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            PMemory        memory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR         identifier,
                            PMemoryManager    dr_memory_manager,
                            IProtocolLayer *    higher_layer);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR    identifier);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR    identifier,
                            USHORT    data_to_transmit,
                            USHORT *    pending_data,
                            USHORT *    holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *    max_packet_size,
                            USHORT *    prepend_size,
                            USHORT *    append_size);

private:

    void            ProcessReadQueue (void);
    void            ProcessWriteQueue (
                        USHORT    data_to_transmit);
    BOOL             TransmitSupervisoryFrame (
                        UChar    frame_type,
                        UChar    poll_final_bit);
    BOOL             TransmitInformationFrame (void);
    BOOL              TransmitUnnumberedFrame (void);

    void            ProcessReceiverReady (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessReceiverNotReady (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessReject (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    BOOL             ProcessInformationFrame (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    DataLinkError    ParsePacketHeader (
                        LPBYTE        packet_address,
                        USHORT        packet_length,
                        BOOL *         command_frame,
                        LPBYTE        receive_sequence_number,
                        BOOL *         poll_final_bit);

    void            ProcessSABME (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessFrameReject (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessUnnumberedAcknowledge (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessDisconnectMode (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    void            ProcessDISC (
                        LPBYTE    packet_address,
                        USHORT    packet_length);
    DataLinkError    ParseUnnumberedPacketHeader (
                        LPBYTE        packet_address,
                        BOOL *         command_frame,
                        BOOL *         poll_final_bit);

    void            UpdateAcknowledgeState (
                        UChar    sequence_number);
    void            ResetSendState (
                        void);

    void            StartTimerT200 (void);
    void            StopTimerT200 (void);
    void            T200Timeout (
                        TimerEventHandle);

    void            StartTimerT203 (void);
    void            StopTimerT203 (void);
    void            T203Timeout (
                        TimerEventHandle);

    void              Reset (void);

private:

    T123               *m_pT123; // owner object
    Multiplexer        *m_pMultiplexer; // lower layer
    IProtocolLayer     *Higher_Layer;
    USHORT              m_nMsgBase;
    DLCI                DLCI;
    BOOL                Link_Originator;
    USHORT              Maximum_Information_Size;
    BOOL                SABME_Pending;
    BOOL                Unnumbered_Acknowledge_Pending;
    BOOL                DISC_Pending;
    BOOL                Disconnected_Mode_Pending;
    BOOL                Frame_Reject_Pending;
    USHORT              Unnumbered_PF_State;
    BOOL                Final_Packet;

    USHORT              Data_Indication_Size;
    PDataQueue          Data_Indication;
    LPBYTE              Data_Indication_Buffer;
    USHORT              Data_Indication_Head;
    USHORT              Data_Indication_Tail;
    USHORT              Data_Indication_Count;

    USHORT              Data_Request_Size;
    USHORT              Data_Request_Total_Size;
    PMemory            *Data_Request;
    USHORT              Data_Request_Head;
    USHORT              Data_Request_Tail;
    USHORT              Data_Request_Count;
    USHORT              Data_Request_Acknowledge_Tail;
    PMemoryManager      Data_Request_Memory_Manager;
    USHORT              Lower_Layer_Prepend;
    USHORT              Lower_Layer_Append;

    PMemory             Supervisory_Write_Struct;
    LPBYTE              Supervisory_Write_Buffer;

    UChar               Send_State_Variable;
    UChar               Receive_State_Variable;
    UChar               Acknowledge_State_Variable;

    BOOL                Own_Receiver_Busy;
    BOOL                Peer_Receiver_Busy;

    BOOL                Command_Pending;
    BOOL                Poll_Pending;
    BOOL                Final_Pending;
    BOOL                Acknowledge_Pending;
    BOOL                Reject_Pending;
    BOOL                Reject_Outstanding;

    ULONG               T200_Timeout;
    TimerEventHandle    T200_Handle;
    BOOL                T200_Active;
    ULONG               N200_Count;
    ULONG               Maximum_T200_Timeouts;
    ULONG               Startup_Maximum_T200_Timeouts;
    ULONG               Link_Maximum_T200_Timeouts;

    ULONG               T203_Timeout;
    TimerEventHandle    T203_Handle;
    BOOL                T203_Active;

    DataLinkMode        Data_Link_Mode;
    BOOL                Link_Stable;

    USHORT              Receive_Sequence_Exception;
    USHORT              Receive_Sequence_Recovery;

    USHORT              Maximum_Outstanding_Packets;
    USHORT              Outstanding_Packets;
    USHORT              Maximum_Outstanding_Bytes;
    USHORT              Outstanding_Bytes;
    ULONG               Total_Retransmitted;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    CLayerQ922::CLayerQ922 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                identifier,
 *                BOOL                 link_originator,
 *                USHORT                data_indication_queue_siz,
 *                USHORT                data_request_queue_size,
 *                USHORT                k_factor,
 *                USHORT                max_information_size,
 *                USHORT                t200,
 *                USHORT                max_outstanding_bytes,
 *                PMemoryManager        memory_manager,
 *                BOOL *                 initialized)
 *
 *    Functional Description
 *        This is the constructor for the Q.922 data link layer.  It prepares
 *        for communications by allocating buffers and setting its internal
 *        buffers properly.  It also registers itself with its lower layer.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object    (i)    -    Address of the object that owns us.  This
 *                                address is used for owner callbacks.
 *        lower_layer        (i)    -    Address of the layer below us.  We pass packets
 *                                to this layer and receive packets from it.
 *        message_base    (i)    -    Message base used in owner callbacks.
 *        identifier        (i)    -    Identifier of this object.  It is passed to the
 *                                lower layer along with our address, to identify
 *                                us.
 *        link_originator    (i)    -    TRUE if this object should initiate a link.
 *        data_indication_queue_size    (i)    -    Number of queues available for
 *                                reception of data from the lower layer
 *        data_request_queue_size (i)    -    Number of queues available for
 *                                transmission of data to the lower layer.
 *        k_factor        (i) -    Number of outstanding packets allowed.
 *        max_information_size (i)    -    Max. number of bytes in the information
 *                                part of a packet
 *        t200            (i)    -    T200 timeout
 *        max_outstanding_bytes    (i)    -    Maximum number of outstanding bytes at
 *                                any one time
 *        initialized        (o)    -    BOOL      returned to user telling him if the
 *                                object initialized o.k.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    CLayerQ922::~CLayerQ922 (void);
 *
 *    Functional Description
 *        This is the destructor for the Q.922 data link layer.  It destroys
 *        the read and write buffers.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    DataLinkError    CLayerQ922::ReleaseRequest (void);
 *
 *    Functional Description
 *        This function is called to terminate a connection.  When this function
 *        is called we queue up a DISC packet to be sent to the remote site.
 *        When we receive an Unnumbered Ack packet, we notify the owner object
 *        that the link is terminated
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataRequest (
 *                                    ULONG        identifier,
 *                                    PMemory        memory,
 *                                    PULong        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.  The packet is held in a memory object.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        memory            (i)    -    Memory object containing packet.
 *        bytes_accepted    (o)    -    Number of bytes accepted by the CLayerQ922.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataRequest (
 *                                    ULONG    identifier,
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the CLayerQ922.
 *                                This value will either be 0 or the packet
 *                                length since this layer has a packet interface.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::DataIndication (
 *                                    LPBYTE    buffer_address,
 *                                    USHORT    length,
 *                                    USHORT *    bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *        to us.  This layer assumes that the data coming to us is in packet
 *        format.
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::RegisterHigherLayer (
 *                                    ULONG            identifier,
 *                                    PMemoryManager    memory_manager,
 *                                    IProtocolLayer *    higher_layer);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  When this object needs to send a packet up, it calls
 *        the higher_layer with a Data Indication
 *
 *    Formal Parameters
 *        identifier        (i)    -    Unique identifier of the higher layer.  If we
 *                                were doing multiplexing at this layer, this
 *                                would have greater significance.
 *        memory_manager    (i)    -    Pointer to outbound memory manager
 *        higher_layer    (i)    -    Address of higher layer
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *        PROTOCOL_LAYER_REGISTRATION_ERROR    -    Error occured on registration
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    CLayerQ922::RemoveHigherLayer (
 *                                    ULONG);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  If the higher layer removes itself from us, we have
 *        no place to send incoming data
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT    data_to_transmit,
 *                                    USHORT *    pending_data,
 *                                    USHORT *    holding_data);
 *
 *    Functional Description
 *        This function is called to give the CLayerQ922 a chance to transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.
 *        pending_data        (o)    -    Return value to indicate which data is left
 *                                    to be transmitted.
 *        holding_data        (o)    -    Returns the number of packets currently
 *                                    outstanding.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::PollReceiver (
 *                                    ULONG    identifier);
 *
 *    Functional Description
 *        This function is called to give the CLayerQ922 a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    CLayerQ922::GetParameters (
 *                                    ULONG    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend_size,
 *                                    USHORT *    append_size);
 *
 *    Functional Description:
 *        This function returns the maximum packet size that it can handle via
 *        its DataRequest() function.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Not used
 *        max_packet_size    (o)    -    Address to return max. packet size in.
 *        prepend_size    (o)    -    Return number of bytes prepended to each packet
 *        append_size        (o)    -    Return number of bytes appended to each packet
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\scfcall.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);
/*    SCFCall.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class is instantiated by the SCF class.  For each call that the
 *        local site or remote site initiates, a SCFCall object is instantiated.
 *        SCF can can manage 254 different calls simultaneously.  For each call
 *        there is a specific Q.933 based protocol that must occur to make the
 *        connection valid.  This object sends and receives the Q.933 packets.
 *
 *    Private Instance Variables:
 *        m_pSCF            -    Address of the owner of this object
 *        Lower_Layer                -    Address of the layer below this layer
 *        m_nMsgBase            -    The owner of this object gives it a base
 *                                    number to use for OwnerCallbacks ()
 *        Maximum_Packet_Size        -    Maximum transmittable packet size
 *        Packet_Pending            -    Tells which packet is to be transmitted 
 *                                    next.
 *        Link_Originator            -    TRUE is this site initiated the call
 *
 *        Write_Buffer            -    Address of write buffer
 *        Send_Priority            -    TRUE if we are suppose to respond to the
 *                                    priority requested by the remote site
 *
 *        Call_Reference            -    Call reference number of this call.
 *        DLCI                    -    Holds the suggested and confirmed DLCI for
 *                                    this call.
 *        Priority                -    Holds the suggested and confirmed priority
 *                                    for this call.
 *
 *        State                    -    Holds the current state of the call.
 *        Release_Cause            -    Reason the the breakup of the link.
 *        Default_Priority        -    Default priority of a non-specified call.
 *
 *        T303_Timeout            -    T303 timeout value.
 *        T303_Handle                -    System timer handle to T303 timer
 *        T303_Active                -    TRUE if the timer is currently active
 *        T303_Count                -    Number of T303 Timeouts
 *
 *        T313_Timeout            -    T313 timeout value
 *        T313_Handle                -    System timer handle to T313 timer
 *        T313_Active                -    TRUE if the timer is currently active.
 * 
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */
#include "scf.h"
#include "scfcall.h"


/*
 *    SCFCall::SCFCall (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                PDataLinkParameters    datalink_struct,
 *                PMemoryManager        data_request_memory_manager,
 *                BOOL *            initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the SCFCall constructor.  This routine initializes all
 *        variables and allocates write buffer space.
 */
SCFCall::SCFCall (
            CLayerSCF            *owner_object,
            IProtocolLayer *        lower_layer,
            USHORT                message_base,
            PDataLinkParameters    datalink_struct,
            PMemoryManager        data_request_memory_manager,
            BOOL *            initialized)
{
    TRACE_OUT(("SCFCall::SCFCall"));

    m_pSCF = owner_object;
    Lower_Layer = lower_layer;
    m_nMsgBase = message_base;
    Data_Request_Memory_Manager = data_request_memory_manager;
    *initialized = TRUE;

    DataLink_Struct.k_factor = datalink_struct->k_factor;
    DataLink_Struct.default_k_factor = datalink_struct->default_k_factor;
    DataLink_Struct.n201 = datalink_struct->n201;
    DataLink_Struct.default_n201 = datalink_struct->default_n201;

     /*
     **    T200 is represented in milliseconds, we need to convert it to 
     **    tenths of seconds.
     */
    DataLink_Struct.t200 = datalink_struct->t200 / 100;
    DataLink_Struct.default_t200 = datalink_struct->default_t200 / 100;

    Lower_Layer -> GetParameters (
                    &Maximum_Packet_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    Packet_Pending = NO_PACKET;
    Link_Originator = FALSE;
    State = NOT_CONNECTED;
    Received_Priority = FALSE;
    Received_K_Factor = FALSE;
    Received_N201 = FALSE;
    Received_T200 = FALSE;
    DLC_Identifier = 0;

    T303_Active = FALSE;
    T313_Active = FALSE;
    
     /*
     **    Get configuration data
     */
    T303_Timeout = DEFAULT_T303_TIMEOUT;
    T313_Timeout = DEFAULT_T313_TIMEOUT;
    Default_Priority = DEFAULT_PRIORITY;
}


/*
 *    SCFCall::~SCFCall (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the SCFCall destructor.  This routine cleans up the mess
 */
SCFCall::~SCFCall (void)
{
    if (T303_Active)
    {
        StopTimerT303 ();
    }

    if (T313_Active)
    {
        StopTimerT313 ();
    }
}


/*
 *    SCFCall::ConnectRequest (
 *                CallReference    call_reference,
 *                DLCI            dlci,
 *                USHORT            priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when SCF wants to initiate a call.
 *        As a result, we queue a SETUP command to be sent out.
 */
SCFCallError    SCFCall::ConnectRequest(
                            CallReference        call_reference,
                            DLCI                dlci,
                            TransportPriority    priority)
{
    TRACE_OUT(("SCFCall::ConnectRequest"));
    Call_Reference = call_reference;
    DLC_Identifier = dlci;
    Priority = priority;
    Link_Originator = TRUE;

    if (State == NOT_CONNECTED)
        Packet_Pending = SETUP;

    return (SCFCALL_NO_ERROR);
}



/*
 *    SCFCallError    SCFCall::ConnectResponse (
 *                                BOOL        valid_dlci)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called in response to a NETWORK_CONNECT_INDICATION
 *        callback to the owner of this object.  Previously, the remote site
 *        sent us a SETUP packet with a suggested DLCI.  This DLCI is sent to 
 *        the owner in the NETWORK_CONNECT_INDICATION call.  The owner calls
 *        this function with a BOOL    , telling us if the DLCI was valid.
 */
SCFCallError    SCFCall::ConnectResponse (
                            BOOL        valid_dlci)
{
    TRACE_OUT(("SCFCall::ConnectResponse"));
    if (valid_dlci)
    {
         /*
         **    This DLCI can be used in a link.  If the remote site did not
         **    request a priority, we set it to Default_Priority
         */
        if (Priority == 0xffff)
            Priority = Default_Priority;

        Packet_Pending = CONNECT;

    }
    else
    {
         /*
         **    Queue up a RELEASE COMPLETE packet
         */
        Packet_Pending = RELEASE_COMPLETE;
        Release_Cause = REQUESTED_CHANNEL_UNAVAILABLE;
    }

    return (SCFCALL_NO_ERROR);
}



/*
 *    SCFCallError    SCFCall::DisconnectRequest ()
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called when the SCF wants to terminate the call
 */
SCFCallError SCFCall::DisconnectRequest ()
{
    TRACE_OUT(("SCFCall::DisconnectRequest"));
     /*
     **    Queue up the Release Complete
     */
    if (State != NOT_CONNECTED)
    {
        Packet_Pending = RELEASE_COMPLETE;
        Release_Cause = NORMAL_USER_DISCONNECT;
    }

    return (SCFCALL_NO_ERROR);
}



/*
 *    BOOL        SCFCall::ProcessSetup (
 *                             CallReference    call_reference,
 *                             LPBYTE            packet_address,
 *                             USHORT            packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming SETUP packet
 */
BOOL     SCFCall::ProcessSetup (
                    CallReference    call_reference,
                    LPBYTE            packet_address,
                    USHORT            packet_length)
{
    USHORT                    length;
    BOOL                    packet_successful;
    USHORT                    remainder_length;
    USHORT                    n201;
    USHORT                    k_factor;
    USHORT                    t200;
    NetworkConnectStruct    connect_struct;

    TRACE_OUT(("SCFCall::ProcessSetup"));

    if (State != NOT_CONNECTED)
        return (FALSE);

    Call_Reference = call_reference;
    packet_successful = TRUE;
    remainder_length = packet_length;

     /*
     **    Bearer capability element
     */
    if (*(packet_address++) != BEARER_CAPABILITY)
        return (FALSE);
    remainder_length--;

    length = *(packet_address++);
    remainder_length--;
    if (length != 3)
        return (FALSE);

     /*
     **    Verify that the Bearer Capability is correct
     */    
    if (*(packet_address) != 
        (EXTENSION | CODING_STANDARD | INFORMATION_TRANSFER_CAPABILITY))
    {
        return (FALSE);
    }
    if (*(packet_address + 1) != (EXTENSION | TRANSFER_MODE))
    {
        return (FALSE);
    }
    if (*(packet_address + 2) != 
        (EXTENSION | LAYER_2_IDENT | USER_INFORMATION_LAYER_2))
    {
        return (FALSE);
    }
    packet_address += length;
    remainder_length -= length;

     /*
     **    DLCI element
     */
    if (*(packet_address++) != DLCI_ELEMENT)
        return (FALSE);
    remainder_length--;

    length = *(packet_address++);
    if (length != 2)
        return (FALSE);
    remainder_length--;
    
     /*
     **    If the Preferred/Exclusive bit is set, its illegal
     */
    if (((*(packet_address) & PREFERRED_EXCLUSIVE) == PREFERRED_EXCLUSIVE) ||
        ((*(packet_address + 1) & EXTENSION) == 0))
    {
        return (FALSE);
    }
    
    DLC_Identifier = (*(packet_address) & 0x3f) << 4;
    DLC_Identifier |= ((*(packet_address + 1) & 0x78) >> 3);

    packet_address += length;
    remainder_length -= length;

    Priority = 0xffff;

     /*
     **    Go thru each of the elements and decode them
     */
    while (remainder_length)
    {
        switch (*(packet_address++))
        {
            case X213_PRIORITY:
                length = *(packet_address++);
                remainder_length--;
                if (((*(packet_address) & EXTENSION) == 1) ||
                    ((*(packet_address + 1) & EXTENSION) == 0))
                {
                    ERROR_OUT(("SCFCall: ProcessSetup: SETUP packet: Illegal X.213 priority"));
                    return (FALSE);
                }
                Priority = (*packet_address & 0x0f);
                packet_address += length;
                remainder_length -= length;
                Received_Priority = TRUE;
                break;

            case LINK_LAYER_CORE_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case FMIF_SIZE:
                             /*
                             **    N201 is a Q922 parameter.  It is the number of 
                             **    maximum information bytes in a packet
                             */
                            n201 = 
                                ((*packet_address << 7) | 
                                (*(packet_address + 1) & 0x7f));
                            if ((*(packet_address+1) & EXTENSION) == EXTENSION)
                            {
                                length -= 2;
                                packet_address += 2;
                            }
                            else
                            {
                                packet_address += 4;
                                length -= 4;
                            }

                             /*
                             **    If the requested n201 value is less than our
                             **    value, it will be our new N201, otherwise send
                             **    our N201 back as the arbitrated value.
                             */
                            if (n201 < DataLink_Struct.n201)
                                DataLink_Struct.n201 = n201;
                            Received_N201 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: n201 = %d", DataLink_Struct.n201));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case LINK_LAYER_PROTOCOL_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case TRANSMIT_WINDOW_SIZE_IDENTIFIER:
                             /*
                             **    The Window size is the maximum number of 
                             **    outstanding packets at any one time
                             */
                            k_factor = *packet_address & 0x7f;
                            packet_address++;
                            length--;

                             /*
                             **    If the requested k_factor value is less than our
                             **    value, it will be our new k_factor, otherwise 
                             **    send our k_factor back as the arbitrated value.
                             */
                            if (k_factor < DataLink_Struct.k_factor)
                                DataLink_Struct.k_factor = k_factor;
                            Received_K_Factor = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: k_factor = %d", DataLink_Struct.k_factor));
                            break;

                        case RETRANSMISSION_TIMER_IDENTIFIER:
                             /*
                             **    t200 is the timeout value before retransmission
                             */
                            t200 = ((*packet_address << 7) | 
                                    (*(packet_address + 1) & 0x7f));
                            packet_address += 2;
                            length -= 2;

                             /*
                             **    If the requested t200 value is too small, 
                             **    value, it will be our new T200, otherwise 
                             **    send our T200 back as the arbitrated value.
                             */
                            if (t200 > DataLink_Struct.t200)
                                DataLink_Struct.t200 = t200;
                            Received_T200 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessSetup: t200 = %d", DataLink_Struct.t200));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case END_TO_END_DELAY:
            case CALLING_PARTY_SUBADDRESS:
            case CALLED_PARTY_SUBADDRESS:
            default:
                TRACE_OUT(("SCFCall: ProcessSetup: SETUP packet: Option 0x%x"
                    "requested, but not supported", *(packet_address-1)));
                length = *(packet_address);

                packet_address += (length + 1);
                remainder_length -= (length + 1);
                break;
        }
        remainder_length--;
    }
    if (Received_N201 == FALSE)
        DataLink_Struct.n201 = DataLink_Struct.default_n201;
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

    if (packet_successful)
    {
         /*
         **    If the packet was successfully decoded, tell the owner the requested
         **    DLCI and priority.
         */
        connect_struct.dlci = DLC_Identifier;
        connect_struct.priority = Priority;
        connect_struct.datalink_struct = &DataLink_Struct;

         /*
         **    Convert t200 into milliseconds
         */
        DataLink_Struct.t200 *= 100;
        m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_CONNECT_INDICATION, 0, 0, &connect_struct);
        DataLink_Struct.t200 /= 100;
    }
                                
    return (packet_successful);
}


/*
 *    BOOL        SCFCall::ProcessConnect (
 *                             LPBYTE        packet_address,
 *                             USHORT        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming CONNECT packet
 */
BOOL     SCFCall::ProcessConnect (
                    LPBYTE        packet_address,
                    USHORT        packet_length)
{
    TRACE_OUT(("SCFCall::ProcessConnect"));

    BOOL        packet_successful;
    USHORT        length;
    DLCI        exclusive_dlci;
    USHORT        remainder_length;
    USHORT        k_factor;
    USHORT        t200;
    
    if (State != SETUP_SENT)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: Call in wrong state"));
        return (FALSE);
    }

    remainder_length = packet_length;
    packet_successful = TRUE;

     /*
     **    DLCI element
     */
    if (*(packet_address++) != DLCI_ELEMENT)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: DLCI_ELEMENT not in packet"));
        return (FALSE);
    }
    remainder_length--;

    length = *(packet_address++);
    if (length != 2)
    {
        ERROR_OUT(("SCFCall: ProcessConnect: DLCI length must be 2"));
        return (FALSE);
    }
    remainder_length--;
    
     /*
     **    If the Preferred/Exclusive bit is not set, its illegal
     */
    if (((*(packet_address) & PREFERRED_EXCLUSIVE) == 0) ||
        ((*(packet_address + 1) & EXTENSION) == 0))
    {
        ERROR_OUT(("SCFCall:  CONNECT: Illegal DLCI"));
        return (FALSE);
    }
    
     /*
     **    Get the DLCI
     */
    exclusive_dlci = (*(packet_address) & 0x3f) << 4;
    exclusive_dlci |= ((*(packet_address + 1) & 0x78) >> 3);

    packet_address += length;
    remainder_length -= length;

     /*
     **    Go thru each of the elements and decode them
     */
    while (remainder_length != 0)
    {
        switch (*(packet_address++))
        {
            case X213_PRIORITY:
                length = *(packet_address++);
                remainder_length--;
                if ((*(packet_address) & EXTENSION) == 0)
                {
                    ERROR_OUT(("SCFCall: DataIndication: CONNECT packet: Illegal X.213 priority"));
                    return (FALSE);
                }
                Priority = (*packet_address & 0x0f);
                packet_address += length;
                remainder_length -= length;
                break;

            case LINK_LAYER_CORE_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case FMIF_SIZE:
                             /*
                             **    FMIF_Size is the max. number of bytes allowed in
                             **    a information packet
                             */
                            DataLink_Struct.n201 = 
                                ((*packet_address << 7) | 
                                (*(packet_address + 1) & 0x7f));
                            if ((*(packet_address+1) & EXTENSION) == EXTENSION)
                            {
                                length -= 2;
                                packet_address += 2;
                            }
                            else
                            {
                                packet_address += 4;
                                length -= 4;
                            }

                            Received_N201 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: n201 = %d", DataLink_Struct.n201));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case LINK_LAYER_PROTOCOL_PARAMETERS:
                length = *(packet_address++);
                remainder_length -= (length + 1);
                while (length)
                {
                    switch (*(packet_address++))
                    {
                        case TRANSMIT_WINDOW_SIZE_IDENTIFIER:
                             /*
                             **    The Window size is the maximum number of 
                             **    outstanding packets at any one time
                             */
                            k_factor = *packet_address & 0x7f;
                            packet_address++;
                            length--;

                            DataLink_Struct.k_factor = k_factor;
                            Received_K_Factor = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: k_factor = %d", DataLink_Struct.k_factor));
                            break;

                        case RETRANSMISSION_TIMER_IDENTIFIER:
                             /*
                             **    t200 is the timeout value before retransmission
                             */
                            t200 = ((*packet_address << 7) | 
                                    (*(packet_address + 1) & 0x7f));
                            packet_address += 2;
                            length -= 2;

                            DataLink_Struct.t200 = t200;
                            Received_T200 = TRUE;
                            TRACE_OUT(("SCFCALL: ProcessConnect: t200 = %d", DataLink_Struct.t200));
                            break;

                        default:
                            while ((*(packet_address++) & EXTENSION) == 0)
                                length--;
                            length--;
                            break;
                    }
                    length--;
                }
                break;

            case END_TO_END_DELAY:
            case CALLING_PARTY_SUBADDRESS:
            case CALLED_PARTY_SUBADDRESS:
            default:
                TRACE_OUT(("SCFCall: DataIndication: CONNECT packet: Option "
                    "requested, but not supported", *(packet_address-1)));
                length = *(packet_address++);
                remainder_length--;

                packet_address += length;
                remainder_length -= length;
                break;
        }
        remainder_length--;
    }

    if (Received_N201 == FALSE)
        DataLink_Struct.n201 = DataLink_Struct.default_n201;
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

     /*
     **    If the packet was successfully decoded, queue up the CONNECT ACK
     */
    if (packet_successful)
    {
        Packet_Pending = CONNECT_ACKNOWLEDGE;
        StopTimerT303 ();
    }

    return (packet_successful);
}


/*
 *    BOOL        SCFCall::ProcessConnectAcknowledge (
 *                             LPBYTE,
 *                             USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming CONNECT ACK packet
 *
 */
BOOL        SCFCall::ProcessConnectAcknowledge (
                        LPBYTE,
                        USHORT)
{
    TRACE_OUT(("SCFCall::ProcessConnectAcknowledge"));

    if (State != CONNECT_SENT)
        return (FALSE);

    StopTimerT313 ();

    return (TRUE);
}


/*
 *    BOOL        SCFCall::ProcessReleaseComplete (
 *                             LPBYTE        packet_address,
 *                             USHORT)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes an incoming RELEASE COMPLETE
 */
BOOL        SCFCall::ProcessReleaseComplete (
                        LPBYTE    packet_address,
                        USHORT)
{
    TRACE_OUT(("SCFCall::ProcessReleaseComplete"));

    USHORT    cause = 0;

    if (State == NOT_CONNECTED)
        return (FALSE);

    if (*(packet_address++) == CAUSE)
    {
        packet_address++;
        if ((*(packet_address++) & EXTENSION) == 0)
            packet_address++;

        cause = *(packet_address++) & (~EXTENSION);
        TRACE_OUT(("SCFCall: Disconnect: cause = %d", cause));
    }

    State = NOT_CONNECTED;

     /*
     **    Tell the owner about the Disconnection
     */
    m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                          (void *) DLC_Identifier,
                          (void *) (ULONG_PTR)(((Link_Originator << 16) | cause)));
    return (TRUE);
}


/*
 *    void    SCFCall::PollTransmitter (
 *                        USHORT        data_to_transmit,
 *                        USHORT *    pending_data);
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to transmit any queued up packets
 */
void    SCFCall::PollTransmitter (
                    USHORT    data_to_transmit,
                    USHORT *    pending_data)
{
    // TRACE_OUT(("SCFCall::PollTransmitter"));

    NetworkConnectStruct    connect_struct;

    if (data_to_transmit & PROTOCOL_CONTROL_DATA)
    {
        switch (Packet_Pending)
        {
        case SETUP:
            SendSetup ();
            break;

        case CONNECT:
            SendConnect ();
            break;

        case CONNECT_ACKNOWLEDGE:
            SendConnectAcknowledge ();
            if (Packet_Pending != CONNECT_ACKNOWLEDGE)
            {
                 /*
                 **    If the CONNECT ACK packet was sent, notify the owner
                 */
                connect_struct.dlci = DLC_Identifier;
                connect_struct.priority = Priority;
                connect_struct.datalink_struct = &DataLink_Struct;

                 /*
                 **    Convert t200 to milliseconds
                 */
                DataLink_Struct.t200 *= 100;
                m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_CONNECT_CONFIRM, 0, 0, &connect_struct);
                DataLink_Struct.t200 /= 100;
            }
            break;

        case RELEASE_COMPLETE:
            SendReleaseComplete ();
            if (Packet_Pending != RELEASE_COMPLETE)
            {
                 /*
                 **    If the RELEASE COMPLETE packet was sent, notify 
                 **    the owner
                 */
                m_pSCF->OwnerCallback(m_nMsgBase + NETWORK_DISCONNECT_INDICATION,
                                      (void *) DLC_Identifier,
                                      (void *) ((((ULONG_PTR) Link_Originator) << 16) | Release_Cause));
            }
            break;
        }
            
        if (Packet_Pending != NO_PACKET)
            *pending_data = PROTOCOL_CONTROL_DATA;
        else
            *pending_data = 0;
    }

    return;
}


/*    
 *    void    SCFCall::SendSetup (void);
 *
 *    Functional Description
 *        This function attempts to send out a SETUP packet.  The T303 timer
 *        is started.  If a CONNECT is not received before the timer expires,
 *        we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a SETUP packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 */
void    SCFCall::SendSetup (void)
{
    TRACE_OUT(("SCFCall::SendSetup"));

    LPBYTE    packet_address;
    ULONG    bytes_accepted;
    USHORT    total_length;
    PMemory    memory;

    total_length = SETUP_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = (UChar) Call_Reference;
    *(packet_address++) = SETUP;

     /*
     **    Bearer Capability
     */
    *(packet_address++) = BEARER_CAPABILITY;
    *(packet_address++) = 3;
    *(packet_address++) = 
        EXTENSION | CODING_STANDARD | INFORMATION_TRANSFER_CAPABILITY;
    *(packet_address++) = EXTENSION | TRANSFER_MODE;
    *(packet_address++) = EXTENSION | LAYER_2_IDENT | USER_INFORMATION_LAYER_2;
    
     /*
     **    DLCI
     */
    *(packet_address++) = DLCI_ELEMENT;
    *(packet_address++) = 2;
    *(packet_address++) = (DLC_Identifier >> 4);
    *(packet_address++) = EXTENSION | ((DLC_Identifier & 0x0f) << 3);

     /*
     **    Link Layer Core Parameters
     */
    *(packet_address++) = LINK_LAYER_CORE_PARAMETERS;
    *(packet_address++) = 3;
    *(packet_address++) = FMIF_SIZE;
    *(packet_address++) = (DataLink_Struct.n201 >> 7);
    *(packet_address++) = EXTENSION | (DataLink_Struct.n201 & 0x7f);

     /*
     **    Link Layer Protocol Parameters
     */
    *(packet_address++) = LINK_LAYER_PROTOCOL_PARAMETERS;
    *(packet_address++) = 5;
    *(packet_address++) = TRANSMIT_WINDOW_SIZE_IDENTIFIER;
    *(packet_address++) = EXTENSION | DataLink_Struct.k_factor;
    *(packet_address++) = RETRANSMISSION_TIMER_IDENTIFIER;
    *(packet_address++) = (DataLink_Struct.t200 >> 7) & 0x7f;
    *(packet_address++) = EXTENSION | (DataLink_Struct.t200 & 0x7f);

     /*
     **    X.213 Priority
     */
    *(packet_address++) = X213_PRIORITY;
    *(packet_address++) = 2;
    *(packet_address++) = (UChar) Priority;

     /*
     **    The next byte contains the lowest priority acceptable, 0
     */
    *(packet_address++) = EXTENSION | 0;

     /*
     **    Attempt to send the packet down
     */
    Lower_Layer -> DataRequest (
                            0,
                            memory,
                            &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        T303_Count = 0;
        Packet_Pending = NO_PACKET;
        State = SETUP_SENT;
        StartTimerT303 ();
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendConnect (void);
 *
 *    Functional Description
 *        This function attempts to send out a CONNECT packet.  The T313 timer
 *        is started.  If a CONNECT ACK is not received before the timer expires,
 *        we terminate the link. 
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a CONNECT packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendConnect (void)
{
    TRACE_OUT(("SCFCall::SendConnect"));

    LPBYTE        packet_address;
    LPBYTE        length_address;
    ULONG        bytes_accepted;
    USHORT        total_length;
    PMemory        memory;

    total_length = CONNECT_PACKET_BASE_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;

    if (Received_N201)
        total_length += 5;

    if (Received_K_Factor || Received_T200)
    {
        total_length += 2;

        if (Received_K_Factor)
            total_length += 2;
        if (Received_T200)
            total_length += 3;
    }
    if (Received_Priority)
        total_length += 3;

     /*
     **    Prepare the CONNECT command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = REMOTE_CALL_REFERENCE | Call_Reference;
    *(packet_address++) = CONNECT;

     /*
     **    DLCI
     */
    *(packet_address++) = DLCI_ELEMENT;
    *(packet_address++) = 2;
    *(packet_address++) = PREFERRED_EXCLUSIVE | (DLC_Identifier >> 4);
    *(packet_address++) = EXTENSION | ((DLC_Identifier & 0x0f) << 3);

    if (Received_N201)
    {
         /*
         **    Link Layer Core Parameters
         */
        *(packet_address++) = LINK_LAYER_CORE_PARAMETERS;
        *(packet_address++) = 3;
        *(packet_address++) = FMIF_SIZE;
        *(packet_address++) = (DataLink_Struct.n201 >> 7);
        *(packet_address++) = EXTENSION | (DataLink_Struct.n201 & 0x7f);
    }
    else
        DataLink_Struct.n201 = DataLink_Struct.default_n201;


    if (Received_K_Factor || Received_T200)
    {
         /*
         **    Link Layer Protocol Parameters
         */
        *(packet_address++) = LINK_LAYER_PROTOCOL_PARAMETERS;
        length_address = packet_address;
        *(packet_address++) = 0;
        if (Received_K_Factor)
        {
            *length_address += 2;
            *(packet_address++) = TRANSMIT_WINDOW_SIZE_IDENTIFIER;
            *(packet_address++) = EXTENSION | DataLink_Struct.k_factor;
        }
        if (Received_T200)
        {
            *length_address += 3;
            *(packet_address++) = RETRANSMISSION_TIMER_IDENTIFIER;
            *(packet_address++) = (DataLink_Struct.t200 >> 7) & 0x7f;
            *(packet_address++) = EXTENSION | (DataLink_Struct.t200 & 0x7f);
        }
    }
    if (Received_K_Factor == FALSE)
        DataLink_Struct.k_factor = DataLink_Struct.default_k_factor;
    if (Received_T200 == FALSE)
        DataLink_Struct.t200 = DataLink_Struct.default_t200;

    if (Received_Priority)
    {
         /*
         **    X.213 Priority
         */
        *(packet_address++) = X213_PRIORITY;
        *(packet_address++) = 1;
        *(packet_address++) = (BYTE) (EXTENSION | Priority);
    }
    
     /*
     **    Attempt to send the packet to the lower layer
     */
    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        StartTimerT313 ();
        Packet_Pending = NO_PACKET;
        State = CONNECT_SENT;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendConnectAcknowledge (void);
 *
 *    Functional Description
 *        This function attempts to send out a CONNECT ACKNOWLEDGE packet
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send the packet to the lower layer,
 *        it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendConnectAcknowledge (void)
{
    TRACE_OUT(("SCFCall::SendConnectAcknowledge"));

    LPBYTE        packet_address;
    USHORT        total_length;
    PMemory        memory;
    ULONG        bytes_accepted;

    total_length = CONNECT_ACK_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;
     /*
     **    Prepare the command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    *(packet_address++) = (UChar) Call_Reference;
    *(packet_address++) = CONNECT_ACKNOWLEDGE;

    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        State = CALL_ESTABLISHED;
        Packet_Pending = NO_PACKET;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::SendReleaseComplete (void);
 *
 *    Functional Description
 *        This function attempts to send out a RELEASE COMPLETE packet
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        If this function is able to send a RELEASE COMPLETE packet to the lower
 *        layer, it sets the Packet_Pending variable to NO_PACKET
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::SendReleaseComplete (void)
{
    TRACE_OUT(("SCFCall::SendReleaseComplete"));

    LPBYTE    packet_address;
    ULONG    bytes_accepted;
    USHORT    total_length;
    PMemory    memory;

    total_length = RELEASE_COMPLETE_PACKET_SIZE + Lower_Layer_Prepend +
                    Lower_Layer_Append;
     /*
     **    Prepare the command and send it to the lower layer
     */
    memory = Data_Request_Memory_Manager -> AllocateMemory (
                                NULL,
                                total_length);
    if (memory == NULL)
        return;

    packet_address = memory -> GetPointer ();
    packet_address += Lower_Layer_Prepend;

    *(packet_address++) = Q931_PROTOCOL_DISCRIMINATOR;
    *(packet_address++) = 1;
    if (Link_Originator)
        *(packet_address++) = (UChar) Call_Reference;
    else
        *(packet_address++) = 0x80 | Call_Reference;
    *(packet_address++) = RELEASE_COMPLETE;


     /*
     **    Append the CAUSE for the link breakup
     */
    *(packet_address++) = CAUSE;
    *(packet_address++) = 2;    
    *(packet_address++) = EXTENSION;
    *(packet_address++) = EXTENSION | Release_Cause;

    Lower_Layer -> DataRequest (
                    0,
                    memory,
                    &bytes_accepted);
    if (bytes_accepted == total_length)
    {
        State = NOT_CONNECTED;
        Packet_Pending = NO_PACKET;
    }
    Data_Request_Memory_Manager -> FreeMemory (memory);
}


/*    
 *    void    SCFCall::StartTimerT303 (void);
 *
 *    Functional Description
 *        This function Starts the T303 Timer.  This is started when we send
 *        out the SETUP packet.  It is stopped when we receive a CONNECT
 *        packet.  If it expires we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void SCFCall::StartTimerT303 (void)
{
    TRACE_OUT(("SCFCall::StartTimerT303"));

    if (T303_Active)
        StopTimerT303 ();

    T303_Handle = g_pSystemTimer->CreateTimerEvent(
                    T303_Timeout,
                    TIMER_EVENT_ONE_SHOT,
                    this,
                    (PTimerFunction) &SCFCall::T303Timeout);

    T303_Active = TRUE;

}


/*    
 *    void    SCFCall::StopTimerT303 (void);
 *
 *    Functional Description
 *        This function stops the T303 Timer.  This is called when we receive
 *        the CONNECT packet.  As a result, we stop the timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StopTimerT303 (void)
{
    TRACE_OUT(("SCFCall::StopTimerT303"));

    if (T303_Active)
    {
        g_pSystemTimer->DeleteTimerEvent(T303_Handle);
        T303_Active = FALSE;
    }
}


/*    
 *    void    SCFCall::T303Timeout (
 *                        TimerEventHandle);
 *
 *    Functional Description
 *        This function is called by the System timer when the T303 timeout
 *        expires.  As a result, we terminate the link.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::T303Timeout (
                    TimerEventHandle)
{
    TRACE_OUT(("SCFCall: T303Timeout"));

    if (T303_Count >= 1)
        State = NOT_CONNECTED;

    T303_Count++;

    Packet_Pending = RELEASE_COMPLETE;
    Release_Cause = NORMAL_USER_DISCONNECT;
}


/*    
 *    void    SCFCall::StartTimerT313 (void);
 *
 *    Functional Description
 *        This function Starts the T313 Timer.  This is started when we send
 *        out the CONNECT packet.  It is stopped when we receive a CONNECT ACK
 *        packet.  If it expires we terminate the link.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StartTimerT313 (void)
{
    TRACE_OUT(("SCFCall: StartTimerT313"));

    if (T313_Active)
        StopTimerT313 ();

    T313_Handle = g_pSystemTimer->CreateTimerEvent(
                    T313_Timeout, 
                    TIMER_EVENT_ONE_SHOT,
                    this,
                    (PTimerFunction) &SCFCall::T313Timeout);

    T313_Active = TRUE;
}


/*    
 *    void    SCFCall::StopTimerT313 (void);
 *
 *    Functional Description
 *        This function stops the T313 Timer.  This is called when we receive
 *        the CONNECT ACK packet.  As a result, we stop the timer.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::StopTimerT313 (void)
{
    TRACE_OUT(("SCFCall: StopTimerT313"));

    if (T313_Active)
    {
        g_pSystemTimer->DeleteTimerEvent(T313_Handle);
        T313_Active = FALSE;
    }
}


/*    
 *    void    SCFCall::T313Timeout (
 *                        TimerEventHandle);
 *
 *    Functional Description
 *        This function is called by the System timer when the T313 timeout
 *        expires.  As a result, we terminate the link.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
void    SCFCall::T313Timeout (
                    TimerEventHandle)
{
    TRACE_OUT(("SCFCall: T313Timeout"));

    State = NOT_CONNECTED;
    Packet_Pending = RELEASE_COMPLETE;
    Release_Cause = NORMAL_USER_DISCONNECT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\scfcall.h ===
/*    SCFCall.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class is instantiated to represent a call under the SCF.  
 *        Each call is identified by a call reference value.  This class
 *        sends and receives the packets necessary to negotiate a connection.
 *    
 *    Caveats:
 *
 *    Authors:
 *        James W. Lawwill
 */


#ifndef _SCFCall_H_
#define _SCFCall_H_

#include "q922.h"
#include "scf.h"

#define    SETUP_PACKET_SIZE                29
#define    CONNECT_PACKET_BASE_SIZE        8
#define    CONNECT_ACK_PACKET_SIZE            4
#define    RELEASE_COMPLETE_PACKET_SIZE    8

 /*
 **    A CallReference is a number that represents a network request.
 */
typedef    USHORT    CallReference;

 /*
 **    DataLink Parameters that can be negotiated by the SCF
 */
typedef struct
{
    USHORT    k_factor;
    USHORT    n201;
    USHORT    t200;
    USHORT    default_k_factor;
    USHORT    default_n201;
    USHORT    default_t200;
} DataLinkParameters;
typedef    DataLinkParameters *    PDataLinkParameters;

 /*
 **    Structure passed during Connect Callbacks
 */
typedef struct
{
    DLCI                dlci;
    TransportPriority    priority;
    CallReference        call_reference;
    PDataLinkParameters    datalink_struct;
}    NetworkConnectStruct;
typedef    NetworkConnectStruct    *    PNetworkConnectStruct;

 /*
 **    States that the call can be in
 */
typedef enum 
{
    NOT_CONNECTED,
    SETUP_SENT,
    CONNECT_SENT,
    CALL_ESTABLISHED
}    SCFCallState;


 /*
 **    Error values
 */
typedef enum 
{
    SCFCALL_NO_ERROR
}     SCFCallError;

class SCFCall : public IObject
{
public:

    SCFCall (
        CLayerSCF            *owner_object,
        IProtocolLayer *        lower_layer,
        USHORT                message_base,
        PDataLinkParameters   datalink_parameters,
        PMemoryManager        memory_manager,
        BOOL *            initialized);
    ~SCFCall (void);

         /*
         **    This routine gives us a slice of time to transmit packets
         */
        void                PollTransmitter (
                                USHORT    data_to_transmit,
                                USHORT *    pending_data);

         /*
         **    Link establishment
         */
        SCFCallError        ConnectRequest (
                                CallReference        call_reference,
                                DLCI                dlci,
                                TransportPriority    priority);
        SCFCallError        ConnectResponse (
                                BOOL    valid_dlci);
        SCFCallError        DisconnectRequest (void);

         /*
         **    Packet processing
         */
        BOOL            ProcessSetup (
                                CallReference    call_reference,
                                LPBYTE            packet_address,
                                USHORT            packet_length);
        BOOL            ProcessConnect (
                                LPBYTE    packet_address,
                                USHORT    packet_length);
        BOOL            ProcessConnectAcknowledge (
                                LPBYTE    packet_address,
                                USHORT    packet_length);
        BOOL            ProcessReleaseComplete (
                                LPBYTE    packet_address,
                                USHORT    packet_length);

    private:
        void            SendSetup (void);
        void            SendConnect (void);
        void            SendReleaseComplete (void);
        void            SendConnectAcknowledge (void);


        void            StartTimerT313 (void);
        void            StopTimerT313 (void);
        void            T313Timeout (
                            TimerEventHandle);
        void            StartTimerT303 (void);
        void            StopTimerT303 (void);
        void            T303Timeout (
                            TimerEventHandle);

        CLayerSCF           *m_pSCF;
        IProtocolLayer *        Lower_Layer;
        USHORT                m_nMsgBase;
        USHORT                Packet_Pending;
        BOOL            Link_Originator;
        DataLinkParameters    DataLink_Struct;
        USHORT                Maximum_Packet_Size;
        USHORT                Lower_Layer_Prepend;
        USHORT                Lower_Layer_Append;

        BOOL            Received_Priority;
        BOOL            Received_K_Factor;
        BOOL            Received_N201;
        BOOL            Received_T200;
        PMemoryManager        Data_Request_Memory_Manager;

        CallReference        Call_Reference;
        DLCI                DLC_Identifier;
        TransportPriority    Priority;
        TransportPriority    Default_Priority;

        SCFCallState        State;
        USHORT                Release_Cause;

        ULONG                T303_Timeout;
        TimerEventHandle    T303_Handle;
        BOOL            T303_Active;
        USHORT                T303_Count;

        ULONG                T313_Timeout;        
        TimerEventHandle    T313_Handle;
        BOOL            T313_Active;

};
typedef    SCFCall *        PSCFCall;

#endif


/*
 *    Documentation for Public class members
 */

/*    
 *    SCFCall::SCFCall (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                PChar                config_file,
 *                PDataLinkParameters    datalink_parameters,
 *                PMemoryManager        memory_manager,
 *                BOOL *            initialized);
 *
 *    Functional Description
 *        This is the constructor for the SCFCall class.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object    (i)    -    Address of the owner object
 *        lower_layer        (i)    -    Address of our lower layer
 *        message_base    (i)    -    Message base used in owner callbacks
 *        config_file        (i)    -    Address of configuration file path
 *        datalink_parameters    (i)    -    Address of structure containing datalink
 *                                    parameters that will be arbitrated
 *        memory_manager    (i)    -    Address of memory manager
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCall::~SCFCall ();
 *
 *    Functional Description
 *        Destructor
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    void    SCFCall::PollTransmitter (
 *                        USHORT    data_to_transmit,
 *                        USHORT *    pending_data);
 *
 *    Functional Description
 *        This function gives the class a time slice to transmit data
 *
 *    Formal Parameters
 *        data_to_transmit    (i)    -    Flags representing data to transmit
 *        pending_data        (o)    -    Return flags of data transmitted
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::ConnectRequest (
 *                                CallReference    call_reference,
 *                                DLCI            dlci,
 *                                USHORT            priority);
 *
 *    Functional Description
 *        This function informs us to initiate a connection with the remote
 *        SCF.  As a result of this, we send a SETUP packet to the remote
 *        machine
 *
 *    Formal Parameters
 *        call_reference        (i)    -    Unique value that differentiates our
 *                                    call from other calls.  This value goes in
 *                                    all Q.933 packets.
 *        dlci                (i)    -    Suggested dlci value.
 *        priority            (i)    -    Suggested priority in the range of 0 to 14.
 *                                    14 is the highest priority
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::ConnectResponse (
 *                                BOOL    valid_dlci);
 *
 *    Functional Description
 *        This function is called in response to a NETWORK_CONNECT_INDICATION
 *        callback to the owner of this object.  Previously, the remote site
 *        sent us a SETUP packet with a suggested DLCI.  This DLCI is sent to 
 *        the owner in the NETWORK_CONNECT_INDICATION call.  The owner calls
 *        this function with a BOOL, telling us if the DLCI was valid.
 *
 *    Formal Parameters
 *        valid_dlci        (i)    -    This is set to TRUE if the user wants to accept
 *                                this call and use the suggested DLCI, FALSE 
 *                                if not.
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    SCFCallError    SCFCall::DisconnectRequest (
 *                                void);
 *
 *    Functional Description
 *        This function is called to release the call.  In response to this 
 *        function, we send out a RELEASE COMPLETE packet to the remote site.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        SCFCALL_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessSetup (
 *                            CallReference    call_reference,
 *                            LPBYTE            packet_address,
 *                            USHORT            packet_length);
 *
 *    Functional Description
 *        This function is called when we have a SETUP packet to decode.
 *
 *    Formal Parameters
 *        call_reference    (i)    -    The call reference attached to the packet.
 *        packet_address    (i)    -    Address of the SETUP packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 SETUP packet or
 *                        the packet was not expected
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessConnect (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a CONNECT packet to decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT packet or
 *                        the packet was not expected
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessConnectAcknowledge (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a CONNECT ACK packet to decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT ACK packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT ACK packet
 *                        or the packet was not expected.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    BOOL    SCFCall::ProcessReleaseComplete (
 *                            LPBYTE    packet_address,
 *                            USHORT    packet_length);
 *
 *    Functional Description
 *        This function is called when we have a RELEASE COMPLETE packet to 
 *        decode.
 *
 *    Formal Parameters
 *        packet_address    (i)    -    Address of the CONNECT ACK packet
 *        packet_length    (i)    -    Length of the passed in packet.
 *
 *    Return Value
 *        TRUE        -    Valid packet
 *        FALSE        -    The packet was not a valid Q.933 CONNECT ACK packet
 *                        or the packet was not expected.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\slist2.h ===
/*	slist.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a single linked list data structure.
 *	The values in a list are DWORD values.  So, for example, if the
 *  value is really a pointer, it has to be converted into a DWORD before being passed into a
 *  member list function.
 *
 */

#ifndef _SINGLE_LIST2_H_
#define _SINGLE_LIST2_H_

#include <windows.h>


#define DEFAULT_NUMBER_OF_ITEMS			15


class SListClass
{

public:
	SListClass (DWORD num_of_items = DEFAULT_NUMBER_OF_ITEMS);
	~SListClass ();
	void append (DWORD_PTR new_key);
	BOOL find (DWORD_PTR Key);
	DWORD_PTR read (DWORD index = 0);
	DWORD_PTR get ();
	DWORD_PTR removeLast ();
	BOOL iterate (DWORD_PTR *pKey);
	void prepend (DWORD_PTR new_key);
	void remove (DWORD_PTR Key);

	void reset () {	CurrOffset = 0xFFFFFFFF; };		// resets the list iterator
	DWORD entries () { return NumOfEntries; };		
													// returns the number of entries in the list
	void clear () { NumOfEntries = 0; HeadOffset = 0; CurrOffset = 0xFFFFFFFF; };
													// clears up the list. The list contains no values afterwards.
	BOOL isEmpty () { return ((NumOfEntries == 0) ? TRUE : FALSE); };

private:
	DWORD				NumOfEntries;	// current # of entries in the list
	DWORD				MaxEntries;		// max # of entries that the array can hold
	DWORD_PTR			*Entries;		// Circular array of entries
	DWORD				HeadOffset;		// Offset of the 1st entry in the circular array
	DWORD				CurrOffset;		// Iterator value

	BOOL Expand (void);
};

typedef SListClass * PSListClass;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\slist2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*	slist.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a linked list data structure.
 *
 */


#define MyMalloc(size)	LocalAlloc (LMEM_FIXED, (size))
#define MyFree(ptr)		LocalFree ((HLOCAL) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))

/*  Function:  Constructor
 *
 *	Parameters:
 *		ltype:			List type
 *		num_of_items:	Size of the list's cache
 *
 *	Return value:
 *		None
 */

SListClass::SListClass (DWORD num_of_items)
{

	MaxEntries = Max (num_of_items, DEFAULT_NUMBER_OF_ITEMS);

	// Allocate the block of items (which, hopefully, will be the last one)
	Entries = (DWORD_PTR *) MyMalloc (MaxEntries * sizeof (DWORD_PTR));

	// Initialize the private member variables
	NumOfEntries = 0;
	HeadOffset = 0;
	CurrOffset = 0xFFFFFFFF;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */

SListClass::~SListClass (void)
{
	if (Entries != NULL)
		MyFree (Entries);
}


/*  Function:  Expand
 *		This private member function, expands the storage array of a list.  It doubles its size.
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		TRUE, if the expansion was successful.  FALSE, otherwise.
 *
 */

BOOL SListClass::Expand (void)
{
	DWORD_PTR	*OldEntries;	// Keeps a copy of the old array of values.
	DWORD		 dwTemp;		// Temporary DWORD value

	if (Entries == NULL) {
		// the list is empty; we try to allocate space anyway.
		Entries = (DWORD_PTR *) MyMalloc (MaxEntries * sizeof (DWORD_PTR));
		if (Entries == NULL)
			return FALSE;
		return TRUE;
	}
		
	ASSERT (Entries != NULL);

	// The current array of entries is full, so we need to allocate a bigger one
	// The new array has twice the size of the old one
	OldEntries = Entries;
	Entries = (DWORD_PTR *) MyMalloc ((MaxEntries << 1) * sizeof (DWORD_PTR));
	if (Entries == NULL) {
		// we failed; we have to return
		Entries = OldEntries;
		return FALSE;
	}

	// copy the old entries into the new array, starting from the beginning
	dwTemp = MaxEntries - HeadOffset;
	memcpy ((void *) Entries, (void *) (OldEntries + HeadOffset), dwTemp * sizeof (DWORD));
	memcpy ((void *) (Entries + dwTemp), (void *) OldEntries, HeadOffset * sizeof (DWORD));

	// Free the old array of entries
	MyFree (OldEntries);

	// Set the instance variables
	MaxEntries <<= 1;
	HeadOffset = 0;
	return TRUE;
}


/*  Function:  append
 *		Inserts a value at the end of a list.
 *
 *	Parameters:
 *		new_key:	The new value that has to be inserted in the list
 *
 *	Return value:
 *		None.
 *
 */


void SListClass::append (DWORD_PTR new_key)
{
	DWORD_PTR		dwTemp;

	if (Entries == NULL || NumOfEntries >= MaxEntries)
		if (! Expand ())
			return;

	ASSERT (Entries != NULL);
	ASSERT (NumOfEntries < MaxEntries);

	dwTemp = HeadOffset + (NumOfEntries++);
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;
	Entries[dwTemp] = new_key;
}


/*  Function:  prepend
 *		Inserts a value at the beginning of a list.
 *
 *	Parameters:
 *		new_key:	The new value that has to be inserted in the list
 *
 *	Return value:
 *		None.
 *
 */

void SListClass::prepend (DWORD_PTR new_key)
{
	if (Entries == NULL || NumOfEntries >= MaxEntries)
		if (! Expand ())
			return;

	ASSERT (Entries != NULL);
	ASSERT (NumOfEntries < MaxEntries);

	NumOfEntries++;
	if (HeadOffset == 0)
		HeadOffset = MaxEntries - 1;
	else
		HeadOffset--;
	Entries[HeadOffset] = new_key;
}


/*  Function:  find
 *		Looks up a value in a DWORD_LIST list.
 *
 *	Parameters:
 *		Key:	The value to look up
 *
 *	Return value:
 *		TRUE, if "Key" is found in the list. FALSE, otherwise.
 *
 */

BOOL SListClass::find (DWORD_PTR Key)
{
	DWORD	i;
	DWORD_PTR *pItem;	// Goes through the items in the list.

	for (i = 0, pItem = Entries + HeadOffset; i < NumOfEntries; i++) {
		if (Key == *pItem)
			return TRUE;

		// Advance the "pItem" pointer
		if ((DWORD) (++pItem - Entries) >= MaxEntries)
			pItem = Entries;
	}
	return FALSE;
}


/*  Function:  read
 *		Reads an item from the list. The list item is not removed from the list.
 *
 *	Parameters:
 *		index:	Index of the item to be read. 0 is the index of the 1st list item.
 *				NumOfEntries - 1 is the last valid index.
 *
 *	Return value:
 *		The value at the index-th entry in the list. If the index is invalid, 0.
 *
 */

DWORD_PTR SListClass::read (DWORD index)
{
	DWORD	dwTemp;

	if (index >= NumOfEntries)
		return 0;

	dwTemp = HeadOffset + index;
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;

	return (Entries[dwTemp]);
}


/*  Function:  remove
 *		Removes a value from the list
 *
 *	Parameters:
 *		Key:	The value that has to be removed from the DWORD_LIST list
 *
 *	Return value:
 *		None.
 *
 */

void SListClass::remove (DWORD_PTR Key)
{
	DWORD	i, dwTemp;
	DWORD_PTR *pItem;		// Goes through the list items

	for (i = 0, pItem = Entries + HeadOffset; i < NumOfEntries; i++) {
		if (Key == *pItem) {
			// we found the "Key"; to remove it, we move the last value into its place.
			dwTemp = HeadOffset + (--NumOfEntries);
			if (dwTemp >= MaxEntries)
				dwTemp -= MaxEntries;
			*pItem = Entries[dwTemp];
			return;
		}

		// Advance the "pItem" pointer
		if ((DWORD) (++pItem - Entries) >= MaxEntries)
			pItem = Entries;	
	}
}


/*  Function:  get
 *		Reads and removes the 1st item from the list.
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		The value at the 1st entry in the list. If the list is empty, 0.
 *
 */

DWORD_PTR SListClass::get (void)
{
	DWORD_PTR	return_value = 0;

	if (NumOfEntries > 0) {
		return_value = Entries[HeadOffset];
		NumOfEntries--;
		if (++HeadOffset >= MaxEntries)
			HeadOffset = 0;
	}
	return return_value;
}


/*  Function:  removeLast
 *		Reads and removes the last item from the list
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		The value at the last entry in the list. If the list is empty, 0.
 *
 */

DWORD_PTR SListClass::removeLast (void)
{
	DWORD_PTR	return_value = 0;
	DWORD	dwTemp;

	if (NumOfEntries > 0) {
		dwTemp = HeadOffset + (--NumOfEntries);
		if (dwTemp >= MaxEntries)
			dwTemp -= MaxEntries;
		return_value = Entries[dwTemp];
	}
	return return_value;
}


/* Function:  iterate
 *		Iterates through the items of a list.  It remembers where it has
 *		stopped during the last call and starts from there.
 *
 * Parameters
 *		pKey:	Pointer to DWORD or unsigned short value to receive the next item's value.
 *				It can be NULL.
 *
 * Return value:
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey is valid
 *
 */

BOOL SListClass::iterate (DWORD_PTR *pKey)
{
	DWORD		dwTemp;

	if (NumOfEntries <= 0)
		return FALSE;

	if (CurrOffset == 0xFFFFFFFF) {
		// start from the beginning
		CurrOffset = 0;
	}
	else {
		if (++CurrOffset >= NumOfEntries) {
			// reset the iterator
			CurrOffset = 0xFFFFFFFF;
			return FALSE;
		}
	}

	dwTemp = CurrOffset + HeadOffset;
	if (dwTemp >= MaxEntries)
		dwTemp -= MaxEntries;

	*pKey = Entries[dwTemp];
	
	return TRUE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\t123.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    T123.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the T123 class.
 *
 *        Beware::
 *            When we refer to a Transport in this class, we are
 *            talking about X224/Class 0.
 *
 *            When we refer to a DataLink in this class, we are
 *            talking about the Q922 Layer.
 *
 *    Private Instance Variables:
 *        Logical_Connection_List    -    This list uses the logical_handle as the
 *                                key and a DLCI as the value.  From the DLCI we
 *                                can determine the specifics about the logical
 *                                connection
 *        DLCI_List            -    This list uses a DLCI as the key and a
 *                                DLCIStruct as the value.  The DLCIStruct holds
 *                                all of the important information about the
 *                                DLCI connection
 *        Message_List        -    List used to hold owner callback information
 *                                that can not be processed immediately.
 *        DataLink_List        -    This is a list of all the DataLink connections.
 *                                We keep a seperate list so that during the
 *                                PollTransmitter() call, we can round-robin thru
 *                                the list, giving each DataLink a chance to
 *                                transmit.
 *        Transport_Priority_List-    This is a prioritized list of DLCIs
 *                                    During PollTransmitter() we    process the
 *                                    logical connections in priority order.
 *
 *        m_pController        -    Address of the owner object
 *        Link_Originator        -    TRUE if we originated the physical connection
 *        m_nMsgBase        -    Message base used in the owner callback.
 *        Identifier            -    Identifier to be passed back in the owner
 *                                callback
 *        m_pSCF        -    Address of the network layer associated with
 *                                this T123 stack.
 *        m_pQ922        -    Address of DataLink Layer associated with the
 *                                Network Layer (DLCI 0).
 *        m_pMultiplexer    -    Address of Multiplexer layer
 *        m_pComPort        -    Address of physical layer
 *        m_hCommLink        -    Physical handle used to access the physical
 *                                layer.
 *        DataLink_Struct        -    Holds default Q922 values.
 *        Data_Request_Memory_Manager    -    Holds the memory manager for the DLCI0
 *                                DataLink.
 *        Random                -    Random number generator
 *        Disconnect_Requested-    TRUE, if the user has requested that the
 *                                complete stack be taken down.
 *
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James W. Lawwill
 */
#include "t123.h"
#include "pstnfram.h"
#include "crc.h"

#define    PSTN_DATALINK_MAX_OUTSTANDING_BYTES    1024
#define    TRANSPORT_DEFAULT_PDU_SIZE            128
#define    DEFAULT_PSTN_N201                     260
#define    TRANSPORT_MAXIMUM_USER_DATA_SIZE    256
#define    NETWORK_RETRIES                        20
#define    NUMBER_8K_BLOCKS                    1
#define    NUMBER_64_BYTE_BLOCKS                64
#define    DEFAULT_MAXIMUM_OUTSTANDING_PACKETS    20
#define DEFAULT_T200_TIMEOUT                3000
#define DEFAULT_T200_COMM_TIMEOUT            500


/*
 *    T123::T123 (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            USHORT                message_base,
 *            BOOL                link_originator,
 *            IProtocolLayer *        physical_layer,
 *            PhysicalHandle        physical_handle,
 *            BOOL *                t123_initialized)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the T123 constructor.  It instantiates the multiplexer.
 */
T123::T123
(
    TransportController    *owner_object,
    USHORT                  message_base,
    BOOL                    link_originator,
    ComPort                *comport, // physical layer
    PhysicalHandle          hCommLink, // physical handle
    PLUGXPRT_PARAMETERS    *pParams,
    BOOL *                  t123_initialized
)
:
    Logical_Connection_List (TRANSPORT_HASHING_BUCKETS),
    DLCI_List (TRANSPORT_HASHING_BUCKETS),
    DataLink_List (),
    m_pController(owner_object),
    m_nMsgBase(message_base),
    m_hCommLink(hCommLink),
    m_pComPort(comport)
{
    TRACE_OUT(("T123::T123"));

    PPacketFrame    framer;
    PCRC            crc;
    BOOL            initialized;
    DWORD            i;

    // SDK parameters
    if (NULL != pParams)
    {
        m_fValidSDKParams = TRUE;
        m_SDKParams = *pParams;
    }
    else
    {
        m_fValidSDKParams = FALSE;
        ::ZeroMemory(&m_SDKParams, sizeof(m_SDKParams));
    }

    // initialize priority list
    for (i = 0; i < NUMBER_OF_PRIORITIES; i++)
    {
        DBG_SAVE_FILE_LINE
        Logical_Connection_Priority_List[i] = new SListClass;
    }

    Link_Originator = link_originator;
    Disconnect_Requested = FALSE;

    m_pSCF = NULL;
    m_pQ922 = NULL;
    Data_Request_Memory_Manager = NULL;
    m_pMultiplexer = NULL;
    *t123_initialized = TRUE;

    DataLink_Struct.default_k_factor = DEFAULT_MAXIMUM_OUTSTANDING_PACKETS;
    DataLink_Struct.default_n201 = DEFAULT_PSTN_N201;
    ULONG baud_rate = m_pComPort->GetBaudRate();
    DataLink_Struct.default_t200 = ((m_pComPort->GetCallControlType() == PLUGXPRT_PSTN_CALL_CONTROL_MANUAL) ?
                                    ((baud_rate  < CBR_2400 ) ?
                                    DEFAULT_T200_COMM_TIMEOUT << 4 : DEFAULT_T200_COMM_TIMEOUT ): DEFAULT_T200_TIMEOUT);

    TRACE_OUT(("T123: Defaults: k = %d  n201 = %d  t200 = %d",
        DataLink_Struct.default_k_factor,
        DataLink_Struct.default_n201,
        DataLink_Struct.default_t200));

    DataLink_Struct.k_factor = DEFAULT_MAXIMUM_OUTSTANDING_PACKETS;
    DataLink_Struct.n201 =     DEFAULT_PSTN_N201;
    DataLink_Struct.t200 =     DataLink_Struct.default_t200;

     /*
     **    Create the CRC object and pass it to the Multiplexer.
     **    Create a framer and send it to the Multiplexer.
     */
    DBG_SAVE_FILE_LINE
    crc = new CRC ();
    if (crc != NULL)
    {
        DBG_SAVE_FILE_LINE
        framer = (PPacketFrame) new PSTNFrame ();
        if (framer != NULL)
        {
            DBG_SAVE_FILE_LINE
            m_pMultiplexer = new Multiplexer(
                                        this,
                                        m_pComPort,
                                        m_hCommLink,
                                        MULTIPLEXER_LAYER_MESSAGE_BASE,
                                        framer,
                                        crc,
                                        &initialized);
            if (m_pMultiplexer != NULL && initialized)
            {
                 /*
                 **    Notify the Multiplexer layer to start a connection
                 */
                m_pMultiplexer->ConnectRequest();
            }
            else
            {
                 /*
                 **    To get here, either the m_pMultiplexer == NULL or
                 **    initialized == FALSE
                 */
                if (m_pMultiplexer != NULL)
                {
                    delete m_pMultiplexer;
                    m_pMultiplexer = NULL;
                }
                else
                {
                    delete crc;
                    delete framer;
                }
                *t123_initialized = FALSE;
            }
        }
        else
        {
            delete crc;
            *t123_initialized = FALSE;
        }
    }
    else
    {
        *t123_initialized = FALSE;
    }
}


/*
 *    T123::~T123 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the T123 object.  It releases all memory
 */
T123::~T123 (void)
{
    TRACE_OUT(("T123::~T123"));

    DWORD            i;

     /*
     **    Reset deletes all DataLink, Network, and Transport objects associated
     **    with this stack.
     */
    Reset ();

     /*
     **    Go thru the Message list and delete all passive owner callback messages
     */
    while (Message_List.isEmpty () == FALSE)
    {
        delete (PMessageStruct) Message_List.get ();
    }

     /*
     **    Delete the multiplexer layer
     */
    delete m_pMultiplexer;

    TRACE_OUT(("T123: Destructor"));

    for (i = 0; i < NUMBER_OF_PRIORITIES; i++)
        delete Logical_Connection_Priority_List[i];
}


/*
 *    TransportError    T123::ConnectRequest (
 *                            LogicalHandle        logical_handle,
 *                            TransportPriority    priority)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the function that initiates a logical connection with the
 *        remote site.
 */
TransportError    T123::ConnectRequest (
                        LogicalHandle        logical_handle,
                        TransportPriority    priority)
{
    TRACE_OUT(("T123::ConnectRequest"));

    PDLCIStruct        dlci_struct;
    DLCI            dlci;
    SCFError        network_error;
    TransportError    transport_error = TRANSPORT_NO_ERROR;

     /*
     **    Get a proposed DLCI for the connection
     */
    dlci = GetNextDLCI ();

     /*
     **    Add the new connection to the Logical_Connection_List
     */
    Logical_Connection_List.insert (logical_handle, (DWORD) dlci);

     /*
     **    Add the proposed DLCI to the DLCI_List
     **    Initialize all of the items in the DLCI structure
     */
    DBG_SAVE_FILE_LINE
    dlci_struct = new DLCIStruct;
    if (dlci_struct != NULL)
    {
        DLCI_List.insert ((DWORD_PTR) dlci, (DWORD_PTR) dlci_struct);
        dlci_struct -> link_originator = TRUE;
        dlci_struct -> x224 = NULL;  // X.224
        dlci_struct -> q922 = NULL; // Q.922
        dlci_struct -> priority = priority;
        dlci_struct -> connect_requested = FALSE;
        dlci_struct -> disconnect_requested = FALSE;
        dlci_struct -> data_request_memory_manager = NULL;
        dlci_struct -> network_retries = 0;
    }
    else
    {
         /*
         **    Remove this entry and send a message to the owner
         */
        NetworkDisconnectIndication (dlci, TRUE, FALSE);
        return (TRANSPORT_MEMORY_FAILURE);
    }

     /*
     **    If the Network Layer exists, issue a connect request
     **
     **    If the Network Layer does not exist yet, the connection will be
     **    requested at a later time.
     */
    if (m_pSCF != NULL)
    {
         /*
         **    Mark this DLCI as already submitting its ConnectRequest()
         */
        dlci_struct -> connect_requested = TRUE;
        network_error = m_pSCF->ConnectRequest(dlci, priority);
        if (network_error != SCF_NO_ERROR)
        {
             /*
             **    Remove this entry and send a message to the owner
             */
            NetworkDisconnectIndication (dlci, TRUE, FALSE);

            if (network_error == SCF_MEMORY_ALLOCATION_ERROR)
                return (TRANSPORT_MEMORY_FAILURE);
            else
                return (TRANSPORT_CONNECT_REQUEST_FAILED);
        }
    }

     /*
     **    Process any passive owner callbacks that may have occured
     */
    ProcessMessages ();

    return (transport_error);
}


/*
 *    TransportError    T123::ConnectResponse (
 *                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called in response to TPRT_CONNECT_INDICATION that we
 *        issued to the controller.  By making this call, the controller is
 *        accepting the incoming call.
 */
TransportError    T123::ConnectResponse (
                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("T123::ConnectResponse"));

    PDLCIStruct            dlci_struct;
    TransportError        return_value;
    DWORD_PTR             dwTempDLCI;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dwTempDLCI) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the Transport address from the DLCI_List and relay the call
     */
    DLCI_List.find (dwTempDLCI, (PDWORD_PTR) &dlci_struct);
    if (dlci_struct->x224 != NULL)
        return_value = dlci_struct->x224->ConnectResponse();
    else
        return_value = TRANSPORT_CONNECT_REQUEST_FAILED;

     /*
     **    Process any passive owner callbacks that may have been received
     */
    ProcessMessages ();
    return (return_value);
}


/*
 *    TransportError    T123::DisconnectRequest (
 *                            LogicalHandle    logical_handle,
 *                            BOOL            trash_packets)
 *
 *    Public
 *
 *    Functional Description:
 *        This function terminates the user's logical connection.
 */
TransportError    T123::DisconnectRequest (
                        LogicalHandle    logical_handle,
                        UINT_PTR            trash_packets)
{
    TRACE_OUT(("T123::DisconnectRequest"));

    Short        priority;
    DLCI        dlci;
    PDLCIStruct    dlci_struct;
    DWORD_PTR    dw_dlci;

    TRACE_OUT(("T123: DisconnectRequest: logical_handle = %d", logical_handle));

     /*
     **    If the logical_handle == INVALID_LOGICAL_HANDLE, the user is
     **    telling us to disconnect all logical connections including DLCI 0.
     */
    if (logical_handle == INVALID_LOGICAL_HANDLE)
    {
        Disconnect_Requested = TRUE;

        if (m_pQ922 != NULL)
            m_pQ922->ReleaseRequest();
        else
        {
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }

         /*
         **    For each priority level, clear the Priority list
         */
        for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
            Logical_Connection_Priority_List[priority]->clear ();

         /*
         **    Clear the Logical_Connection_List and DataLink_List
         */
        Logical_Connection_List.clear ();
        DataLink_List.clear ();

         /*
         **    Go thru each Transport and DataLink layer (excluding DLCI 0) and
         **    delete them.  Delete the DLCIStruct.  Finally, clear the list.
         */
        DLCI_List.reset();
        while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
        {
            delete dlci_struct -> x224;
            if (dlci_struct -> q922 != NULL)
            {
                delete dlci_struct -> q922;
                delete dlci_struct -> data_request_memory_manager;
            }
            delete dlci_struct;
        }
        DLCI_List.clear ();
        return (TRANSPORT_NO_ERROR);
    }

     /*
     **    Start breaking down the link from the Transport Layer down
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);
    dlci = (DLCI) dw_dlci;

     /*
     **    It is illegal for the user to ask us to preserve the user data when
     **    a Transport Layer doesn't even exist yet.
     */
    if ((trash_packets == FALSE) && ((dlci_struct -> x224) == NULL))
    {
        trash_packets = TRUE;
    }

    if (trash_packets)
    {
         /*
         **    If the Transport object exists, delete it and remove it from our
         **    lists.  It is no longer valid.
         */
        if ((dlci_struct -> x224) != NULL)
        {
            delete dlci_struct -> x224;
            dlci_struct -> x224 = NULL;
            Logical_Connection_Priority_List[dlci_struct->priority]->remove (dlci);
        }

         /*
         **    If the DataLink object exists, delete it and remove it from our
         **    lists.  It is no longer valid.
         */
        if (dlci_struct -> q922 != NULL)
        {
            delete dlci_struct -> q922;
            delete dlci_struct -> data_request_memory_manager;
            dlci_struct -> data_request_memory_manager = NULL;
            dlci_struct -> q922 = NULL;
            DataLink_List.remove (dlci);
        }

         /*
         **    If the Network Layer exists, issue a disconnect
         **
         **    The Logical Connection has been removed from every list except the
         **    Logical_Connection_List and the DLCI_List.  When we get the
         **    NETWORK_DISCONNECT_INDICATION from the Network layer, we will
         **    complete this operation.
         */
        if (m_pSCF != NULL)
        {
            m_pSCF->DisconnectRequest(dlci);
        }
        else
        {
             /*
             **    If the Network Layer does not exist yet, remove the logical
             **    connection from our Transport List and from the DLCI_List
             */
            Logical_Connection_List.remove (logical_handle);
            delete dlci_struct;
            DLCI_List.remove (dw_dlci);
        }
    }
    else
    {
         /*
         **    This mode requires us to terminate the connection after all user
         **    data has been successfully sent to the remote side.
         */
        if ((dlci_struct != NULL) && (dlci_struct -> x224 != NULL))
        {
            dlci_struct->x224->ShutdownReceiver ();
            dlci_struct->x224->ShutdownTransmitter ();
            dlci_struct->disconnect_requested = TRUE;
        }
    }

    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    T123::DataRequest (
 *                            LogicalHandle    logical_handle,
 *                            LPBYTE            user_data,
 *                            ULONG            user_data_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 */
TransportError    T123::DataRequest (
                        LogicalHandle    logical_handle,
                        LPBYTE            user_data,
                        ULONG            user_data_length)
{
    TRACE_OUT(("T123::DataRequest"));

    CLayerX224         *x224;
    ULONG               bytes_accepted;
    PDLCIStruct         dlci_struct;
    DWORD_PTR           dw_dlci;
    TransportError      return_value;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the DLCI structure associated with this logical connection
     */
    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);

     /*
     **    Attempt to send that data to the Transport Layer
     */
    x224 = dlci_struct -> x224;
    if (x224 == NULL)
        return (TRANSPORT_NOT_READY_TO_TRANSMIT);

     /*
     **    Pass the data to the Transport object for transmission
     */
    return_value =  x224 -> DataRequest (
                            0, user_data, user_data_length, &bytes_accepted);

     /*
     **    If it didn't accept the packet, its buffers must be full
     */
    if (bytes_accepted != user_data_length)
        return_value = TRANSPORT_WRITE_QUEUE_FULL;

    return (return_value);
}


/*
 *    void    T123::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function enables the receiver so that packets can be passed to the
 *        user application.
 */
void T123::EnableReceiver (void)
{
    TRACE_OUT(("T123::EnableReceiver"));

    PDLCIStruct        dlci_struct;

    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        if (dlci_struct->x224 != NULL)
        {
            dlci_struct->x224->EnableReceiver ();
        }
    }

    return;
}


/*
 *    TransportError    T123::PurgeRequest (
 *                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function notifies the X224 layer to purge all outbound packets.
 */
TransportError    T123::PurgeRequest (
                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("T123::PurgeRequest"));

    DWORD_PTR      dw_dlci;
    PDLCIStruct    dlci_struct;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (Logical_Connection_List.find (logical_handle, &dw_dlci) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

     /*
     **    Get the DLCI structure associated with this logical connection
     */
    DLCI_List.find (dw_dlci, (PDWORD_PTR) &dlci_struct);

     /*
     **    If the Transport layer == NULL, the stack is not completely up yet
     */
    if ((dlci_struct -> x224) == NULL)
        return (TRANSPORT_NOT_READY_TO_TRANSMIT);

    dlci_struct->x224->PurgeRequest ();

    return (TRANSPORT_NO_ERROR);
}


/*
 *    void    T123::PollReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives each of the layers a chance to process incoming
 *        data and pass it to their higher layers.
 *
 *        We start this process by calling the higher layers first so that they
 *        can empty buffers that the lower layers may need.
 */
ULONG T123::PollReceiver (void)
{
    // TRACE_OUT(("T123::PollReceiver"));

    PDLCIStruct            dlci_struct;
    IProtocolLayer *        protocol_layer;
    ULONG                return_error = FALSE;

    if (m_pSCF != NULL)
    {
        m_pSCF->PollReceiver();
    }

    if (m_pQ922 != NULL)
    {
        m_pQ922->PollReceiver();
    }

     /*
     **    Go through each of the Transport and Datalink layers and give them
     **    a chance to pass data up the line
     */
    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        protocol_layer = dlci_struct -> x224;
        if (protocol_layer != NULL)
            protocol_layer -> PollReceiver();

        protocol_layer = dlci_struct -> q922;
        if (protocol_layer != NULL)
            protocol_layer -> PollReceiver();
    }

    if (m_pMultiplexer != NULL)
    {
        m_pMultiplexer->PollReceiver();
    }

     /*
     **    The Physical Layer is the only layer that has a handle associated
     **    with it.
     */
    if (m_pComPort != NULL)
    {
        if (m_pComPort->PollReceiver() == PROTOCOL_LAYER_ERROR)
        {
            return_error = PROTOCOL_LAYER_ERROR;
        }
    }


     /*
     **    Go back through the Transport layers and allow them to issue
     **    TRANSPORT_BUFFER_AVAILABLE_INDICATIONs to the user.  This will refill
     **    the input buffers.
     */
    DLCI_List.reset ();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        if (dlci_struct -> x224 != NULL)
            (dlci_struct -> x224) -> CheckUserBuffers ();
    }

     /*
     **    Process any passive owner callbacks that may have come in
     */
    ProcessMessages ();
    return(return_error);
}


/*
 *    void    T123::PollTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives each of the layers a chance to transmit data
 *
 *        We poll the transmitters in reverse order from the PollReceiver() call.
 *        We start at the lower layers and let them empty their buffers before we
 *        go to the higher layers.  This should give the higher layers a better
 *        opportunity to get their packets sent down.
 *
 *        We treat the DataLink layers differently than all other layers.  They
 *        must send out control and user data.  If they don't get a chance to
 *        send out their control data, the remote side will eventually hangup on
 *        them.  Therefore we give each DataLink layer a chance to send its
 *        control data before any DataLink can send out user data.  The only
 *        exception to this is the DataLink 0 (DLCI 0).  It actaully sends out
 *        very little user data.A
 *
 *        After all of the control data is sent out, we go thru the Datalink
 *        Layers based on the priority given to the Transport Layer.  Higher
 *        priority Transport Layers get to send their data out first.  If there
 *        any room left, the lower layers get to send their data.  We round-robin
 *        thru the Transports of equal priority
 */
void T123::PollTransmitter (void)
{
    // TRACE_OUT(("T123::PollTransmitter"));

    PDLCIStruct        dlci_struct;
    DWORD_PTR          dlci;
    IProtocolLayer *    protocol_layer;

    USHORT            data_to_transmit;
    USHORT            data_pending;
    USHORT            datalink_data_to_transmit;
    USHORT            datalink_data_pending;
    USHORT            holding_data;
    Short            priority;

     /*
     **    Since we are going to call the Physical and Multiplexer layers, set
     **    the data_to_transmit to both types of data
     */
    data_to_transmit = PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA;
    datalink_data_to_transmit = PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA;

    if (m_pComPort != NULL)
    {
        m_pComPort->PollTransmitter(
                            (ULONG_PTR) m_hCommLink,
                            data_to_transmit,
                            &data_pending,
                            &holding_data);
    }

    if (m_pMultiplexer != NULL)
    {
        m_pMultiplexer->PollTransmitter(
                                0,
                                data_to_transmit,
                                &data_pending,
                                &holding_data);
    }

     /*
     **    The SCF Datalink Layer is the highest priority
     */
    if (m_pQ922 != NULL)
    {
        m_pQ922->PollTransmitter(
                            0,
                            datalink_data_to_transmit,
                            &datalink_data_pending,
                            &holding_data);

         /*
         **    If this DataLink returns and still has data that needs to go out,
         **    we won't let the other DataLinks transmit any data at all.
         */
        if ((datalink_data_pending & PROTOCOL_USER_DATA) ||
            (datalink_data_pending & PROTOCOL_CONTROL_DATA))
                datalink_data_to_transmit = 0;
    }

    if (m_pSCF != NULL)
    {
        m_pSCF->PollTransmitter(
                            0,
                            data_to_transmit,
                            &data_pending,
                            &holding_data);
        if (data_pending & PROTOCOL_USER_DATA)
            datalink_data_to_transmit = PROTOCOL_CONTROL_DATA;
    }

     /*
     **    Go thru each of the DataLinks giving them a chance to send out control
     **    data.  At the end of the iterator, we take the first entry and put it
     **    at the end of the list.  This gives all DataLinks a chance to send out
     **    control data.  This does not guarantee that each DataLink will get
     **    equal treatment.
     */
    if (datalink_data_to_transmit & PROTOCOL_CONTROL_DATA)
    {
         /*
         **    Go through the DataLink layers to transmit control
         */
        DataLink_List.reset();
        while (DataLink_List.iterate (&dlci))
        {
            DLCI_List.find (dlci, (PDWORD_PTR) &dlci_struct);
            dlci_struct->q922->PollTransmitter(0,
                                               PROTOCOL_CONTROL_DATA,
                                               &datalink_data_pending,
                                               &holding_data);
            if (datalink_data_pending & PROTOCOL_CONTROL_DATA)
                datalink_data_to_transmit = PROTOCOL_CONTROL_DATA;
        }

        if (DataLink_List.entries() > 1)
        {
            DataLink_List.append (DataLink_List.get ());
        }
    }

     /*
     **    Go thru each of the priorities, Issuing PollTransmitter() calls.
     **
     **    This loop allows the DataLink and Transport to send out User or
     **    Control data.
     */
    if (datalink_data_to_transmit & PROTOCOL_USER_DATA)
    {
        for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
        {
            if (Logical_Connection_Priority_List[priority]->isEmpty ())
                continue;

             /*
             **    Go thru each priority level
             */
            Logical_Connection_Priority_List[priority]->reset();
            while (Logical_Connection_Priority_List[priority]->iterate (&dlci))
            {
                DLCI_List.find (dlci, (PDWORD_PTR) &dlci_struct);

                protocol_layer = dlci_struct -> x224;
                if (protocol_layer == NULL)
                    continue;

                 /*
                 **    Allow the DataLink to transmit first, followed by the
                 **    Transport
                 */
                dlci_struct->q922->PollTransmitter(
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &datalink_data_pending,
                                    &holding_data);

                protocol_layer -> PollTransmitter (
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &data_pending,
                                    &holding_data);

                 /*
                 **    The Disconnect_Requested flag is set to TRUE if someone
                 **    wants to break the TC but transmit all data in the queue
                 */
                if ((dlci_struct -> disconnect_requested))
                {
                     /*
                     **    Re-call the DataLink layer to see if the Transport
                     **    layer put any data in it to be transmitted.
                     */
                    dlci_struct->q922->PollTransmitter(
                                    0,
                                    PROTOCOL_CONTROL_DATA | PROTOCOL_USER_DATA,
                                    &datalink_data_pending,
                                    &holding_data);

                     /*
                     **    If the DataLink layer has no data to transmit and it
                     **    is not holding any packets to be acknowledged,
                     **    disconnect the TC.
                     */
                    if ((datalink_data_pending == 0) && (holding_data == 0))
                    {
                        dlci_struct -> disconnect_requested = FALSE;
                        m_pSCF->DisconnectRequest ((DLCI) dlci);
                    }
                }

            }
             /*
             **    Change the order of the list at this priority level
             */
            Logical_Connection_Priority_List[priority]->append (
                                            Logical_Connection_Priority_List[priority]->get ());
        }
    }

     /*
     **    Process any passive owner callbacks
     */
    ProcessMessages ();
}


/*
 *    ULONG    T123::OwnerCallback (
 *                    USHORT    message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the owner callback function.  Layers owned by this layer can
 *        issue an owner callback to this object when a significant event occurs.
 */
ULONG T123::OwnerCallback
(
    ULONG       layer_message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("T123::OwnerCallback"));

    ULONG           message;
    PMessageStruct  passive_message;
    ULONG           return_value = 0;

    message = layer_message & MESSAGE_MASK;

    switch (message)
    {
    case NETWORK_CONNECT_INDICATION:
         /*
         **    This message comes from the Network Layer when the remote site
         **    has requested a logical connection.
         **
         **    We will check the requested dlci to make sure it is valid.
         **    We will make a ConnectResponse() call to the Network layer to
         **    let it know.
         */
        NetworkConnectIndication ((PNetworkConnectStruct) parameter3);
        break;

    case NETWORK_CONNECT_CONFIRM:
         /*
         **    This message is issued from the Network Layer.  The
         **    ConnectRequest() call we made to the layer has resulted in
         **    a new DLCI (permission to create a new logical connection)
         */
        NetworkConnectConfirm ((PNetworkConnectStruct) parameter3);
        break;

    case DATALINK_ESTABLISH_CONFIRM:
    case DATALINK_ESTABLISH_INDICATION:
         /*
         **    These messages come from the DataLink layer when a connection
         **    has been established.  If the DLCI returned is 0, this signifies
         **    that we need to create a Network Layer, otherwise we need to
         **    create a Transport Layer.
         */
        DataLinkEstablish ((DLCI) parameter1);
        break;

     /*
     **    Transport messages
     */
    case TPRT_CONNECT_CONFIRM:
         /*
         **    This message is received from the Transport Layer to confirm
         **    that the Transport Layer (that we initiated) is up and running
         **
         **    We notify the owner object that the connection is now valid.
         */
        m_pController->OwnerCallback(m_nMsgBase + TPRT_CONNECT_CONFIRM,
                                     parameter1);
        break;

    case TPRT_CONNECT_INDICATION:
         /*
         **    This message is received from the Transport Layer to confirm
         **    that the Transport Layer (that the remote site initiated) is
         **    up.
         **
         **    We notify the owner object that the connection is up.
         */
        m_pController->OwnerCallback(m_nMsgBase + TPRT_CONNECT_INDICATION,
                                     parameter1);
        break;

    case NEW_CONNECTION:
         /*
         **    Multiplexer is initiated and ready, create a DataLink to sit
         **    on top of this layer.  The Link_Originator flag tells the
         **    DataLink whether to start link establishment
         */
        NewConnection ();
        break;

    case BROKEN_CONNECTION:
    case TPRT_DISCONNECT_INDICATION:
    case NETWORK_DISCONNECT_INDICATION:
    case DATALINK_RELEASE_INDICATION:
    case DATALINK_RELEASE_CONFIRM:
         /*
         **    These messages need to be processed at a later time.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (NULL != passive_message)
        {
            passive_message -> message = layer_message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("T123::OwnerCallback: cannot allocate MessageStruct"));
        }
        break;

    case T123_STATUS_MESSAGE:
        TRACE_OUT(("T123: OwnerCallback: T123_STATUS_MESSAGE"));
        switch ((UINT)((UINT_PTR)(parameter2)))
        {
        case DATALINK_TIMING_ERROR:
            ERROR_OUT(("T123: OwnerCallback: DATALINK_TIMING_ERROR"));
            break;

        default:
            ERROR_OUT(("T123: OwnerCallback: Illegal status message = %ld", (UINT)((UINT_PTR)parameter2)));
            break;
        }
        break;

    default:
        ERROR_OUT(("T123: OwnerCallback: Illegal message = %lx", message));
        break;
    }

    return (return_value);
}


/*
 *    void    Controller::ProcessMessages (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes the passive owner callbacks.
 */
void    T123::ProcessMessages (void)
{
    // TRACE_OUT(("T123::ProcessMessages"));

    ULONG                    message;
    PMessageStruct           message_struct;
    void                    *parameter1;
    void                    *parameter2;

    LogicalHandle            logical_handle;
    DLCI                     dlci;
    USHORT                   link_originator;
    USHORT                   retry;
    DataLinkDisconnectType   error;

     /*
     **    Go thru the Message List processing the messages until the messages
     **    are gone
     */
    while (! Message_List.isEmpty())
    {
        message_struct = (PMessageStruct) Message_List.get();
        message = (message_struct -> message) & MESSAGE_MASK;
        parameter1 = message_struct -> parameter1;
        parameter2 = message_struct -> parameter2;

        switch (message)
        {
         /*
         **    DataLink messages
         */
        case DATALINK_RELEASE_INDICATION:
        case DATALINK_RELEASE_CONFIRM:
             /*
             **    These messages occur when the DataLink has broken the link
             */
            dlci = (DLCI) parameter1;
            error = (DataLinkDisconnectType) (UINT_PTR) parameter2;

            DataLinkRelease (dlci, error);
            break;

         /*
         **    Network messages
         */
        case NETWORK_DISCONNECT_INDICATION:
             /*
             **    The Network Layer issues this message when it needs to
             **    terminate a logical connection
             */
            dlci = (DLCI) parameter1;
            link_originator = (USHORT) (((UINT_PTR) parameter2) >> 16);
            retry = (USHORT) ((UINT_PTR) parameter2) & 0xffff;

            NetworkDisconnectIndication (dlci, link_originator, retry);
            break;

        case TPRT_DISCONNECT_INDICATION:
             /*
             **    If the Transport is breaking the connection, the
             **    Connect arbitration must not have worked.  Issue a
             **    DisconnectRequest() to ourselves with the logical
             **    connection
             **
             **    parameter1 = logical connection
             */
            TRACE_OUT(("T123: ProcessMessages: TPRT_DISCONNECT_INDICATION from X224"));
            logical_handle = (LogicalHandle) parameter1;
            DisconnectRequest (logical_handle, TRUE);
            break;

        case BROKEN_CONNECTION:
             /*
             **    This message is issued by the Multiplexer when its
             **    disconnect is completed.  When this occurs, we notify the
             **    owner that the T123 stack is terminating.
             */
            TRACE_OUT(("t123: BROKEN_CONNECTION from MPLEX"));
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
            break;
        }

         /*
         **    Delete the message and remove it from the list
         */
        delete message_struct;
        Message_List.remove ((DWORD_PTR) message_struct);
    }
}


/*
 *    DLCI    T123::GetNextDLCI (void)
 *
 *    Functional Description
 *        This function searches the DLCI list for the first available DLCI.  The
 *        T123 spec. allows DLCIs between a specified range.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
DLCI    T123::GetNextDLCI (void)
{
    DLCI    dlci;

    dlci = (DLCI) ((GetTickCount() % (HIGHEST_DLCI_VALUE + 1 - LOWEST_DLCI_VALUE)) + LOWEST_DLCI_VALUE);

    while(1)
    {
        if(DLCI_List.find ((DWORD) dlci) == FALSE)
            break;
        if (++dlci > HIGHEST_DLCI_VALUE)
            dlci = LOWEST_DLCI_VALUE;
    }

    return (dlci);
}


/*
 *    void    T123::Reset (void)
 *
 *    Functional Description
 *        This function deletes all Transport Layers, DataLink Layers and
 *        Network Layers that are active.  It clears our lists and puts us
 *        in a reset state.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::Reset (void)
{
    TRACE_OUT(("T123::Reset"));

    TRACE_OUT(("T123::Reset network layer = %lx", m_pSCF));

    Short    priority;
    PDLCIStruct dlci_struct;

     /*
     **    Delete the Network Layer if it exists
     */
    delete m_pSCF;
    m_pSCF = NULL;

     /*
     **    Delete the DLCI 0  DataLink Layer, if it exists
     */
    delete m_pQ922;
    m_pQ922 = NULL;

    delete Data_Request_Memory_Manager;
    Data_Request_Memory_Manager = NULL;


     /*
     **    For each priority level, clear the Priority list
     */
    for (priority=(NUMBER_OF_PRIORITIES - 1); priority>=0; priority--)
        Logical_Connection_Priority_List[priority]->clear ();

     /*
     **    Clear the Logical_Connection_List and DataLink_List
     */
    Logical_Connection_List.clear ();
    DataLink_List.clear ();

     /*
     **    Go thru each Transport and DataLink layer (excluding DLCI 0) and delete
     **    them.  Delete the DLCIStruct.  Finally, clear the list
     */
    DLCI_List.reset();
    while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct))
    {
        delete dlci_struct->x224;
        if (dlci_struct->q922 != NULL)
        {
            delete dlci_struct->q922;
            delete dlci_struct->data_request_memory_manager;
        }

        delete dlci_struct;
    }
    DLCI_List.clear ();

}


/*
 *    void    T123::NetworkDisconnectIndication (
 *                    DLCI        dlci,
 *                    BOOL        link_originator,
 *                    BOOL        retry)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_DISCONNECT_INDICATION
 *        message from the SCF Layer.  It removes the TC and if no TCs remain, it
 *        tears down the stack
 *
 *    Formal Parameters
 *        dlci                (i)    -    Connection identifier
 *        link_originiator    (i)    -    TRUE, if this side originated the logical
 *                                    connection
 *        retry                (i)    -    TRUE, if we should retry the connection.
 *
 *    Return Value
 *        void
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkDisconnectIndication (
                DLCI        dlci,
                BOOL        link_originator,
                BOOL        retry)
{
    TRACE_OUT(("T123::NetworkDisconnectIndication"));

    DLCI            new_dlci;
    LogicalHandle    logical_handle;
    BOOL            transport_found;
    PDLCIStruct        lpdlciStruct;
    DWORD_PTR        dwTemp_dlci;


    TRACE_OUT(("T123: NetworkDisconnectIndication"));

    if (DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &lpdlciStruct) == FALSE)
        return;

     /*
     **    if dlci equals 0, a connection was requested by the remote
     **    site but the connection was not fully established.  This object
     **    will not do anything about it.  It only recognizes that it
     **    occured.
     */
    transport_found = FALSE;
    if (dlci != 0)
    {
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate(&dwTemp_dlci, (PDWORD_PTR) &logical_handle))
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                 /*
                 **    It is VERY important to check the link_originator flag,
                 **    otherwise we may break the wrong connection
                 */
                if (link_originator == lpdlciStruct-> link_originator)
                {
                    transport_found = TRUE;
                    break;
                }
            }
        }
    }

     /*
     **    retry is set to TRUE if during the request for this new
     **    connection, the remote site refused our DLCI selection.
     **    This is not a major error, we will request another
     **    connection using another DLCI.
     */
    TRACE_OUT(("retry = %d link_originator = %d retries = %d",
        retry, link_originator, lpdlciStruct->network_retries));

    if (retry && link_originator &&
        (lpdlciStruct->network_retries < NETWORK_RETRIES))
    {
        lpdlciStruct->network_retries++;

         /*
         **    Get another DLCI and replace the old dlci in the
         **    Logical_Connection_List.  Add the new DLCI to the DLCI_List
         **    and remove the old one.
         */
        new_dlci = GetNextDLCI ();
        Logical_Connection_List.insert (logical_handle, (DWORD_PTR) new_dlci);
        DLCI_List.insert ((DWORD_PTR) new_dlci, (DWORD_PTR) lpdlciStruct);
        DLCI_List.remove ((DWORD_PTR) dlci);

         /*
         **    Issue another ConnectRequest to the Network Layer.
         */
        m_pSCF->ConnectRequest(new_dlci, lpdlciStruct->priority);
    }
    else
    {
         /*
         **    If a transport was found in our list and we don't want
         **    to retry the connection, delete the Transport and
         **    DataLink and remove them from our lists
         */
        if (transport_found)
        {
            if (lpdlciStruct != NULL)
            {
                delete lpdlciStruct -> x224;
                lpdlciStruct->x224 = NULL;

                delete lpdlciStruct->q922;
                lpdlciStruct->q922 = NULL;

                delete lpdlciStruct->data_request_memory_manager;
                lpdlciStruct->data_request_memory_manager = NULL;

                 /*
                 **    Remove the logical connection from the lists
                 */
                Logical_Connection_Priority_List[lpdlciStruct->priority]->remove (dlci);
                DataLink_List.remove (dlci);

                delete lpdlciStruct;
            }

            Logical_Connection_List.remove (logical_handle);
            DLCI_List.remove ((DWORD) dlci);

             /*
             **    Notify the owner object that the logical
             **    connection is no longer valid.
             */
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                (void *) logical_handle,
                                m_hCommLink);
        }


         /*
         **    This check determines if we will automatically tear down the
         **    T.120 stack if the logical connection count reaches zero.
         */
        if (m_pComPort->PerformAutomaticDisconnect())
        {
            TRACE_OUT(("T123: NetworkDisconnectIndication: Perform Auto Disconnect"));
             /*
             **    If there aren't any more Logical Connections and I
             **    was the link originator, initiate a Release Request to
             **    the DataLink of DLCI 0
             */
            if (Logical_Connection_List.isEmpty() && Link_Originator)
            {
                delete m_pSCF;
                m_pSCF = NULL;

                if (m_pQ922 != NULL)
                {
                    m_pQ922->ReleaseRequest();
                }
                else
                {
                    m_pController->OwnerCallback(
                                    m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                    INVALID_LOGICAL_HANDLE,
                                    m_hCommLink,
                                    &Disconnect_Requested);
                }
            }
        }
    }
}


/*
 *    void    T123::DataLinkRelease (
 *                    DLCI            dlci,
 *                    DisconnectType    error)
 *
 *    Functional Description
 *        This function is called when we receive a DATALINK_RELEASE message
 *        message from the DataLink Layer.  As a result we may disconnect a
 *        logical connection or (if it is DLCI 0) the whole stack.
 *
 *    Formal Parameters
 *        dlci                (i)    -    Connection identifier
 *        error                (i)    -    error type
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::DataLinkRelease (
                DLCI                    dlci,
                DataLinkDisconnectType    disconnect_type)
{
    TRACE_OUT(("T123::DataLinkRelease"));

    BOOL            transport_found;
    LogicalHandle    logical_handle;
    USHORT            message;

    TRACE_OUT(("T123: DataLinkRelease: DLCI = %d", dlci));

     /*
     **    If DLCI 0 is terminating, all Transports and DataLinks must
     **    be terminated
     */
    if (dlci == 0)
    {
         /*
         **    If the DataLink broke the connection because of a
         **    Fatal Error, issue an immediate TPRT_DISCONNECT_INDICATION
         **    to the owner object.  This may cause the owner object
         **    to delete us immediately.  If the error is not Fatal
         **    disconnect the Multiplexer so that it can send out
         **    its remaining data
         */
        if (disconnect_type != DATALINK_NORMAL_DISCONNECT)
        {
             /*
             **    This function deletes all of the DataLinks,
             **    Network Layers, and Transports.
             */
            Reset ();

             /*
             **    Notify the owner that DLCI 0 is terminating
             */
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }
        else
        {
             /*
             **    If the error is not Fatal, let the Multiplexer
             **    complete its transmission.
             */
            m_pMultiplexer->DisconnectRequest();
        }
    }
    else
    {
        DWORD_PTR    dwTemp_dlci;

         /*
         **    The DataLink associated with a Transport is terminating
         */
        if (DLCI_List.find ((DWORD) dlci) == FALSE)
            return;

        transport_found = FALSE;

         /*
         **    Find the logical connection associated with this DLCI
         */
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate(&dwTemp_dlci, (PDWORD_PTR) &logical_handle) == TRUE)
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                transport_found = TRUE;
                break;
            }
        }

        if (transport_found)
            DisconnectRequest (logical_handle, TRUE);
    }
}


/*
 *    void    T123::NewConnection (void)
 *
 *    Functional Description
 *        This function is called when we receive a NEW_CONNECTION message from
 *        the Multiplexer Layer.  It instantiates a DataLink Layer to serve
 *        the SCF.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NewConnection (void)
{
    TRACE_OUT(("T123::NewConnection"));

    USHORT                max_outstanding_bytes;
    BOOL                initialized;
    MemoryTemplate        memory_template[2];
    MemoryManagerError    memory_manager_error;

    memory_template[0].block_size = 128;
    memory_template[0].block_count = 4;

    DBG_SAVE_FILE_LINE
    Data_Request_Memory_Manager = new MemoryManager (
                                        memory_template,
                                        1,
                                        &memory_manager_error,
                                        9,
                                        TRUE);

    if ((Data_Request_Memory_Manager != NULL) &&
        (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
    {
        delete Data_Request_Memory_Manager;
        Data_Request_Memory_Manager = NULL;
    }

    if (Data_Request_Memory_Manager != NULL)
    {
        max_outstanding_bytes = PSTN_DATALINK_MAX_OUTSTANDING_BYTES;


        DBG_SAVE_FILE_LINE
        m_pQ922 = new CLayerQ922(this,
                                m_pMultiplexer,
                                DATALINK_LAYER_MESSAGE_BASE,
                                0,
                                Link_Originator,
                                4,
                                4,
                                DataLink_Struct.default_k_factor,
                                DataLink_Struct.default_n201,
                                DataLink_Struct.default_t200,
                                max_outstanding_bytes,
                                Data_Request_Memory_Manager,
                                m_pComPort->GetCallControlType(),
                                m_fValidSDKParams ? &m_SDKParams : NULL,
                                &initialized);
        if (m_pQ922 == NULL)
        {
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);

        }
        else if (initialized == FALSE)
        {
            delete m_pQ922;
            m_pQ922 = NULL;
            m_pController->OwnerCallback(
                                m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                INVALID_LOGICAL_HANDLE,
                                m_hCommLink,
                                &Disconnect_Requested);
        }
    }
    else
    {
        TRACE_OUT(("T123: Allocation of memory manager failed"));
        m_pController->OwnerCallback(
                            m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                            INVALID_LOGICAL_HANDLE,
                            m_hCommLink,
                            &Disconnect_Requested);
    }
}


/*
 *    void    T123::NetworkConnectIndication (
 *                    PNetworkConnectStruct    connect_struct)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_CONNECT_INDICATION
 *        message from the SCF Layer.  It instantiates a DataLink Layer to serve
 *        the new TC.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        Valid DLCI
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkConnectIndication (
                PNetworkConnectStruct    connect_struct)

{
    TRACE_OUT(("T123::NetworkConnectIndication"));

    USHORT              blocks;
    CLayerQ922         *q922;
    BOOL                initialized;
    PMemoryManager      data_request_memory_manager;
    BOOL                valid_dlci;
    PDLCIStruct         dlci_struct;
    USHORT              max_outstanding_bytes;
    MemoryTemplate      memory_template[2];
    MemoryManagerError  memory_manager_error;
    ULONG               max_transport_tpdu_size;

     /*
     **    See if the DLCI is already being used elsewhere.  If it is,
     **    set valid_dlci to FALSE and call ConnectResponse().  If it is
     **    not, put the DLCI in out DLCI_List
     */
    if (DLCI_List.find ((DWORD) (connect_struct->dlci)))
        valid_dlci = FALSE;
    else
    {
        DBG_SAVE_FILE_LINE
        dlci_struct = new DLCIStruct;
        if (dlci_struct != NULL)
        {
            DLCI_List.insert ((DWORD_PTR) (connect_struct->dlci), (DWORD_PTR) dlci_struct);
            dlci_struct -> link_originator = FALSE;
            dlci_struct -> x224 = NULL; // X.224
            dlci_struct -> q922 = NULL; // Q.922
            dlci_struct -> disconnect_requested = FALSE;
            dlci_struct -> data_request_memory_manager = NULL;
            dlci_struct -> network_retries = 0;
            dlci_struct -> priority = connect_struct->priority;

             /*
             **    Connect_Requested does not mean tha we issued a
             **    ConnectRequest() to the Network Layer.  It means that the
             **    Network Layer is aware of the connection.
             */
            dlci_struct -> connect_requested = TRUE;
            valid_dlci = TRUE;
        }
        else
        {
            valid_dlci = FALSE;
        }
    }

    if (valid_dlci)
    {
         /*
         **    Create a DataLink that will service this Transport Layer
         */
        max_transport_tpdu_size = CLayerX224::GetMaxTPDUSize (
                            (ULONG) (connect_struct->datalink_struct) -> n201);

        blocks = (USHORT) (MAXIMUM_USER_DATA_SIZE /
            (max_transport_tpdu_size - DATA_PACKET_HEADER_SIZE)) + 1;

         /*
         **    Allow for one extra block so that a HIGH_PRIORITY memory
         **    allocation can get as many blocks as it needs to hold the
         **    MAXIMUM_USER_DATA_SIZE packet.
         */
        blocks++;

        TRACE_OUT(("T123: NCIndication: max_tpdu = %d",max_transport_tpdu_size));

         /*
         **    Allow for X 8K blocks
         */
        blocks *= NUMBER_8K_BLOCKS;

         /*
         **    The '2' in the following statement is for the CRC added by the
         **    multiplexer.
         */
        memory_template[0].block_size = max_transport_tpdu_size +
                                        DATALINK_PACKET_OVERHEAD +
                                        2;
        memory_template[0].block_count = blocks;
        memory_template[1].block_size = 64;
        memory_template[1].block_count = NUMBER_64_BYTE_BLOCKS;

        DBG_SAVE_FILE_LINE
        data_request_memory_manager = new MemoryManager (
                                            memory_template,
                                            2,
                                            &memory_manager_error,
                                            33,
                                            TRUE);

        if ((data_request_memory_manager != NULL) &&
            (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
        {
            delete data_request_memory_manager;
            data_request_memory_manager = NULL;
        }

        if (data_request_memory_manager != NULL)
        {

            dlci_struct->priority = connect_struct -> priority;
            dlci_struct->data_request_memory_manager = data_request_memory_manager;

            max_outstanding_bytes = PSTN_DATALINK_MAX_OUTSTANDING_BYTES;

            DBG_SAVE_FILE_LINE
            q922 =  new CLayerQ922(this,
                                    m_pMultiplexer,
                                    DATALINK_LAYER_MESSAGE_BASE,
                                    connect_struct->dlci,
                                    dlci_struct->link_originator,
                                    1,
                                    4,
                                    (connect_struct->datalink_struct)->k_factor,
                                    (connect_struct->datalink_struct)->n201,
                                    (connect_struct->datalink_struct)->t200,
                                    max_outstanding_bytes,
                                    data_request_memory_manager,
                                    m_pComPort->GetCallControlType(),
                                    m_fValidSDKParams ? &m_SDKParams : NULL,
                                    &initialized);
            if (q922 != NULL)
            {

                if (initialized)
                {
                     /*
                     **    Add it to the DataLink list
                     */
                    dlci_struct->q922 = q922;
                    DataLink_List.append (connect_struct->dlci);
                }
                else
                {
                    delete q922;
                    delete data_request_memory_manager;
                    valid_dlci = FALSE;
                }
            }
            else
            {
                delete data_request_memory_manager;
                valid_dlci = FALSE;
            }
        }
        else
        {
            ERROR_OUT(("t123: Unable to allocate memory manager"));
            valid_dlci = FALSE;
        }

        // Clean up on error
        if (FALSE == valid_dlci)
        {
            DLCI_List.remove((DWORD) connect_struct->dlci);
            delete dlci_struct;
        }
    }

     /*
     **    Contact the Network Layer with a response
     */
    m_pSCF->ConnectResponse(
                        connect_struct -> call_reference,
                        connect_struct -> dlci,
                        valid_dlci);

}


/*
 *    void    T123::NetworkConnectConfirm (
 *                    PNetworkConnectStruct    connect_struct)
 *
 *    Functional Description
 *        This function is called when we receive a NETWORK_CONFIRM message
 *        from the SCF Layer.  It instantiates a DataLink Layer to serve the
 *        new logical connection.
 *
 *    Formal Parameters
 *        connect_struct    (i)    -    Address of connect struct.  It holds the DLCI
 *                                and priority.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::NetworkConnectConfirm (
                PNetworkConnectStruct    connect_struct)
{
    TRACE_OUT(("T123::NetworkConnectConfirm"));

    DLCI                dlci;
    USHORT              blocks;
    CLayerQ922         *q922;
    BOOL                initialized;
    PMemoryManager      data_request_memory_manager;
    MemoryTemplate      memory_template[2];
    MemoryManagerError  memory_manager_error;
    USHORT              max_outstanding_bytes;
    ULONG               max_transport_tpdu_size;
    PDLCIStruct         dlci_struct;


    max_transport_tpdu_size = CLayerX224::GetMaxTPDUSize (
                                (ULONG) (connect_struct->datalink_struct) -> n201);

    blocks = (USHORT) (MAXIMUM_USER_DATA_SIZE /
        (max_transport_tpdu_size - DATA_PACKET_HEADER_SIZE)) + 1;

    TRACE_OUT(("T123:  NCConfirm: max_tpdu = %d", max_transport_tpdu_size));

     /*
     **    Allow for one extra block so that a HIGH_PRIORITY memory
     **    allocation can get as many blocks as it needs to hold the
     **    MAXIMUM_USER_DATA_SIZE packet.
     */
    blocks++;

     /*
     **    Allow for X 8K blocks
     */
    blocks *= NUMBER_8K_BLOCKS;

     /*
     **    Figure out the maximum packet size; The '2' is for the CRC appended
     **    to the end of a packet.
     */
    memory_template[0].block_size = max_transport_tpdu_size +
                                    DATALINK_PACKET_OVERHEAD +
                                    2;
    memory_template[0].block_count = blocks;
    memory_template[1].block_size = 64;
    memory_template[1].block_count = NUMBER_64_BYTE_BLOCKS;

    DBG_SAVE_FILE_LINE
    data_request_memory_manager = new MemoryManager (
                                        memory_template,
                                        2,
                                        &memory_manager_error,
                                        33,
                                        TRUE);

    if ((data_request_memory_manager != NULL) &&
        (memory_manager_error != MEMORY_MANAGER_NO_ERROR))
    {
        delete data_request_memory_manager;
        data_request_memory_manager = NULL;
    }

    if (data_request_memory_manager != NULL)
    {

        dlci = connect_struct -> dlci;

        DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &dlci_struct);
        dlci_struct->data_request_memory_manager = data_request_memory_manager;

         /*
         **    The DLCI is already entered in our DLCI list, set the priority
         **    and create a DataLink for it.
         */
        dlci_struct->q922 = NULL;
        dlci_struct->priority = connect_struct->priority;

        max_outstanding_bytes =    PSTN_DATALINK_MAX_OUTSTANDING_BYTES;

        DBG_SAVE_FILE_LINE
        q922 = new CLayerQ922(this,
                                m_pMultiplexer,
                                DATALINK_LAYER_MESSAGE_BASE,
                                dlci,
                                dlci_struct->link_originator,
                                1,
                                4,
                                (connect_struct->datalink_struct)->k_factor,
                                (connect_struct->datalink_struct)->n201,
                                (connect_struct->datalink_struct)->t200,
                                max_outstanding_bytes,
                                data_request_memory_manager,
                                m_pComPort->GetCallControlType(),
                                m_fValidSDKParams ? &m_SDKParams : NULL,
                                &initialized);
        if (q922 != NULL)
        {
            if (initialized)
            {
                dlci_struct->q922 = q922;
                DataLink_List.append (dlci);
            }
            else
            {
                delete q922;
                delete data_request_memory_manager;
                m_pSCF->DisconnectRequest(dlci);
            }
        }
        else
        {
            delete data_request_memory_manager;
            m_pSCF->DisconnectRequest(dlci);
        }
    }
}


/*
 *    void    T123::DataLinkEstablish (
 *                    DLCI    dlci)
 *
 *    Functional Description
 *        This function is called when we receive a DATALINK_ESTABLISH message
 *        from a DataLink Layer.  Depending on which DataLink is successfully up,
 *        it creates the layer on top of it.
 *
 *    Formal Parameters
 *        dlci        (i)    -    DLCI value
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    T123::DataLinkEstablish (DLCI    dlci)
{
    TRACE_OUT(("T123::DataLinkEstablish, dlci=%d", dlci));

    BOOL                initialized;
    BOOL                transport_found;
    PDLCIStruct            dlci_struct;
    LogicalHandle        logical_handle;
    TransportPriority    priority;
    DWORD_PTR            dwTemp_dlci;

    if (dlci == 0)
    {
        DBG_SAVE_FILE_LINE
        m_pSCF = new CLayerSCF(this,
                                m_pQ922,
                                NETWORK_LAYER_MESSAGE_BASE,
                                0,
                                Link_Originator,
                                &DataLink_Struct,
                                Data_Request_Memory_Manager,
                                &initialized);
        if (m_pSCF == NULL)
        {
            m_pQ922->ReleaseRequest();
            return;
        }
        else if (initialized == FALSE)
        {
            delete m_pSCF;
            m_pQ922->ReleaseRequest();
            return;
        }

         /*
         **    Go thru the Transport list and attempt connections
         ** for all Transport requests that we have received
         */
        DLCI_List.reset();
        while (DLCI_List.iterate ((PDWORD_PTR) &dlci_struct, &dwTemp_dlci))
        {
            dlci = (DLCI) dwTemp_dlci;
             /*
             **    The Link_Originator is set to TRUE if the
             **    ConnectRequest() function was called.  We have to check
             **    the Connect_Requested variable to see if we have
             **    already made the request to the Network Layer.
             */
            if (dlci_struct->link_originator
                && (dlci_struct->connect_requested == FALSE))
            {
                dlci_struct -> connect_requested = TRUE;
                m_pSCF->ConnectRequest(dlci, dlci_struct -> priority);
            }
        }
    }
    else
    {
         /*
         **    If DLCI != 0, this is a DataLink for a Transport Layer
         */
        transport_found = FALSE;

         /*
         **    Go thru each of the Transports to find the one associated
         **    with the DLCI.
         */
        Logical_Connection_List.reset();
        while (Logical_Connection_List.iterate((PDWORD_PTR) &dwTemp_dlci, (PDWORD_PTR) &logical_handle))
        {
            if (dlci == (DLCI) dwTemp_dlci)
            {
                transport_found = TRUE;
                break;
            }
        }

         /*
         **    If we go thru the list and don't find the logical
         **    connection we have to request a new logical connection
         **    handle from the controller.
         */
        if (transport_found == FALSE)
        {
            logical_handle = (LogicalHandle) m_pController->OwnerCallback(
                                    m_nMsgBase + REQUEST_TRANSPORT_CONNECTION,
                                    m_hCommLink,
                                    0,
                                    NULL);
            if (logical_handle != INVALID_LOGICAL_HANDLE)
            {
                 /*
                 **    Set the Logical_Connection_List appropriately
                 */
                Logical_Connection_List.insert (logical_handle, (DWORD) dlci);
            }
            else
            {
                m_pSCF->DisconnectRequest(dlci);
                return;
            }
        }

         /*
         **    Create a Transport Layer to go with the DataLink layer.
         */
        DLCI_List.find ((DWORD_PTR) dlci, (PDWORD_PTR) &dlci_struct);
        DBG_SAVE_FILE_LINE
        dlci_struct->x224 = new CLayerX224 (
                    this,
                    dlci_struct->q922,
                    TRANSPORT_LAYER_MESSAGE_BASE,
                    logical_handle,
                    0,
                    1,
                    TRANSPORT_DEFAULT_PDU_SIZE,
                    dlci_struct -> data_request_memory_manager,
                    &initialized);

        if (dlci_struct->x224 != NULL)
        {
            if (initialized)
            {
                 /*
                 **    Put the dlci in the Priority list
                 */
                priority = dlci_struct->priority;
                Logical_Connection_Priority_List[priority]->append ((DWORD) dlci);

                 /*
                 **    If transport_found == TRUE, we must have initiated
                 **    the request for this logical connection, so issue
                 **    the ConnectRequest() to the Transport Layer.
                 */
                if (transport_found)
                {
                    dlci_struct->x224->ConnectRequest ();
                }
            }
            else
            {
                m_pSCF->DisconnectRequest (dlci);
            }
        }
        else
        {
            m_pSCF->DisconnectRequest (dlci);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\timer.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    Timer.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the Timer class
 *
 *    Private Instance Variables:
 *        Maximum_Timer_Events            -    Maximum number of timers maintained
 *                                            by this class
 *        Timer_Memory                    -    Base address of our TimerEvent
 *                                            structure memory
 *        Timer_Event_Table                -    Address of first structure in
 *                                            Timer_Memory
 *        Timer_Event_Count                -    Number of timers active
 *        Timer_Event_Free_Stack            -    Holds numbers of available timers
 *        First_Timer_Event_In_Chain        -    Number of first timer in the chain
 *        Last_Timer_Value                -    Last time that we got from Windows
 *        Timer_Info                        -    Windows structure that holds the
 *                                            current time.
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James P. Galvin
 *        James W. Lawwill
 */
#include <windowsx.h>
#include "timer.h"


/*
 *    Timer (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the constructor for the timer class.  This procedure gets
 *        thc current Windows system time.
 */
Timer::Timer (void) :
        Timer_List (TRANSPORT_HASHING_BUCKETS),
        Timer_Event_Free_Stack ()
{
     /*
     **     Get the current time from Windows
     */
    Last_Timer_Value = GetTickCount ();
    Maximum_Timer_Events = 0;
    Timer_Event_Count = 0;
    First_Timer_Event_In_Chain=NULL;
}


/*
 *    ~Timer (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the destructor for the timer class.  This routine frees all
 *        memory associated with timer events.
 */
Timer::~Timer (void)
{
    PTimerEvent        lpTimerEv;

    Timer_List.reset();
    while (Timer_List.iterate ((PDWORD_PTR) &lpTimerEv))
        delete lpTimerEv;
}


/*
 *    TimerEventHandle    Timer::CreateTimerEvent (
 *                                 ULONG            timer_duration,
 *                                USHORT            control_flags,
 *                                IObject *            object_ptr,
 *                                PTimerFunction    timer_func_ptr)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine is called to create a timer event.  The routine stores the
 *        information passed-in in a TimerEvent structure.  When the timer expires
 *        the function will be called.
 *
 */
TimerEventHandle Timer::CreateTimerEvent
(
    ULONG               timer_duration,
    USHORT              control_flags,
    IObject            *object_ptr,
    PTimerFunction      timer_func_ptr
)
{
    TimerEventHandle    timer_event=NULL;
    PTimerEvent            next_timer_event;
    PTimerEvent            timer_event_ptr;

     /*
     **    Get the current time from Windows
     */
    Last_Timer_Value = GetTickCount ();

    if (Maximum_Timer_Events > Timer_Event_Count)
    {
          /*
          ** Get the next available handle from the free stack
          */
        timer_event = (TimerEventHandle) Timer_Event_Free_Stack.get();
        Timer_Event_Count++;
    }
    else
    {
         /*
         **    Assign the timer event counter to the handle
         */
        timer_event = ++Timer_Event_Count;
        Maximum_Timer_Events++;
    }
     /*
     **    If this is the first event to be created, keep track of it
     **    so when we iterate through the list, we will know where to
     **    start.
     */
    timer_event_ptr = new TimerEvent;
    if (First_Timer_Event_In_Chain == NULL)
    {
        First_Timer_Event_In_Chain = timer_event_ptr;
        next_timer_event = NULL;
    }
    else
    {
        next_timer_event = First_Timer_Event_In_Chain;
        First_Timer_Event_In_Chain -> previous_timer_event =
            timer_event_ptr;

    }
    First_Timer_Event_In_Chain = timer_event_ptr;
    Timer_List.insert ((DWORD_PTR) timer_event, (DWORD_PTR) timer_event_ptr);
     /*
     **    Fill in the TimerEvent structure
     */
    timer_event_ptr->event_handle=timer_event;
    timer_event_ptr->timer_duration = timer_duration;
    timer_event_ptr->total_duration = timer_duration;
    timer_event_ptr->object_ptr = object_ptr;
    timer_event_ptr->timer_func_ptr = timer_func_ptr;
    timer_event_ptr->control_flags = control_flags | TIMER_EVENT_IN_USE;
    timer_event_ptr->next_timer_event = next_timer_event;
    timer_event_ptr->previous_timer_event = NULL;

    return (timer_event);
}


/*
 *    TimerError    Timer::DeleteTimerEvent (TimerEventHandle    timer_event)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine is called by the user to delete a timer event that is
 *        currently active.
 */
TimerError    Timer::DeleteTimerEvent (TimerEventHandle    timer_event)
{
    TimerError        return_value;
    PTimerEvent        timer_event_ptr;
    PTimerEvent        previous_timer_event_ptr;
    PTimerEvent        next_timer_event_ptr;

    if (Timer_List.find ((DWORD_PTR) timer_event, (PDWORD_PTR) &timer_event_ptr) == FALSE)
        return_value = TIMER_INVALID_TIMER_HANDLE;
    else
    {
        Timer_List.remove ((DWORD) timer_event);
        if (!(timer_event_ptr->control_flags & TIMER_EVENT_IN_USE))
            return_value = TIMER_INVALID_TIMER_HANDLE;
        else
        {
            if (timer_event_ptr->previous_timer_event == NULL)
                First_Timer_Event_In_Chain =
                        timer_event_ptr->next_timer_event;
            else
            {
                previous_timer_event_ptr =
                        timer_event_ptr->previous_timer_event;
                previous_timer_event_ptr->next_timer_event =
                        timer_event_ptr->next_timer_event;
            }
            if (timer_event_ptr->next_timer_event != NULL)
            {
                next_timer_event_ptr =
                        timer_event_ptr->next_timer_event;
                next_timer_event_ptr->previous_timer_event =
                        timer_event_ptr->previous_timer_event;
            }
            delete timer_event_ptr;
            Timer_Event_Free_Stack.append ((DWORD) timer_event);
            --Timer_Event_Count;

            return_value = TIMER_NO_ERROR;
        }
    }
    return (return_value);
}


/*
 *    void    Timer::ProcessTimerEvents (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This routine MUST be called frequently and regularly so that we can
 *        manage our timers.  This function gets the current system time and
 *        goes through each of the timers to see which have expired.  If a timer
 *        has expired, we call the function associated with it.  Upon return,
 *        if the timer was marked as a one-shot event, we remove it from our
 *        list of timers.
 */
void    Timer::ProcessTimerEvents (void)
{
    TimerEventHandle    timer_event;
    TimerEventHandle    next_timer_event;
    PTimerEvent            timer_event_ptr;
    IObject *                object_ptr;
    PTimerFunction        timer_func_ptr;
    ULONG                timer_increment;
    DWORD                timer_value;


    if (!First_Timer_Event_In_Chain)
        return;

     /*
     **    Get the current time
     */
    timer_value = GetTickCount ();
    timer_increment = timer_value - Last_Timer_Value;
    Last_Timer_Value = timer_value;

    next_timer_event = First_Timer_Event_In_Chain->event_handle;

     /*
     **    Go through each of the timer events to see if they have expired
     */
    while (Timer_List.find ((DWORD_PTR) next_timer_event, (PDWORD_PTR) &timer_event_ptr))
    {
        timer_event = timer_event_ptr->event_handle;
         /*
         **    Has the timer expired?
         */
        if (timer_event_ptr->timer_duration <= timer_increment)
        {
            object_ptr = timer_event_ptr->object_ptr;
            timer_func_ptr = timer_event_ptr->timer_func_ptr;

             /*
             **    Call the function before deleting...
             ** otherwise the function could manipulate the list
             ** and we wouldn't know if the one we're pointing to
             **    is still valid
             */
            (object_ptr->*timer_func_ptr) (timer_event);
             //     Get the next timer_event_handle
            if (timer_event_ptr->next_timer_event)
                next_timer_event = timer_event_ptr->next_timer_event->event_handle;
            else
                next_timer_event = NULL;
            if (timer_event_ptr->control_flags & TIMER_EVENT_ONE_SHOT)
                DeleteTimerEvent (timer_event);
            else
                timer_event_ptr->timer_duration =
                        timer_event_ptr->total_duration;
        }
        else
        {
             // Get the next timer_event_handle
            if (timer_event_ptr->next_timer_event)
                next_timer_event = timer_event_ptr->next_timer_event->event_handle;
            else
                next_timer_event = NULL;
            timer_event_ptr->timer_duration -= timer_increment;
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\timer.h ===
/*    Timer.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class maintains the current time and dispathes function calls
 *        when timers expire.  If a routine wants to be called in X amount of
 *        time, it creates a timer event with this class.  When the time expires,
 *        the function is called.  If the user wants to cancel the timer before
 *        it expires, he can use the DeleteTimerEvent() function.
 *
 *        When a person creates a timer event, one of the parameters is the 
 *        control flags.  The user can set the flag so that the event is a
 *        one-time thing or a constant event that occurs every X milliseconds.
 *
 *        This timer has a millisecond granularity.  The time passed into the
 *        CreateEventTimer() function is assumed to be in milliseconds.
 *
 *        The ProcessTimerEvents() function must be called frequently and 
 *        regularly so that the timeouts occur promptly.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James P. Galvin
 *        James W. Lawwill
 */
#ifndef _TIMER_
#define _TIMER_

/*
**    Possible Error values
*/
typedef    enum
{
    TIMER_NO_ERROR,
    TIMER_NO_TIMERS_AVAILABLE,
    TIMER_NO_TIMER_MEMORY,
    TIMER_INVALID_TIMER_HANDLE
}
    TimerError, * PTimerError;

/*
**    These defines are used in the control_flags variable in the TimerEvent
**    structure.  TIMER_EVENT_IN_USE is a flag used internal to the timer
**    procedure.  TIMER_EVENT_ONE_SHOT can be passed in by the user to 
**    signify that the timer should only occur once.
*/
#define TIMER_EVENT_IN_USE          0x0001
#define TIMER_EVENT_ONE_SHOT        0x0002

#define TRANSPORT_HASHING_BUCKETS   3

typedef USHORT               TimerEventHandle;
typedef TimerEventHandle    *PTimerEventHandle;

typedef void (IObject::*PTimerFunction) (TimerEventHandle);

/*
**    Each timer event has a TimerEvent structure associated with it.
*/
typedef struct TimerEventStruct
{
    TimerEventHandle    event_handle;
    ULong               timer_duration;
    ULong               total_duration;
    IObject            *object_ptr;
    PTimerFunction      timer_func_ptr;
    USHORT              control_flags;
    TimerEventStruct   *next_timer_event;
    TimerEventStruct   *previous_timer_event;
}
    TimerEvent, * PTimerEvent;

class    Timer
{
    public:
                            Timer (
                                    Void);
                            ~Timer (
                                    Void);
        TimerEventHandle    CreateTimerEvent (
                                    ULong            timer_duration,
                                    USHORT            control_flags,
                                    IObject *            object_ptr,
                                    PTimerFunction    timer_function);
        TimerError            DeleteTimerEvent (
                                    TimerEventHandle    timer_event);
        Void                ProcessTimerEvents (
                                    Void);

    private:
        USHORT                Maximum_Timer_Events;
        USHORT                Timer_Event_Count;
        SListClass            Timer_Event_Free_Stack;
        PTimerEvent            First_Timer_Event_In_Chain;
        DWORD                Last_Timer_Value;
        DictionaryClass        Timer_List;
};
typedef    Timer *        PTimer;

extern PTimer        System_Timer;

#define InstallTimerEvent(duration, control, func) \
    (g_pSystemTimer->CreateTimerEvent((duration),(control),this,(PTimerFunction)(func)))

#endif

/*
 *    Timer (Void)
 *
 *    Functional Description:
 *        This is the constructor for the timer class.  This procedure gets
 *        thc current Windows system time.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    ~Timer (Void)
 *
 *    Functional Description:
 *        This is the destructor for the timer class.  This routine frees all
 *        memory associated with timer events.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    TimerEventHandle    CreateTimerEvent (
 *                            ULong            timer_duration,
 *                            USHORT            control_flags,
 *                            IObject *            object_ptr,
 *                            PTimerFunction    timer_function);
 *
 *    Functional Description:
 *        This routine is called to create a timer event.  The routine stores the
 *        information passed-in in a TimerEvent structure.  When the timer expires
 *        the function will be called.
 *        
 *    Formal Parameters:
 *        timer_duration    -    (i)        Amount of time to wait before calling the 
 *                                    function.  The granularity of the timer
 *                                    is milliseconds.
 *        control_flags    -    (i)        This is a USHORT but currently we only 
 *                                    look at one of the bits.  The 
 *                                    TIMER_EVENT_ONE_SHOT can be passed-in by
 *                                    the user if they only want this timeout
 *                                    to occur once.  If this value is 0, the
 *                                    event will occur time after time.
 *        object_ptr        -    (i)        This is the data address of the object.  It
 *                                    is the 'this' pointer of the calling object.
 *        timer_function    -    (i)        This is the address of the function to 
 *                                    call after the timer expires.
 *
 *    Return Value:
 *        TimerEventHandle    -    This is a handle to the timer event.  If you
 *                                need to delete the timer event, pass this 
 *                                handle to the DeleteTimer() function.  A NULL
 *                                handle is returned if the create failed.
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    TimerError    DeleteTimerEvent (TimerEventHandle    timer_event)
 *
 *    Functional Description:
 *        This routine is called by the user to delete a timer event that is 
 *        currently active.  
 *        
 *    Formal Parameters:
 *        timer_event        -    (i)        Handle to a timer event 
 *
 *    Return Value:
 *        TIMER_NO_ERROR                -    Successful Delete
 *        TIMER_NO_TIMER_MEMORY        -    The timer_event can't exist because
 *                                        there was never any Timer memory
 *        TIMER_INVALID_TIMER_HANDLE    -    timer_event is not in our list 
 *                                        of timers
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */

/*
 *    Void    ProcessTimerEvents (Void)
 *
 *    Functional Description:
 *        This routine MUST be called frequently and regularly so that we can
 *        manage our timers.  This function gets the current system time and
 *        goes through each of the timers to see which have expired.  If a timer
 *        has expired, we call the function associated with it.  Upon return,
 *        if the timer was marked as a one-shot event, we remove it from our
 *        list of timers.
 *        
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None
 *
 *    Caveats:
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\t123.h ===
/*    T123.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class controlls the T123 stack associated with a particular 
 *        physical connection.  
 *
 *        This class builds a T123 PSTN stack. The physical layer is passed in via
 *        the constructor.  During the constructor, we instantiate a multiplexer.
 *        This multiplexer will allow us to mux multiple DataLink layers to the 
 *        same physical address.  For this particular physical connection (PSTN) 
 *        the Multiplexer adds a CRC to the packet and frames it before passing
 *        it to the physical layer.  On the receive side, it frames the incoming
 *        stream data and packetizes it.  It also checks the CRC for validity.
 *        The Multiplexer receives data from its higher layer 
 *        (DataLink) in packet form.  When the Multiplexer passes data to its 
 *        lower layer, it passes it in stream form.  The Multiplexer is
 *        configured to be a multi-DataLink entity.  Since it does handle multiple
 *        DataLinks, it can NOT buffer data on the receive side.  If one 
 *        particular DataLink is backed up, it can NOT hold the other DataLinks 
 *        up.  If it can not pass a packet up immediately, it will trash it. 
 *
 *        After the Multiplexer issues a callback to us to us it is ready, we 
 *        will create a DataLink Layer to service the Network layer.  The DataLink
 *        Layer is based on the Q.922 standard.  The DLCI associated with this 
 *        DataLink is 0.  Its Lower Layer is the Multiplexer.  Its Higher Layer is
 *        the SCF Layer.
 *
 *        The SCF Layer is the Network Layer.  It is responsible for 
 *        arbitrating the DLCI and parameters used in other transport 
 *        connections.  It has no responsibilities once the connection is up.  If
 *        this class receives a ConnectRequest() from the user, it issues a 
 *        ConnectRequest() to the SCF Layer.  SCF will notify us when the 
 *        connection is up.
 *        
 *        When the SCF notifies us that a new connection exists, we create a 
 *        DataLink Layer that services the new Transport Connection.  This 
 *        DataLink Layer uses our Multiplexer as its Lower Layer.
 *
 *        When the DataLink Layer is up and operational, it notifies us.  At this
 *        point, we create an X224 Layer to interface with the user.  The X224 
 *        Layer interfaces with the DataLink Layer to send data.  It also 
 *        interfaces with the user to pass data on up.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James W. Lawwill
 */
#ifndef _T123_H_
#define _T123_H_

#include "scf.h"
#include "q922.h"
#include "mplex.h"
#include "x224.h"

 /*
 **    Layer Numbers
 */
#define PHYSICAL_LAYER          1
#define MULTIPLEXER_LAYER       2    // This is a DataBeam-specific layer
#define DATALINK_LAYER          3
#define NETWORK_LAYER           4
#define TRANSPORT_LAYER         5



 /* 
 **    Layer Message Bases
 */
#define PHYSICAL_LAYER_MESSAGE_BASE     0x0000
#define MULTIPLEXER_LAYER_MESSAGE_BASE  0x1000
#define DATALINK_LAYER_MESSAGE_BASE     0x2000
#define NETWORK_LAYER_MESSAGE_BASE      0x3000
#define TRANSPORT_LAYER_MESSAGE_BASE    0x4000
#define LAYER_MASK                      0x7000
#define MESSAGE_MASK                    0x0fff

 /*
 **    Maximum number of priorities
 */
// #define    NUMBER_OF_PRIORITIES         15
#define    NUMBER_OF_PRIORITIES         4
#define    LOWEST_DLCI_VALUE            16
#define    HIGHEST_DLCI_VALUE           991

#define    INVALID_LOGICAL_HANDLE       0

 /*
 **    Each DLCI has this structure associated with it.
 */
typedef struct
{
    BOOL                link_originator;
    CLayerX224         *x224; // transport_layer
    CLayerQ922         *q922; // datalink_layer
    TransportPriority   priority;
    BOOL                disconnect_requested;
    BOOL                connect_requested;
    PMemoryManager      data_request_memory_manager;
    USHORT              network_retries;
}
    DLCIStruct, *PDLCIStruct;


class T123
{
public:

    T123(TransportController   *owner_object,
        USHORT                  message_base,
        BOOL                    link_originator,
        ComPort                *physical_layer,
        PhysicalHandle          physical_handle,
        PLUGXPRT_PARAMETERS    *pParams,
        BOOL *                  t123_initialized);

    virtual ~T123(void);

     /*
     **    Functions related to making and breaking a linkg
     */
    TransportError    ConnectRequest (
                        LogicalHandle        logical_handle,
                        TransportPriority    priority);
    TransportError    ConnectResponse (
                        LogicalHandle    logical_handle);
    TransportError    DisconnectRequest (
                        LogicalHandle    logical_handle,
                        UINT_PTR            trash_packets);
    TransportError    DataRequest (
                        LogicalHandle    logical_handle,
                        LPBYTE            user_data,
                        ULONG            user_data_length);
    TransportError    PurgeRequest (
                        LogicalHandle    logical_handle);
    void            EnableReceiver (void);

    ULONG            PollReceiver (void);
    void            PollTransmitter (void);

    ULONG OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

private:

    void            Reset (void);
    DLCI            GetNextDLCI (void);
    void            ProcessMessages (void);
    void            NetworkDisconnectIndication (
                        DLCI        dlci,
                        BOOL        link_originator,
                        BOOL        retry);
    void            DataLinkRelease (
                        DLCI    dlci,
                        DataLinkDisconnectType    error);
    void            NewConnection (void);
    void            NetworkConnectIndication (
                        PNetworkConnectStruct    connect_struct);
    void            NetworkConnectConfirm (
                        PNetworkConnectStruct    connect_struct);
    void            DataLinkEstablish (
                        DLCI    dlci);
private:

    BOOL                        m_fValidSDKParams;
    PLUGXPRT_PARAMETERS         m_SDKParams;

    DictionaryClass         Logical_Connection_List;
    DictionaryClass         DLCI_List;
    SListClass              Message_List;
    SListClass              DataLink_List;
    SListClass             *Logical_Connection_Priority_List[NUMBER_OF_PRIORITIES];
    
    TransportController    *m_pController;
    BOOL                    Link_Originator;
    USHORT                  m_nMsgBase;

    CLayerSCF              *m_pSCF; // network layer
    CLayerQ922             *m_pQ922; // data link layer
    Multiplexer            *m_pMultiplexer; // multiplexer layer
    ComPort                *m_pComPort; // physical layer
    PhysicalHandle          m_hCommLink;
    DataLinkParameters      DataLink_Struct;
    PMemoryManager          Data_Request_Memory_Manager;
#ifdef USE_RANDOM_CLASS
    PRandomNumberGenerator  Random;
#endif
    BOOL                    Disconnect_Requested;
};
typedef    T123 *        PT123;

#endif


/*
 *    Documentation for Public class members
 */

/*    
 *    T123::T123 (
 *            PTransportResources    transport_resources,
 *            IObject *                owner_object,
 *            USHORT                message_base,
 *            BOOL                link_originator,
 *            IProtocolLayer *        physical_layer,
 *            PhysicalHandle        physical_handle,
 *            BOOL *                initialized);
 *
 *    Functional Description
 *        This is the constructor for the T123 class.  It prepares for new
 *        connections.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Address of resources structure.
 *        owner_object        (i)    -    Address of owner object.  Used for owner
 *                                    callbacks.
 *        message_base        (i)    -    Message base used with owner callbacks.
 *        link_originator        (i)    -    TRUE if we actually originated the 
 *                                    connection
 *        physical_layer        (i)    -    Pointer to physical layer
 *        physical_handle        (i)    -    Identifier that needs to be passed to the
 *                                    physical layer to identify the connection
 *        initialized            (o)    -    TRUE if the object initialized OK.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    T123::~T123 (void)
 *
 *    Functional Description
 *        This is the T123 destructor.  It removes all active connections
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*    
 *    TransportError    T123::ConnectRequest (
 *                            LogicalHandle        logical_handle
 *                            TransportPriority    priority);
 *
 *    Functional Description
 *        This function initiates a logical connection.  
 *
 *    Formal Parameters
 *        logical_handle            (i)    -    Handle assocaiated with the 
 *                                        logical connection
 *        priority                (i)    -    Requested priority of the connection.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::ConnectResponse (
 *                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function is called in response to TRANSPORT_CONNECT_INDICATION 
 *        message that was sent the owner.  By making this call, the owner is 
 *        accepting the connection.
 *
 *    Formal Parameters
 *        logical_handle    (i)    -    Logical connection handle
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                    -    No Error
 *        TRANSPORT_CONNECT_RESPONSE_FAILURE    -    Function not valid
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::DisconnectRequest (
 *                            LogicalHandle    logical_handle,
 *                            BOOL            trash_packets);
 *
 *    Functional Description
 *        This function terminates the transport connection.  The user will 
 *        receive a TRANSPORT_DISCONNECT_INDICATION message when the connection
 *        is terminated
 *
 *        If the logical_handle equals INVALID_LOGICAL_HANDLE, the user is 
 *        telling us to take down all logical connections and ultimately the 
 *        physical connection.
 *
 *    Formal Parameters
 *        logical_handle         - (i)  Logical connection number to terminate
 *        trash_packets         - (i)  BOOL    , set to TRUE if we are to trash
 *                                   the packets in the output buffer.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::DataRequest (
 *                            LogicalHandle    logical_handle,
 *                            LPBYTE            user_data,
 *                            ULONG            user_data_length);
 *
 *    Functional Description
 *        This function is used to send a data packet to the remote location.
 *        We simply pass this packet to the X224 object associated with the 
 *        transport connection.
 *
 *    Formal Parameters
 *        logical_handle          - (i)  Transport connection number
 *        user_data              - (i)  Address of data to send
 *        user_data_length      - (i)  Length of data to send
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Logical connection does not exist
 *        TRANSPORT_WRITE_QUEUE_FULL        -    Transport write queues are already
 *                                            full.
 *        TRANSPORT_NOT_READY_TO_TRANSMIT    -    The transport layer is in the 
 *                                            process of building or breaking
 *                                            down the transport stack and is
 *                                            not ready for user data.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    TransportError    T123::PurgeRequest (
 *                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function purges the outbound packets for the logical connection.
 *
 *    Formal Parameters
 *        logical_handle - (i)  Transport connection number
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Logical connection does not exist
 *
 *    Side Effects
 *        None
 */

/*    
 *    TransportError    T123::EnableReceiver (void);
 *
 *    Functional Description
 *        This function is called to enable TRANSPORT_DATA_INDICATION callbacks 
 *        to the user application.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *
 *    Side Effects
 *        None
 */

/*    
 *    void    T123::PollReceiver (void);
 *
 *    Functional Description
 *        This function gives the T123 stack a chance to receive packets from 
 *        the remote site.  During this call, we may be making user callbacks to
 *        pass the data on up.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    void    T123::PollTransmitter (void);
 *
 *    Functional Description
 *        This function gives the T123 stack a chance to transmit data to the 
 *        remote site.  
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*    
 *    ULONG    T123::OwnerCallback (
 *                    USHORT    layer_message,
 *                    ULONG    parameter1,
 *                    ULONG    parameter2,
 *                    PVoid    parameter3);
 *
 *    Functional Description
 *        This function is the owner callback function.  If any of the layers
 *        owned by this object want to send us a message, they make an owner
 *        callback.  During instantiation of these lower layers, we pass them our
 *        address.  They can call us with significant messages.
 *
 *    Formal Parameters
 *        layer_message    (i)    -    Layer-specific message
 *        parameter1        (i)    -    Message-specific parameter
 *        parameter2        (i)    -    Message-specific parameter
 *        parameter3        (i)    -    Message-specific parameter
 *
 *    Return Value
 *        Message specific
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tprtcore.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    TransportController.cpp
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation file for the TransportController class
 *
 *    Private Instance Variables:
 *        Logical_Connection_List        -    This list uses the LogicalHandle
 *                                as a key and a pointer to a
 *                                TransportConnectionStruct as the value.  This
 *                                structure holds all of the pertinent information
 *                                about the connection.
 *        Protocol_Stacks        -    This list uses the physical handle as a key and
 *                                a pointer to a pointer to a object as the value.
 *                                Sometimes we need to find the T123 object
 *                                associated with a physical handle
 *        Message_List        -    Owner callback calls are placed in this list if
 *                                we can not process them immediately.
 *        Controller            -    Address of the PSTNController
 *        Emergency_Shutdown    -    Set to TRUE if we have encountered a situation
 *                                where the integrity of the Transport has been
 *                                compromised.  As a result, all connections will
 *                                be purged.
 *        Poll_Active            -    Set to TRUE while we are in a PollReceiver() or
 *                                PollTransmitter() call.  This solves our re-
 *                                entrancy problems.
 *
 *    Caveats:
 *        None
 *
 *    Author:
 *        James W. Lawwill
 */
#include "tprtcore.h"


/*
 *    TransportController::TransportController (
 *                            PTransportResources    transport_resources)
 *
 *    Public
 *
 *    Functional Description:
 *        TransportController constructor.  We instantiate the PSTNController
 *        and initialize the T123 class.
 */
TransportController::TransportController(void)
:
    Protocol_Stacks (TRANSPORT_HASHING_BUCKETS),
    Logical_Connection_List (TRANSPORT_HASHING_BUCKETS)
{
    TRACE_OUT(("TransportController::TransportController"));

    Emergency_Shutdown = FALSE;
    Poll_Active = FALSE;
}


/*
 *    TransportController::~TransportController (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TransportController destructor.  All allocated memory is
 *        released and all lists are cleared
 */
TransportController::~TransportController (void)
{
    TRACE_OUT(("TransportController::~TransportController"));

    Reset (FALSE);
}


TransportError TransportController::CreateTransportStack
(
    BOOL                fCaller,
    HANDLE              hCommLink,
    HANDLE              hevtClose,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TRACE_OUT(("TransportController::CreateTransportStack"));

    DBG_SAVE_FILE_LINE
    ComPort *comport = new ComPort(this, PHYSICAL_LAYER_MESSAGE_BASE,
                                   pParams,
                                   hCommLink,
                                   hevtClose);
    if (NULL != comport)
    {
        TransportError rc = CreateT123Stack(hCommLink, fCaller, comport, pParams);
        if (TRANSPORT_NO_ERROR == rc)
        {
            ComPortError cperr = comport->Open();
            if (COMPORT_NO_ERROR == cperr)
            {
                return TRANSPORT_NO_ERROR;
            }
        }

        ERROR_OUT(("TransportController::CreateTransportStack: cannot open comm port"));
        return TRANSPORT_INITIALIZATION_FAILED;
    }

    ERROR_OUT(("TransportController::CreateTransportStack: cannot allocate ComPort"));
    return TRANSPORT_MEMORY_FAILURE;
}


TransportError TransportController::CloseTransportStack
(
    HANDLE          hCommLink
)
{
    TRACE_OUT(("TransportController::CloseTransportStack"));

     /*
     **    If for some reason we get an error on the ConnectRequest(),
     **    take the physical connection down.
     */
    T123 *t123 = NULL;
    if (Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        RemoveLogicalConnections (hCommLink);

         /*
         **    Remove the T123 object from the lists and
         **    delete the object
         */
        Transmitter_List.remove((DWORD_PTR) t123);
        Protocol_Stacks.remove((DWORD_PTR) hCommLink);
        delete t123;
    }

    // find the physical layer through the physical handle
    ComPort *comport;
    if (! g_pComPortList2->find((DWORD_PTR) hCommLink, (PDWORD_PTR) &comport))
    {
        WARNING_OUT(("TransportController::CloseTransportStack: cannot find comport for hCommLink=%d", hCommLink));
        return TRANSPORT_PHYSICAL_LAYER_NOT_FOUND;
    }
    ASSERT(NULL != comport);

    // close and delete the device
    // g_pComPortList2->remove((DWORD) hCommLink); // removed in handling "delete event"
    comport->Release();

    return TRANSPORT_NO_ERROR;
}


/*
 *    TransportError    TransportController::ConnectRequest (
 *                                    TransportAddress        transport_address,
 *                                    TransportPriority        transport_priority,
 *                                    LogicalHandle *           logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connection.  It passes the transport address
 *        to the PSTN Controller.  It will either deny the request or accept the
 *        request and call us back when the physical connection is established.
 *
 *        We return the transport connection handle in the logical_handle
 *        address.  Although we return this transport number to the user, it
 *        is not ready for data transfer until the user receives the
 *        TRANSPORT_CONNECT_INDICATION message via the callback.  At that point,
 *        the logical connection is up and running.
 */
TransportError TransportController::ConnectRequest
(
    LogicalHandle      *logical_handle,
    HANDLE              hCommLink,          // physical handle
    TransportPriority   transport_priority
)
{
    TRACE_OUT(("TransportController::CreateConnection"));

    *logical_handle = GetNextLogicalHandle();
    if (INVALID_LOGICAL_HANDLE == *logical_handle)
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot allocate logical handle"));
        return TRANSPORT_MEMORY_FAILURE;
    }

    // find the physical layer through the physical handle
    ComPort *comport;
    if (! g_pComPortList2->find((DWORD_PTR) hCommLink, (PDWORD_PTR) &comport))
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot find comport for hCommLink=%d", hCommLink));
        return TRANSPORT_PHYSICAL_LAYER_NOT_FOUND;
    }
    ASSERT(NULL != comport);

     /*
     **    Register the connection handle in out Logical_Connection_List. After the
     **    physical connection is established, we will create a T123 object
     ** and request a logical connection to the remote site.
     **
     **    This structure contains the information necessary to maintain the
     ** logical connection.
     **
     **    The t123_connection_requested is set to TRUE when we have issued
     **    a ConnectRequest() to the T123 object for this logical connection.
     */
    DBG_SAVE_FILE_LINE
    PLogicalConnectionStruct pConn = new LogicalConnectionStruct;
    if (pConn == NULL)
    {
        ERROR_OUT(("TransportController::ConnectRequest: cannot to allocate LogicalConnectionStruct"));
        return (TRANSPORT_MEMORY_FAILURE);
    }

    pConn->fCaller = TRUE;
    pConn->comport = comport;
    pConn->t123 = NULL;
    pConn->t123_connection_requested = FALSE;
    pConn->t123_disconnect_requested = FALSE;
    pConn->priority = transport_priority;
    pConn->hCommLink = hCommLink;
    Logical_Connection_List.insert((DWORD_PTR) *logical_handle, (DWORD_PTR) pConn);

    return NewConnection(hCommLink, TRUE, comport);
}


/*
 *    TransportError    TransportController::ConnectResponse (
 *                                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the user in response to a
 *        TRANSPORT_CONNECT_INDICATION callback from us.  By making this call the
 *        user is accepting the call.  If the user does not want to accept the
 *        he should call DisconnectRequest ();
 */
TransportError TransportController::ConnectResponse
(
    LogicalHandle       logical_handle
)
{
    TRACE_OUT(("TransportController::ConnectResponse"));

    PLogicalConnectionStruct   pConn;
    PT123                      t123;

     /*
     **    If this is an invalid handle, return error
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
        return (TRANSPORT_NO_SUCH_CONNECTION);

    t123 = pConn -> t123;

     /*
     **    If the user calls this function before the T123 object is created, that
     **    is an error
     */
    return (t123 != NULL) ? t123->ConnectResponse(logical_handle) : TRANSPORT_NO_SUCH_CONNECTION;
}


/*
 *    TransportError    TransportController::DisconnectRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            BOOL            trash_packets)
 *
 *    Public
 *
 *    Functional Description:
 *        This function issues a Disconnect request to the T123 object (if it
 *        exists).  If T123 does not exist, it hangs up the physical connection.
 */
TransportError TransportController::DisconnectRequest
(
    LogicalHandle       logical_handle,
    UINT_PTR                trash_packets
)
{
    TRACE_OUT(("TransportController::DisconnectRequest"));

    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;
    BOOL                        transport_found;
    PT123                       t123;
    PMessageStruct              passive_message;
    TransportError              rc = TRANSPORT_NO_ERROR;

     /*
     **    If the logical connection handle is not registered, return error
     */
    if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn) == FALSE)
        return (TRANSPORT_NO_SUCH_CONNECTION);

    TRACE_OUT(("TPRTCTRL: DisconnectRequest for logical handle %d", logical_handle));

     /*
     **    Calling this function during a callback from this transport
     **    is a re-entrancy problem.  In this case, we add a message to
     **    our Message_List and process the request later.
     */
    if (! Poll_Active)
    {
         /*
         **    We set the t123_disconnect_requested to TRUE at this point so
         **    that when we get the TPRT_DISCONNECT_INDICATION message back
         **    from the t123 object, we will know who originated the
         **    operation.  If we originated the operation locally, we do not
         **    issue a TRANSPORT_DISCONNECT_INDICATION to the user.
         */
        pConn -> t123_disconnect_requested = TRUE;

         /*
         **    If a T123 object is associated with this object, issue a disconnect
         */
        t123 = pConn -> t123;
        if (t123 != NULL)
        {
            t123 -> DisconnectRequest (logical_handle, trash_packets);
        }
        else
        {
             /*
             **    This occurs if the user wants to terminate the connection
             **    before it comes all the way up
             **
             **    Remove the transport connection handle from the
             **    Logical_Connection_List
             */
            Logical_Connection_List.remove (logical_handle);
            delete pConn;
        }
    }
    else
    {
         /*
         **    If we are in the middle of a PollReceiver() or PollTransmitter(),
         **    and this function is being called  during a callback from this
         **    transport, save the message and process it later.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = TPRT_DISCONNECT_REQUEST;
            passive_message -> parameter1 = (void *) logical_handle;
            passive_message -> parameter2 = (void *) trash_packets;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TransportController::DisconnectRequest: cannot allocate MessageStruct"));
            rc = TRANSPORT_MEMORY_FAILURE;
        }
    }

    return rc;
}


/*
 *    TransportError    TransportController::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function allows data packets to be sent to the user application.
 *        Prior to this call, we must have sent a data packet to the user and
 *        the user must not have been able to accept it.  When this happens, the
 *        user must issue this call to re-enable TRANSPORT_DATA_INDICATIONs.
 *        callbacks.
 */
void TransportController::EnableReceiver(void)
{
    TRACE_OUT(("TransportController::EnableReceiver"));

    PT123                       t123;
    PLogicalConnectionStruct    pConn;

     /*
     **    Go through each of the Transports and enable the receivers
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn))
    {
        t123 = pConn -> t123;

         /*
         **    If the protocol stack pointer is set to NULL, then we have not
         **    realized that the socket is up and functional.
         */
        if (t123 != NULL)
        {
            t123 -> EnableReceiver ();
        }
    }
}


/*
 *    TransportError    TransportController::DataRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            LPBYTE            user_data,
 *                                            ULONG            user_data_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is used to send a data packet to the remote site.
 *        This function passes the request to the T123 stack associated with
 *        the transport connection handle
 */
TransportError TransportController::DataRequest
(
    LogicalHandle       logical_handle,
    LPBYTE              user_data,
    ULONG               user_data_length
)
{
    TRACE_OUT(("TransportController::DataRequest"));

    PLogicalConnectionStruct    pConn;
    PT123                       t123;

     /*
     **    Verify that this connection exists and is ready for data
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
    {
        WARNING_OUT(("TPRTCTRL: DataRequest: Illegal logical_handle"));
        return (TRANSPORT_NO_SUCH_CONNECTION);
    }

     /*
     **    Attempt to send that data to the T123 Layer
     */
    t123 = pConn -> t123;
    return (t123 != NULL) ? t123->DataRequest(logical_handle, user_data, user_data_length) :
                            TRANSPORT_NOT_READY_TO_TRANSMIT;
}


/*
 *    TransportError    TransportController::PurgeRequest (
 *                                            LogicalHandle    logical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to remove data from our output queues.  The
 *        user application usually calls this to speed up the disconnect process.
 */
TransportError TransportController::PurgeRequest
(
    LogicalHandle       logical_handle
)
{
    TRACE_OUT(("TransportController::PurgeRequest"));

    PLogicalConnectionStruct    pConn;
    PT123                       t123;

     /*
     **    If the transport connection handle is not registered, return error
     */
    if (! Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
        return (TRANSPORT_NO_SUCH_CONNECTION);

    t123 = pConn -> t123;
    return (t123 != NULL) ? t123->PurgeRequest(logical_handle) : TRANSPORT_NO_ERROR;
}


/*
 *    void    TransportController::PollReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called to give us a chance to process incoming data
 */
void TransportController::PollReceiver(void)
{
    // TRACE_OUT(("TransportController::PollReceiver"));

    PT123    t123;

    if (! Poll_Active)
    {
        ProcessMessages ();
        Poll_Active = TRUE;

        if (! Transmitter_List.isEmpty())
        {
            Transmitter_List.reset();
            while (Transmitter_List.iterate((PDWORD_PTR) &t123))
            {
                t123-> PollReceiver ();
            }

              /*
             **    The following code removes the first t123 object from the
             **    list and puts it at the end of the list.  This attempts to
             **    give the t123 objects equal access to the user application.
             **    If we did not do this, one t123 object would always be able
             **    to send its data to the user application and other t123
             **    objects would be locked out.
             */
            Transmitter_List.append (Transmitter_List.get ());
        }
        Poll_Active = FALSE;
    }
}


/*
 *    void    TransportController::PollReceiver (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 *        This function gives the t123 object associated with this physical
 *        handle a chance to process incoming data.
 */
void TransportController::PollReceiver
(
    PhysicalHandle          physical_handle
)
{
    // TRACE_OUT(("TransportController::PollReceiver"));

    PT123    t123;

    if (! Poll_Active)
    {
        ProcessMessages ();
        Poll_Active = TRUE;

         /*
         **    See if there is a t123 object associated with this
         **    physical handle
         */
        if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
        {
            if (t123->PollReceiver() == PROTOCOL_LAYER_ERROR)
            {
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
        }

        Poll_Active = FALSE;
    }
}


/*
 *    void    TransportController::PollTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function processes output data to remote sites.  This
 *        function MUST be called on a REGULAR and FREQUENT basis so that
 *        we can maintain the physical connections in a timely manner.
 */
void TransportController::PollTransmitter(void)
{
    // TRACE_OUT(("TransportController::PollTransmitter"));

    if (! Poll_Active)
    {
        PT123        t123;

        Poll_Active = TRUE;

         /*
         **    Allow each t123 object to transmit any data it has available.
         */
        Transmitter_List.reset();
        while (Transmitter_List.iterate ((PDWORD_PTR) &t123))
        {
            t123->PollTransmitter ();
        }

        Poll_Active = FALSE;
        ProcessMessages ();
    }
}


/*
 *    void    TransportController::PollTransmitter (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Public
 *
 *    Functional Description:
 */
void TransportController::PollTransmitter
(
    PhysicalHandle          physical_handle
)
{
    // TRACE_OUT(("TransportController::PollTransmitter"));

    PT123    t123;

    if (! Poll_Active)
    {
        Poll_Active = TRUE;

         /*
         **    See if there is a t123 object associated with this
         **    physical handle
         */
        if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
        {
            t123->PollTransmitter();
        }

        Poll_Active = FALSE;
        ProcessMessages ();
    }
}


/*
 *    PhysicalHandle    TransportController::GetPhysicalHandle (
 *                        LogicalHandle    logical_handle);
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the physical handle associated with the
 *        logical handle.
 */
PhysicalHandle    TransportController::GetPhysicalHandle (
                                        LogicalHandle    logical_handle)
{
    TRACE_OUT(("TransportController::GetPhysicalHandle"));

    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;

    if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
    {
        physical_handle = pConn -> hCommLink;
    }
    else
    {
        physical_handle = 0;
    }

    return (physical_handle);
}


/*
 *    ULONG    TransportController::OwnerCallback (
 *                                    CallbackMessage    message,
 *                                    ULONG            parameter1,
 *                                    ULONG            parameter2,
 *                                    PVoid            parameter3)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the PSTNController and the T123 object(s).
 *        This function is called when a significant event occurs.  This gives the
 *        lower objects the ability to communicate with the higher layer.
 */
ULONG_PTR TransportController::OwnerCallback
(
    ULONG       message,
    void       *parameter1,
    void       *parameter2,
    void       *parameter3
)
{
    TRACE_OUT(("TransportController::OwnerCallback"));

    PMessageStruct              passive_message;
    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    LegacyTransportID           transport_identifier;
    ULONG_PTR                   return_value = 0;
    PT123                       t123;

    message = message - TRANSPORT_CONTROLLER_MESSAGE_BASE;

    switch (message)
    {
    case TPRT_CONNECT_INDICATION:
         /*
         **    The TPRT_CONNECT_INDICATION message comes from a T123
         **    object when the remote site is attempting to make a
         **    logical connection with    us.  We issue a callback to the
         **    user to notify him of the request
         */

        // LONCHANC: we automatically accept the call
        ConnectResponse((LogicalHandle) parameter1);

        transport_identifier.logical_handle = (LogicalHandle) parameter1;

        if (Logical_Connection_List.find((DWORD_PTR) parameter1, (PDWORD_PTR) &pConn))
        {
            transport_identifier.hCommLink = pConn->hCommLink;
        }
        else
        {
            transport_identifier.hCommLink = NULL;
        }

        TRACE_OUT(("TPRTCTRL: CONNECT_INDICATION: physical_handle = %d",
            transport_identifier.hCommLink));

        ::NotifyT120(TRANSPORT_CONNECT_INDICATION, &transport_identifier);
        break;

    case TPRT_CONNECT_CONFIRM:
         /*
         **    The TPRT_CONNECT_CONFIRM message comes from a T123 object
         **    when a logical connection that we requested is up and
         **    running.  We notify the user of this by issuing a callback.
         */
        transport_identifier.logical_handle = (LogicalHandle) parameter1;

        if (Logical_Connection_List.find((DWORD_PTR) parameter1, (PDWORD_PTR) &pConn))
        {
            transport_identifier.hCommLink = pConn->hCommLink;
        }
        else
        {
            transport_identifier.hCommLink = NULL;
        }

        TRACE_OUT(("TPRTCTRL: CONNECT_CONFIRM: physical_handle = %d",
            transport_identifier.hCommLink));

        ::NotifyT120(TRANSPORT_CONNECT_CONFIRM, &transport_identifier);
        break;

    case REQUEST_TRANSPORT_CONNECTION:
         /*
         **    This message is issued when a T123 object is making a new
         **    logical connection and needs a new logical handle.
         **
         **    If we return INVALID_LOGICAL_HANDLE, we wer not able to
         **    get a handle.
         */
        logical_handle = GetNextLogicalHandle();
        if (logical_handle == INVALID_LOGICAL_HANDLE)
        {
            return_value = INVALID_LOGICAL_HANDLE;
            break;
        }

         /*
         **    Register the new transport connection handle in the
         **    Logical_Connection_List
         **
         **    Parameter1 holds the physical handle
         */
        DBG_SAVE_FILE_LINE
        pConn = new LogicalConnectionStruct;
        if (pConn != NULL)
        {
            Logical_Connection_List.insert (logical_handle, (DWORD_PTR) pConn);
            pConn->fCaller = FALSE;
            pConn->hCommLink = (PhysicalHandle) parameter1;
            Protocol_Stacks.find((DWORD_PTR) parameter1, (PDWORD_PTR) &t123);
            pConn -> t123 = t123;

             /*
             **    Set the t123_connection_requested to TRUE.  We didn't
             **    actually make a ConnectRequest() but the T123 object does
             **    know about the connection
             */
            pConn -> t123_connection_requested = TRUE;
            pConn -> t123_disconnect_requested = FALSE;
            return_value = logical_handle;
        }
        else
        {
            TRACE_OUT(("TPRTCTRL: Unable to allocate memory "
                "for connection"));
            return_value = INVALID_LOGICAL_HANDLE;
        }
        break;

     /*
     **    The following messages can NOT be processed during the callback.
     **    They are passive messages, that is they must be saved and
     **    processed at a later time.   The BROKEN_CONNECTION and
     **    TPRT_DISCONNECT_INDICATION messages involve destroying t123
     **    objects.  If we deleted an object here and then returned to
     **    the object, this would cause a GPF.  Therefore these messages
     **    are processed later.
     **
     **    The NEW_CONNECTION callback is processed later because we want
     **    to process certain messages in the order they were received.  If
     **    we received a NEW_CONNECTION followed by a BROKEN_CONNECTION
     **    followed by a NEW_CONNECTION, and we only processed the
     **    NEW_CONNECTION messages as they were received, it would really
     **    confuse the code.
     */
    case TPRT_DISCONNECT_INDICATION:
    case BROKEN_CONNECTION:
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
            Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: TPRT_DISCONNECT_INDICATION: cannot allocate MessageStruct"));
            Emergency_Shutdown = TRUE;
        }
        break;

    case NEW_CONNECTION:
          /*
         ** If we can not allocate the memory needed to store this
         **    message, we need to return a non-zero value to the
         **    calling routine.
         */
        DBG_SAVE_FILE_LINE
        passive_message = new MessageStruct;
        if (passive_message != NULL)
        {
            passive_message -> message = message;
            passive_message -> parameter1 = parameter1;
            passive_message -> parameter2 = parameter2;
            passive_message -> parameter3 = parameter3;
                Message_List.append ((DWORD_PTR) passive_message);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: NEW_CONNECTION: cannot allocate MessageStruct"));
            return_value = 1;
        }
        break;

    default:
        ERROR_OUT(("TPRTCTRL: OwnerCallback: Illegal message = %lx", message));
        break;
    }
    return (return_value);
}


/*
 *    void TransportController::ProcessMessages (void)
 *
 *    Functional Description
 *        This function is called periodically to process any passive owner
 *        callbacks.  If an owner callback can not be processed immediately,
 *        it is put into the Message_List and processed at a later time.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::ProcessMessages(void)
{
    // TRACE_OUT(("TransportController::ProcessMessages"));

    ULONG                       message;
    PMessageStruct              message_struct;
    IProtocolLayer             *physical_layer;
    void                       *parameter1;
    void                       *parameter2;
    void                       *parameter3;

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    PhysicalHandle              physical_handle;
    BOOL                        save_message = FALSE;
    LegacyTransportID           transport_identifier;
    PT123                       t123;
    BOOL                        link_originator;
    BOOL                        disconnect_requested;
    ComPort                    *comport;

     /*
     **    This routine can not be called during a callback from this transport.
     **    In other words this code is not re-entrant.
     */
    if (Poll_Active)
        return;

     /*
     **    Emergency_Shutdown can occur if we unsuccessfully attempt to allocate
     **    memory.  In this situation, we shutdown the entire Transport
     */
    if (Emergency_Shutdown)
    {
        Reset (TRUE);
        Emergency_Shutdown = FALSE;
    }

     /*
     **    Go thru the Message_List until it is empty or until a message
     **    can not be processed.
     */
    while ((! Message_List.isEmpty ()) && (! save_message))
    {
         /*
         **    Look at the first message in the Message_List.
         */
        message_struct = (PMessageStruct) Message_List.read ();
        message = (message_struct -> message) - TRANSPORT_CONTROLLER_MESSAGE_BASE;
        parameter1 = message_struct -> parameter1;
        parameter2 = message_struct -> parameter2;
        parameter3 = message_struct -> parameter3;

        switch (message)
        {
        case NEW_CONNECTION:
            ASSERT(0); // impossible
             /*
             **    This message is issued by the PSTNController to notify us
             **    a new physical connection exists or that a previously
             **    requested connection is going to be muxed over a
             **    currently active physical connection
             **
             **    Parameter1 is the physical handle
             **    Parameter2 is a BOOL     used to tell us if
             **    Parameter3 is the address of the physical layer handling
             **    this connection.
             */
            physical_handle = (PhysicalHandle) parameter1;
            link_originator = (BOOL) (DWORD_PTR)parameter2;
            comport = (ComPort *) parameter3;

            TRACE_OUT(("TPRTCTRL: ProcessMessage NEW_CONNECTION: Physical: handle = %ld", physical_handle));

            if (TRANSPORT_NO_ERROR != NewConnection(physical_handle, link_originator, comport))
            {
                save_message = TRUE;
            }
            break;

        case BROKEN_CONNECTION:
            ASSERT(0); // impossible
             /*
             **    This message is issued by the PSTNController when a
             **    physical connection has been broken.
             **
             **    parameter1 = physical_handle
             */
            physical_handle = (PhysicalHandle) parameter1;

            TRACE_OUT(("TPRTCTRL: BROKEN_CONNECTION: phys_handle = %lx", physical_handle));

             /*
             **    RemoveLogicalConnections() terminates all logical
             **    connections associated with this physical handle.
             **    There may be logical connections in our list even
             **    though a T123 does not exist for the physical handle
             */
            TRACE_OUT(("TPRTCTRL: RemoveLogicalConnections: phys_handle = %lx", physical_handle));
            RemoveLogicalConnections (physical_handle);

             /*
             **    Check to see if there is a t123 stack associated
             **    with this physical handle.
             */
            if (Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
            {
                 /*
                 **    Remove the T123 protocol stacks from our lists and
                 **    delete it.
                 */
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
            break;

        case TPRT_DISCONNECT_REQUEST:
             /*
             **    This message occurs when a DisconnectRequest() was received
             **    during a PollReceiver() call.  We can NOT process the
             **    DisconnectRequest() during our callback to the user
             **    application, but we can queue the message and process it
             **    now
             */
            DisconnectRequest((LogicalHandle) parameter1, (BOOL) (DWORD_PTR)parameter2);
            break;

        case TPRT_DISCONNECT_INDICATION:
             /*
             **    This message is received from a T123 object when a logical
             **    connection is terminated.  If the logical connection
             **    handle passed in parameter1 is INVALID_LOGICAL_HANDLE,
             **    the T123 object is telling us to terminate it.
             **
             **    parameter1 = logical_handle
             **    parameter2 = physical_handle
             **    parameter3 = BOOL     - TRUE if we requested this
             **                 disconnection.
             */
            logical_handle = (LogicalHandle) parameter1;
            physical_handle = (PhysicalHandle) parameter2;

             /*
             **    Check the physical_handle to make sure it is valid
             */
            if (! Protocol_Stacks.find((DWORD_PTR) physical_handle, (PDWORD_PTR) &t123))
            {
                ERROR_OUT(("TPRTCTRL: ProcessMessages: DISCONNECT_IND **** Illegal Physical Handle = %ld", physical_handle));
                break;
            }

             /*
             **    If the logical_handle is INVALID_LOGICAL_HANDLE, the
             **    T123 object is telling us to delete it.
             */
            if (logical_handle == INVALID_LOGICAL_HANDLE)
            {
                TRACE_OUT(("TPRTCTRL: Protocol stack deleted - phys handle = %ld", physical_handle));

                 /*
                 **    Find out the value of parameter3 before we
                 **    delete the t123 object.
                 */
                disconnect_requested = *((BOOL *) parameter3);

                 /*
                 **    Call RemoveLogicalConnections() to remove all logical
                 **    connections associated with this physical handle.
                 */
                RemoveLogicalConnections (physical_handle);

                 /*
                 **    Remove the T123 object from the lists and delete the
                 **    object
                 */
                Transmitter_List.remove((DWORD_PTR) t123);
                Protocol_Stacks.remove((DWORD_PTR) physical_handle);
                delete t123;
            }
            else
            if (Logical_Connection_List.find (logical_handle, (PDWORD_PTR) &pConn))
            {
                 /*
                 **    This specifies that a logical connection needs to be
                 ** removed.  We remove it from the Logical_Connection_List
                 **    and notify the user of the disconnection
                 */
                Logical_Connection_List.remove (logical_handle);

                if (! pConn->t123_disconnect_requested)
                {
                    transport_identifier.logical_handle = logical_handle;
                    transport_identifier.hCommLink = physical_handle;

                    ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
                }
                delete pConn;
            }
            break;

        default:
            ERROR_OUT(("TPRTCTRL: ProcessMessages: Illegal message = %lx", message));
            break;
        }

         /*
         **    If save_message is TRUE, the message needs to be re-processed at a
         **    later time.
         */
        if (! save_message)
        {
            delete ((PMessageStruct) Message_List.get ());
        }
    }
}


/*
 *    void    TransportController::Reset (
 *                                    BOOL        notify_user)
 *
 *    Functional Description
 *        This function deletes all stacks and TCs.  If the notify_user flag is
 *        set to TRUE, it makes a callback to the user.
 *
 *    Formal Parameters
 *        notify_user        (i)    -    Notify User flag
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::Reset
(
    BOOL            notify_user
)
{
    TRACE_OUT(("TransportController::Reset"));

    LogicalHandle               logical_handle;
    PMessageStruct              message_struct;
    LegacyTransportID           transport_identifier;
    PhysicalHandle              physical_handle;
    PLogicalConnectionStruct    pConn;
    PT123                       t123;

    TRACE_OUT(("TPRTCTRL: reset: notify_user = %d", notify_user));

     /*
     **    Delete all of the stacks
     */
    Protocol_Stacks.reset();
    while (Protocol_Stacks.iterate((PDWORD_PTR) &t123))
    {
        delete t123;
    }

    Protocol_Stacks.clear ();
    Transmitter_List.clear ();

     /*
     **    Empty the message list
     */
    while (! Message_List.isEmpty ())
    {
        delete ((PMessageStruct) Message_List.get ());
    }

     /*
     **    Empty the Logical_Connection_List
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
        if (pConn != NULL)
        {
            physical_handle = pConn->hCommLink;
            delete pConn;
        }
        else
        {
            physical_handle = 0;
        }

        if (notify_user)
        {
            transport_identifier.logical_handle = logical_handle;
            transport_identifier.hCommLink = physical_handle;

            ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
        }
    }
    Logical_Connection_List.clear ();
}


/*
 *    BOOL        TransportController::NewConnection (
 *                                        PhysicalHandle    physical_handle,
 *                                        BOOL             link_originator,
 *                                        IProtocolLayer *    physical_layer)
 *
 *    Functional Description
 *        This function is called when a new physical connection is created.  It
 *        creates a T123 object if necessary.
 *
 *    Formal Parameters
 *        physical_handle    (i)    -    physical handle of the new physical connection
 *        link_originator    (i)    -    TRUE if we initiated the connection.
 *        physical_layer    (i)    -    Address of the physical layer.
 *
 *    Return Value
 *        TRUE, if the new connection was successfully executed.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
TransportError TransportController::CreateT123Stack
(
    PhysicalHandle      hCommLink,
    BOOL                link_originator, // fCaller
    ComPort            *comport,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TRACE_OUT(("TransportController::CreateT123Stack"));

    TransportError rc = TRANSPORT_NO_ERROR;

     /*
     **    Do we need to create a new t123 stack for this physical connection.
     */
    T123 *t123 = NULL;
    if (! Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        BOOL initialized;
        DBG_SAVE_FILE_LINE
        t123 = new T123(this,
                        TRANSPORT_CONTROLLER_MESSAGE_BASE,
                        link_originator,
                        comport,
                        hCommLink,
                        pParams,
                        &initialized);
        if (t123 != NULL && initialized)
        {
             /*
             **    Put the T123 object into the Protocol_Stacks
             **    and Transmitter_List arrays
             */
            Protocol_Stacks.insert((DWORD_PTR) hCommLink, (DWORD_PTR) t123);
            Transmitter_List.append((DWORD_PTR) t123);
        }
        else
        {
            ERROR_OUT(("TPRTCTRL: CreateT123Stack: cannot allocate T123"));
            delete t123;
            rc = TRANSPORT_MEMORY_FAILURE;
        }
    }

    return rc;
}


TransportError TransportController::NewConnection
(
    PhysicalHandle      hCommLink,
    BOOL                link_originator,
    ComPort            *comport
)
{
    TRACE_OUT(("TransportController::NewConnection"));

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    BOOL                        initialized;
    T123                       *t123;
    TransportError              rc;

    if (! Protocol_Stacks.find((DWORD_PTR) hCommLink, (PDWORD_PTR) &t123))
    {
        ERROR_OUT(("TransportController::NewConnection: cannot find T123 stack, hCommLink=%d", hCommLink));
        return TRANSPORT_NO_T123_STACK;
    }

     /*
     **    Go through each of the logical connections to find the
     **    ones that are waiting for this physical connection to be
     **    established.  The PSTNController object issues a
     **    NEW_CONNECTION callback for each logical connection that
     **    needs to be initiated.
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
         /*
         **    Compare the physical handles, if they are the same,
         **    check to see if this logical connection has already issued
         **    a ConnectRequest() to the T123 object.
         */
        if (hCommLink == pConn->hCommLink)
        {
             /*
             **    See if this connection has already issued a ConnectRequest
             */
            if (! pConn->t123_connection_requested)
            {
                 /*
                 **    Fill in the transport structure.
                 */
                pConn->t123 = t123;
                pConn->comport = comport;
                pConn->t123_connection_requested = TRUE;

                 /*
                 **    Issue a Connect Request to the T123 object
                 */
                rc = t123->ConnectRequest(logical_handle, pConn->priority);

                 /*
                 **    If for some reason we get an error on the ConnectRequest(),
                 **    take the physical connection down.
                 */
                if (rc != TRANSPORT_NO_ERROR)
                {
                    RemoveLogicalConnections (hCommLink);

                     /*
                     **    Remove the T123 object from the lists and
                     **    delete the object
                     */
                    Transmitter_List.remove((DWORD_PTR) t123);
                    Protocol_Stacks.remove((DWORD_PTR) hCommLink);
                    delete t123;
                }
            }
        }
    }

    return TRANSPORT_NO_ERROR;
}


/*
 *    LogicalHandle TransportController::GetNextLogicalHandle (void);
 *
 *    Functional Description
 *        This function returns an available logical handle
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        The next available logical handle
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
LogicalHandle TransportController::GetNextLogicalHandle (void)
{
    LogicalHandle    logical_handle = 1;

     /*
     **    Go thru the Logical_Connection_list, looking for the first
     **    available entry
     */
    while (Logical_Connection_List.find (logical_handle) &&
           (logical_handle != INVALID_LOGICAL_HANDLE))
    {
        logical_handle++;
    }

    return (logical_handle);
}


/*
 *    void    TransportController::RemoveLogicalConnections (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function removes all logical connections associated with the
 *        passed in physical handle
 *
 *    Formal Parameters
 *        physical_handle    (i)    -    PSTNController generated physical handle
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void TransportController::RemoveLogicalConnections
(
    PhysicalHandle          physical_handle
)
{
    TRACE_OUT(("TransportController::RemoveLogicalConnections"));

    LogicalHandle               logical_handle;
    PLogicalConnectionStruct    pConn;
    LegacyTransportID           transport_identifier;

     /*
     **    Go thru each logical connection to see if it is associated with the
     **    specified physical handle.
     */
    Logical_Connection_List.reset();
    while (Logical_Connection_List.iterate((PDWORD_PTR) &pConn, (PDWORD_PTR) &logical_handle))
    {
         /*
         **    If the physical handle is used by the logical connection,
         **    delete the structure and remove it from the Logical_Connection_List
         */
        if (physical_handle == pConn->hCommLink)
        {
            Logical_Connection_List.remove(logical_handle);

             /*
             **    Notify the user that the logical connection is no longer valid
             **    If the user had previously issued a DisconnectRequest(), don't
             **    issue the TRANSPORT_DISCONNECT_INDICATION callback.  The user
             **    isn't expecting a callback.
             */
            if (! pConn->t123_disconnect_requested)
            {
                transport_identifier.logical_handle = logical_handle;
                transport_identifier.hCommLink = physical_handle;

                ::NotifyT120(TRANSPORT_DISCONNECT_INDICATION, &transport_identifier);
            }
            delete pConn;

             /*
             **    Since we removed an entry from the Logical_Connection_List,
             **    reset the iterator.
             */
            Logical_Connection_List.reset ();
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tmemory.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    TMemory.cpp
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the implementation of the TMemory class.
 *
 *    Private Instance Variables:
 *        Default_Buffer_Size            -    Static buffer size
 *        Base_Buffer                    -    Address of static buffer
 *        Auxiliary_Buffer            -    Address of auxiliary buffer, if needed
 *        Length                        -    Current number of bytes in buffer
 *        Auxiliary_Buffer_In_Use        -    TRUE if we are using the aux. buffer
 *        Prepend_Space                -    Amount of space to leave open at 
 *                                        beginning of buffer
 *        Fatal_Error_Count            -    Number of times we have attempted to 
 *                                        allocate a buffer and failed
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#include "tmemory2.h"



/*
 *    TMemory::TMemory (
 *                ULONG            total_size,
 *                USHORT            prepend_space,
 *                PTMemoryError    error)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TMemory constructor.
 */
TMemory::TMemory (
            ULONG            total_size,
            USHORT            prepend_space,
            PTMemoryError    error)
{
    *error = TMEMORY_NO_ERROR;

    Fatal_Error_Count = 0;
    Prepend_Space = prepend_space;
    Default_Buffer_Size = total_size;
    Base_Buffer = NULL;
    Length = Prepend_Space;
    Auxiliary_Buffer = NULL;
    Auxiliary_Buffer_In_Use = FALSE;

     /*
     **    Attempt to allocate our internal buffer
     */
    Base_Buffer = (FPUChar) LocalAlloc (LMEM_FIXED, total_size);
    if (Base_Buffer == NULL)
    {
        ERROR_OUT(("TMemory: Constructor: Error allocating memory"));
        *error = TMEMORY_FATAL_ERROR;
    }
}


/*
 *    TMemory::~TMemory (
 *                void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the TMemory class destructor
 */
TMemory::~TMemory (
            void)
{
    if (Base_Buffer != NULL)
        LocalFree ((HLOCAL) Base_Buffer);

    if (Auxiliary_Buffer != NULL)
        LocalFree ((HLOCAL) Auxiliary_Buffer);
}


/*
 *    void    TMemory::Reset (
 *                        void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function resets the current buffer pointers and frees the
 *        Auxiliary buffer (if used)
 */
void    TMemory::Reset (
                    void)
{
    if (Auxiliary_Buffer_In_Use)
    {
        Auxiliary_Buffer_In_Use = FALSE;
        LocalFree ((HLOCAL) Auxiliary_Buffer);
        Auxiliary_Buffer = NULL;
    }
    Length = Prepend_Space;
}


/*
 *    TMemoryError    TMemory::Append (
 *                                HPUChar        address,
 *                                ULONG        length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function appends the buffer passed in, to our internal buffer
 */
TMemoryError    TMemory::Append (
                            HPUChar        address,
                            ULONG        length)
{
    TMemoryError    error = TMEMORY_NO_ERROR;
    FPUChar            new_address;

    if (Auxiliary_Buffer_In_Use == FALSE)
    {
         /*
         **    If the proposed buffer length is > our default buffer size,
         **    allocate an auxiliary buffer
         */
        if ((Length + length) > Default_Buffer_Size)
        {
            Auxiliary_Buffer = (HPUChar) LocalAlloc (LMEM_FIXED, Length + length);
            if (Auxiliary_Buffer == NULL)
            {
                if (Fatal_Error_Count++ >= MAXIMUM_NUMBER_REALLOC_FAILURES)
                    error = TMEMORY_FATAL_ERROR;
                else
                    error = TMEMORY_NONFATAL_ERROR;
            }
            else
            {
                Fatal_Error_Count = 0;

                 /*
                 **    Copy our current data into the auxiliary buffer
                 */
                memcpy (Auxiliary_Buffer, Base_Buffer, Length);
                memcpy (Auxiliary_Buffer + Length, address, length);
                Length += length;
                Auxiliary_Buffer_In_Use = TRUE;
            }
        }
        else
        {
            memcpy (Base_Buffer + Length, address, length);
            Length += length;
        }
    }
    else
    {
        new_address = (FPUChar) LocalReAlloc ((HLOCAL) Auxiliary_Buffer, 
                                        Length + length, LMEM_MOVEABLE);
        if (new_address == NULL)
        {
             /*
             **    If we have attempted to allocate a buffer before and failed
             **    we will eventually return a FATAL ERROR
             */
            if (Fatal_Error_Count++ >= MAXIMUM_NUMBER_REALLOC_FAILURES)
                error = TMEMORY_FATAL_ERROR;
            else
                error = TMEMORY_NONFATAL_ERROR;
        }
        else
        {
            Fatal_Error_Count = 0;

            Auxiliary_Buffer = new_address;
            memcpy (Auxiliary_Buffer + Length, address, length);
            Length += length;
        }
    }

    return (error);
}


/*
 *    TMemoryError    TMemory::GetMemory (
 *                            HPUChar    *    address,
 *                            FPULong        length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the address and used length of our internal buffer
 */
TMemoryError    TMemory::GetMemory (
                            HPUChar    *    address,
                            FPULong        length)
{

    if (Auxiliary_Buffer_In_Use)
        *address = (FPUChar) Auxiliary_Buffer;
    else
        *address = (FPUChar) Base_Buffer;
    *length = Length;

    return (TMEMORY_NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tmemory2.h ===
/*    TMemory2.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is a memory class used  to manage a memory buffer.  During 
 *        instantiation, a buffer is allocated and a prepend value is passed in.
 *        The prepend value is used during the Append() call.  All Append() calls
 *        are appended after the prepend value.  A running length is also 
 *        maintained.  This class is good to use if you are going to build up a 
 *        packet over time.
 *
 *        If a packet overruns the max. buffer size, a new buffer is allocated and
 *        used.
 *    
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _TMEMORY2_
#define _TMEMORY2_

#define    MAXIMUM_NUMBER_REALLOC_FAILURES    10

typedef    enum
{
    TMEMORY_NO_ERROR,
    TMEMORY_NONFATAL_ERROR,
    TMEMORY_FATAL_ERROR,
    TMEMORY_NO_DATA
}
    TMemoryError, * PTMemoryError;

class TMemory
{
public:
                        TMemory (
                            ULong            total_length,
                            UShort            prepend_space,
                            PTMemoryError    error);
                        ~TMemory (
                            Void);

        TMemoryError    Append (
                            HPUChar    address,
                            ULong    length);
        TMemoryError    GetMemory (
                            HPUChar    *     address,
                            FPULong        length);
        Void            Reset (
                            Void);

    private:
        ULong        Default_Buffer_Size;
        HPUChar        Base_Buffer;
        HPUChar        Auxiliary_Buffer;
        ULong        Length;
        DBBoolean    Auxiliary_Buffer_In_Use;
        UShort        Prepend_Space;
        UShort        Fatal_Error_Count;
};
typedef    TMemory *        PTMemory;

#endif

/*
 *    Documentation for Public class members
 */

/*
 *    TMemory::TMemory (
 *                ULong            total_length,
 *                UShort            prepend_space,
 *                PTMemoryError    error);
 *
 *    Functional Description:
 *        This is the constructor for the TMemory class.
 *
 *    Formal Parameters:
 *        total_length    (i)    -    Length of the default buffer
 *        prepend_space    (i)    -    Space to leave blank in the buffer
 *        error            (o)    -    Returns an error value
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemory::TMemory (
 *                Void)
 *
 *    Functional Description:
 *        This is the destructor for the object.
 *
 *    Formal Parameters:
 *        None.
 *
 *    Return Value:
 *        None.
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemoryError    TMemory::Append (
 *                                HPUChar    address,
 *                                ULong    length);
 *
 *    Functional Description:
 *        This function appends the buffer passed in to the internal buffer.
 *
 *    Formal Parameters:
 *        address            (i)    -    Address of buffer
 *        length            (i)    -    Length of buffer
 *
 *    Return Value:
 *        TMEMORY_NO_ERROR        -    No error
 *        TMEMORY_FATAL_ERROR        -    Fatal error occured, can't alloc a buffer
 *        TMEMORY_NONFATAL_ERROR    -    Buffer was not copied but it was not a 
 *                                    fatal error
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    TMemoryError    TMemory::GetMemory (
 *                                HPUChar    *     address,
 *                                FPULong        length);
 *
 *    Functional Description:
 *        This function returns the address and used length of our internal buffer
 *
 *    Formal Parameters:
 *        address            (o)    -    Address of our internal buffer
 *        length            (i)    -    Length of buffer
 *
 *    Return Value:
 *        TMEMORY_NO_ERROR        -    No error
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */

/*
 *    Void    TMemory::Reset (
 *                        Void)
 *
 *    Functional Description:
 *        This function resets the memory object.  All data in the object is lost
 *
 *    Formal Parameters:
 *        None
 *
 *    Return Value:
 *        None
 *
 *    Side Effects:
 *        None.
 *
 *    Caveats:
 *        None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tprtcore.h ===
/*    TransportController.h
 *
 *    Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This is the Transport Controller file for the MCATPSTN DLL.
 *
 *        This DLL instantiates a PSTNController which controls the
 *        making and breaking of connections.  This routine also constructs and
 *        destructs T123 stacks.  When the physical layer creates or detects a
 *        connection this class is notified.  It then instantiates a T123 object
 *        which sets up a T123 stack to control this physical connection.  The
 *        T123 stace notifies this controller when a connection is up and running.
 *        It also notifies this controller if the link is broken for some reason.
 *        As a result, this controller notifies the user of the new or broken
 *        connection.
 *
 *        When the user wants to make a data request of a specific transport
 *        connection, this controller maps the connection id to a T123 stack.  The
 *        data request is passed on to that stack.  Data Indications are passed
 *        to the user by the T123 stack.  The controller does not need to know
 *        about these and lets the T123 stack handle them.
 *
 *    POLLING THE DLL:
 *        This stack is maintained by the Poll calls (PollTransmitter() and
 *        PollReceiver()).  During these calls we transmit and receive
 *        packets with the remote sites.  It is extremely important that
 *        this DLL receive a time slice from the CPU on a regular and
 *        frequent basis.  This will give us the time we need to properly
 *        maintain the link.  If these calls are not used in a frequent and
 *        regular basis, the communications link will be unproductive and
 *        could eventually be lost.
 *
 *    USER CALLBACKS:
 *        The user communicates with this DLL by making calls directly to the
 *        DLL.  The DLL communicates with the user by issuing callbacks.
 *        The TInitialize() call accepts as a parameter, a callback address and
 *        a user defined variable.  When a significant event occurs in the DLL,
 *        the DLL will jump to the callback address.  The first parameter of
 *        the callback is the message.  This could be a
 *        TRANSPORT_CONNECT_INDICATION, TRANSPORT_DISCONNECT_INDICATION, or any
 *        number of significant events.  The second parameter is a message
 *        specific parameter.  The third parameter is the user defined variable
 *        that was passed in during the TInitialize() function.  See the
 *        mcattprt.h interface file for a complete description of the callback
 *        messages.
 *
 *    MAKING A CALL:
 *        After the initialization has been done, the user will eventually,
 *        want to attempt a connection.  The user issues a TConnectRequest() call
 *        with the PSTN address of the remote location.   The connection request
 *        is passed on to the PSTNcontroller.  It eventually issues a callback to
 *        the this controller to say that the connection was successful and passes
 *        up the address of the physical layer.  If the physical handle passed up
 *        by the PSTNController is a new handle, we create a T123 object, and
 *        issue a ConnectRequest() to it.  The T123 object creates a T.123
 *        compliant stack and notifies the Controller when it is up and running.
 *        If the handle passed up from the PSTNController is currently associated
 *        with an already active T123 object, we simply make a ConnectRequest()
 *        call to the T123 object so that it will create another logical
 *        connection over    the same physical connection.
 *
 *    RECEIVING A CALL:
 *        If we receive a call from a remote location, the PSTNController notifies
 *        us that a new connection is being attempted.  We then create a new
 *        T123 stack associated with the physical connection.  The T123 stack
 *        will notify us if new a Transport Connection id need to be generated.
 *        It will also notify us when the Transport Connection is up and running.
 *
 *    SENDING PACKETS:
 *        To send data to the remote location, use the DataRequest() function
 *        call.  This controller will pass the packet to the T123 stack that it is
 *        associated with.  The send may actually occur after the call has
 *        returned to the user.
 *
 *    RECEIVING PACKETS:
 *        The user receives packets by DATA_INDICATION callbacks.  When the
 *        user makes PollReceiver() calls, the Transport Layer checks its input
 *        buffers for packets.  If a packet is found, we issue a DATA_INDICATION
 *        callback to the user with the Transport Connection handle, the address
 *        of the packet, and the packet length.
 *
 *    DISCONNECTING A TRANSPORT:
 *        To disconnect a transport connection, use the DisconnectRequest()
 *        function.  After the link has been brought down, we perform a
 *        callback to the user to verify the disconnect.
 *
 *    Caveats:
 *        None.
 *
 *    Author:
 *        James W. Lawwill
 *
 */
#ifndef    _TRANSPORT_CONTROLLER_
#define    _TRANSPORT_CONTROLLER_

#include "t123.h"

#define TRANSPORT_CONTROLLER_MESSAGE_BASE    0



 /*
 **    Each Logical Connection has a LogicalConnectionStruct associated
 **    with it.
 **
 **    physical_layer                -    Pointer to physical layer associated with
 **                                    this logical connection.
 **    physical_handle                -    Each physical connection has a
 **                                    physical_handle associated with it.
 **    protocol_stack                -    The T123 object associated with it.
 **    priority                    -    Priority of the logical connection
 **    t123_connection_requested    -    TRUE if this logical connection has issued
 **                                    a ConnectRequest() to the t123 object.
 **    t123_disconnect_requested    -    TRUE if this logical connection has issued
 **                                    a DiconnectRequest() to the t123 object.
 */
typedef struct
{
    BOOL                fCaller;
    ComPort            *comport;    // physical layer
    PhysicalHandle      hCommLink;  // physical handle
    T123               *t123;       // protocal stack
    TransportPriority   priority;
    BOOL                t123_connection_requested;
    BOOL                t123_disconnect_requested;
}
    LogicalConnectionStruct, * PLogicalConnectionStruct;


class TransportController
{
public:

    TransportController(void);
    ~TransportController (void);

         /*
         **    Functions related making and breaking a link
         */
        TransportError CreateTransportStack(
                            BOOL            fCaller,
                            HANDLE          hCommLink,
                            HANDLE          hevtClose,
                            PLUGXPRT_PARAMETERS *);
        TransportError CloseTransportStack(
                            HANDLE          hCommLink);
        TransportError ConnectRequest (
                            LogicalHandle      *logical_handle,
                            HANDLE              hCommLink,
                            TransportPriority   transport_priority = DEFAULT_PRIORITY);
        TransportError ConnectResponse (
                            LogicalHandle    logical_handle);
        TransportError DisconnectRequest (
                            LogicalHandle    logical_handle,
                            UINT_PTR            trash_packet);

         /*
         **    This function is used to send a data packet
         */
        TransportError DataRequest (
                            LogicalHandle    logical_handle,
                            LPBYTE            user_data,
                            ULONG            user_data_length);
        TransportError PurgeRequest (
                            LogicalHandle    logical_handle);
        void           EnableReceiver (void);

         /*
         **    These four functions are the heartbeat of the DLL.  Transmission
         **    and reception of data occur during these calls.
         */
        void           PollReceiver(void);
        void           PollReceiver(PhysicalHandle);
        void           PollTransmitter(void);
        void           PollTransmitter(PhysicalHandle);

         /*
         **    Miscellaneous utilities
         */
        TransportError ProcessCommand (
                            USHORT    message,
                            PVoid    input_structure,
                            PVoid    output_structure);

         /*
         **    Callback used by the PSTNController and the T123 objects
         */
        ULONG_PTR OwnerCallback(ULONG, void *p1 = NULL, void *p2 = NULL, void *p3 = NULL);

        PhysicalHandle GetPhysicalHandle (
                            LogicalHandle    logical_handle);

private:

        LogicalHandle  GetNextLogicalHandle (void);
        void           ProcessMessages (void);
        void           RemoveLogicalConnections (
                                PhysicalHandle    physical_handle);
        void           Reset (
                                BOOL        notify_user);
        TransportError NewConnection (
                                PhysicalHandle   physical_handle,
                                BOOL             link_originator,
                                ComPort         *physical_layer);
        TransportError CreateT123Stack(
                                PhysicalHandle      hCommLink,
                                BOOL                link_originator, // fCaller
                                ComPort            *comport,
                                PLUGXPRT_PARAMETERS *pParams);

private:

         /*
         **    This is a list of the physical connections we currently have.
         **    It is associated with a structure that holds each layer in
         **    the stack(s).
         */
    DictionaryClass         Protocol_Stacks; // list of T123 objects
    DictionaryClass         Logical_Connection_List;
    SListClass              Transmitter_List;
    SListClass              Message_List;

    BOOL                    Emergency_Shutdown;
    BOOL                    Poll_Active;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    TransportController::TransportController (
 *                            PTransportResources    transport_resources);
 *
 *    Functional Description
 *        This is the Transport Controller constructor.  This routine instantiates
 *        a PSTNController() and routes calls to the proper location.
 *
 *    Formal Parameters
 *        transport_resources        - (i)    This is the address TransportResources
 *                                        structure.
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportController::~TransportController (void)
 *
 *    Functional Description
 *        This is the TransportController destructor.  It deletes the
 *        PSTNController and any T123 objects that are alive.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ConnectRequest (
 *                                        TransportAddress    transport_address,
 *                                        TransportPriority    transport_priority,
 *                                        LogicalHandle        *logical_handle);
 *
 *    Functional Description
 *        This function initiates a connection.  It calls the PSTNController with
 *        the transport_address so that it can start the connection procedure.
 *        When this routine returns, it does NOT mean that a connection exists.
 *        It means that a connection is in progress and will eventually be
 *        completed when the user receives a TRANSPORT_CONNECT_CONFIRM or
 *        TRANSPORT_DISCONNECT_INDICATION.
 *
 *    Formal Parameters
 *        transport_address    - (i)    Address of ascii string containing the
 *                                    telephone number or physical handle.
 *        transport_priority    - (i)    Requested priority of the connection.
 *                                    This value can be 0-14 inclusive.
 *        logical_handle        - (o)    Address of transport connection.  We return
 *                                    a unique transport connection number as the
 *                                    result of a successful dial operation.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                    -    No Error
 *        TRANSPORT_NO_CONNECTION_AVAILABLE    -    No resources for the connection
 *        TRANSPORT_CONNECT_REQUEST_FAILED    -    Unable to reach the address
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ConnectResponse (
 *                                            LogicalHandle    logical_handle);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        callback.  The user should call this function or the
 *        DisconnectRequest() function if that don't want the logical connection.
 *
 *    Formal Parameters
 *        logical_handle        - (i)    Logical handle that we are responding to.
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::DisconnectRequest (
 *                                            LogicalHandle    logical_handle);
 *
 *    Functional Description
 *        This function terminates the user's transport connection.  The user
 *        will receive a DISCONNECT_INDICATION when the connection is broken.
 *        If we are multiplexing multiple connections over the same physical
 *        connection, we will not break the physical comm. link until the last
 *        connection is broken.
 *
 *    Formal Parameters
 *        logical_handle         - (i)  Transport connection number to terminate
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::DataRequest (
 *                                            LogicalHandle    logical_handle,
 *                                            LPBYTE            user_data,
 *                                            ULONG            user_data_length);
 *
 *    Functional Description
 *        This function is used to send a data packet to the remote location.
 *
 *    Formal Parameters
 *        logical_handle          - (i)  Transport connection number
 *        user_data              - (i)  Address of data to send
 *        user_data_length      - (i)  Length of data to send
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *        TRANSPORT_PACKET_TOO_LARGE        -    Packet is bigger than acceptable
 *                                            size
 *        TRANSPORT_WRITE_QUEUE_FULL        -    Transport write queues are already
 *                                            full.
 *        TRANSPORT_NOT_READY_TO_TRANSMIT    -    The transport layer is in the
 *                                            process of building or breaking
 *                                            down the transport stack and is
 *                                            not ready for user data.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        The maximum size of a packet is 8192 bytes.
 */

/*
 *    void    TransportController::EnableReceiver (void);
 *
 *    Functional Description
 *        This function is called by the user application to notify us that
 *        it is ready for more data.  We only receive this call if we had
 *        previously attempted a TRANSPORT_DATA_INDICATION and it was rejected.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::PurgeRequest (
 *                                            LogicalHandle    logical_handle)
 *
 *    Functional Description
 *        This function is used purge outbound packets
 *
 *    Formal Parameters
 *        logical_handle - (i)  Transport connection number
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR                -    No Error
 *        TRANSPORT_NO_SUCH_CONNECTION    -    Transport connection does not exist
 *
 *    Side Effects
 *        None
 */

/*
 *    void    TransportController::PollReceiver (void);
 *
 *    Functional Description
 *        This function gives the DLL a chance to take the data received and
 *        pass it to the user.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollReceiver (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function calls the T123 stack associated with the physical
 *        handle.
 *
 *    Formal Parameters
 *        physical_handle    (i)        -    Handle of the T123 stack that we need
 *                                    to maintain.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollTransmitter (void);
 *
 *    Functional Description
 *        This function processes output data to remote locations.
 *
 *    Formal Parameters
 *        None.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    TransportController::PollTransmitter (
 *                                    PhysicalHandle    physical_handle)
 *
 *    Functional Description
 *        This function calls the T123 stack associated with the physical
 *        handle.
 *
 *    Formal Parameters
 *        physical_handle    (i)        -    Handle of the T123 stack that we need
 *                                    to maintain.
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TransportError    TransportController::ProcessCommand (
 *                                            USHORT    message,
 *                                            PVoid    input_structure,
 *                                            PVoid    output_structure)
 *
 *    Functional Description
 *        This function passes in a command and command-specific parameters.
 *
 *    Formal Parameters
 *        message          - (i)  Message to execute
 *        input_structure  - (i)  Pointer to data type related to message
 *        output_structure - (o)  Pointer to data type related to message
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalConnectRequest (
 *                                        ULONG            connect_type,
 *                                        PVoid            connect_parameter,
 *                                        PVoid            physical_configuration,
 *                                         PPhysicalHandle    physical_handle);
 *
 *    Functional Description
 *        This function initiates a physical connection.
 *
 *    Formal Parameters
 *        connect_type             -    (i)    Type of connection to make
 *        connect_parameter          -    (i) Pointer to parameter associated with
 *                                        connect_type.
 *        physical_configuration     -    (i) Pointer to configuration structure.
 *        physical_handle         -    (o) Pointer to PhysicalHandle.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalListen (
 *                                    ULONG                listen_type,
 *                                    PVoid                listen_parameter,
 *                                    PVoid                physical_configuration,
 *                                    PPhysicalHandle        physical_handle);
 *
 *    Functional Description
 *        This function initiates a physical connection listen.
 *
 *    Formal Parameters
 *        listen_type             -    (i)    Type of connection to make
 *        listen_parameter          -    (i) Pointer to parameter associated with
 *                                        listen_type.
 *        physical_configuration     -    (i) Pointer to configuration structure.
 *        physical_handle         -    (o) Pointer to PhysicalHandle.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalUnlisten (
 *                                            PhysicalHandle    physical_handle);
 *
 *    Functional Description
 *        This function takes a physical connection out of the listen mode.
 *
 *    Formal Parameters
 *        physical_handle -    (i) physical handle
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    TPhysicalError    TransportController::PhysicalDisconnectRequest (
 *                                    PhysicalHandle            physical_handle,
 *                                    PhysicalDisconnectMode    disconnect_mode);
 *
 *    Functional Description
 *        This function disconnects a physical connection.  Depending on the
 *        disconnect_mode, the port may be released to the user.  If the
 *        mode is TPHYSICAL_NOWAIT, the port is released when the function
 *        returns.  Otherwise, it is released when the
 *        TPHYSICAL_DISCONNECT_CONFIRM callback is issued.
 *
 *    Formal Parameters
 *        physical_handle -    (i) physical handle
 *        disconnect_mode -    (i) TPHYSICAL_WAIT, if you want to shutdown cleanly.
 *                                TPHYSICAL_NOWAIT, if you want to do a hard
 *                                shutdown of the physical connection.
 *
 *    Return Value
 *        TPHYSICAL_NO_ERROR        -    No error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ULONG    TransportController::OwnerCallback (
 *                                    USHORT    layer_message,
 *                                    ULONG    parameter1,
 *                                    ULONG    parameter2,
 *                                    PVoid    parameter3);
 *
 *    Functional Description
 *        This is the owner callback function.  This function is called by
 *        objects that are owned by the TransportController.  This is basically
 *        their way of communicating with the TransportController.  When the
 *        controller calls an object (i.e. PSTNController or a T123 object), it
 *        can call the owner back with message it wants processed.  This is a
 *        little tricky but it works well.
 *
 *    Formal Parameters
 *        command_string - (i)  String containing the operation to perform.  It
 *                              also contains any parameters that are necessary
 *                              for the function.
 *        parameter1         - (i)  Message specific parameter
 *        parameter2         - (i)  Message specific parameter
 *        parameter3         - (i)  Message specific parameter
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR        -    No Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tprtintf.h ===
#ifndef	_PSTN_TRANSPORT_INTERFACE_
#define	_PSTN_TRANSPORT_INTERFACE_

extern DictionaryClass    *g_pComPortList2;
extern SListClass         *g_pPSTNEventList;

// #include "wincfg.h"

typedef	enum
{
	READ_EVENT,
	WRITE_EVENT,
	CONTROL_EVENT
}
    WIN32Event;

typedef struct
{
	HANDLE			event;
	WIN32Event		event_type;
	BOOL            delete_event;
	PhysicalHandle	hCommLink; // physical handle
	ComPort        *comport;  // phsyical layer
}
    EventObject, * PEventObject;



class CTransportInterface : public ILegacyTransport
{
public:

    CTransportInterface(TransportError *);
    ~CTransportInterface(void);

    STDMETHODIMP_(void) ReleaseInterface(void);

    STDMETHODIMP_(TransportError) TInitialize(TransportCallback, void *user_defined);
    STDMETHODIMP_(TransportError) TCleanup(void);
    STDMETHODIMP_(TransportError) TCreateTransportStack(THIS_ BOOL fCaller, HANDLE hCommLink, HANDLE hevtClose, PLUGXPRT_PARAMETERS *pParams);
    STDMETHODIMP_(TransportError) TCloseTransportStack(THIS_ HANDLE hCommLink);
    STDMETHODIMP_(TransportError) TConnectRequest(LEGACY_HANDLE *, HANDLE hCommLink);
    STDMETHODIMP_(TransportError) TDisconnectRequest(LEGACY_HANDLE, BOOL trash_packets);
    STDMETHODIMP_(TransportError) TDataRequest(LEGACY_HANDLE, LPBYTE pbData, ULONG cbDataSize);
    STDMETHODIMP_(TransportError) TReceiveBufferAvailable(void);
    STDMETHODIMP_(TransportError) TPurgeRequest(LEGACY_HANDLE);
    STDMETHODIMP_(TransportError) TEnableReceiver(void);

private:

    LONG            m_cUsers;
};


extern ULONG NotifyT120(ULONG msg, void *lParam);


#endif	_PSTN_TRANSPORT_INTERFACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\tprtintf.cpp ===
#include "precomp.h"

/*    tprtintf.cpp
 *
 *  Copyright (c) 1996 by Microsoft Corporation
 *
 *    Abstract:
 *        This is the implementation file for the Win32 PSTN transport stack.
 *        This file contains all of the public functions needed to use
 *        the PSTN stack.  Transprt.cpp really performs three functions:
 *
 *            1.  Since this is a Win32 DLL, it provides a C to C++ conversion
 *                layer.  The functions called by the user are not processed
 *                in this file, they are passed on down to the C++ object that
 *                handles it (g_pController).  If we supplied a C++
 *                interface to the user, it would force the user to use C++ and
 *                it would force them to use a C++ compiler that used the same
 *                name-mangling algorithm as our compiler(s).
 *
 *            2.  It holds the code that acts as the administrator for the PSTN
 *                thread.  This is a fairly straightforward piece of code that
 *                is explained later in this comment block.
 *
 *            3.  This file provides thread synchronization to the underlying
 *                code by protecting it with a CRITICAL_SECTION.  This prevents
 *                multiple threads from executing the code at the same time.
 *
 *
 *
 *        CREATING A SECONDARY "PSTN" THREAD
 *
 *        Since this is a Win32 DLL, we create a seperate thread to maintain the
 *        PSTN DLL.  During initialization of the DLL, we create the secondary or
 *        PSTN thread which runs in response to timeouts and system events.  It
 *        uses the WaitForMultipleObjects() system call to wait for events that
 *        need to be processed.
 *
 *        This DLL is event driven.  When a new com port is opened and
 *        initialized, it uses Win32 event objects to signal significant events.
 *        Three events that can occur are read events, write events, and control
 *        events.  An example of a control event is a change in the carrier
 *        detect signal.
 *
 *        When the ComPort object initializes an event object, it registers the
 *        object with the PSTN thread, by placing it in the PSTN Event_List.  It
 *        not only registers the event, but also all of the data needed to
 *        identify the event.  The following structure must be filled out by the
 *        ComPort for each event that it registers.
 *            struct
 *            {
 *                HANDLE            event;                // event object
 *                WIN32Event        event_type;            // READ, WRITE, CONTROL
 *                BOOL              delete_event;        // FLAG, delete it?
 *                PhysicalHandle    physical_handle;    // Handle associated with
 *                                                    // ComPort
 *                IObject *            physical_layer;        // this pointer of comport
 *            } EventObject;
 *
 *        When an event occurs, the PSTN thread makes a call directly to the
 *        ComPort object to notify it.  If the event that occured was a WRITE
 *        event, we also issue a PollTransmitter() function call to the
 *        g_pController object so that it can transmit more data.
 *
 *        If a READ event occurs, we call the ComPort object directly to notify
 *        it that the event occurred.  We then issue a PollReceiver() function
 *        call to the g_pController object so that we can process the
 *        received data.  We then issue a PollTransmitter() to the
 *        g_pController object.  Logically, this doesn't make much sense,
 *        but if you study the Q922 code, you'll see that we sometimes don't
 *        transmit data until we receive notification that previously transmitted
 *        data was successfully transmitted.
 *
 *        If a CONTROL event occurs, we call the ComPort object directly to
 *        notify it that the event occurred.  We then issue a PollReceiver()
 *        function call to the g_pController object so that the CONTROL
 *        event will be processed.
 *
 *
 *
 *        X.214 INTERFACE
 *
 *        You will notice that many of the entry points to this DLL were taken
 *        from the X.214 service definition.  These entry points are consistent
 *        between all DataBeam Transport DLLs.  This gives the user application
 *        a consistent interface.
 *
 *
 *        PHYSICAL API
 *
 *        Some of the entry points to this DLL are specific to the creation
 *        and use of LOGICAL connections, and some of the entry points are
 *        specific to the creation and deletion of PHYSICAL connections.  The
 *        out-of-band physical API is new as of version 2.0 and provides the
 *        user with an optional way of making PHYSICAL connections.  In earlier
 *        versions of the Transport stacks, there was no Physical API and PHYSICAL
 *        connections were made in-band using the TConnectRequest() and
 *        TDisconnectRequest() calls.  This form of call control is still
 *        supported in this version.
 *
 *        Although the user can use out-of-band (PHYSICAL call control) and
 *        in-band call control, the DLL must be put in one mode or the other.
 *        The DLL can NOT function in both modes simultaneously.  The user
 *        determines the DLL's mode of operation by the calls it makes to it.
 *        If the user makes the TPhysicalInitialize() function call to the DLL
 *        before it issues the TInitialize() function call, the DLL is in the
 *        out-of-band call control mode.  If the user only makes the TInitialize()
 *        function call, by default the DLL will be in the in-band call control
 *        mode.
 *
 *        If MCS will be using this DLL, it makes the TInitialize() function call.
 *        Therefore, if the user wants to use the out-of-band call control mode,
 *        it should call TPhysicalInitialize() before it initializes MCS.
 *
 *
 *    Static Variables:
 *        Static_Instance_Handle       - Instance handle passed to the DLL when it
 *                                     is started.  The instance handle is used
 *                                     for Win32 system calls.
 *        g_pController               - This is a pointer to the controller that
 *                                     maintains the T123 stacks.
 *        m_cUsers                   - This is incremented each time someone
 *                                     calls the TInitialize function.  It is
 *                                     decremented each time someone calls the
 *                                      TCleanup function.  When this value
 *                                     reaches 0, we destroy the transport
 *                                     controller.
 *        g_hWorkerThread            - This global variable keeps the handle of
 *                                     the thread we spawn on initialization.
 *        g_dwWorkerThreadID           - Thread identifier
 *        g_hWorkerThreadEvent       - This is an event object that is used to
 *                                     synchronize actions between the 2 threads.
 *        g_hThreadTerminateEvent    - This event is used to signal the PSTN
 *                                     thread that it needs to terminate.
 *        ComPort_List                - This is a list of the ComPort objects
 *                                     serviced by this DLL.
 *                                     class.
 *        Number_Of_Diagnostic_Users - This variable keeps up with the number of
 *                                     people using who called T120DiagnosticCreate.
 *                                     We won't delete the Diagnostic class until
 *                                     an equal number of people call
 *                                     T120DiagnosticDestroy.
 *
 */

/*
**    External Interfaces
*/

#include "tprtintf.h"
#include "comport.h"

#define TPRTINTF_MAXIMUM_WAIT_OBJECTS    (1 + 16)

 /*
 **    Global variables used within the C to C++ converter.
 */
HINSTANCE                   g_hDllInst = NULL;
CTransportInterface        *g_pTransportInterface = NULL;
CRITICAL_SECTION            g_csPSTN;
Timer                      *g_pSystemTimer = NULL;
TransportController        *g_pController = NULL;
HANDLE                      g_hWorkerThread = NULL;
DWORD                       g_dwWorkerThreadID = 0;
HANDLE                      g_hWorkerThreadEvent= NULL;
HANDLE                      g_hThreadTerminateEvent = NULL;
DictionaryClass            *g_pComPortList2 = NULL;
SListClass                 *g_pPSTNEventList = NULL;
TransportCallback           g_pfnT120Notify = NULL;
void                       *g_pUserData = NULL;
BOOL                        g_fEventListChanged = FALSE;

 /*
 **    The following defines the MCATPSTN User window class name.
 **    This name must be unique, system wide.
 */

#define MCATPSTN_USER_WINDOW_CLASS_NAME    "NMPSTN USER Message Window"

 /*
 /*
 **    Timer duration.  We will poll the DLL every X milliseconds.  During
 **    this time, we can do any maintenance that is necessary
 */
#define    MCATPSTN_TIMER_DURATION        250

 /*
 **    These are prototypes
 */
DWORD T123_WorkerThreadProc(DWORD *);


/*
 *    BOOL    WINAPI    DllMain (
 *                        HINSTANCE    instance_handle,
 *                        DWORD        reason,
 *                        LPVOID)
 *
 *    Functional Description:
 *        This routine is the DLL startup routine.  It is analagous to the
 *        constructor of a class.  It is called by Windows when the DLL is
 *        loaded and when other significant events occur.
 */
#ifdef _DEBUG

#define INIT_DBG_ZONE_DATA
#include "fsdiag2.h"

#endif /* _DEBUG */


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD reason, LPVOID)
{
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllInst = hDllInst;
        ::DisableThreadLibraryCalls(hDllInst);
        #ifdef _DEBUG
    	MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
				(sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
        #endif
        DBG_INIT_MEMORY_TRACKING(hDllInst);
        ::InitializeCriticalSection(&g_csPSTN);
        break;

    case DLL_PROCESS_DETACH:
        ::DeleteCriticalSection(&g_csPSTN);
        DBG_CHECK_MEMORY_TRACKING(hDllInst);
        #ifdef _DEBUG
    	MLZ_DbgDeInit();
        #endif
        break;
    }

    return TRUE;
}


TransportError WINAPI T123_CreateTransportInterface(ILegacyTransport **pp)
{
    TransportError rc;

    if (NULL != pp)
    {
        *pp = NULL;

        if (NULL == g_pTransportInterface)
        {
            rc = TRANSPORT_MEMORY_FAILURE;

            DBG_SAVE_FILE_LINE
            g_pTransportInterface = new CTransportInterface(&rc);
            if (NULL != g_pTransportInterface && TRANSPORT_NO_ERROR == rc)
            {
                *pp = (ILegacyTransport *) g_pTransportInterface;
                return TRANSPORT_NO_ERROR;
            }

            delete g_pTransportInterface;
            g_pTransportInterface = NULL;
            return rc;
        }

        ASSERT(0);
        return TRANSPORT_ALREADY_INITIALIZED;
    }

    return TRANSPORT_INVALID_PARAMETER;
}


CTransportInterface::CTransportInterface(TransportError *rc)
:
    m_cUsers(0)
{
    g_hWorkerThread = NULL;
    g_dwWorkerThreadID = 0;

    g_pfnT120Notify = NULL;
    g_pUserData = NULL;

    g_fEventListChanged = FALSE;

    DBG_SAVE_FILE_LINE
    g_pSystemTimer = new Timer;
    ASSERT(NULL != g_pSystemTimer);

    DBG_SAVE_FILE_LINE
    g_hWorkerThreadEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != g_hWorkerThreadEvent);

    DBG_SAVE_FILE_LINE
    g_hThreadTerminateEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
    ASSERT(NULL != g_hThreadTerminateEvent);

    DBG_SAVE_FILE_LINE
    g_pComPortList2 = new DictionaryClass(TRANSPORT_HASHING_BUCKETS);
    ASSERT(NULL != g_pComPortList2);

    DBG_SAVE_FILE_LINE
    g_pPSTNEventList = new SListClass;
    ASSERT(NULL != g_pPSTNEventList);

    *rc = (g_pSystemTimer &&
           g_hWorkerThreadEvent &&
           g_hThreadTerminateEvent &&
           g_pComPortList2 &&
           g_pPSTNEventList)
          ?
           TRANSPORT_NO_ERROR :
           TRANSPORT_INITIALIZATION_FAILED;
    ASSERT(TRANSPORT_NO_ERROR == *rc);
}


CTransportInterface::~CTransportInterface(void)
{
    if (m_cUsers > 0)
    {
        // TCleanup() was not properly called enough times in the process.
        // Force final cleanup.
        m_cUsers = 1;
        TCleanup();
    }

    delete g_pSystemTimer;
    g_pSystemTimer = NULL;

    delete g_pComPortList2;
    g_pComPortList2 = NULL;

    delete g_pPSTNEventList;
    g_pPSTNEventList = NULL;

    g_pfnT120Notify = NULL;
    g_pUserData = NULL;

    if (NULL != g_hWorkerThreadEvent)
    {
        ::CloseHandle(g_hWorkerThreadEvent);
        g_hWorkerThreadEvent = NULL;
    }

    if (NULL != g_hThreadTerminateEvent)
    {
        ::CloseHandle(g_hThreadTerminateEvent);
        g_hThreadTerminateEvent = NULL;
    }

    if (NULL != g_hWorkerThread)
    {
        ::CloseHandle(g_hWorkerThread);
        g_hWorkerThread = NULL;
    }
}


void CTransportInterface::ReleaseInterface(void)
{
    delete this;
}



/*
 *    TransportError APIENTRY    TInitialize (
 *                                TransportCallback    transport_callback,
 *                                PVoid                user_defined)
 *
 *    Functional Description:
 *        This function must be called by the user of the Transport
 *        stack.  The PSTN thread is started.
 *
 *    Caveats:
 *        If this function is successful, the user must also call the
 *        TCleanup() function when he is finished with the DLL.
 */
TransportError CTransportInterface::TInitialize
(
    TransportCallback    transport_callback,
    void                *user_defined
)
{
    TransportError rc = TRANSPORT_NO_ERROR;

    if (! m_cUsers)
    {
        g_pfnT120Notify = transport_callback;
        g_pUserData = user_defined;

         /*
         **    At this point, we need to create another thread that will
         **    maintain this DLL.
         */
        g_hWorkerThread = ::CreateThread(
                            NULL, 0, (LPTHREAD_START_ROUTINE) T123_WorkerThreadProc,
                            NULL, 0, &g_dwWorkerThreadID);
        if (NULL != g_hWorkerThread)
        {
            if (::SetThreadPriority(g_hWorkerThread, THREAD_PRIORITY_ABOVE_NORMAL) == FALSE)
            {
                WARNING_OUT(("SetThreadPriority ERROR: = %d", ::GetLastError()));
            }

             /*
             **    Wait for the secondary thread to notify us that initialization is
             **    complete
             */
            ::WaitForSingleObject(g_hWorkerThreadEvent, 30000); // 30 seconds

             /*
             **    If g_pController == NULL, initialization FAILED.  We use
             **    this variable to signal us regarding the status of the secondary
             **    thread.
             */
            if (NULL == g_pController)
            {
                ERROR_OUT(("TInitialize: Unable to initialize transport"));
                rc = TRANSPORT_INITIALIZATION_FAILED;
            }
        }
        else
        {
            rc = TRANSPORT_INITIALIZATION_FAILED;
        }
    }

    if (TRANSPORT_NO_ERROR == rc)
    {
        m_cUsers++;
    }

    return rc;
}


/*
 *    TransportError TCleanup (void)
 *
 *    Functional Description:
 *        This function is called to release all system resources that
 *        were used during the life of the DLL.
 *
 *    Caveats:
 *        This function should only be called if the user had previously
 *        called the TInitialize() function.
 */
TransportError CTransportInterface::TCleanup(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        if (--m_cUsers == 0)
        {
             /*
             **    Set the g_hThreadTerminateEvent to notify the PSTN thread
             **    that it should terminate operations.
             */
            ::SetEvent(g_hThreadTerminateEvent);

             /*
             **    Wait for the PSTN thread to notify us that cleanup is
             **    complete
             */
            if (g_hWorkerThreadEvent != NULL)
            {
                // WaitForSingleObject (g_hWorkerThreadEvent, INFINITE);
                ::WaitForSingleObject(g_hWorkerThreadEvent, 30000); // 30 seconds
                g_hWorkerThreadEvent = NULL;

                //
                //  Relinquish the remainder of our time slice, to allow trasnsport thread to exit.
                //
                Sleep(0);
            }
        }

        rc = TRANSPORT_NO_ERROR;
    }

    return rc;
}


TransportError CTransportInterface::TCreateTransportStack
(
    BOOL                fCaller,
    HANDLE              hCommLink,
    HANDLE              hevtClose,
    PLUGXPRT_PARAMETERS *pParams
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->CreateTransportStack(fCaller, hCommLink, hevtClose, pParams);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


TransportError CTransportInterface::TCloseTransportStack
(
    HANDLE          hCommLink
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->CloseTransportStack(hCommLink);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY        TConnectRequest (
 *                                    TransportAddress    transport_address,
 *                                    TransportPriority    transport_priority,
 *                                    LogicalHandle        *logical_handle)
 *
 *    Functional Description:
 *        This function starts the process of building a transport connection.
 *        It uses the transport_address and attempts to make a connection to it.
 *
 *        If the DLL is set up for in-band call control, the DLL will choose a
 *        modem and attempt a connection.  After the physical connection is up,
 *        it will create a logical connection that the user application can use.
 *
 *        If the DLL is set up for out-of-band call control, the transport address
 *        is actually an ascii string that represents a DLL generated
 *        physicalhandle.  This call can only be made in response to a successful
 *        TPhysicalConnectRequest() function.  The TPhysicalConnectRequest() call
 *        returns a PhysicalHandle that the user must convert to ascii and pass
 *        back to the DLL via this call.  Although this is very ugly, we did this
 *        for a reason.  We added the out-of-band call control API to the
 *        transports but we did not want to change GCC or MCS to do it.  GCC and
 *        MCS already expected an ascii string as the transport address.  In the
 *        future, look for this to change in MCS and GCC.
 */
TransportError CTransportInterface::TConnectRequest
(
    LEGACY_HANDLE          *logical_handle,
    HANDLE                  hCommLink
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->ConnectRequest(logical_handle, hCommLink);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TDisconnectRequest (
 *                                LogicalHandle    logical_handle,
 *                                BOOL             trash_packets)
 *
 *    Functional Description:
 *        This function breaks a logical connection.  This is also an X.214
 *        primitive.  Since the DLL may have packets queued up for transmission
 *        for this logical connection, the trash_packets parameter determines
 *        whether the DLL should trash those packets before disconnecting the
 *        logical connection.
 */
TransportError CTransportInterface::TDisconnectRequest
(
    LEGACY_HANDLE       logical_handle,
    BOOL                trash_packets
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->DisconnectRequest(logical_handle, trash_packets);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TDataRequest (
 *                                LogicalHandle    logical_handle,
 *                                LPBYTE            user_data,
 *                                ULONG            user_data_length)
 *
 *    Functional Description:
 *        This function takes the data passed in and attempts to send it
 *        to the remote site.
 */
TransportError CTransportInterface::TDataRequest
(
    LEGACY_HANDLE    logical_handle,
    LPBYTE           user_data,
    ULONG            user_data_length
)
{
    TransportError    rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);

        if (NULL != g_pController)
        {
            rc = g_pController->DataRequest(logical_handle, user_data, user_data_length);
             /*
             **    If the packet was accepted, we need to issue a
             **    PollTransmitter() to flush the packet out.  Otherwise,
             **    we will have a latency problem.
             */
            if (TRANSPORT_NO_ERROR == rc)
            {
                ComPort *comport;
                PhysicalHandle physical_handle = g_pController->GetPhysicalHandle(logical_handle);
                if ( ( 0 != physical_handle ) &&
                    g_pComPortList2->find((DWORD_PTR) physical_handle, (PDWORD_PTR) &comport))
                {
                    if (! comport->IsWriteActive())
                    {
                        g_pController->PollTransmitter(physical_handle);
                    }
                }
            }
        }

        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TReceiveBufferAvailable (void)
 *
 *    Functional Description:
 *        This function informs the transport to enable packet transfer from the
 *        Transport to the user application.  This function makes a call to
 *        'Enable' the receiver and then it issues a PollReceiver() to actually
 *        allow any pending packets to be sent on up to the user.
 */
TransportError CTransportInterface::TReceiveBufferAvailable(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);

        if (NULL != g_pController)
        {
            g_pController->EnableReceiver();
            g_pController->PollReceiver();

             /*
             **    We are doing a PollTransmitter() here to allow
             **    the Q922 object to exit the 'receiver not ready' mode.
             **    If MCS had been rejecting packets, and now it is accepting
             **    packets, we need to let the remote site know that it
             **    can re-start its transmitter.
             */
            g_pController->PollTransmitter();
        }

        ::LeaveCriticalSection(&g_csPSTN);

        rc = TRANSPORT_NO_ERROR;
    }

    return rc;
}


/*
 *    TransportError APIENTRY    TPurgeRequest (
 *                                LogicalHandle    logical_handle)
 *
 *    Functional Description:
 *        This function purges all of the outbound packets for the given
 *        logical connection.
 */
TransportError CTransportInterface::TPurgeRequest
(
    LEGACY_HANDLE       logical_handle
)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            rc = g_pController->PurgeRequest(logical_handle);
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return rc;
}


TransportError CTransportInterface::TEnableReceiver(void)
{
    TransportError rc = TRANSPORT_NOT_INITIALIZED;

    if (m_cUsers > 0)
    {
        ::EnterCriticalSection(&g_csPSTN);
        if (NULL != g_pController)
        {
            g_pController->EnableReceiver();
        }
        ::LeaveCriticalSection(&g_csPSTN);
    }

    return TRANSPORT_NO_ERROR;
}


/*
 *    DWORD    T123_WorkerThreadProc (LPDWORD)
 *
 *    Functional Description:
 *        This function is the PSTN thread.  It maintains the DLL.
 */
DWORD T123_WorkerThreadProc(DWORD *)
{
    PEventObject        event_struct;
    BOOL                fContinue = TRUE;
    HANDLE              aEvents[TPRTINTF_MAXIMUM_WAIT_OBJECTS];
    ULONG               cEvents;
    ULONG               last_time_polled;
    ULONG               current_time;

    g_fEventListChanged = FALSE;

     /*
     **    Create the one and only instance of the Transport Controller
     **    to be in charge of this DLL.  Once it is created, all other
     **    primitives are routed to it.
     */
    DBG_SAVE_FILE_LINE
    g_pController = new TransportController();
    if (g_pController == NULL)
    {
        ERROR_OUT(("PSTN_WorkerThreadProc: cannot allocate TransportController"));
        ::SetEvent(g_hWorkerThreadEvent);
        return TRANSPORT_INITIALIZATION_FAILED;
    }

     /*
     **    The DLL needs to be polled every X milliseconds.  We do this
     **    by checking the system clock and if X milliseconds have elapsed
     **    since the last DLL poll, we do it again.  This line of code is
     **    actually initializing the timer.
     */
    last_time_polled = ::GetTickCount();

     /*
     **    Notify the primary thread that we are up
     */
    ::SetEvent(g_hWorkerThreadEvent);


// THREAD LOOP

     /*
     **    This while loop is the heart of the PSTN thread.  We use the
     **    WaitForMultipleObjects() function to wake up our thread when a
     **    significant event occurs OR when a timeout occurs.
     **
     **    There are four different types of event objects that can occur
     **    that will wake up the thread.
     **
     **        1.  The primary thread sets the g_hThreadTerminateEvent object.
     **        2.  Read event from the ComPort object.  If a read of a comm port
     **            completes or times out, the event object is set
     **        3.  Write event from the ComPort object.  If a write on a comm
     **            port completes or times out.
     **        4.  Control event from the ComPort object.  If the carrier detect
     **            signal changes.
     **
     ** Also, the thread will continue running if the MCATPSTN_TIMER_DURATION
     **    expires
     **
     **
     **    A ComPort object can add event objects to our PSTN Event_List at any
     **    time.  When they are added to the Event_List, we add them to the
     **    local aEvents and the WaitForMultipleObjects() function waits
     **    for them.
     **
     **    This approach works very well except that the WaitForMultipleObjects()
     **    function can only handle TPRTINTF_MAXIMUM_WAIT_OBJECTS at a time.  Currently,
     **    this #define is set to 64 by the Windows 95 operating system.  Since
     **    each ComPort uses 3 event objects, this limits us to a maximum of
     **    21 active ports.
     */
    aEvents[0] = g_hThreadTerminateEvent;
    cEvents = 1;

    while (fContinue)
    {
         /*
         **    Wait for an event to occur or for the timeout to expire
         */
         DWORD dwRet = ::WaitForMultipleObjects(cEvents, aEvents, FALSE, MCATPSTN_TIMER_DURATION);

         /*
         **    We MUST enter this critical section of code and lock out the
         **    primary thread from enterring it.  Both threads executing this
         **    code could be disasterous
         */
        ::EnterCriticalSection(&g_csPSTN);

        if (dwRet == WAIT_FAILED)
        {
            fContinue = FALSE;
            break;
        }
        else
        if (dwRet == WAIT_TIMEOUT)
        {
            if (cEvents > 1)
            {
                last_time_polled = ::GetTickCount();
                g_pController->PollReceiver();
                g_pController->PollTransmitter();
                g_pSystemTimer->ProcessTimerEvents();
            }
        }
        else
        {
             /*
             **    Determine which object has signalled us
             */
            ULONG dwIdx = dwRet - WAIT_OBJECT_0;
            if (dwIdx > cEvents)
            {
                ERROR_OUT(("ThreadFunc: Invalid object signalled = %d", dwIdx));
            }
            else
            {
                 /*
                 **    If the object that signalled us is index 0, it is the
                 **    terminate thread object.
                 */
                if (! dwIdx)
                {
                    TRACE_OUT(("ThreadFunc: Terminating thread"));
                    fContinue = FALSE;
                }
                else
                {
                    dwIdx--;
                    event_struct = (PEventObject) g_pPSTNEventList->read((USHORT) dwIdx);
                    if (NULL != event_struct)
                    {
                         /*
                         **    Check the delete_event, if it is set, we need to
                         **    terminate the event.
                         **
                         **    By design, other objects throughout the DLL create
                         **    the events, and this function deletes them.  If the
                         **    creating function deleted them, we could be waiting
                         **    on an event that gets deleted.  That has the potential
                         **    of being messy.
                         */
                        if (event_struct->delete_event)
                        {
                             /*
                             **    Remove the ComPort from our list
                             */
                            ComPort *comport = NULL;
                            if (g_pComPortList2->find((DWORD_PTR) event_struct->hCommLink, (PDWORD_PTR) &comport))
                            {
                                g_pComPortList2->remove((DWORD_PTR) event_struct->hCommLink);
                                comport->Release();
                            }

                             /*
                             **    Close the event
                             */
                            ::CloseHandle(event_struct->event);

                             /*
                             **    Remove the event from our list
                             */
                            g_pPSTNEventList->remove((DWORD_PTR) event_struct);
                            delete event_struct;

                            g_fEventListChanged = TRUE;
                        }
                        else
                        {
                            ComPort *comport = event_struct->comport;
                             /*
                             **    Switch on the event_type to determine the
                             **    operation that needs to take place
                             */
                            switch (event_struct->event_type)
                            {
                            case READ_EVENT:
                                comport->ProcessReadEvent();

                                 /*
                                 **    If a READ event occurred, we need to issue
                                 **    a PollReceiver() and then issue a
                                 **    PollTransmitter().  We issue the
                                 **    PollTransmitter() because the PollReceiver()
                                 **    may have freed up space for us to send out
                                 **    data.
                                 */
                                g_pController->PollReceiver(event_struct->hCommLink);
                                g_pController->PollTransmitter(event_struct->hCommLink);
                                break;

                            case WRITE_EVENT:
                                 /*
                                 **    If a WRITE_EVENT occurs, this means that
                                 **    space has become available to transmit more
                                 **    data.
                                 */
                                comport->ProcessWriteEvent();
                                g_pController->PollTransmitter(event_struct->hCommLink);
                                break;

                            case CONTROL_EVENT:
                                 /*
                                 ** The CONTROL events are particular to the
                                 **    ComPort object.  A change in the CD signal
                                 **    could be a CONTROL event.
                                 */
                                g_pController->PollReceiver(event_struct->hCommLink);
                                break;

                            default:
                                ERROR_OUT(("ThreadFunc:  Illegal event type = %d", event_struct->event_type));
                                break;
                            } // switch
                        }
                    } // if event_struct
                }
            }

             /*
             **    Check to see if enough time has elapsed since the last time we
             **    polled the DLL to do it again.
             */
            if (cEvents > 1)
            {
                current_time = ::GetTickCount();
                if ((current_time - last_time_polled) >= MCATPSTN_TIMER_DURATION)
                {
                    last_time_polled = current_time;

                    g_pController->PollReceiver();
                    g_pController->PollTransmitter();
                    g_pSystemTimer->ProcessTimerEvents();
                }
            }
        }


         /*
         **    This Event_List_Changed will only be set to TRUE if we need to
         **    update our event list
         */
        if (g_fEventListChanged)
        {
            aEvents[0] = g_hThreadTerminateEvent;
            cEvents = 1;

            if (g_pPSTNEventList->entries() > (TPRTINTF_MAXIMUM_WAIT_OBJECTS - 1))
            {
                ERROR_OUT(("ThreadFunc:  ERROR:  Number of event objects = %d",
                    g_pPSTNEventList->entries() + 1));
            }

             /*
             **    Go thru the Event_List and create a new aEvents.
             */
            g_pPSTNEventList->reset();
            while (g_pPSTNEventList->iterate((PDWORD_PTR) &event_struct))
            {
                aEvents[cEvents] = event_struct -> event;
                cEvents++;

                 /*
                 **    Add the physical_handle to the ComPort_List
                 */
                if (event_struct->event_type == WRITE_EVENT)
                {
                    if (! g_pComPortList2->find((DWORD_PTR) event_struct->hCommLink))
                    {
                        g_pComPortList2->insert((DWORD_PTR) event_struct->hCommLink,
                                                (DWORD_PTR) event_struct->comport);
                    }
                }
            }
            g_fEventListChanged = FALSE;
        }

        ::LeaveCriticalSection(&g_csPSTN);
    } // while


// CLEANUP THE THREAD RESOURCES
    delete g_pController;
    g_pController = NULL;

     /*
     **    Delete all of the event objects
     */
    g_pPSTNEventList->reset();
    while (g_pPSTNEventList->iterate((PDWORD_PTR) &event_struct))
    {
        ::CloseHandle(event_struct->event);
        delete event_struct;
    }

     /*
     **    Notify the primary thread that we are up
     */
    ::SetEvent(g_hWorkerThreadEvent);

    return (0);
}



ULONG NotifyT120(ULONG msg, void *param)
{
    if (NULL != g_pfnT120Notify)
    {
        return (*g_pfnT120Notify) (msg, param, g_pUserData);
    }
    return 0;
}


IObject::~IObject(void) { }


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\x224.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_T123PSTN);

/*    X224.cpp
 *
 *    Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *
 *    Private Instance Variables:
 *        Default_PDU_Size             -    Default PDU size, if no arb. is done
 *        Data_Request_Memory_Manager -    Memory manager
 *        Lower_Layer_Prepend            -    Number of bytes prepended to packet by
 *                                        lower layer
 *        Lower_Layer_Append            -    Number of bytes appended to packet byt
 *                                        lower layer
 *        Shutdown_Receiver            -    TRUE if we aren't to receive any more
 *                                        packets from the lower layer
 *        Shutdown_Transmitter        -    TRUE if we aren't to transmit any more
 *                                        packets
 *        Data_Request_Queue            -    Queue that keeps the pending user data
 *                                        requests
 *        Data_Indication_Queue        -    Queue that holds the pending user data
 *                                        indications
 *        Data_Indication_Memory_Pool    -    List that holds available data
 *                                        indication buffers.
 *
 *        Active_Data_Indication        -    Address of packet structure.  This
 *                                        packet holds the current data indication
 *                                        that we are reassembling
 *        m_pT123                -    Address of owner object.  Used for
 *                                        callbacks
 *        m_pQ922                    -    Address of lower layer.
 *        m_nMsgBase                -    Message base to be used for owner
 *                                        callbacks
 *        Maximum_PDU_Size            -    Max. PDU size
 *        Arbitrated_PDU_Size            -    Max. arbitrated packet size.
 *        Identifier                    -    Identifier passed to lower layer to
 *                                        register ourselves.
 *        Data_Indication_Queue_Size    -    Number of data indications we will
 *                                        buffer
 *        Data_Indication_Reassembly_Active    -    Flag set if we are in the middle
 *                                        of a packet reassembly.
 *        State                        -    Holds the current state of the object
 *        Packet_Pending                -    Tells which packet will be sent next.
 *        Reject_Cause                -    The reason why the error packet was sent
 *        Packet_Size_Respond            -    Set to TRUE if we are to send a TPDU
 *                                        size element in the CC packet
 *        Error_Buffer                -    Address of error buffer.
 *        Error_Buffer_Length            -    Length of error buffer.
 *
 *        m_nLocalLogicalHandle    -    Local transport connection id.
 *        m_nRemoteLogicalHandle    -    Remote transport connection id.
 *         User_Data_Pending            -    Set to the size of the last packet that
 *                                        the user attempted to pass to us, that
 *                                        we couldn't accept because we ran out
 *                                        of memory.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#include <windowsx.h>
#include "x224.h"



/*
 *    CLayerX224::CLayerX224 (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                logical_handle,
 *                USHORT                identifier,
 *                USHORT                data_indication_queue_size,
 *                USHORT                default_PDU_size,
 *                PMemoryManager        dr_memory_manager,
 *                BOOL *            initialization_success)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the Transport constructor.  This routine initializes all
 *        variables and allocates the buffers needed to operate.
 */
CLayerX224::CLayerX224
(
    T123               *owner_object,
    CLayerQ922         *pQ922, // lower layer
    USHORT              message_base,
    LogicalHandle       logical_handle,
    ULONG               identifier,
    USHORT              data_indication_queue_size,
    USHORT              default_PDU_size,
    PMemoryManager      dr_memory_manager,
    BOOL               *initialization_success
)
:
    m_pT123(owner_object),
    m_nMsgBase(message_base),
    m_pQ922(pQ922)
{
    TRACE_OUT(("CLayerX224::CLayerX224"));

    ProtocolLayerError    error;

    m_nLocalLogicalHandle = logical_handle;
    Identifier = identifier;
    Default_PDU_Size = default_PDU_size;
    Data_Request_Memory_Manager = dr_memory_manager;
    *initialization_success = TRUE;

    Shutdown_Receiver = FALSE;
    Shutdown_Transmitter = FALSE;
    Reject_Cause = 0;


     /*
     **    Find the maximum packet size
     */
    m_pQ922->GetParameters(
                    &Maximum_PDU_Size,
                    &Lower_Layer_Prepend,
                    &Lower_Layer_Append);

    Arbitrated_PDU_Size = Default_PDU_Size;

     /*
     **    Figure out what our largest PDU could be.  We will use this value to
     **    arbitrate the maximum PDU size.
     */
    Maximum_PDU_Size = (USHORT)GetMaxTPDUSize (Maximum_PDU_Size);

     /*
     **    Register with the lower layer, so we can send and receive packets.
     */
    error = m_pQ922->RegisterHigherLayer(
                            identifier,
                            Data_Request_Memory_Manager,
                            (IProtocolLayer *) this);

    if (error != PROTOCOL_LAYER_NO_ERROR)
    {
        ERROR_OUT(("X224: constructor:  Error registering with lower layer"));
        *initialization_success = FALSE;
    }

     /*
     **    Prepare for buffer allocation
     */
    Data_Indication_Queue_Size = data_indication_queue_size;
    Error_Buffer = NULL;

     /*
     **    Set member variables appropriately
     */
    Active_Data_Indication = NULL;
    Data_Indication_Reassembly_Active = FALSE;
    Packet_Pending = TRANSPORT_NO_PACKET;
    User_Data_Pending = 0;

    m_nRemoteLogicalHandle = 0;
    Packet_Size_Respond = FALSE;

    if (*initialization_success == FALSE)
        State = FAILED_TO_INITIALIZE;
    else
        State = NO_CONNECTION;
}


/*
 *    CLayerX224::~CLayerX224 (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This is the Transport destructor.  This routine cleans up everything.
 */
CLayerX224::~CLayerX224(void)
{
    TRACE_OUT(("CLayerX224::~CLayerX224"));

    PMemory     lpMemory;
    PTMemory    lptMem;
     /*
     **    Notify the lower layer that we are terminating
     */
    m_pQ922->RemoveHigherLayer(Identifier);

     /*
     **    Go thru the data request queue and delete the structures held in the
     **    queue.
     */
    Data_Request_Queue.reset();
    while (Data_Request_Queue.iterate ((PDWORD_PTR) &lpMemory))
    {
        Data_Request_Memory_Manager-> FreeMemory (lpMemory);
    }

     /*
     **    Go thru the data indication queue and delete the structures held in the
     **    queue.
     */
    Data_Indication_Queue.reset();
    while (Data_Indication_Queue.iterate ((PDWORD_PTR) &lptMem))
        delete lptMem;

     /*
     **    Go thru the data request free structure pool and delete the structures
     **    held in the    pool.
     */
    Data_Indication_Memory_Pool.reset();
    while (Data_Indication_Memory_Pool.iterate ((PDWORD_PTR) &lptMem))
        delete lptMem;

     /*
     **    If there is a data indication active, delete that structure.
     */
    delete Active_Data_Indication;

     /*
     **    If the error buffer holds a packet, delete it
     */
    delete [] Error_Buffer;

    return;
}


/*
 *    TransportError    CLayerX224::ConnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connect request.
 */
TransportError    CLayerX224::ConnectRequest (void)
{
    TRACE_OUT(("CLayerX224::ConnectRequest"));

    if (State != NO_CONNECTION)
    {
        ERROR_OUT(("Transport: Illegal ConnectRequest packet"));
        return (TRANSPORT_CONNECT_REQUEST_FAILED);
    }

    Packet_Pending = CONNECTION_REQUEST_PACKET;
    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::ShutdownReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function stops us from receiving any more packets from the lower
 *        layer
 */
void    CLayerX224::ShutdownReceiver (void)
{
    TRACE_OUT(("CLayerX224::ShutdownReceiver"));

    Shutdown_Receiver = TRUE;
}


/*
 *    TransportError    CLayerX224::EnableReceiver (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function permits us to send packets to the user application.
 */
void    CLayerX224::EnableReceiver (void)
{
    TRACE_OUT(("CLayerX224::EnableReceiver"));

    Shutdown_Receiver = FALSE;
}


/*
 *    TransportError    CLayerX224::ShutdownTransmitter (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function keeps us from transmitting any more packets
 */
void    CLayerX224::ShutdownTransmitter (void)
{
    TRACE_OUT(("CLayerX224::ShutdownTransmitter"));

    Shutdown_Transmitter = TRUE;
}


/*
 *    TransportError    CLayerX224::PurgeRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function removes all packets from out output queue that aren't
 *        active
 */
void    CLayerX224::PurgeRequest (void)
{
    TRACE_OUT(("CLayerX224::PurgeRequest"));

    DWORD    entries;
    DWORD    keep_counter = 0;
    PMemory    memory;
    LPBYTE    packet_address;
    DWORD    i;

    if (Data_Request_Queue.isEmpty() == FALSE)
    {
        entries = Data_Request_Queue.entries ();

         /*
         **    Go thru packets looking for the last PDU in the SDU
         */
        Data_Request_Queue.reset();
        while (Data_Request_Queue.iterate ((PDWORD_PTR) &memory))
        {
            keep_counter++;
            packet_address = memory -> GetPointer ();
            if (*(packet_address + 2) == EOT_BIT)
                break;
        }

        TRACE_OUT(("PurgeRequest: Removing %d packets", entries-keep_counter));
        for (i=keep_counter; i<entries; i++)
        {
            Data_Request_Memory_Manager->FreeMemory ((PMemory) Data_Request_Queue.removeLast ());
        }
    }
    return;
}


/*
 *    TransportError    CLayerX224::ConnectResponse (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a connect response.
 */
TransportError    CLayerX224::ConnectResponse (void)
{
    TRACE_OUT(("CLayerX224::ConnectResponse"));

    if (State != RECEIVED_CONNECT_REQUEST_PACKET)
    {
        ERROR_OUT(("Transport: Illegal ConnectResponse packet"));
        return (TRANSPORT_CONNECT_RESPONSE_FAILED);
    }

    Packet_Pending = CONNECTION_CONFIRM_PACKET;
    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DisconnectRequest (void)
 *
 *    Public
 *
 *    Functional Description:
 *        This function initiates a disconnect request.
 */
TransportError    CLayerX224::DisconnectRequest (void)
{
    TRACE_OUT(("CLayerX224::DisconnectRequest"));

    if (State == SENT_CONNECT_REQUEST_PACKET)
    {
         /*
         **    The connection is being rejected, send out the DISCONNECT
         **    packet and wait for termination
         */
        Packet_Pending = DISCONNECT_REQUEST_PACKET;
    }
    else
    {
         /*
         **    Normal disconnects don't send any notification to the remote site.
         **    It depends on the Network layer to terminate the link.
         */
        m_pQ922->RemoveHigherLayer(Identifier);

        m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                               (void *) m_nLocalLogicalHandle);
    }

    return (TRANSPORT_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DataIndication (
 *                                LPBYTE        packet_address,
 *                                ULONG        buffer_size,
 *                                PULong        packet_length)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called by the lower layer when it has a packet for us.
 */
ProtocolLayerError    CLayerX224::DataIndication (
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerX224::DataIndication"));

    ULONG            remainder_length;
    USHORT            class_request;
    USHORT            packet_type;
    USHORT            length;
    USHORT            destination_reference;
    LegacyTransportData    transport_data;
    BOOL            packet_accepted;
    ULONG            user_accepted;
    UChar            eot;
    PTMemory        packet;
    TMemoryError    packet_error;
    LPBYTE            temp_address;
    BOOL            use_default_PDU_size;


    *bytes_accepted = 0;
    packet_accepted = FALSE;

     /*
     ** If the receiver is shutdown, don't accept any data
     */
    if (Shutdown_Receiver)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    The packet must be at least 2 bytes long
     */
    if (packet_length < 2)
    {
        ERROR_OUT(("X224: DataIndication:  Invalid packet received from lower layer: length = %d", packet_length));
        return (PROTOCOL_LAYER_NO_ERROR);
    }

    remainder_length = packet_length;
    temp_address = packet_address;
    packet_address++;
    packet_type = *(packet_address++) & TPDU_CODE_MASK;
    remainder_length -= 2;

    switch (packet_type)
    {
        case CONNECTION_REQUEST_PACKET:
            packet_accepted = TRUE;

             /*
             **    There should be at least 5 bytes remaining in this packet
             */
            if (remainder_length < 5)
            {
                ERROR_OUT(("X224: DataIndication: CR: Invalid packet received from lower layer: length = %d", packet_length));
                break;
            }

             /*
             **    Increment the packet address by 2 to get past the DST_REF
             */
            packet_address += 2;
            m_nRemoteLogicalHandle = *(packet_address++);
            m_nRemoteLogicalHandle <<= 8;
            m_nRemoteLogicalHandle |= *(packet_address++);
            remainder_length -= 4;

             /*
             **    Look at the class request to make sure it is 0
             */
            class_request = *(packet_address++) >> 4;
            remainder_length -= 1;
            if (class_request != 0)
            {
                ERROR_OUT(("X224: DataIndication: CR packet: Illegal class request"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }
            use_default_PDU_size = TRUE;

            while (remainder_length != 0)
            {
                switch (*(packet_address++))
                {
                    case TPDU_SIZE:
                        length = *(packet_address++);
                        remainder_length -= 1;
                        if (length != 1)
                        {
                            TRACE_OUT(("X224: DataIndication: CR packet: Illegal TPDU_Size length"));

                            ErrorPacket (
                                temp_address,
                                (USHORT) (packet_length - remainder_length));
                            break;
                        }

                         /*
                         **    Figure out the actual PDU size
                         */
                        Arbitrated_PDU_Size = (1 << *(packet_address++));
                        remainder_length -= 1;
                        TRACE_OUT(("X224: CR_Packet: Packet size = %d", Arbitrated_PDU_Size));
                        if (Arbitrated_PDU_Size > Maximum_PDU_Size)
                        {
                            Packet_Size_Respond = TRUE;
                            Arbitrated_PDU_Size = Maximum_PDU_Size;
                        }
                        if (AllocateBuffers() == FALSE)
                        {
                            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                                   (void *) m_nLocalLogicalHandle);
                        }
                        use_default_PDU_size = FALSE;
                        break;

                    default:
                        ERROR_OUT(("X224: DataIndication: CR packet Unsupported parameter 0x%x", *(packet_address - 1)));
                        length = *(packet_address++);
                        remainder_length--;

                        packet_address += length;
                        remainder_length -= length;
                        break;
                }
                remainder_length--;
            }

             /*
             **    If the initiator wants to use the default PDU size, we need to
             **    check the default size with the Max. size to make sure it is
             **    valid for us.
             */
            if (use_default_PDU_size)
            {
                if (Default_PDU_Size > Maximum_PDU_Size)
                {
                    Packet_Size_Respond = TRUE;
                    Arbitrated_PDU_Size = Maximum_PDU_Size;
                }
                if (AllocateBuffers() == FALSE)
                {
                    m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                           (void *) m_nLocalLogicalHandle);
                }
            }

            State = RECEIVED_CONNECT_REQUEST_PACKET;

             /*
             **    Notify the owner that the remote site wants to start a
             **    connection
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_CONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            TRACE_OUT(("X224: DataInd: ConnectRequest: max pkt = %d", Arbitrated_PDU_Size));
            break;

        case CONNECTION_CONFIRM_PACKET:
            packet_accepted = TRUE;

             /*
             **    There should be at least 5 bytes remaining in this packet
             */
            if (remainder_length < 5)
            {
                ERROR_OUT(("X224: DataIndication: CC: Invalid packet received from lower layer: length = %d",
                        packet_length));
                break;
            }

            destination_reference = *(packet_address++);
            destination_reference <<= 8;
            destination_reference |= *(packet_address++);
            remainder_length -= 2;
            if (destination_reference != m_nLocalLogicalHandle)
            {
                ERROR_OUT(("X224: DataIndication: CC packet: DST-REF incorrect"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }

            m_nRemoteLogicalHandle = *(packet_address++);
            m_nRemoteLogicalHandle <<= 8;
            m_nRemoteLogicalHandle |= *(packet_address++);

            class_request = *(packet_address++) >> 4;
            remainder_length -= 3;
            if (class_request != 0)
            {
                ERROR_OUT(("X224: DataIndication: CR packet: Illegal class request"));
                ErrorPacket (
                    temp_address,
                    (USHORT) (packet_length - remainder_length));
                break;
            }
            use_default_PDU_size = TRUE;

            while (remainder_length != 0)
            {
                switch (*(packet_address++))
                {
                    case TPDU_SIZE:
                        length = *(packet_address++);
                        remainder_length -= 1;
                        if (length != 1)
                        {
                            ERROR_OUT(("X224: DataIndication: CR packet: Illegal TPDU_Size length"));

                            ErrorPacket (
                                temp_address,
                                (USHORT) (packet_length - remainder_length));
                        }
                        Arbitrated_PDU_Size = (1 << *(packet_address++));
                        remainder_length -= 1;
                        TRACE_OUT(("X224: CC_Packet: Packet size = %d", Arbitrated_PDU_Size));
                        use_default_PDU_size = FALSE;

                         /*
                         **    Allocate the buffers
                         */
                        if (AllocateBuffers() == FALSE)
                        {
                            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                                   (void *) m_nLocalLogicalHandle);
                        }
                        break;

                    default:
                        ERROR_OUT(("X224: DataIndication: CC packet Unsupported parameter"));
                        length = *(packet_address++);
                        remainder_length--;

                        packet_address += length;
                        remainder_length -= length;
                        break;
                }
                remainder_length--;
            }
            if (use_default_PDU_size)
            {
                if (AllocateBuffers () == FALSE)
                {
                    m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                           (void *) m_nLocalLogicalHandle);
                }
            }

            State = CONNECTION_ACTIVE;

             /*
             **    Notify the owner that the connect request has been confirmed
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_CONNECT_CONFIRM,
                                   (void *) m_nLocalLogicalHandle);
            TRACE_OUT(("X224: DataInd: ConnectConfirm max pkt = %d", Arbitrated_PDU_Size));
            break;

        case DISCONNECT_REQUEST_PACKET:
            TRACE_OUT(("X224: DataIndication: Disconnect req. received"));

             /*
             **    Notify the owner that a disconnect has been requested.  This
             **    message is only valid during establishment of the connection.
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            packet_accepted = TRUE;
            break;

        case ERROR_PACKET:
            TRACE_OUT(("X224: DataIndication: ERROR REQUEST received"));

             /*
             **    Notify the owner that the remote site has detected an error in
             **    one of our packets.
             */
            m_pT123->OwnerCallback(m_nMsgBase + TPRT_DISCONNECT_INDICATION,
                                   (void *) m_nLocalLogicalHandle);
            packet_accepted = TRUE;
            break;

        case DATA_PACKET:
            if ((Data_Indication_Reassembly_Active == FALSE) &&
                Data_Indication_Memory_Pool.isEmpty())
            {
                break;
            }

            packet_accepted = TRUE;

             /*
             **    There should be at least 1 bytes remaining in this packet
             */
            if (remainder_length < 1)
            {
                ERROR_OUT(("X224: DataIndication: DATA: Invalid packet "
                    "received from lower layer: length = %d", packet_length));
                break;
            }

            eot = *(packet_address++);
            remainder_length--;

             /*
             **    The EOT_BIT is set if this is the last TPDU of the TSDU
             */
            if ((eot & EOT_BIT) == EOT_BIT)
            {
                if (Data_Indication_Reassembly_Active == FALSE)
                {
                     /*
                     **    If the remote site has passed us an empty packet,
                     **    just return
                     */
                    if (remainder_length == 0)
                        break;

                     /*
                     **    If this is a single packet and there aren't any
                     **    other packets preceeding it, try to send it to the
                     **    user without copying it into our own buffers
                     */
                    if (Data_Indication_Queue.isEmpty())
                    {
                        transport_data.logical_handle = m_nLocalLogicalHandle;
                        transport_data.pbData = packet_address;
                        transport_data.cbDataSize = remainder_length;

                         /*
                         **    Issue the user callback to give the user the data.
                         */
                        user_accepted = ::NotifyT120(TRANSPORT_DATA_INDICATION, &transport_data);

                         /*
                         **    If the user appliction does NOT accept the packet
                         **    shutdown the receiver and wait for the user
                         **    to re-enable it.
                         */
                        if (user_accepted == TRANSPORT_NO_ERROR)
                            break;
                        else
                            Shutdown_Receiver = TRUE;
                    }

                     /*
                     **    Put the packet into the DataIndication queue
                     */
                    packet = (PTMemory) Data_Indication_Memory_Pool.get ();
                    packet_error = packet->Append (packet_address, remainder_length);
                    switch (packet_error)
                    {
                        case TMEMORY_NO_ERROR:
                            Data_Indication_Queue.append ((DWORD_PTR) packet);
                            break;

                        case TMEMORY_NONFATAL_ERROR:
                        case TMEMORY_FATAL_ERROR:
                            packet_accepted = FALSE;
                            break;
                    }
                }
                else
                {
                     /*
                     **    Add this PDU to the currently active SDU
                     */
                    packet_error = Active_Data_Indication -> Append (
                                    packet_address,
                                    remainder_length);

                    switch (packet_error)
                    {
                        case TMEMORY_NO_ERROR:
                            Data_Indication_Reassembly_Active = FALSE;
                            Data_Indication_Queue.append ((DWORD_PTR) Active_Data_Indication);
                            Active_Data_Indication = NULL;

                             /*
                             **    Call PollReceiver (), it will attempt to pass
                             **    the packet on up to the user.
                             */
                            PollReceiver();
                            break;

                        case TMEMORY_NONFATAL_ERROR:
                        case TMEMORY_FATAL_ERROR:
                            packet_accepted = FALSE;
                            break;
                    }
                }
            }
            else
            {
                 /*
                 **    If the remote site is passing us a zero-length packet,
                 **    just return
                 */
                if (remainder_length == 0)
                    break;

                 /*
                 **    This is NOT the last packet in the incoming SDU, copy it
                 **    into the data indication buffer and wait for the next packet
                 */
                if (Data_Indication_Reassembly_Active == FALSE)
                {
                    Data_Indication_Reassembly_Active = TRUE;
                    Active_Data_Indication = (PTMemory) Data_Indication_Memory_Pool.get ();
                }

                packet_error = Active_Data_Indication -> Append (
                                                            packet_address,
                                                            remainder_length);
                switch (packet_error)
                {
                    case TMEMORY_NO_ERROR:
                        break;

                    case TMEMORY_NONFATAL_ERROR:
                    case TMEMORY_FATAL_ERROR:
                        packet_accepted = FALSE;
                        break;
                }
            }
            break;

        default:
            ERROR_OUT(("X224: Illegal packet"));
            break;
    }

    if (packet_accepted)
        *bytes_accepted = packet_length;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::PollTransmitter (
 *                                    ULONG,
 *                                    USHORT,
 *                                    USHORT *    pending_data,
 *                                    USHORT *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function is called periodically to give X224 a chance to transmit
 *        data.
 */
ProtocolLayerError    CLayerX224::PollTransmitter (
                                ULONG_PTR,
                                USHORT,
                                USHORT *    pending_data,
                                USHORT *)
{
    // TRACE_OUT(("CLayerX224::PollTransmitter"));

    LPBYTE        packet_address;
    ULONG        bytes_accepted;
    USHORT        counter;
    USHORT        packet_size;
    ULONG        total_length;
    USHORT        packet_length;
    PMemory        memory;
    BOOL        continue_loop = TRUE;

    while (continue_loop)
    {
        switch (Packet_Pending)
        {
            case CONNECTION_REQUEST_PACKET:
                 /*
                 **    Add up the packet length, don't forget the 1 byte
                 **    for the Length Indicator
                 */
                total_length =
                    CONNECT_REQUEST_HEADER_SIZE +
                    TPDU_ARBITRATION_PACKET_SIZE +
                    1 +
                    Lower_Layer_Prepend +
                    Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                *(packet_address++) =
                    CONNECT_REQUEST_HEADER_SIZE +
                    TPDU_ARBITRATION_PACKET_SIZE;
                *(packet_address++) = CONNECTION_REQUEST_PACKET;

                 /*
                 **    The following 2 bytes are the destination reference
                 */
                *(packet_address++) = 0;
                *(packet_address++) = 0;
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle & 0xff);

                 /*
                 **    The following byte is the Class/Options
                 */
                *(packet_address++) = 0;

                 /*
                 **    Add TPDU arbitration data
                 */
                *(packet_address++) = TPDU_SIZE;
                *(packet_address++) = 1;

                 /*
                 **    Code our maximum PDU size into the X224 scheme
                 */
                Arbitrated_PDU_Size = Maximum_PDU_Size;
                packet_size = Arbitrated_PDU_Size;
                counter = 0;
                while (packet_size > 1)
                {
                    packet_size >>= 1;
                    counter++;
                }
                *(packet_address++) = (unsigned char) counter;


                 /*
                 **    Attempt to send the packet to the lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                 /*
                 **    We assume that the lower layer has a packet input
                 **    interface, if it does not, there has been a major error.
                 */
                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_CONNECT_REQUEST_PACKET;
                }
                else
                    continue_loop = FALSE;

                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case CONNECTION_CONFIRM_PACKET:
                packet_length = CONNECT_CONFIRM_HEADER_SIZE;
                if (Packet_Size_Respond)
                    packet_length += TPDU_ARBITRATION_PACKET_SIZE;

                total_length = packet_length +
                                1 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                 /*
                 **    Build the packet
                 */
                *(packet_address++) = (UChar) packet_length;
                *(packet_address++) = CONNECTION_CONFIRM_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nLocalLogicalHandle & 0xff);

                 /*
                 **    Set the Class/Options to 0
                 */
                *(packet_address++) = 0;

                 /*
                 **    Packet_Size_Respond is TRUE if we are suppose to respond
                 **    to the TPDU element in the Connect Request packet
                 */
                if (Packet_Size_Respond)
                {
                     /*
                     **    Add TPDU arbitration data
                     */
                    *(packet_address++) = TPDU_SIZE;
                    *(packet_address++) = 1;
                    packet_size = Arbitrated_PDU_Size;
                    counter = 0;
                    while (packet_size > 1)
                    {
                        packet_size >>= 1;
                        counter++;
                    }
                    *(packet_address++) = (unsigned char) counter;
                }

                 /*
                 **    Attempt to send the packet to the lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = CONNECTION_ACTIVE;
                }
                else
                    continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case DISCONNECT_REQUEST_PACKET:
                 /*
                 **    Add 1 to the length for the Length Indicator
                 */
                total_length = DISCONNECT_REQUEST_HEADER_SIZE +
                                1 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;

                TRACE_OUT(("X224: Sending Disconnect Request Packet"));
                *(packet_address++) = DISCONNECT_REQUEST_HEADER_SIZE;
                *(packet_address++) = DISCONNECT_REQUEST_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);

                 /*
                 **    Set the source reference to 0,  this packet will only
                 **    be sent as a refusal to a Connect Request, therefore
                 **    this value should be 0
                 */
                *(packet_address++) = 0;
                *(packet_address++) = 0;
                *(packet_address++) = DISCONNECT_REASON_NOT_SPECIFIED;

                 /*
                 **    Attempt to send packet to lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_DISCONNECT_REQUEST_PACKET;
                }
                continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case ERROR_PACKET:
                TRACE_OUT(("X224: Sending Error Packet"));
                total_length = ERROR_HEADER_SIZE +
                                Error_Buffer_Length +
                                1 +
                                2 +
                                Lower_Layer_Prepend +
                                Lower_Layer_Append;

                memory = Data_Request_Memory_Manager -> AllocateMemory (
                                            NULL,
                                            total_length);
                if (memory == NULL)
                {
                    continue_loop = FALSE;
                    break;
                }

                packet_address = memory -> GetPointer ();
                packet_address += Lower_Layer_Prepend;


                *(packet_address++) =
                    ERROR_HEADER_SIZE + Error_Buffer_Length;
                *(packet_address++) = ERROR_PACKET;
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle >> 8);
                *(packet_address++) = (BYTE)(m_nRemoteLogicalHandle & 0xff);
                *(packet_address++) = Reject_Cause;

                *(packet_address++) = INVALID_TPDU;
                *(packet_address++) = (UChar) Error_Buffer_Length;
                memcpy (packet_address, Error_Buffer, Error_Buffer_Length);

                 /*
                 **    Attempt to send packet to lower layer
                 */
                m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                if (bytes_accepted == total_length)
                {
                    delete [] Error_Buffer;
                    Error_Buffer = NULL;

                    Packet_Pending = TRANSPORT_NO_PACKET;
                    State = SENT_CONNECT_REQUEST_PACKET;
                }
                else
                    continue_loop = FALSE;
                Data_Request_Memory_Manager -> FreeMemory (memory);
                break;

            case TRANSPORT_NO_PACKET:
                if (Data_Request_Queue.isEmpty() == FALSE)
                {
                     /*
                     **    Get the next packet from the queue
                     */
                    memory = (PMemory) Data_Request_Queue.read ();
                    total_length = memory -> GetLength ();

                    m_pQ922->DataRequest(Identifier, memory, &bytes_accepted);

                    if (bytes_accepted == total_length)
                    {
                        Data_Request_Queue.get ();
                        Data_Request_Memory_Manager -> FreeMemory (memory);
                    }
                    else
                        continue_loop = FALSE;
                }
                else
                    continue_loop = FALSE;
                break;
        }
    }

    if (Data_Request_Queue.isEmpty())
        *pending_data = 0;
    else
        *pending_data = PROTOCOL_USER_DATA;

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    TransportError    CLayerX224::DataRequest (
 *                                ULONG,
 *                                LPBYTE    packet_address,
 *                                USHORT    packet_length,
 *                                USHORT *    bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes a packet from the user and queues it for
 *        transmission.
 */
ProtocolLayerError    CLayerX224::DataRequest (
                                ULONG_PTR,
                                LPBYTE        packet_address,
                                ULONG        packet_length,
                                PULong        bytes_accepted)
{
    TRACE_OUT(("CLayerX224::DataRequest"));

    ULONG                total_packet_size;
    ULONG                packet_size;
    DataRequestQueue    temporary_queue;
    PMemory                memory;
    BOOL                packet_failed = FALSE;
    LPBYTE                address;

    *bytes_accepted = 0;

    if (Shutdown_Transmitter)
        return (PROTOCOL_LAYER_NO_ERROR);

    total_packet_size = packet_length;

     /*
     **    Create enough PDUs to hold the packet.  We don't actually copy the
     **    packet into the new buffers until we know that we can get enough
     **    space.
     */
    while (total_packet_size != 0)
    {
        if (total_packet_size >
            (ULONG) (Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE))
        {
            packet_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
        }
        else
            packet_size = total_packet_size;

        total_packet_size -= packet_size;

        memory = Data_Request_Memory_Manager -> AllocateMemory (
                                    NULL,
                                    packet_size +
                                        DATA_PACKET_HEADER_SIZE +
                                        Lower_Layer_Prepend +
                                        Lower_Layer_Append);
        if (memory == NULL)
        {
            packet_failed = TRUE;
            break;
        }

        temporary_queue.append ((DWORD_PTR) memory);
    }


     /*
     **    If we were unable to allocate memory for the packet, release the memory
     **    that we did allocate.
     */
    if (packet_failed)
    {
        temporary_queue.reset();
        while (temporary_queue.iterate ((PDWORD_PTR) &memory))
        {
            Data_Request_Memory_Manager->FreeMemory (memory);
        }

         /*
         **    Set the User_Data_Pending flag to the packet_length so we can
         **    notify the user when buffer space is available.
         */
        User_Data_Pending = packet_length;
    }
    else
    {
        User_Data_Pending = 0;

        total_packet_size = packet_length;

         /*
         **    Go thru each of the PDUs and actually create them.
         */
        temporary_queue.reset();
        while (temporary_queue.iterate ((PDWORD_PTR) &memory))
        {
            if (total_packet_size >
                (ULONG) (Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE))
            {
                packet_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
            }
            else
                packet_size = total_packet_size;

            address = memory -> GetPointer ();

            memcpy (
                address + DATA_PACKET_HEADER_SIZE + Lower_Layer_Prepend,
                packet_address + (USHORT) (packet_length - total_packet_size),
                packet_size);

            total_packet_size -= packet_size;

             /*
             **    This is the header for a data packet
             */
            address += Lower_Layer_Prepend;
            *address = 2;
            *(address + 1) = DATA_PACKET;
            if (total_packet_size == 0)
                *(address + 2) = EOT_BIT;
            else
                *(address + 2) = 0;

             /*
             **    Load the memory object into the queue
             */
            Data_Request_Queue.append ((DWORD_PTR) memory);
        }
        *bytes_accepted = packet_length;
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::DataRequest (
 *                                    ULONG,
 *                                    PMemory,
 *                                    USHORT *        bytes_accepted)
 *
 *    Public
 *
 *    Functional Description:
 *        This function takes a packet from the user and queues it for
 *        transmission.
 */
ProtocolLayerError    CLayerX224::DataRequest (
                                ULONG_PTR,
                                PMemory,
                                PULong        bytes_accepted)
{
    *bytes_accepted = 0;

    return (PROTOCOL_LAYER_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::PollReceiver (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function should be called periodically to allow us to send received
 *        packets to the user.
 */
ProtocolLayerError CLayerX224::PollReceiver(void)
{
    // TRACE_OUT(("CLayerX224::PollReceiver"));

    LegacyTransportData    transport_data;
    ULONG            packet_accepted;
    PTMemory        packet;
    HPUChar            packet_address;
    ULONG            packet_length;

    if (Shutdown_Receiver)
        return (PROTOCOL_LAYER_NO_ERROR);

     /*
     **    If I have any packets in my receive buffers that
     **    need to go to higher layers, do it now
     */
    while (Data_Indication_Queue.isEmpty () == FALSE)
    {
        packet = (PTMemory) Data_Indication_Queue.read ();
        packet -> GetMemory (
                    &packet_address,
                    &packet_length);
        transport_data.logical_handle = m_nLocalLogicalHandle;
        transport_data.pbData = (LPBYTE) packet_address;
        transport_data.cbDataSize = packet_length;

        packet_accepted = ::NotifyT120(TRANSPORT_DATA_INDICATION, &transport_data);

         /*
         **    If the user returns anything but TRANSPORT_NO_ERROR, it could not
         **    accept the packet.  We will try to send the packet again later.
         */
        if (packet_accepted == TRANSPORT_NO_ERROR)
        {
            Data_Indication_Queue.get ();
            packet -> Reset ();
            Data_Indication_Memory_Pool.append ((DWORD_PTR) packet);
        }
        else
        {
             /*
             **    If the user appliction does NOT accept the packet
             **    shutdown the receiver and wait for the user to re-enable it.
             */
            Shutdown_Receiver = TRUE;
            break;
        }
    }

    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::GetParameters (
 *                                    ULONG,
 *                                    USHORT *    packet_size)
 *
 *    Public
 *
 *    Functional Description:
 *        This function returns the maximum allowable TSDU.
 */
ProtocolLayerError    CLayerX224::GetParameters (
                                USHORT *,
                                USHORT *,
                                USHORT *)
{
    return (PROTOCOL_LAYER_NO_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::RegisterHigherLayer (
 *                                    ULONG,
 *                                    PMemoryManager,
 *                                    IProtocolLayer *)
 *
 *    Public
 *
 *    Functional Description:
 *        This function does nothing.  The only reason it is here is because this
 *        class inherits from ProtocolLayer and this function is pure virtual in
 *        that class.
 */
ProtocolLayerError    CLayerX224::RegisterHigherLayer (
                                ULONG_PTR,
                                PMemoryManager,
                                IProtocolLayer *)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    ProtocolLayerError    CLayerX224::RemoveHigherLayer (
 *                                    ULONG)
 *
 *    Public
 *
 *    Functional Description:
 *        This function does nothing.  The only reason it is here is because this
 *        class inherits from ProtocolLayer and this function is pure virtual in
 *        that class.
 */
ProtocolLayerError    CLayerX224::RemoveHigherLayer (
                                ULONG_PTR)
{
    return (PROTOCOL_LAYER_REGISTRATION_ERROR);
}


/*
 *    BOOL        CLayerX224::AllocateBuffers ()
 *
 *    Functional Description
 *        This function allocates the data request and data indication buffers.
 *        and sets up the memory pools necessary.  It also sets up the Control
 *        buffer for control packets.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
BOOL        CLayerX224::AllocateBuffers ()
{
    TRACE_OUT(("CLayerX224::AllocateBuffers"));

    PTMemory        packet;
    USHORT            i;
    ULONG            total_packet_size;
    TMemoryError    error;

    total_packet_size = MAXIMUM_USER_DATA_SIZE;
    for (i=0; i<Data_Indication_Queue_Size; i++)
    {
        DBG_SAVE_FILE_LINE
        packet = new TMemory (
                        total_packet_size,
                        0,
                        &error);

        if (error == TMEMORY_NO_ERROR)
            Data_Indication_Memory_Pool.append ((DWORD_PTR) packet);
        else
        {
            delete packet;
            return (FALSE);
        }
    }

    return (TRUE);
}


/*
 *    void    CLayerX224::ErrorPacket (
 *                        LPBYTE    packet_address,
 *                        USHORT    packet_length)
 *
 *    Functional Description
 *        This function stores the packet into our own error buffer and prepares
 *        to send it out
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */
void    CLayerX224::ErrorPacket (
                    LPBYTE    packet_address,
                    USHORT    packet_length)
{
    TRACE_OUT(("CLayerX224::ErrorPacket"));

    DBG_SAVE_FILE_LINE
    Error_Buffer = new BYTE[packet_length];
    if (NULL != Error_Buffer)
    {
        Error_Buffer_Length = packet_length;

        memcpy (Error_Buffer, packet_address, packet_length);

        Packet_Pending = ERROR_PACKET;
    }
}


/*
 *    void    CLayerX224::CheckUserBuffers ()
 *
 *    Public
 *
 *    Functional Description:
 *        This function issues TRANSPORT_BUFFER_AVAILABLE_INDICATIONs to the
 *        user if available.
 */
void    CLayerX224::CheckUserBuffers ()
{
    // TRACE_OUT(("CLayerX224::CheckUserBuffers"));

    ULONG    user_data_size;
    ULONG    buffer_size;
    ULONG    full_size_buffers_needed;
    ULONG    full_size_buffer_count;
    ULONG    partial_buffer_size;
    ULONG    partial_buffer_count;


    if (User_Data_Pending == 0)
        return;

     /*
     **    Determine the user data size in a packet, then determine
     **    how many buffers will be needed to accept that packet.
     */
    user_data_size = Arbitrated_PDU_Size - DATA_PACKET_HEADER_SIZE;
    full_size_buffers_needed = User_Data_Pending / user_data_size;

     /*
     **    Find out how many full size buffers are available
     */
    if (full_size_buffers_needed != 0)
    {
         /*
         **    Increment full_size_buffers_needed to account for our priority
         **    value.
         */
        buffer_size =
            Arbitrated_PDU_Size + Lower_Layer_Prepend + Lower_Layer_Append;

        full_size_buffer_count = Data_Request_Memory_Manager ->
                                    GetBufferCount (buffer_size);
        if (full_size_buffer_count < full_size_buffers_needed)
            return;
    }

    partial_buffer_size = User_Data_Pending % user_data_size;
    if (partial_buffer_size != 0)
    {
        if ((full_size_buffers_needed == 0) ||
            (full_size_buffer_count == full_size_buffers_needed))
        {
            buffer_size = partial_buffer_size +
                            DATA_PACKET_HEADER_SIZE +
                            Lower_Layer_Prepend +
                            Lower_Layer_Append;

            partial_buffer_count = Data_Request_Memory_Manager ->
                                    GetBufferCount (buffer_size);

            if (full_size_buffers_needed == 0)
            {
                if (partial_buffer_count == 0)
                    return;
            }
            else
            {
                if ((partial_buffer_count == full_size_buffer_count) ||
                    (partial_buffer_count == 0))
                {
                    return;
                }
            }
        }
    }

    User_Data_Pending = 0;

    ::NotifyT120(TRANSPORT_BUFFER_EMPTY_INDICATION, (void *) m_nLocalLogicalHandle);

    return;
}


/*
 *    static    ULONG    CLayerX224::GetMaxTPDUSize (
 *                                ULONG    max_lower_layer_pdu)
 *
 *    Public
 *
 *    Functional Description:
 *        This function accepts a value for the lower layer max. PDU size
 *        and returns the max. PDU size that this Transport can support
 *        based on it.  X224 only suports max PDU sizes of 128, 256, 512,
 *        1024, and 2048.  So, if the max_lower_layer_pdu is 260, the
 *        Transport can only have a max pdu size of 256.
 */
ULONG    CLayerX224::GetMaxTPDUSize (
                    ULONG    max_lower_layer_pdu)
{
    TRACE_OUT(("CLayerX224::GetMaxTPDUSize"));

    ULONG    max_tpdu_size;

    if (max_lower_layer_pdu < 256)
        max_tpdu_size = 128;
    else if (max_lower_layer_pdu < 512)
        max_tpdu_size = 256;
    else if (max_lower_layer_pdu < 1024)
        max_tpdu_size = 512;
    else if (max_lower_layer_pdu < 2048)
        max_tpdu_size = 1024;
    else
        max_tpdu_size = 2048;

    return (max_tpdu_size);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\cb32stub\cb32stub.cpp ===
// File: cb32stub.cpp

#include <windows.h>
#include <tchar.h>
#include "SDKInternal.h"

#ifdef _DEBUG
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPSTR lpCmdLine, int nCmdShow)
#else  // _DEBUG
int __cdecl main()
#endif // _DEBUG
{
	CoInitialize(NULL);

	IInternalConfExe* pConf = NULL;

	if(SUCCEEDED(CoCreateInstance(CLSID_NmManager, NULL, CLSCTX_LOCAL_SERVER, IID_IInternalConfExe, reinterpret_cast<void**>(&pConf))))
	{
		pConf->LaunchApplet(NM_APPID_CHAT, NULL);
		pConf->Release();
	}
	
	CoUninitialize();

	#ifndef _DEBUG
		ExitProcess(0);
	#endif

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\appcollection.h ===
#ifndef __AppCollection_h__
#define __AppCollection_h__

#include "NetMeeting.h"
#include "ias.h"

class ATL_NO_VTABLE CSharableAppCollection :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISharableAppCollection, &IID_ISharableAppCollection, &LIBID_NetMeetingLib>
{

protected:

IAS_HWND_ARRAY* m_pList;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CSharableAppCollection)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSharableAppCollection)
	COM_INTERFACE_ENTRY(ISharableAppCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//////////////////////////////////////////////////////////
// Construction/destruction/initialization
//////////////////////////////////////////////////////////

CSharableAppCollection();
~CSharableAppCollection();

static HRESULT CreateInstance(IAS_HWND_ARRAY* pList, ISharableAppCollection **ppSharebleAppCollection);

//////////////////////////////////////////////////////////
// ISharableAppCollection
//////////////////////////////////////////////////////////
	STDMETHOD(get_Item)(VARIANT Index, DWORD* pSharableAppHWND);
	STDMETHOD(_NewEnum)(IUnknown** ppunk);
    STDMETHOD(get_Count)(LONG * pnCount);

//////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////
HWND _GetHWNDFromName(LPCTSTR pcsz);

};

#endif // __AppCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\asui.cpp ===
// File: asui.cpp

#include "precomp.h"
#include "resource.h"
#include "popupmsg.h"
#include "cr.h"
#include "dshowdlg.h"
#include <help_ids.h>
#include "confroom.h"
#include "confman.h"
#include "particip.h"
#include "menuutil.h"
#include <nmremote.h>
#include "NmManager.h"

//
// AppSharing part of confroom
//


//
// IAppSharingNotify METHODS
//


STDMETHODIMP CConfRoom::OnReadyToShare(BOOL fReady)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK:  CHANGE AS CHANNEL STATE
    //
    CNmManagerObj::AppSharingChannelActiveStateChanged(fReady != FALSE);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnShareStarted(void)
{
    ASSERT(m_pAS);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnSharingStarted(void)
{
    ASSERT(m_pAS);

	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnShareEnded(void)
{
    ASSERT(m_pAS);

	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPersonJoined(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- ADD PERSON TO AS CHANNEL MEMBER LIST
    //

	CNmManagerObj::ASMemberChanged(gccMemberID);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPersonLeft(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- REMOVE PERSON FROM AS CHANNEL MEMBER LIST
    //

	CNmManagerObj::ASMemberChanged(gccMemberID);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStartInControl(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change remote (gccMemberID)   to VIEWING
    //      * Change local                  to IN CONTROL
    // 

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStopInControl(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change remote (gccMemberID)   to DETACHED
    //      * Change local                  to DETACHED
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPausedInControl(IAS_GCC_ID gccMemberID)
{
    //
    // New for 3.0
    // 3.0 SDK -- Change member state?
    //
    return S_OK;
}


STDMETHODIMP CConfRoom::OnUnpausedInControl(IAS_GCC_ID gccMemberID)
{
    //
    // New for 3.0
    // 3.0 SDK -- Change member state?
    //
    return(S_OK);
}


STDMETHODIMP CConfRoom::OnControllable(BOOL fControllable)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE LOCAL STATE?
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStartControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change local                  to VIEWING
    //      * Change remote (gccMemberID)   to IN CONTROL
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStopControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change local                  to DETACHED
    //      * Change remote                 to DETACHED
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}


STDMETHODIMP CConfRoom::OnPausedControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);
    return(S_OK);
}


STDMETHODIMP CConfRoom::OnUnpausedControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);
    return(S_OK);
}




//
// RevokeControl()
//

HRESULT CConfRoom::RevokeControl(UINT gccID)
{
	if (!m_pAS)
        return E_FAIL;

	return m_pAS->RevokeControl(gccID);
}


//
// AllowControl()
//
HRESULT CConfRoom::AllowControl(BOOL fAllow)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->AllowControl(fAllow));
}



//
// GiveControl()
//
HRESULT CConfRoom::GiveControl(UINT gccID)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->GiveControl(gccID));
}


//
// CancelGiveControl()
//
HRESULT CConfRoom::CancelGiveControl(UINT gccID)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->CancelGiveControl(gccID));
}




BOOL CConfRoom::FIsSharingAvailable(void)
{
    if (!m_pAS)
        return FALSE;

    return(m_pAS->IsSharingAvailable());
}


/*  F  C A N  S H A R E  */
/*-------------------------------------------------------------------------
    %%Function: FCanShare
    
-------------------------------------------------------------------------*/
BOOL CConfRoom::FCanShare(void)
{
    if (!m_pAS)
        return FALSE;

	return (m_pAS->CanShareNow());
}


//
// FInShare()
//
BOOL CConfRoom::FInShare(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsInShare());
}


BOOL CConfRoom::FIsSharing(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsSharing());
}


//
// FIsControllable()
//
BOOL CConfRoom::FIsControllable(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsControllable());
}


//
// GetPersonShareStatus()
//
HRESULT CConfRoom::GetPersonShareStatus(UINT gccID, IAS_PERSON_STATUS * pStatus)
{
    if (!m_pAS)
        return E_FAIL;

    ZeroMemory(pStatus, sizeof(*pStatus));
    pStatus->cbSize = sizeof(*pStatus);
    return(m_pAS->GetPersonStatus(gccID, pStatus));
}


HRESULT CConfRoom::CmdShare(HWND hwnd)
{
    HRESULT hr = E_FAIL;

	DebugEntry(CConfRoom::CmdShare);

    if (m_pAS)
	{
		hr = m_pAS->Share(hwnd, IAS_SHARE_DEFAULT);

		if (SUCCEEDED(hr))
		{
			CNmManagerObj::SharableAppStateChanged(hwnd, NM_SHAPP_SHARED);
		}
	}
	DebugExitHRESULT(CConfRoom::CmdShare, hr);
	return hr;
}

HRESULT CConfRoom::CmdUnshare(HWND hwnd)
{
	HRESULT hr = E_FAIL;

	DebugEntry(CConfRoom::CmdUnshare);

    if (m_pAS)
	{
		hr = m_pAS->Unshare(hwnd);
		if (SUCCEEDED(hr))
		{
			CNmManagerObj::SharableAppStateChanged(hwnd, NM_SHAPP_NOT_SHARED);
		}
	}

	DebugExitHRESULT(CConfRoom::CmdUnshare, hr);
	return hr;
}


BOOL CConfRoom::FIsWindowShareable(HWND hwnd)
{
    if (!m_pAS)
        return(FALSE);

    return(m_pAS->IsWindowShareable(hwnd));
}


BOOL CConfRoom::FIsWindowShared(HWND hwnd)
{
    if (!m_pAS)
        return(FALSE);

    return(m_pAS->IsWindowShared(hwnd));
}


HRESULT CConfRoom::GetShareableApps(IAS_HWND_ARRAY ** pList)
{
    if (!m_pAS)
        return E_FAIL;

    return m_pAS->GetShareableApps(pList);
}


HRESULT CConfRoom::FreeShareableApps(IAS_HWND_ARRAY * pList)
{
    if (!m_pAS)
        return E_FAIL;

    return m_pAS->FreeShareableApps(pList);
}


void CConfRoom::LaunchHostUI(void)
{
    if (m_pAS)
    {
        m_pAS->LaunchHostUI();
    }
}




HRESULT GetShareState(ULONG ulGCCId, NM_SHARE_STATE *puState)
{
	HRESULT hr = E_UNEXPECTED;
	
	ASSERT(puState);
			
	*puState = NM_SHARE_UNKNOWN;

	CConfRoom *p = ::GetConfRoom();

	if(p)
	{
    	IAS_PERSON_STATUS s;
		hr = p->GetPersonShareStatus(ulGCCId, &s);

		if(SUCCEEDED(hr))
		{
			//
			// There's no share at all as far as we know, or this person isn't participating
			//
			if (!s.InShare)
			{
				*puState = NM_SHARE_UNKNOWN;
				return hr;
			}

			//
			// This person is in control of another
			//	
			if ((s.InControlOf) || (s.Controllable && !s.ControlledBy))
			{
				*puState = NM_SHARE_IN_CONTROL;
				return hr;
			}

			//
			// This person can be (and maybe is) controlled by another
			//
			if (s.Controllable)
			{
				*puState = NM_SHARE_COLLABORATING;
				return hr;
			}

			*puState = NM_SHARE_WORKING_ALONE;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\adlkup.cpp ===
#include "precomp.h"
#include <mapix.h>
#include "wabutil.h"
#include "AdLkup.h"
#include "MapiInit.h"

// From Platform SDK AddrLkup.c


////////////////////////////////////////////////////////////////////////////
/*
    This function was ripped out from the source for AdrLkup.lib
        because it is the only function that we use from that lib, and linking
        to it required linking to MAPI32.lib as well as C-RunTime LIBs.
*/
////////////////////////////////////////////////////////////////////////////

//$--HrFindExchangeGlobalAddressList-------------------------------------------------
// Returns the entry ID of the global address list container in the address
// book.
// -----------------------------------------------------------------------------
HRESULT HrFindExchangeGlobalAddressList( // RETURNS: return code
    IN LPADRBOOK  lpAdrBook,        // address book pointer
    OUT ULONG *lpcbeid,             // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid)          // pointer to entry ID pointer
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1, 
        {
            PR_ENTRYID,
        }
    };

    if(FAILED(hr))
        return(hr);

    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = (lpAdrBook)->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS, 
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = (((LPABCONT)lpRootContainer))->GetHierarchyTable(
                MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
                &lpContainerTable);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction 
    
    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

	//
	//  Query all the rows
	//

	hr = lpfnHrQueryAllRows(
	        lpContainerTable,
		    (LPSPropTagArray)&rgPropTags,
		    &SRestrictGAL,
		    NULL,
		    0,
		    &lpRows);

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = EDK_E_NOT_FOUND;
        goto cleanup;
    }

    hr = lpfnMAPIAllocateBuffer(cbContainerEntryId, (LPVOID *)lppeid);

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    lpRootContainer -> Release();
    lpContainerTable -> Release();
    lpfnFreeProws( lpRows );
    
    if(FAILED(hr))
    {
        lpfnMAPIFreeBuffer(*lppeid);

        *lpcbeid = 0;
        *lppeid = NULL;
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst123\x224.h ===
/*    X224.h
 *
 *    Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *    Abstract:
 *        This class represents the X.224 class 0 Transport functionality.  This
 *        is the highest layer in the T.123 specification.  This layer is unique
 *        in that it has direct access to the User.  When data packets are
 *        received from the remote site and reassembled by this class, they are
 *        passed on to the user via a callback.
 *
 *        This class has only limited functionality.  It basically has a simple
 *        link establishment procedure (which includes arbitration of maximum PDU
 *        size).  It is then responsible for transmitting and receiving user data.
 *        Its maximum TSDU size is 8K, and its TPDU size can range from 128 bytes
 *        to 2K.  Its TSDU size is larger than its TPDU size, it must be able to
 *        segment and reassemble the user packet.
 *
 *        This layer ASSUMES that its lower layer has a packet interface rather
 *        than a stream interface.
 *
 *        This layer ASSUMES that the disconnect of a call is handled by the
 *        Network layer (as specified in the X.224 class 0 document).
 *
 *        Prior knowledge of the X.224 class 0 specification would help the user
 *        understand the code.
 *
 *    Caveats:
 *        None.
 *
 *    Authors:
 *        James W. Lawwill
 */

#ifndef _X224_H_
#define _X224_H_

#include "tmemory2.h"

 /*
 **    The following, are states that the class can be in.
 */
typedef enum
{
    NO_CONNECTION,
    SENT_CONNECT_REQUEST_PACKET,
    SENT_CONNECT_CONFIRM_PACKET,
    SENT_DISCONNECT_REQUEST_PACKET,
    SENT_ERROR_PACKET,
    CONNECTION_ACTIVE,
    RECEIVED_CONNECT_REQUEST_PACKET,
    FAILED_TO_INITIALIZE
}
    X224State;


#define TRANSPORT_HASHING_BUCKETS   3

 /*
 **    Packet types
 */
#define TPDU_CODE_MASK              0xf0
#define TRANSPORT_NO_PACKET         0x00
#define CONNECTION_REQUEST_PACKET   0xe0
#define CONNECTION_CONFIRM_PACKET   0xd0
#define DISCONNECT_REQUEST_PACKET   0x80
#define ERROR_PACKET                0x70
#define DATA_PACKET                 0xf0

#define TSAP_CALLING_IDENTIFIER     0xc1
#define TSAP_CALLED_IDENTIFIER      0xc2
#define TPDU_SIZE                   0xc0

 /*
 **    These defines are used for the ERROR packet
 */
#define INVALID_TPDU            0xc1

 /*
 **    Packet size codes
 */
#define PACKET_SIZE_128         0x07
#define PACKET_SIZE_256         0x08
#define PACKET_SIZE_512         0x09
#define PACKET_SIZE_1024        0x0a
#define PACKET_SIZE_2048        0x0b

 /*
 **    Miscellaneous definitions
 */
#define MAXIMUM_USER_DATA_SIZE              8192
#define DATA_PACKET_HEADER_SIZE             3
#define EOT_BIT                             0x80
#define CONNECT_REQUEST_HEADER_SIZE         6
#define CONNECT_CONFIRM_HEADER_SIZE         6
#define DISCONNECT_REQUEST_HEADER_SIZE      6
#define ERROR_HEADER_SIZE                   6
#define TPDU_ARBITRATION_PACKET_SIZE        3
#define DISCONNECT_REASON_NOT_SPECIFIED     0


typedef SListClass    DataRequestQueue;
typedef SListClass    PacketQueue;


class CLayerX224 : public IProtocolLayer
{
public:

    CLayerX224(
        T123               *owner_object,
        CLayerQ922         *lower_layer,
        USHORT              message_base,
        LogicalHandle       logical_handle,
        ULONG               identifier,
        USHORT              data_indication_queue_size,
        USHORT              default_PDU_size,
        PMemoryManager      dr_memory_manager,
        BOOL               *initialization_success);

     virtual ~CLayerX224(void);

     /*
     **    Making and breaking links
     */
    TransportError    ConnectRequest (void);
    TransportError    ConnectResponse (void);
    TransportError    DisconnectRequest (void);

     /*
     **    Functions overridden from the ProtocolLayer object
     */
    ProtocolLayerError    DataRequest (
                            ULONG_PTR     identifier,
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataRequest (
                            ULONG_PTR    identifier,
                            PMemory,
                            PULong        bytes_accepted);
    ProtocolLayerError    DataIndication (
                            LPBYTE        buffer_address,
                            ULONG        length,
                            PULong        bytes_accepted);
    ProtocolLayerError    RegisterHigherLayer (
                            ULONG_PTR,
                            PMemoryManager,
                            IProtocolLayer *);
    ProtocolLayerError    RemoveHigherLayer (
                            ULONG_PTR);
    ProtocolLayerError    PollTransmitter (
                            ULONG_PTR     identifier,
                            USHORT        data_to_transmit,
                            USHORT *    pending_data,
                            USHORT *    holding_data);
    ProtocolLayerError    PollReceiver(void);
    ProtocolLayerError    GetParameters (
                            USHORT *,
                            USHORT *,
                            USHORT *);

    void                ShutdownReceiver (void);
    void                EnableReceiver (void);
    void                ShutdownTransmitter (void);
    void                PurgeRequest (void);
    void                CheckUserBuffers (void);
static    ULONG                GetMaxTPDUSize (
                            ULONG    max_lower_layer_pdu);

private:

    BOOL                AllocateBuffers (void);
    void                ErrorPacket (
                            LPBYTE    packet_address,
                            USHORT    packet_length);
private:

    DataRequestQueue    Data_Request_Queue;
    PacketQueue         Data_Indication_Queue;
    PacketQueue         Data_Indication_Memory_Pool;

    PTMemory            Active_Data_Indication;
    T123               *m_pT123; // owner object
    CLayerQ922         *m_pQ922; // lower layer;
    USHORT              m_nMsgBase;
    USHORT              Default_PDU_Size;
    USHORT              Maximum_PDU_Size;
    USHORT              Arbitrated_PDU_Size;
    ULONG               Identifier;
    PMemoryManager      Data_Request_Memory_Manager;
    USHORT              Lower_Layer_Prepend;
    USHORT              Lower_Layer_Append;
    ULONG               User_Data_Pending;

    USHORT              Data_Indication_Queue_Size;
    BOOL                Data_Indication_Reassembly_Active;

    X224State           State;
    USHORT              Packet_Pending;
    UChar               Reject_Cause;
    BOOL                Packet_Size_Respond;
    BOOL                Shutdown_Receiver;
    BOOL                Shutdown_Transmitter;

    LPBYTE              Error_Buffer;
    USHORT              Error_Buffer_Length;

    LogicalHandle       m_nLocalLogicalHandle;
    LogicalHandle       m_nRemoteLogicalHandle;
};

#endif


/*
 *    Documentation for Public class members
 */

/*
 *    Transport::Transport (
 *                PTransportResources    transport_resources,
 *                IObject *                owner_object,
 *                IProtocolLayer *        lower_layer,
 *                USHORT                message_base,
 *                USHORT                logical_handle,
 *                USHORT                identifier,
 *                USHORT                data_request_queue_size,
 *                USHORT                data_indication_queue_size,
 *                USHORT                default_PDU_size,
 *                PMemoryManager        dr_memory_manager,
 *                BOOL  *               initialization_success);
 *
 *    Functional Description
 *        This is the class constructor.  During construction, this object
 *        registers itself with its lower layer and allocates buffer space for
 *        sending and receiving data.
 *
 *    Formal Parameters
 *        transport_resources    (i)    -    Pointer to TransportResources structure.
 *        owner_object        (i) -    Address of owner object.  We use this
 *                                    address for owner callbacks.
 *        lower_layer            (i) -    Address of the lower layer that we will use
 *                                    for data reception and transmission.  This
 *                                    layer must inherit from ProtocolLayer.
 *        message_base        (i) -    Message base for messages used for owner
 *                                    callbacks.
 *        logical_handle         (i) -    This identification must be passed back to
 *                                    the owner during owner callbacks to identify
 *                                    itself.
 *        identifier             (i) -    This identifier is passed to the lower layer
 *                                    to identify itself (in case the lower layer
 *                                    is doing multiplexing.
 *        data_request_queue_size    (i) -    Number of buffers to be used for data
 *                                        requests from user.
 *        data_indication_queue_size    (i) -    Number of buffers to be used for
 *                                            data requests from user.
 *        default_PDU_size    (i) -    If the remote site does not support packet
 *                                    size arbitration, this is the default
 *        dr_memory_manager    (i) -    Data Request memory manager
 *        initialization_success    (o) -    Return TRUE if initialization was
 *                                        successful
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    Transport::~Transport (void)
 *
 *    Functional Description
 *        This is the destructor for the class.  It does all cleanup
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::ConnectRequest (void);
 *
 *    Functional Description
 *        This function is called to initiate the connection.  As a result the
 *        owner will either receive a TRANSPORT_CONNECT_CONFIRM or a
 *        TRANSPORT_DISCONNECT_INDICATION message on completion of arbitration.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::ConnectResponse (void);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        message issued by this class.  By calling this function, the user is
 *        accepting the transport connection.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    TransportError    Transport::DisconnectRequest (void);
 *
 *    Functional Description
 *        This function is called in response to a TRANSPORT_CONNECT_INDICATION
 *        message issued by this class.  By calling this function, the user is
 *        not accepting the transport connection.
 *
 *    Formal Parameters
 *        None
 *
 *    Return Value
 *        TRANSPORT_NO_ERROR    -    No error occured
 *        TRANSPORT_ERROR        -    Error
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::DataRequest (
 *                                    USHORT        identifier,
 *                                    LPBYTE        buffer_address,
 *                                    USHORT        length,
 *                                    USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by a higher layer to request transmission of
 *        a packet.
 *
 *    Formal Parameters
 *        identifier        (i)    -    Identifier of the higher layer
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Length of packet to transmit
 *        bytes_accepted    (o)    -    Number of bytes accepted by the Transport.
 *                                This value will either be 0 or the packet
 *                                length since this layer is a packet to byte
 *                                converter.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::DataIndication (
 *                                    LPBYTE        buffer_address,
 *                                    USHORT        length,
 *                                    USHORT *        bytes_accepted);
 *
 *    Functional Description
 *        This function is called by the lower layer when it has data to pass up
 *
 *    Formal Parameters
 *        buffer_address    (i)    -    Buffer address
 *        length            (i)    -    Number of bytes available
 *        bytes_accepted    (o)    -    Number of bytes accepted
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::RegisterHigherLayer (
 *                                    USHORT,
 *                                    IProtocolLayer *);
 *
 *    Functional Description
 *        This function is called by the higher layer to register its identifier
 *        and its address.  This function is not used by this class.  It is only
 *        in here because this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR                -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::RemoveHigherLayer (
 *                                    USHORT);
 *
 *    Functional Description
 *        This function is called by the higher layer to remove its identifier
 *        and its address.  This function is not used by this class.  It is only
 *        in here because this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    Transport::PollTransmitter (
 *                                        USHORT,
 *                                        USHORT        data_to_transmit,
 *                                        USHORT *        pending_data,
 *                                        USHORT *)
 *
 *    Functional Description
 *        This function is called to give the Transport a chance transmit data
 *        in its Data_Request buffer.
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *        data_to_transmit    (i)    -    This is a mask that tells us to send Control
 *                                    data, User data, or both.  Since the
 *                                     Transport does not differentiate between
 *                                    data types it transmits any data it has
 *        pending_data        (o)    -    Return value to indicate which data is left
 *                                    to be transmitted.
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 *
 */

/*
 *    ProtocolLayerError    Transport::PollReceiver (
 *                                    USHORT    identifier);
 *
 *    Functional Description
 *        This function is called to give the Transport a chance pass packets
 *        to higher layers
 *
 *    Formal Parameters
 *        identifier            (i)    -    Not used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR    -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    ProtocolLayerError    Transport::GetParameters (
 *                                    USHORT    identifier,
 *                                    USHORT *    max_packet_size,
 *                                    USHORT *    prepend,
 *                                    USHORT *    append);
 *
 *    Functional Description:
 *        This function is not used by this class.  It is only in here because
 *        this class inherits from ProtocolLayer and this function
 *        is a pure virtual function.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        PROTOCOL_LAYER_NO_ERROR        -    No error occured
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::ShutdownReceiver ();
 *
 *    Functional Description:
 *        This function tells the object to stop accepting packets from the
 *        lower layer
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::EnableReceiver (void);
 *
 *    Functional Description:
 *        This function tells the object to start sending packets up to the user
 *        again.  If the X224 object ever issues a DATA_INDICATION and it fails,
 *        we shutdown the receiver.  We wait for this call to be issued before
 *        we start sending up packets again.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::ShutdownTransmitter (void);
 *
 *    Functional Description:
 *        This function tells the object to stop accepting packets from
 *        higher layers.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::PurgeRequest (void);
 *
 *    Functional Description:
 *        This function removes all packets from the Transport's outbound queue
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    void    Transport::CheckUserBuffers (void);
 *
 *    Functional Description:
 *        This function determines if the user has recently failed to pass a
 *        packet down to the Transport because we didn't have enough memory
 *        available to handle it.  If he did and we NOW have space for that
 *        packet, we will issue a TRANSPORT_BUFFER_EMPTY_INDICATION callback
 *        to the user, to notify him that we can accept it.
 *
 *    Formal Parameters
 *        None used
 *
 *    Return Value
 *        None
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

/*
 *    static    ULONG    Transport::GetMaxTPDUSize (
 *                                ULONG    max_lower_layer_pdu)
 *
 *    Public
 *
 *    Functional Description:
 *        This function accepts a value for the lower layer max. PDU size
 *        and returns the max. PDU size that this Transport can support
 *        based on it.  X224 only suports max PDU sizes of 128, 256, 512,
 *        1024, and 2048.  So, if the max_lower_layer_pdu is 260, the
 *        Transport can only have a max pdu size of 256.
 *
 *    Formal Parameters
 *        max_lower_layer_pdu        -    Since we pass data to the lower layer,
 *                                    we must conform to its max packet size.
 *
 *    Return Value
 *        The largest TPDU that we will send based on the max_lower_layer_pdu.
 *
 *    Side Effects
 *        None
 *
 *    Caveats
 *        None
 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\adlkup.h ===
#ifndef __AdLkup_h__
#define __AdLkup_h__


////////////////////////////////////////////////////////////////////////////
/*
    This function was ripped out from the source for AdrLkup.lib
        because it is the only function that we use from that lib, and linking
        to it required linking to MAPI32.lib as well as C-RunTime LIBs.
*/
////////////////////////////////////////////////////////////////////////////

//$--HrFindExchangeGlobalAddressList-------------------------------------------------
// Returns the entry ID of the global address list container in the address
// book.
// -----------------------------------------------------------------------------
HRESULT HrFindExchangeGlobalAddressList( // RETURNS: return code
    IN LPADRBOOK  lpAdrBook,        // address book pointer
    OUT ULONG *lpcbeid,             // pointer to count of bytes in entry ID
    OUT LPENTRYID *lppeid);         // pointer to entry ID pointer






////////////////////////////////////////////////////////////////////////////
/*

    The following constants were ripped out from various header files from
        the platform SDK because including the actual headers pulled in a bunch
        of stuff that we didn't care about.  Because there are so few dependencies
        it was better to just grab the constants...
*/
////////////////////////////////////////////////////////////////////////////

 // From platform SDK _entryid.h

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}




// From platform SDK EdkCode.h

// Every HRESULT is built from a serverity value, a facility
// value and an error code value.

#define FACILITY_EDK    11          // EDK facility value

// Pairs of EDK error codes and the HRESULTs built from them.
// EDK functions always return HRESULTs.  Console applications
// return exit codes via the _nEcFromHr function.

#define EC_EDK_E_NOT_FOUND          0x0001
#define EDK_E_NOT_FOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_EDK, EC_EDK_E_NOT_FOUND)



// This is taken from emsabTag.h
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)


#endif // __AdLkup_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\appcollection.cpp ===
#include "precomp.h"
#include "AppCollection.h"
#include "confroom.h"
#include "EnumVar.h"

//////////////////////////////////////////////////////////
// Construction/destruction/initialization
//////////////////////////////////////////////////////////

CSharableAppCollection::CSharableAppCollection()
: m_pList(NULL)
{
	DBGENTRY(CSharableAppCollection::CSharableAppCollection);
	
	DBGEXIT(CSharableAppCollection::CSharableAppCollection);
}

CSharableAppCollection::~CSharableAppCollection()
{
	DBGENTRY(CSharableAppCollection::~CSharableAppCollection);
	
	if(m_pList)
	{
		FreeShareableApps(m_pList);
	}

	DBGEXIT(CSharableAppCollection::~CSharableAppCollection);
}

//static 
HRESULT CSharableAppCollection::CreateInstance(IAS_HWND_ARRAY* pList, ISharableAppCollection **ppSharebleAppCollection)
{
	DBGENTRY(HRESULT CSharableAppCollection::CreateInstance);
	HRESULT hr = S_OK;

	if(pList)
	{	
		CComObject<CSharableAppCollection>* p = NULL;
		p = new CComObject<CSharableAppCollection>(NULL);
		if(p)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hr = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if(hr == S_OK)
			{
				hr = p->QueryInterface(IID_ISharableAppCollection, reinterpret_cast<void**>(ppSharebleAppCollection));
				p->m_pList = pList;
			}

			if(FAILED(hr))		
			{
				delete p;
				*ppSharebleAppCollection = NULL;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT(CSharableAppCollection::CreateInstance);
	return hr;
}

//////////////////////////////////////////////////////////
// ISharableAppCollection
//////////////////////////////////////////////////////////
STDMETHODIMP CSharableAppCollection::get_Item(VARIANT Index, DWORD* pSharableAppHWND)
{
	DBGENTRY(CSharableAppCollection::get_Item);
	HRESULT hr = S_OK;

	if(m_pList)
	{
		if(pSharableAppHWND)
		{
			switch(Index.vt)
			{
				case VT_BSTR:
				        LPTSTR  szName;
				        hr =  BSTR_to_LPTSTR (&szName, Index.bstrVal);				        
                                    if (SUCCEEDED(hr))
                                    {
        					*pSharableAppHWND = reinterpret_cast<long>(_GetHWNDFromName(szName));
        				         // Free resources
        				         //
        				         delete  (szName);
                                    }
					break;

				case VT_I2:
					if(static_cast<UINT>(Index.iVal) < m_pList->cEntries)
					{
						*pSharableAppHWND = reinterpret_cast<long>(m_pList->aEntries[Index.iVal].hwnd);
					}
					else
					{
						hr = E_INVALIDARG;
					}
					break;

				case VT_I4:
					if(static_cast<UINT>(Index.lVal) < m_pList->cEntries)
					{
						*pSharableAppHWND = reinterpret_cast<long>(m_pList->aEntries[Index.lVal].hwnd);
					}
					else
					{
						hr = E_INVALIDARG;
					}
					break;

				default:
					hr = E_INVALIDARG;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CSharableAppCollection::get_Item,hr);
	return hr;
}

STDMETHODIMP CSharableAppCollection::_NewEnum(IUnknown** ppunk)
{
	DBGENTRY(CSharableAppCollection::_NewEnum);
	HRESULT hr = S_OK;

	if(m_pList)
	{
		SAFEARRAY* psa;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = m_pList->cEntries;

		psa = SafeArrayCreate(VT_I4, m_pList->cEntries, rgsabound);
		if(psa)
		{
			for(UINT i = 0; i < m_pList->cEntries; ++i)
			{
				CComVariant var(reinterpret_cast<long>(m_pList->aEntries[i].hwnd));
				long ix[1] = {i};
				SafeArrayPutElement(psa, ix, &var);
			}

			CEnumVariant* pEnumVar = NULL;
			hr = CEnumVariant::Create(psa, m_pList->cEntries, &pEnumVar);
			if(SUCCEEDED(hr))
			{
				hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(ppunk));
			}

			SafeArrayDestroy(psa);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	DBGEXIT_HR(CSharableAppCollection::_NewEnum,hr);
	return hr;

}

STDMETHODIMP CSharableAppCollection::get_Count(LONG * pnCount)
{
	DBGENTRY(CSharableAppCollection::get_Count);
	HRESULT hr = S_OK;

	if(m_pList)
	{
		if(pnCount)
		{
			*pnCount = m_pList->cEntries;
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CSharableAppCollection::get_Count,hr);
	return hr;
}


//////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////
HWND CSharableAppCollection::_GetHWNDFromName(LPCTSTR pcsz)
{
	HWND hWnd = NULL;

	if(m_pList)
	{
		int cch = lstrlen(pcsz) + 1;
		LPTSTR pszTmp = new TCHAR[cch];
		if(pszTmp)
		{
			for(UINT i = 0; i < m_pList->cEntries; ++i)
			{
				HWND hWndCur = m_pList->aEntries[i].hwnd;
				if(::GetWindowText(hWndCur , pszTmp, cch))
				{
						// If the window text is the same, just return the hwnd
					if(!lstrcmp(pcsz, pszTmp))
					{
						hWnd = hWndCur;
						break;
					}
				}
			}

			delete [] pszTmp;
		}
	}

	return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\atlexemodule.cpp ===
#include "precomp.h"
#include "Conf.h"
#include "confpolicies.h"
#include "AtlExeModule.h"
#include "NmManager.h"
#include "NmApp.h"

// This is slightly modified from the code that AtlAppWizard generates for local servers


CExeModule::CExeModule()
: m_dwThreadID( 0 ),
  m_hResourceModule( NULL ),
  m_bInitControl(FALSE),
  m_bVisible(FALSE),
  m_bDisableH323(FALSE),
  m_bDisableInitialILSLogon(FALSE)
{
	DBGENTRY(CExeModule::CExeModule);

	DBGEXIT(CExeModule::CExeModule);
}

LONG CExeModule::Unlock()
{
	DBGENTRY(CExeModule::Unlock);
	
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
		if (ConfPolicies::RunWhenWindowsStarts())
		{
			// we may want to make sure that there is no conference
			// if there is,we should probably bring up the UI
		}
		else
		{
			if( !IsUIVisible() )
			{
				CmdShutdown();
			}
		}
    }

	DBGEXIT_INT(CExeModule::Unlock,l);
    return l;
}


BOOL CExeModule::IsUIActive()
{
	return !InitControlMode() &&
		(0 == CNmManagerObj::GetManagerCount(NM_INIT_OBJECT)) && 
		(IsUIVisible() ||
		 (0 == CNmManagerObj::GetManagerCount(NM_INIT_BACKGROUND)) &&
		 (0 == CNetMeetingObj::GetObjectCount()));
}

// Declare the _Module
CExeModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\atlexemodule.h ===
#ifndef __AtlExeModule_h__
#define __AtlExeModule_h__

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{

public: // Data
	DWORD		m_dwThreadID;
	HINSTANCE	m_hResourceModule;
	BOOL		m_bInitControl;
	BOOL		m_bVisible;
	BOOL		m_bDisableH323;
	BOOL		m_bDisableInitialILSLogon;
	BOOL        m_bCallerIsRTC;

// Construction / destriction
	CExeModule();

// Fns
	void SetUIVisible(BOOL bVisible) { m_bVisible = bVisible; }
	BOOL IsUIVisible()  { return m_bVisible; }
	BOOL IsUIActive();
	BOOL InitControlMode() { return m_bInitControl; }
	void SetInitControlMode(BOOL bInitControl) { m_bInitControl = bInitControl; }
	void SetSDKDisableH323(BOOL bDisable) { m_bDisableH323 = bDisable; };
	BOOL DidSDKDisableH323() { return m_bDisableH323; }
	void SetSDKDisableInitialILSLogon(BOOL bDisable) { m_bDisableInitialILSLogon = bDisable; };
	BOOL DidSDKDisableInitialILSLogon() { return m_bDisableInitialILSLogon; }
	void SetSDKCallerIsRTC (BOOL bCallerIsRTC) { m_bCallerIsRTC = bCallerIsRTC; }
	BOOL IsSDKCallerRTC () { return m_bCallerIsRTC; }
	HINSTANCE GetResourceModule(void) const { return m_hResourceModule; }

	LONG Unlock();

};

extern CExeModule _Module;


#endif // __AtlExeModule_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audioctl.cpp ===
// File: audioctl.cpp

#include "precomp.h"
#include "resource.h"
#include "audioctl.h"
#include "mixer.h"
#include "confpolicies.h"

CAudioControl::CAudioControl(HWND hwnd) :
	m_pRecMixer(NULL),
	m_pSpkMixer(NULL),
	m_fMicMuted(FALSE),
	m_fSpkMuted(FALSE),
	m_pChannelMic(NULL),
	m_pChannelSpk(NULL),
	m_pAudioEvent(NULL),
	m_dwRecordDevice(0),
	m_dwPlaybackDevice(0),
	m_dwSilenceLevel(DEFAULT_MICROPHONE_SENSITIVITY * 10),
	m_hwndParent(hwnd)
{
	m_dwMicVolume.leftVolume	= 0xFFFFFFFF,
	m_dwMicVolume.rightVolume	= 0xFFFFFFFF;
	m_dwSpkVolume.leftVolume	= 0xFFFFFFFF;
	m_dwSpkVolume.rightVolume	= 0xFFFFFFFF;
	m_dwSpkVolumeOld.leftVolume	= 0xFFFFFFFF;
	m_dwSpkVolumeOld.rightVolume	= 0xFFFFFFFF;

	LoadSettings();
	OnDeviceChanged();
	OnAGC_Changed();
	OnSilenceLevelChanged();
}

CAudioControl::~CAudioControl()
{
	SaveSettings();

	// restore speaker volume
	if (m_pSpkMixer && (m_dwSpkVolumeOld.leftVolume <= 0x0000ffff || m_dwSpkVolumeOld.rightVolume <= 0x0000ffff))
	{
		m_pSpkMixer->SetVolume(&m_dwSpkVolumeOld);
	}


	delete m_pRecMixer;
	delete m_pSpkMixer;

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->Release();
	}
	if (NULL != m_pChannelSpk)
	{
		m_pChannelSpk->Release();
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   OnChannelChanged()
*
*    PURPOSE:  Tracks audio channel changes
*
****************************************************************************/

void CAudioControl::OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	INmChannelAudio* pChannelAudio;
	if (SUCCEEDED(pChannel->QueryInterface(IID_INmChannelAudio, (void**)&pChannelAudio)))
	{
		if (S_OK == pChannelAudio->IsActive())
		{
			if (S_OK == pChannelAudio->IsIncoming())
			{
				if (NULL == m_pChannelSpk)
				{
					m_pChannelSpk = pChannelAudio;
					m_pChannelSpk->AddRef();
					m_pChannelSpk->SetProperty(NM_AUDPROP_PAUSE, m_fSpkMuted);
					m_pChannelSpk->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwPlaybackDevice);
				}
			}
			else
			{
				if (NULL == m_pChannelMic)
				{
					m_pChannelMic = pChannelAudio;
					m_pChannelMic->AddRef();
					m_pChannelMic->SetProperty(NM_AUDPROP_PAUSE, m_fMicMuted);
					m_pChannelMic->SetProperty(NM_AUDPROP_LEVEL, m_dwSilenceLevel);
					m_pChannelMic->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwRecordDevice);
					m_pChannelMic->SetProperty(NM_AUDPROP_AUTOMIX, m_fAutoMix);
				}
			}
		}
		else
		{
			if (S_OK == pChannelAudio->IsIncoming())
			{
				// were done with the speaker channel
				if (pChannelAudio == m_pChannelSpk)
				{
					m_pChannelSpk->Release();
					m_pChannelSpk = NULL;
				}
			}
			else
			{
				// were done with the speaker channel
				if (pChannelAudio == m_pChannelMic)
				{
					m_pChannelMic->Release();
					m_pChannelMic = NULL;
				}
			}
		}
		pChannelAudio->Release();
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   RefreshMixer()
*
*    PURPOSE:  Refreshes all controls that are mixer dependent
*
****************************************************************************/

void CAudioControl::RefreshMixer()
{
	if (NULL != m_pSpkMixer)
	{
		MIXVOLUME dwVol;
		BOOL fValid;
		fValid = m_pSpkMixer->GetVolume(&dwVol);

		if (fValid && (dwVol.leftVolume != m_dwSpkVolume.leftVolume || dwVol.rightVolume != m_dwSpkVolume.rightVolume))
		{
			m_dwSpkVolume.leftVolume = dwVol.leftVolume;
			m_dwSpkVolume.rightVolume = dwVol.rightVolume;

			if (NULL != m_pAudioEvent)
			{
				m_pAudioEvent->OnLevelChange(TRUE /* fSpeaker */, max(m_dwSpkVolume.leftVolume , m_dwSpkVolume.rightVolume));
			}
		}
	}
	
	if (NULL != m_pRecMixer)
	{
		BOOL fChanged = FALSE;
		
		MIXVOLUME dwMainVol = {0,0};
		BOOL fValidMain = m_pRecMixer->GetMainVolume(&dwMainVol);
		
		MIXVOLUME dwMicVol = {0,0};
		BOOL fValidMic = m_pRecMixer->GetSubVolume(&dwMicVol);
		
		if (fValidMain && (m_dwMicVolume.leftVolume != dwMainVol.leftVolume || m_dwMicVolume.rightVolume != dwMainVol.rightVolume))
		{
			m_dwMicVolume.leftVolume = dwMainVol.leftVolume;
			m_dwMicVolume.rightVolume = dwMainVol.rightVolume;

			// Force the mic vol to equal the main vol
			SetRecorderVolume(&dwMainVol);
			fChanged = TRUE;
		}
		else if (fValidMic && (m_dwMicVolume.leftVolume != dwMicVol.leftVolume || m_dwMicVolume.rightVolume != dwMicVol.rightVolume))
		{
			m_dwMicVolume.leftVolume = dwMicVol.leftVolume;
			m_dwMicVolume.rightVolume = dwMicVol.rightVolume;

			// Force the main vol to equal the mic vol
			SetRecorderVolume(&dwMicVol);
			fChanged = TRUE;
		}

		if (fChanged)
		{
			if (NULL != m_pAudioEvent)
			{
				m_pAudioEvent->OnLevelChange(FALSE /* fSpeaker */, max(m_dwMicVolume.leftVolume , m_dwMicVolume.rightVolume));
			}
		}
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   MuteAudio(BOOL fSpeaker, BOOL fMute)
*
*    PURPOSE:  Internal routine to mute an audio device
*
****************************************************************************/

VOID CAudioControl::MuteAudio(BOOL fSpeaker, BOOL fMute)
{
	INmChannelAudio *pChannel;
	if (fSpeaker)
	{
		m_fSpkMuted = fMute;
		pChannel = m_pChannelSpk;
	}
	else
	{
		m_fMicMuted = fMute;
		pChannel = m_pChannelMic;
	}

	if (NULL != pChannel)
	{
		pChannel->SetProperty(NM_AUDPROP_PAUSE, fMute);
	}

	if (NULL != m_pAudioEvent)
	{
		m_pAudioEvent->OnMuteChange(fSpeaker, fMute);
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   GetAudioSignalLevel(BOOL fSpeaker)
*
*    PURPOSE:  Internal routine to get the audio signal level
*
****************************************************************************/

DWORD CAudioControl::GetAudioSignalLevel(BOOL fSpeaker)
{
	DWORD_PTR dwLevel = 0;
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;

	if (NULL != pChannel)
	{
		pChannel->GetProperty(NM_AUDPROP_LEVEL, &dwLevel);
	}

	return (DWORD)dwLevel;
}

BOOL CAudioControl::CanSetRecorderVolume()
{
	if (NULL != m_pRecMixer)
	{
		return m_pRecMixer->CanSetVolume();
	}
	return FALSE;
}

BOOL CAudioControl::CanSetSpeakerVolume()
{
	if (NULL != m_pSpkMixer)
	{
		return m_pSpkMixer->CanSetVolume();
	}
	return FALSE;
}

void CAudioControl::SetRecorderVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->SetVolume(pdwVolume);
	}
}

void CAudioControl::SetSpeakerVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pSpkMixer)
	{
		m_pSpkMixer->SetVolume(pdwVolume);
	}
}

void CAudioControl::GetRecorderVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->GetVolume(pdwVolume);
	}
}

void CAudioControl::GetSpeakerVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pSpkMixer)
	{
		m_pSpkMixer->GetVolume(pdwVolume);
	}
}


void CAudioControl::SetRecorderVolume(DWORD dwVolume)
{
	MIXVOLUME mixVol;
	MIXVOLUME mixNewVol;

	GetRecorderVolume(&mixVol);

	NewMixVolume(&mixNewVol, mixVol, dwVolume);
				
	SetRecorderVolume(&mixNewVol);
	
}

void CAudioControl::SetSpeakerVolume(DWORD dwVolume)
{	
	MIXVOLUME mixVol;
	MIXVOLUME mixNewVol;

	GetSpeakerVolume(&mixVol);

	NewMixVolume(&mixNewVol, mixVol, dwVolume);
				
	SetSpeakerVolume(&mixNewVol);

}


void CAudioControl::OnDeviceChanged()
{
	MIXVOLUME dwMicVolume;
	DWORD dwNewPlaybackDevice;

	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

	dwNewPlaybackDevice = re.GetNumber(REGVAL_WAVEOUTDEVICEID, 0);

	// restore the speaker setting before changing to the new device
	// verify that we aren't changing to the same device
	if (m_pSpkMixer && (m_dwSpkVolumeOld.leftVolume <= 0x0000ffff || m_dwSpkVolumeOld.rightVolume <= 0x0000ffff) &&
		(m_dwPlaybackDevice != dwNewPlaybackDevice) )
	{
		m_pSpkMixer->SetVolume(&m_dwSpkVolumeOld);
	}


	// Initialize the proper record/playback devices:
	delete m_pRecMixer;
	m_dwRecordDevice = re.GetNumber(REGVAL_WAVEINDEVICEID, 0);
	m_pRecMixer = CMixerDevice::GetMixerForWaveDevice(
			m_hwndParent,
			m_dwRecordDevice,
			MIXER_OBJECTF_WAVEIN);

	delete m_pSpkMixer;
	m_dwPlaybackDevice = dwNewPlaybackDevice;
	m_pSpkMixer = CMixerDevice::GetMixerForWaveDevice(
			m_hwndParent,
			m_dwPlaybackDevice,
			MIXER_OBJECTF_WAVEOUT);

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwRecordDevice);
	}

	if (NULL != m_pChannelSpk)
	{
		m_pChannelSpk->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwPlaybackDevice);
	}

	// restore the microphone setting from whatever it was in the tuning wizard
	if (m_pRecMixer)
	{
		dwMicVolume.leftVolume = dwMicVolume.rightVolume = re.GetNumber(REGVAL_CALIBRATEDVOL, 0x00ff);
		m_pRecMixer->SetVolume(&dwMicVolume);
	}

	// remember the old speaker volume
	if (m_pSpkMixer)
	{
		m_pSpkMixer->GetVolume(&m_dwSpkVolumeOld);
	}


	RefreshMixer();
}

void CAudioControl::OnAGC_Changed()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	BOOL fAgc = ( reAudio.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );


	m_fAutoMix = (reAudio.GetNumber(REGVAL_AUTOMIX, AUTOMIX_ENABLED) == AUTOMIX_ENABLED);

	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->SetAGC(fAgc);
	}

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_AUTOMIX, m_fAutoMix);
	}
}

void CAudioControl::OnSilenceLevelChanged()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	if (MICROPHONE_AUTO_NO == reAudio.GetNumber(REGVAL_MICROPHONE_AUTO,
										MICROPHONE_AUTO_YES))
	{
		// Use "manual" mode:
	
		// BUGBUG - there is a mismatch in terminology between
		// "sensitivity" and "threshhold", which reverses the
		// sense of this value. A low threshhold implies a high
		// sensitivity, etc.
		// Reverse the sense of this value before setting the
		// Nac value, and resolve the terminology problem later.
		// PROP_SILENCE_LEVEL property is in units of 0.1%, so scale it.
		m_dwSilenceLevel = (MAX_MICROPHONE_SENSITIVITY -
					reAudio.GetNumber(REGVAL_MICROPHONE_SENSITIVITY,
									DEFAULT_MICROPHONE_SENSITIVITY))*10;
	}
	else
	{
		// Use "automatic" mode:  This is actually controlled by
		// PROP_SILENCE_LEVEL.  If at maximum (100%), then it is
		// in "automatic" mode
		m_dwSilenceLevel = 100*10; // remember units are 0.1%
	
	}

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_LEVEL, m_dwSilenceLevel);
	}
}



BOOL CAudioControl::LoadSettings()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	m_fSpkMuted = reAudio.GetNumber(REGVAL_SPKMUTE, FALSE);
	m_fMicMuted = reAudio.GetNumber(REGVAL_RECMUTE, FALSE);

	return TRUE;
}


BOOL CAudioControl::SaveSettings()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );
	
	reAudio.SetValue(REGVAL_SPKMUTE, m_fSpkMuted);
	reAudio.SetValue(REGVAL_RECMUTE, m_fMicMuted);


	//
	// Check if the microphone got changed during this section
	//
	if(m_pRecMixer)
	{
		MIXVOLUME dwMicVol = {0,0};
		m_pRecMixer->GetVolume(&dwMicVol);

		DWORD oldVolume = reAudio.GetNumber(REGVAL_CALIBRATEDVOL, 0x00ff);
		DWORD newVolume = max(dwMicVol.leftVolume,dwMicVol.rightVolume);
		
		if(oldVolume != newVolume)
		{
			reAudio.SetValue(REGVAL_CALIBRATEDVOL, newVolume);
		}
	}


	return TRUE;
}

HRESULT CAudioControl::SetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR uValue)
{
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;
	if (NULL != pChannel)
	{
		return(pChannel->SetProperty(uID, uValue));
	}

	return(E_UNEXPECTED);
}

HRESULT CAudioControl::GetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR *puValue)
{
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;
	if (NULL != pChannel)
	{
		return(pChannel->GetProperty(uID, puValue));
	}

	return(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\avdefs.h ===
// File: avDefs.h

#ifndef _AVDEFS_H_

//To bring in the video stuff...from the NAC interface
#ifndef WSA_IO_PENDING

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } WSA_IO_PENDING

#include <mmreg.h>
#include <msacm.h>
#include <vidinout.h>
#include <vcmstrm.h>
#include <iacapapi.h>

#endif /* _AVDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audioctl.h ===
#ifndef _AUDIOCTL_H_
#define _AUDIOCTL_H_

#include "SDKInternal.h"
#include "mixer.h"

interface IAudioEvent
{
public:
	virtual void OnLevelChange(BOOL fSpeaker, DWORD dwVolume) = 0;
	virtual void OnMuteChange(BOOL fSpeaker, BOOL fMute) = 0;
};
	
class CMixerDevice;

class CAudioControl
{
private:
	CMixerDevice*	m_pRecMixer;
	CMixerDevice*	m_pSpkMixer;
	MIXVOLUME		m_dwMicVolume;
	MIXVOLUME 		m_dwSpkVolume;
	BOOL			m_fMicMuted;
	BOOL			m_fSpkMuted;
	DWORD			m_dwRecordDevice;
	DWORD			m_dwPlaybackDevice;
	DWORD			m_dwSilenceLevel;
	BOOL			m_fAutoMix;
	INmChannelAudio * m_pChannelMic;
	INmChannelAudio * m_pChannelSpk;
	IAudioEvent *	m_pAudioEvent;
	HWND			m_hwndParent;

	MIXVOLUME			m_dwSpkVolumeOld;

protected:
	BOOL LoadSettings();
	BOOL SaveSettings();

public:
	CAudioControl(HWND hwnd);
	~CAudioControl();

	void	OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	void	RefreshMixer();

	VOID	OnDeviceChanged();
	VOID	OnAGC_Changed();
	VOID	OnSilenceLevelChanged();

	void	RegisterAudioEventHandler(IAudioEvent *pEvent)
					{ m_pAudioEvent = pEvent; }

	BOOL	CanSetRecorderVolume();
	BOOL	CanSetSpeakerVolume();
	void	SetRecorderVolume(MIXVOLUME *pdwVolume);
	void	SetSpeakerVolume(MIXVOLUME *pdwVolume);

	void	SetRecorderVolume(DWORD dwVolume);
	void	SetSpeakerVolume(DWORD  dwVolume);

	void	GetRecorderVolume(MIXVOLUME *pdwVolume);
	void	GetSpeakerVolume(MIXVOLUME *pdwVolume);

	DWORD	GetRecorderVolume()	{ return max(m_dwMicVolume.leftVolume , m_dwMicVolume.rightVolume); }
	DWORD	GetSpeakerVolume() { return  max(m_dwSpkVolume.leftVolume , m_dwSpkVolume.rightVolume); }


	void	MuteAudio(BOOL fSpeaker, BOOL fMute);
	DWORD	GetAudioSignalLevel(BOOL fSpeaker);

	BOOL	IsSpkMuted() { return m_fSpkMuted;}
	BOOL	IsRecMuted() { return m_fMicMuted;}

	HRESULT	SetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR uValue);
	HRESULT	GetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR *puValue);
};

#endif	// _AUDIOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audiocpl.cpp ===
// File: AudioCpl.cpp

#include "precomp.h"
#include "resource.h"
#include "avdefs.h"
#include "ConfCpl.h"

#include "help_ids.h"
#include <ih323cc.h>
#include <initguid.h>
#include <nacguids.h>
#include <auformats.h>

#include "ConfPolicies.h"


const int SLOW_CPU_MHZ = 110;  // pentiums 110mhz - 180mhz are "slow"
const int FAST_CPU_MHZ = 200; // fast machines are 200mhz and faster
const int VERYFAST_CPU_MHZ = 500; // un-normalized, this will include 400 mhz PentIIs


// 486 and slow pentium (<= 100 mhz) settings (VERY SLOW)
const UINT CIF_RATE_VERYSLOW = 3;
const UINT SQCIF_RATE_VERYSLOW = 7;
const UINT QCIF_RATE_VERYSLOW = 7;

// pentium 75mhz settings (SLOW)
const UINT CIF_RATE_SLOW = 7;
const UINT SQCIF_RATE_SLOW = 15;
const UINT QCIF_RATE_SLOW = 15;


// pentium 200mhz settings (FAST)
const UINT CIF_RATE_FAST = 15;
const UINT SQCIF_RATE_FAST = 30;
const UINT QCIF_RATE_FAST = 30;

const UINT CIF_RATE_VERYFAST = 30;




typedef struct _CODECINFO
{
	HINSTANCE			hLib;
	IH323CallControl*	lpIH323;
	UINT				uNumFormats;
	PBASIC_AUDCAP_INFO	pCodecCapList;
	PWORD				pOldCodecOrderList;
	PWORD				pCurCodecOrderList;
	LPAPPCAPPIF 		lpIAppCap;
	LPAPPVIDCAPPIF		lpIVidAppCap;
	LPCAPSIF			lpICapsCtl;

} CODECINFO, *PCODECINFO;

typedef struct
{
	BOOL fManual;
	UINT uBandwidth;
	PCODECINFO pCodecInfo;
} ADVCODEC, *PADVCODEC;


//SS: the cpu utilization is bogus so for now hide it
//#define CODEC_LV_NUM_COLUMNS	3
#define CODEC_LV_MAX_COLUMNS	3
#define CODEC_LV_NUM_COLUMNS	2



#define MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE 50	//Don't use more than this % of the CPU for encoding
												//Also in nac\balance.cpp


// given the bandwidth identifier (1-4) and the CPU megahertz, return
// the actual bandwidth amount in bits/sec
int GetBandwidthBits(int id, int megahertz)
{
	int nBits=BW_144KBS_BITS;

	switch (id)
	{
		case BW_144KBS:
			nBits=BW_144KBS_BITS;
			break;
		case BW_288KBS:
			nBits=BW_288KBS_BITS;
			break;
		case BW_ISDN:
			nBits=BW_ISDN_BITS;
			break;
		case BW_MOREKBS:  // LAN
			if (megahertz >= VERYFAST_CPU_MHZ)
			{
				nBits = BW_FASTLAN_BITS;
			}
			else
			{
				nBits = BW_SLOWLAN_BITS;
			}
			break;
	}

	return nBits;
}


// begin data types used for ChooseCodecByBw
#define CODEC_DISABLED	99
#define CODEC_UNKNOWN	98

typedef struct _codecprefrow
{
	WORD wFormatTag;
	WORD wOrder586;
	WORD wOrder486;
	WORD wMinBW;
} CODECPREFROW;

typedef CODECPREFROW	CODECPREFTABLE[];
	
// FORMAT NAME             586 Order      486 Order       Minimum BW
static const CODECPREFTABLE g_CodecPrefTable =
{
   WAVE_FORMAT_MSG723,     1,             CODEC_DISABLED, BW_144KBS,
   WAVE_FORMAT_LH_SB16,    2,             1,              BW_288KBS,
   WAVE_FORMAT_LH_SB8,     3,             2,              BW_144KBS,
   WAVE_FORMAT_LH_SB12,    4,             3,              BW_144KBS,
   WAVE_FORMAT_MULAW,      5,             4,              BW_ISDN,
   WAVE_FORMAT_ALAW,       6,             5,              BW_ISDN,
   WAVE_FORMAT_ADPCM,      7,             6,              BW_ISDN,
   WAVE_FORMAT_LH_CELP,    8,             CODEC_DISABLED, BW_144KBS,
   WAVE_FORMAT_MSRT24,    9,             7, BW_144KBS
};
// end of stuff used by ChooseCodecByBw

static const int g_ColHdrStrId[CODEC_LV_MAX_COLUMNS] =
{
	IDS_CODECNAME,
	IDS_MAXBITRATE,
	IDS_CPUUTIL,
};



//prototypes
INT_PTR CALLBACK AdvCodecDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int CALLBACK CodecLVCompareProc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
BOOL FillCodecListView(HWND hCB, PCODECINFO pCodecInfo);
BOOL ChooseCodecByBw(UINT uBandWidthId, PCODECINFO pCodecInfo);
void SortCodecs(PADVCODEC pAdvCodec, int nSelection);
BOOL SetAppCodecPrefs(PCODECINFO pCodecInfo,UINT uBandwith);
BOOL GetIAppCap(PCODECINFO pCodecInfo);
BOOL GetAppCapFormats(PCODECINFO pCodecInfo);
void FreeAppCapFormats(PCODECINFO pCodecInfo);
void ReleaseIAppCap(PCODECINFO pCodecInfo);
BOOL ApplyUserPrefs(PCODECINFO pCodecInfo, UINT uMaximumBandwidth);


static const DWORD _rgHelpIdsAudio[] = {

	IDC_GENERAL_GROUP, 				IDH_AUDIO_GENERAL,
	IDC_FULLDUPLEX, 				IDH_AUDIO_FULL_DUPLEX,
	IDC_AUTOGAIN,					IDH_AUDIO_AUTO_GAIN,
	IDC_AUTOMIX,                    IDH_AUDIO_AUTOMIXER,
	IDC_DIRECTSOUND,                IDH_AUDIO_DIRECTSOUND,
	IDC_START_AUDIO_WIZ,			IDH_AUDIO_TUNING_WIZARD,

	IDC_ADVANCEDCODEC,				IDH_AUDIO_ADVANCED_CODEC_SETTINGS,

	IDC_MICSENSE_GROUP,				IDH_AUDIO_MIC_SENSITIVITY,
	IDC_MICSENSE_AUTO,				IDH_AUDIO_AUTO_SENSITIVITY,
	IDC_MICSENSE_MANUAL,			IDH_AUDIO_MANUAL_SENSITIVITY,
	IDC_TRK_MIC,					IDH_AUDIO_MANUAL_SENSITIVITY,

	0, 0   // terminator
};
	


VOID InitAudioSettings(HWND hDlg, BOOL *pfFullDuplex, BOOL *pfAgc, BOOL *pfAutoMix, BOOL *pfDirectSound)
{
	BOOL	fFullDuplex = FALSE;
	BOOL	fAgc = FALSE;
	BOOL	fDirectSound;
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

	UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

	ASSERT(ISSOUNDCARDPRESENT(uSoundCardCaps) && (!SysPol::NoAudio()));

	if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps) && ConfPolicies::IsFullDuplexAllowed())
	{					
		::EnableWindow(::GetDlgItem(hDlg, IDC_FULLDUPLEX), TRUE);
		// read settings from registry
		fFullDuplex = (BOOL)
			( re.GetNumber(REGVAL_FULLDUPLEX,0) == FULLDUPLEX_ENABLED );
	}					
	else
	{
		DisableControl(hDlg, IDC_FULLDUPLEX);
	}
	
	if (DOESSOUNDCARDHAVEAGC(uSoundCardCaps))
	{					
		::EnableWindow(::GetDlgItem(hDlg, IDC_AUTOGAIN), TRUE);
		// read settings from registry
		fAgc = (BOOL)
			( re.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );
	}					
	else
	{
		DisableControl(hDlg, IDC_AUTOGAIN);
	}


	*pfFullDuplex = fFullDuplex;

	// for automix and agc, don't try updating the check-mark if
	// NULL has been passed in

	if (pfAutoMix)
	{
		*pfAutoMix = (BOOL)(re.GetNumber(REGVAL_AUTOMIX, AUTOMIX_ENABLED) == AUTOMIX_ENABLED);
		SendDlgItemMessage(hDlg, IDC_AUTOMIX, BM_SETCHECK, *pfAutoMix, 0L);
	}

	if (pfAgc)
	{
		*pfAgc = fAgc;
		SendDlgItemMessage ( hDlg, IDC_AUTOGAIN, BM_SETCHECK, fAgc, 0L );
	}

	
	if (ISDIRECTSOUNDAVAILABLE(uSoundCardCaps))
	{
        RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);

		fDirectSound = (BOOL)(re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED) == DSOUND_USER_ENABLED);
		::EnableWindow(::GetDlgItem(hDlg, IDC_DIRECTSOUND),
            !rePol.GetNumber(REGVAL_POL_NOCHANGE_DIRECTSOUND, DEFAULT_POL_NOCHANGE_DIRECTSOUND));
	}
	else
	{
		fDirectSound = FALSE;
		::EnableWindow(::GetDlgItem(hDlg, IDC_DIRECTSOUND), FALSE);
		SendDlgItemMessage(hDlg, IDC_DIRECTSOUND, BM_SETCHECK, FALSE, 0L);
	}

	// don't check the checkbox if the caller didn't pass in a var to be updated
	if (pfDirectSound)
	{
		*pfDirectSound = fDirectSound;
		SendDlgItemMessage(hDlg, IDC_DIRECTSOUND, BM_SETCHECK, *pfDirectSound, 0L);
	}


	// set the check boxes for those that are enabled
	SendDlgItemMessage ( hDlg, IDC_FULLDUPLEX,
			BM_SETCHECK, *pfFullDuplex, 0L );



}
			
INT_PTR APIENTRY AudioDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static	PROPSHEETPAGE * ps;
	static UINT uOldCodecChoice;
	static UINT uNewCodecChoice;
	static BOOL fOldFullDuplex;
	static BOOL fOldAgc;
	static BOOL fOldAutoMic;
	static BOOL fOldAutoMix;
	static BOOL fOldDirectSound;
	static BOOL fOldH323GatewayEnabled;
	static UINT uOldMicSense;
	static CODECINFO CodecInfo;
	static BOOL bAdvDlg;

	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

			InitAudioSettings(hDlg, &fOldFullDuplex, &fOldAgc, &fOldAutoMix, &fOldDirectSound);

			//initialize the codecinfo structure, these will be set as and when needed
			ZeroMemory(&CodecInfo, sizeof(CodecInfo));

			uNewCodecChoice = uOldCodecChoice = re.GetNumber(REGVAL_CODECCHOICE, CODECCHOICE_AUTO);

			// Get Audio settings
			fOldAutoMic = (BOOL)
				( re.GetNumber(REGVAL_MICROPHONE_AUTO,
					DEFAULT_MICROPHONE_AUTO) == MICROPHONE_AUTO_YES );

			SendDlgItemMessage ( hDlg,
						fOldAutoMic ? IDC_MICSENSE_AUTO : IDC_MICSENSE_MANUAL,
						BM_SETCHECK, TRUE, 0L );

			EnableWindow ( GetDlgItem ( hDlg, IDC_TRK_MIC ),
				(BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_MANUAL,
										BM_GETCHECK, 0,0));

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETRANGE, FALSE,
				MAKELONG (MIN_MICROPHONE_SENSITIVITY,
					MAX_MICROPHONE_SENSITIVITY ));

			uOldMicSense = re.GetNumber ( REGVAL_MICROPHONE_SENSITIVITY,
									DEFAULT_MICROPHONE_SENSITIVITY );

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETTICFREQ,
				( MAX_MICROPHONE_SENSITIVITY - MIN_MICROPHONE_SENSITIVITY )
														/ 10, 0 );

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETPOS, TRUE,
								uOldMicSense );

			bAdvDlg = FALSE;

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_APPLY:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
					BOOL fFullDuplex = SendDlgItemMessage
							(hDlg, IDC_FULLDUPLEX, BM_GETCHECK, 0, 0 ) ?
								FULLDUPLEX_ENABLED : FULLDUPLEX_DISABLED;

					BOOL fAgc = SendDlgItemMessage
							(hDlg, IDC_AUTOGAIN, BM_GETCHECK, 0, 0 ) ?
								AUTOGAIN_ENABLED : AUTOGAIN_DISABLED;

					BOOL fAutoMix = SendDlgItemMessage
							(hDlg, IDC_AUTOMIX, BM_GETCHECK, 0, 0) ?
								AUTOMIX_ENABLED : AUTOMIX_DISABLED;

					BOOL fDirectSound = SendDlgItemMessage
							(hDlg, IDC_DIRECTSOUND, BM_GETCHECK, 0, 0) ?
								DSOUND_USER_ENABLED : DSOUND_USER_DISABLED;

					if ( fFullDuplex != fOldFullDuplex )
					{
						re.SetValue ( REGVAL_FULLDUPLEX, fFullDuplex );
						g_dwChangedSettings |= CSETTING_L_FULLDUPLEX;
					}
					if ( fAgc != fOldAgc )
					{
						re.SetValue ( REGVAL_AUTOGAIN, fAgc );
						g_dwChangedSettings |= CSETTING_L_AGC;
					}

					// use same flag bit as agc as for automix
					// since this automix and agc may evenutally
					// get combined into 1 ui choice
					if (fAutoMix != fOldAutoMix)
					{
						re.SetValue(REGVAL_AUTOMIX, fAutoMix);
						g_dwChangedSettings |= CSETTING_L_AGC;
					}

					if (fDirectSound != fOldDirectSound)
					{
						re.SetValue(REGVAL_DIRECTSOUND, fDirectSound);
						g_dwChangedSettings |= CSETTING_L_DIRECTSOUND;
					}

					UINT uBandWidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH,BW_DEFAULT);

					// if the advanced dialog has not been accessed,
					// then there is nothing to changes as far as the
					// codecs go
					if (bAdvDlg)
					{
						if (uNewCodecChoice == CODECCHOICE_AUTO)
						{
							//apply heuristics and apply the prefs to registry
							ChooseCodecByBw(uBandWidth, &CodecInfo);
							SetAppCodecPrefs(&CodecInfo, uBandWidth);
						}
						else
						{
							for (int i = 0; i < (int)CodecInfo.uNumFormats &&
									CodecInfo.pCodecCapList; i++)
							{
								if (CodecInfo.pCodecCapList[i].wSortIndex !=
										CodecInfo.pOldCodecOrderList[i])
								{
									// oder has changed, save the new order
									SetAppCodecPrefs(&CodecInfo, uBandWidth);
									break;
								}
							}
						}
					}

					FreeAppCapFormats(&CodecInfo);

					// Handle the Trackbar controls:

					BOOL fAutoMic = (BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_AUTO,
													BM_GETCHECK, 0, 0 );

					if ( fAutoMic != fOldAutoMic ) {
						g_dwChangedSettings |= CSETTING_L_AUTOMIC;
						re.SetValue ( REGVAL_MICROPHONE_AUTO, fAutoMic ?
							MICROPHONE_AUTO_YES : MICROPHONE_AUTO_NO );
					}

					UINT uMicSense = (UINT)SendDlgItemMessage( hDlg, IDC_TRK_MIC,
								TBM_GETPOS, 0, 0 );

					if ( uMicSense != uOldMicSense ) {
						g_dwChangedSettings |= CSETTING_L_MICSENSITIVITY;
						re.SetValue ( REGVAL_MICROPHONE_SENSITIVITY, uMicSense);
					}
					break;
				}

				case PSN_RESET:
					//reset the codec choice in the registry if it has changed
					if (uNewCodecChoice != uOldCodecChoice)
					{
						RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
						re.SetValue(REGVAL_CODECCHOICE, uOldCodecChoice);
					}

					//free the capformats if allocated
					FreeAppCapFormats(&CodecInfo);
					break;
			}
			break;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case IDC_START_AUDIO_WIZ:
				{
					AUDIOWIZOUTPUT AwOutput;
					BOOL fFullDuplex, fAgc, fDirectSound, fCurrentDS;
					
					if (::FIsConferenceActive())
					{
						ConfMsgBox(hDlg,
								(LPCTSTR)IDS_NOAUDIOTUNING);
						break;
					}

					fAgc = SendDlgItemMessage
								(hDlg, IDC_AUTOGAIN, BM_GETCHECK, 0, 0 ) ?
									AUTOGAIN_ENABLED : AUTOGAIN_DISABLED;
					//SS:note the calibrated value can get out of sync
					//need a warning

					CallAudioCalibWizard(hDlg,RUNDUE_USERINVOKED,WAVE_MAPPER,&AwOutput,(INT)fAgc);
					if (AwOutput.uChanged & SOUNDCARD_CHANGED)
						g_dwChangedSettings |= CSETTING_L_AUDIODEVICE;
					
					// wizard can change duplex, and agc availability, and DirectSound
					// don't pass in AGC and AUTOMIX pointers, because we don't want
					// the checkboxes to revet back to what they were initialized at.

					InitAudioSettings(hDlg, &fFullDuplex, NULL, NULL, NULL);
					break;
				}

				case IDC_ADVANCEDCODEC:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

					//SS ::: get the cap formats,
					//this will retrieve the codec caps if not allready rerieved
					if (GetAppCapFormats(&CodecInfo))
					{
						ADVCODEC AdvCodec;

						AdvCodec.fManual = (uNewCodecChoice == CODECCHOICE_MANUAL);
						AdvCodec.uBandwidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);
						AdvCodec.pCodecInfo = &CodecInfo;

						if ((DialogBoxParam(GetInstanceHandle(),MAKEINTRESOURCE(IDD_ADVANCEDCODEC),hDlg,AdvCodecDlgProc,
							(LPARAM)&AdvCodec)) == IDCANCEL)
						{
							//the dialog box changes it in place so current settings need to be restored into
							//update the pcodecinfo sort order from the previous current settings
							for (int i = 0; i < (int)CodecInfo.uNumFormats; i++)
								(CodecInfo.pCodecCapList[i]).wSortIndex = CodecInfo.pCurCodecOrderList[i];
						}
						else
						{
							uNewCodecChoice = (AdvCodec.fManual ?
									CODECCHOICE_MANUAL : CODECCHOICE_AUTO);
							re.SetValue(REGVAL_CODECCHOICE, uNewCodecChoice);

							//else update the current
							for (int i = 0; i < (int)CodecInfo.uNumFormats; i++)
								CodecInfo.pCurCodecOrderList[i] = (CodecInfo.pCodecCapList[i]).wSortIndex;

							bAdvDlg = TRUE;
						}
					}
					break;
				}
				
				case IDC_MICSENSE_AUTO:
				case IDC_MICSENSE_MANUAL:
					EnableWindow ( GetDlgItem ( hDlg, IDC_TRK_MIC ),
						(BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_MANUAL,
												BM_GETCHECK, 0,0));
					break;

				default:
					break;
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsAudio);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsAudio);
			break;
	}
	return (FALSE);
}


static const DWORD aAdvCodecHelpIds[] = {

	IDC_CODECMANUAL, IDH_AUDIO_MANUAL_CODEC_SETTINGS,
	IDC_COMBO_CODEC, IDH_ADVCOMP_CODECS,
	IDC_CODECDEFAULT, IDH_ADVCOMP_DEFAULTS,
	IDC_CODECLISTLABEL, IDH_ADVCOMP_CODECS,

	0, 0   // terminator
};

INT_PTR CALLBACK AdvCodecDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static PADVCODEC	pAdvCodec = NULL;
	static nCodecSelection=0;
	WORD				wCmdId;
	
	switch(uMsg)
	{
		case WM_INITDIALOG:
			//get the list of codecs
			pAdvCodec = (PADVCODEC)lParam;
			ASSERT(pAdvCodec);

			SendDlgItemMessage ( hDlg, IDC_CODECMANUAL,
					BM_SETCHECK, pAdvCodec->fManual, 0L );
			EnableWindow(GetDlgItem(hDlg, IDC_COMBO_CODEC), pAdvCodec->fManual);

			if (!pAdvCodec->fManual)
			{
				ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);
			}

			//fill the list box;
			FillCodecListView(GetDlgItem(hDlg, IDC_COMBO_CODEC),
					pAdvCodec->pCodecInfo);

			if (pAdvCodec->fManual)
			{
				nCodecSelection = (int)SendMessage((HWND)lParam, CB_GETCURSEL, 0,0);
				// convert index of combo box choice to index in capability list
				nCodecSelection = (int)SendMessage((HWND)lParam, CB_GETITEMDATA, nCodecSelection,0);
			}

			return(TRUE);

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aAdvCodecHelpIds);
			break;

		case WM_HELP:
			DoHelp(lParam, aAdvCodecHelpIds);
			break;

		case WM_COMMAND:
			wCmdId = GET_WM_COMMAND_ID (wParam, lParam);	// LOWORD (uParam)
			switch (wCmdId)
			{
			case IDOK:
				if (pAdvCodec->fManual)
				{
					nCodecSelection = (int)SendDlgItemMessage(hDlg, IDC_COMBO_CODEC, CB_GETCURSEL, 0,0);
					nCodecSelection = (int)SendDlgItemMessage(hDlg, IDC_COMBO_CODEC, CB_GETITEMDATA, nCodecSelection,0);
					SortCodecs(pAdvCodec, nCodecSelection);
				}
				EndDialog (hDlg, IDOK);
				return(TRUE);
	
			case IDCANCEL:
				EndDialog(hDlg, IDCANCEL);
				return(TRUE);



			case IDC_CODECMANUAL:
				pAdvCodec->fManual = (BOOL)SendDlgItemMessage ( hDlg, IDC_CODECMANUAL,
						BM_GETCHECK, 0,0);
				EnableWindow(GetDlgItem(hDlg, IDC_COMBO_CODEC), pAdvCodec->fManual);
				if (pAdvCodec->fManual)
				{
					break;
				}
				else
				{
					ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);
					FillCodecListView(GetDlgItem(hDlg, IDC_COMBO_CODEC),
							pAdvCodec->pCodecInfo);
				}

				break;

			
			} // WM_COMMAND

		default:
			return FALSE;
	}
	return (FALSE);
}




BOOL FillCodecListView(HWND hCB, PCODECINFO pCodecInfo)
{
	PBASIC_AUDCAP_INFO	pCurCodecCap;
	UINT uIndex, uTotal, uItemIndex;
	UINT uSortTop, uSortTopIndex;


	SendMessage(hCB, CB_RESETCONTENT,0,0); // erase all items in CB

	uSortTopIndex = 0;
	uTotal = pCodecInfo->uNumFormats;
	uSortTop = uTotal-1;

	for (uIndex = 0; uIndex < uTotal; uIndex++)
	{
		pCurCodecCap = &(pCodecInfo->pCodecCapList[uIndex]);

		if ((!pCurCodecCap->bRecvEnabled) && (!pCurCodecCap->bSendEnabled))
		{
			continue;
		}

		uItemIndex = (UINT)SendMessage(hCB, CB_ADDSTRING, 0, (LPARAM)(pCurCodecCap->szFormat));
		SendMessage(hCB, CB_SETITEMDATA, uItemIndex, uIndex);

		if (pCurCodecCap->wSortIndex < uSortTop)
		{
			uSortTop = pCurCodecCap->wSortIndex;
			uSortTopIndex = uItemIndex;
		}
	}

	SendMessage(hCB, CB_SETCURSEL, uSortTopIndex, 0);

	return TRUE;
}


void SortCodecs(PADVCODEC pAdvCodec, int nSelection)
{
	PBASIC_AUDCAP_INFO	pDefaultCodec, pSelectedCodec, pCodec;
	WORD wSortOrderBest, wSortOrderSelected;
	UINT uIndex;


	if (!pAdvCodec->fManual)
		return;

	if ((nSelection < 0) || ((UINT)nSelection > (pAdvCodec->pCodecInfo->uNumFormats)))
	{
		return;
	}

	ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);

	// this is the codec the user selected
	pSelectedCodec = &(pAdvCodec->pCodecInfo->pCodecCapList[nSelection]);

	// all codecs that have a sort index less than the selected codec
	// get moved down one
	for (uIndex = 0; uIndex < pAdvCodec->pCodecInfo->uNumFormats; uIndex++)
	{
		pCodec = &(pAdvCodec->pCodecInfo->pCodecCapList[uIndex]);
		if (pCodec->wSortIndex < pSelectedCodec->wSortIndex)
		{
			pCodec->wSortIndex = pCodec->wSortIndex + 1;
		}
	}
	pSelectedCodec->wSortIndex = 0;

}



#define SQCIF	0x1
#define QCIF	0x2
#define CIF 	0x4
#define UNKNOWN 0x8
#define get_format(s) (s == Small ? SQCIF : (s == Medium ? QCIF: (s == Large ? CIF : UNKNOWN)))

BOOL SetAppCodecPrefs(PCODECINFO pCodecInfo,UINT uBandwidth)
{

	BOOL	fRet = FALSE;
	HRESULT hr;
	DWORD dwcFormats,dwcFormatsReturned;
	BASIC_VIDCAP_INFO *pvidcaps = NULL;
	UINT dwBitsPerSec,x;
	int iFamily,format, nNormalizedSpeed;
	int nCifIncrease;
	DWORD dwSysPolBandwidth;

	// frame rates initialized to 486/P60 settings
	UINT uRateCIF=CIF_RATE_VERYSLOW, uRateQCIF=QCIF_RATE_VERYSLOW, uRateSQCIF=SQCIF_RATE_VERYSLOW;

	if (!pCodecInfo->lpIAppCap)
	{
		if (!GetIAppCap(pCodecInfo))
			goto MyExit;

	}		
	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->ApplyAppFormatPrefs(pCodecInfo->pCodecCapList,
		pCodecInfo->uNumFormats))))
		goto MyExit;

	//Set the BW to something sane

#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&iFamily);
#else
	//BUGBUG, setting things really high, otherwise,
	iFamily=6;
	nNormalizedSpeed=300;
#endif

	dwBitsPerSec = GetBandwidthBits(uBandwidth,nNormalizedSpeed);
	dwSysPolBandwidth = SysPol::GetMaximumBandwidth();

	// apply bandwidth policy key if the user's setting is set to
	// a LAN speed
	if ((dwSysPolBandwidth > 0) && (dwBitsPerSec >= BW_SLOWLAN_BITS))
	{
		dwBitsPerSec = dwSysPolBandwidth;
	}


	if ((iFamily >= 5) && (nNormalizedSpeed >= SLOW_CPU_MHZ))
	{
		// normal pentiums (75mhz - 180mhz)
		if (nNormalizedSpeed < FAST_CPU_MHZ)
		{
			uRateCIF =  CIF_RATE_SLOW;
			uRateQCIF = QCIF_RATE_SLOW;
			uRateSQCIF= SQCIF_RATE_SLOW;
		}

		// pentiums between 200-350 mhz
		else if (nNormalizedSpeed < VERYFAST_CPU_MHZ)
		{
			uRateCIF = CIF_RATE_FAST;
			uRateQCIF = QCIF_RATE_FAST;
			uRateSQCIF = SQCIF_RATE_FAST;
		}

		// really fast pentiums (400mhz and greater)
		else
		{
			// it would be better if we could scale between 15 and 30 frames/sec
			// depending on the CPU speed.  But H.245 doesn't have any values
			// between 15 and 30.  (See definition of Minimum Picture Interval)
			// So for now, 30 frames per sec CIF for all 400mhz and faster machines
			uRateCIF = CIF_RATE_VERYFAST;
			uRateQCIF = QCIF_RATE_FAST;
			uRateSQCIF = SQCIF_RATE_FAST;
		}

	}


	// Get the number of BASIC_VIDCAP_INFO structures available
	if (pCodecInfo->lpIVidAppCap->GetNumFormats((UINT*)&dwcFormats) != S_OK)
		goto MyExit;

	if (dwcFormats > 0)
	{
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR,dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto MyExit;

		// Get the list
		if (pCodecInfo->lpIVidAppCap->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
		   (UINT*)&dwcFormatsReturned) != S_OK)
			goto MyExit;

		//Setup the Bandwitdh, and the frame rate (according to philf's #s)
		for (x=0;x<dwcFormatsReturned;x++)
		{

			// If the codec is "hardware accelerated" (0 for cpu usage), then we assume
			// that the maximum bitrate is whatever is specified at install
			// time.

			pvidcaps[x].uMaxBitrate=dwBitsPerSec;

			if (pvidcaps[x].wCPUUtilizationEncode == 0)
			{
				// hardware acceleration - don't change the frame rate
				continue;
			}

			format=get_format (pvidcaps[x].enumVideoSize);
			//Which format
			switch (format)
			{
				case SQCIF:
					pvidcaps[x].uFrameRate=uRateSQCIF;
					break;
				case QCIF:
					pvidcaps[x].uFrameRate=uRateQCIF;
					break;
				case CIF:
					pvidcaps[x].uFrameRate=uRateCIF;
					break;
				default:
					WARNING_OUT(("Incorrect Frame size discovered\r\n"));
					pvidcaps[x].uFrameRate=uRateCIF;
				}
		   }
		}

	// Ok, now submit this list
	if (pCodecInfo->lpIVidAppCap->ApplyAppFormatPrefs(pvidcaps, dwcFormats) != S_OK)
			goto MyExit;

	// Free the memory, we're done
	LocalFree(pvidcaps);

	// Set the bandwidth limit, which rebuilds capability sets
	hr = pCodecInfo->lpIH323->SetMaxPPBandwidth(dwBitsPerSec);
	fRet = !FAILED(hr);

MyExit:
	return (fRet);

}


BOOL GetIAppCap(PCODECINFO pCodecInfo)
{
	BOOL		fRet=TRUE;
	HRESULT 	hr;

	if (pCodecInfo->lpIAppCap && pCodecInfo->lpIVidAppCap && pCodecInfo->lpICapsCtl)
		return TRUE;

	if(NULL == pCodecInfo->lpIH323)
	{
		IH323CallControl *pIH323 = NULL;

		pCodecInfo->hLib = ::NmLoadLibrary(H323DLL,FALSE);
		if ((pCodecInfo->hLib) == NULL)
		{
			WARNING_OUT(("NmLoadLibrary(H323DLL) failed"));
			return FALSE;
		}

		CREATEH323CC	pfnCreateH323 = (CREATEH323CC) ::GetProcAddress(pCodecInfo->hLib, SZ_FNCREATEH323CC);
		if (pfnCreateH323 == NULL)
		{
			ERROR_OUT(("GetProcAddress(CreateH323) failed"));
			return FALSE;
		}

		hr = pfnCreateH323(&pIH323, FALSE, 0);
		if (FAILED(hr))
		{
			ERROR_OUT(("CreateH323 failed, hr=0x%lx", hr));
			return FALSE;
		}

		pCodecInfo->lpIH323 = pIH323;
	}
    else
    {
    	// going to Release() later, so AddRef()
	    pCodecInfo->lpIH323->AddRef();
    }

	if(!pCodecInfo->lpIAppCap)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IAppAudioCap, (void **)&(pCodecInfo->lpIAppCap));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}
	if(!pCodecInfo->lpIVidAppCap)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IAppVidCap, (void **)&(pCodecInfo->lpIVidAppCap));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}
	if(!pCodecInfo->lpICapsCtl)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IDualPubCap, (void **)&(pCodecInfo->lpICapsCtl));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}

MyExit:
	if (!fRet)
	{
		ReleaseIAppCap(pCodecInfo);
	}
	return (fRet);
}



BOOL GetAppCapFormats(PCODECINFO pCodecInfo)
{
	BOOL				fRet = FALSE;
	UINT				uNumFormats = 0;
	HRESULT 			hr;
	int 				i;
	
	if (pCodecInfo->pCodecCapList)
		return TRUE;

	if (!pCodecInfo->lpIAppCap)
	{
		if (!GetIAppCap(pCodecInfo))
			goto MyExit;

	}		
	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->GetNumFormats(&uNumFormats))))
		goto MyExit;
		
	if (!uNumFormats)
		goto MyExit;
	
	if (!(pCodecInfo->pCodecCapList =  (PBASIC_AUDCAP_INFO)LocalAlloc
		(LPTR,uNumFormats * sizeof(BASIC_AUDCAP_INFO))))
		goto MyExit;
		
	if (!(pCodecInfo->pOldCodecOrderList =	(PWORD)LocalAlloc
		(LPTR,uNumFormats * sizeof(WORD))))
		goto MyExit;

		if (!(pCodecInfo->pCurCodecOrderList =	(PWORD)LocalAlloc
			(LPTR,uNumFormats * sizeof(WORD))))
		goto MyExit;


	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->EnumFormats(pCodecInfo->pCodecCapList,
		uNumFormats * sizeof(BASIC_AUDCAP_INFO), &(pCodecInfo->uNumFormats)))))
	{
		//free the memory
		LocalFree(pCodecInfo->pCodecCapList);
		pCodecInfo->pCodecCapList = NULL;
		LocalFree(pCodecInfo->pOldCodecOrderList);
		pCodecInfo->pOldCodecOrderList = NULL;
		LocalFree(pCodecInfo->pCurCodecOrderList);
		pCodecInfo->pCurCodecOrderList = NULL;
		pCodecInfo->uNumFormats = 0;
		goto MyExit;
	}

	// initialize the old and the current state
	for (i=0; i<(int)pCodecInfo->uNumFormats;i++)
	{
		pCodecInfo->pCurCodecOrderList[i] = pCodecInfo->pCodecCapList[i].wSortIndex;
		pCodecInfo->pOldCodecOrderList[i] = pCodecInfo->pCodecCapList[i].wSortIndex;
		//SS:hack if we dont have the average, use the max as average
		if (!(pCodecInfo->pCodecCapList[i].uAvgBitrate))
			pCodecInfo->pCodecCapList[i].uAvgBitrate = pCodecInfo->pCodecCapList[i].uMaxBitrate;

	}

	fRet = TRUE;
	
MyExit:
	if (!fRet)
	{
		FreeAppCapFormats(pCodecInfo);
	}
	return (fRet);
}

void FreeAppCapFormats(PCODECINFO pCodecInfo)
{
	if (pCodecInfo->pCodecCapList)
	{
		LocalFree(pCodecInfo->pCodecCapList);
		pCodecInfo->pCodecCapList = NULL;
		pCodecInfo->uNumFormats = 0;
	}
	if (pCodecInfo->pOldCodecOrderList)
	{
		LocalFree(pCodecInfo->pOldCodecOrderList);
		pCodecInfo->pOldCodecOrderList = NULL;
	}
	if (pCodecInfo->pCurCodecOrderList)
	{
		LocalFree(pCodecInfo->pCurCodecOrderList);
		pCodecInfo->pCurCodecOrderList = NULL;
	}

	ReleaseIAppCap(pCodecInfo);
}

void ReleaseIAppCap(PCODECINFO pCodecInfo)
{
	if(pCodecInfo->lpIAppCap)
	{
		pCodecInfo->lpIAppCap->Release();
		pCodecInfo->lpIAppCap = NULL;
	}
	if(pCodecInfo->lpIVidAppCap)
	{
		pCodecInfo->lpIVidAppCap->Release();
		pCodecInfo->lpIVidAppCap = NULL;
	}
	if(pCodecInfo->lpICapsCtl)
	{
		pCodecInfo->lpICapsCtl->Release();
		pCodecInfo->lpICapsCtl = NULL;
	}
	if(pCodecInfo->lpIH323)
	{
		pCodecInfo->lpIH323->Release();
		pCodecInfo->lpIH323 = NULL;
	}
	if (pCodecInfo->hLib)
	{
		FreeLibrary(pCodecInfo->hLib);
		pCodecInfo->hLib = NULL;
	}
}



static void IsCodecDisabled(WORD wFormatTag, int cpu_family,
            UINT uBandwidthID, BOOL *pbSendEnabled, BOOL *pbRecvEnabled)
{
	int index;
	int size = sizeof(g_CodecPrefTable)/sizeof(CODECPREFROW);

	for (index = 0; index < size; index++)
	{
		if (g_CodecPrefTable[index].wFormatTag == wFormatTag)
		{
			// does bandwidth limit the use of this codec  ?
			if (uBandwidthID < g_CodecPrefTable[index].wMinBW)
			{
				*pbSendEnabled = FALSE;
				*pbRecvEnabled = FALSE;
				return;
			}

			*pbRecvEnabled = TRUE;  // all codecs can decode on 486

			if ((cpu_family <= 4) &&
             (CODEC_DISABLED == g_CodecPrefTable[index].wOrder486))
			{
				*pbSendEnabled = FALSE;
			}

			// otherwise, the codec can be used for sending and receiving
			else
			{
				*pbSendEnabled = TRUE;
			}
			return;
		}
	}

	WARNING_OUT(("Audiocpl.cpp:IsCodecDisabled - Unknown Codec!"));

	// it may be unknown, but enable it anyway
	*pbSendEnabled = TRUE;
	*pbRecvEnabled = TRUE;
	return;
}

static int GetCodecPrefOrder(WORD wFormatTag, int cpu_family)
{
	int index;
	int size = sizeof(g_CodecPrefTable)/sizeof(CODECPREFROW);

	for (index = 0; index < size; index++)
	{
		if (g_CodecPrefTable[index].wFormatTag == wFormatTag)
		{
			if (cpu_family > 4)
			{
				return g_CodecPrefTable[index].wOrder586;
			}
			else
			{
				return g_CodecPrefTable[index].wOrder486;
			}
		}
	}

	WARNING_OUT(("Audiocpl.cpp:GetCodecPrefOrder - Unknown Codec!"));

	// this will put the codec at the bottom of the list
	return CODEC_UNKNOWN;

}

// called by the sort routine that is within ChooseCodecByBW()
// returns -1 if v1 is more prefered.  +1 if v2 is more preferred over
// v1.  Returns 0 on tie.
static int codec_compare(const void *v1, const void *v2, int nCpuFamily)
{
	PBASIC_AUDCAP_INFO pCap1, pCap2;

	pCap1 = (PBASIC_AUDCAP_INFO)v1;
	pCap2 = (PBASIC_AUDCAP_INFO)v2;
	int pref1, pref2;

	// get preference order
	// if we can't send with this codec, we compare it as disabled
	// so that it appears on the bottom of the Codec Selection UI list
	if (pCap1->bSendEnabled == TRUE)
		pref1 = GetCodecPrefOrder(pCap1->wFormatTag, nCpuFamily);
	else
		pref1 = CODEC_DISABLED;

	if (pCap2->bSendEnabled == TRUE)
		pref2 = GetCodecPrefOrder(pCap2->wFormatTag, nCpuFamily);
	else
		pref2 = CODEC_DISABLED;

	if (pref1 < pref2)
		return -1;

	if (pref1 > pref2)
		return 1;
	
	// pref1==pref2

	// special case, G723.1 has two formats.  Higher bitrate is prefered
	if (pCap1->wFormatTag == WAVE_FORMAT_MSG723)
	{
		if (pCap1->uMaxBitrate < pCap2->uMaxBitrate)
			return 1;
		else
			return -1;
	}

	return 0;

}

BOOL ChooseCodecByBw(UINT uBandWidthId, PCODECINFO pCodecInfo)
{
	PBASIC_AUDCAP_INFO	pCodecCapList; // list of capabilities
#ifdef _M_IX86
	int nNormalizedSpeed;
#endif
	int nFamily;
	UINT uNumFormats, uNumDisabled = 0;
	UINT index;
	BOOL bSendEnabled, bRecvEnabled, bCompletelySorted;
	int *OrderList, ret, temp;

	//Fill out the PCodecInfo Structure
	if (!GetAppCapFormats(pCodecInfo))
		return FALSE;

	if (NULL == pCodecInfo->pCodecCapList)
		return FALSE;

	pCodecCapList = pCodecInfo->pCodecCapList;
	uNumFormats = pCodecInfo->uNumFormats;

	// figure out what type of CPU we have
#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&nFamily);
	// A Pentium with FP emumalation is assumed to be a 486
	if (TRUE == IsFloatingPointEmulated())
	{
		nFamily = 4;
	}
#else
	// assume a DEC Alpha is a really fast pentium
	nFamily=5;
#endif

	// scan once to see which codecs should be disabled
	for (index=0; index < uNumFormats; index++)
	{
		IsCodecDisabled(pCodecCapList[index].wFormatTag,
          nFamily,uBandWidthId, &bSendEnabled, &bRecvEnabled);

		pCodecCapList[index].bSendEnabled = bSendEnabled;
		pCodecCapList[index].bRecvEnabled = bRecvEnabled;
	}


	// sort the capability list based on the preference table
	OrderList = (int *)LocalAlloc(LPTR, sizeof(int)*uNumFormats);
	if (OrderList == NULL)
		return FALSE;

	for (index = 0; index < uNumFormats; index++)
	{
		OrderList[index] = index;
	}


	//  bubble sort routine
	do
	{
		bCompletelySorted = TRUE;
		for (index=0; index < (uNumFormats-1); index++)
		{

			ret = codec_compare(&pCodecCapList[OrderList[index]],
			                    &pCodecCapList[OrderList[index+1]], nFamily);
			if (ret > 0)
			{
				// swap
				temp = OrderList[index];
				OrderList[index] = OrderList[index+1];
				OrderList[index+1] = temp;
				bCompletelySorted = FALSE;
			}
		}
	} while (bCompletelySorted == FALSE);


	// set the selection index from the result of the sort
	for (index = 0; index < uNumFormats; index++)	
	{
		pCodecCapList[OrderList[index]].wSortIndex = (WORD)index;
	}

	LocalFree(OrderList);
	
	return TRUE;
}



// this is called by the audio tuning wizard
VOID SaveDefaultCodecSettings(UINT uBandWidth)
{
	CODECINFO CodecInfo;

	ZeroMemory(&CodecInfo, sizeof(CodecInfo));

	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
	re.SetValue(REGVAL_CODECCHOICE, CODECCHOICE_AUTO);

	ChooseCodecByBw(uBandWidth, &CodecInfo);
	//set the ordering
	SetAppCodecPrefs(&CodecInfo, uBandWidth);
	FreeAppCapFormats(&CodecInfo);
}


// this is called by the general property page
VOID UpdateCodecSettings(UINT uBandWidth)
{
	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
	if (re.GetNumber(REGVAL_CODECCHOICE, CODECCHOICE_AUTO) ==
		CODECCHOICE_AUTO)
	{
		CODECINFO CodecInfo;

		ZeroMemory(&CodecInfo, sizeof(CodecInfo));

		ChooseCodecByBw(uBandWidth, &CodecInfo);
		//set the ordering
		SetAppCodecPrefs(&CodecInfo, uBandWidth);
		FreeAppCapFormats(&CodecInfo);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audiolvl.h ===
#ifndef _AUDIOLEVEL_H
#define _AUDIOLEVEL_H

#include "AudioCtl.h"
#include "imsconf3.h"

#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open

const int g_nAudLevelTotalHeight =	30;
const int g_nAudLevelMinWidth = 150;

// CAudioLevel encapsulates the rebar band for the "signal level"
// display (and mute buttons)



class CAudioLevel : public CAudioEvent
{
public:
	CAudioLevel(CAudioControl *);
	~CAudioLevel();

	BOOL Create(HWND hwndParent);
	BOOL OnTimer(WPARAM wTimerId);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	BOOL ShiftFocus(HWND hwndCur, BOOL fForward);
	BOOL IsChildWindow(HWND hwnd);
	BOOL OnMuteChange(BOOL fSpeaker, BOOL fMute);
	BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plRet);
	BOOL OnScroll(WPARAM wParam, LPARAM lParam);
	BOOL OnLevelChange(BOOL fSpeaker, DWORD dwVolume);
	BOOL OnDeviceChanged(void);
	BOOL OnDeviceStatusChanged(BOOL fSpeaker, UINT uEvent, UINT uSubCode);


	BOOL OnPaint(PAINTSTRUCT *ps);
	BOOL PaintChannel(BOOL fSpeaker, HDC hdc=NULL);
	BOOL PaintIcons(HDC hdc);

	BOOL Resize(int nLeft, int nTop, int nWidth, int nHeight);
	BOOL Show(BOOL bVisible);

	BOOL CreateBrushes();
	BOOL ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);


private:

	HWND m_hwndParent;
	HWND m_hwndParentParent; // m_hwndParent's parent (rebar frame)

	HWND		m_hwndMicTrack;
	HWND		m_hwndMicTrackTT;
	HWND		m_hwndSpkTrack;
	HWND		m_hwndSpkTrackTT;

	HICON m_hIconSpkr;
	UINT m_uIconSpkrID;

	HICON m_hIconMic;
	UINT m_uIconMicID;

	HWND m_hwndChkbRecMute;
	HWND m_hwndChkbSpkMute;
	HWND m_hwndChkbRecMuteTT;
	HWND m_hwndChkbSpkMuteTT;

	CAudioControl *m_pAudioControl;

	RECT m_rect;
	BOOL m_fVisible;
	BOOL m_fMicTrkVisible;
	BOOL m_fSpkTrkVisible;

	RECT m_rcChannelSpk;     // window area of the signal level
	RECT m_rcChannelMic;     // window area of the signal level

	DWORD m_dwMicTrackPos, m_dwSpkTrackPos;  // trackbar thumb positions
	DWORD m_dwMicLvl, m_dwSpkLvl;            // signal level position

	HBRUSH m_hGreyBrush;  // background
	HBRUSH m_hRedBrush, m_hYellowBrush, m_hGreenBrush, m_hBlackBrush;
	HPEN   m_hHiLitePen, m_hShadowPen, m_hDkShadowPen, m_hLitePen;

	BOOL GetIconArea(BOOL fSpeaker, RECT *pRect);


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audiowiz.h ===
#ifndef _AUDIOWIZ_H
#define _AUDIOWIZ_H

//for uOptions in wizard calls
#define RUNDUE_CARDCHANGE		0x00000001
#define RUNDUE_NEVERBEFORE		0x00000002
#define RUNDUE_USERINVOKED		0x00000003

#define STARTWITH_BACK			0x10000000
#define ENDWITH_NEXT			0x20000000

//card capabilities
#define 	SOUNDCARD_NONE				0x00000000
#define 	SOUNDCARD_PRESENT			0x00000001
#define		SOUNDCARD_FULLDUPLEX		0x00000002
#define		SOUNDCARD_HAVEAGC			0x00000004
#define		SOUNDCARD_HAVERECVOLCNTRL	0x00000008
#define		SOUNDCARD_DIRECTSOUND		0x00000010

#define		MASKOFFFULLDUPLEX(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_FULLDUPLEX))
#define		MASKOFFHAVEAGC(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_HAVEAGC))
#define		MASKOFFHAVERECVOLCNTRL(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_HAVERECVOLCNTRL))
#define		ISSOUNDCARDPRESENT(SoundCap)	(SoundCap & SOUNDCARD_PRESENT)
#define 	ISSOUNDCARDFULLDUPLEX(SoundCap)	(SoundCap & SOUNDCARD_FULLDUPLEX)
#define		DOESSOUNDCARDHAVEAGC(SoundCap)	(SoundCap & SOUNDCARD_HAVEAGC)
#define 	DOESSOUNDCARDHAVERECVOLCNTRL(SoundCap) (SoundCap & SOUNDCARD_HAVERECVOLCNTRL)
#define 	ISDIRECTSOUNDAVAILABLE(SoundCap) (SoundCap & SOUNDCARD_DIRECTSOUND)

#pragma warning (disable:4200)
typedef struct _WIZCONFIG{
	BOOL	fCancel;	//if a dialog was cancelled, this will be set
	UINT	uFlags;		//the higher order WORD specifying the config of this dialog
	DWORD	dwCustomDataSize;
	BYTE	pCustomData[];
}WIZCONFIG, *PWIZCONFIG;
#pragma warning (default:4200)


#define AUDIOWIZ_NOCHANGES			0x00000000
#define CALIBVOL_CHANGED			0x00000001
#define SOUNDCARDCAPS_CHANGED		0x00000002
#define CODECPOWER_CHANGED			0x00000004
#define TYPBANDWIDTH_CHANGED		0x00000008
#define SOUNDCARD_CHANGED			0x00000010
#define SPEAKERVOL_CHANGED			0x00000020

#define	MASKOFFCALIBVOL_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ CALIBVOL_CHANGED))
#define	MASKOFFSOUNDCARDCAPS_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ SOUNDCARDCAPS_CHANGED))
#define	MASKOFFCODECPOWER_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ CODECPOWER_CHANGED))
#define	MASKOFFTYPBANDWIDTH_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ TYPBANDWIDTH_CHANGED))
#define	MASKOFFSOUNDCARD_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ SOUNDCARD_CHANGED))

typedef struct _AUDIOWIZOUTPUT{
	UINT	uChanged;
	UINT	uValid;
	UINT	uSoundCardCaps;
	UINT	uCalibratedVol;
	UINT	uTypBandWidth;
	UINT	uWaveInDevId;
	UINT	uWaveOutDevId;
	TCHAR	szWaveInDevName[MAXPNAMELEN];
	TCHAR	szWaveOutDevName[MAXPNAMELEN];
} AUDIOWIZOUTPUT, *PAUDIOWIZOUTPUT;
					
//for now set uDevId to WAVE_MAPPER - later that will allow user to
//select the device.
//uOptions-rundue_userinvoked brings up just the calibration pages
//uOptions-rundue_cardchange or rundue_neverbefore also invoked full duplex check pages.

BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,LPUINT lpuNumPages);

void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages,
	PWIZCONFIG pWizConfig,PAUDIOWIZOUTPUT pAudioWizOut);

// Global flag keeps setting that changed for windows msg broadcast
INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

VOID CmdAudioCalibWizard(HWND hwnd);

#endif	//#ifndef _AUDIOWIZ_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\audiolvl.cpp ===
#include "precomp.h"
#include "resource.h"
#include "AudioLvl.h"



static const int g_nAudIconWidth   = 16;
static const int g_nAudIconHeight  = 16;
static const int g_nAudChkbWidth   = 13;
static const int g_nAudChkbHeight  = 13;
static const int g_nAudChkbXMargin =  13;
static const int g_nAudChkbYMargin = 12;

static const int g_nAudIconXMargin = g_nAudChkbXMargin + g_nAudChkbWidth + 3;
static const int g_nAudIconYMargin = 10;

static const int g_nAudMeterXMargin = g_nAudIconXMargin + g_nAudIconWidth + 5;
static const int g_nAudMeterHeight = 7;
static const int g_nAudMeterYMargin = g_nAudIconYMargin + (g_nAudMeterHeight/2);

static const int g_nAudMeterRightMargin = 5; // 5 pixels from end

static const int g_nAudTrkRangeMin = 0;
static const int g_nAudTrkRangeMax = 99;
static const int g_nAudTrkRangeSeg = 0xFFFF / g_nAudTrkRangeMax;
static const int g_nAudTrkTickFreq =	20;

static const int g_nAudTrkRightGap =	3;
static const int g_nAudTrkXMargin = g_nAudIconXMargin + g_nAudIconWidth + 5;
static const int g_nAudTrkYMargin =	2;
static const int g_nAudTrkHeight =	25;
static const int g_nAudTrkMinWidth = 50;


static const int RECTANGLE_WIDTH = 10;
static const int RECTANGLE_LEADING = 1;


static inline WORD ScaleMixer(DWORD dwVol)
{
	// NOTE: the "+ g_nAudTrkRangeSeg - 1" provides for a correction that
	// takes place while truncating the position when we are setting the
	// volume.  See bug 1634
	return (((LOWORD(dwVol) + g_nAudTrkRangeSeg - 1) *
		g_nAudTrkRangeMax) / 0xFFFF);
}



CAudioLevel::CAudioLevel(CAudioControl *pAudioControl) :
m_hwndParent(NULL),
m_hwndMicTrack(NULL),
m_hwndMicTrackTT(NULL),
m_hwndSpkTrack(NULL),
m_hwndSpkTrackTT(NULL),
m_hIconMic(NULL),
m_hIconSpkr(NULL),
m_hwndChkbRecMute(NULL),
m_hwndChkbSpkMute(NULL),
m_hwndChkbRecMuteTT(NULL),
m_hwndChkbSpkMuteTT(NULL),
m_fVisible(FALSE),
m_fMicTrkVisible(TRUE),
m_fSpkTrkVisible(TRUE),


m_dwMicTrackPos(0xFFFFFFFF),
m_dwSpkTrackPos(0xFFFFFFFF),
m_dwMicLvl(0),
m_dwSpkLvl(0),

m_hGreyBrush(NULL), m_hBlackBrush(NULL), m_hRedBrush(NULL),
m_hGreenBrush(NULL), m_hYellowBrush(NULL), m_hHiLitePen(NULL),
m_hShadowPen(NULL), m_hDkShadowPen(NULL), m_hLitePen(NULL)
{

	ClearStruct(&m_rect);
	m_pAudioControl = pAudioControl;


	// load icons

	m_hIconSpkr = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(IDI_SPKEMPTY),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	m_hIconMic = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(IDI_MICEMPTY),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	// create the brushes used for painting the signal level
	CreateBrushes();

}

CAudioLevel::~CAudioLevel()
{
	if (m_hGreyBrush)
		DeleteObject(m_hGreyBrush);
	if (m_hRedBrush)
		DeleteObject(m_hRedBrush);
	if (m_hYellowBrush)
		DeleteObject(m_hYellowBrush);
	if (m_hGreenBrush)
		DeleteObject(m_hGreenBrush);
	if (m_hBlackBrush)
		DeleteObject(m_hBlackBrush);

	if (m_hHiLitePen)
		DeleteObject(m_hHiLitePen);
	if (m_hDkShadowPen)
		DeleteObject(m_hDkShadowPen);
	if (m_hShadowPen)
		DeleteObject(m_hShadowPen);
	if (m_hLitePen)
		DeleteObject(m_hLitePen);

}




CAudioLevel::Create(HWND hwndParent)
{
	BOOL fCanSetRecVolume, fCanSetSpkVolume;
	BOOL fCheck;

	m_hwndParent = hwndParent;
	m_hwndParentParent = GetParent(hwndParent);


	fCanSetRecVolume = m_pAudioControl->CanSetRecorderVolume();
	fCanSetSpkVolume = m_pAudioControl->CanSetSpeakerVolume();


	// create the mute check box for microphone
	m_hwndChkbRecMute = ::CreateWindow(	_TEXT("BUTTON"),
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS |
											BS_AUTOCHECKBOX,
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) IDM_MUTE_MICROPHONE,
										GetInstanceHandle(),
										NULL);

	if (m_hwndChkbRecMute != NULL)
	{
		// mute is initially off
		fCheck = !(m_pAudioControl->IsRecMuted());
		::SendMessage(m_hwndChkbRecMute, BM_SETCHECK, fCheck, 0);

		// create the tool tip
		m_hwndChkbRecMuteTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndChkbRecMuteTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndChkbRecMute;
			ti.lpszText = (LPTSTR) IDS_AUDIO_REC_MUTE_TT;

			::SendMessage(	m_hwndChkbRecMuteTT, TTM_ADDTOOL, 0,
							(LPARAM) (LPTOOLINFO) &ti);
		}

	}


	// create the mute check box for speaker
	m_hwndChkbSpkMute = ::CreateWindow(	_TEXT("BUTTON"),
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS
											| BS_AUTOCHECKBOX,
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) IDM_MUTE_SPEAKER,
										GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndChkbSpkMute)
	{
		// set appropriate mute status in microphone's mute check box
		fCheck = !(m_pAudioControl->IsSpkMuted());

		// Mute is off - so check it
		::SendMessage(m_hwndChkbSpkMute, BM_SETCHECK, fCheck, 0);

		// create the tool tip
		m_hwndChkbSpkMuteTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndChkbSpkMuteTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndChkbSpkMute;
			ti.lpszText = (LPTSTR) IDS_AUDIO_SPK_MUTE_TT;

			::SendMessage(	m_hwndChkbSpkMuteTT, TTM_ADDTOOL, 0,
							(LPARAM) (LPTOOLINFO) &ti);
		}


	}

	// create the mic level trackbar:
	m_hwndMicTrack = ::CreateWindowEx(	0L,
										TRACKBAR_CLASS,
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS
											| TBS_HORZ | TBS_NOTICKS | TBS_BOTH
											| (fCanSetRecVolume ? 0 : WS_DISABLED),
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) ID_AUDIODLG_MIC_TRACK,
										::GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndMicTrack)
	{
		::SendMessage(	m_hwndMicTrack,
						TBM_SETRANGE,
						FALSE,
						MAKELONG(g_nAudTrkRangeMin, g_nAudTrkRangeMax));
		
		::SendMessage(	m_hwndMicTrack,
						TBM_SETTICFREQ,
						g_nAudTrkTickFreq,
						g_nAudTrkRangeMin);

		WORD wPos = (g_nAudTrkRangeMax - g_nAudTrkRangeMin) / 2;
		if (fCanSetRecVolume)
		{
			wPos = ScaleMixer(m_pAudioControl->GetRecorderVolume());
		}
		::SendMessage(	m_hwndMicTrack,
						TBM_SETPOS,
						TRUE,
						wPos);

		m_hwndMicTrackTT = CreateWindowEx(	0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndMicTrackTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndMicTrack;
			ti.lpszText = (LPTSTR) IDS_AUDIO_MIC_TRACK_TT;

			::SendMessage(m_hwndMicTrackTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
		}
	}



	// create the speaker level trackbar:
	m_hwndSpkTrack = ::CreateWindowEx(	0L,
										TRACKBAR_CLASS,
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS 
											| TBS_HORZ | TBS_NOTICKS | TBS_BOTH
											| (fCanSetSpkVolume ? 0 : WS_DISABLED),
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) ID_AUDIODLG_SPKR_TRACK,
										::GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndSpkTrack)
	{
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETRANGE,
						FALSE,
						MAKELONG(g_nAudTrkRangeMin, g_nAudTrkRangeMax));
		
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETTICFREQ,
						g_nAudTrkTickFreq,
						g_nAudTrkRangeMin);

		WORD wPos = (g_nAudTrkRangeMax - g_nAudTrkRangeMin) / 2;
		if (fCanSetSpkVolume)
		{
			wPos = ScaleMixer(m_pAudioControl->GetSpeakerVolume());
		}
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETPOS,
						TRUE,
						wPos);

		m_hwndSpkTrackTT = CreateWindowEx(	0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndSpkTrackTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndSpkTrack;
			ti.lpszText = (LPTSTR) IDS_AUDIO_SPK_TRACK_TT;

			::SendMessage(m_hwndSpkTrackTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
		}

	}





	return TRUE;
}


BOOL CAudioLevel::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CreateBrushes();
	if (NULL != m_hwndMicTrack)
	{
		::SendMessage(m_hwndMicTrack, uMsg, wParam, lParam);
	}
	if (NULL != m_hwndSpkTrack)
	{
		::SendMessage(m_hwndSpkTrack, uMsg, wParam, lParam);
	}
	return TRUE;
}

BOOL CAudioLevel::CreateBrushes()
{
	// the background color may change on us!
	COLORREF GreyColor = GetSysColor(COLOR_3DFACE);
	COLORREF BlackColor = GetSysColor(COLOR_BTNTEXT);
	const COLORREF RedColor = RGB(255,0,0);
	const COLORREF YellowColor = RGB(255,255,0);
	const COLORREF GreenColor = RGB(0,255,0);

	COLORREF ShadowColor = GetSysColor(COLOR_3DSHADOW);
	COLORREF HiLiteColor = GetSysColor(COLOR_3DHIGHLIGHT);
	COLORREF LiteColor = GetSysColor(COLOR_3DLIGHT);
	COLORREF DkShadowColor = GetSysColor(COLOR_3DDKSHADOW);

	if (m_hGreyBrush)
	{
		DeleteObject(m_hGreyBrush);
	}
	m_hGreyBrush = CreateSolidBrush(GreyColor);

	if (m_hBlackBrush)
	{
		DeleteObject(m_hBlackBrush);
	}
	m_hBlackBrush = CreateSolidBrush(BlackColor);

	if (m_hHiLitePen)
	{
		DeleteObject(m_hHiLitePen);
	}
	m_hHiLitePen = CreatePen(PS_SOLID, 0, HiLiteColor);

	if (m_hLitePen)
	{
		DeleteObject(m_hLitePen);
	}
	m_hLitePen = CreatePen(PS_SOLID, 0, LiteColor);

	if (m_hDkShadowPen)
	{
		DeleteObject(m_hDkShadowPen);
	}
	m_hDkShadowPen = CreatePen(PS_SOLID, 0, DkShadowColor);

	if (m_hShadowPen)
	{
		DeleteObject(m_hShadowPen);
	}
	m_hShadowPen = CreatePen(PS_SOLID, 0, ShadowColor);

	// red, yellow, green will never change
	if (!m_hRedBrush)
		m_hRedBrush = CreateSolidBrush (RedColor);

	if (!m_hGreenBrush)
		m_hGreenBrush = CreateSolidBrush(GreenColor);

	if (!m_hYellowBrush)
		m_hYellowBrush = CreateSolidBrush(YellowColor);

	return TRUE;


}

BOOL CAudioLevel::OnCommand(WPARAM wParam, LPARAM lParam)
{
	LRESULT lCheck;
	BOOL    fSpeaker;

	switch (LOWORD(wParam))
	{
	default:
		return FALSE;

	case IDM_MUTE_MICROPHONE_ACCEL:
		lCheck = BST_CHECKED;
		fSpeaker = FALSE;
		break;

	case IDM_MUTE_MICROPHONE:
		lCheck = BST_UNCHECKED;
		fSpeaker = FALSE;
		break;

	case IDM_MUTE_SPEAKER_ACCEL:
		lCheck = BST_CHECKED;
		fSpeaker = TRUE;
		break;
	
	case IDM_MUTE_SPEAKER:
		lCheck = BST_UNCHECKED;
		fSpeaker = TRUE;
		break;
	}

	BOOL fMute = (lCheck == ::SendMessage(
		fSpeaker ? m_hwndChkbSpkMute : m_hwndChkbRecMute,
		BM_GETCHECK, 0, 0));

	m_pAudioControl->MuteAudio(fSpeaker, fMute);
	return TRUE;
}


BOOL CAudioLevel::ShiftFocus(HWND hwndCur, BOOL fForward)
{
	BOOL bRet = FALSE;
	HWND aHwnds[] = {m_hwndChkbSpkMute,m_hwndSpkTrack,m_hwndChkbRecMute,m_hwndMicTrack};
	int nSizeArray = ARRAY_ELEMENTS(aHwnds);
	int nIndex, nSelect;
	HWND hwndNewFocus=NULL;

	if (m_fVisible)
	{
		if (hwndCur == NULL)
		{
			hwndNewFocus = m_hwndSpkTrack;
		}
		else
		{
			for (nIndex = 0; nIndex < nSizeArray; nIndex++)
			{
				if (aHwnds[nIndex] == hwndCur)
				{
					nSelect = (nIndex + (fForward ? 1 : -1)) % nSizeArray;

					if (nSelect < 0)
						nSelect += nSizeArray;

					hwndNewFocus = aHwnds[nSelect];
					break;
				}
			}
		}

		if (hwndNewFocus)
		{
			SetFocus(hwndNewFocus);
			bRet = TRUE;
		}
	}

	return bRet;
}

BOOL CAudioLevel::IsChildWindow(HWND hwnd)
{

	if (hwnd)
	{
		if ((hwnd == m_hwndSpkTrack) || (hwnd == m_hwndMicTrack) ||
			(hwnd == m_hwndChkbRecMute) || (hwnd == m_hwndChkbSpkMute))
		{
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CAudioLevel::OnMuteChange(BOOL fSpeaker, BOOL fMute)
{
	SendMessage(fSpeaker ? m_hwndChkbSpkMute : m_hwndChkbRecMute,
		BM_SETCHECK, fMute ? BST_UNCHECKED : BST_CHECKED, 0);

	return TRUE;
}




BOOL CAudioLevel::OnPaint(PAINTSTRUCT* pps)
{
	if (m_fVisible)
	{
		ASSERT(pps);
		ASSERT(pps->hdc);
		PaintIcons(pps->hdc);
	}

	return TRUE;
}


BOOL CAudioLevel::PaintChannel(BOOL fSpeaker, HDC hdc)
{
	BOOL bGotDC = FALSE;
	DWORD dwVolume;
	int nVuWidth, nDiff;
	RECT rect, rectDraw;
	HBRUSH hCurrentBrush;
	HPEN hOldPen;
	int nRects;
	int nRectangleWidth;
	int nIndex;
	const int NUM_RECTANGLES_MAX = 16;
	const int NUM_RECTANGLES_MIN = 6;
	int nRectsTotal;
	bool bTransmitting;
	POINT ptOld, pt;

	if (fSpeaker)
	{
		dwVolume = LOWORD(m_dwSpkLvl);
		bTransmitting = HIWORD(m_dwSpkLvl) & SIGNAL_STATUS_TRANSMIT;
	}
	else
	{
		dwVolume = LOWORD(m_dwMicLvl);
		bTransmitting = HIWORD(m_dwMicLvl) & SIGNAL_STATUS_TRANSMIT;
	}


	if (!hdc)
	{
		if ((fSpeaker) && (m_hwndSpkTrack))
			hdc = GetDC(m_hwndSpkTrack);
		else if (m_hwndMicTrack)
			hdc = GetDC(m_hwndMicTrack);
		bGotDC = TRUE;
	}

	if (!hdc)
		return FALSE;

	// rectangle leading is 1

	if (dwVolume > 100)
		dwVolume = 100;

	if (fSpeaker)
		rect = m_rcChannelSpk;
	else
		rect = m_rcChannelMic;

	nVuWidth = rect.right - rect.left;
	if (nVuWidth < (NUM_RECTANGLES_MIN*2))
		return FALSE;


	// "rect" represents the edges of the meter's outer rectangle

	// compute the number of individual rectangles to use
	// we do the computation this way so that sizing the rebar band
	// makes the size changes consistant
	nRectsTotal = NUM_RECTANGLES_MAX;

	nRectsTotal = (nVuWidth + (g_nAudMeterHeight - 1)) / g_nAudMeterHeight;
	nRectsTotal = min(nRectsTotal, NUM_RECTANGLES_MAX);
	nRectsTotal = max(nRectsTotal, NUM_RECTANGLES_MIN);

	// nRectangleWidth - width of colored rectangle - no leading
	nRectangleWidth = ((nVuWidth-2)/nRectsTotal) - 1;

	// nVuWidth - width of entire VU meter including edges
	nVuWidth = (nRectangleWidth + 1)*nRectsTotal + 2;

	// re-adjust meter size to be an integral number of rects
	nDiff = rect.right - (rect.left + nVuWidth);
	rect.right = rect.left + nVuWidth;

	// center vu-meter across whole channel area so that the
	// slider's thumb is always covering some portion of the channel
	rect.left += (nDiff/2);
	rect.right += (nDiff/2);

	// draw the 3D frame border
	hOldPen = (HPEN) SelectObject (hdc, m_hHiLitePen);
	MoveToEx(hdc, rect.right, rect.top, &ptOld);
	LineTo(hdc, rect.right, rect.bottom);
	LineTo(hdc, rect.left-1, rect.bottom);  // -1 because LineTo stops just short of this point

	SelectObject(hdc, m_hShadowPen);
	MoveToEx(hdc, rect.left, rect.bottom-1, &pt);
	LineTo(hdc, rect.left, rect.top);
	LineTo(hdc, rect.right, rect.top);

	SelectObject(hdc, m_hDkShadowPen);
	MoveToEx(hdc, rect.left+1, rect.bottom-2, &pt);
	LineTo(hdc, rect.left+1, rect.top+1);
	LineTo(hdc, rect.right-1, rect.top+1);

	SelectObject(hdc, m_hLitePen);
	MoveToEx(hdc, rect.left+1, rect.bottom-1, &pt);
	LineTo(hdc, rect.right-1, rect.bottom-1);
	LineTo(hdc, rect.right-1, rect.top);

	SelectObject(hdc, m_hShadowPen);

	// the top and left of the meter has a 2 line border
	// the bottom and right of the meter has a 2 line border
	rectDraw.top = rect.top + 2;
	rectDraw.bottom = rect.bottom - 1 ;
	rectDraw.left = rect.left + 2;
	rectDraw.right = rectDraw.left + nRectangleWidth;


	// how many colored rectangles do we draw ?
	nRects = (dwVolume * nRectsTotal) / 100;

	// not transmitting - don't show anything
	if ((false == bTransmitting) && (false == fSpeaker))
		nRects = 0;

	// transmitting or receiving something very quiet - 
	// light up at least one rectangle
	else if ((bTransmitting) && (nRects == 0))
		nRects = 1;
	
	hCurrentBrush = m_hGreenBrush;

	for (nIndex = 0; nIndex < nRectsTotal; nIndex++)
	{
		// far left fourth of the bar is green
		// right fourth of the bar is red
		// middle is yellow
		if (nIndex > ((nRectsTotal*3)/4))
			hCurrentBrush = m_hRedBrush;
		else if (nIndex >= nRectsTotal/2)
			hCurrentBrush = m_hYellowBrush;

		if (nIndex >= nRects)
			hCurrentBrush = m_hGreyBrush;

		FillRect(hdc, &rectDraw, hCurrentBrush);

		if (nIndex != (nRectsTotal-1))
		{
			MoveToEx(hdc, rectDraw.left + nRectangleWidth, rectDraw.top, &pt);
			LineTo(hdc, rectDraw.left + nRectangleWidth, rectDraw.bottom);
		}

		rectDraw.left += nRectangleWidth + 1;  // +1 for the leading
		rectDraw.right = rectDraw.left + nRectangleWidth;
	}

	MoveToEx(hdc, ptOld.x, ptOld.y, &pt);
	SelectObject (hdc, hOldPen);

	if (bGotDC)
	{
		DeleteDC(hdc);
	}

	return TRUE;

}




BOOL CAudioLevel::OnTimer(WPARAM wTimerID)
{
	DWORD dwLevel;



	if (m_fVisible && (NULL != m_pAudioControl))
	{
		dwLevel = m_pAudioControl->GetAudioSignalLevel(FALSE /*fSpeaker*/);	// This level ranges from 0-100
		if (dwLevel != m_dwMicLvl)
		{
			m_dwMicLvl = dwLevel;			
			// HACK: SETRANGEMAX is the only way to force the slider to update itself...
			SendMessage(m_hwndMicTrack, TBM_SETRANGEMAX, TRUE, g_nAudTrkRangeMax);
		}

		dwLevel = m_pAudioControl->GetAudioSignalLevel(TRUE /*fSpeaker*/);	// This level ranges from 0-100
		if (dwLevel != m_dwSpkLvl)
		{
			m_dwSpkLvl = dwLevel;
			SendMessage(m_hwndSpkTrack, TBM_SETRANGEMAX, TRUE, g_nAudTrkRangeMax);
		}

	}

	return TRUE;
}


// returns the coordinates of where one of the icons should be drawn
BOOL CAudioLevel::GetIconArea(BOOL fSpeaker, RECT *pRect)
{
	int nIconY;
	int nLeftMic;
	int nLeftSpk;

	nIconY = (m_rect.bottom - m_rect.top - g_nAudIconHeight - 1) / 2;
	pRect->top = m_rect.top + nIconY;
	pRect->bottom = pRect->top + g_nAudIconHeight;

	if (fSpeaker)
	{
		pRect->left = m_rect.left + ((m_rect.right - m_rect.left) / 2) + g_nAudIconXMargin;
	}
	else
	{
		pRect->left = m_rect.left + g_nAudIconXMargin;
	}

	pRect->right = pRect->left + g_nAudIconWidth;

	return TRUE;
}

BOOL CAudioLevel::PaintIcons(HDC hdc)
{
	int nIconY;
	ASSERT(hdc);
	RECT rect;

	if (NULL != m_hIconMic)
	{
		GetIconArea(FALSE, &rect);

		DrawIconEx(	hdc, 
					rect.left,
					rect.top,
					m_hIconMic,
					rect.right - rect.left,
					rect.bottom - rect.top,
					0,
					NULL,
					DI_NORMAL);


	}

	if (NULL != m_hIconSpkr)
	{
		GetIconArea(TRUE, &rect);

		DrawIconEx(	hdc, 
					rect.left,
					rect.top,
					m_hIconSpkr,
					rect.right - rect.left,
					rect.bottom - rect.top,
					0,
					NULL,
					DI_NORMAL);

	}

	return TRUE;
}


BOOL CAudioLevel::OnDeviceStatusChanged(BOOL fSpeaker, UINT uEvent, UINT uSubCode)
{
	UINT uIconID;
	HICON *phIcon;
	UINT *puIconID;
	RECT rectInvalid;


	switch (uEvent)
	{
		case NM_STREAMEVENT_DEVICE_CLOSED:
		{
			uIconID = fSpeaker ? IDI_SPKEMPTY : IDI_MICEMPTY;
			break;
		}

		case NM_STREAMEVENT_DEVICE_OPENED:
		{
			uIconID = fSpeaker ? IDI_SPEAKER : IDI_MICFONE;
			break;
		}

		case NM_STREAMEVENT_DEVICE_FAILURE:
		{
			uIconID = fSpeaker ? IDI_SPKERROR : IDI_MICERROR;
			break;
		}
			
		default:
			return FALSE;
	}

	phIcon = fSpeaker ? &m_hIconSpkr : &m_hIconMic;
	puIconID = fSpeaker ? &m_uIconSpkrID : &m_uIconMicID;

	if (*puIconID == uIconID)
		return TRUE;

	*phIcon = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(uIconID),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	// invalidate the icon regions
	if (m_hwndParentParent)
	{
		RECT rect;
		GetIconArea(fSpeaker, &rect);
		::MapWindowPoints(m_hwndParent, m_hwndParentParent, (LPPOINT) &rect, 2);
		::InvalidateRect(m_hwndParentParent, &rect, TRUE /* erase bkgnd */);
		::UpdateWindow(m_hwndParentParent);
	}

	return TRUE;

}


BOOL CAudioLevel::Resize(int nLeft, int nTop, int nWidth, int nHeight)
{
	int nCBY, nTBY; // checkbox, trackbar, and Icon y positions

	// Disable redraws:
	ASSERT(m_hwndChkbRecMute && m_hwndChkbSpkMute && m_hwndMicTrack && m_hwndSpkTrack);

	if (m_fVisible)
	{
		::SendMessage(m_hwndChkbRecMute, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndChkbSpkMute, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndMicTrack, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndSpkTrack, WM_SETREDRAW, FALSE, 0);
	}
	
	m_rect.left =	nLeft;
	m_rect.top =	nTop;
	m_rect.right =	nLeft + nWidth;
	m_rect.bottom =	nTop + nHeight;

	nCBY = (m_rect.bottom - m_rect.top - g_nAudChkbHeight) / 2;
	if (nCBY < 0)
		nCBY = 0;

	// "+1" so the trackbar is better centered with the checkbox and icon
	nTBY = 	(m_rect.bottom - m_rect.top - g_nAudTrkHeight + 1) / 2;
	if (nTBY < 0)
		nTBY = 0;

	int nHalfPoint = nLeft + (nWidth / 2);

	if (NULL != m_hwndChkbRecMute)
	{
		::MoveWindow(	m_hwndChkbRecMute,
						nLeft + g_nAudChkbXMargin,
						nTop + nCBY,
						g_nAudChkbWidth,
						g_nAudChkbHeight,
						TRUE /* repaint */);
	}

	
	if (NULL != m_hwndChkbSpkMute)
	{
		::MoveWindow(	m_hwndChkbSpkMute,
						nHalfPoint + g_nAudChkbXMargin,
						nTop + nCBY,
						g_nAudChkbWidth,
						g_nAudChkbHeight,
						TRUE /* repaint */);
	}

	m_fMicTrkVisible = m_fVisible;
	if (NULL != m_hwndMicTrack)
	{
		int nMicTrkWidth = nHalfPoint - g_nAudTrkRightGap - (nLeft + g_nAudTrkXMargin);
		::MoveWindow(	m_hwndMicTrack,
						nLeft + g_nAudTrkXMargin,
						nTop + nTBY,
						nMicTrkWidth,
						g_nAudTrkHeight,
						FALSE /* don't repaint */);
		m_fMicTrkVisible = (nMicTrkWidth > g_nAudTrkMinWidth);
	}

	
	m_fSpkTrkVisible = m_fVisible;
	if (NULL != m_hwndSpkTrack)
	{
		int nSpkTrkWidth = nLeft + nWidth - g_nAudTrkRightGap
							- (nHalfPoint + g_nAudTrkXMargin);
		::MoveWindow(	m_hwndSpkTrack,
						nHalfPoint + g_nAudTrkXMargin,
						nTop + nTBY,
						nSpkTrkWidth,
						g_nAudTrkHeight,
						FALSE /* don't repaint */);
		m_fSpkTrkVisible = (nSpkTrkWidth > g_nAudTrkMinWidth);
	}



	// enable redraws
	if (m_fVisible)
	{
		::SendMessage(m_hwndChkbRecMute, WM_SETREDRAW, TRUE, 0);
		::SendMessage(m_hwndChkbSpkMute, WM_SETREDRAW, TRUE, 0);
		// Enable redraws:
		if (m_fMicTrkVisible)
		{
			::SendMessage(m_hwndMicTrack, WM_SETREDRAW, TRUE, 0);
		}
		if (m_fSpkTrkVisible)
		{
			::SendMessage(m_hwndSpkTrack, WM_SETREDRAW, TRUE, 0);
		}	
		// Force the title area to repaint:
		::InvalidateRect(m_hwndChkbRecMute, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndChkbSpkMute, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndMicTrack, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndSpkTrack, NULL, TRUE /* erase bkgnd */);

		ASSERT(m_hwndParent);
		ASSERT(m_hwndParentParent);


		RECT rctTemp = m_rect;
		::MapWindowPoints(m_hwndParent, m_hwndParentParent, (LPPOINT) &rctTemp, 2);
		::InvalidateRect(m_hwndParentParent, &rctTemp, TRUE /* erase bkgnd */);
		::UpdateWindow(m_hwndParentParent);
	}
	
	return TRUE;


}


BOOL CAudioLevel::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plRet)
{
	LPNMCUSTOMDRAW pCustomDraw;
	BOOL bRet = FALSE, fSpeaker;
	RECT *pChannelRect;

	*plRet = 0;

	fSpeaker = (wParam == ID_AUDIODLG_SPKR_TRACK);

	if (fSpeaker)
	{
		pChannelRect = &m_rcChannelSpk;
	}
	else
	{
		pChannelRect = &m_rcChannelMic;
	}

	pCustomDraw = (LPNMCUSTOMDRAW)lParam;

	switch (pCustomDraw->dwDrawStage)
	{
		case CDDS_PREPAINT:
			bRet = TRUE;
			*plRet = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
			break;

		case CDDS_ITEMPREPAINT:
			if (pCustomDraw->dwItemSpec == TBCD_CHANNEL)
			{
				*plRet = CDRF_SKIPDEFAULT;
				bRet  = TRUE;

				pCustomDraw->rc.top -= 2;
				pCustomDraw->rc.bottom += 2;

				*pChannelRect = pCustomDraw->rc;

				PaintChannel(fSpeaker, pCustomDraw->hdc);
			}
			break;


		default:
			break;

	}

	return bRet;


}


BOOL CAudioLevel::OnScroll(WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;

	if ((HWND) lParam == m_hwndMicTrack)
	{
		DWORD dwCurMicTrackPos = ::SendMessage((HWND) lParam, TBM_GETPOS, 0, 0);
		if (m_dwMicTrackPos != dwCurMicTrackPos)
		{
			m_dwMicTrackPos = dwCurMicTrackPos;
			m_pAudioControl->SetRecorderVolume(
				(m_dwMicTrackPos * 0xFFFF) / g_nAudTrkRangeMax);
		}

		bRet = TRUE;
	}
	else if ((HWND) lParam == m_hwndSpkTrack)
	{
		DWORD dwCurSpkTrackPos = ::SendMessage((HWND) lParam, TBM_GETPOS, 0, 0);
		if (m_dwSpkTrackPos != dwCurSpkTrackPos)
		{
			m_dwSpkTrackPos = dwCurSpkTrackPos;
			m_pAudioControl->SetSpeakerVolume(
				(m_dwSpkTrackPos * 0xFFFF) / g_nAudTrkRangeMax);
		}

		bRet = TRUE;
	}

	return bRet;
}

BOOL CAudioLevel::OnLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	if (fSpeaker)
	{
		if (NULL != m_hwndSpkTrack)
		{
			DWORD dwTrackPos = ScaleMixer(dwVolume);
			
			if (m_dwSpkTrackPos != dwTrackPos)
			{
				m_dwSpkTrackPos = dwTrackPos;
				TRACE_OUT(("Setting Spk Volume to %d", m_dwSpkTrackPos));
				::SendMessage(	m_hwndSpkTrack,
								TBM_SETPOS,
								TRUE,
								m_dwSpkTrackPos);
			}
		}
	}
	else
	{
		if (NULL != m_hwndMicTrack)
		{
			DWORD dwTrackPos = ScaleMixer(dwVolume);
			
			if (m_dwMicTrackPos != dwTrackPos)
			{
				m_dwMicTrackPos = dwTrackPos;
				TRACE_OUT(("Setting Mic Volume to %d", m_dwMicTrackPos));
				::SendMessage(	m_hwndMicTrack,
								TBM_SETPOS,
								TRUE,
								m_dwMicTrackPos);
			}
		}
	}

	return TRUE;
}

BOOL CAudioLevel::OnDeviceChanged(void)
{
	ASSERT(m_pAudioControl);

	EnableWindow(m_hwndMicTrack, m_pAudioControl->CanSetRecorderVolume());
	EnableWindow(m_hwndSpkTrack, m_pAudioControl->CanSetSpeakerVolume());
	return TRUE;
}



BOOL CAudioLevel::Show(BOOL fVisible)
{
    m_fVisible = fVisible;
	if (m_fVisible)
	{
		// Start mic sensitivity timer:
		::SetTimer(m_hwndParent, AUDIODLG_MIC_TIMER, AUDIODLG_MIC_TIMER_PERIOD, NULL);
	}
	else
	{
		// Stop mic sensitivity timer:
		::KillTimer(m_hwndParent, AUDIODLG_MIC_TIMER);
	}

    // Hide or show all windows:
	if (NULL != m_hwndChkbRecMute)
	{
		::ShowWindow(m_hwndChkbRecMute, fVisible ? SW_SHOW : SW_HIDE);
	}
	if (NULL != m_hwndChkbSpkMute)
	{
		::ShowWindow(m_hwndChkbSpkMute, fVisible ? SW_SHOW : SW_HIDE);
	}

	if (NULL != m_hwndMicTrack)
	{
		::ShowWindow(m_hwndMicTrack, (fVisible && m_fMicTrkVisible) ? SW_SHOW : SW_HIDE);
	}
	if (NULL != m_hwndSpkTrack)
	{
		::ShowWindow(m_hwndSpkTrack, (fVisible && m_fSpkTrkVisible) ? SW_SHOW : SW_HIDE);
	}


	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\autoconf.h ===
#ifndef _AutoConf_h_
#define _AutoConf_h_

#define AUTOCONF_CONTEXT_OPENURL   1
#define AUTOCONF_CONTEXT_READFILEX 2

class CAutoConf
{
public:
	static void DoIt();

private:
	LPTSTR		m_szServer;
	HINTERNET   m_hInternet;
	HINTERNET	m_hOpenUrl;
	HANDLE		m_hFile;
	HINF		m_hInf;
	TCHAR		m_szFile[ MAX_PATH ];

	HANDLE		m_hEvent;
	DWORD		m_dwTimeOut;
	DWORD		m_dwGrab;

private:
	CAutoConf( LPTSTR szServer );
	~CAutoConf();

private:
	BOOL OpenConnection();
	BOOL ParseFile();
	BOOL GetFile();
	void CloseInternet();
	BOOL GrabData();
	BOOL QueryData();

private:
	static VOID CALLBACK InetCallback( HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus,
    LPVOID lpvStatusInformation, DWORD dwStatusInformationLength );
};

#endif // _AutoConf_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\autoconf.cpp ===
#include "precomp.h"
#include "resource.h"
#include "pfnwininet.h"
#include "pfnsetupapi.h"
#include "AutoConf.h"
#include "ConfUtil.h"

// File level globals
CAutoConf * g_pAutoConf = NULL;

void CAutoConf::DoIt( void )
{
	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);
	if( !re.GetNumber(REGVAL_AUTOCONF_USE, DEFAULT_AUTOCONF_USE ) )
	{
		TRACE_OUT(( TEXT("AutoConf: Not using autoconfiguration")));
		return;
	}

	LPTSTR szAutoConfServer = re.GetString( REGVAL_AUTOCONF_CONFIGFILE );

	if( NULL == szAutoConfServer )
	{
		WARNING_OUT(( TEXT("AutoConf: AutoConf server is unset") ));
		DisplayErrMsg( IDS_AUTOCONF_SERVERNAME_MISSING );
		return;
	}

	g_pAutoConf = new CAutoConf( szAutoConfServer );
	ASSERT( g_pAutoConf );

	if( !g_pAutoConf->OpenConnection() )
	{
		WARNING_OUT(( TEXT("AutoConf: Connect to net failed") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}
	
	if( NULL == g_pAutoConf->m_hOpenUrl )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->m_hOpenUrl = NULL") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FALSE == g_pAutoConf->GetFile() )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->GetFile() == FALSE") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FALSE == g_pAutoConf->QueryData() )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->QueryData() == FALSE") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FAILED( SETUPAPI::Init() ) )
	{
		WARNING_OUT(( TEXT("AutoConf: Setupapi's failed to init") ));
		DisplayErrMsg( IDS_AUTOCONF_NEED_SETUPAPIS );
		goto cleanup;
	}

	if( !g_pAutoConf->ParseFile() )
	{
		WARNING_OUT(( TEXT("AutoConf: Could not parse inf file") ));
		DisplayErrMsg( IDS_AUTOCONF_PARSE_ERROR );
		goto cleanup;
	}
	TRACE_OUT(( TEXT("AutoConf: FILE PARSED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!") ));
	
cleanup:
	delete g_pAutoConf;
	return;
}

CAutoConf::CAutoConf( LPTSTR szServer )
	: m_szServer( szServer ), m_hInternet( NULL ), m_hOpenUrl( NULL ), m_dwGrab( 0 ),
		m_hInf( NULL ), m_hFile( INVALID_HANDLE_VALUE ), m_hEvent( NULL )
{
	ZeroMemory( m_szFile, CCHMAX( m_szFile ) );
	m_hEvent = CreateEvent( NULL, TRUE, FALSE, TEXT( "NMAutoConf_WaitEvent" ) );
	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);
	m_dwTimeOut = re.GetNumber(REGVAL_AUTOCONF_TIMEOUT, DEFAULT_AUTOCONF_TIMEOUT );

}

CAutoConf::~CAutoConf() 
{
	CloseInternet();
	
	if( INVALID_HANDLE_VALUE != m_hFile )
	{
		CloseHandle( m_hFile );
	}
	
	DeleteFile( m_szFile );

	if( NULL != m_hInf )
	{
		SETUPAPI::SetupCloseInfFile( m_hInf );
	}

	//WININET::DeInit();
	//SETUPAPI::DeInit();
}

BOOL CAutoConf::OpenConnection()
{
//	ASSERT( phInternet );

	if( FAILED( WININET::Init() ) )
	{
		WARNING_OUT(( TEXT("AutoConf: WININET::Init failed") ));
		DisplayErrMsg( IDS_AUTOCONF_NO_WININET );
		return FALSE;
	}

	ASSERT( NULL != m_szServer );
	m_hInternet = WININET::InternetOpen( TEXT("NetMeeting"),
											INTERNET_OPEN_TYPE_DIRECT,
											NULL,
											NULL,
											INTERNET_FLAG_ASYNC  );
	if( NULL == m_hInternet )
	{
		WARNING_OUT(( TEXT( "AutoConf: InternetOpen failed" ) ));
		return FALSE;
	}

	if( INTERNET_INVALID_STATUS_CALLBACK ==
		WININET::InternetSetStatusCallback( m_hInternet,
			(INTERNET_STATUS_CALLBACK) CAutoConf::InetCallback ) )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetSetStatusCallback failed") ));
		return FALSE;
	}

	m_hOpenUrl = WININET::InternetOpenUrl( m_hInternet,
								m_szServer,
								NULL,
								0,
								INTERNET_FLAG_KEEP_CONNECTION |
								INTERNET_FLAG_RELOAD,
								AUTOCONF_CONTEXT_OPENURL );
	if( NULL == m_hOpenUrl && ERROR_IO_PENDING != GetLastError() )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetOpenUrl failed") ));
		return FALSE;
	}

	if( WAIT_FAILED == WaitForSingleObject( m_hEvent, m_dwTimeOut ) )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetOpenUrl wait for handle failed") ));
		return FALSE;
	}

	return TRUE;
}

BOOL CAutoConf::ParseFile()
{
	LPTSTR lstrInstallSection = TEXT("NetMtg.Install.NMRK");

	m_hInf = SETUPAPI::SetupOpenInfFile( m_szFile, // name of the INF to open
										NULL, // optional, the class of the INF file
										INF_STYLE_WIN4,  // specifies the style of the INF file
										NULL  // optional, receives error information
									); 

	if( INVALID_HANDLE_VALUE == m_hInf )
	{
		return false;
	}

	return SETUPAPI::SetupInstallFromInfSection(
							  NULL,            // optional, handle of a parent window
							  m_hInf,        // handle to the INF file
							  lstrInstallSection,    // name of the Install section
							  SPINST_REGISTRY ,            // which lines to install from section
							  NULL,  // optional, key for registry installs
							  NULL, // optional, path for source files
							  0,        // optional, specifies copy behavior
							  NULL,  // optional, specifies callback routine
							  NULL,         // optional, callback routine context
							  NULL,  // optional, device information set
							  NULL	 // optional, device info structure
									);
}


BOOL CAutoConf::GetFile()
{
//	ASSERT( INVALID_HANDLE_VALUE == m_hFile );

	TCHAR szPath[ MAX_PATH ];
	
	GetTempPath(  CCHMAX( szPath ),  // size, in characters, of the buffer
				  szPath       // pointer to buffer for temp. path
				);

	GetTempFileName(  szPath,  // pointer to directory name for temporary file
					  TEXT("NMA"),  // pointer to filename prefix
					  0,        // number used to create temporary filename
					  m_szFile    // pointer to buffer that receives the new filename
					);

	m_hFile = CreateFile( m_szFile,
						GENERIC_READ | GENERIC_WRITE,
						0,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_TEMPORARY /*| FILE_FLAG_DELETE_ON_CLOSE*/,
						NULL );

	if( INVALID_HANDLE_VALUE == m_hFile )
	{
		WARNING_OUT(( TEXT("AutoConf: AutoConfGetFile returned INVALID_HANDLE_VALUE") ));
		return FALSE;
	}

	return TRUE;
}

BOOL CAutoConf::QueryData()
{
 	ASSERT( NULL != m_hOpenUrl );

	m_dwGrab = 0;
	if (!WININET::InternetQueryDataAvailable( m_hOpenUrl,
											&m_dwGrab,
											0,
											0 ) )
	{
		if( ERROR_IO_PENDING != GetLastError() )
		{
			WARNING_OUT(( TEXT("AutoConf: InternetQueryDataAvailable failed") ));
			return FALSE;
		} 
		else if( WAIT_FAILED == WaitForSingleObject( m_hEvent, m_dwTimeOut ) )
		{
			WARNING_OUT(( TEXT("AutoConf: InternetQueryDataAvailable wait for data failed") ));
			return FALSE;
		} 
	}
	GrabData();

	return TRUE;
}

BOOL CAutoConf::GrabData()
{
	ASSERT( NULL != m_hOpenUrl );
	ASSERT( INVALID_HANDLE_VALUE != m_hFile );

	if( !m_dwGrab )
	{
		TRACE_OUT(( TEXT("AutoConf: Finished Reading File") ));
		CloseHandle( m_hFile );
		m_hFile = INVALID_HANDLE_VALUE;
		return TRUE;
	}

	DWORD dwRead;
	LPTSTR pInetBuffer = new TCHAR[ m_dwGrab + 1];
	ASSERT( pInetBuffer );

	if( !WININET::InternetReadFile( m_hOpenUrl,
						(void *)pInetBuffer,
						m_dwGrab,
						&dwRead ) )// && ERROR_IO_PENDING != GetLastError() )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetReadFile Failed") ));
		delete [] pInetBuffer;
		return FALSE;
	}
	else
	{
		pInetBuffer[ dwRead ] = '\0';

		if( !WriteFile( m_hFile,
						pInetBuffer,
						dwRead,
						&m_dwGrab,
						NULL ) || dwRead != m_dwGrab )
		{
			WARNING_OUT(( TEXT("AutoConf: WriteFile Failed") ));
			delete [] pInetBuffer;
			return FALSE;
		}
	}

	delete [] pInetBuffer;

	QueryData();
	return TRUE;
}

void CAutoConf::CloseInternet()
{
	HINTERNETKILL( m_hInternet );
	HINTERNETKILL( m_hOpenUrl );
}

VOID CALLBACK CAutoConf::InetCallback( HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus,
    LPVOID lpvStatusInformation, DWORD dwStatusInformationLength )
{
	if( g_pAutoConf != NULL )
	{
		switch( dwInternetStatus )
		{
			case INTERNET_STATUS_REQUEST_COMPLETE:
			{
				TRACE_OUT(( TEXT("AutoConf: AutoConfInetCallback::INTERNET_STATUS_REQUEST_COMPLETE") ));

				if( AUTOCONF_CONTEXT_OPENURL == dwContext && g_pAutoConf->m_hOpenUrl == NULL )
				{
					TRACE_OUT(( TEXT("AutoConf: InternetOpenUrl Finished") ));
					LPINTERNET_ASYNC_RESULT lpIAR = (LPINTERNET_ASYNC_RESULT)lpvStatusInformation;
#ifndef _WIN64
					g_pAutoConf->m_hOpenUrl = (HINTERNET)lpIAR->dwResult;
#endif

					SetEvent( g_pAutoConf->m_hEvent );
				}
				else 
				{
					LPINTERNET_ASYNC_RESULT lpIAR = (LPINTERNET_ASYNC_RESULT)lpvStatusInformation;
					TRACE_OUT(( TEXT("AutoConf: QueryData returned") ));
					
					g_pAutoConf->m_dwGrab = (DWORD)lpIAR->dwResult;
					SetEvent( g_pAutoConf->m_hEvent );
				}
				break;
			}
#ifdef DEBUG
			case INTERNET_STATUS_CLOSING_CONNECTION:
		//Closing the connection to the server. The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Closing connection\n") ) );
			break;

		case INTERNET_STATUS_CONNECTED_TO_SERVER: 
		//Successfully connected to the socket address (SOCKADDR) pointed to by lpvStatusInformation. 
			TRACE_OUT(( TEXT("Connected to server") ) );
			break;

		case INTERNET_STATUS_CONNECTING_TO_SERVER: 
	//Connecting to the socket address (SOCKADDR) pointed to by lpvStatusInformation. 
			TRACE_OUT(( TEXT("Connecting to server") ) );
			break;


		case INTERNET_STATUS_CONNECTION_CLOSED:
		//Successfully closed the connection to the server. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Connection Closed") ) );
			break;

		case INTERNET_STATUS_HANDLE_CLOSING:
		//This handle value is now terminated.
			TRACE_OUT(( TEXT("Handle value terminated\n") ) );
			break;

		case INTERNET_STATUS_HANDLE_CREATED: 
		//Used by InternetConnect to indicate it has created the new handle. 
		//This lets the application call InternetCloseHandle from another thread,
		//if the connect is taking too long. 
			TRACE_OUT(( TEXT("Handle created\n") ) );
			break;

		case INTERNET_STATUS_NAME_RESOLVED:
		//Successfully found the IP address of the name contained in lpvStatusInformation. 
			TRACE_OUT(( TEXT("Resolved name of server") ) );
			break;

		case INTERNET_STATUS_RECEIVING_RESPONSE:
		//Waiting for the server to respond to a request. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Recieving response\n") ) );
			break;

		case INTERNET_STATUS_REDIRECT:
		//An HTTP request is about to automatically redirect the request. 
		//The lpvStatusInformation parameter points to the new URL. 
		//At this point, the application can read any data returned by the server with the
		//redirect response, and can query the response headers. It can also cancel the operation
		//by closing the handle. This callback is not made if the original request specified
		//INTERNET_FLAG_NO_AUTO_REDIRECT. 
			TRACE_OUT(( TEXT("Redirected to new server") ) );
			break;

		case INTERNET_STATUS_REQUEST_SENT: 
		//Successfully sent the information request to the server.
		//The lpvStatusInformation parameter points to a DWORD containing the number of bytes sent. 
			TRACE_OUT(( TEXT("Sent %d bytes in request"), *((DWORD *)lpvStatusInformation) ) );
			break;

		case INTERNET_STATUS_RESOLVING_NAME: 
		//Looking up the IP address of the name contained in lpvStatusInformation. 
			TRACE_OUT(( TEXT("Resolving name") ) );
			break;

		case INTERNET_STATUS_RESPONSE_RECEIVED: 
		//Successfully received a response from the server. 
		//The lpvStatusInformation parameter points to a DWORD containing the number of bytes received. 
			TRACE_OUT(( TEXT("Recieved %d bytes in response\n"), *((DWORD *)lpvStatusInformation) ) );
			break;

		case INTERNET_STATUS_SENDING_REQUEST: 
		//Sending the information request to the server. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Sending request") ) );
			break;
#endif // DEBUG

			default:
				break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calib.cpp ===
// File: calib.cpp

#include "precomp.h"
#include "resource.h"
#include "WaveDev.h"
#include "dstest.h"

#include "avdefs.h"
#include <mmsystem.h>
#include <mixer.h>
#include <mperror.h>
#include <iacapapi.h>
#include <sehcall.h>

// Local includes
#include "ConfCpl.h"
#include "conf.h"

// Defined in wizard.cpp
extern UINT_PTR GetPageBeforeAudioWiz();


// move somewhere else
#define MAXNUMPAGES_INCALIBWIZ		7
#define WAVEDEVICE_OPENFAILED		-1
#define MAXSTRINGSIZE				256
#define READFROM_REGISTRY			-1

#define AUDIOWIZ_WARNING			1
#define AUDIOWIZ_ERROR				2


#define CALIB_CHECK 				1
#define CALIB_PREPARE				2

#define CALIBERR_NO_MIXERS				1
#define CALIBERR_CANT_OPEN_WAVE_DEV 	2
#define CALIBERR_CANT_SET_VOLUME		3
#define CALIBERR_USER_CANCEL			4
#define CALIBERR_MIXER_ERROR			6
#define CALIBERR_NO_MICROPHONE			7
#define CALIBERR_DEVICE_ERROR			8


#define ATW_PLAYFILE_SOUND	TEXT("TestSnd.Wav")


#define CLIPPINGVOL 0x6000
#define DECREMENT_AMOUNT	0x800
#define DECREMENT_AMOUNT_LARGE	0x1200
#define SILENCE_THRESHOLD	0x800
// trackbar sets volume range from 0-65535, but only has 100 steps.
#define TB_VOL_INCREMENT	655
#define ATW_MSG_LENGTH	256

#define MIXER_VOLUME_MAX	0x0000ffff
#define MIXER_VOLUME_UNINITIALIZED	0xffffffff

#define WM_AUDIO_CLIPPING	(WM_USER+21)
#define WM_AUDIOTHREAD_STOP (WM_USER+22)
#define WM_AUDIOTHREAD_ERROR (WM_USER+23)
#define WM_AUDIOTHREAD_SOUND (WM_USER+24)

// vu meter
#define RECTANGLE_WIDTH	10
#define RECTANGLE_LEADING 1
#define MAX_VOLUME	32768
#define MAX_VOLUME_NORMALIZED	256

#define SHABS(x)	(((x) > 0) ? (x) : (WORD)(-(x)))

typedef struct _power_struct
{
	DWORD dwMin;
	DWORD dwMax;
	DWORD dwAvg;
	LONG lDcComponent;
} AUDIO_POWER;

#define SAMPLE_SIZE 2	// 16 bit samples

typedef struct _ERRWIZINFO{
	UINT			uType;
	UINT			uButtonOptions;
	UINT			uNextWizId;
	UINT			uBackWizId;
	UINT			uErrTitleId;
	UINT			uErrTextId;
}ERRWIZINFO, *PERRWIZINFO;


typedef struct _calib_wavein
{
	HWND hVUMeter;
	DWORD nErrorTextId;
	HWND hDlg;
	UINT uWaveInDevId;
	HANDLE hEvent;     // signal to parent after creating msg queue
} CALIB_DISPLAY, *PCALIBDISPLAY;


typedef struct _AUDIOWIZINFO{
	UINT		uFlags;
	UINT		uOptions;
	UINT		uWaveInDevId;
	UINT		uWaveOutDevId;
	BOOL		iSetAgc;
	UINT		uChanged;		//set in the wizard.
	UINT		uCalibratedVol;
	UINT		uSpeakerVol;
	UINT		uSoundCardCaps;
	UINT		uTypBandWidth;
	TCHAR		szWaveInDevName[MAXPNAMELEN];
	TCHAR		szWaveOutDevName[MAXPNAMELEN];
	MIXVOLUME	uPreCalibMainVol; // record volume
	MIXVOLUME	uPreCalibSubVol;  // microphone volume
	MIXVOLUME	uPreCalibSpkVol;  // speaker/wave volume
	UINT		uOldWaveInDevId;
	UINT		uOldWaveOutDevId;
	TCHAR		szOldWaveInDevName[MAXPNAMELEN];
	TCHAR		szOldWaveOutDevName[MAXPNAMELEN];
	ERRWIZINFO	ErrWizInfo;

	DWORD		dwWizButtons;
}AUDIOWIZINFO, *PAUDIOWIZINFO;



class WaveBufferList
{
	BYTE *m_aBytes;

	DWORD m_dwBuffers;
	DWORD m_dwSize;

public:
	WaveBufferList(DWORD dwBuffers, DWORD dwSize);
	~WaveBufferList();
	BYTE *GetBuffer(DWORD dwIndex);
};



WaveBufferList::WaveBufferList(DWORD dwBuffers, DWORD dwSize) :
m_aBytes(NULL),
m_dwBuffers(dwBuffers),
m_dwSize(dwSize)
{
	if ((m_dwBuffers > 0) && (m_dwSize > 0))
	{
		m_aBytes = new BYTE[m_dwBuffers*m_dwSize];
	}
}


BYTE *WaveBufferList::GetBuffer(DWORD dwIndex)
{
	if ((dwIndex < m_dwBuffers) && (m_aBytes))
	{
		return m_aBytes + dwIndex*m_dwSize;
	}

	return NULL;
}

WaveBufferList::~WaveBufferList()
{
	if (m_aBytes)
		delete [] m_aBytes;
}









//------------------------ Prototype Definitions -------------------------
BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, LPUINT lpuNumPages);
void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages, PWIZCONFIG pWizConfig,
	PAUDIOWIZOUTPUT pAudioWizOut);
INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

static INT_PTR IntCreateAudioCalibWizard(HWND hwndOwner, UINT uOptions, UINT uDevId,
	PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz2( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz3( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

static void SaveAudioWizChanges(PAUDIOWIZINFO pawInfo);
static UINT GetSoundCardCaps(UINT uWaveInDevId,UINT uWaveOutDevId, HWND hwnd);
static UINT CheckForFullDuplex(UINT uWaveInDevId,UINT uWaveOutDevId);
static UINT CheckForAgc(UINT uWaveInDevId);
static UINT GetWaveDeviceFromWaveMapper(UINT uNumWaveDevId, UINT uInOrOut);
static UINT CheckForWaveDeviceSupport(UINT uWaveDevId, UINT uInOrOut);

static void ProcessCalibError(UINT uCalibErr, PAUDIOWIZINFO pawInfo);
static DWORD ComputePower(SHORT *wBuffer, DWORD dwNumSamples, AUDIO_POWER *pAudioPower);
static BOOL StartAGC(CMixerDevice *pMixer, BOOL iSetAgc, UINT uSoundCardCaps);
static void PaintVUMeter (HWND hwnd, DWORD dwVolume);

static DWORD CALLBACK CalibrateTalking(PVOID);
BOOL IntGetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,
	LPUINT lpuNumPages, INT iSetAgc);

///////////////////////

static const BYTE g_VUTable[] = {
     0,     1,     2,     3,     4,     5,     6,     7,
     8,    23,    30,    35,    39,    43,    46,    49,
    52,    55,    57,    60,    62,    64,    66,    68,
    70,    72,    74,    76,    78,    80,    81,    83,
    85,    86,    88,    89,    91,    92,    94,    95,
    97,    98,    99,   101,   102,   103,   105,   106,
   107,   108,   110,   111,   112,   113,   114,   115,
   117,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   127,   128,   129,   130,   132,   132,
   133,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   147,
   148,   149,   150,   151,   152,   153,   154,   154,
   155,   156,   157,   158,   159,   159,   160,   161,
   162,   163,   163,   164,   165,   166,   167,   167,
   168,   169,   170,   170,   171,   172,   173,   173,
   174,   175,   176,   176,   177,   178,   179,   179,
   180,   181,   181,   182,   183,   184,   184,   185,
   186,   186,   187,   188,   188,   189,   190,   190,
   191,   192,   192,   193,   194,   194,   195,   196,
   196,   197,   198,   198,   199,   200,   200,   201,
   202,   202,   203,   204,   204,   205,   205,   206,
   207,   207,   208,   209,   209,   210,   210,   211,
   212,   212,   213,   213,   214,   215,   215,   216,
   216,   217,   218,   218,   219,   219,   220,   221,
   221,   222,   222,   223,   223,   224,   225,   225,
   226,   226,   227,   227,   228,   229,   229,   230,
   230,   231,   231,   232,   232,   233,   234,   234,
   235,   235,   236,   236,   237,   237,   238,   238,
   239,   239,   240,   241,   241,   242,   242,   243,
   243,   244,   244,   245,   245,   246,   246,   247,
   247,   248,   248,   249,   249,   250,   250,   251,
   251,   252,   252,   253,   253,   254,   254,   255
};


//functions
BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig, LPUINT lpuNumPages)
{
	return IntGetAudioWizardPages(uOptions, uDevId,
			plpPropSheetPages, plpWizConfig,
			lpuNumPages, READFROM_REGISTRY);
}

BOOL IntGetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,
	LPUINT lpuNumPages, INT iSetAgc)
{
	LPPROPSHEETPAGE psp;
	UINT			uNumPages = 0;
	PWIZCONFIG		pWizConfig;
	PAUDIOWIZINFO	pawInfo;
	LPSTR			szTemp;
	RegEntry		re( AUDIO_KEY, HKEY_CURRENT_USER );

	*plpPropSheetPages = NULL;
	*plpWizConfig = NULL;

	psp = (LPPROPSHEETPAGE) LocalAlloc(LPTR, MAXNUMPAGES_INCALIBWIZ * sizeof(PROPSHEETPAGE));
	if (NULL == psp)
	  {
		return FALSE;
	  }

	pWizConfig = (PWIZCONFIG) LocalAlloc(LPTR, sizeof(AUDIOWIZINFO) + sizeof(WIZCONFIG));
	if (NULL == pWizConfig)
	  {
		LocalFree(psp);
		return FALSE;
	  }
	pWizConfig->fCancel = FALSE;
	pWizConfig->uFlags = HIWORD(uOptions);
	pWizConfig->dwCustomDataSize = sizeof(AUDIOWIZINFO);

	pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
	pawInfo->uOptions = LOWORD(uOptions);
	pawInfo->uWaveInDevId = uDevId;
	pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
	pawInfo->iSetAgc = iSetAgc;

	pawInfo->uOldWaveInDevId = re.GetNumber(REGVAL_WAVEINDEVICEID,WAVE_MAPPER);
	szTemp = re.GetString(REGVAL_WAVEINDEVICENAME);
	if (szTemp)
	  lstrcpy(pawInfo->szOldWaveInDevName, szTemp);
	
	pawInfo->uOldWaveOutDevId = re.GetNumber(REGVAL_WAVEOUTDEVICEID,WAVE_MAPPER);
	szTemp = re.GetString(REGVAL_WAVEOUTDEVICENAME);
	if (szTemp)
	  lstrcpy(pawInfo->szOldWaveOutDevName, szTemp);

	pawInfo->uCalibratedVol = re.GetNumber(REGVAL_LASTCALIBRATEDVOL, 0xFFFFFFFF);

	pawInfo->uPreCalibSpkVol.leftVolume = MIXER_VOLUME_UNINITIALIZED;  // playback
	pawInfo->uPreCalibSpkVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;  // playback

	pawInfo->uPreCalibMainVol.leftVolume  = MIXER_VOLUME_UNINITIALIZED;  // recording
	pawInfo->uPreCalibMainVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;  // recording

	pawInfo->uPreCalibSubVol.leftVolume  = MIXER_VOLUME_UNINITIALIZED;   // microphone
	pawInfo->uPreCalibSubVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;   // microphone

	if (!waveInGetNumDevs() || !waveOutGetNumDevs())
	  pawInfo->uSoundCardCaps = SOUNDCARD_NONE;
	else
	  pawInfo->uSoundCardCaps = SOUNDCARD_PRESENT;
	
	FillInPropertyPage(&psp[uNumPages++], IDD_DETSOUNDCARDWIZ,
						DetSoundCardWiz,(LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ0,
						AudioCalibWiz0, (LPARAM)pWizConfig);
	if ((RUNDUE_CARDCHANGE == pawInfo->uOptions) ||
		(RUNDUE_NEVERBEFORE == pawInfo->uOptions) ||
		(RUNDUE_USERINVOKED == pawInfo->uOptions))
	  {
		FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ1,
							AudioCalibWiz1,(LPARAM)pWizConfig);
	  }
	else
	  {
		//the old wavein and wave out device will remain
		pawInfo->uWaveInDevId = pawInfo->uOldWaveInDevId;
		pawInfo->uWaveOutDevId = pawInfo->uOldWaveOutDevId;
		lstrcpy(pawInfo->szWaveInDevName,pawInfo->szOldWaveOutDevName);
		lstrcpy(pawInfo->szWaveOutDevName,pawInfo->szOldWaveOutDevName);
	  }
	
	// For each of the pages that I need, fill in a PROPSHEETPAGE structure.
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ2,
						AudioCalibWiz2, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ3,
						AudioCalibWiz3, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ4,
						AudioCalibWiz4, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBERRWIZ,
						AudioCalibErrWiz, (LPARAM)pWizConfig);
	
	// The number of pages in this wizard.
	*lpuNumPages = uNumPages;
	*plpPropSheetPages = (LPPROPSHEETPAGE) psp;
	*plpWizConfig = pWizConfig;
	return TRUE;
}


void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages,
	PWIZCONFIG pWizConfig, PAUDIOWIZOUTPUT pAudioWizOut)
{
	PAUDIOWIZINFO	pawInfo;

	pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

	if (pAudioWizOut)
	{
		pAudioWizOut->uValid = pawInfo->uChanged;//whatever is set in the wizard is valid
		pAudioWizOut->uSoundCardCaps = pawInfo->uSoundCardCaps;
		pAudioWizOut->uCalibratedVol = pawInfo->uCalibratedVol;
		pAudioWizOut->uTypBandWidth = pawInfo->uTypBandWidth;
		pAudioWizOut->uWaveInDevId = pawInfo->uWaveInDevId;
		pAudioWizOut->uWaveOutDevId = pawInfo->uWaveOutDevId;
		lstrcpy(pAudioWizOut->szWaveInDevName,pawInfo->szWaveInDevName);
		lstrcpy(pAudioWizOut->szWaveOutDevName,pawInfo->szWaveOutDevName);
			

		//the ui needs to read the changed values and call nac methods for
		//the changes below
		pAudioWizOut->uChanged = AUDIOWIZ_NOCHANGES;
		if ((pawInfo->uChanged & SOUNDCARD_CHANGED) &&
			((pawInfo->uWaveInDevId != pawInfo->uOldWaveInDevId) ||
			 (pawInfo->uWaveOutDevId != pawInfo->uOldWaveOutDevId) ||
			 lstrcmp(pawInfo->szWaveInDevName,pawInfo->szOldWaveInDevName) ||
			 lstrcmp(pawInfo->szWaveOutDevName,pawInfo->szOldWaveOutDevName)))
		{			
				pAudioWizOut->uChanged |= SOUNDCARD_CHANGED;
				pAudioWizOut->uChanged |= SOUNDCARDCAPS_CHANGED;
					
		}
	}

	LocalFree(pWizConfig);
	LocalFree(lpPropSheetPages);

}

INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc)
{
	//agc values are provided
	return(IntCreateAudioCalibWizard(hwndOwner, uOptions, uDevId, pAudioWizOut, iSetAgc));

}		

VOID CmdAudioCalibWizard(HWND hwnd)
{
	AUDIOWIZOUTPUT awo;
	INT_PTR nRet = IntCreateAudioCalibWizard(
					hwnd,
					RUNDUE_USERINVOKED,
					WAVE_MAPPER,
					&awo,
					READFROM_REGISTRY);

	if ((nRet > 0) && (awo.uChanged & SOUNDCARD_CHANGED))
	{
		::HandleConfSettingsChange(CSETTING_L_AUDIODEVICE);
	}
}

INT_PTR IntCreateAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId, PAUDIOWIZOUTPUT pAudioWizOut, INT iSetAgc)
{	
	LPPROPSHEETPAGE ppsp;
	UINT			uNumPages;
	PWIZCONFIG		pWizConfig;

	if (!IntGetAudioWizardPages(uOptions, uDevId,
			&ppsp, &pWizConfig, &uNumPages, iSetAgc))
	{
		return -1;
	}

	PROPSHEETHEADER psh;
	InitStruct(&psh);

	// Specify that this is a wizard property sheet with no Apply Now button.
	psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
	psh.hwndParent = hwndOwner;

	// Use page captions.
	ASSERT(NULL == psh.pszCaption);
	ASSERT(0 == psh.nStartPage);
	
	psh.nPages = uNumPages;
	psh.ppsp = ppsp;
	
	// Create and run the wizard.
	INT_PTR iRet = PropertySheet(&psh);

	ReleaseAudioWizardPages(ppsp, pWizConfig, pAudioWizOut);

	return iRet;
}

void SaveAudioWizChanges(PAUDIOWIZINFO pawInfo)
{
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	
	if (pawInfo->uChanged & SOUNDCARDCAPS_CHANGED)
	{
		re.SetValue ( REGVAL_SOUNDCARDCAPS, pawInfo->uSoundCardCaps);
		re.SetValue ( REGVAL_FULLDUPLEX, ISSOUNDCARDFULLDUPLEX(pawInfo->uSoundCardCaps) ? FULLDUPLEX_ENABLED : FULLDUPLEX_DISABLED);

		if (!ISDIRECTSOUNDAVAILABLE(pawInfo->uSoundCardCaps))
		{
			re.SetValue(REGVAL_DIRECTSOUND, (ULONG)DSOUND_USER_DISABLED);
		}
	}

	if (pawInfo->uChanged & CALIBVOL_CHANGED)
	{
		re.SetValue ( REGVAL_CALIBRATEDVOL, pawInfo->uCalibratedVol);
		re.SetValue ( REGVAL_LASTCALIBRATEDVOL, pawInfo->uCalibratedVol);
	}		
	if (pawInfo->uChanged & SOUNDCARD_CHANGED)
	{
		re.SetValue (REGVAL_WAVEINDEVICEID, pawInfo->uWaveInDevId);
		re.SetValue (REGVAL_WAVEINDEVICENAME, pawInfo->szWaveInDevName);
		re.SetValue (REGVAL_WAVEOUTDEVICEID, pawInfo->uWaveOutDevId);
		re.SetValue (REGVAL_WAVEOUTDEVICENAME, pawInfo->szWaveOutDevName);
	}	

	if (pawInfo->uChanged & SPEAKERVOL_CHANGED)
	{
		re.SetValue (REGVAL_SPEAKERVOL, pawInfo->uSpeakerVol);	
	}

}


INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}

			return (TRUE);

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					if (pawInfo->uSoundCardCaps != SOUNDCARD_NONE)
					{
						// Skip this page; go to IDD_AUDIOCALIBWIZ0;
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}						

					// Initialize the controls.
					DWORD dwWizButtons = PSWIZB_FINISH;
					if (pWizConfig->uFlags & STARTWITH_BACK)
						dwWizButtons |= PSWIZB_BACK;
					PropSheet_SetWizButtons(GetParent(hDlg), dwWizButtons );
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
					}
					break;
				}										

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 don't allow next
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
					return TRUE;

				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!(pWizConfig->uFlags & STARTWITH_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					else
					{	
						UINT_PTR iPrev = GetPageBeforeAudioWiz();
						ASSERT( iPrev );
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
						return TRUE;
					}
					break;

				case PSN_WIZFINISH:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
					re.SetValue ( REGVAL_SOUNDCARDCAPS, pawInfo->uSoundCardCaps);
					break;
				}

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
									
				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}

INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return TRUE;

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					DWORD dwWizButtons = PSWIZB_NEXT;
					if (pWizConfig->uFlags & STARTWITH_BACK)
						dwWizButtons |= PSWIZB_BACK;
					PropSheet_SetWizButtons(GetParent(hDlg), dwWizButtons );
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!(pWizConfig->uFlags & STARTWITH_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					if (pawInfo->uSoundCardCaps != SOUNDCARD_NONE)
					{
							//  don't go to the DetSoundCard page...
						UINT_PTR iPrev = GetPageBeforeAudioWiz();
						ASSERT( iPrev );
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
						return TRUE;
					}
				
					break;

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
									
				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}


INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	UINT						uSoundCardCaps;
	int 						nIndex;
	HWND						hwndCB;
	
	switch (message)
	{
		case WM_INITDIALOG:
		{
			WAVEINCAPS	wiCaps;
			WAVEOUTCAPS woCaps;
			LPSTR		lpszTemp;
			UINT		uWaveDevId;
			UINT		uWaveDevRealId;
			UINT		uDevCnt;
			UINT		uCnt;
			UINT		uDevID;
			
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			//we come to this page only if a sound card is present.
			
			// If we end up with WAVE_MAPPER, this means that this is the first time we run this code
			pawInfo->uWaveInDevId = uWaveDevRealId = uWaveDevId = pawInfo->uOldWaveInDevId;
			uDevCnt = waveInGetNumDevs();
			lstrcpy(pawInfo->szWaveInDevName, lpszTemp = pawInfo->szOldWaveInDevName);

			//add the device to the drop down list
			hwndCB = GetDlgItem(hDlg, IDC_WAVEIN);
			for (uDevID = 0, uCnt = uDevCnt; 0 != uCnt; uDevID++, uCnt--)
			{
				if ((waveInGetDevCaps(uDevID, &wiCaps, sizeof(WAVEINCAPS)) == MMSYSERR_NOERROR) &&
					(CheckForWaveDeviceSupport(uDevID, 0)))
				{
					nIndex = ComboBox_AddString(hwndCB, wiCaps.szPname);
					ComboBox_SetItemData(hwndCB, nIndex, uDevID);

					//if a device hasnt been chosen previously, then set the default device to the
					//zeroth one
					if (uWaveDevId == WAVE_MAPPER)
					{
						if (uDevCnt <= 1)
							uWaveDevRealId = uDevID;
						else
							if ((uWaveDevRealId == WAVE_MAPPER) && (uDevCnt == uCnt))
								uWaveDevRealId = GetWaveDeviceFromWaveMapper(uCnt, 0);
						if (uDevID == uWaveDevRealId)
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveInDevId = uDevID;
							lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
						}
					}
					else
					{
						if ((0 == nIndex) || (!lstrcmp(wiCaps.szPname, lpszTemp)))
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveInDevId = uDevID;
							lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
						}
					}
				}
			}
			// TEMPORARY 1.0 stuff because this would require too much rewrite:
			// In case no device was added to the combo box, let's put the first one in
			// even though we know it will never work.
			if ((0 == ComboBox_GetCount(hwndCB)) || (uWaveDevRealId == WAVE_MAPPER))
			{
				waveInGetDevCaps(0,&wiCaps, sizeof(WAVEINCAPS));
				if (0 == ComboBox_GetCount(hwndCB))
				{
					ComboBox_AddString(hwndCB, wiCaps.szPname);
					ComboBox_SetItemData(hwndCB, 0, 0);
				}
				ComboBox_SetCurSel(hwndCB, 0);
				pawInfo->uWaveInDevId = 0;
				lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
			}

			// If we end up with WAVE_MAPPER, this means that this is the first time we run this code
			pawInfo->uWaveOutDevId = uWaveDevRealId = uWaveDevId = pawInfo->uOldWaveOutDevId;
			uDevCnt = waveOutGetNumDevs();
			lstrcpy(pawInfo->szWaveOutDevName, lpszTemp = pawInfo->szOldWaveOutDevName);

			//add the device to the drop down list
			hwndCB = GetDlgItem(hDlg, IDC_WAVEOUT);
			for (uDevID = 0, uCnt = uDevCnt; 0 != uCnt; uDevID++, uCnt--)
			{
				if	((waveOutGetDevCaps(uDevID, &woCaps, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR) &&
					(CheckForWaveDeviceSupport(uDevID, 1)))
				{
					nIndex = ComboBox_AddString(hwndCB, woCaps.szPname);
					ComboBox_SetItemData(hwndCB, nIndex, uDevID);

					//if a device hasnt been chosen previously, then set the default device to the
					//zeroth one
					if (uWaveDevId == WAVE_MAPPER)
					{
						if (uDevCnt <= 1)
							uWaveDevRealId = uDevID;
						else
							if ((uWaveDevRealId == WAVE_MAPPER) && (uDevCnt == uCnt))
								uWaveDevRealId = GetWaveDeviceFromWaveMapper(uCnt, 1);
						if (uDevID == uWaveDevRealId)
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveOutDevId = uDevID;
							lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
						}
					}
					else
					{
						if ((0 == nIndex) || (!lstrcmp(woCaps.szPname, lpszTemp)))
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveOutDevId = uDevID;
							lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
						}
					}					
				}
			}
			// TEMPORARY 1.0 stuff because this would require too much rewrite:
			// In case no device was added to the combo box, let's put the first one in
			// even though we know it will never work.
			if ((0 == ComboBox_GetCount(hwndCB)) || (uWaveDevRealId == WAVE_MAPPER))
			{
				waveOutGetDevCaps(0,&woCaps, sizeof(WAVEOUTCAPS));
				if (0 == ComboBox_GetCount(hwndCB))
				{
					ComboBox_AddString(hwndCB, (LPARAM)woCaps.szPname);
					ComboBox_SetItemData(hwndCB, 0, 0);
				}
				ComboBox_SetCurSel(hwndCB, 0);
				pawInfo->uWaveOutDevId = 0;
				lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
			}

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
					// Initialize the controls.
					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						break;
					}
					else
					{
						if ((1 != ComboBox_GetCount(GetDlgItem(hDlg, IDC_WAVEIN))) ||
							(1 != ComboBox_GetCount(GetDlgItem(hDlg, IDC_WAVEOUT))))
						{
							break;
						}
						// else fall through to next
					}

				case PSN_WIZNEXT:
					// set settings in registry
					//check the device
					//get the new wavein device and its info
					hwndCB = GetDlgItem(hDlg, IDC_WAVEIN);
					nIndex = ComboBox_GetCurSel(hwndCB);
					pawInfo->uWaveInDevId = (UINT)ComboBox_GetItemData(hwndCB, nIndex);
					ComboBox_GetLBText(hwndCB, nIndex, pawInfo->szWaveInDevName);

					//get the new waveout device and its info
					hwndCB = GetDlgItem(hDlg, IDC_WAVEOUT);
					nIndex = ComboBox_GetCurSel(hwndCB);
					pawInfo->uWaveOutDevId = (UINT)ComboBox_GetItemData(hwndCB, nIndex);
					ComboBox_GetLBText(hwndCB, nIndex, pawInfo->szWaveOutDevName);

					uSoundCardCaps = GetSoundCardCaps(pawInfo->uWaveInDevId,pawInfo->uWaveOutDevId, hDlg);
					
					//save it in the wizinfo struct for writing to registry 					
					pawInfo->uSoundCardCaps = uSoundCardCaps;
					
					pawInfo->uChanged |= SOUNDCARDCAPS_CHANGED;
					pawInfo->uChanged |= SOUNDCARD_CHANGED;

					if (PSN_SETACTIVE == ((NMHDR FAR *) lParam)->code)
					{
						// Skip this page;
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					break;

				case PSN_RESET:
				{
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
				}

				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}

// The WaveOut test page
INT_PTR WINAPI AudioCalibWiz2(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static CMixerDevice *pMixer = NULL;
	static HWND hTrackBar;
	DWORD dwTBPos;
	MIXVOLUME dwNewVol;
	static MIXVOLUME dwVol;  // last set volume
	BOOL fRet;
	static BOOL fCanSetVolume = FALSE;
	static waveOutDev *pWaveOut= NULL;
	UINT uWaveOutDevId;
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	TCHAR szText[ATW_MSG_LENGTH];
	MMRESULT mmr;
	static fIsPlaying;
	
	switch (msg)
	{
		case (WM_INITDIALOG):
		{
			pMixer = NULL;
			hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER1);

			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			break;
		}

		case (WM_NOTIFY):
		{
			switch (((NMHDR *)lParam)->code)
			{

				case PSN_SETACTIVE:
					fIsPlaying = FALSE;

					uWaveOutDevId = pawInfo->uWaveOutDevId;

					pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, uWaveOutDevId, MIXER_OBJECTF_WAVEOUT);
					if (pMixer)
					{
						SendMessage(hTrackBar, TBM_SETRANGE, TRUE, (LPARAM)MAKELONG(0, 100));
						SendMessage(hTrackBar, TBM_SETTICFREQ, 10, 0);
						SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 20);
						SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 10);

						pMixer->GetVolume(&dwVol);
						fCanSetVolume = pMixer->SetVolume(&dwVol);
						pMixer->UnMuteVolume();

						// preserve the speaker volume so that it can be restored
						// if the user presses cancel

						if (pawInfo->uPreCalibSpkVol.leftVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pawInfo->uPreCalibSpkVol.leftVolume = dwVol.leftVolume;
						}

						if (pawInfo->uPreCalibSpkVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pawInfo->uPreCalibSpkVol.rightVolume = dwVol.rightVolume;
						}

					}
					else
						fCanSetVolume = FALSE;

					EnableWindow(GetDlgItem(hDlg, IDC_GROUP_VOLUME), fCanSetVolume);
					EnableWindow(GetDlgItem(hDlg, IDC_ATW_SLIDER1), fCanSetVolume);
					EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_ATW_TEST), TRUE);

					if (fCanSetVolume)
					{
						FLoadString(IDS_ATW_PLAYBACK, szText, CCHMAX(szText));
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					}

					// if we can't get a mixer, then center the trackbar and disable
					else
					{
						FLoadString(IDS_ATW_PLAYBACK_NOMIX, szText, CCHMAX(szText));
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, 50);
					}

					SetDlgItemText(hDlg, IDC_ATW_PLAYTEXT, szText);
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, TEXT(""));
					
					FLoadString(IDS_TESTBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);

					pWaveOut = new waveOutDev(uWaveOutDevId, hDlg);
					if (pWaveOut == NULL)
					{
						ERROR_OUT(("AudioWiz2: Unable to create waveOutDev object"));
					}

					PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_NEXT);

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						return TRUE;
					}

					break;

				case PSN_WIZNEXT:
				case PSN_WIZBACK:
				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					if ((fCanSetVolume) && (pMixer))
					{
						pMixer->GetVolume(&dwNewVol);
						pawInfo->uSpeakerVol = max(dwNewVol.leftVolume , dwNewVol.rightVolume);
						pawInfo->uChanged |= SPEAKERVOL_CHANGED;
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					if (pWaveOut)
					{
						delete pWaveOut;
						pWaveOut = NULL;
					}

					SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.

					// restore speaker volume to what it was before the tuning wizard was launched
					if (pawInfo->uPreCalibSpkVol.leftVolume <= MIXER_VOLUME_MAX || pawInfo->uPreCalibSpkVol.rightVolume <= MIXER_VOLUME_MAX)
					{
						if (pMixer == NULL)
						{
							pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveOutDevId, MIXER_OBJECTF_WAVEOUT);
						}
						if (pMixer)
						{
							pMixer->SetVolume(&pawInfo->uPreCalibSpkVol);
						}
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					if (pWaveOut)
					{
						delete pWaveOut;
						pWaveOut = NULL;
					}

					break;

				default:
					return FALSE;
			}
			return TRUE;
		}


		case (WM_HSCROLL):  // trackbar notification
		{
			dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				NewMixVolume(&dwNewVol, dwVol, (dwTBPos * TB_VOL_INCREMENT));				
				pMixer->SetVolume(&dwNewVol);
			}
			break;
		}


		// mixer notifications
		case MM_MIXM_CONTROL_CHANGE:
		case MM_MIXM_LINE_CHANGE:
		{
			if (pMixer)
			{

				fRet = pMixer->GetVolume(&dwNewVol);

				if ((fRet) && (dwNewVol.leftVolume != dwVol.leftVolume || dwNewVol.rightVolume != dwVol.rightVolume))
				{
					dwVol = dwNewVol;
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}
			}
			break;
		}

		// when the PlayFile is done playing
		case WOM_DONE:
		{
			if ((pWaveOut) && (fIsPlaying))
			{
				pWaveOut->PlayFile(ATW_PLAYFILE_SOUND);
			}

			break;
		}


		case WM_COMMAND:
		{
			// if the device fails to open, then we
			// display the error text

			// if the WAV file fails to load, we simply disable the button

			if (LOWORD(wParam) == IDC_BUTTON_ATW_TEST)
			{

				if (fIsPlaying == TRUE)
				{
					fIsPlaying = FALSE;
					pWaveOut->Close();
					FLoadString(IDS_TESTBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);
					break;
				}

				mmr = pWaveOut->PlayFile(ATW_PLAYFILE_SOUND);

				if (mmr == MMSYSERR_ALLOCATED )
				{
					FLoadString(IDS_PLAYBACK_ERROR, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, szText);
				}

				else if (mmr != MMSYSERR_NOERROR)
				{
					EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_ATW_TEST), FALSE);
					FLoadString(IDS_PLAYBACK_ERROR2, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, szText);
				}

				else // mmr == MMSYSERR_NOERROR
				{
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, TEXT(""));
					FLoadString(IDS_STOPBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);
					fIsPlaying = TRUE;
				}

			}
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}



// Microphone test page
INT_PTR WINAPI AudioCalibWiz3(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static HANDLE hThread = NULL;
	static DWORD dwThreadID = 0;
	static HANDLE hEvent = NULL;
	static CMixerDevice *pMixer = NULL;
	static HWND hTrackBar;
	static DWORD dwMainVol;
	static DWORD dwSubVol;
	DWORD dwTBPos, dwNewMainVol, dwNewSubVol;
	MIXVOLUME dwVol, dwNewVol;
	BOOL fRet;
	static BOOL fCanSetVolume=FALSE;
	static CALIB_DISPLAY CalibDisplay;
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	static BOOL fSoundDetected;
	const TCHAR *szEventName = _TEXT("CONF.EXE ATW Event Handle");

	switch (msg)
	{
		case (WM_INITDIALOG):
		{
			hThread = NULL;
			dwThreadID = NULL;
			hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER2);

			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			break;
		}

		case (WM_NOTIFY):
		{
			switch (((NMHDR *)lParam)->code)
			{

				case PSN_SETACTIVE:
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						return TRUE;
					}

					fCanSetVolume = TRUE;
					fSoundDetected = FALSE;

					pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveInDevId, MIXER_OBJECTF_WAVEIN);
					if (pMixer)
					{
						SendMessage(hTrackBar, TBM_SETRANGE, TRUE, (LPARAM)MAKELONG(0, 100));
						SendMessage(hTrackBar, TBM_SETTICFREQ, 10, 0);
						SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 20);
						SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 10);

						// remember the volume in case the user presses cancel
						if (pawInfo->uPreCalibMainVol.leftVolume == MIXER_VOLUME_UNINITIALIZED ||
							pawInfo->uPreCalibMainVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pMixer->GetMainVolume(&(pawInfo->uPreCalibMainVol));
						}
						if (pawInfo->uPreCalibSubVol.leftVolume == MIXER_VOLUME_UNINITIALIZED ||
							pawInfo->uPreCalibSubVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pMixer->GetSubVolume(&(pawInfo->uPreCalibSubVol));
						}

						MIXVOLUME mixVol = {-1, -1};
						pMixer->GetVolume(&mixVol);
						fCanSetVolume = pMixer->SetVolume(&mixVol);
						dwSubVol = dwMainVol= 0xffff;
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, dwMainVol/TB_VOL_INCREMENT);
						pMixer->EnableMicrophone();
						pMixer->UnMuteVolume();

						StartAGC(pMixer, pawInfo->iSetAgc, pawInfo->uSoundCardCaps);
					}

					// no mixer!
					if (pMixer == NULL)
					{
						ProcessCalibError(CALIBERR_MIXER_ERROR, pawInfo);
					}

					// no microphone!
					else if (fCanSetVolume == FALSE)
					{
						delete pMixer;
						pMixer = NULL;
						ProcessCalibError(CALIBERR_CANT_SET_VOLUME, pawInfo);
					}

					// process error
					if ((pMixer == NULL) || (fCanSetVolume == FALSE))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_AUDIOCALIBERRWIZ);
						return TRUE;
					}

					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
					CalibDisplay.hDlg = hDlg;
					CalibDisplay.hVUMeter = GetDlgItem(hDlg, IDC_VUMETER);
					CalibDisplay.uWaveInDevId = pawInfo->uWaveInDevId;

					ASSERT(hEvent == NULL);

					// just create the same event twice (easier than using DuplicateHandle)
					hEvent = CreateEvent(NULL, FALSE, FALSE, szEventName);
					CalibDisplay.hEvent = CreateEvent(NULL, FALSE, FALSE, szEventName);

					ASSERT(hThread == NULL);
					hThread = NULL;

					if (hEvent && (CalibDisplay.hEvent))
					{
						hThread = CreateThread(NULL, 0, CalibrateTalking, (LPVOID)(&CalibDisplay), 0, &dwThreadID);
					}

#ifdef DEBUG
					if ((hEvent == NULL) || (CalibDisplay.hEvent == NULL))
					{
						ERROR_OUT(("ATW:  Unable to create events for thread control!\r\n"));
					}
					else if (hThread == NULL)
					{
						ERROR_OUT(("ATW:  Unable to create thread for recording loop!\r\n"));
					}
#endif

					break;

				case PSN_WIZNEXT:
				case PSN_WIZBACK:
				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					if (hThread)
					{
						SetEvent(hEvent); // signal the thread to exit, thread will CloseHandle(hEvent)

						// wait for the thread to exit, but
						// but keep processing window messages
						AtlWaitWithMessageLoop(hThread);

						CloseHandle(hEvent);
						CloseHandle(hThread);
						hThread = NULL;
						hEvent = NULL;
						dwThreadID = 0;
					}

					
					// silent wizard get's set to max
					if (g_fSilentWizard)
					{
						pawInfo->uChanged |= CALIBVOL_CHANGED;
						pawInfo->uChanged = 0xffff;
					}
					
					else if ((fCanSetVolume) && (pMixer))
					{
						pawInfo->uChanged |= CALIBVOL_CHANGED;
						pMixer->GetVolume(&dwVol);
						pawInfo->uCalibratedVol = max (dwVol.leftVolume , dwVol.rightVolume);
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					// if we never got an indication back from the sound thread
					// then the next page to be displayed is the "microphone" error page
					// note the check for the silent wizard
					if ((!g_fSilentWizard) && (fSoundDetected == FALSE) && (((NMHDR *)lParam)->code == PSN_WIZNEXT))
					{
						ProcessCalibError(CALIBERR_NO_MICROPHONE, pawInfo);
						SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, IDD_AUDIOCALIBERRWIZ);
					}

					else
						SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.
					if (hThread)
					{
						SetEvent(hEvent);  // signal thread to exit

						AtlWaitWithMessageLoop(hThread);

						CloseHandle(hEvent);
						hEvent = NULL;
						CloseHandle(hThread);
						hThread = NULL;
						dwThreadID = 0;
					}


					// restore recording/microphone volume to what it was before the tuning wizard was launched
					if ( (pawInfo->uPreCalibMainVol.leftVolume <= MIXER_VOLUME_MAX && pawInfo->uPreCalibMainVol.rightVolume <= MIXER_VOLUME_MAX) ||
						 (pawInfo->uPreCalibSubVol.leftVolume <= MIXER_VOLUME_MAX && pawInfo->uPreCalibSubVol.rightVolume <= MIXER_VOLUME_MAX))
					{
						if (pMixer == NULL)
						{
							pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveInDevId, MIXER_OBJECTF_WAVEIN);
						}
						if (pMixer)
						{
							if (pawInfo->uPreCalibMainVol.leftVolume < MIXER_VOLUME_MAX || pawInfo->uPreCalibMainVol.rightVolume < MIXER_VOLUME_MAX)
							{
								pMixer->SetMainVolume(&pawInfo->uPreCalibMainVol);
							}
							
							if (pawInfo->uPreCalibSubVol.leftVolume < MIXER_VOLUME_MAX || pawInfo->uPreCalibSubVol.rightVolume < MIXER_VOLUME_MAX)
							{
								pMixer->SetSubVolume(&pawInfo->uPreCalibSubVol);
							}
						}
					}


					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}
					break;

				default:
					return FALSE;
			}
			return TRUE;
		}

		case (WM_HSCROLL):  // trackbar notification
		{

			dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				NewMixVolume(&dwNewVol, dwVol, (dwTBPos * TB_VOL_INCREMENT));				
				pMixer->SetVolume(&dwNewVol);
				
			}
			break;
		}

		// notifications from the mixer
		case MM_MIXM_CONTROL_CHANGE:
		case MM_MIXM_LINE_CHANGE:
		{
			if (pMixer)
			{
				fRet = pMixer->GetMainVolume(&dwVol);
				if ((fRet) && (dwVol.leftVolume != dwMainVol || dwVol.rightVolume != dwMainVol))
				{
					pMixer->SetSubVolume(&dwVol);
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}

				MIXVOLUME subvol;
				fRet = pMixer->GetSubVolume(&subvol);
				if ((fRet) && (dwVol.leftVolume != subvol.leftVolume || dwVol.rightVolume !=subvol.rightVolume))
				{
					pMixer->SetMainVolume(&subvol);
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(subvol.leftVolume , subvol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}
			}
			break;
		}

		// calibration thread sends this message to indicate that the
		// volume is too loud
		case WM_AUDIO_CLIPPING:
		{
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				if (dwVol.leftVolume > DECREMENT_AMOUNT || dwVol.rightVolume > DECREMENT_AMOUNT)
				{
					dwVol.leftVolume -=DECREMENT_AMOUNT;
					dwVol.rightVolume -=DECREMENT_AMOUNT;
					
					pMixer->SetVolume(&dwVol);

					// fix for Videum driver
					// check to see if the volume actually got lowered
					// if it didn't, try a larger decrement
					pMixer->GetVolume(&dwNewVol);
					if ((dwNewVol.leftVolume == dwVol.leftVolume) && (dwVol.leftVolume >= DECREMENT_AMOUNT_LARGE) ||
						(dwNewVol.rightVolume == dwVol.rightVolume) && (dwVol.rightVolume >= DECREMENT_AMOUNT_LARGE))
					{
						dwVol.leftVolume -=DECREMENT_AMOUNT_LARGE;
						dwVol.rightVolume -=DECREMENT_AMOUNT_LARGE;
					
						pMixer->SetVolume(&dwVol);
					}
				}
			}
			break;
		}

		// the recording thread is signaling back to us that there is
		// a severe error.  Assume the thread has exited
		case WM_AUDIOTHREAD_ERROR:
		{
			ProcessCalibError(CALIBERR_DEVICE_ERROR, pawInfo);
			PropSheet_SetCurSelByID(GetParent(hDlg), IDD_AUDIOCALIBERRWIZ);
			break;
		}

		// The recording thread will send this message back to us
		// at least once to indicate that the silence threshold was
		// broken.  Thus, the microphone is functional.
		case WM_AUDIOTHREAD_SOUND:
		{
			fSoundDetected = TRUE;
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}




INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
		{

			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return (TRUE);
		}			

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
					}
					break;
				}

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 don't allow next
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
					return TRUE;

				case PSN_WIZFINISH:
					SaveAudioWizChanges(pawInfo);
					break;
			}
			break;

	}
	return (FALSE);
}

INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	PWIZCONFIG					pWizConfig;
	static	PAUDIOWIZINFO		pawInfo;
	TCHAR	szTemp[MAXSTRINGSIZE];
	LPTSTR pszIcon;


	//WORD	wCmdId;
	
	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
					// initialize the controls.

					// Show the error or warning icon
					pszIcon = (((pawInfo->ErrWizInfo).uType == AUDIOWIZ_WARNING) ?
								IDI_ASTERISK : IDI_EXCLAMATION);

					// Set the wizard bitmap to the static control
					::SendDlgItemMessage(	hDlg,
									IDC_ERRWIZICON,
									STM_SETIMAGE,
									IMAGE_ICON,
									(LPARAM) ::LoadIcon(NULL, pszIcon));

					//set the error title
					if ((pawInfo->ErrWizInfo).uErrTitleId)
					{
						LoadString(GetInstanceHandle(),(pawInfo->ErrWizInfo).uErrTitleId,
							szTemp, MAXSTRINGSIZE);
						SetDlgItemText(hDlg, IDC_ERRTITLE, szTemp);
					}

					if ((pawInfo->ErrWizInfo).uErrTextId)
					{
						//show the error text
						LoadString(GetInstanceHandle(),(pawInfo->ErrWizInfo).uErrTextId,
							szTemp, MAXSTRINGSIZE);
						SetDlgItemText(hDlg, IDC_ERRTEXT, szTemp);
					}

					PropSheet_SetWizButtons(GetParent(hDlg),
						(pawInfo->ErrWizInfo).uButtonOptions );

					if (g_fSilentWizard)
					{
						// Due to bug in ComCtl32 check if button is enabled
						if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_FINISH))
						{
							PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
						}
						else
						{
							PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						}
					}
					break;

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_NEXT))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (pawInfo->ErrWizInfo).uNextWizId);
					return TRUE;

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;

				case PSN_WIZFINISH:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_FINISH))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SaveAudioWizChanges(pawInfo);
					break;
					
				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (pawInfo->ErrWizInfo).uBackWizId);
					return TRUE;
			}
			break;
	}
	return (FALSE);
}

void ProcessCalibError(UINT uCalibErr, PAUDIOWIZINFO pawInfo)
{
	switch (uCalibErr)
	{
	case CALIBERR_CANT_SET_VOLUME:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_WARNING;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_NORECVOLCNTRL;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;

	case CALIBERR_NO_MIXERS:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ1;
		break;

	case CALIBERR_MIXER_ERROR:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;

	case CALIBERR_CANT_OPEN_WAVE_DEV:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_CANTOPENWAVE;
		pawInfo->ErrWizInfo.uErrTextId = IDS_QUITPROGRAM;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_NEXT|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = IDD_AUDIOCALIBWIZ3;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ1;
		break;

	case CALIBERR_NO_MICROPHONE:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_WARNING;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_NO_MICROPHONE;
		pawInfo->ErrWizInfo.uErrTextId = IDS_NO_MICWARNING;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_NEXT|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = IDD_AUDIOCALIBWIZ4;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ3;
		break;

	default:
	case CALIBERR_DEVICE_ERROR:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;
	}
}

UINT GetSoundCardCaps(UINT uWaveInDevId, UINT uWaveOutDevId, HWND hwnd)
{
	UINT	uSoundCardCaps;
	UINT	uRet;
	bool bFD = false;
	UINT uDSCheck;

	
	uSoundCardCaps = SOUNDCARD_PRESENT;

	if ((uRet = CheckForFullDuplex(uWaveInDevId,uWaveOutDevId)) == SOUNDCARD_NONE)
	{
		//failed to open wave device
		//SS:Error message ??
		//all applications using the wave device should be closed
		
	}
	else if (uRet == SOUNDCARD_FULLDUPLEX)
	{
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_FULLDUPLEX;
		bFD = true;
	}
	if ((uRet = CheckForAgc(uWaveInDevId)) == SOUNDCARD_NONE)
	{
		//mixer initialization failed
		//SS: Error message
	}
	else if (uRet == SOUNDCARD_HAVEAGC)
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_HAVEAGC;


	uDSCheck = DirectSoundCheck(uWaveInDevId, uWaveOutDevId, hwnd);
	if (uDSCheck & DS_FULLDUPLEX)
	{
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_DIRECTSOUND;
	}

	return(uSoundCardCaps);
}

UINT CheckForFullDuplex(UINT uWaveInDevId,UINT uWaveOutDevId)
{
	HWAVEIN 		hWaveIn=NULL;
	HWAVEOUT		hWaveOut=NULL;
	MMRESULT		mmr;
	UINT			uRet = SOUNDCARD_NONE;

	waveInDev waveIn(uWaveInDevId);
	waveOutDev waveOut(uWaveOutDevId);


	mmr = waveOut.Open();
	if (mmr != MMSYSERR_NOERROR)
	{
		return SOUNDCARD_NONE;
	}

	mmr = waveIn.Open();
	if (mmr != MMSYSERR_NOERROR)
	{
		return SOUNDCARD_PRESENT;
	}

	return SOUNDCARD_FULLDUPLEX;

	// object destructors will close devices
}

UINT GetWaveDeviceFromWaveMapper(UINT uNumWaveDevId, UINT uInOrOut)
{
	HWAVE			hWave=NULL;
	HWAVE			hWaveMapper=NULL;
	WAVEFORMATEX	WaveFormatEx;
	MMRESULT		mmr;
	UINT			uDeviceId = (UINT)-1;
	UINT			i;
	
	WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
	WaveFormatEx.nChannels =  1;
	WaveFormatEx.nSamplesPerSec = 8000;
	WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
	WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
	WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
	WaveFormatEx.cbSize = 0;

	if (!uInOrOut)
	{
#if 0
		// First, make sure that none of the devices are already open
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				goto MyExit;
			else
				if (mmr == WAVERR_BADFORMAT)
				{
					// This is probably an 8 bit board. Try again using 8 bit format
					WaveFormatEx.nAvgBytesPerSec = 8000;
					WaveFormatEx.nBlockAlign = 1;
					WaveFormatEx.wBitsPerSample = 8;
					if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
						goto MyExit;
				}
			if (hWave)
			{
				waveInClose((HWAVEIN)hWave);
				hWave = (HWAVE)NULL;
			}
		}

		WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
		WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
		WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
#endif
		// Open the wave in device using wave mapper
		if (mmr = waveInOpen ((HWAVEIN *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
			{
			if (mmr == WAVERR_BADFORMAT)
			{
				// This is probably an 8 bit board. Try again using 8 bit format
				WaveFormatEx.nAvgBytesPerSec = 8000;
				WaveFormatEx.nBlockAlign = 1;
				WaveFormatEx.wBitsPerSample = 8;
				if (mmr = waveInOpen ((HWAVEIN *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
					goto MyExit;
			}
			else
				goto MyExit;
			}

		// Now, look for the wave device that is already open
		// that's the one wave mapper picked up
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				{
				uDeviceId = i;
				goto MyExit;
				}
			else
				if (hWave)
				{
					waveInClose((HWAVEIN)hWave);
					hWave = (HWAVE)NULL;
				}
		}
	}
	else
	{
#if 0
		// First, make sure that none of the devices are already open
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				goto MyExit;
			else
				if (mmr == WAVERR_BADFORMAT)
				{
					// This is probably an 8 bit board. Try again using 8 bit format
					WaveFormatEx.nAvgBytesPerSec = 8000;
					WaveFormatEx.nBlockAlign = 1;
					WaveFormatEx.wBitsPerSample = 8;
					if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
						goto MyExit;
				}
			if (hWave)
			{
				waveOutClose((HWAVEOUT)hWave);
				hWave = (HWAVE)NULL;
			}
		}

		WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
		WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
		WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
#endif
		// Open the wave in device using wave mapper
		if (mmr = waveOutOpen ((HWAVEOUT *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
			{
			if (mmr == WAVERR_BADFORMAT)
			{
				// This is probably an 8 bit board. Try again using 8 bit format
				WaveFormatEx.nAvgBytesPerSec = 8000;
				WaveFormatEx.nBlockAlign = 1;
				WaveFormatEx.wBitsPerSample = 8;
				if (mmr = waveOutOpen ((HWAVEOUT *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
					goto MyExit;
			}
			else
				goto MyExit;
			}

		// Now, look for the wave device that is already open
		// that's the one wave mapper picked up
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				{
				uDeviceId = i;
				goto MyExit;
				}
			else
				if (hWave)
				{
					waveOutClose((HWAVEOUT)hWave);
					hWave = (HWAVE)NULL;
				}
		}
	}

MyExit:
	if (!uInOrOut)
	{
		if (hWave) waveInClose((HWAVEIN)hWave);
		if (hWaveMapper) waveInClose((HWAVEIN)hWaveMapper);
	}
	else
	{
		if (hWave) waveOutClose((HWAVEOUT)hWave);
		if (hWaveMapper) waveOutClose((HWAVEOUT)hWaveMapper);
	}

	return(uDeviceId);
}

UINT CheckForWaveDeviceSupport(UINT uWaveDevId, UINT uInOrOut)
{
	MMRESULT		mmr;

	// querying isn't good enough, always directly open the device
	// to see if it supports a given format
	
	if (!uInOrOut)
	{
		waveInDev	WaveIn(uWaveDevId);

		if (uWaveDevId != WAVE_MAPPER)
			WaveIn.AllowMapper(FALSE);

		mmr = WaveIn.Open(8000,16);
		if (mmr == WAVERR_BADFORMAT)
		{
			mmr = WaveIn.Open(8000,8);
			if (mmr == WAVERR_BADFORMAT)
			{
				mmr = WaveIn.Open(11025, 16);
				if (mmr == WAVERR_BADFORMAT)
				{
					mmr = WaveIn.Open(22050, 16);
					if (mmr == WAVERR_BADFORMAT)
					{
						mmr = WaveIn.Open(44100, 16);
					}
				}
			}
		}
	}
					
	else  // waveOut
	{
		waveOutDev	WaveOut(uWaveDevId);

		if (uWaveDevId != WAVE_MAPPER)
			WaveOut.AllowMapper(FALSE);

		mmr = WaveOut.Open(8000,16);
		if (mmr == WAVERR_BADFORMAT)
		{
			mmr = WaveOut.Open(8000,8);
			if (mmr == WAVERR_BADFORMAT)
			{
				mmr = WaveOut.Open(11025, 16);
				if (mmr == WAVERR_BADFORMAT)
				{
					mmr = WaveOut.Open(22050, 16);
					if (mmr == WAVERR_BADFORMAT)
					{
						mmr = WaveOut.Open(44100, 16);
					}
				}
			}
		}
	}
					
	// go ahead and allow the device to pass if it's in use
	if ((mmr == MMSYSERR_ALLOCATED) || (mmr == MMSYSERR_NOERROR))
		return TRUE;

	else
		return FALSE;

	// destructors for waveOut and waveIn will call Close()
}

UINT CheckForAgc(UINT uWaveInDevId)
{

	CMixerDevice	*pMixDev;
	UINT			uRet = SOUNDCARD_NONE;
	BOOL			fAgc;
	
	pMixDev = CMixerDevice::GetMixerForWaveDevice(
			NULL,
			uWaveInDevId,
			MIXER_OBJECTF_WAVEIN);
	//SS: we need to correlate the uDevId to mixer id
	if (pMixDev)
	{
		uRet = SOUNDCARD_PRESENT;
		if (pMixDev->GetAGC(&fAgc))
			uRet = SOUNDCARD_HAVEAGC;

		delete pMixDev;
	}
	return (uRet);
}






// This function is here to allow the help system to invoke
// the wizard via rundll32

void WINAPI RunAudioWiz(HWND hwndStub, HINSTANCE hInst, LPSTR lpszCmdLine, int CmdShow )
{
	IntCreateAudioCalibWizard(hwndStub, RUNDUE_USERINVOKED, WAVE_MAPPER,
		NULL, READFROM_REGISTRY);
}


static void PaintVUMeter (HWND hwnd, DWORD dwVolume)
{
	COLORREF RedColor = RGB(255,0,0);
	COLORREF YellowColor = RGB(255,255,0);
	COLORREF GreenColor = RGB(0,255,0);
	static DWORD dwPrevVolume=0;
	HBRUSH	hRedBrush, hOldBrush, hYellowBrush, hGreenBrush;
	HBRUSH	hBlackBrush, hCurrentBrush;
	HDC		hdc;
	RECT	rect, rectDraw, invalidRect;
	DWORD	width, boxwidth, startPos=0;
	DWORD nRect=0, yellowPos, redPos;
	LONG lDiff, lDiffTrunc = (MAX_VOLUME_NORMALIZED/2);


	// rect gets filled with the dimensions we are drawing into
	if (FALSE == GetClientRect (hwnd, &rect))
	{
		return;
	}

	// we expect volume to be between 0-32768
	if (dwVolume > MAX_VOLUME)
		dwVolume = MAX_VOLUME;

	// reduce from 15 bits to 8    // 0 <= dwVolume <= 256
	dwVolume = dwVolume / 128;

	// run it through the "normalizing" table.  Special case: F(256)==256
	if (dwVolume < MAX_VOLUME_NORMALIZED)
		dwVolume = g_VUTable[dwVolume];
	
	// visual aesthetic #1 - get rid of VU jerkiness
	// if the volume changed by more than 1/2 since the last update
	// only move the meter up half way
   // exception: if volume is explicitly 0, then skip
	lDiff = (LONG)dwVolume - (LONG)dwPrevVolume;
	if ((dwVolume != 0) && ( (lDiff > (MAX_VOLUME_NORMALIZED/2))
                       ||   (lDiff < -(MAX_VOLUME_NORMALIZED/2)) ))
		dwVolume = dwVolume - (lDiff/2);
	
	// minus 2 for the ending borders
	// if Framed rectangles are used, drop the -2
	boxwidth = rect.right - rect.left - 2;
	width = (boxwidth * dwVolume)/ MAX_VOLUME_NORMALIZED;

	// visual aesthetic #2 - to get rid of flicker
	// if volume has increased since last time
	// then there is no need to invalidate/update anything
	// otherwise only clear everything to the right of the
	// calculated "width".  +/- 1 so the border doesn't get erased
	if ((dwVolume < dwPrevVolume) || (dwVolume == 0))
	{
		invalidRect.left = rect.left + width - RECTANGLE_WIDTH;
		if (invalidRect.left < rect.left)
			invalidRect.left = rect.left;
		invalidRect.right = rect.right - 1;
		invalidRect.top = rect.top + 1;
		invalidRect.bottom = rect.bottom - 1;

		// these calls together erase the invalid region
		InvalidateRect (hwnd, &invalidRect, TRUE);
		UpdateWindow (hwnd);
	}

	hdc = GetDC (hwnd) ;

	hRedBrush = CreateSolidBrush (RedColor) ;
	hGreenBrush = CreateSolidBrush(GreenColor);
	hYellowBrush = CreateSolidBrush(YellowColor);

	hBlackBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
	hOldBrush = (HBRUSH) SelectObject (hdc, hBlackBrush);

	// draw the main
	FrameRect(hdc, &rect, hBlackBrush);

	yellowPos = boxwidth/2;
	redPos = (boxwidth*3)/4;

	SelectObject(hdc, hGreenBrush);

	hCurrentBrush = hGreenBrush;

	rectDraw.top = rect.top +1;
	rectDraw.bottom = rect.bottom -1;
	while ((startPos+RECTANGLE_WIDTH) < width)
	{
		rectDraw.left = rect.left + (RECTANGLE_WIDTH+RECTANGLE_LEADING)*nRect + 1;
		rectDraw.right = rectDraw.left + RECTANGLE_WIDTH;
		nRect++;

		FillRect(hdc, &rectDraw, hCurrentBrush);
		startPos += RECTANGLE_WIDTH+RECTANGLE_LEADING;

		if (startPos > redPos)
			hCurrentBrush = hRedBrush;
		else if (startPos > yellowPos)
			hCurrentBrush = hYellowBrush;
	}

	SelectObject (hdc, hOldBrush);
	DeleteObject(hRedBrush);
	DeleteObject(hYellowBrush);
	DeleteObject(hGreenBrush);
	ReleaseDC (hwnd, hdc) ;

	dwPrevVolume = dwVolume;
	return;
}

static DWORD ComputePower(SHORT *wBuffer, DWORD dwNumSamples, AUDIO_POWER *pAudioPower)
{
	DWORD dwIndex, dwTotal;
	LONG dcComponent;
	SHORT val;
	DWORD dwVal;

	ZeroMemory(pAudioPower, sizeof(AUDIO_POWER));
	pAudioPower->dwMin = MAX_VOLUME; // 32768

	dwTotal = 0;
	dcComponent = 0;

	for (dwIndex = 0; dwIndex < dwNumSamples; dwIndex++)
	{
		val = wBuffer[dwIndex];
		dwVal = SHABS(val);
		dwTotal += dwVal;
		dcComponent += val;

		if (dwVal > pAudioPower->dwMax)
			pAudioPower->dwMax = dwVal;
		if (dwVal < pAudioPower->dwMin)
			pAudioPower->dwMin = dwVal;
	}

	pAudioPower->lDcComponent = dcComponent / (LONG)dwNumSamples;
	pAudioPower->dwAvg = dwTotal / dwNumSamples;

	return pAudioPower->dwAvg;
}





// given a pointer to a wave In device, and a list of WAVEHDR structs
// each wave header is prepared (if needed) and fed to wavein
MMRESULT PostFreeBuffers(waveInDev *pWaveInDev, WAVEHDR *aWaveHdrs, int numBuffers, DWORD *pdwCount)
{
	int nIndex;
	MMRESULT mmr=MMSYSERR_NOERROR;
	bool bNeedToPrepare;

	// first time through - the dwUser field of all wave headers
	// will be zero.  Just look a the first header in the list
	// to figure this out.

	if (numBuffers < 1)
	{
		ASSERT(false);
		return MMSYSERR_ERROR;
	}

	bNeedToPrepare = (aWaveHdrs[0].dwUser == 0);

	if (bNeedToPrepare)
	{
		for (nIndex = 0; nIndex < numBuffers; nIndex++)
		{
			mmr = pWaveInDev->PrepareHeader(&aWaveHdrs[nIndex]);

			if (mmr != MMSYSERR_NOERROR)
			{
				return mmr;
			}

			// so that the code below works ok, just mark the done
			// bit on the wave headers

			aWaveHdrs[nIndex].dwFlags |= WHDR_DONE;
		}
	}


	// for each wave header passed in that has the "done" bit set
	// repost to wavein

	for (nIndex = 0; nIndex < numBuffers; nIndex++)
	{
		if (aWaveHdrs[nIndex].dwFlags & WHDR_DONE)
		{
			aWaveHdrs[nIndex].dwFlags &= ~(WHDR_DONE | WHDR_INQUEUE);
			aWaveHdrs[nIndex].dwFlags |= WHDR_PREPARED;

			*pdwCount = (*pdwCount) + 1;
			if (*pdwCount == 0)
			{
				*pdwCount = 1;
			}

			aWaveHdrs[nIndex].dwUser = *pdwCount;

			mmr = pWaveInDev->Record(&aWaveHdrs[nIndex]);
		}
	}

	return mmr;

}




// scan the array of wave headers for "done" buffers
// return the most recently posted buffer (if any)

BYTE *GetLatestBuffer(WAVEHDR *aWaveHdrs, int numBuffers)
{
	DWORD_PTR dwUserHigh=0;
	int nIndexHigh=0;
	int nIndex;


	for (nIndex = 0; nIndex < numBuffers; nIndex++)
	{
		if (aWaveHdrs[nIndex].dwFlags & WHDR_DONE)
		{
			if (aWaveHdrs[nIndex].dwUser > dwUserHigh)
			{
				dwUserHigh = aWaveHdrs[nIndex].dwUser;
				nIndexHigh = nIndex;
			}
		}
	}

	if (dwUserHigh > 0)
	{
		return (BYTE*)(aWaveHdrs[nIndexHigh].lpData);
	}

	return NULL;

}





static DWORD CALLBACK CalibrateTalking(PVOID pVoid)
{
	const int SIZE_WAVEIN_BUFFER = 1600; // 100ms @ 8khz, 16-bit
	const int NUM_WAVEIN_BUFFERS = 5;
	WaveBufferList waveList(NUM_WAVEIN_BUFFERS, SIZE_WAVEIN_BUFFER);
	WAVEHDR aWaveHdrs[NUM_WAVEIN_BUFFERS];

	HWND hVUMeter, hDlg;
	HANDLE hEvent;
	MMRESULT mmr;
	DWORD dwPow, dwRet, dwExitCode=0;
	AUDIO_POWER audioPower;
	CALIB_DISPLAY *pCalibDisplay;
	TCHAR szText[ATW_MSG_LENGTH];
	BOOL fOpened = TRUE;
	BOOL fSoundDetected = FALSE;
	int nRecordCount = 0, nIndex;
	DWORD dwBufferIndex = 1;
	SHORT *buffer;


	HANDLE hEventRecord = CreateEvent(NULL, TRUE, FALSE, NULL);

	waveInDev waveIn(((CALIB_DISPLAY *)pVoid)->uWaveInDevId, hEventRecord);

	pCalibDisplay = (CALIB_DISPLAY *)pVoid;
	hVUMeter = pCalibDisplay->hVUMeter;
	hDlg = pCalibDisplay->hDlg;
	hEvent = pCalibDisplay->hEvent;

	ASSERT(hEvent);


	mmr = waveIn.Open(8000,16);
	if (mmr == MMSYSERR_ALLOCATED)
	{
		FLoadString(IDS_RECORD_ERROR, szText, CCHMAX(szText));
		SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, szText);
		fOpened = FALSE;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
		CloseHandle(hEvent);
		CloseHandle(hEventRecord);
		return -1;
	}
	else
	{
		SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, "");
		ResetEvent(hEventRecord);
	}


	// initialize the array of wavehdrs
	for (nIndex=0; nIndex < NUM_WAVEIN_BUFFERS; nIndex++)
	{
		ZeroMemory(&aWaveHdrs[nIndex], sizeof(WAVEHDR));
		aWaveHdrs[nIndex].lpData = (LPSTR)(waveList.GetBuffer(nIndex));
		aWaveHdrs[nIndex].dwBufferLength = SIZE_WAVEIN_BUFFER;
	}


	while (1)
	{

		// is it time to exit ?
		dwRet = WaitForSingleObject(hEvent, 0);
		if (dwRet == WAIT_OBJECT_0)
		{
			dwExitCode = 0;
			break;
		}

		// if we still haven't opened the device
		// keep trying

		if (fOpened == FALSE)
		{
			mmr = waveIn.Open(8000,16);
			if (mmr == MMSYSERR_ALLOCATED)
			{
				PaintVUMeter(hVUMeter, 0); // draw a blank rectangle
				Sleep(500);
				continue;
			}

			if (mmr != MMSYSERR_NOERROR)
			{
				PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
				dwExitCode = (DWORD)(-1);
				break;
			}

			// mmr == noerror
			SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, TEXT(""));
			fOpened = TRUE;
			ResetEvent(hEventRecord);
		}

		// wave device is open at this point

		mmr = PostFreeBuffers(&waveIn, aWaveHdrs, NUM_WAVEIN_BUFFERS, &dwBufferIndex);
		if (mmr != MMSYSERR_NOERROR)
		{
			PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
			dwExitCode = (DWORD) -1;
			break;
		}

		WaitForSingleObject(hEventRecord, 5000);
		ResetEvent(hEventRecord);

		buffer = (SHORT*)GetLatestBuffer(aWaveHdrs, NUM_WAVEIN_BUFFERS);

		if (buffer)
		{
			nRecordCount++;

			dwPow = ComputePower(buffer, SIZE_WAVEIN_BUFFER/2, &audioPower);

			// don't update the meter for the first 200ms.
			// "noise" from opening the soundcard tends to show up
			if (nRecordCount > 2)
			{
				PaintVUMeter(hVUMeter, audioPower.dwMax);

				// signal back to the calling window (if it hasn't already),
				// that the silence threshold was broken
				if ((fSoundDetected == FALSE) && (audioPower.dwMax > SILENCE_THRESHOLD))
				{
					PostMessage(hDlg, WM_AUDIOTHREAD_SOUND, 0,0);
					fSoundDetected = TRUE;
				}

				// check for clipping, post message back to parent thread/window
				// so that it will adjust the volume
				if (audioPower.dwMax > CLIPPINGVOL)
				{
					// should we use send message instead ?
					PostMessage(hDlg, WM_AUDIO_CLIPPING,0,0);
				}
			}
			else
				PaintVUMeter(hVUMeter, 0);

		}
	}

	waveIn.Reset();

	for (nIndex = 0; nIndex < NUM_WAVEIN_BUFFERS; nIndex++)
	{
		waveIn.UnPrepareHeader(&aWaveHdrs[nIndex]);
	}

	waveIn.Close();

	CloseHandle(hEvent);
	CloseHandle(hEventRecord);

	TRACE_OUT(("ATW: Recording Thread Exit\r\n"));

	return dwExitCode;

}




// Turns on AGC if needed
// parameter is whatever pawInfo->iSetAgc is.
// but it's probably been hardcoded to be READFROM_REGISTRY
static BOOL StartAGC(CMixerDevice *pMixer, BOOL iSetAgc, UINT uSoundCardCaps)
{
	BOOL bSet, bRet;

	if (iSetAgc == READFROM_REGISTRY)
	{
		if (DOESSOUNDCARDHAVEAGC(uSoundCardCaps))
		{
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			bSet = (BOOL)( re.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );
		}
		else
		{
			bSet = FALSE; 		
		}
	}
	else
	{
		bSet = (iSetAgc != 0);
	}
	

	bRet = pMixer->SetAGC(bSet);	

	if (bSet == FALSE)
		return FALSE;

	return bRet;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\call.cpp ===
// File: call.cpp

#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "dlgcall.h"
#include "confapi.h"
#include "popupmsg.h"
#include "passdlg.h"
#include "chcondlg.h"
#include "dshowdlg.h"

#include "conf.h"
#include "calllog.h"
#include "rostinfo.h"
#include "..\..\core\cncodes.h"  // for CN_* codes
#include <inodecnt.h> // for UI_RC_...
#include "cr.h" 	  // for CreateConfRoomWindow, UpdateUI
#include "confroom.h"
#include "confman.h"
#include "NmLdap.h"
#include "nmremote.h"
#include <tsecctrl.h>
#include "ConfPolicies.h"
#include "StatBar.h"
#include "certui.h"
#include "cmd.h"
#include "callto.h"
#include "dlgacd.h"

// External SDK stuff...
#include "NmCall.h"
#include "NmApp.h"


COBLIST * g_pCallList = NULL;  // Global list of calls in progress
extern INmSysInfo2 * g_pNmSysInfo;

static HRESULT OnUIRemotePassword(BSTR bstrConference, BSTR *pbstrPassword, LPCTSTR pCertText, BOOL fIsService);

extern BOOL FRejectIncomingCalls(void);
extern BOOL FIsConfRoomClosing(void);
extern GUID g_csguidSecurity;
extern GUID g_csguidMeetingSettings;

/*	C  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: CCall
	
-------------------------------------------------------------------------*/
CCall::CCall(LPCTSTR pszCallTo, LPCTSTR pszDisplayName, NM_ADDR_TYPE nmAddrType, BOOL bAddToMru, BOOL fIncoming) :
	RefCount(NULL),
	m_fIncoming 	   (fIncoming),
	m_pszDisplayName	(PszAlloc(pszDisplayName)),
	m_pszCallTo 	(PszAlloc(pszCallTo)),
	m_nmAddrType	(nmAddrType),
	m_bAddToMru 	(bAddToMru),
	m_fSelectedConference (FALSE),
	 m_pDlgCall 	 (NULL),
	m_pInternalICall(NULL),
	m_pos			(NULL),
	m_dwCookie		(0),
	m_ppm			 (NULL),
	m_fInRespond		(FALSE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CCall", this);

	if (FEmptySz(m_pszDisplayName))
	{
		delete m_pszDisplayName;

		// Default to "another person" if no name available in the call data
		m_pszDisplayName = PszLoadString(IDS_UNKNOWN_PERSON);
	}

	m_dwTick = ::GetTickCount();

	DbgMsgCall("CCall: %08X Created Name=[%s] CallTo=[%s]",
		this, m_pszDisplayName, m_pszCallTo ? m_pszCallTo : _TEXT("<NULL>"));

	// add it to the global call list
	if (NULL == g_pCallList)
	{
		g_pCallList = new COBLIST;
		if (NULL == g_pCallList)
		{
			ERROR_OUT(("CCall::CCall - unable to allocate g_pCallList"));
			return;
		}
	}
	m_pos = g_pCallList->AddTail(this);

}

CCall::~CCall()
{
	DBGENTRY(CCall::~CCall);

	RemoveFromList();

	delete m_pszDisplayName;
	delete m_pszCallTo;

	if(m_pInternalICall)
	{
		m_pInternalICall->Release();
		m_pInternalICall = NULL;
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CCall", this);
	
	DBGEXIT(CCall::~CCall);
}


/*	S E T  N M	C A L L  */
/*-------------------------------------------------------------------------
	%%Function: SetNmCall
	
-------------------------------------------------------------------------*/
VOID CCall::SetNmCall(INmCall * pCall)
{
	ASSERT(NULL != pCall);
	ASSERT((!m_pInternalICall) || (m_pInternalICall == pCall));
		
	if(!m_pInternalICall)
	{
		pCall->AddRef();		
		m_pInternalICall = pCall;
	}

	if(!m_dwCookie)
	{
		NmAdvise(m_pInternalICall, this, IID_INmCallNotify2, &m_dwCookie);
	}

	Update();
}


BOOL CCall::RemoveFromList(void)
{
	// Remove the call from the global list
	if (NULL == m_pos)
		return FALSE;

	ASSERT(NULL != g_pCallList);
	CCall * pCall = (CCall *) g_pCallList->RemoveAt(m_pos);
	ASSERT(this == pCall);
	
	m_pos = NULL;

	if(m_pInternalICall)
	{
		NmUnadvise(m_pInternalICall, IID_INmCallNotify2, m_dwCookie);
		m_dwCookie = NULL;
	}

	return TRUE;
}

VOID CCall::Cancel(BOOL fDisplayCancelMsg)
{
	if (!FComplete())
	{
		if (fDisplayCancelMsg & !FIncoming())
		{
			DisplayPopup();  // Inform the user with a small popup message
		}
		if (m_pInternalICall)
		{
			m_pInternalICall->Cancel();
		}

		Update();
	}
}			



///////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CCall::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCallNotify2) || (riid == IID_INmCallNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmCallNotify2 *)this;
		ApiDebugMsg(("CCall::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// INmCallNotify methods

STDMETHODIMP CCall::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CCall::StateChanged(NM_CALL_STATE uState)
{
	Update();

	return S_OK;
}

STDMETHODIMP CCall::Failed(ULONG uError)
{
	DbgMsgCall("CCall: %08X Failed uError=%d", this, uError);
	return S_OK;
}

STDMETHODIMP CCall::Accepted(INmConference *pConference)
{
	DbgMsgCall("CCall: %08X Accepted pConference=0x%08X", this, pConference);
	return S_OK;
}


VOID CCall::ShowProgress(BOOL fShow)
{
	if (NULL == m_pDlgCall)
		return;

	ShowWindow(m_pDlgCall->GetHwnd(), fShow ? SW_SHOWNORMAL : SW_HIDE);
}


VOID CCall::RemoveProgress(void)
{
	if (NULL == m_pDlgCall)
		return;

	m_pDlgCall->Destroy();
	m_pDlgCall->Release();
	m_pDlgCall = NULL;
}

/*	C A L L  E R R O R	*/
/*-------------------------------------------------------------------------
	%%Function: CallError
	
-------------------------------------------------------------------------*/
STDMETHODIMP CCall::CallError(UINT cns)
{
	UINT ids = 0;

	ShowProgress(FALSE);

	ASSERT(m_pInternalICall != NULL);
	DbgMsgCall("CCall: %08X CallError cns=%08X", this, cns);

	// Translate cns to normal error message
	switch (cns)
	{
	case CN_RC_NAME_RESOLUTION_FAILED:
		ids = IDS_RESOLVE_FAILED;
		break;

	case CN_RC_CONNECT_FAILED:
	case CN_RC_AUDIO_CONNECT_FAILED:
		ids = IDS_COULD_NOT_CONNECT;
		break;
		
	case CN_RC_CONNECT_REMOTE_NO_SECURITY:
			ids = IDS_CONNECT_REMOTE_NO_SECURITY;
		break;

	case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
			ids = IDS_CONNECT_REMOTE_DOWNLEVEL_SECURITY;
		break;

	case CN_RC_CONNECT_AUTHENTICATION_FAILED:
		ids = IDS_CONNECT_AUTHENTICATION_FAILED;
		break;

	case CN_RC_SECURITY_FAILED:
		ids = IDS_CONNECT_SECURITY_FAILED;
		break;

	case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
		ids = IDS_CONNECT_REMOTE_REQUIRE_SECURITY;
		break;
		
	case CN_RC_CONFERENCE_JOIN_DENIED:
		ids = IDS_JOIN_DENIED;
		break;
		
	case CN_RC_CONFERENCE_INVITE_DENIED:
		ids = IDS_INVITE_DENIED;
		break;
		
	case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
		ids = IDS_INVITE_DENIED_REMOTE_CONF;
		break;
		
	case CN_RC_CONFERENCE_DOES_NOT_EXIST:
		ids = m_fSelectedConference ?
			IDS_CONFERENCE_DOES_NOT_EXIST : IDS_CONFERENCE_ENDED_BEFORE_JOIN;
		break;
		
	case CN_RC_CONFERENCE_ENDED_BEFORE_JOIN:
		// REVIEW: This is no longer sent?
		ids = IDS_CONFERENCE_ENDED_BEFORE_JOIN;
		break;
		
	case CN_RC_AUDIO_NOT_AVAILABLE:
		ids = IDS_AUDIO_NOT_AVAILABLE;
		break;
		
	case CN_RC_AUDIO_FAILED_AFTER_DATA:
		ids = IDS_AUDIO_FAILED_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_REMOTE_AFTER_DATA:
		ids = IDS_AUDIO_IN_USE_REMOTE_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_REMOTE:
		ids = IDS_AUDIO_IN_USE_REMOTE;
		break;
		
	case CN_RC_AUDIO_IN_USE_LOCAL_AFTER_DATA:
		ids = IDS_AUDIO_IN_USE_LOCAL_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_LOCAL:
		ids = IDS_AUDIO_IN_USE_LOCAL;
		break;
		
	case CN_RC_CANT_INVITE_MCU:
		ids = IDS_CANT_INVITE_MCU;
		break;
		
	case CN_RC_REMOTE_PLACING_CALL:
		ids = IDS_REMOTE_PLACING_CALL;
		break;
		
	case CN_RC_TRANSPORT_FAILURE:
		ids = IDS_TRANSPORT_UNAVAILABLE;
		break;

	case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
		ids = IDS_INCALL_JOIN_FAILED;
		break;

	case CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED:
		ids = IDS_INVITE_CONF_ENDED;
		break;

	case CN_RC_GK_CALLEE_NOT_REGISTERED:
		ids = IDS_GK_CALLEE_NOT_REGISTERED;
		break;

	case CN_RC_GK_TIMEOUT:
		ids = IDS_GK_TIMEOUT;
		break;

	case CN_RC_GK_REJECTED:
		ids = IDS_GK_REJECTED;
		break;

	case CN_RC_GK_NOT_REGISTERED:
		ids = IDS_GK_NOT_REGISTERED;
		break;

	default:
		return S_FALSE;
	} /*  switch (cns) */

	DisplayMsgIdsParam(ids, m_pszDisplayName);
	return S_OK;
}


STDMETHODIMP CCall::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
	return OnUIRemoteConference(fMCU, (PWSTR *)pwszConfNames, pbstrConfToJoin);
}

STDMETHODIMP CCall::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, PBYTE pb, DWORD cb, BOOL fIsService)
{
	TCHAR* pLastCertText = NULL;
	if (NULL != pb) {
		ASSERT(cb > 0);
	if (!(pLastCertText = FormatCert(pb, cb)))
		{
			ERROR_OUT(("FormatCert failed"));
		}
	}

	ShowProgress(FALSE);
	HRESULT hr = OnUIRemotePassword(bstrConference, pbstrPassword, pLastCertText, fIsService);
	if (pLastCertText) delete pLastCertText;
	return hr;
}

NM_CALL_STATE CCall::GetState()
{
	NM_CALL_STATE callState = NM_CALL_INVALID;

	if(m_pInternalICall)
	{
		m_pInternalICall->GetState(&callState);
	}

	return callState;
}

/*	U P D A T E  */
/*-------------------------------------------------------------------------
	%%Function: Update

	Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CCall::Update(void)
{
	DBGENTRY(CCall::Update);
	
	NM_CALL_STATE callState = GetState();;

	switch (callState)
	{
		case NM_CALL_CANCELED:
		case NM_CALL_ACCEPTED:
		case NM_CALL_REJECTED:
			// Remove the call from the global list because we'll never get
			// any more notifications for this.
			if (RemoveFromList())
			{
				if (FIncoming())
				{
					if ((NM_CALL_CANCELED == callState) && (NULL != m_ppm))
					{
						//
						// if m_fInRespond is set then we've already
						// dismissed the dialog and the call is being
						// cancelled because we discovered the underlying
						// connection is gone.
						//

						if ( !m_fInRespond )
						{
							delete m_ppm;
							m_ppm = NULL;

							// Release the lock added by OnRing
							Release();
						}
					}
					LogCall(NM_CALL_ACCEPTED == callState);
				}
				else
				{
					RemoveProgress();

					if (NM_CALL_ACCEPTED == callState)
					{

						if(m_bAddToMru)
						{
							CAcdMru CallList;
							CallList.AddEntry(m_pszDisplayName, m_pszCallTo,  m_nmAddrType);
							CallList.Save();
						}
					}
				}

				// Release the initial lock on this object
				Release();
			}
			break;

		case NM_CALL_RING:
			OnRing();
			break;

		case NM_CALL_SEARCH:
			ASSERT(NULL == m_pDlgCall);
			m_pDlgCall = new CDlgCall(this);
			break;

		case NM_CALL_WAIT:
			if (NULL != m_pDlgCall)
			{
				m_pDlgCall->OnStateChange();
			}
			break;

		default:
			ERROR_OUT(("CCall::Update: Unknown state %08X", callState));

		case NM_CALL_INVALID:
		case NM_CALL_INIT:
			break;
	}

	::UpdateUI(CRUI_CALLANIM | CRUI_TOOLBAR | CRUI_STATUSBAR);

	DBGEXIT(CCall::Update);
}


/*	F  C O M P L E T E	*/
/*-------------------------------------------------------------------------
	%%Function: FComplete
	
	Return TRUE if the call has completed
-------------------------------------------------------------------------*/
BOOL CCall::FComplete(void)
{
	switch (GetState())
		{
	case NM_CALL_ACCEPTED:
	case NM_CALL_REJECTED:
	case NM_CALL_CANCELED:
		return TRUE;

	case NM_CALL_INVALID:
	case NM_CALL_INIT:
	case NM_CALL_RING:
	case NM_CALL_SEARCH:
	case NM_CALL_WAIT:
	default:
		return FALSE;
		}
}

/*	P O P U P  M S G  R I N G I N G  C A L L B A C K  */
/*-------------------------------------------------------------------------
	%%Function: CCall::PopupMsgRingingCallback

-------------------------------------------------------------------------*/


VOID CALLBACK CCall::PopupMsgRingingCallback(LPVOID pContext, DWORD dwFlags)
{
	CCall *pCall = (CCall *) pContext;
	ASSERT(NULL != pCall);

	DbgMsgCall("CCall: %08X Responding from invite popup - result is 0x%08X", pCall, dwFlags);
	DWORD dwCLEF;

	if(!( PMF_KILLED & dwFlags ))
	{
		dwCLEF = (PMF_OK & dwFlags) ? CLEF_ACCEPTED : CLEF_REJECTED;

		if (PMF_TIMEOUT & dwFlags)
		{
			dwCLEF |= CLEF_TIMED_OUT;
		}

		pCall->RespondToRinging(dwCLEF);
	}

	if(pCall->m_ppm)
	{
		// pop up message will be destroyed after callback returns
		pCall->m_ppm = NULL;

		// Release the lock added by OnRing
		pCall->Release();
	}
}


/*	O N  R I N G  */
/*-------------------------------------------------------------------------
	%%Function: OnRing

	Handling an incoming call that just started to "ring".
-------------------------------------------------------------------------*/
VOID CCall::OnRing(void)
{
	DbgMsgCall("CCall: %08X OnRing", this);
	
	if (FRejectIncomingCalls())
	{
		// Respond negatively
		WARNING_OUT(("Rejecting invite - not listening or sys pol disabled"));
		RespondToRinging(CLEF_REJECTED);
		return;
	}

	if( ConfPolicies::IsAutoAcceptCallsEnabled() && !_Module.InitControlMode())
	{
		// Respond with success
		RespondToRinging(CLEF_ACCEPTED | CLEF_AUTO_ACCEPTED);
		return;
	}

	if(!_Module.InitControlMode())
	{
		// Display a message for the user

		TCHAR szFormatBuf[MAX_PATH];
		TCHAR szMsgBuf[MAX_PATH];

		if (FLoadString(IDS_INVITE_PERMISSION, szFormatBuf, CCHMAX(szFormatBuf)))
		{
			TCHAR szName[MAX_PATH];
			LPTSTR psz = m_pszDisplayName;
			if (FEmptySz(psz))
			{
				// The name string is blank, so fill it in with a default:
				::LoadString(::GetInstanceHandle(), IDS_UNKNOWN_PERSON,
								szName, CCHMAX(szName));
				psz = szName;
			}
			wsprintf(szMsgBuf, szFormatBuf, psz);
		}

		ASSERT(NULL == m_ppm);
		m_ppm = new CPopupMsg(PopupMsgRingingCallback, this);
		if (NULL != m_ppm)
		{
			RegEntry re(UI_KEY, HKEY_CURRENT_USER);
			UINT uTime = re.GetNumber(REGVAL_RING_TIMEOUT, DEFAULT_RING_TIMEOUT) * 1000;
			
			AddRef(); // Released in PopupMsgRingingCallback
			m_ppm->CreateDlg(szMsgBuf, TRUE, MAKEINTRESOURCE(IDI_CONFROOM),
				::GetInstanceHandle(), IDS_INVITE_SOUND, uTime);
		}
	}
}

/*	R E S P O N D  T O	R I N G I N G  */
/*-------------------------------------------------------------------------
	%%Function: RespondToRinging
	
-------------------------------------------------------------------------*/
BOOL CCall::RespondToRinging(DWORD dwCLEF)
{
	BOOL fAccept = FALSE;
	m_fInRespond = TRUE;
	
	if (NM_CALL_RING == GetState())
	{
		if (!FIsConfRoomClosing() && (CLEF_ACCEPTED & dwCLEF))
		{
			fAccept = TRUE;
			if(_Module.IsUIActive())
			{
				CConfRoom * pcr = ::GetConfRoom();
				ASSERT(pcr);
				pcr->BringToFront();
			}
		}

		CNmCallObj::StateChanged(m_pInternalICall, fAccept ? NM_CALL_ACCEPTED : NM_CALL_REJECTED);

		if (fAccept)
		{
			m_pInternalICall->Accept();
		}
		else
		{
			m_pInternalICall->Reject();
		}
	}
	else
	{
		CallError(CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED);
	}

	m_fInRespond = FALSE;
	return fAccept;
}


/*	D I S P L A Y  P O P U P  */
/*-------------------------------------------------------------------------
	%%Function: DisplayPopup
	
-------------------------------------------------------------------------*/
VOID CCall::DisplayPopup(void)
{
	CPopupMsg* ppm = new CPopupMsg(NULL);
	if (NULL == ppm)
		return;
		
	TCHAR szMsg[MAX_PATH*2];
	if (FLoadString1(IDS_CALL_CANCELED_FORMAT, szMsg, m_pszDisplayName))
	{
		ppm->Create(szMsg, FALSE, MAKEINTRESOURCE(IDI_CONFROOM),
				::GetInstanceHandle(), IDS_PERSON_LEFT_SOUND,
				ROSTER_TIP_TIMEOUT);
	}
	else
	{
		delete ppm;
	}

}

/*	P L A C E  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: PlaceCall

	Place an outgoing call.
-------------------------------------------------------------------------*/
HRESULT
CCall::PlaceCall
(
	DWORD dwFlags,
	NM_ADDR_TYPE addrType,
	const TCHAR * const    setupAddress,
	const TCHAR * const    destinationAddress,
	const TCHAR * const    alias,
	const TCHAR * const    url,
	const TCHAR * const conference,
	const TCHAR * const password,
	const TCHAR * const    userData
){

	DBGENTRY(CCall::PlaceCall);
	
	HRESULT hr = E_FAIL;

	ASSERT(m_pInternalICall == NULL);

	INmManager2 *pNmMgr = CConfMan::GetNmManager();
	ASSERT (NULL != pNmMgr);

	hr = pNmMgr->CallEx(	&m_pInternalICall,
							dwFlags,
							addrType,
							CComBSTR( GetPszName() ),
							CComBSTR( setupAddress ),
							CComBSTR( destinationAddress ),
							CComBSTR( alias ),
							CComBSTR( url ),
							CComBSTR( conference ),
							CComBSTR( password ),
							CComBSTR( userData ) );

	if(m_pInternalICall && (CRPCF_JOIN & dwFlags) )
	{
		SetSelectedConference();
	}

	// Force an update of the status bar, animation, etc.
	::UpdateUI(CRUI_DEFAULT);

	pNmMgr->Release();

	TRACE_OUT(("CCall::PlaceCall(%s) result=%08X", m_pszCallTo? m_pszCallTo: g_szEmpty, hr));

	DBGEXIT_HR(CCall::PlaceCall, hr);
	return hr;
}


VOID CCall::LogCall(BOOL fAccepted)
{
	LPCTSTR pcszName = GetPszName();

	TCHAR szName[MAX_PATH];
	if (FEmptySz(pcszName))
	{
		if (FLoadString(IDS_UNKNOWN_PERSON, szName, CCHMAX(szName)))
			pcszName = szName;
	}

	LOGHDR logHdr;
	CRosterInfo ri;
	LPBYTE pb;
	ULONG cb;
	LPBYTE pbCert = NULL;
	ULONG cbCert = 0;
	
	if (SUCCEEDED(GetINmCall()->GetUserData(g_csguidRostInfo, &pb, &cb)))
	{
		ri.Load(pb);
	}
	
	GetINmCall()->GetUserData(g_csguidSecurity, &pbCert, &cbCert);
	
	DWORD dwCLEF = fAccepted ? CLEF_ACCEPTED : CLEF_REJECTED;
	if (ri.IsEmpty())
	{
		// No caller data - not NetMeeting
		dwCLEF |= CLEF_NO_CALL;
	}
	if (pbCert)
	{
		ASSERT(cbCert);
		dwCLEF |= CLEF_SECURE;
	}

	ZeroMemory(&logHdr, sizeof(LOGHDR));
	logHdr.dwCLEF = dwCLEF;

	if (NULL != ::GetIncomingCallLog() )
	{
		// Write the data to the log file
		::GetIncomingCallLog()->AddCall(pcszName, &logHdr, &ri, pbCert, cbCert);
	}
}


/*	C R E A T E  I N C O M I N G  C A L L  */
/*-------------------------------------------------------------------------
	%%Function: CreateIncomingCall

	Create an CCall object for the incoming call.
-------------------------------------------------------------------------*/
CCall * CreateIncomingCall(INmCall * pNmCall)
{
	HRESULT hr;
	BSTR  bstr;
	LPTSTR pszName = NULL;
	LPTSTR pszAddr = NULL;
	NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN;

	ASSERT(NULL != pNmCall);

	// Get the display name
	hr = pNmCall->GetName(&bstr);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&pszName, bstr);
		SysFreeString(bstr);
	}

	// Get the address and type
	hr = pNmCall->GetAddr(&bstr, &addrType);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&pszAddr, bstr);
		SysFreeString(bstr);
	}

	CCall * pCall = new CCall(pszAddr, pszName, NM_ADDR_CALLTO, FALSE, TRUE /* fIncoming */);

	delete pszName;
	delete pszAddr;

	return pCall;
}



///////////////////////////////////////////////////////////////////////////
// Global Functions



/*	C A L L  F R O M  N M  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: CallFromNmCall
	
-------------------------------------------------------------------------*/
CCall * CallFromNmCall(INmCall * pNmCall)
{
	if (NULL == g_pCallList)
		return NULL;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		if (pNmCall == pCall->GetINmCall())
		{
			return pCall;
		}
	}

	// no matching call?
	return NULL;
}


/*	F  I S	C A L L  I N  P R O G R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FIsCallInProgress

	Return TRUE if there is an incoming or outgoing call in progress.
-------------------------------------------------------------------------*/
BOOL FIsCallInProgress(void)
{
	if (NULL == g_pCallList)
		return FALSE;

	return !g_pCallList->IsEmpty();
}


/*	G E T  L A S T	O U T G O I N G  C A L L  */
/*-------------------------------------------------------------------------
	%%Function: GetLastOutgoingCall
	
-------------------------------------------------------------------------*/
CCall * GetLastOutgoingCall(void)
{
	if (NULL == g_pCallList)
		return NULL;

	CCall * pCall = NULL;
	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCallTemp = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCallTemp);
		if (!pCallTemp->FIncoming())
		{
			pCall = pCallTemp;
		}
	}

	return pCall;
}


/*	G E T  C A L L	S T A T U S  */
/*-------------------------------------------------------------------------
	%%Function: GetCallStatus

	Check the current call status and return a string for the status bar.
	Return 0 if no call information is available
-------------------------------------------------------------------------*/
DWORD GetCallStatus(LPTSTR pszStatus, int cchMax, UINT * puID)
{
	ASSERT(NULL != pszStatus);
	ASSERT(NULL != puID);
	ASSERT(cchMax > 0);

	*pszStatus = _T('\0');
	*puID = 0;

	CCall *pCall = GetLastOutgoingCall();
	if (NULL == pCall)
		return 0; // not in a call

	// Use the status info from the most recent connection attempt:
	switch (pCall->GetState())
		{
	case NM_CALL_INIT:
	{
		*puID = IDS_STATUS_SETTING_UP;
		break;
	}

	case NM_CALL_SEARCH:
	{
		*puID = IDS_STATUS_FINDING;
		break;
	}

	case NM_CALL_WAIT:
	{
		*puID = IDS_STATUS_WAITING;
		break;
	}

	default:
	{
		// unknown/useless call state
		return 0;
	}
		} /* switch */

	if (FEmptySz(pCall->GetPszName()))
	{
		return 0;
	}

	if (!FLoadString1(*puID, pszStatus, pCall->GetPszName()))
	{
		return 0;
	}

	return pCall->GetTickCount();
}


///////////////////////////////////////////////////////////////////////////
// TODO: Replace these with real connection points

/*	O N  U	I  C A L L	C R E A T E D  */
/*-------------------------------------------------------------------------
	%%Function: OnUICallCreated
	
-------------------------------------------------------------------------*/
HRESULT OnUICallCreated(INmCall *pNmCall)
{
	CCall * pCall;

	// Notify the API
	if (S_OK == pNmCall->IsIncoming())
	{
		pCall = CreateIncomingCall(pNmCall);
		if (NULL == pCall)
		{
			return S_FALSE;
		}
	}
	else
	{
		pCall = CallFromNmCall(pNmCall);
		if (NULL == pCall)
		{
			WARNING_OUT(("OnUiCallCreated: Unable to find outgoing call=%08X", pNmCall));
			return S_FALSE;
		}
	}
	pCall->SetNmCall(pNmCall);

	return S_OK;
}



HRESULT OnUIRemotePassword(BSTR bstrConference, BSTR * pbstrPassword, LPCTSTR pCertText, BOOL fIsService)
{
    HRESULT hr = S_FALSE;

    LPTSTR  szName;
    hr =  BSTR_to_LPTSTR (&szName, bstrConference);				        
    if (SUCCEEDED(hr))
    {
        CPasswordDlg dlgPw(::GetMainWindow(), szName, pCertText, fIsService);
        // Free resources
        //
        delete (szName);

        if (IDOK == dlgPw.DoModal())
        {
            TRACE_OUT(("password dialog complete (OK pressed)"));

            LPTSTR_to_BSTR(pbstrPassword, dlgPw.GetPassword());
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CCall::OnUIRemoteConference(BOOL fMCU, PWSTR* pwszConfNames, BSTR *pbstrConfToJoin)
{
	HRESULT hr = S_FALSE;

	ShowProgress(FALSE);

	// We bring up the "choose a conference" dialog
	// when calling an MCU or another node with more than
	// one "listed" conference
	CChooseConfDlg dlgChoose(::GetMainWindow(),    pwszConfNames);
	if (IDOK == dlgChoose.DoModal())
	{
		TRACE_OUT(("choose conference dialog complete (OK pressed)"));
		
		LPTSTR_to_BSTR(pbstrConfToJoin, dlgChoose.GetName());
		hr = S_OK;
		m_fSelectedConference = TRUE;
	}

	ShowProgress(TRUE);

	return hr;
}


/*	F R E E  C A L L  L I S T  */
/*-------------------------------------------------------------------------
	%%Function: FreeCallList

	Free any remaining calls
-------------------------------------------------------------------------*/
VOID FreeCallList(void)
{
	if (NULL == g_pCallList)
		return;

	while (!g_pCallList->IsEmpty())
	{
		CCall * pCall = (CCall *) g_pCallList->GetHead();
		WARNING_OUT(("FreeCallList: Orphan call=%08X", pCall));
		pCall->RemoveFromList();
		pCall->Release();
	}

	delete g_pCallList;
	g_pCallList = NULL;
}

/*	C A N C E L  A L L	O U T G O I N G  C A L L S	*/
/*-------------------------------------------------------------------------
	%%Function: CancelAllOutgoingCalls
	
-------------------------------------------------------------------------*/
VOID CancelAllOutgoingCalls(void)
{
	if (NULL == g_pCallList)
		return;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		if (!pCall->FIncoming())
		{
			// Cancel will release the call object.
			// Ensure that there is at least one reference.
			pCall->AddRef();
			pCall->Cancel(TRUE);
			pCall->Release();
		}
	}
}


/*	C A N C E L  A L L	C A L L S  */
/*-------------------------------------------------------------------------
	%%Function: CancelAllCalls
	
-------------------------------------------------------------------------*/
VOID CancelAllCalls(void)
{
	if (NULL == g_pCallList)
		return;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		// Cancel will release the call object.
		// Ensure that there is at least one reference.
		pCall->AddRef();
		pCall->Cancel(TRUE);
		pCall->Release();
	}
}


///////////////////////////////////////////////////////////////////////////
// IP Utilities

/*	F  L O C A L  I P  A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FLocalIpAddress

	Return TRUE if the parameter matches the local IP address.
-------------------------------------------------------------------------*/
BOOL FLocalIpAddress(DWORD dwIP)
{
	if (dwIP == 0x0100007F)
	{
		WARNING_OUT(("t-bkrav is trying to call himself"));
		return TRUE;
	}

	// Get own host name
	TCHAR sz[MAX_PATH];
	if (0 != gethostname(sz, CCHMAX(sz)))
	{
		WARNING_OUT(("FLocalIpAddress: gethostname failed? err=%s", PszWSALastError()));
		return FALSE;
	}

	HOSTENT * pHostInfo = gethostbyname(sz);
	if (NULL == pHostInfo)
	{
		WARNING_OUT(("FLocalIpAddress: gethostbyname failed? err=%s", PszWSALastError()));
		return FALSE;
	}

	return (dwIP == *(DWORD *) pHostInfo->h_addr);
}


/*	F  I P	A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FIpAddress

	Return TRUE if the string is in the form:  a.b.c.d
	where a,b,c,d < 256.

	Note that inet_addr returns success on strings like "55534" and "3102.550"

	FUTURE: Return the converted DWORD
-------------------------------------------------------------------------*/
BOOL FIpAddress(LPCTSTR pcsz)
{
	TCHAR ch;
	int cPeriods = 0;
	int uVal = 0;

	ASSERT(NULL != pcsz);
	while (_T('\0') != (ch = *pcsz++))
	{
		switch (ch)
		{
		case _T('0'):
		case _T('1'):
		case _T('2'):
		case _T('3'):
		case _T('4'):
		case _T('5'):
		case _T('6'):
		case _T('7'):
		case _T('8'):
		case _T('9'):
			uVal = (uVal *= 10) + (ch - _T('0'));
			if (uVal > 255)
				return FALSE;
			break;

		case _T('.'):
			cPeriods++;
			uVal = 0;
			break;

		default:
			return FALSE;
		} /* switch (ch) */
	}
	return (3 == cPeriods);
}


VOID DisplayCallError(HRESULT hr, LPCTSTR pcszName)
{
	int ids;

	WARNING_OUT(("DisplayCallError pcsz=[%s] err=%s", pcszName, PszHResult(hr)));

	switch (hr)
		{
	case S_OK:
	case S_FALSE:
		return; // no error

	default:
	case E_FAIL:
		WARNING_OUT(("DisplayCallError - message is not very informative. HRESULT=%08X", hr));
		// fall thru to IDS_RESOLVE_FAILED
	case NM_CALLERR_NAME_RESOLUTION:
		ids = IDS_RESOLVE_FAILED;
		break;

	case NM_CALLERR_NOT_INITIALIZED:
	case NM_CALLERR_NOT_FOUND:
		ids = IDS_COULD_NOT_INVITE;
		break;

	case NM_CALLERR_LOOPBACK:
		ids = IDS_CALL_LOOPBACK;
		break;

	case NM_CALLERR_ALREADY_CALLING:
		ids = IDS_ALREADY_CALLING;
		break;

	case E_OUTOFMEMORY:
		ids = IDS_ULSLOGON_OUTOFMEMORY;
		break;

	case NM_CALLERR_INVALID_PHONE_NUMBER:
		ids = IDS_CALLERR_E_BAD_PHONE_NUMBER;
		break;

	case NM_CALLERR_NO_PHONE_SUPPORT:
		ids = IDS_CALLERR_E_NO_PHONE_SUPPORT;
		break;

	case NM_CALLERR_INVALID_IPADDRESS:
		ids = IDS_CALLERR_E_BAD_IPADDRESS;
		break;

	case NM_CALLERR_HOST_RESOLUTION_FAILED:
		ids = IDS_CALLERR_E_BAD_HOSTNAME;
		break;

	case NM_CALLERR_NO_ILS:
		ids = IDS_CALLERR_E_NO_ILS;
		break;

	case NM_CALLERR_ILS_RESOLUTION_FAILED:
		ids = IDS_CALLERR_E_ILS_RESOLUTION_FAILED;
		break;

	case NM_CALLERR_NO_ADDRESS:
		ids = IDS_CALLERR_E_NO_ADDRESS;
		break;

	case NM_CALLERR_INVALID_ADDRESS:
		ids = IDS_CALLERR_E_INVALID_ADDRESS;
		break;

	case NM_CALLERR_NO_GATEKEEPER:
		ids = IDS_CALLERR_E_NO_GATEKEEPER;
		break;

	case NM_CALLERR_NOT_REGISTERED:
		ids = IDS_GK_NOT_REGISTERED;
		break;

	case NM_CALLERR_NO_GATEWAY:
		ids = IDS_CALLERR_E_NO_GATEWAY;
		break;

	case NM_CALLERR_PARAM_ERROR:
		ids = IDS_CALLERR_E_PARAM_ERROR;
		break;

	case NM_CALLERR_SECURITY_MISMATCH:
		ids = IDS_CALLERR_E_SECURITY_MISMATCH;
		break;

	case NM_CALLERR_UNESCAPE_ERROR:
		ids = IDS_CALLERR_E_UNESCAPE_ERROR;
		break;

	case NM_CALLERR_IN_CONFERENCE:
		ids = IDS_INVITE_DENIED_REMOTE_CONF;
		break;
		}

	DisplayMsgIdsParam(ids, pcszName);
}

///////////////////////////////////////////////////////////////////////
// Gateway utility routines


/*	G E T  D E F A U L T  G A T E W A Y  */
/*-------------------------------------------------------------------------
	%%Function: GetDefaultGateway
	
-------------------------------------------------------------------------*/
int GetDefaultGateway(LPTSTR psz, UINT cchMax)
{
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// Make sure it's enabled
	if (0 == re.GetNumber(REGVAL_USE_H323_GATEWAY, DEFAULT_USE_H323_GATEWAY))
	{
		SetEmptySz(psz);
		return 0;
	}

	lstrcpyn(psz, re.GetString(REGVAL_H323_GATEWAY), cchMax);
	return lstrlen(psz);
}

BOOL FH323GatewayEnabled(VOID)
{
	if (!::FIsAudioAllowed())
		return FALSE;

	TCHAR sz[MAX_PATH];
	return 0 != GetDefaultGateway(sz, CCHMAX(sz));
}




/*	C R E A T E  G A T E W A Y	A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: CreateGatewayAddress

	Create a gateway address in the form: gateway/address
	e.g. "157.59.0.40/65000"
-------------------------------------------------------------------------*/
HRESULT CreateGatewayAddress(LPTSTR pszResult, UINT cchMax, LPCTSTR pszAddr)
{
	int cch = GetDefaultGateway(pszResult, cchMax);
	if (0 == cch)
		return E_FAIL;
	if (cchMax <= (UINT) (cch + 1 + lstrlen(pszAddr)))
		return E_FAIL;

	*(pszResult+cch) = _T('/');

	pszResult += cch+1;
	lstrcpy(pszResult, pszAddr);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
// Gatekeeper utility routines

NM_GK_STATE g_GkLogonState = NM_GK_NOT_IN_GK_MODE;

BOOL FGkEnabled(VOID)
{
	return ( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );
}


inline bool ISE164CHAR(TCHAR digit)
{
	if ((digit >= '0') && (digit <= '9'))
	{
		return true;
	}
	if ((digit == '#') || (digit == '*'))
	{
		return true;
	}

	return false;
}

// removes non E-164 chars from a phone number string
int CleanupE164String(LPTSTR szPhoneNumber)
{
	int nLength;
	int nIndex, nIndexWrite;

	if ((szPhoneNumber == NULL) || (szPhoneNumber[0] == '\0'))
	{
		return 0;
	}

	nIndexWrite = 0;
	nLength  = lstrlen(szPhoneNumber);
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		if (ISE164CHAR(szPhoneNumber[nIndex]))
		{
			if (nIndex != nIndexWrite)
			{
				szPhoneNumber[nIndexWrite] = szPhoneNumber[nIndex];
			}
			nIndexWrite++;
		}
	}

	szPhoneNumber[nIndexWrite] = '\0';

	return nIndexWrite;  // length of the new string
}


// removes non E-164 & non-comma chars from a phone number string
int CleanupE164StringEx(LPTSTR szPhoneNumber)
{
	int nLength;
	int nIndex, nIndexWrite;

	if ((szPhoneNumber == NULL) || (szPhoneNumber[0] == '\0'))
	{
		return 0;
	}

	nIndexWrite = 0;
	nLength  = lstrlen(szPhoneNumber);
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		if (ISE164CHAR(szPhoneNumber[nIndex]) || (szPhoneNumber[nIndex] == ',') )
		{
			if (nIndex != nIndexWrite)
			{
				szPhoneNumber[nIndexWrite] = szPhoneNumber[nIndex];
			}
			nIndexWrite++;
		}
	}

	szPhoneNumber[nIndexWrite] = '\0';

	return nIndexWrite;  // length of the new string
}


static bool _CanLogonToGk()
{
	return (NULL != g_pNmSysInfo) &&
		   FGkEnabled() &&
		   ( ( NM_GK_IDLE == g_GkLogonState ) || ( NM_GK_NOT_IN_GK_MODE == g_GkLogonState ) );

}

void GkLogon(void)
{
	if(_CanLogonToGk())
	{
			// In case the logon fails, we set this to idle
		SetGkLogonState(NM_GK_IDLE);

		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
		LPCTSTR pszServer = reConf.GetString(REGVAL_GK_SERVER);
	
		g_pCCallto->SetGatekeeperName( pszServer );

		RegEntry		reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		LPTSTR			  pszAliasID = NULL;
		LPTSTR			  pszAliasE164 = NULL;

		ConfPolicies::eGKAddressingMode    mode = ConfPolicies::GKAddressing_Invalid;

		mode = ConfPolicies::GetGKAddressingMode();

		if( (ConfPolicies::GKAddressing_PhoneNum == mode) || (ConfPolicies::GKAddressing_Both == mode) )
		{
			pszAliasE164 = PszAlloc(reULS.GetString( REGVAL_ULS_PHONENUM_NAME ));

			CleanupE164String(pszAliasE164);
		}

		if( (ConfPolicies::GKAddressing_Account == mode) || (ConfPolicies::GKAddressing_Both == mode) )
		{	
			pszAliasID = PszAlloc(reULS.GetString( REGVAL_ULS_GK_ACCOUNT ));
		}

		HRESULT hr = g_pNmSysInfo->GkLogon(CComBSTR(pszServer),
							CComBSTR(pszAliasID ? pszAliasID : g_szEmpty),
							CComBSTR(pszAliasE164 ? pszAliasE164 : g_szEmpty));

		delete pszAliasID;
		delete pszAliasE164;
		
		if( SUCCEEDED( hr ) )
		{
			SetGkLogonState(NM_GK_LOGGING_ON);
		}
		else
		{
			PostConfMsgBox(IDS_ERR_GK_NOT_FOUND);
		}
	}
}

void GkLogoff(void)
{
	if (NULL != g_pNmSysInfo)
	{
		g_pNmSysInfo->GkLogoff();
	}

	SetGkLogonState( NM_GK_IDLE );
}


bool IsGatekeeperLoggedOn(void)
{
	return ( NM_GK_LOGGED_ON == g_GkLogonState );

}

bool IsGatekeeperLoggingOn(void)
{
	return ( NM_GK_LOGGING_ON == g_GkLogonState );
}


void SetGkLogonState( NM_GK_STATE state )
{

	if( FGkEnabled() )
	{
		if( g_GkLogonState != state )
		{
				// Set the new state
			g_GkLogonState = state;
		}
	}
	else
	{	
			// We are not in GK mode anymore
		g_GkLogonState = NM_GK_NOT_IN_GK_MODE;
	}

	::UpdateUI(CRUI_STATUSBAR, TRUE);

	g_pCCallto->SetGatekeeperEnabled( IsGatekeeperLoggedOn() || IsGatekeeperLoggingOn() );
}



CCallResolver::CCallResolver(LPCTSTR pszAddr, NM_ADDR_TYPE addrType) :
	m_pszAddr(PszAlloc(pszAddr)),
	m_pszAddrIP(NULL),
	m_addrType(addrType)
{
}

CCallResolver::~CCallResolver()
{
	delete m_pszAddr;
	delete m_pszAddrIP;
}

///////////////////////////////////////////////////////////////////////////
// Name Resolution

HRESULT CCallResolver::CheckHostEnt(HOSTENT * pHostInfo)
{
	// Only expecting IP addresses..
	if ((AF_INET != pHostInfo->h_addrtype) || (sizeof(DWORD) != pHostInfo->h_length))
	{
		WARNING_OUT(("CCallResolver: %08X CheckHostEnt - address type=%d",this, pHostInfo->h_addrtype));
		return E_FAIL;
	}

	struct in_addr inAddr;
	inAddr.s_addr = *((DWORD *)pHostInfo->h_addr);
	if (FLocalIpAddress(inAddr.s_addr))
	{
		WARNING_OUT(("CCallResolver: %08X CheckHostEnt - Attempted to call local machine", this));
		return NM_CALLERR_LOOPBACK;
	}

	m_pszAddrIP = PszAlloc(inet_ntoa(inAddr));
	if (NULL == m_pszAddrIP)
		return E_OUTOFMEMORY;

	return S_OK;
}


HRESULT CCallResolver::ResolveMachineName(LPCTSTR pcszAddr)
{
	TCHAR szOem[MAX_PATH];
	lstrcpyn(szOem, pcszAddr, CCHMAX(szOem));
	CharUpper(szOem);
	CharToOem(szOem, szOem);

	HOSTENT * pHostInfo = gethostbyname(szOem);
	if (NULL == pHostInfo)
	{
		WARNING_OUT(("CCallResolver: %08X ResolveMachineName(%s) gethostbyname failed. err=%s",
			this, szOem, PszWSALastError()));
		return NM_CALLERR_NAME_RESOLUTION;
	}

	return CheckHostEnt(pHostInfo);
}


HRESULT CCallResolver::ResolveUlsName(LPCTSTR pcszAddr)
{
	TCHAR szIP[MAX_PATH];
	TCHAR szServer[MAX_PATH];

	LPCTSTR pcsz = ExtractServerName(pcszAddr, szServer, CCHMAX(szServer));
	if (pcsz == pcszAddr)
		return NM_CALLERR_NAME_RESOLUTION;

	HRESULT hr = S_OK;
	if( SUCCEEDED( hr = CNmLDAP::ResolveUser( pcsz, szServer, szIP, CCHMAX( szIP ) ) ) )
	{		
		hr = ResolveIpName( szIP );
	}
	
	return hr;
}


HRESULT CCallResolver::ResolveIpName(LPCTSTR pcszAddr)
{
	DWORD dwIP = inet_addr(pcszAddr);
	if (INADDR_NONE == dwIP)
		return NM_CALLERR_NAME_RESOLUTION;

	char * pAddr = (char *) &dwIP;
	HOSTENT hostInfo;
	ClearStruct(&hostInfo);
	hostInfo.h_addrtype = AF_INET;
	hostInfo.h_length = sizeof(DWORD);
	hostInfo.h_addr_list = &pAddr;

	return CheckHostEnt(&hostInfo);
}

HRESULT CCallResolver::ResolveGateway(LPCTSTR pcszAddr)
{
	TCHAR szGateway[MAX_PATH];

	LPCTSTR pchSlash = _StrChr(pcszAddr, _T('/'));
	if (NULL == pchSlash)
	{
		WARNING_OUT(("CCallResolver: %08X ResolveGateway(%s) no separator?", this, pcszAddr));
		return NM_CALLERR_NAME_RESOLUTION;
	}

	lstrcpyn(szGateway, pcszAddr, (int)(1 + (pchSlash-pcszAddr)));
	return ResolveIpName(szGateway);
}



/*	R E S O L V E  */
/*-------------------------------------------------------------------------
	%%Function: Resolve

	Attempt to resolve the string into a standard IP address.
-------------------------------------------------------------------------*/
HRESULT CCallResolver::Resolve()
{
	DBGENTRY(CCallResolver::Resolve);

	HRESULT hr = E_FAIL;

	switch (m_addrType)
		{
	case NM_ADDR_UNKNOWN:
	{
		if (NULL != _StrChr(m_pszAddr, _T('/')))
		{
			if(SUCCEEDED(hr = ResolveUlsName(m_pszAddr)))
			{
				m_addrType = NM_ADDR_ULS;
			}
			break;
		}

		if (FIpAddress(m_pszAddr))
		{
			if(SUCCEEDED(hr = ResolveIpName(m_pszAddr)))
			{
				m_addrType = NM_ADDR_IP;
			}
			break;
		}

		if(SUCCEEDED(hr = ResolveMachineName(m_pszAddr)))
		{
			m_addrType = NM_ADDR_MACHINENAME;	
		}
		break;
	}

	case NM_ADDR_H323_GATEWAY:
	{
		LPTSTR pch = (LPTSTR) _StrChr(m_pszAddr, _T('/'));
		if (NULL != pch)
		{
			// Address is in the format: Gateway/address
			// e.g. "157.59.0.40/65000" or "efusion/65000"
			*pch = _T('\0');
			pch++;
			hr = ResolveIpName(m_pszAddr);
			if (FAILED(hr))
			{
				hr = ResolveMachineName(m_pszAddr);
				if (FAILED(hr))
				{
					break;
				}
			}
			LPTSTR pszNumber = PszAlloc(pch);
			delete m_pszAddr;
			m_pszAddr = pszNumber;
		}
		else
		{
			TCHAR sz[MAX_PATH];
			if (0 == GetDefaultGateway(sz, CCHMAX(sz)))
			{
				hr = E_FAIL;
				break;
			}
			hr = ResolveIpName(sz);
			if (FAILED(hr))
			{
				hr = ResolveMachineName(sz);
				if (FAILED(hr))
				{
					break;
				}
			}
		}
		
		hr = FEmptySz(m_pszAddr) ? E_INVALIDARG : S_OK;
		break;
	}

	case NM_ADDR_ULS:
		// Make sure the address is prefixed with an ILS server
		if (NULL == _StrChr(m_pszAddr, _T('/')))
		{
			TCHAR szAddr[CCHMAXSZ_ADDRESS];
			if (!FCreateIlsName(szAddr, NULL, m_pszAddr, CCHMAX(szAddr)))
			{
				hr = E_FAIL;
				break;
			}
			delete m_pszAddr;
			m_pszAddr = PszAlloc(szAddr);
		}

		hr = ResolveUlsName(m_pszAddr);
		break;

	case NM_ADDR_IP:
		hr = ResolveIpName(m_pszAddr);
		if (FAILED(hr) && (hr != NM_CALLERR_LOOPBACK) )
		{
			hr = ResolveMachineName(m_pszAddr);
		}
		break;

	case NM_ADDR_MACHINENAME:
		hr = ResolveMachineName(m_pszAddr);
		break;

	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ALIAS_E164:
	case NM_ADDR_T120_TRANSPORT:
		hr = FEmptySz(m_pszAddr) ? E_INVALIDARG : S_OK;
		break;

	default:
		WARNING_OUT(("Resolve: Unsupported address type %d", m_addrType));
		ASSERT(E_FAIL == hr);
		break;
	} /* switch (addrType) */

	WARNING_OUT(("CCallResolver::Resolve(%d,%s) result=%08X", m_addrType, m_pszAddrIP ? m_pszAddrIP : m_pszAddr, hr));

	DBGEXIT_HR(CCallResolver::Resolve, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\call.h ===
// File: call.h

#ifndef _CALL_H_
#define _CALL_H_

#include "oblist.h"
#include "SDKInternal.h"

const HRESULT NM_CALLERR_NOT_REGISTERED	= NM_E(0x01EF);

class CDlgCall;  // from dlgcall.h
class CPopupMsg;

class CCall : public RefCount, INmCallNotify2
{

private:
	INmCall*		 m_pInternalICall;// Call Object in core
	CPopupMsg*		 m_ppm;				// Popup incomming call dialog
	LPTSTR    m_pszDisplayName;      // Display Name
	LPTSTR    m_pszCallTo;     // CallTo (original)
	BOOL      m_fSelectedConference;
	BOOL      m_fIncoming;
	BOOL      m_fInRespond;		// Responding to call dialog?
	NM_ADDR_TYPE	m_nmAddrType;
	BOOL		m_bAddToMru;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	DWORD     m_dwCookie;

	CDlgCall * m_pDlgCall;  // Outgoing call dialog
	VOID      RemoveProgress(void);
	VOID      ShowProgress(BOOL fShow);

	VOID      LogCall(BOOL fAccepted);

public:
	CCall(LPCTSTR pszCallTo, LPCTSTR pszDisplayName, NM_ADDR_TYPE nmAddrType, BOOL bAddToMru, BOOL fIncoming);
	~CCall();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);

	// INmCallNotify3 methods
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, PBYTE pb, DWORD cb, BOOL fIsService);

	// Internal methods
	VOID    Update(void);
	BOOL    FComplete(void);
	BOOL    RemoveFromList(void);
	VOID    OnRing(void);
	BOOL    RespondToRinging(DWORD dwCLEF);
	HRESULT OnUIRemoteConference(BOOL fMCU, PWSTR* pwszConfNames, BSTR *pbstrConfToJoin);

	VOID    SetNmCall(INmCall * pCall);

	HRESULT
	PlaceCall
	(
		DWORD dwFlags,
		NM_ADDR_TYPE addrType,
		const TCHAR * const	setupAddress,
		const TCHAR * const	destinationAddress,
		const TCHAR * const	alias,
		const TCHAR * const	url,
		const TCHAR * const conference,
		const TCHAR * const password,
		const TCHAR * const	userData
	);

	VOID    Cancel(BOOL fDisplayCancelMsg);

	INmCall * GetINmCall()       {return m_pInternalICall;}
	LPTSTR  GetPszName()         {return m_pszDisplayName;}
	BOOL    FIncoming()          {return m_fIncoming;}
	NM_CALL_STATE GetState();
	DWORD   GetTickCount()       {return m_dwTick;}
	VOID    DisplayPopup(void);
	VOID    SetSelectedConference() {m_fSelectedConference = TRUE;}

	static VOID CALLBACK PopupMsgRingingCallback(LPVOID pContext, DWORD dwFlags);
};

// Fake connection points
HRESULT OnUICallCreated(INmCall *pNmCall);

// Global utility Functions
int CleanupE164StringEx(LPTSTR szPhoneNumber);
CCall * CallFromNmCall(INmCall * pNmCall);
DWORD GetCallStatus(LPTSTR pszStatus, int cchMax, UINT * puID);
BOOL  FIsCallInProgress(void);
VOID  FreeCallList(void);

CCall * CreateIncomingCall(INmCall * pNmCall);

// Commands
VOID CancelAllOutgoingCalls(void);
VOID CancelAllCalls(void);

BOOL FIpAddress(LPCTSTR pcsz);

VOID DisplayCallError(HRESULT hr, LPCTSTR pcszName);

// Gateway utility routines
BOOL FH323GatewayEnabled(void);
int  GetDefaultGateway(LPTSTR psz, UINT cchMax);
HRESULT CreateGatewayAddress(LPTSTR pszResult, UINT cchMax, LPCTSTR pszAddr);

	// Gatekeeper logon state
extern NM_GK_STATE g_GkLogonState;



BOOL FGkEnabled(void);
void GkLogon(void);
void GkLogoff(void);
void SetGkLogonState(NM_GK_STATE state);
bool IsGatekeeperLoggedOn(void);
bool IsGatekeeperLoggingOn(void);


class CCallResolver
{

private:
	LPTSTR    m_pszAddr;       // Address (original)
	LPTSTR    m_pszAddrIP;     // Address (IP)
	NM_ADDR_TYPE m_addrType;    // Address type (of m_pszAddr)

	HRESULT ResolveIpName(LPCTSTR pcszAddr);
	HRESULT ResolveMachineName(LPCTSTR pcszAddr);
	HRESULT ResolveUlsName(LPCTSTR pcszAddr);
	HRESULT ResolveGateway(LPCTSTR pcszAddr);
	HRESULT CheckHostEnt(HOSTENT * pHostInfo);

public:
	CCallResolver(LPCTSTR pszAddr, NM_ADDR_TYPE addrType);
	~CCallResolver();

	LPCTSTR GetPszAddr() { return m_pszAddr; }
	NM_ADDR_TYPE GetAddrType() { return m_addrType; }
	LPCTSTR GetPszAddrIP() { return m_pszAddrIP; }

	HRESULT Resolve();
};

#endif // _CALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\callingbar.h ===
/****************************************************************************
*
*    FILE:     CallingBar.h
*
*    CREATED:  George Pitt 1-22-99
*
****************************************************************************/

#ifndef _CALLINGBAR_H_
#define _CALLINGBAR_H_

#include "GenContainers.h"
#include "GenControls.h"
#include "ConfUtil.h"

class CConfRoom;
struct RichAddressInfo;

// We are making some changes specifically for OSR2 beta, but we should rip them out afterwards
#define OSR2LOOK

class CCallingBar : public CToolbar, public IComboBoxChange
{
public:
	CCallingBar();

	BOOL Create(CGenWindow *pParent, CConfRoom *pConfRoom);

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
	{
		return(CToolbar::QueryInterface(riid, ppvObject));
	}
    
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
	{
		return(CToolbar::AddRef());
	}
    
    virtual ULONG STDMETHODCALLTYPE Release( void)
	{
		return(CToolbar::Release());
	}

	virtual void OnTextChange(CComboBox *pEdit);
	virtual void OnFocusChange(CComboBox *pEdit, BOOL bSet);
	virtual void OnSelectionChange(CComboBox *pCombo);

	int GetText(LPTSTR szText, int nLen);
	void SetText(LPCTSTR szText);

protected:
	virtual ~CCallingBar();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uCmd, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	// A pointer back to the global ConfRoom object for some functionality
	CConfRoom *m_pConfRoom;
	// The last rich address we were given
	RichAddressInfo *m_pAddr;
	// The edit text control in the bar
	CComboBox *m_pEdit;
	ITranslateAccelerator *m_pAccel;
	// Last font set on the edit control
	BOOL m_bUnderline : 1;

	void SetEditFont(BOOL bUnderline, BOOL bForce=FALSE);
	void ClearAddr(RichAddressInfo **ppAddr);
	void ClearCombo();
	void OnNewAddress(RichAddressInfo *pAddr);
} ;

#endif // _CALLINGBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\callingbar.cpp ===
// File: rtoolbar.cpp

#include "precomp.h"
#include "resource.h"

#include "CallingBar.h"
#include "RToolbar.h"
#include "conf.h"
#include "ConfRoom.h"
#include "richaddr.h"
#include "dlgAcd.h"
#include "callto.h"
#include "topwindow.h"
#include "roomlist.h"

#define ReleaseIt(pUnk) if (NULL != (pUnk)) { (pUnk)->Release(); (pUnk) = NULL; }


const static int CCH_MAX_NAME = 256;

// BUGBUG georgep: Hard-coded colors for the edit control
static const COLORREF EditBack = RGB(-1  , -1  , -1  );
static const COLORREF EditFore = RGB(0, 55, 55);


void CCallingBar::SetEditFont(BOOL bUnderline, BOOL bForce)
{
	// BUGBUG georgep: For now, we will never underline; We'll probably need to
	// change this some time in the future
	bUnderline = FALSE;

	if (!bForce && ((bUnderline&&m_bUnderline) || (!bUnderline&&!m_bUnderline)))
	{
		return;
	}
	m_bUnderline = bUnderline;

	LOGFONT lf;
	{
		HDC hdc = GetDC(NULL);
		lf.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);
		ReleaseDC(NULL, hdc);
	}
	lf.lfWidth = 0;
	lf.lfEscapement = 0;
	lf.lfOrientation = 0;
	lf.lfWeight = FW_NORMAL;
	lf.lfItalic = FALSE;
	lf.lfUnderline = (BYTE)bUnderline;
	lf.lfStrikeOut = FALSE;
	lf.lfCharSet = DEFAULT_CHARSET;
	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	lf.lfFaceName[0] = '\0';

	m_pEdit->SetFont(CreateFontIndirect(&lf));
}

void CCallingBar::ClearAddr(RichAddressInfo **ppAddr)
{
	if (NULL != *ppAddr)
	{
		m_pConfRoom->FreeAddress(ppAddr);
		*ppAddr = NULL;
	}
}

void CCallingBar::ClearCombo()
{
	if (NULL == m_pEdit)
	{
		return;
	}

	// Clear the combo
	while (0 < m_pEdit->GetNumItems())
	{
		RichAddressInfo *pAddr = reinterpret_cast<RichAddressInfo*>(m_pEdit->GetUserData(0));
		ClearAddr(&pAddr);
		m_pEdit->RemoveItem(0);
	}
}

void CCallingBar::OnNewAddress(RichAddressInfo *pAddr)
{
	if (NULL != pAddr)
	{
		m_pEdit->SetSelectedIndex(-1);

		m_pEdit->SetText(pAddr->szName);

		SetEditFont(TRUE);

		ClearAddr(&m_pAddr);
		m_pAddr = pAddr;
	}
}

CCallingBar::CCallingBar() : m_pAddr(NULL), m_pEdit(NULL), m_bUnderline(FALSE), m_pAccel(NULL)
{
}

BOOL CCallingBar::Create(CGenWindow *pParent, CConfRoom *pConfRoom)
{
	m_pConfRoom = pConfRoom;

	// Create the toolbar
	if (!CToolbar::Create(pParent->GetWindow()))
	{
		return(FALSE);
	}

	CCallingBar *pDial = this;

	pDial->m_nAlignment = Center;

	// Add the directory button
	static const Buttons callButtons[] =
	{
		{ IDB_DIAL     , CBitmapButton::Disabled+1, 1, ID_TB_NEW_CALL, IDS_TT_TB_NEW_CALL, },
	} ;

	// Create the text control
	CComboBox *pEdit = new CComboBox();
	m_pEdit = pEdit;
	if (NULL != pEdit)
	{
		if (pEdit->Create(pDial->GetWindow(), 200, CBS_AUTOHSCROLL|CBS_DROPDOWN, g_szEmpty, this))
		{
			USES_RES2T
			pEdit->SetTooltip(RES2T(IDS_TT_ADDRESS_BAR));
//			pEdit->SetWindowtext(RES2T(IDS_TT_ADDRESS_BAR));

			// Set the colors and the font
			pEdit->SetColors(CreateSolidBrush(EditBack), EditBack, EditFore);

			SetEditFont(FALSE, TRUE);
			
			::SendMessage( *pEdit, CB_LIMITTEXT, CCallto::s_iMaxAddressLength, 0 );
		}
	}

	// Add the call button on the right
	AddButtons(pDial, callButtons, 1);

	// I want the second button on the right, and the ComboBox in the
	// middle
	pDial->m_uRightIndex = 1;
	pDial->m_bHasCenterChild = TRUE;

	m_pAccel = new CTranslateAccelTable(GetWindow(),
		::LoadAccelerators(GetInstanceHandle(), MAKEINTRESOURCE(IDR_CALL)));
	if (NULL != m_pAccel)
	{
		AddTranslateAccelerator(m_pAccel);
	}

	return(TRUE);
}

void CCallingBar::OnTextChange(CComboBox *pEdit)
{
	ClearAddr(&m_pAddr);
	SetEditFont(FALSE);
}

void CCallingBar::OnFocusChange(CComboBox *pEdit, BOOL bSet)
{
	if (!bSet)
	{
		RichAddressInfo *pAddr = NULL;
		int index = m_pEdit->GetSelectedIndex();
		if (0 <= index)
		{
			LPARAM lpAddr = m_pEdit->GetUserData(index);
			if (static_cast<LPARAM>(-1) != lpAddr && 0 != lpAddr)
			{
				// There are cases where the combo thinks we have a selection,
				// but there is no associated address
				pAddr = reinterpret_cast<RichAddressInfo*>(lpAddr);

				// I need to make a copy so I won't delete twice
				RichAddressInfo *pCopy = NULL;
				m_pConfRoom->CopyAddress(pAddr, &pCopy);

				OnNewAddress(pCopy);
			}
		}
	}

	if (bSet)
	{
		// Only clear this on setfocus, to avoid some weirdness when the focus is
		// lost while the list is dropped down.
		ClearCombo();

		IEnumRichAddressInfo *pEnum;
		if (SUCCEEDED(m_pConfRoom->GetRecentAddresses(&pEnum)))
		{
			for (long index=0; ; ++index)
			{
				RichAddressInfo *pAddr;

				if (S_OK != pEnum->GetAddress(index, &pAddr))
				{
					break;
				}

				m_pEdit->AddText(pAddr->szName, reinterpret_cast<LPARAM>(pAddr));
			}

			pEnum->Release();
		}
	}
}

void CCallingBar::OnSelectionChange(CComboBox *pCombo)
{
}

CCallingBar::~CCallingBar()
{
	ClearAddr(&m_pAddr);

	ReleaseIt(m_pEdit);
}

LRESULT CCallingBar::ProcessMessage(HWND hwnd, UINT uCmd, WPARAM wParam, LPARAM lParam)
{
	switch (uCmd)
	{
	case WM_DESTROY:
		if (NULL != m_pAccel)
		{
			RemoveTranslateAccelerator(m_pAccel);
			m_pAccel->Release();
			m_pAccel = NULL;
		}

		ClearCombo();
		break;

	case WM_SETFOCUS:
		if (NULL != m_pEdit)
		{
			::SetFocus(m_pEdit->GetWindow());
		}
		break;

	default:
		break;
	}

	return(CToolbar::ProcessMessage(hwnd, uCmd, wParam, lParam));
}

void CCallingBar::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
	case ID_TB_NEW_CALL:
	{

		// Make sure all the fields are updated correctly
		OnFocusChange(m_pEdit, FALSE);

		TCHAR szEdit[CCH_MAX_NAME];

	    int szEditLen = m_pEdit->GetText(szEdit, ARRAY_ELEMENTS(szEdit));

		if( szEditLen > 0 )
		{
			szEditLen = TrimSz( szEdit );
		}

		if( (m_pAddr != NULL) || (szEditLen > 0) )
		{
			const TCHAR *	pszCallto;
			const TCHAR *	pszDisplayName;
			NM_ADDR_TYPE	nmAddressType;

			if( hasValidUserInfo( m_pAddr ) )
			{
				pszCallto		= m_pAddr->rgDwStr[ 0 ].psz;
				pszDisplayName	= m_pAddr->szName;
				nmAddressType	= static_cast<NM_ADDR_TYPE>(m_pAddr->rgDwStr[ 0 ].dw);
			}
			else
			{
				pszCallto		= szEdit;
				pszDisplayName	= szEdit;
				nmAddressType	= bCanCallAsPhoneNumber( pszCallto )? NM_ADDR_ALIAS_E164: NM_ADDR_UNKNOWN;
			}

			g_pCCallto->Callto(	pszCallto,			//	pointer to the callto url to try to place the call with...
								pszDisplayName,		//	pointer to the display name to use...
								nmAddressType,		//	callto type to resolve this callto as...
								true,				//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
								NULL,				//	security preference, NULL for none. must be "compatible" with secure param if present...
								true,				//	whether or not save in mru...
								true,				//	whether or not to perform user interaction on errors...
								GetWindow(),		//	if bUIEnabled is true this is the window to parent error/status windows to...
								NULL );				//	out pointer to INmCall * to receive INmCall * generated by placing call...
		}
		else
		{
			CDlgAcd::newCall( GetWindow(), m_pConfRoom );
		}
		break;
	}

	case ID_TB_DIRECTORY:
		// Let the parent handle this command
	default:
		FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CToolbar::ProcessMessage);
	}
}

int CCallingBar::GetText(LPTSTR szText, int nLen)
{
	if (NULL != m_pEdit)
	{
		return(m_pEdit->GetText(szText, nLen));
	}

	szText[0] = '\0';
	return(0);
}

void CCallingBar::SetText(LPCTSTR szText)
{
	if (NULL != m_pEdit)
	{
		m_pEdit->SetText(szText);
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calllog.cpp ===
//
// CallLog.cpp
//
// Created:  ChrisPi   10-17-96
// Updated:  RobD      10-30-96
//
// ToDo:
// - Expire records
// - UI to delete record(s)
// - system policy?
//

#include "precomp.h"
#include "rostinfo.h"
#include "CallLog.h"
#include "particip.h"   // for MAX_PARTICIPANT_NAME
#include "ConfUtil.h"

#define MAX_DELETED_ENTRIES_BEFORE_REWRITE  10
#define LARGE_ENTRY_SIZE    256

CCallLogEntry::CCallLogEntry(   LPCTSTR pcszName,
                                DWORD dwFlags,
                                CRosterInfo* pri,
                                LPVOID pvRosterData,
                                PBYTE pbCert,
                                ULONG cbCert,
                                LPSYSTEMTIME pst,
                                DWORD dwFileOffset) :
    m_dwFlags       (dwFlags),
    m_pri           (NULL),
    m_pbCert        (NULL),
    m_cbCert        (0),
    m_dwFileOffset  (dwFileOffset)
{
    DebugEntry(CCallLogEntry::CCallLogEntry);
    ASSERT(NULL != pcszName);
    ASSERT(NULL != pst);
    // Only one of these two parameters should be non-NULL
    ASSERT((NULL == pvRosterData) || (NULL == pri));
    LPVOID pvData = pvRosterData;
    if (NULL != pri)
    {
        UINT cbData;
        if (SUCCEEDED(pri->Save(&pvData, &cbData)))
        {
            ASSERT(pvData);
        }
    }
    if (NULL != pvData)
    {
        m_pri = new CRosterInfo();
        if (NULL != m_pri)
        {
            m_pri->Load(pvData);
        }
    }
    if (NULL != pbCert && 0 != cbCert)
    {
        m_pbCert = new BYTE[cbCert];
        if (NULL == m_pbCert)
        {
            ERROR_OUT(("CCalllogEntry::CCalllogEntry() -- failed to allocate memory"));
        }
            else
            {
                memcpy(m_pbCert, pbCert, cbCert);
                m_cbCert = cbCert;
            }
    }
    m_st = *pst;
    m_pszName = PszAlloc(pcszName);
    DebugExitVOID(CCallLogEntry::CCallLogEntry);
}

CCallLogEntry::~CCallLogEntry()
{
    DebugEntry(CCallLogEntry::~CCallLogEntry);
    delete m_pszName;
    // NOTE: m_pri must be new'ed by the function that calls the
    // constructor - this is an optimization to avoid unnecessary
    // copying - but it's a little unclean.
    delete m_pri;
    delete []m_pbCert;
    DebugExitVOID(CCallLogEntry::~CCallLogEntry);
}


/////////////////////////////////////////////////////////////////////////

CCallLog::CCallLog(LPCTSTR pszKey, LPCTSTR pszDefault) :
    m_fUseList  (FALSE),
    m_fDataRead (FALSE),
    m_cTotalEntries (0),
    m_cDeletedEntries (0)
{
    InitLogData(pszKey, pszDefault);
    TRACE_OUT(("Using Call Log file [%s]", m_strFile));
}


CCallLog::~CCallLog()
{
    DebugEntry(CCallLog::~CCallLog);

    // Check to see if we are more than a number entries over our
    // configured maximum and re-write the file if so

    TRACE_OUT(("Entry count: total:%d deleted:%d", m_cTotalEntries,
        m_cDeletedEntries));

    if ( m_fUseList && m_cDeletedEntries > MAX_DELETED_ENTRIES_BEFORE_REWRITE )
        RewriteFile();
    else
    {
        int size    = GetSize();

        for( int i = 0; i < size; i++ )
        {
            ASSERT( NULL != (*this)[i] );
            delete (*this)[i];
        }
    }

    DebugExitVOID(CCallLog::~CCallLog);
}


/*  A D D  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: AddCall

-------------------------------------------------------------------------*/
HRESULT CCallLog::AddCall(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert)
{
TRACE_OUT( ("CCallLog::AddCall(\"%s\")", pcszName) );
    DWORD dwFileOffset;
    HRESULT hr = S_OK;

    ASSERT(NULL != pLogHdr);

    // Grab the current local time
    ::GetLocalTime(&(pLogHdr->sysTime));

    ApiDebugMsg(("CALL_LOG: [%s] %s", pcszName,
            (pLogHdr->dwCLEF & CLEF_ACCEPTED) ? "ACCEPTED" : "REJECTED"));

    // Append the data to the file
    dwFileOffset = WriteEntry(pcszName, pLogHdr, pri, pbCert, cbCert);

    TRACE_OUT(("AddCall: adding entry with %d total, %d deleted, %d max",
        m_cTotalEntries, m_cDeletedEntries, m_cMaxEntries ));

    // Create list entry only when necessary
    if (m_fUseList)
    {
        CCallLogEntry* pcleNew = new CCallLogEntry( pcszName,
                    pLogHdr->dwCLEF, pri, NULL, pbCert, cbCert, &(pLogHdr->sysTime), dwFileOffset);

        if (NULL == pcleNew)
            return E_OUTOFMEMORY;

        Add(pcleNew);

        m_cTotalEntries++;

        // Check to see if this put us over the top of valid entries
        // and remove the oldest entry if so

        if ( m_cTotalEntries - m_cDeletedEntries > m_cMaxEntries )
        {
            // Remove oldest entry
            DeleteEntry((*this)[0]);
            RemoveAt( 0 );
        }
    }
    else
    {
        // Check to see if the file is getting large based on
        // our target number of entries and a heuristic large
        // entry size. If our file has grown over this point, load
        // the file and trim the list so that we will re-write
        // a smaller file on exit.

        TRACE_OUT(("Checking file size %d against %d * %d",
            dwFileOffset, m_cMaxEntries, LARGE_ENTRY_SIZE));

        if ( dwFileOffset > (DWORD)( m_cMaxEntries * LARGE_ENTRY_SIZE ) )
        {
            TRACE_OUT(("Log file getting large, forcing LoadFileData"));

            LoadFileData();
        }
    }

    return S_OK;
}

/*  I N I T  L O G  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: InitLogData

    Get the log data from the registry.
    - the expiration information
    - the file name (with path)
    If there is no entry for the file name, a new, unique file is created.
-------------------------------------------------------------------------*/
VOID CCallLog::InitLogData(LPCTSTR pszKey, LPCTSTR pszDefault)
{
    TCHAR  szPath[MAX_PATH];
    PTSTR  pszFileName;
    HANDLE hFile;

    ASSERT(m_strFile.IsEmpty());

    RegEntry reLog(pszKey, HKEY_CURRENT_USER);

    m_Expire = reLog.GetNumber(REGVAL_LOG_EXPIRE, 0);
        
    m_strFile = reLog.GetString(REGVAL_LOG_FILE);

    m_cMaxEntries = reLog.GetNumber(REGVAL_LOG_MAX_ENTRIES,
                                DEFAULT_LOG_MAX_ENTRIES );

    TRACE_OUT(("Max Entries set to %d", m_cMaxEntries ));

    // Make sure file exists and can be read/written
    hFile = OpenLogFile();
    if (NULL != hFile)
    {
        // valid file found
        CloseHandle(hFile);
        return;
    }
    // String is invalid (or empty) - make sure it's empty
    m_strFile.Empty();
    
    // Create the new log file in the NetMeeting directory
    if (!GetInstallDirectory(szPath))
    {
        WARNING_OUT(("InitLogData: Unable to get Install Directory?"));
        return;
    }
    pszFileName = &szPath[lstrlen(szPath)];

    // Try to use the default name
    wsprintf(pszFileName, TEXT("%s%s"), pszDefault, TEXT(".dat"));

    hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        // Use a unique name to avoid other users' files
        for (int iFile = 2; iFile < 999; iFile++)
        {
            wsprintf(pszFileName, TEXT("%s%d.dat"), pszDefault, iFile);

            hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != hFile)
                break;

            switch (GetLastError())
                {
            case ERROR_FILE_EXISTS:     // We get this with NT
            case ERROR_ALREADY_EXISTS:  // and this with Win95
                break;
            default:
                WARNING_OUT(("Unable to create log file [%s] err=0x%08X", szPath, GetLastError()));
                break;
                } /* switch (GetLastError()) */
        }
    }

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
        m_strFile = szPath;
        reLog.SetValue(REGVAL_LOG_FILE, szPath);
    }
}


/*  O P E N  L O G  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: OpenLogFile

    Open the log file and return a handle to file.
    Return NULL if there was a problem.
-------------------------------------------------------------------------*/
HANDLE CCallLog::OpenLogFile(VOID)
{
    HANDLE   hFile;

    if (m_strFile.IsEmpty())
    {
        WARNING_OUT(("Problem opening call log file"));
        return NULL;
    }

    hFile = CreateFile(m_strFile, GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        ERROR_OUT(("OpenLogFile: Unable to open call log file"));
        hFile = NULL;
    }

    return hFile;
}


/*  R E A D  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: ReadData

-------------------------------------------------------------------------*/
BOOL CCallLog::ReadData(HANDLE hFile, PVOID pv, UINT cb)
{
    DWORD cbRead;

    ASSERT(NULL != hFile);
    ASSERT(NULL != pv);

    if (0 == cb)
        return TRUE;

    if (!ReadFile(hFile, pv, cb, &cbRead, NULL))
        return FALSE;

    return (cb == cbRead);
}



/*  W R I T E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: WriteData

    Write the data to the file.
    The file will be automatically opened/close if hFile is NULL.
-------------------------------------------------------------------------*/
HRESULT CCallLog::WriteData(HANDLE hFile, LPDWORD pdwOffset, PVOID pv, DWORD cb)
{
    HRESULT hr = E_FAIL;
    HANDLE  hFileTemp = NULL;
    DWORD   cbWritten;

    if (0 == cb)
        return S_OK; // nothing to do

    ASSERT(NULL != pv);
    ASSERT(NULL != pdwOffset);
    ASSERT(INVALID_FILE_SIZE != *pdwOffset);

    if (NULL == hFile)
    {
        // Auto-open the file, if necessary
        hFileTemp = OpenLogFile();
        if (NULL == hFileTemp)
            return E_FAIL;
        hFile = hFileTemp;
    }
    ASSERT(INVALID_HANDLE_VALUE != hFile);


    if (INVALID_FILE_SIZE != SetFilePointer(hFile, *pdwOffset, NULL, FILE_BEGIN))
    {
        if (WriteFile(hFile, pv, cb, &cbWritten, NULL) && (cb == cbWritten))
        {
            *pdwOffset += cbWritten;
            hr = S_OK;
        }
    }

    if (NULL != hFileTemp)
    {
        // Close the temporary file handle
        CloseHandle(hFileTemp);
    }

    return hr;
}



/*  W R I T E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: WriteEntry

    Write a call log entry to the end of the log file.
    The function returns the file position at which the data was written
    or INVALID_FILE_SIZE (0xFFFFFFFF) if there was a problem.
-------------------------------------------------------------------------*/
DWORD CCallLog::WriteEntry(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert)
{
    PVOID  pvData;
    HANDLE hFile;
    DWORD  dwFilePosition;
    DWORD  dwPos;
    BSTR  pcwszName;


    ASSERT(NULL != pcszName);
    ASSERT(NULL != pLogHdr);

    hFile = OpenLogFile();
    if (NULL == hFile)
        return INVALID_FILE_SIZE;

    dwFilePosition = SetFilePointer(hFile, 0, NULL, FILE_END);
    if (INVALID_FILE_SIZE != dwFilePosition)
    {
        dwPos = dwFilePosition;

        // Always write display name in UNICODE
        if(SUCCEEDED(LPTSTR_to_BSTR(&pcwszName, pcszName)))
        {
                pLogHdr->cbName = (lstrlenW((LPWSTR)pcwszName) + 1) * sizeof(WCHAR);

                if ((NULL == pri) ||
                    (!SUCCEEDED(pri->Save(&pvData, (UINT *) &(pLogHdr->cbData)))) )
                {
                    // No data?
                    pLogHdr->cbData = 0;
                    pvData = NULL;
                }
                pLogHdr->cbCert = cbCert;
                
                // Calculate total size of record
                pLogHdr->dwSize = sizeof(LOGHDR) + pLogHdr->cbName + pLogHdr->cbData + pLogHdr->cbCert;

                if ((S_OK != WriteData(hFile, &dwPos, pLogHdr,   sizeof(LOGHDR)))  ||
                    (S_OK != WriteData(hFile, &dwPos, pcwszName, pLogHdr->cbName)) ||
                    (S_OK != WriteData(hFile, &dwPos, pvData,    pLogHdr->cbData)) ||
                    (S_OK != WriteData(hFile, &dwPos, pbCert,    cbCert)))
                {
                    dwFilePosition = INVALID_FILE_SIZE;
                }

                SysFreeString(pcwszName);
        }


    }

    CloseHandle(hFile);

    return dwFilePosition;
}


/*  R E A D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: ReadEntry

    Read the next entry from the file.
    *ppcle will be set to NULL if the entry was deleted.

    Return Values:
        S_OK    - data was read successfully
        S_FALSE - data exists, but was deleted
        E_FAIL  - problem reading file
-------------------------------------------------------------------------*/
HRESULT CCallLog::ReadEntry(HANDLE hFile, DWORD * pdwFileOffset, CCallLogEntry** ppcle)
{
    DWORD   dwOffsetSave;
    LOGHDR  logHdr;
    WCHAR   wszName[MAX_PARTICIPANT_NAME];

    ASSERT(NULL != ppcle);
    ASSERT(NULL != hFile);
    ASSERT(NULL != pdwFileOffset);
    *ppcle = NULL; // initialize this in case we return with an error

    dwOffsetSave = *pdwFileOffset;
    if (INVALID_FILE_SIZE == SetFilePointer(hFile, dwOffsetSave, NULL, FILE_BEGIN))
        return E_FAIL;


    // Read record header
    if (!ReadData(hFile, &logHdr, sizeof(LOGHDR)) )
        return E_FAIL;

    // Return pointer to end of record
    *pdwFileOffset += logHdr.dwSize;

    if (logHdr.dwCLEF & CLEF_DELETED)
    {
        // Skip deleted record
        ASSERT(NULL == *ppcle);
        return S_FALSE;
    }
    
    if (logHdr.cbName > sizeof(wszName))
        logHdr.cbName = sizeof(wszName);


    // Read Name
    if (!ReadData(hFile, wszName, logHdr.cbName))
        return E_FAIL;

    // Read Extra Data
    PVOID pvData = NULL;
    if (logHdr.cbData != 0)
    {
        pvData = new BYTE[logHdr.cbData];
        if (NULL != pvData)
        {
            if (!ReadData(hFile, pvData, logHdr.cbData))
            {
                WARNING_OUT(("Problem reading roster data from log"));
            }
        }
    }

        PBYTE pbCert = NULL;
        if ((logHdr.dwCLEF & CLEF_SECURE ) && logHdr.cbCert != 0)
        {
            pbCert = new BYTE[logHdr.cbCert];
            if (NULL != pbCert)
            {
                if (!ReadData(hFile, pbCert, logHdr.cbCert))
                {
                    WARNING_OUT(("Problem reading certificate data from log"));
                }
            }
        }


        BSTR bstrName = ::SysAllocString(wszName);

        if(bstrName)
        {
            LPTSTR  szName;
            HRESULT hr =  BSTR_to_LPTSTR (&szName, bstrName);                       
            if (SUCCEEDED(hr))
            {    

                // Create the new log entry from the data read
                *ppcle = new CCallLogEntry(szName, logHdr.dwCLEF,
                                    NULL, pvData, pbCert, logHdr.cbCert, &logHdr.sysTime, dwOffsetSave);
                delete szName;
            }

            SysFreeString(bstrName);
        }
        
    delete [] pvData;
    delete [] pbCert;
    return S_OK;
}


/*  L O A D  F I L E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: LoadFileData

    Load the call log data from the file
-------------------------------------------------------------------------*/
VOID CCallLog::LoadFileData(VOID)
{
    HANDLE hFile;
    DWORD  dwFileOffset;
    CCallLogEntry * pcle;

    hFile = OpenLogFile();
    if (NULL == hFile)
        return;

    m_cTotalEntries = 0;
    m_cDeletedEntries = 0;

    dwFileOffset = 0;
    while (E_FAIL != ReadEntry(hFile, &dwFileOffset, &pcle))
    {
        m_cTotalEntries++;

        if (NULL == pcle)
        {
            m_cDeletedEntries++;
            continue;  // deleted record
        }

        Add(pcle);

        TRACE_OUT(("Read Entry: \"%s\" (%02d/%02d/%04d %02d:%02d:%02d) : %s",
                        pcle->m_pszName,
                        pcle->m_st.wMonth, pcle->m_st.wDay, pcle->m_st.wYear,
                        pcle->m_st.wHour, pcle->m_st.wMinute, pcle->m_st.wSecond,
                        (CLEF_ACCEPTED & pcle->m_dwFlags) ? "ACCEPTED" : "REJECTED"));
    }

    CloseHandle(hFile);

    m_fUseList = TRUE;
    m_fDataRead = TRUE;

    // Now trim the list down to our configured maximum if
    // the count exceeds our target. The file will be compacted
    // when we write it out if we have more than a few deleted
    // entries.

    for( int nn = 0, delCount = m_cTotalEntries - m_cDeletedEntries - m_cMaxEntries; nn < delCount; nn++ )
    {
        DeleteEntry((*this)[0]);
        RemoveAt( 0 );
    }
}

/*  R E W R I T E   F I L E  */
/*-------------------------------------------------------------------------
    %%Function: RewriteFile

    Re-write the log file from the in-memory list, compress deleted entries
-------------------------------------------------------------------------*/
VOID CCallLog::RewriteFile(VOID)
{
    HANDLE hFile;

    TRACE_OUT(("Rewriting log file"));

    // Make sure we don't nuke the file without a list to write out
    ASSERT(m_fUseList);

    // Reset the file pointer and write the EOF marker
    if (!m_strFile.IsEmpty())
    {
        hFile = OpenLogFile();

        if (NULL != hFile)
        {
            if (INVALID_FILE_SIZE != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
            {
                SetEndOfFile(hFile);
                m_cTotalEntries = 0;
                m_cDeletedEntries = 0;
            }
            CloseHandle(hFile);
        }
    }

    // Write out all non-deleted records
    for( int i = 0; i < GetSize(); ++i )
    {
        
        CCallLogEntry* pcle = (*this)[i];
        ASSERT(NULL != pcle);

        LOGHDR LogHdr;

        // Initialize LogHdr items from memory object
        LogHdr.dwCLEF = pcle->GetFlags();
        LogHdr.dwPF = 0;
        LogHdr.sysTime = *pcle->GetTime();

        // Write out entry
        WriteEntry( pcle->m_pszName,
                    &LogHdr,
                    pcle->m_pri,
                    pcle->m_pbCert,
                    pcle->m_cbCert);

        delete pcle;
    }
}


// Grumble... Inefficient
HRESULT CCallLog::DeleteEntry(CCallLogEntry * pcle)
{
    HRESULT hr;
    DWORD   dwFlags;
    DWORD   dwOffset;

    if (NULL == pcle)
    {
        WARNING_OUT(("DeleteEntry: Unable to find entry"));
        return E_FAIL;
    }

    // Calculate offset to "CLEF"
    dwOffset = pcle->GetFileOffset() + offsetof(LOGHDR, dwCLEF);

    dwFlags = pcle->GetFlags() | CLEF_DELETED;
    hr = WriteData(NULL, &dwOffset, &dwFlags, sizeof(DWORD));

    m_cDeletedEntries++;

    TRACE_OUT(("Marked [%s] pos=%08X for deletion", pcle->GetName(), pcle->GetFileOffset() ));

    delete pcle;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltocontext.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"call.h"
#include	"confPolicies.h"
#include	"nmldap.h"
#include	"confroom.h"
#include	"regentry.h"

//#include	"debug.hpp"
#include	"callto.h"
#include	"calltoContext.h"
#include	"dlgAcd.h"
#include	"richAddr.h"


//--------------------------------------------------------------------------//
//	CUIContext::CUIContext.													//
//--------------------------------------------------------------------------//
CUIContext::CUIContext(void):
	m_parent( NULL ),
	m_callFlags( 0 )
{

}	//	End of CUIContext::CUIContext.


//--------------------------------------------------------------------------//
//	CUIContext::~CUIContext.												//
//--------------------------------------------------------------------------//
CUIContext::~CUIContext(void)
{
}	//	End of CUIContext::~CUIContext.


//--------------------------------------------------------------------------//
//	CUIContext::disambiguate.												//
//--------------------------------------------------------------------------//
HRESULT
CUIContext::disambiguate
(
	ICalltoCollection * const	calltoCollection,
	ICallto * const				,//emptyCallto,
	const ICallto ** const		selectedCallto
){
//trace( TEXT( "CUIContext::disambiguate()\r\n" ) );
	HRESULT	result	= S_FALSE;

	if( calltoCollection->get_count() > 1 )
	{
		static HRESULT	confidenceLevels[]	= {S_CONFIDENCE_CERTITUDE, S_CONFIDENCE_HIGH, S_CONFIDENCE_MEDIUM, S_CONFIDENCE_LOW};

		//	Just take the first highest confidence one until we have time to do something superior...
		for( int level = 0; (level < elementsof( confidenceLevels )) && (result == S_FALSE); level++ )
		{
			for(	*selectedCallto = calltoCollection->get_first();
					*selectedCallto != NULL;
					*selectedCallto = calltoCollection->get_next() )
			{
				if( (*selectedCallto)->get_confidence() == confidenceLevels[ level ] )
				{
					result = S_OK;
					break;
				}
			}
		}
	}

	if( result != S_OK )
	{
		USES_RES2T
		::MessageBox( m_parent, RES2T( IDS_UNRESOLVED_MESSAGE ), RES2T( IDS_UNRESOLVED_CAPTION ), MB_OK );

		*selectedCallto = NULL;
	}

	return( result );

};	//	End of class CUIContext::disambiguate.


//--------------------------------------------------------------------------//
//	CUIContext::set_parentWindow.											//
//--------------------------------------------------------------------------//
void
CUIContext::set_parentWindow
(
	const HWND	window
){
//trace( TEXT( "CUIContext::set_parentWindow()\r\n" ) );

	m_parent = window;

};	//	End of class CUIContext::set_parentWindow.


//--------------------------------------------------------------------------//
//	CUIContext::set_callFlags.												//
//--------------------------------------------------------------------------//
void
CUIContext::set_callFlags
(
	const DWORD	callFlags
){
//trace( TEXT( "CUIContext::set_callFlags()\r\n" ) );

	m_callFlags = callFlags;

};	//	End of class CUIContext::set_callFlags.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::CGatekeeperContext.									//
//--------------------------------------------------------------------------//
CGatekeeperContext::CGatekeeperContext(void):
	m_enabled( false ),
	m_ipAddress( NULL )
{

}	//	End of CGatekeeperContext::CGatekeeperContext.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::~CGatekeeperContext.								//
//--------------------------------------------------------------------------//
CGatekeeperContext::~CGatekeeperContext(void)
{

	delete [] m_ipAddress;

}	//	End of CGatekeeperContext::~CGatekeeperContext.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::isEnabled.											//
//--------------------------------------------------------------------------//
bool
CGatekeeperContext::isEnabled(void) const
{

	return( m_enabled && (get_ipAddress() != NULL) );

}	//	End of CGatekeeperContext::isEnabled.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::get_ipAddress.										//
//--------------------------------------------------------------------------//
const TCHAR *
CGatekeeperContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CGatekeeperContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_enabled.										//
//--------------------------------------------------------------------------//
void
CGatekeeperContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CGatekeeperContext::set_enabled.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_gatekeeperName.									//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperContext::set_gatekeeperName
(
	const TCHAR * const	gatekeeperName
){
	TCHAR	ipAddress[ MAX_PATH ];
	HRESULT	result	= CCalltoContext::get_ipAddressFromName( gatekeeperName, ipAddress, elementsof( ipAddress ) );

	if( result == S_OK )
	{
		result = set_ipAddress( ipAddress );
	}

	return( result );

}	//	End of CGatekeeperContext::set_gatekeeperName.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_ipAddress.										//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CGatekeeperContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CGatewayContext::CGatewayContext.										//
//--------------------------------------------------------------------------//
CGatewayContext::CGatewayContext(void):
	m_enabled( false ),
	m_ipAddress( NULL )
{
}	//	End of CGatewayContext::CGatewayContext.


//--------------------------------------------------------------------------//
//	CGatewayContext::~CGatewayContext.										//
//--------------------------------------------------------------------------//
CGatewayContext::~CGatewayContext(void)
{

	delete [] m_ipAddress;

}	//	End of CGatewayContext::~CGatewayContext.


//--------------------------------------------------------------------------//
//	CGatewayContext::isEnabled.												//
//--------------------------------------------------------------------------//
bool
CGatewayContext::isEnabled(void) const
{

	return( m_enabled && (get_ipAddress() != NULL) );

}	//	End of CGatewayContext::isEnabled.


//--------------------------------------------------------------------------//
//	CGatewayContext::get_ipAddress.											//
//--------------------------------------------------------------------------//
const TCHAR *
CGatewayContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CGatewayContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_enabled.											//
//--------------------------------------------------------------------------//
void
CGatewayContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CGatewayContext::set_enabled.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_gatewayName.										//
//--------------------------------------------------------------------------//
HRESULT
CGatewayContext::set_gatewayName
(
	const TCHAR * const	gatewayName
){
	TCHAR	ipAddress[ MAX_PATH ];
	HRESULT	result	= CCalltoContext::get_ipAddressFromName( gatewayName, ipAddress, elementsof( ipAddress ) );

	if( result == S_OK )
	{
		result = set_ipAddress( ipAddress );
	}

	return( result );

}	//	End of CGatewayContext::set_gatewayName.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_ipAddress.											//
//--------------------------------------------------------------------------//
HRESULT
CGatewayContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CGatewayContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CILSContext::CILSContext.												//
//--------------------------------------------------------------------------//
CILSContext::CILSContext
(
	const TCHAR * const	ilsServer
):
	m_enabled( false ),
	m_ipAddress( NULL ),
	m_ilsName( NULL )
{
}	//	End of CILSContext::CILSContext.


//--------------------------------------------------------------------------//
//	CILSContext::~CILSContext.												//
//--------------------------------------------------------------------------//
CILSContext::~CILSContext(void)
{

	delete [] m_ipAddress;
	delete [] m_ilsName;

}	//	End of CILSContext::~CILSContext.


//--------------------------------------------------------------------------//
//	CILSContext::isEnabled.													//
//--------------------------------------------------------------------------//
bool
CILSContext::isEnabled(void) const
{

	return( (g_pLDAP != NULL) && (ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct) );

}	//	End of CILSContext::isEnabled.


//--------------------------------------------------------------------------//
//	CILSContext::get_ipAddress.												//
//--------------------------------------------------------------------------//
const TCHAR *
CILSContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CILSContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CILSContext::get_ilsName.												//
//--------------------------------------------------------------------------//
const TCHAR * const
CILSContext::get_ilsName(void) const
{

	return( m_ilsName );

}	//	End of CILSContext::get_ilsName.


//--------------------------------------------------------------------------//
//	CILSContext::set_enabled.												//
//--------------------------------------------------------------------------//
void
CILSContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CILSContext::set_enabled.


//--------------------------------------------------------------------------//
//	CILSContext::set_ilsName.												//
//--------------------------------------------------------------------------//
HRESULT
CILSContext::set_ilsName
(
	const TCHAR * const	ilsName
){
	HRESULT	result;

	if( m_ilsName && lstrcmpi( ilsName, m_ilsName ) == 0 )
	{
		result = S_OK;
	}
	else
	{
		result = E_FAIL;

		if( m_ilsName != NULL )
		{
			delete [] m_ilsName;
			m_ilsName = NULL;
		}

		if( ilsName != NULL )
		{
			if( (m_ilsName = new TCHAR [ lstrlen( ilsName ) + 1 ]) == NULL )
			{
				result = E_OUTOFMEMORY;
			}
			else
			{
				TCHAR	ipAddress[ MAX_PATH ];

				if( (result = CCalltoContext::get_ipAddressFromName( ilsName, ipAddress, elementsof( ipAddress ) )) == S_OK )
				{
					if( (result = set_ipAddress( ipAddress )) == S_OK )
					{
						lstrcpy( m_ilsName, ilsName );
					}
				}
			}
		}
	}

	return( result );

}	//	End of CILSContext::set_ilsName.


//--------------------------------------------------------------------------//
//	CILSContext::set_ipAddress.												//
//--------------------------------------------------------------------------//
HRESULT
CILSContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CILSContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CCalltoContext::CCalltoContext.											//
//--------------------------------------------------------------------------//
CCalltoContext::CCalltoContext()
{
}	//	End of CCalltoContext::CCalltoContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::~CCalltoContext.										//
//--------------------------------------------------------------------------//
CCalltoContext::~CCalltoContext()
{
}	//	End of CCalltoContext::~CCalltoContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::callto.													//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::callto
(
	const ICalltoProperties * const	calltoProperties,
	INmCall** ppInternalCall
){

	HRESULT	result	= CRPlaceCall( calltoProperties, this, ppInternalCall );

	if( FAILED( result ) )
	{
		DisplayCallError( result, calltoProperties->get_displayName() );
	}

	return( result );

}	//	End of CCalltoContext::callto.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_gatekeeperContext.									//
//--------------------------------------------------------------------------//
const IGatekeeperContext * const
CCalltoContext::get_gatekeeperContext(void) const
{

	return( (CGatekeeperContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_gatekeeperContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_gatewayContext.										//
//--------------------------------------------------------------------------//
const IGatewayContext * const
CCalltoContext::get_gatewayContext(void) const
{

	return( (CGatewayContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_gatewayContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ilsContext.											//
//--------------------------------------------------------------------------//
const IILSContext * const
CCalltoContext::get_ilsContext(void) const
{

	return( (CILSContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_ilsContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableUIContext.									//
//--------------------------------------------------------------------------//
IMutableUIContext * const
CCalltoContext::get_mutableUIContext(void) const
{

	return( (IMutableUIContext * const) this );

}	//	End of CCalltoContext::get_mutableUIContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableGatekeeperContext.							//
//--------------------------------------------------------------------------//
IMutableGatekeeperContext * const
CCalltoContext::get_mutableGatekeeperContext(void) const
{

	return( (IMutableGatekeeperContext * const) this );

}	//	End of CCalltoContext::get_mutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableGatewayContext.								//
//--------------------------------------------------------------------------//
IMutableGatewayContext * const
CCalltoContext::get_mutableGatewayContext(void) const
{

	return( (IMutableGatewayContext * const) this );

}	//	End of CCalltoContext::get_mutableGatewayContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableIlsContext.									//
//--------------------------------------------------------------------------//
IMutableILSContext * const
CCalltoContext::get_mutableIlsContext(void) const
{

	return( (IMutableILSContext * const) this );

}	//	End of CCalltoContext::get_mutableIlsContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::isPhoneNumber.											//
//--------------------------------------------------------------------------//
bool
CCalltoContext::isPhoneNumber
(
	const TCHAR *	phone
){
	bool	result	= ((phone != NULL) && (phone[ 0 ] != '\0'));

	while( (phone != NULL) && (phone[ 0 ] != '\0') )
	{
		switch( phone[ 0 ] )
		{

			default:
				result = false;	//	fall through...

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '(':
			case ')':
			case '#':
			case '*':
			case '-':
			case ',':
			case '+':
			case ' ':
				break;
		}
		
		phone++;
	}

	return( result );

}	//	End of CCalltoContext::isPhoneNumber.


//--------------------------------------------------------------------------//
//	CCalltoContext::toE164.													//
//--------------------------------------------------------------------------//
bool
CCalltoContext::toE164
(
	const TCHAR *	phone,
	TCHAR *			base10,
	int				size
){
	static TCHAR	base10map[]	=
	{
		0,		-1,		-1,		'#',	-1,		-1,		-1,		-1,		//	 !"#$%&'
		0,		0,		'*',	-1,		',',	0,		0,		-1,		//	()*+,-./
		'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',	//	01234567
		'8',	'9',	-1,		-1,		-1,		-1,		-1,		-1,		//	89:;<=>?
		-1,		'2',	'2',	'2',	'3',	'3',	'3',	'4',	//	@ABCDEFG
		'4',	'4',	'5',	'5',	'5',	'6',	'6',	'6',	//	HIJKLMNO
		'7',	'7',	'7',	'7',	'8',	'8',	'8',	'9',	//	PQRSTUVW
		'9',	'9',	'9',	-1,		-1,		-1,		-1,		-1,		//	XYZ[\]^_
		-1,		'2',	'2',	'2',	'3',	'3',	'3',	'4',	//	`abcdefg
		'4',	'4',	'5',	'5',	'5',	'6',	'6',	'6',	//	hijklmno
		'7',	'7',	'7',	'7',	'8',	'8',	'8',	'9',	//	pqrstuvw
		'9',	'9',	'9'												//	xyz
	};

	bool	result	= true;

	for( ; (*phone != NULL) && ((size > 0) || (base10 == NULL)) && result; phone++ )
	{
		if( (*phone >= ' ') && (*phone < (TCHAR) (' ' + elementsof( base10map ))) )
		{
			TCHAR	mapValue	= base10map[ *phone - ' ' ];

			if( mapValue == (TCHAR) -1 )
			{
				result = false;
			}
			else if( mapValue != (TCHAR) 0 )
			{
				if( base10 != NULL )
				{
					*base10++ = mapValue;
					size--;
				}
			}
		}
		else
		{
			result = false;
		}
	}

	if( (size <= 0) && (base10 != NULL) )
	{
		result = false;
	}
	else if( result )
	{
		if( base10 != NULL )
		{
			*base10 = NULL;
		}
	}

	return( result );

}	//	End of CCalltoContext::toE164.


//--------------------------------------------------------------------------//
//	CCalltoContext::isIPAddress.											//
//--------------------------------------------------------------------------//
bool
CCalltoContext::isIPAddress
(
	const TCHAR * const	ipAddress
){
	int		parts	= 0;
	bool	result;
	
	if( (result = (ipAddress != NULL)) != false )
	{
		const TCHAR *	ptr		= ipAddress;
		bool			newPart	= true;
		int				ipByte	= 0;
		int				base	= 10;

		while( result && (*ptr != NULL) && (parts <= 16) )
		{
			if( (*ptr >= '0') && (*ptr <= '9') )
			{
				if( newPart )
				{
					parts++;
					newPart = false;
				}

				if( (*ptr == '0') && (ipByte == 0) && (base == 10) )
				{
					base = 8;
				}
				else if( (base == 8) && ((*ptr == '8') || (*ptr == '9')) )
				{
					result = false;
				}
				else
				{
					ipByte = (ipByte * base) + (*ptr - '0');

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( (*ptr >= 'A') && (*ptr <= 'F') )
			{
				if( base != 16 )
				{
					result = false;
				}
				else
				{
					if( newPart )
					{
						parts++;
						newPart = false;
					}

					ipByte = (ipByte * 16) + (*ptr - 'A' + 10);

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( (*ptr >= 'a') && (*ptr <= 'f') )
			{
				if( base != 16 )
				{
					result = false;
				}
				else
				{
					if( newPart )
					{
						parts++;
						newPart = false;
					}

					ipByte = (ipByte * 16) + (*ptr - 'a' + 10);

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( *ptr == '.' )
			{
				newPart	= true;
				ipByte	= 0;
				base	= 10;
			}
			else if( (*ptr == 'x') || (*ptr == 'X') )
			{
				base	= 16;
				result	= (ipByte == 0);
			}
			else
			{
				result = false;
			}

			ptr++;
		}

		if( result )
		{
			if( (parts != 4) && (parts != 16) )		//	4 for IPv4, 16 for IPv6 (IPng)...
			{
				if( (result = (parts < 4)) != false )
				{
#if !defined( UNICODE )
					result = (inet_addr( ipAddress ) != INADDR_NONE);	// Check for valid 1, 2, or 3 part IPv4 address...
#else
					result = false;

					char *	ansiIPAddress;
					int		size;

					size = WideCharToMultiByte(	CP_ACP,		// code page
												0,			// performance and mapping flags
												ipAddress,	// address of wide-character string
												-1,			// number of characters in string
												NULL,		// address of buffer for new string
												0,			// size of buffer
												NULL,		// address of default for unmappable characters
												NULL );		// address of flag set when default char. used

					if( (ansiIPAddress = new char [ size ]) != NULL )
					{
						size = WideCharToMultiByte(	CP_ACP,			// code page
													0,				// performance and mapping flags
													ipAddress,		// address of wide-character string
													-1,				// number of characters in string
													ansiIPAddress,	// address of buffer for new string
													size,			// size of buffer
													NULL,			// address of default for unmappable characters
													NULL );			// address of flag set when default char. used

						if( size != 0 )
						{
							result = (inet_addr( ansiIPAddress ) != INADDR_NONE);	// Check for valid 1-4 part IPv4 address...
						}

						delete [] ansiIPAddress;
					}
#endif	//	!defined( UNICODE )
				}
			}
		}
	}

	return( result );

}	//	End of CCalltoContext::isIPAddress.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ipAddressFromName.									//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::get_ipAddressFromName
(
	const TCHAR * const	name,
	TCHAR *				buffer,
	int					length
){
	HRESULT	result	= S_FALSE;

	if( (name != NULL) && (buffer != NULL) )
	{
		if( isIPAddress( name ) )
		{
			if( lstrlen( name ) < length )
			{
				lstrcpy( buffer, name );
				result = S_OK;
			}
		}
		else
		{
			HOSTENT *	hostEntry;

#if !defined( UNICODE )
			if( (hostEntry = gethostbyname( name )) != NULL )
			{
				if( hostEntry->h_addr_list[ 0 ] != NULL )
				{
					const char * const	ipAddress	= inet_ntoa( *((in_addr *) hostEntry->h_addr_list[ 0 ]) );

					if( lstrlen( ipAddress ) < length )
					{
						lstrcpy( buffer, ipAddress );
						result = S_OK;
					}
				}
			}
#else
			char *	ansiHost;
			int		size;

			size = WideCharToMultiByte(	CP_ACP,		// code page
										0,			// performance and mapping flags
										name,		// address of wide-character string
										-1,			// number of characters in string
										NULL,		// address of buffer for new string
										0,			// size of buffer
										NULL,		// address of default for unmappable characters
										NULL );		// address of flag set when default char. used

			if( (ansiHost = new char [ size ]) == NULL )
			{
				result = E_OUTOFMEMORY;
			}
			else
			{
				size = WideCharToMultiByte(	CP_ACP,		// code page
											0,			// performance and mapping flags
											name,		// address of wide-character string
											-1,			// number of characters in string
											ansiHost,	// address of buffer for new string
											size,		// size of buffer
											NULL,		// address of default for unmappable characters
											NULL );		// address of flag set when default char. used

				if( size != 0 )
				{
					if( (hostEntry = gethostbyname( ansiHost )) != NULL )
					{
						if( hostEntry->h_addr_list[ 0 ] != NULL )
						{
							const char * const	ipAddress = inet_ntoa( *((in_addr *) hostEntry->h_addr_list[ 0 ]) );

							if( lstrlen( ipAddress ) < length )
							{
								MultiByteToWideChar(	CP_ACP,				//	code page
														MB_PRECOMPOSED,		//	character-type options
														ipAddress,			//	string to convert
														-1,					//	length of string to convert
														buffer,				//	address of wide character buffer
														length );			//	size of buffer

								result = S_OK;
							}
						}
					}
				}

				delete [] ansiHost;
			}
#endif	// !defined( UNICODE )
		}
	}

	return( result );

}	//	End of CCalltoContext::get_ipAddressFromName.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ipAddressFromILSEmail.								//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::get_ipAddressFromILSEmail
(
	const TCHAR * const	ilsServer,
	const TCHAR * const	ilsPort,
	const TCHAR * const	email,
	TCHAR * const		ipAddress,
	const int			size
){
	HRESULT	result;

	if( g_pLDAP == NULL )
	{
		g_pLDAP = new CNmLDAP;
	}

	if( g_pLDAP == NULL )
	{
		result = E_FAIL;
	}
	else
	{
		int	port	= (ilsPort != NULL)? (int) DecimalStringToUINT( ilsPort ): LDAP_PORT;

		result = g_pLDAP->ResolveUser( email, ilsServer, ipAddress, size, port );
	}

	return( result );

}	//	End of CCalltoContext::get_ipAddressFromILSEmail.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calllog.h ===
//
// CallLog.h
//
// Created:  ChrisPi   10-17-96
//

#ifndef _CALLLOG_H_
#define _CALLLOG_H_

#include <cstring.hpp>

// CCallLogEntry flags:
const DWORD CLEF_ACCEPTED =			0x00000001;
const DWORD CLEF_REJECTED =			0x00000002;
const DWORD CLEF_AUTO_ACCEPTED =	0x00000004; // call was auto-accepted
const DWORD CLEF_TIMED_OUT =		0x00000008; // call was rejected due to timeout
const DWORD CLEF_SECURE =           0x00000010; // call was secure

const DWORD CLEF_NO_CALL  =         0x40000000; // No call back information
const DWORD CLEF_DELETED  =         0x80000000; // Record marked for deletion


// The header for a record in the call log file
typedef struct _tagLogHdr {
	DWORD dwSize;              // size of this entire record
	DWORD dwCLEF;              // CallLogEntry Flags (CLEF_*)
	DWORD dwPF;                // Participant flags (PF_*)
	DWORD cbName;              // size of szName, in bytes, including NULL
	DWORD cbData;              // size of rgData, in bytes
	DWORD cbCert;              // size of certificate data in bytes
	SYSTEMTIME 	sysTime;       // date/time of record creation
//  WCHAR szName;              // null terminated display name (in UNICODE)
//  BYTE  ri[];                // Roster Information
} LOGHDR;
typedef LOGHDR * PLOGHDR;


class CCallLog;
class CRosterInfo;

class CCallLogEntry
{
protected:
	LPTSTR			m_pszName;
	DWORD			m_dwFlags;
	SYSTEMTIME		m_st;
	CRosterInfo*	m_pri;
	PBYTE           m_pbCert;
	ULONG           m_cbCert;
	DWORD           m_dwFileOffset; // offset in log file

	friend		CCallLog;
public:
	CCallLogEntry(LPCTSTR pcszName, DWORD dwFlags, CRosterInfo* pri,
				LPVOID pvRosterData, PBYTE pbCert, ULONG cbCert, LPSYSTEMTIME pst, DWORD dwFileOffset);
	~CCallLogEntry();

	LPTSTR			GetName()		{ return m_pszName;		};
	DWORD			GetFlags()		{ return m_dwFlags;		};
	LPSYSTEMTIME	GetTime()		{ return &m_st;			};
	CRosterInfo*	GetRosterInfo()	{ return m_pri;			};
	DWORD			GetFileOffset()	{ return m_dwFileOffset;};
};



class CCallLog : public CSimpleArray<CCallLogEntry*>
{
private:
	BOOL    m_fUseList;            // if TRUE, add data to list
	BOOL    m_fDataRead;           // if TRUE, data has been read
	CSTRING m_strFile;             // Filename
	DWORD   m_Expire;              // Days before expiring an entry

	int		m_cTotalEntries;		// Total number of records in the log
	int		m_cDeletedEntries;		// Number of records marked for deletion
	int		m_cMaxEntries;			// Configurable max entries in file

	VOID    InitLogData(LPCTSTR pszKey, LPCTSTR pszDefault);
	HANDLE  OpenLogFile(VOID);
	BOOL    ReadData(HANDLE hFile, PVOID pv, UINT cb);
	HRESULT WriteData(HANDLE hFile, LPDWORD pdwOffset, PVOID pv, DWORD cb);
	HRESULT ReadEntry(HANDLE hFile, DWORD * pdwFileOffset, CCallLogEntry** ppcle);
	DWORD   WriteEntry(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert);
	VOID    LoadFileData(VOID);
	VOID	RewriteFile(VOID);

public:
	CCallLog(LPCTSTR pszKey, LPCTSTR pszDefault);
	~CCallLog();

	HRESULT  AddCall(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert);

private:
	HRESULT  DeleteEntry(CCallLogEntry * pcle);
};

#endif // !_CALLLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\callto.cpp ===
#include	"precomp.h"
#include	"call.h"
#include	"callto.h"
#include	"conf.h"
#include	"confroom.h"
#include	"confpolicies.h"
#include	"confutil.h"
#include	"nmldap.h"


const int	CCallto::s_iMaxCalltoLength		= 255;
const int	CCallto::s_iMaxAddressLength	= 255;

//--------------------------------------------------------------------------//
//	CCallto::CCallto.														//
//--------------------------------------------------------------------------//
CCallto::CCallto(void):
	m_bUnescapedAddressOnly( false ),
	m_ulDestination( INADDR_NONE ),
	m_bGatekeeperEnabled( false ),
	m_pszGatekeeperName( NULL ),
	m_ulGatekeeperAddress( INADDR_NONE ),
	m_bGatewayEnabled( false ),
	m_pszGatewayName( NULL ),
	m_ulGatewayAddress( INADDR_NONE ),
	m_pszDefaultIlsServerName( NULL ),
	m_pszCalltoBuffer( NULL ),
	m_pszDisplayName( NULL )
{
}	//	End of CCallto::CCallto.


//--------------------------------------------------------------------------//
//	CCallto::~CCallto.														//
//--------------------------------------------------------------------------//
CCallto::~CCallto(void)
{
	delete [] m_pszGatekeeperName;
	delete [] m_pszGatewayName;
	delete [] m_pszDefaultIlsServerName;
	delete [] m_pszCalltoBuffer;
	delete [] m_pszDisplayName;

}	//	End of CCallto::~CCallto.


//--------------------------------------------------------------------------//
//	CCallto::Callto.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::Callto
(
	const TCHAR * const	pszCallto,				//	pointer to the callto url to try to place the call with...
	const TCHAR * const	pszDisplayName,			//	pointer to the display name to use...
	const NM_ADDR_TYPE	nmType,					//	callto type to resolve this callto as...
	const bool			bAddressOnly,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
	const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
	const bool			bAddToMru,				//	whether or not save in mru...
	const bool			bUIEnabled,				//	whether or not to perform user interaction on errors...
	const HWND			hwndParent,				//	if bUIEnabled is true this is the window to parent error/status windows to...
	INmCall ** const	ppInternalCall			//	out pointer to INmCall * to receive INmCall * generated by placing call...
){
	ASSERT( pszCallto != NULL );
	ASSERT( (hwndParent == NULL) || IsWindow( hwndParent ) );

	HRESULT	hrResult;

	//	These members need to be reset at the beginning of every call...
	m_bUIEnabled			= bUIEnabled;
	m_hwndParent			= hwndParent;
	m_ulDestination			= INADDR_NONE;
	m_bUnescapedAddressOnly	= bAddressOnly;
	m_pszDisplayName		= PszAlloc( pszDisplayName );
	
	m_Parameters.SetParams( NULL );		//	Need to reset all parameter settings too...

	//	Process the callto...
	if( (hrResult = Parse( pszCallto )) == S_OK )
	{
		//	Validate that the security specified (if any) is compatible with current NM state.
		bool	bValidatedSecurity;

		if( (hrResult = GetValidatedSecurity( pbSecurityPreference, bValidatedSecurity )) == S_OK )
		{
			if( (hrResult = Resolve( nmType )) == S_OK )
			{
				hrResult = PlaceCall( pszCallto, bAddToMru, bValidatedSecurity, ppInternalCall );
			}
		}
	}

	if( FAILED( hrResult ) && m_bUIEnabled )
	{
		DisplayCallError( hrResult, (pszDisplayName != NULL)? pszDisplayName: pszCallto );
	}

	delete [] m_pszCalltoBuffer;
	delete [] m_pszDisplayName;
	m_pszCalltoBuffer	= NULL;
	m_pszDisplayName	= NULL;

	return( hrResult );

}	//	End of CCallto::Callto.


//--------------------------------------------------------------------------//
//	CCallto::Parse.															//
//--------------------------------------------------------------------------//
HRESULT CCallto::Parse
(
	const TCHAR * const	pszCallto	//	pointer to the callto url to parse...
){
	ASSERT( pszCallto != NULL );
	ASSERT( m_ulDestination == INADDR_NONE );

	HRESULT	hrResult;

	if( (m_pszCalltoBuffer = PszAlloc( pszCallto )) == NULL )	//	Make a copy that we can modify in place...
	{
		hrResult = E_OUTOFMEMORY;
	}
	else if( TrimSzCallto( m_pszCalltoBuffer ) == 0 )		//	Remove any leading/trailing blanks...
	{
		hrResult = NM_CALLERR_PARAM_ERROR;	//	Entire string was blanks...
	}
	else
	{
		hrResult = S_OK;

		m_pszParsePos = m_pszCalltoBuffer;

		if( !m_bUnescapedAddressOnly )
		{
			//	Skip over "callto:" or "callto://" which mean nothing to us now...
			static const TCHAR	pszCallto2[]			= TEXT( "callto:" );
			static const TCHAR	pszDoubleSlash[]	= TEXT( "//" );

			if( StrCmpNI_literal( m_pszCalltoBuffer, pszCallto2 ) )
			{
				m_pszParsePos = m_pszCalltoBuffer + strlen_literal( pszCallto2 );

				if( StrCmpNI_literal( m_pszParsePos, pszDoubleSlash ) )
				{
					m_pszParsePos += strlen_literal( pszDoubleSlash );
				}
			}

			int	iLength	= lstrlen( m_pszCalltoBuffer );

			if( m_pszCalltoBuffer[ iLength - 1 ] == '/' )
			{
				m_pszCalltoBuffer[ iLength - 1 ] = '\0';	//	The shell seems to add a trailing slash before calling us...
			}
		}

		//	Break the callto into two pieces at the start of the parameters (if any)...
		m_pszParameters = StrChr( m_pszCalltoBuffer, '+' );

		if( m_pszParameters != NULL )
		{
			if( m_bUnescapedAddressOnly )
			{
				//	Sorry but '+' not allowed in addressing component...
				hrResult = NM_CALLERR_INVALID_ADDRESS;
			}
			else
			{
				*m_pszParameters++ = '\0';
			}
		}

		if( hrResult == S_OK )
		{
			//	Make sure we have something left before going on...
			if( m_pszParsePos[ 0 ] == '\0' )
			{
				hrResult = NM_CALLERR_NO_ADDRESS;
			}
			else
			{
				//	Not really a parsing thing but what we have at this point is conveiniently
				//	exactly what we want to use for a display name if one wasn't specified so
				//	save a copy of it before ParseAddress breaks it up into pieces...
				if( m_pszDisplayName == NULL )
				{
					m_pszDisplayName = PszAlloc( m_pszParsePos );
				}

				if( m_pszParameters != NULL )
				{
					//	Send the parameters off to be parsed...
					hrResult = m_Parameters.SetParams( m_pszParameters );
				}

				if( hrResult == S_OK )
				{
					//	Go parse the addressing component...
					hrResult = ParseAddress();
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::Parse.


//--------------------------------------------------------------------------//
//	CCallto::ParseAddress.													//
//--------------------------------------------------------------------------//
HRESULT CCallto::ParseAddress(void)
{
	ASSERT( m_pszCalltoBuffer != NULL );

	HRESULT	hrResult	= NM_CALLERR_INVALID_ADDRESS;

	if( m_Parameters.GetBooleanParam( TEXT( "h323" ), true ) && inGatekeeperMode() )
	{
		m_pszAddress	= m_pszParsePos;
		hrResult		= S_OK;			//	Bless you gatekeeper...
	}
	else if( StrChr( m_pszParsePos, '=' ) == NULL )		//	We're not going to allow the address component to contain an '='...
	{
		//	The address is allowed to be one of these formats...
		//		(1) string
		//		(2) server/email
		//		(3) server:port/email
		//	This means it may contain at most one ':', at most one '/',
		//	and given a ':', there must be a following '/'...

		TCHAR * const	pszColon	= StrChr( m_pszParsePos, ':' );
		TCHAR * const	pszSlash	= StrChr( m_pszParsePos, '/' );

		if( (pszSlash == NULL) && (pszColon == NULL) )
		{
			//	It's a valid simple (1) string format...
			m_pszAddress	= m_pszParsePos;
			m_pszIlsServer	= NULL;
			m_uiIlsPort		= DEFAULT_LDAP_PORT;
			m_pszEmail		= m_pszParsePos;

			if( m_bUnescapedAddressOnly )
			{
				hrResult = S_OK;	//	Done...
			}
			else
			{
				//	Need to unescape m_pszAddress but not m_pszEmail because it points to the same place...
				hrResult = Unescape( m_pszAddress );
			}
		}
		else if( (pszSlash != NULL) && (pszColon == NULL) )
		{
			if( StrChr( pszSlash + 1, '/' ) == NULL )
			{
				//	No colon and only one slash so it's a valid (2) format
				//	as long as each side is non zero length...
				if( (pszSlash > m_pszParsePos) && (lstrlen( pszSlash ) > 1) )
				{
					m_pszAddress	= TEXT( "" );
					m_pszIlsServer	= m_pszParsePos;
					m_uiIlsPort		= DEFAULT_LDAP_PORT;
					m_pszEmail		= pszSlash + 1;
					*pszSlash		= '\0';

					if( m_bUnescapedAddressOnly )
					{
						hrResult = S_OK;	//	Done...
					}
					else
					{
						if( (hrResult = Unescape( m_pszIlsServer )) == S_OK )
						{
							hrResult = Unescape( m_pszEmail );
						}
					}
				}
			}
		}
		else if( (pszSlash != NULL) && (pszColon != NULL) )
		{
			//	Make sure the ':' preceeds the '/' and there's only one of each...
			if( (pszColon < pszSlash) && (StrChr( pszSlash + 1, '/') == NULL) && (StrChr( pszColon + 1, ':' ) == NULL) )
			{
				//	One colon and one slash in the correct order so it's a valid (3) format as long
				//	as all three pieces are non zero length and the port piece is a number...
				if( (pszColon > m_pszParsePos) && (pszSlash > pszColon + 1) && (lstrlen( pszSlash ) > 1) )
				{
					//	We're not in gatekeeper mode so break it up into server, port, and email...
					m_pszAddress	= TEXT( "" );
					m_pszIlsServer	= m_pszParsePos;
					m_pszEmail		= pszSlash + 1;
					*pszColon		= '\0';
					*pszSlash		= '\0';

					if( m_bUnescapedAddressOnly )
					{
						hrResult = DecimalStringToUINT( pszColon + 1, m_uiIlsPort );
					}
					else
					{
						if( (hrResult = Unescape( m_pszIlsServer )) == S_OK )
						{
							if( (hrResult = Unescape( m_pszEmail )) == S_OK )
							{
								if( (hrResult = Unescape( pszColon + 1 )) == S_OK )
								{
									hrResult = DecimalStringToUINT( pszColon + 1, m_uiIlsPort );
								}
							}
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::ParseAddress.


//--------------------------------------------------------------------------//
//	CCallto::Resolve.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::Resolve
(
	const NM_ADDR_TYPE	nmType		//	callto type to resolve this callto as...
){
	HRESULT	hrResult;

	//	First set our address type...

	if( (nmType != NM_ADDR_UNKNOWN) && (nmType != NM_ADDR_CALLTO) )
	{
		m_nmAddressType = nmType;
	}
	else
	{
		const TCHAR * const	pszType	= m_Parameters.GetParam( TEXT( "type" ), NULL );

        if(NULL != pszType)
        {
    		if( lstrcmpi( pszType, TEXT( "phone" ) ) == 0 )
    		{
    			m_nmAddressType = NM_ADDR_ALIAS_E164;
    		}
    		else if( lstrcmpi( pszType, TEXT( "ip" ) ) == 0 )
    		{
    			m_nmAddressType = NM_ADDR_IP;
    		}
    		else if( lstrcmpi( pszType, TEXT( "host" ) ) == 0 )
    		{
    			m_nmAddressType = NM_ADDR_MACHINENAME;
    		}
    		else if( lstrcmpi( pszType, TEXT( "directory" ) ) == 0 )
    		{
    			m_nmAddressType = NM_ADDR_ULS;
    		}
    		else
    		{
    			m_nmAddressType = NM_ADDR_UNKNOWN;
    		}
        }
        else
        {
            m_nmAddressType = NM_ADDR_UNKNOWN;
        }
	}

	//	Then see what we should do with it...

	if( m_Parameters.GetBooleanParam( TEXT( "h323" ), true ) && inGatekeeperMode() )
	{
		if (!IsGatekeeperLoggedOn() && !IsGatekeeperLoggingOn())
		{
			hrResult = NM_CALLERR_NOT_REGISTERED;
		}
		else
		{
			//	We can always send anything to the gatekeeper for actual resolution...
			if( (hrResult = GetGatekeeperIpAddress( m_ulDestination )) == S_OK )
			{
				if( m_nmAddressType == NM_ADDR_ALIAS_E164 )		//	should this also check for NM_ADDR_H323_GATEWAY???
				{
					CleanupE164StringEx( m_pszAddress );
				}
				else
				{
					m_nmAddressType = NM_ADDR_ALIAS_ID;
				}
			}
		}
	}
	else
	{
		switch( m_nmAddressType )
		{
			case NM_ADDR_ALIAS_ID:
			{
				hrResult = NM_CALLERR_NO_GATEKEEPER;
			}
			break;

			case NM_ADDR_ALIAS_E164:
			case NM_ADDR_H323_GATEWAY:
			{
				if( inGatewayMode() )
				{
					if( (hrResult = GetGatewayIpAddress( m_ulDestination )) == S_OK )
					{
						//	Explicit phone types are also still resolvable in gateway mode...
						CleanupE164StringEx( m_pszAddress );
					}
				}
				else
				{
					hrResult = NM_CALLERR_NO_PHONE_SUPPORT;
				}
			}
			break;

			case NM_ADDR_IP:
			{
				if( (hrResult = GetIpAddress( m_pszAddress, m_ulDestination )) != S_OK )
				{
					hrResult = NM_CALLERR_INVALID_IPADDRESS;
				}
			}
			break;

			case NM_ADDR_MACHINENAME:
			{
				if( (hrResult = GetIpAddressFromHostName( m_pszAddress, m_ulDestination )) != S_OK )
				{
					hrResult = NM_CALLERR_HOST_RESOLUTION_FAILED;
				}
			}
			break;

			case NM_ADDR_ULS:
			{
				//	Ils types need to be resolved against an ils...
				hrResult = GetIpAddressFromIls(	m_ulDestination );
			}
			break;

			default:
			{
				//	If we get here the type was unspecified (Automatic or 2.xx)...
				//	Our order of precedence is ipaddress,hostname,ils,fail...
				//	We will not try phone since it didn't explicitly have a phone type...

				if( (hrResult = GetIpAddress( m_pszAddress, m_ulDestination )) == S_OK )
				{
					m_nmAddressType = NM_ADDR_IP;
				}
				else
				{
					//	It's not a valid ip address so try it next as a host name...
					if( (hrResult = GetIpAddressFromHostName( m_pszAddress, m_ulDestination )) == S_OK )
					{
						m_nmAddressType = NM_ADDR_MACHINENAME;
					}
					else
					{
						//	It's not a valid host name either so try it finally as an ils lookup...
						if ( (hrResult = GetIpAddressFromIls( m_ulDestination )) == S_OK )
						{
							m_nmAddressType = NM_ADDR_ULS;
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::Resolve.


//--------------------------------------------------------------------------//
//	CCallto::PlaceCall.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::PlaceCall
(
	const TCHAR * const	pszCallto,			//	pointer to the original callto...
	const bool			bAddToMru,			//	whether or not save in mru...
	const bool			bSecure,			//	whether or not to place the call securely...
	INmCall ** const	ppInternalCall		//	out pointer to INmCall * to receive INmCall * generated by placing call...
){
	ASSERT( m_ulDestination != INADDR_NONE );

	const TCHAR * const	pszConferenceName	= m_Parameters.GetParam( TEXT( "conference" ), NULL );
	const TCHAR * const	pszPassword			= m_Parameters.GetParam( TEXT( "password" ), NULL );
	const bool			bH323				= m_Parameters.GetBooleanParam( TEXT( "h323" ), true );
	const bool			bAV					= m_Parameters.GetBooleanParam( TEXT( "av" ), true );
	const bool			bData				= m_Parameters.GetBooleanParam( TEXT( "data" ), true );
	const TCHAR * const	pszAlias			= NULL;
	const TCHAR * const	pszE164				= NULL;
	HRESULT				hrResult;

	if( IsLocalIpAddress( m_ulDestination ) )	
	{
		//	We don't want to go any further if we are attempting to call ourselves...
		hrResult = NM_CALLERR_LOOPBACK;
	}
	else
	{
		//	Map to old style call flags...

		DWORD	dwCallFlags	= 0;

		if( pszConferenceName != NULL )
		{
			dwCallFlags |= CRPCF_JOIN;
		}

		if( bH323 )
		{
			dwCallFlags |= CRPCF_H323CC;
		}
		
		if( bSecure )
		{
			dwCallFlags |= CRPCF_SECURE;
		}
		else if( bAV )
		{
			if( g_uMediaCaps & (CAPFLAG_RECV_AUDIO | CAPFLAG_SEND_AUDIO) )
			{
				dwCallFlags |= CRPCF_AUDIO;
			}

			if( g_uMediaCaps & (CAPFLAG_RECV_VIDEO | CAPFLAG_SEND_VIDEO) )
			{
				dwCallFlags |= CRPCF_VIDEO;
			}
		}

		if( bData )
		{
			dwCallFlags |= CRPCF_DATA | CRPCF_T120;
		}

		if (((CRPCF_T120 | CRPCF_DATA) != (dwCallFlags & (CRPCF_T120 | CRPCF_DATA))) &&
			((CRPCF_H323CC | CRPCF_AUDIO) != ( dwCallFlags & (CRPCF_H323CC | CRPCF_AUDIO))) &&
			((CRPCF_H323CC | CRPCF_VIDEO) != ( dwCallFlags & (CRPCF_H323CC | CRPCF_VIDEO))))
			 
		{
			hrResult = NM_CALLERR_UNKNOWN;
		}

		CConfRoom *	pConfRoom	= ::GetConfRoom();
		ASSERT(pConfRoom);

		if (_Module.IsUIActive())
		{
			pConfRoom->BringToFront();
		}

		if( !(pConfRoom->GetMeetingPermissions() & NM_PERMIT_OUTGOINGCALLS) )
		{
			ERROR_OUT( ("CCallto::PlaceCall: meeting setting permissions do not permit outgoing calls...") );
		}
		else
		{
			CCall *	pCall	= new CCall( pszCallto, m_pszDisplayName, m_nmAddressType, bAddToMru, FALSE );

			if( pCall == NULL )
			{
				ERROR_OUT( ("CCallto::PlaceCall: CCall object not created...") );
				hrResult = E_OUTOFMEMORY;
			}
			else
			{
				pCall->AddRef(); // Protect against another thread canceling this call
				
				IncrementBusyOperations();
				{
					const TCHAR *		pszCallAlias	= (m_nmAddressType == NM_ADDR_ULS)? m_pszEmail: m_pszAddress;
					const char * const	pszDestination	= inet_ntoa( *reinterpret_cast<in_addr *>(&m_ulDestination) );

					hrResult = pCall->PlaceCall(	dwCallFlags,		//	call flags bit mask, is there a good reason why they're not named?
													m_nmAddressType,	//	address type.
													pszDestination,		//	setup address.
													pszDestination,		//	destination address.
													pszCallAlias,		//	alias.
													NULL,				//	callto url.
													pszConferenceName,	//	conference name.
													pszPassword,		//	conference password.
													NULL );				//	user data.
				}
				DecrementBusyOperations();
				
				if( FAILED( hrResult ) && (pCall->GetState() == NM_CALL_INVALID) )
				{
					// just release the call to free the data
					// otherwise wait for the call state to be changed
					pCall->Release();
				}

				if( ppInternalCall )
				{
					*ppInternalCall = pCall->GetINmCall();
					(*ppInternalCall)->AddRef();
				}

				pCall->Release();
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::PlaceCall.


//--------------------------------------------------------------------------//
//	CCallto::GetValidatedSecurity.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetValidatedSecurity
(
	const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
	bool &				bValidatedSecurity		//	out bool reference to recieve validated security setting
){
	HRESULT	hrResult;

	//	First figure out what security setting is desired...

	if( pbSecurityPreference != NULL )
	{
		//	A preference was specified so use it.
		bValidatedSecurity = *pbSecurityPreference;
	}
	else
	{
		//	No preference was specified either so check for secure param
		//	passing the current system settings to use as the default.

		bool	bUserAlterable;
		bool	bDefaultSecurity;

		CConfRoom::get_securitySettings( bUserAlterable, bDefaultSecurity );
		
		bValidatedSecurity = m_Parameters.GetBooleanParam( TEXT( "secure" ), bDefaultSecurity );
	}

	//	And then validate that the desired setting is allowed...

    int	iSecurityPolicy	= ConfPolicies::GetSecurityLevel();

	if( (bValidatedSecurity && (iSecurityPolicy == DISABLED_POL_SECURITY)) ||
		((!bValidatedSecurity) && (iSecurityPolicy == REQUIRED_POL_SECURITY)) )
	{
		//	There was a mismatch between what they want and what they can have...
		//	Set security to what they can have and return mismatch error...

		bValidatedSecurity	= (iSecurityPolicy == REQUIRED_POL_SECURITY);
		hrResult			= NM_CALLERR_SECURITY_MISMATCH;
	}
	else
	{
		hrResult = S_OK;
    }

	return( hrResult );

}	//	End of CCallto::GetValidatedSecurity.


//--------------------------------------------------------------------------//
//	CCallto::inGatekeeperMode.												//
//--------------------------------------------------------------------------//
bool CCallto::inGatekeeperMode(void)
{
	return(ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );

}	//	End of CCallto::inGatekeeperMode.


//--------------------------------------------------------------------------//
//	CCallto::SetGatekeeperEnabled.											//
//--------------------------------------------------------------------------//
void CCallto::SetGatekeeperEnabled
(
	const bool	bEnabled	//	new Gatekeeper state
){

	m_bGatekeeperEnabled = bEnabled;

}	//	End of CCallto::SetGatekeeperEnabled.


//--------------------------------------------------------------------------//
//	CCallto::SetGatekeeperName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetGatekeeperName
(
	const TCHAR * const	pszGatekeeperName	//	pointer to new Gatekeeper name
){

	if( lstrcmpi( pszGatekeeperName, m_pszGatekeeperName ) != 0 )
	{
		delete [] m_pszGatekeeperName;

		m_pszGatekeeperName		= PszAlloc( pszGatekeeperName );
		m_ulGatekeeperAddress	= INADDR_NONE;	//	We reset this cached value when the name changes...
	}

	ASSERT( (m_pszGatekeeperName != NULL) || (pszGatekeeperName == NULL) );

	return( ((pszGatekeeperName != NULL) && (m_pszGatekeeperName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetGatekeeperName.


//--------------------------------------------------------------------------//
//	CCallto::GetGatekeeperIpAddress.										//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetGatekeeperIpAddress
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive gatekeeper IP address
){
	ASSERT( m_pszGatekeeperName != NULL );

	if( m_ulGatekeeperAddress == INADDR_NONE )
	{
		GetIpAddressFromHostName( m_pszGatekeeperName, m_ulGatekeeperAddress );
	}

	ulIpAddress = m_ulGatekeeperAddress;

	return( (m_ulGatekeeperAddress != INADDR_NONE)? S_OK: NM_CALLERR_NO_GATEKEEPER );

}	//	End of CCallto::GetGatekeeperIpAddress.


//--------------------------------------------------------------------------//
//	CCallto::inGatewayMode.													//
//--------------------------------------------------------------------------//
bool CCallto::inGatewayMode(void)
{

	return( (m_bGatewayEnabled && (m_pszGatewayName != NULL)) || (m_Parameters.GetParam( TEXT( "gateway" ), NULL ) != NULL) );

}	//	End of CCallto::inGatewayMode.


//--------------------------------------------------------------------------//
//	CCallto::SetGatewayEnabled.												//
//--------------------------------------------------------------------------//
void CCallto::SetGatewayEnabled
(
	const bool	bEnabled	//	new Gateway state
){

	m_bGatewayEnabled = bEnabled;

}	//	End of CCallto::SetGatewayEnabled.


//--------------------------------------------------------------------------//
//	CCallto::SetGatewayName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetGatewayName
(
	const TCHAR * const	pszGatewayName	//	pointer to new Gateway name
){

	if( lstrcmpi( pszGatewayName, m_pszGatewayName ) != 0 )
	{
		delete [] m_pszGatewayName;

		m_pszGatewayName	= PszAlloc( pszGatewayName );
		m_ulGatewayAddress	= INADDR_NONE;	//	We reset this cached value when the name changes...
	}

	ASSERT( (m_pszGatewayName != NULL) || (pszGatewayName == NULL) );

	return( ((pszGatewayName != NULL) && (m_pszGatewayName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetGatewayName.


//--------------------------------------------------------------------------//
//	CCallto::GetGatewayIpAddress.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetGatewayIpAddress
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive gateway IP address
){

	const TCHAR * const	pszGateway	= m_Parameters.GetParam( TEXT( "gateway" ), NULL );

	if( pszGateway != NULL )
	{
		//	A non-default gateway was specified with this callto...
		GetIpAddressFromHostName( pszGateway, ulIpAddress );
	}
	else
	{
		if( m_ulGatewayAddress == INADDR_NONE )
		{
			GetIpAddressFromHostName( m_pszGatewayName, m_ulGatewayAddress );
		}

		ulIpAddress = m_ulGatewayAddress;
	}

	return( (ulIpAddress != INADDR_NONE)? S_OK: NM_CALLERR_NO_GATEWAY );

}	//	End of CCallto::GetGatewayIpAddress.


//--------------------------------------------------------------------------//
//	CCallto::SetIlsServerName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetIlsServerName
(
	const TCHAR * const	pszServerName	//	pointer to new default Ils server name
){

	delete [] m_pszDefaultIlsServerName;
	
	m_pszDefaultIlsServerName = PszAlloc( pszServerName );

	ASSERT( (m_pszDefaultIlsServerName != NULL) || (pszServerName == NULL) );

	return( ((pszServerName != NULL) && (m_pszDefaultIlsServerName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetIlsServerName.


//--------------------------------------------------------------------------//
//	CCallto::GetIpAddressFromIls.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetIpAddressFromIls
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( m_pszEmail != NULL );

	HRESULT	hrResult;

	const TCHAR * const	pszActiveIlsServer	= (m_pszIlsServer != NULL)? m_pszIlsServer: m_pszDefaultIlsServerName;

	if( pszActiveIlsServer == NULL )
	{
		hrResult = NM_CALLERR_NO_ILS;
	}

	if( g_pLDAP == NULL )
	{
		g_pLDAP = new CNmLDAP;
	}

	ASSERT( g_pLDAP != NULL );

	if( g_pLDAP == NULL )
	{
		hrResult = E_OUTOFMEMORY;
	}
	else
	{
		TCHAR	szIpAddress[ 64 ];

		hrResult = g_pLDAP->ResolveUser( m_pszEmail, pszActiveIlsServer, szIpAddress, ARRAY_ELEMENTS( szIpAddress ), m_uiIlsPort );

		if( hrResult == S_OK )
		{
			//	Verify that it gave back a good IP address...
			hrResult = GetIpAddress( szIpAddress, ulIpAddress );
		}

		if( hrResult != S_OK )
		{
			hrResult = NM_CALLERR_ILS_RESOLUTION_FAILED;
		}
	}

	return( hrResult );

}	//	End of CCallto::GetIpAddressFromIls.


//--------------------------------------------------------------------------//
//	CCallto::DoUserValidation    											//
//--------------------------------------------------------------------------//
bool CCallto::DoUserValidation(const TCHAR * const pszCallto)
{
    bool    bRet        = false;
    CCallto callto;
    TCHAR   szCaption[MAX_PATH];
    TCHAR   *pszText    = NULL;

    // Parse input string to retrieve display name
    if(FAILED(callto.Parse(pszCallto)))
        goto Exit;

    // Verify we have a valid display name
    if(NULL == callto.m_pszDisplayName)
        goto Exit;

    // Allocate message buffer. MAX_PATH represents max format string size
    pszText = new TCHAR[_tcslen(callto.m_pszDisplayName) + MAX_PATH];
    if(NULL == pszText)
        goto Exit;

    // Compose message string
    if(!FLoadString1(IDS_JOIN_PERMISSION, pszText, callto.m_pszDisplayName))
        goto Exit;

    if(!FLoadString(IDS_MSGBOX_TITLE, szCaption, CCHMAX(szCaption)))
        goto Exit;

    // Display message box
    if(IDOK != MessageBox(NULL, pszText, szCaption, MB_ICONWARNING | MB_OKCANCEL | MB_TOPMOST))
        goto Exit;

    bRet = true;
Exit:
    // Free allocated buffer
    if(NULL != pszText)
    {
        delete [] pszText;
    }
    
    return bRet;
}

//--------------------------------------------------------------------------//
//	CCalltoParams::CCalltoParams.											//
//--------------------------------------------------------------------------//
CCalltoParams::CCalltoParams(void):
	m_chNameDelimiter( '+' ),
	m_chValueDelimiter( '=' ),
	m_pszParams( NULL ),
	m_iCount( 0 )
{
}	//	End of CCalltoParams::CCalltoParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::CCalltoParams.											//
//--------------------------------------------------------------------------//
CCalltoParams::~CCalltoParams()
{

	delete [] m_pszParams;

}	//	End of CCalltoParams::~CCalltoParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::SetParams.												//
//--------------------------------------------------------------------------//
HRESULT
CCalltoParams::SetParams
(
	const TCHAR * const	pszParams
){

	HRESULT	hrResult;

	delete [] m_pszParams;

	m_pszParams	= NULL;
	m_iCount	= 0;

	if( pszParams == NULL )
	{
		hrResult = S_OK;
	}
	else if( (m_pszParams = new TCHAR [ lstrlen( pszParams ) + 1 ]) == NULL )
	{
		hrResult = E_OUTOFMEMORY;
	}
	else
	{
		hrResult = S_OK;

		lstrcpy( m_pszParams, pszParams );

		TCHAR *	pszPos	= m_pszParams;
		TCHAR *	pszEnd;

		while( (*pszPos != '\0') && (m_iCount < ARRAY_ELEMENTS( m_pszNames )) )
		{
			m_pszNames[ m_iCount ]	= pszPos;
			m_pszValues[ m_iCount ]	= NULL;

			while( *pszPos != '\0' )
			{
				if( (*pszPos == '+') || (*pszPos == '=') )
				{
					break;
				}

				pszPos = CharNext( pszPos );
			}

			if( *pszPos != '=' )
			{
				//	Valueless param...

				if( m_pszNames[ m_iCount ] == pszPos )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have zero length param names...
					break;
				}

				pszEnd = pszPos;
				pszPos = CharNext( pszPos );

				if( (pszPos != pszEnd) && (*pszPos == '\0') )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have trailing + or =...
					break;
				}

				*pszEnd = '\0';
				m_iCount++;
			}
			else
			{
				//	Value follows...
				pszEnd = pszPos;
				pszPos = CharNext( pszPos );
				*pszEnd = '\0';

				m_pszValues[ m_iCount ] = pszPos;

				while( *pszPos != '\0' )
				{
					if( (*pszPos == '+') || (*pszPos == '=') )
					{
						break;
					}

					pszPos = CharNext( pszPos );
				}

				if( (*pszPos == '=') || (m_pszValues[ m_iCount ] == pszPos) )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have '=' or zero length param names...
					break;
				}

				pszEnd = pszPos;
				pszPos = CharNext( pszPos );

				if( (pszPos != pszEnd) && (*pszPos == '\0') )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have trailing + or =...
					break;
				}

				*pszEnd = '\0';
				m_iCount++;
			}
		}

		if( hrResult == S_OK )
		{
			if( m_iCount == ARRAY_ELEMENTS( m_pszNames ) )
			{
				hrResult = NM_CALLERR_PARAM_ERROR;	//	Too many params...
			}
			else
			{
				for( int nn = 0; nn < m_iCount; nn++ )
				{
					if( (hrResult = Unescape( m_pszNames[ nn ] )) != S_OK )
					{
						break;
					}

					if( m_pszValues[ nn ] != NULL )
					{
						if( (hrResult = Unescape( m_pszValues[ nn ] )) != S_OK )
						{
							break;
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCalltoParams::SetParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::GetParam.												//
//--------------------------------------------------------------------------//
const TCHAR * const
CCalltoParams::GetParam
(
	const TCHAR * const	pszName,
	const TCHAR * const	pszDefaultValue
) const
{
	ASSERT( pszName != NULL );

	TCHAR *	pszValue	= NULL;

	if( m_pszParams != NULL )
	{
		for( int nn = 0; nn < m_iCount; nn++ )
		{
			if( lstrcmpi( pszName, m_pszNames[ nn ] ) == 0 )
			{
				pszValue = m_pszValues[ nn ];
				break;
			}
		}
	}

	return( (pszValue == NULL)? pszDefaultValue: pszValue );

}	//	End of CCalltoParams::GetParam.


//--------------------------------------------------------------------------//
//	CCalltoParams::GetBooleanParam.											//
//--------------------------------------------------------------------------//
bool
CCalltoParams::GetBooleanParam
(
	const TCHAR * const	pszParamName,
	const bool			bDefaultValue
) const
{
	ASSERT( pszParamName != NULL );

	const TCHAR * const	pszValue	= GetParam( pszParamName, NULL );
	bool				bResult;

	if( pszValue == NULL )		//	this parameter wasn't specified...
	{
		bResult = bDefaultValue;
	}
	else if( *pszValue == 0 )	//	this parameter was specified but with no value...
	{
		bResult = true;
	}
	else if(	(lstrcmpi( pszValue, TEXT( "1" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "true" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "y" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "yes" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "on" ) ) == 0) )
	{
		bResult = true;
	}
	else if(	(lstrcmpi( pszValue, TEXT( "0" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "false" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "n" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "no" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "off" ) ) == 0) )
	{
		bResult = false;
	}
	else
	{
		bResult = bDefaultValue;
	}

	return( bResult );

}	//	End of CCalltoParams::GetBooleanParam.


//--------------------------------------------------------------------------//
//	IsLocalIpAddress.														//
//--------------------------------------------------------------------------//
bool IsLocalIpAddress
(
	const unsigned long	ulIpAddress		// IP Address to verify is not local
){
	bool	bResult	= (ulIpAddress == INADDR_LOOPBACK);	//	First check right away if it's the prefined loop back ip address...

	if( !bResult )
    {
	    char	szHostName[ MAX_PATH ];

	    //	Get our own local hostname...
		if( gethostname( szHostName, ARRAY_ELEMENTS( szHostName ) ) == SOCKET_ERROR )
		{
			WARNING_OUT( ("IsLocalIpAddress: gethostname() failed with error=%s", PszWSALastError()) );
		}
		else
		{
			//	Now find out which IP addresses are associated with it...
			HOSTENT *	pHostEnt	= gethostbyname( szHostName );

			if( pHostEnt == NULL )
			{
				WARNING_OUT( ("IsLocalIpAddress: gethostbyname() failed with error=%s", PszWSALastError()) );
			}
			else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
			{
				WARNING_OUT( ("IsLocalIpAddress: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
			}
			else
			{
				ASSERT( reinterpret_cast<unsigned long **>(pHostEnt->h_addr_list) != NULL );

				//	Compare all the IP addresses associated with this machine to see if any of them match the one specified...
				for( unsigned long ** ppIpAddress = reinterpret_cast<unsigned long **>(pHostEnt->h_addr_list); *ppIpAddress != NULL; ppIpAddress++ )
				{
					if( **ppIpAddress == ulIpAddress )
					{
						bResult = true;
						break;
					}
				}
			}
		}
	}

	return( bResult );

}	//	End of IsLocalIpAddress.


//--------------------------------------------------------------------------//
//	DecimalStringToUINT.													//
//--------------------------------------------------------------------------//
HRESULT DecimalStringToUINT
(
	const TCHAR * const	pszDecimalString,		//	Pointer to string to convert...
	unsigned int &		uiValue					//	out unsigned int reference to receive converted value...
){
	ASSERT( pszDecimalString != NULL );

	HRESULT	hrResult;

	if( lstrlen( pszDecimalString ) > 10 )
	{
		hrResult = E_INVALIDARG;		//	Limit it to billions....
	}
	else
	{
		hrResult = S_OK;

		const TCHAR * pszDigit;

		for( pszDigit = pszDecimalString, uiValue = 0; *pszDigit != '\0'; pszDigit = CharNext( pszDigit ) )
		{
			if( (*pszDigit < '0') || (*pszDigit > '9') )
			{
				//	There's a non digit character in the string so fail...
				hrResult = E_INVALIDARG;
				break;
			}

			uiValue = (uiValue * 10) + *pszDigit - '0';
		}
	}

	return( hrResult );

}	//	End of DecimalStringToUINT.


//--------------------------------------------------------------------------//
//	TrimSzCallto.															//
//--------------------------------------------------------------------------//
int TrimSzCallto
(
	TCHAR * const	pszSrc		//	Pointer to string to trim blanks from in place...
){
	ASSERT( pszSrc != NULL );

	TCHAR *	pszFirst;
	int		iResult;

	for( pszFirst = pszSrc; *pszFirst == ' '; pszFirst = CharNext( pszFirst ) ){};

	if( *pszFirst == '\0' )
	{
		*pszSrc = '\0';
		iResult	= 0;
	}
	else
	{
		TCHAR *	pszLast;
		TCHAR *	psz;

		for( pszLast = pszFirst, psz = pszFirst; *psz != '\0'; psz = CharNext( psz ) )
		{
			if( *psz != ' ' )
			{
				pszLast = psz;
			}
		}

		pszLast		= CharNext( pszLast );
		*pszLast	= '\0';

		lstrcpy( pszSrc, pszFirst );
		iResult = lstrlen( pszSrc );
	}

	return( iResult );

}	//	End of TrimSzCallto.


//--------------------------------------------------------------------------//
//	GetIpAddress.															//
//--------------------------------------------------------------------------//
HRESULT GetIpAddress
(
	const TCHAR * const	pszIpAddress,	//	pointer to dotted IP address string
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( pszIpAddress != NULL );

	ulIpAddress = INADDR_NONE;

	int				ipByte	= 0;
	int				parts	= 0;
	const TCHAR *	ptr		= pszIpAddress;
	bool			newPart	= true;
	bool			result	= true;

	while( result && (*ptr != NULL) && (parts <= 4) )
	{
		if( (*ptr >= '0') && (*ptr <= '9') )
		{
			if( newPart )
			{
				parts++;
				newPart = false;
			}

			ipByte = (ipByte * 10) + (*ptr - '0');

			if( ipByte > 255 )
			{
				result = false;
			}
		}
		else if( *ptr == '.' )
		{
			newPart	= true;
			ipByte	= 0;
		}
		else
		{
			result = false;
		}

		ptr++;
	}

	if( result && (parts == 4) )
	{
#if !defined( UNICODE )
		ulIpAddress = inet_addr( pszIpAddress );
#else
		char *	ansiIPAddress;
		int		size;

		size = WideCharToMultiByte(	CP_ACP,		// code page
									0,			// performance and mapping flags
									ipAddress,	// address of wide-character string
									-1,			// number of characters in string
									NULL,		// address of buffer for new string
									0,			// size of buffer
									NULL,		// address of default for unmappable characters
									NULL );		// address of flag set when default char. used

		if( (ansiIPAddress = new char [ size ]) != NULL )
		{
			size = WideCharToMultiByte(	CP_ACP,			// code page
										0,				// performance and mapping flags
										pszIpAddress,	// address of wide-character string
										-1,				// number of characters in string
										ansiIPAddress,	// address of buffer for new string
										size,			// size of buffer
										NULL,			// address of default for unmappable characters
										NULL );			// address of flag set when default char. used

			if( size != 0 )
			{
				ulIpAddress = inet_addr( ansiIPAddress );
			}

			delete [] ansiIPAddress;
		}
#endif	//	!defined( UNICODE )
	}

	return( (ulIpAddress != INADDR_NONE)? S_OK: E_FAIL );

}	//	End of GetIpAddress.


//--------------------------------------------------------------------------//
//	GetIpAddressFromHostName.												//
//--------------------------------------------------------------------------//
HRESULT GetIpAddressFromHostName
(
	const TCHAR * const	pszName,		//	pointer to host name to get IP address of
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( pszName != NULL );

	HRESULT	hrResult	= E_FAIL;

	if( pszName[ 0 ] == '\0' )
	{
		ulIpAddress = INADDR_NONE;
	}
	else if( (hrResult = GetIpAddress( pszName, ulIpAddress )) != S_OK )
	{
		//	Wasn't already in dotted IP address form...

		HOSTENT *	pHostEnt;
#if !defined( UNICODE )
		TCHAR *		pszOemName = new TCHAR [ lstrlen( pszName ) + 1 ];

		if( pszOemName == NULL )
		{
			hrResult = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( pszOemName, pszName );
			CharUpper ( pszOemName );
			CharToOem( pszOemName, pszOemName );

			pHostEnt = gethostbyname( pszOemName );

			if( pHostEnt == NULL )
			{
				WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() failed with error=%s", PszWSALastError()) );
			}
			else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
			{
				WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
			}
			else
			{
				if( pHostEnt->h_addr_list[ 0 ] != NULL )
				{
					ulIpAddress	= *reinterpret_cast<unsigned long *>(pHostEnt->h_addr_list[ 0 ]);	//	Just use the first IP address
					hrResult	= S_OK;
				}
			}

			delete [] pszOemName;
		}
#else
		//	Need to figure out OEM'ing the name...

		char *	pszMultiByteName;
		int		iSize;

		iSize = WideCharToMultiByte(	CP_ACP,		// code page
										0,			// performance and mapping flags
										pszName,	// address of wide-character string
										-1,			// number of characters in string
										NULL,		// address of buffer for new string
										0,			// size of buffer
										NULL,		// address of default for unmappable characters
										NULL );		// address of flag set when default char. used

		if( (pszMultiByteName = new char [ iSize ]) == NULL )
		{
			hrResult = E_OUTOFMEMORY;
		}
		else
		{
			iSize = WideCharToMultiByte(	CP_ACP,				// code page
											0,					// performance and mapping flags
											pszName,			// address of wide-character string
											-1,					// number of characters in string
											pszMultiByteName,	// address of buffer for new string
											iSize,				// size of buffer
											NULL,				// address of default for unmappable characters
											NULL );				// address of flag set when default char. used

			if( iSize != 0 )
			{
				pHostEnt = gethostbyname( ansiHost );

				if( pHostEnt == NULL )
				{
					WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() failed with error=%s", PszWSALastError()) );
				}
				else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
				{
					WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
				}
				else
				{
					if( pHostEnt->h_addr_list[ 0 ] != NULL )
					{
						ulIpAddress	= *reinterpret_cast<unsigned long *>(pHostEnt->h_addr_list[ 0 ]);	//	Just use the first IP address
						hrResult	= S_OK;
					}
				}
			}

			delete [] pszMultiByteName;
		}
#endif	// !defined( UNICODE )
	}

	return( hrResult );

}	//	End of GetIpAddressFromHostName.


//--------------------------------------------------------------------------//
//	IsPhoneNumber.															//
//--------------------------------------------------------------------------//
bool IsPhoneNumber
(
	const TCHAR *	pszPhone	//	string to check for invalid phone number characters
){
	ASSERT( pszPhone != NULL );
	ASSERT( pszPhone[ 0 ] != '\0' );

	bool	bResult	= true;

	while( pszPhone[ 0 ] != '\0' )
	{
		switch( pszPhone[ 0 ] )
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '(':
			case ')':
			case '#':
			case '*':
			case '-':
			case ',':
			case ' ':
				break;

			default:
				bResult = false;
				break;
		}
		
		pszPhone++;
	}

	return( bResult );

}	//	End of IsPhoneNumber.


//--------------------------------------------------------------------------//
//	bCanCallAsPhoneNumber.													//
//--------------------------------------------------------------------------//
bool bCanCallAsPhoneNumber
(
	const TCHAR * const	pszPhone
){
	ASSERT( pszPhone != NULL );
	ASSERT( pszPhone[ 0 ] != '\0' );

	bool	bResult	= FALSE;

	if( IsPhoneNumber( pszPhone ) )
	{
		if( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() )
		{
			bResult = true;
		}
		else
		{
			RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

			bResult = (reConf.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0);
		}
	}

	return( bResult );

}	//	End of bCanCallAsPhoneNumber.


//--------------------------------------------------------------------------//
//	unescape.																//
//--------------------------------------------------------------------------//
HRESULT Unescape
(
	TCHAR * const	pszSrc		//	pointer to string to unescape in place
){
	ASSERT( pszSrc != NULL );
	
	TCHAR *	pszPercentSign;
	HRESULT	hrResult;

	for( hrResult = S_OK, pszPercentSign = pszSrc; pszPercentSign != NULL; )
	{
		if( (pszPercentSign = StrChr( pszPercentSign, '%' )) != NULL )
		{
			TCHAR	chHighNibble	= pszPercentSign[ 1 ];

			if( ((chHighNibble >= '0') && (chHighNibble <= '9'))	||
				((chHighNibble >= 'a') && (chHighNibble <= 'f'))	||
				((chHighNibble >= 'A') && (chHighNibble <= 'F')) )
			{
				TCHAR	chLowNibble	= pszPercentSign[ 2 ];

				if( ((chLowNibble >= '0') && (chLowNibble <= '9'))	||
					((chLowNibble >= 'a') && (chLowNibble <= 'f'))	||
					((chLowNibble >= 'A') && (chLowNibble <= 'F')) )
				{
					chHighNibble	= ((chHighNibble >= '0') && (chHighNibble <= '9'))? chHighNibble - '0':
										((chHighNibble >= 'a') && (chHighNibble <= 'f'))? chHighNibble - 'a' + 10: chHighNibble - 'A' + 10;
					chLowNibble		= ((chLowNibble >= '0') && (chLowNibble <= '9'))? chLowNibble - '0':
										((chLowNibble >= 'a') && (chLowNibble <= 'f'))? chLowNibble - 'a' + 10: chLowNibble - 'A' + 10;

					*pszPercentSign++ = (chHighNibble << 4) | chLowNibble;
					lstrcpy( pszPercentSign, &pszPercentSign[ 2 ] );
				}
				else
				{
					hrResult = NM_CALLERR_UNESCAPE_ERROR;
					break;
				}
			}
			else
			{
				hrResult = NM_CALLERR_UNESCAPE_ERROR;
				break;
			}
		}
	}

	return( hrResult );

}	//	End of Unescape.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\callto.h ===
#if	!defined( callto_h )
#define	callto_h
//--------------------------------------------------------------------------//
#include	"call.h"

#define strlen_literal( l )			((sizeof( (l) ) / sizeof( TCHAR )) - 1)
#define StrCmpNI_literal( str, l )	((bool)(StrCmpNI( (str), (l), ((sizeof( (l) ) / sizeof( TCHAR )) - 1) ) == 0))


//--------------------------------------------------------------------------//
//	Public Methods.															//
//--------------------------------------------------------------------------//
HRESULT DecimalStringToUINT
(
	const TCHAR * const	pszDecimalString,	//	Pointer to string to convert...
	unsigned int &		uiValue				//	out unsigned int reference to receive converted value...
);

HRESULT GetIpAddress
(
	const TCHAR * const	pszIpAddress,	//	pointer to dotted IP address string
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
);

HRESULT GetIpAddressFromHostName
(
	const TCHAR * const	pszName,		//	pointer to host name to get IP address of
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
);

bool IsLocalIpAddress
(
	const unsigned long	IpAddress		// IP Address to verify is/not local
);

bool IsPhoneNumber
(
	const TCHAR *	pszPhone			//	string to check for invalid phone number characters
);

bool bCanCallAsPhoneNumber
(
	const TCHAR * const	pszPhone		//	string to check for call placement
);

int TrimSzCallto
(
	TCHAR * const	pszSrc				//	Pointer to string to trim blanks from in place...
);

HRESULT Unescape
(
	TCHAR * const	pszSrc				//	pointer to string to unescape in place
);


//--------------------------------------------------------------------------//
//	class CCalltoParams.													//
//--------------------------------------------------------------------------//
class CCalltoParams
{
	public:
		
		CCalltoParams(void);
		virtual ~CCalltoParams();

		HRESULT SetParams
		(
			const TCHAR * const	pszParams = NULL		//	pointer to string of "+name=value" pairs to parse
		);

		const TCHAR * const GetParam
		(
			const TCHAR * const	pszName,				//	pointer to name of parameter to get
			const TCHAR * const	pszDefaultValue = NULL	//	pointer to default value to return if "name" doesn't exist
		) const;

		bool GetBooleanParam
		(
			const TCHAR * const	pszName,				//	pointer to name of parameter to evaluate as boolean
			const bool			bDefaultValue = false	//	default value to return is "name" doesn't exist
		) const;


	private:	//	private members	----------------------------------------//

		int		m_iCount;
		TCHAR *	m_pszNames[ 15 ];
		TCHAR *	m_pszValues[ 15 ];

		TCHAR	m_chNameDelimiter;
		TCHAR	m_chValueDelimiter;
		TCHAR *	m_pszParams;
		int		m_iParamsLength;

};	//	End of class CCalltoParams.


//--------------------------------------------------------------------------//
//	class CCallto.															//
//--------------------------------------------------------------------------//
class CCallto
{
	public:

		CCallto(void);
		virtual ~CCallto(void);

	public:

		virtual HRESULT Callto
		(
			const TCHAR * const	pszCallto,				//	pointer to the callto url to try to place the call with...
			const TCHAR * const	pszDisplayName,			//	pointer to the display name to use...
			const NM_ADDR_TYPE	nmType,					//	callto type to resolve this callto as...
			const bool			bAddressOnly,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
			const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
			const bool			bAddToMru,				//	whether or not save in mru...
			const bool			bUIEnabled,				//	whether or not to perform user interaction on errors...
			const HWND			hwndParent,				//	if bUIEnabled is true this is the window to parent error/status windows to...
			INmCall ** const	ppInternalCall			//	out pointer to INmCall * to receive INmCall * generated by placing call...
		);

		virtual void SetGatekeeperEnabled
		(
			const bool	bEnabled					//	new Gatekeeper state
		);

		virtual HRESULT SetGatekeeperName
		(
			const TCHAR * const	pszGatekeeperName	//	new Gatekeeper name
		);

		virtual void SetGatewayEnabled
		(
			const bool	bEnabled					//	new Gateway state
		);

		virtual HRESULT SetGatewayName
		(
			const TCHAR * const	pszGatewayName		//	new Gateway name
		);

		virtual HRESULT SetIlsServerName
		(
			const TCHAR * const	pszServerName		//	pointer to new default Ils server name
		);

		static const int	s_iMaxCalltoLength;
		static const int	s_iMaxAddressLength;

        static bool DoUserValidation(const TCHAR * const pszCallto);


	private:

		HRESULT Parse
		(
			const TCHAR * const	pszCallto			//	pointer to the callto url to parse...
		);

		HRESULT ParseAddress(void);

		HRESULT Resolve
		(
			const NM_ADDR_TYPE	nmType				//	callto type to resolve this callto as if no type specified in the pszCallto parameter...
		);

		HRESULT PlaceCall
		(
			const TCHAR * const	pszCallto,			//	pointer to the callto url to try to place the call with...
			const bool			bAddToMru,			//	whether or not save in mru...
			const bool			bSecure,			//	whether or not to place the call securely...
			INmCall ** const	ppInternalCall		//	out pointer to INmCall * to receive INmCall * generated by placing call...
		);

		HRESULT GetValidatedSecurity
		(
			const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
			bool &				bValidatedSecurity		//	out bool reference to recieve validated security setting
		);

		bool inGatekeeperMode(void);

		HRESULT GetGatekeeperIpAddress
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive gatekeeper IP address
		);

		bool inGatewayMode(void);

		HRESULT GetGatewayIpAddress
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive gateway IP address
		);

		HRESULT GetIpAddressFromIls
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive IP address
		);


	private:

		HWND			m_hwndParent;
		bool			m_bUnescapedAddressOnly;
		bool			m_bUIEnabled;
		unsigned long	m_ulDestination;
		TCHAR *			m_pszCalltoBuffer;
		TCHAR *			m_pszAddress;
		TCHAR *			m_pszParameters;
		TCHAR *			m_pszParsePos;
		TCHAR *			m_pszIlsServer;
		unsigned int	m_uiIlsPort;
		bool			m_bGatekeeperEnabled;
		TCHAR *			m_pszGatekeeperName;
		unsigned long	m_ulGatekeeperAddress;
		bool			m_bGatewayEnabled;
		TCHAR *			m_pszGatewayName;
		unsigned long	m_ulGatewayAddress;
		TCHAR *			m_pszDefaultIlsServerName;
		TCHAR *			m_pszEmail;
		TCHAR *			m_pszDisplayName;
		CCalltoParams	m_Parameters;
		NM_ADDR_TYPE	m_nmAddressType;

};	//	End of class CCallto.

//--------------------------------------------------------------------------//
#endif	//	!defined( callto_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltocontext.h ===
#if !defined( calltoContext_h )
#define	calltoContext_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"SDKInternal.h"


//--------------------------------------------------------------------------//
//	interface IUIContext.													//
//--------------------------------------------------------------------------//
class IUIContext
{
	protected:	//	protected constructors	--------------------------------//

		IUIContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IUIContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		disambiguate
		(
			ICalltoCollection * const	calltoCollection,
			ICallto * const				emptyCallto,
			const ICallto ** const		selectedCallto
		) = 0;

};	//	End of interface IUIContext.


//--------------------------------------------------------------------------//
//	interface IMutableUIContext.											//
//--------------------------------------------------------------------------//
class IMutableUIContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableUIContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableUIContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_parentWindow
		(
			const HWND	window
		) = 0;

		virtual
		void
		set_callFlags
		(
			const DWORD	callFlags
		) = 0;

};	//	End of interface IMutableUIContext.


//--------------------------------------------------------------------------//
//	class CUIContext.														//
//--------------------------------------------------------------------------//
class CUIContext:	public	IUIContext,
					public	IMutableUIContext
{
	public:		//	public constructors	------------------------------------//

		CUIContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CUIContext();


	public:		//	public methods	(IUIContext)	------------------------//

		virtual
		HRESULT
		disambiguate
		(
			ICalltoCollection * const	calltoCollection,
			ICallto * const				emptyCallto,
			const ICallto ** const		callto
		);


	public:		//	public methods	(IMutableUIContext)	--------------------//

		virtual
		void
		set_parentWindow
		(
			const HWND	window
		);

		virtual
		void
		set_callFlags
		(
			const DWORD	callFlags
		);


	private:	//	private members	----------------------------------------//

		HWND	m_parent;
		DWORD	m_callFlags;

};	//	End of class CUIContext.


//--------------------------------------------------------------------------//
//	interface IGatekeeperContext.											//
//--------------------------------------------------------------------------//
class IGatekeeperContext
{
	protected:	//	protected constructors	--------------------------------//

		IGatekeeperContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IGatekeeperContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

};	//	End of interface IGatekeeperContext.


//--------------------------------------------------------------------------//
//	interface IMutableGatekeeperContext.									//
//--------------------------------------------------------------------------//
class IMutableGatekeeperContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableGatekeeperContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableGatekeeperContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_gatekeeperName
		(
			const TCHAR * const	gatekeeperName
		) = 0;

};	//	End of interface IMutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	class CGatekeeperContext.												//
//--------------------------------------------------------------------------//
class CGatekeeperContext:	public	IGatekeeperContext,
							public	IMutableGatekeeperContext
{
	public:		//	public constructors	------------------------------------//

		CGatekeeperContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CGatekeeperContext();


	public:		//	public methods	(IGatekeeperContext)	----------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;


	public:		//	public methods	(IMutableGatekeeperContext)	------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_gatekeeperName
		(
			const TCHAR * const	gatekeeperName
		);


	private:		//	private methods	------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;

};	//	End of class CGatekeeperContext.


//--------------------------------------------------------------------------//
//	interface IGatewayContext.												//
//--------------------------------------------------------------------------//
class IGatewayContext
{
	protected:	//	protected constructors	--------------------------------//

		IGatewayContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IGatewayContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

};	//	End of interface IGatewayContext.


//--------------------------------------------------------------------------//
//	interface IMutableGatewayContext.										//
//--------------------------------------------------------------------------//
class IMutableGatewayContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableGatewayContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableGatewayContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_gatewayName
		(
			const TCHAR * const	gatewayName
		) = 0;

};	//	End of interface IMutableGatewayContext.


//--------------------------------------------------------------------------//
//	class CGatewayContext.													//
//--------------------------------------------------------------------------//
class CGatewayContext:	public	IGatewayContext,
						public	IMutableGatewayContext
{
	public:		//	public constructors	------------------------------------//

		CGatewayContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CGatewayContext();


	public:		//	public methods	(IGatewayContext)	--------------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;


	public:		//	public methods	(IMutableGatewayContext)	------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_gatewayName
		(
			const TCHAR * const	gatewayName
		);


	private:	//	private methods	----------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;

};	//	End of class CGatewayContext.


//--------------------------------------------------------------------------//
//	interface IILSContext.													//
//--------------------------------------------------------------------------//
class IILSContext
{
	protected:	//	protected constructors	--------------------------------//

		IILSContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IILSContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

		virtual
		const TCHAR * const
		get_ilsName(void) const = 0;

};	//	End of interface IILSContext.


//--------------------------------------------------------------------------//
//	interface IMutableILSContext.											//
//--------------------------------------------------------------------------//
class IMutableILSContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableILSContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableILSContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_ilsName
		(
			const TCHAR * const	ilsName
		) = 0;

};	//	End of interface IMutableILSContext.


//--------------------------------------------------------------------------//
//	class CILSContext.														//
//--------------------------------------------------------------------------//
class CILSContext:	public	IILSContext,
					public	IMutableILSContext
{
	public:		//	public constructors	------------------------------------//

		CILSContext
		(
			const TCHAR * const	ilsServer = NULL
		);


	public:		//	public destructor	------------------------------------//

		virtual
		~CILSContext();


	public:		//	public methods	(IILSContext)	------------------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;

		virtual
		const TCHAR * const
		get_ilsName(void) const;


	public:		//	public methods	(IMutableILSContext)	----------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_ilsName
		(
			const TCHAR * const	ilsName
		);


	private:	//	private methods	----------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;
		TCHAR *	m_ilsName;

};	//	End of class CILSContext.


//--------------------------------------------------------------------------//
//	interface ICalltoContext.												//
//--------------------------------------------------------------------------//
class ICalltoContext
{
	protected:	//	protected constructors	--------------------------------//

		ICalltoContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~ICalltoContext(){}


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		callto
		(
			const ICalltoProperties * const	calltoProperties,
			INmCall** ppInternalCall
		)	= 0;

		virtual
		const IGatekeeperContext * const
		get_gatekeeperContext(void) const = 0;

		virtual
		const IGatewayContext * const
		get_gatewayContext(void) const = 0;

		virtual
		const IILSContext * const
		get_ilsContext(void) const = 0;

};	//	End of interface ICalltoContext.


//--------------------------------------------------------------------------//
//	interface IMutableCalltoContext.										//
//--------------------------------------------------------------------------//
class IMutableCalltoContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableCalltoContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableCalltoContext(){}


	public:		//	public methods	----------------------------------------//

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const = 0;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const = 0;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const = 0;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const = 0;

};	//	End of interface IMutableCalltoContext.


//--------------------------------------------------------------------------//
//	class CCalltoContext.													//
//--------------------------------------------------------------------------//
class CCalltoContext:	public	ICalltoContext,
						public	IMutableCalltoContext,
						public	CUIContext,
						public	CGatekeeperContext,
						public	CGatewayContext,
						public	CILSContext
{
	public:		//	public constructors	------------------------------------//

		CCalltoContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CCalltoContext();


	public:		//	public methods	(ICalltoContext)	--------------------//

		virtual
		HRESULT
		callto
		(
			const ICalltoProperties * const	calltoProperties,
			INmCall** ppInternalCall
		);

		virtual
		const IGatekeeperContext * const
		get_gatekeeperContext(void) const;

		virtual
		const IGatewayContext * const
		get_gatewayContext(void) const;

		virtual
		const IILSContext * const
		get_ilsContext(void) const;


	public:		//	public methods	(IMutableCalltoContext)	----------------//

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const;


	public:	//	public static methods	------------------------------------//

		static
		bool
		isPhoneNumber
		(
			const TCHAR *	phone
		);

		static
		bool
		toE164
		(
			const TCHAR *	phone,
			TCHAR *			base10,
			int				size
		);

		static
		bool
		isIPAddress
		(
			const TCHAR * const	ipAddress
		);

		static
		HRESULT
		get_ipAddressFromName
		(
			const TCHAR * const	name,
			TCHAR *				buffer,
			int					length
		);

		static
		HRESULT
		get_ipAddressFromILSEmail
		(
			const TCHAR * const	ilsServer,
			const TCHAR * const	ilsPort,
			const TCHAR * const	email,
			TCHAR * const		ipAddress,
			const int			size
		);

};	//	End of class CCalltoContext.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoContext_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltodisambiguator.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoDisambiguator.h"


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::CCalltoDisambiguator.								//
//--------------------------------------------------------------------------//
CCalltoDisambiguator::CCalltoDisambiguator(void):
	m_registeredDisambiguators( 0 )
{

	addDisambiguator( &m_gatekeeperDisambiguator );
	addDisambiguator( &m_gatewayDisambiguator );
	addDisambiguator( &m_computerDisambiguator );
	addDisambiguator( &m_ilsDisambiguator );
	addDisambiguator( &m_unrecognizedDisambiguator );

}	//	End of CCalltoDisambiguator::CCalltoDisambiguator.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::~CCalltoDisambiguator.							//
//--------------------------------------------------------------------------//
CCalltoDisambiguator::~CCalltoDisambiguator()
{
}	//	End of CCalltoDisambiguator::~CCalltoDisambiguator.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::disambiguate.										//
//--------------------------------------------------------------------------//
HRESULT
CCalltoDisambiguator::disambiguate
(
	const ICalltoContext * const	calltoContext,
	ICalltoCollection * const		resolvedCalltoCollection,
	CCalltoCollection * const		disambiguatedCalltoCollection
){
	HRESULT	result;

	if( (calltoContext == NULL) || (resolvedCalltoCollection == NULL) || (disambiguatedCalltoCollection == NULL) )
	{
		result = E_POINTER;
	}
	else
	{
		result = S_UNDISAMBIGUATED;

		disambiguatedCalltoCollection->reset();

		//	Run through "smart" disambiguators...
		static HRESULT	confidenceLevels[]	= {S_CONFIDENCE_CERTITUDE, S_CONFIDENCE_HIGH, S_CONFIDENCE_MEDIUM, S_CONFIDENCE_LOW};

		const ICallto *	resolvedCallto;
		HRESULT			resolveResult	= S_OK;

		for( int level = 0; (level < elementsof( confidenceLevels )) && (resolveResult != S_CONFIDENCE_CERTITUDE); level++ )
		{
			for(	resolvedCallto = resolvedCalltoCollection->get_first();
					(resolvedCallto != NULL) && (resolveResult != S_CONFIDENCE_CERTITUDE);
					resolvedCallto = resolvedCalltoCollection->get_next() )
			{
				if( resolvedCallto->get_confidence() == confidenceLevels[ level ] )
				{
					for( int nn = 0; (nn < m_registeredDisambiguators) && (resolveResult != S_CONFIDENCE_CERTITUDE); nn++ )
					{
						resolveResult = m_disambiguators[ nn ]->disambiguate( calltoContext, disambiguatedCalltoCollection, resolvedCallto );

						if( FAILED( resolveResult ) && (!FAILED( result )) )
						{
							result = resolveResult;
						}
					}
				}
			}
		}
	}

	return( result );

}	//	End of CCalltoDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::addDisambiguator.									//
//--------------------------------------------------------------------------//
bool
CCalltoDisambiguator::addDisambiguator
(
	IDisambiguator * const	disambiguator
){
//assert( disambiguator != NULL, TEXT( "attempted to add NULL disambiguator\r\n" ) );
//assert( m_registeredDisambiguators < elementsof( m_disambiguators ), TEXT( "attempted to add to many disambiguators: %d\r\n" ), m_registeredDisambiguators );

	if( (disambiguator != NULL) && (m_registeredDisambiguators < elementsof( m_disambiguators )) )
	{
		m_disambiguators[ m_registeredDisambiguators++ ] = disambiguator;
	}

	return( (disambiguator !=NULL ) && (m_registeredDisambiguators <= elementsof( m_disambiguators )) );

}	//	End of CCalltoDisambiguator::addDisambiguator.


//--------------------------------------------------------------------------//
//	CGatekeeperDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	const IGatekeeperContext * const	gatekeeperContext	= calltoContext->get_gatekeeperContext();
	HRESULT								result				= S_UNDISAMBIGUATED;

	if( gatekeeperContext != NULL )
	{
		ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

		if( disambiguatedCallto != NULL )
		{
			disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
			disambiguatedCallto->set_destination( gatekeeperContext->get_ipAddress() );
			disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
			result = S_CONFIDENCE_CERTITUDE;
		}
	}

	return( result );

}	//	End of CGatekeeperDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CGatewayDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CGatewayDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	HRESULT	result	= S_UNDISAMBIGUATED;

	if( lstrcmpi( resolvedCallto->get_type(), TEXT( "phone" ) ) == 0 )
	{
		const TCHAR * const	gateway	= resolvedCallto->get_gateway();

		if( gateway != NULL )
		{
			TCHAR	ipAddress[ MAX_PATH ];

			result = CCalltoContext::get_ipAddressFromName( gateway, ipAddress, elementsof( ipAddress ) );

			if( result == S_OK )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto == NULL )
				{
					result = S_UNDISAMBIGUATED;
				}
				else
				{
					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( ipAddress );
					disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
					result = S_CONFIDENCE_CERTITUDE;
				}
			}
		}
		else
		{
			const IGatewayContext * const	gatewayContext	= calltoContext->get_gatewayContext();

			if( gatewayContext != NULL )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto != NULL )
				{
					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( gatewayContext->get_ipAddress() );
					disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
					result = S_CONFIDENCE_CERTITUDE;
				}
			}
		}
	}

	return( result );

}	//	End of CGatewayDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CComputerDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CComputerDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	bool	ip			= (lstrcmpi( resolvedCallto->get_type(), TEXT( "ip" ) ) == 0);
	bool	computer	= (lstrcmpi( resolvedCallto->get_type(), TEXT( "computer" ) ) == 0);
	HRESULT	result		= S_UNDISAMBIGUATED;

	if( ip || computer )
	{
		TCHAR	ipAddress[ 64 ];

		result = CCalltoContext::get_ipAddressFromName(	resolvedCallto->get_value(),
														ipAddress,
														elementsof( ipAddress ) );

		if( result != S_OK )
		{
			result = S_UNDISAMBIGUATED;
		}
		else
		{
			ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

			if( disambiguatedCallto == NULL )
			{
				result = S_UNDISAMBIGUATED;
			}
			else
			{
				result = S_CONFIDENCE_CERTITUDE;

				disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
				disambiguatedCallto->set_destination( ipAddress );
				disambiguatedCallto->set_confidence( result );
			}
		}
	}

	return( result );

}	//	End of CComputerDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CILSDisambiguator::disambiguate.										//
//--------------------------------------------------------------------------//
HRESULT
CILSDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	const IILSContext * const	ilsContext	= calltoContext->get_ilsContext();
	const TCHAR * const			type		= resolvedCallto->get_type();
	const TCHAR *				ilsServer	= resolvedCallto->get_server();
	HRESULT						result		= S_FALSE;
	TCHAR						ipAddress[ MAX_PATH ];

	if( (ilsServer == NULL) && (ilsContext != NULL) )
	{
		ilsServer = ilsContext->get_ilsName();
	}

	if( ilsServer != NULL )
	{
		bool	ils	= (lstrcmpi( type, TEXT( "ils" ) ) == 0);

		if( ils || (lstrcmpi( type, TEXT( "email" ) ) == 0) )
		{
			result = CCalltoContext::get_ipAddressFromILSEmail(	ilsServer,
																resolvedCallto->get_serverPort(),
																resolvedCallto->get_value(),
																ipAddress,
																elementsof( ipAddress ) );
		
			if( result == S_OK )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto == NULL )
				{
					result = S_UNDISAMBIGUATED;
				}
				else
				{
					result = (ils)? S_CONFIDENCE_HIGH: S_CONFIDENCE_MEDIUM;

					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( ipAddress );
					disambiguatedCallto->set_confidence( result );
				}
			}
		}
	}

	return( result );

}	//	End of CILSDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CUnrecognizedDisambiguator::disambiguate.								//
//--------------------------------------------------------------------------//
HRESULT
CUnrecognizedDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){

	if( calltoCollection->get_count() == 0 )
	{
		const TCHAR * const	type		= resolvedCallto->get_type();
		bool				phone		= (lstrcmpi( type, TEXT( "phone" ) ) == 0);
		bool				email		= (lstrcmpi( type, TEXT( "email" ) ) == 0);
		bool				ip			= (lstrcmpi( type, TEXT( "ip" ) ) == 0);
		bool				computer	= (lstrcmpi( type, TEXT( "computer" ) ) == 0);
		bool				ils			= (lstrcmpi( type, TEXT( "ils" ) ) == 0);
		bool				string		= (lstrcmpi( type, TEXT( "string" ) ) == 0);

		if( string || ((!phone) && (!email) && (!ip) && (!computer) && (!ils)) )
		{
			ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

			if( disambiguatedCallto != NULL )
			{
				disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
				disambiguatedCallto->set_confidence( S_UNDISAMBIGUATED );
			}
		}
	}

	return( S_UNDISAMBIGUATED );

}	//	End of CUnrecognizedDisambiguator::disambiguate.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltodisambiguator.h ===
#if !defined( calltoDisambiguator_h )
#define	calltoDisambiguator_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"


//--------------------------------------------------------------------------//
//	interface IDisambiguator.												//
//--------------------------------------------------------------------------//
class IDisambiguator
{
	protected:	//	protected constructors	--------------------------------//

		IDisambiguator(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IDisambiguator(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		) = 0;

};	//	End of interface IDisambiguator.


//--------------------------------------------------------------------------//
//	class CGatekeeperDisambiguator.											//
//--------------------------------------------------------------------------//
class CGatekeeperDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CGatekeeperDisambiguator.


//--------------------------------------------------------------------------//
//	class CGatewayDisambiguator.											//
//--------------------------------------------------------------------------//
class CGatewayDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CGatewayDisambiguator.


//--------------------------------------------------------------------------//
//	class CComputerDisambiguator.											//
//--------------------------------------------------------------------------//
class CComputerDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CComputerDisambiguator.


//--------------------------------------------------------------------------//
//	class CILSDisambiguator.												//
//--------------------------------------------------------------------------//
class CILSDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CILSDisambiguator.


//--------------------------------------------------------------------------//
//	class CUnrecognizedDisambiguator.										//
//--------------------------------------------------------------------------//
class CUnrecognizedDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CUnrecognizedDisambiguator.


//--------------------------------------------------------------------------//
//	class CCalltoDisambiguator.												//
//--------------------------------------------------------------------------//
class CCalltoDisambiguator
{
	public:		//	public constructors	------------------------------------//

		CCalltoDisambiguator(void);


	public:		//	public destructor	------------------------------------//

		~CCalltoDisambiguator();


	public:		//	public methods	----------------------------------------//

		HRESULT
		disambiguate
		(
			const ICalltoContext * const	calltoContext,
			ICalltoCollection * const		resolvedCalltoCollection,
			CCalltoCollection * const		disambiguatedCalltoCollection
		);


	private:	//	private methods	----------------------------------------//

		bool
		addDisambiguator
		(
			IDisambiguator * const	disambiguator
		);


	private:	//	private members	----------------------------------------//

		CGatekeeperDisambiguator	m_gatekeeperDisambiguator;
		CGatewayDisambiguator		m_gatewayDisambiguator;
		CILSDisambiguator			m_ilsDisambiguator;
		CComputerDisambiguator		m_computerDisambiguator;
		CUnrecognizedDisambiguator	m_unrecognizedDisambiguator;

		IDisambiguator *			m_disambiguators[ 5 ];
		int							m_registeredDisambiguators;

};	//	End of class CCalltoDisambiguator.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoDisambiguator_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltonm.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"
#include	"calltoDisambiguator.h"
#include	"calltoNM.h"


//--------------------------------------------------------------------------//
//	CNMCallto::CNMCallto.													//
//--------------------------------------------------------------------------//
CNMCallto::CNMCallto(void)
{
//tracec( assert( selfTest(), TEXT( "class CNMCallto failed self test..." ) ),
//			TEXT( "class CNMCallto passed self test...\r\n" ) );

}	//	End of CNMCallto::CNMCallto.


//--------------------------------------------------------------------------//
//	CNMCallto::~CNMCallto.													//
//--------------------------------------------------------------------------//
CNMCallto::~CNMCallto(void)
{
}	//	End of CNMCallto::~CNMCallto.


//--------------------------------------------------------------------------//
//	CNMCallto::callto.														//
//--------------------------------------------------------------------------//
HRESULT
CNMCallto::callto
(
	const TCHAR * const	url,
	const bool			strict,
	const bool			uiEnabled,
	INmCall**			ppInternalCall
){
	CCalltoProperties	calltoProperties;
	CCalltoCollection	resolvedCalltoCollection;
	CCalltoCollection	disambiguatedCalltoCollection;
	const ICallto *		disambiguatedCallto	= NULL;
	HRESULT				result;

	if( url == NULL )
	{
		result = E_POINTER;
	}
	else if( url[ 0 ] == '\0' )
	{
		result = E_INVALIDARG;
	}
	else
	{
		result = m_resolver.resolve( this, &calltoProperties, &resolvedCalltoCollection, url, strict );

		if( resolvedCalltoCollection.get_count() > 0 )
		{
			result = m_disambiguator.disambiguate( this, &resolvedCalltoCollection, &disambiguatedCalltoCollection );

			if( (!uiEnabled) || (disambiguatedCalltoCollection.get_count() == 1) )
			{
				//	Either there's only one choice or we've been instructed NOT to
				//	present any ui...   either way we just grab the first one...
				disambiguatedCallto = disambiguatedCalltoCollection.get_first();

				//	and verify that it was really disambiguated...
				if( disambiguatedCallto->get_confidence() != S_UNDISAMBIGUATED )
				{
					result = S_OK;
				}
				else
				{
					disambiguatedCallto = NULL;
				}
			}
		}
	}

	CCallto	emptyCallto;

	if( uiEnabled && (disambiguatedCallto == NULL) )
	{
		//	the user must now make the decision...
		result = disambiguate( &disambiguatedCalltoCollection, &emptyCallto, &disambiguatedCallto );
	}

	if( (result == S_OK) && (disambiguatedCallto != NULL) )
	{
		calltoProperties.set_url( disambiguatedCallto->get_qualifiedName() );
		calltoProperties.set_destination( disambiguatedCallto->get_destination() );
		calltoProperties.set_type( disambiguatedCallto->get_type() );
		calltoProperties.set_alias( disambiguatedCallto->get_value() );

		if( StrCmpNI_literal( disambiguatedCallto->get_type(), TEXT( "phone" ) ) )
		{
			calltoProperties.set_E164( disambiguatedCallto->get_value() );
		}

		result = ((ICalltoContext *) this)->callto( &calltoProperties, ppInternalCall );
	}

	return( result );

}	//	End of CNMCallto::callto.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableUIContext.										//
//--------------------------------------------------------------------------//
IMutableUIContext * const
CNMCallto::get_mutableUIContext(void) const
{

	return( CCalltoContext::get_mutableUIContext() );

}	//	End of CNMCallto::get_mutableUIContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableGatekeeperContext.								//
//--------------------------------------------------------------------------//
IMutableGatekeeperContext * const
CNMCallto::get_mutableGatekeeperContext(void) const
{

	return( CCalltoContext::get_mutableGatekeeperContext() );

}	//	End of CNMCallto::get_mutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableGatewayContext.									//
//--------------------------------------------------------------------------//
IMutableGatewayContext * const
CNMCallto::get_mutableGatewayContext(void) const
{

	return( CCalltoContext::get_mutableGatewayContext() );

}	//	End of CNMCallto::get_mutableGatewayContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableIlsContext.										//
//--------------------------------------------------------------------------//
IMutableILSContext * const
CNMCallto::get_mutableIlsContext(void) const
{

	return( CCalltoContext::get_mutableIlsContext() );

}	//	End of CNMCallto::get_mutableIlsContext.


#if 0
//--------------------------------------------------------------------------//
//	CNMCallto::selfTest.													//
//--------------------------------------------------------------------------//
bool
CNMCallto::selfTest(void)
{
	static TCHAR	buffer[ 2048 ];
	static LONG		tested	= -1;
	
	static HRESULT	confidenceLevels[]	=
	{
		S_CONFIDENCE_CERTITUDE,
		S_CONFIDENCE_HIGH,
		S_CONFIDENCE_MEDIUM,
		S_CONFIDENCE_LOW
	};

	static const TCHAR *	testUrls[]	=
	{
		TEXT( "callto:myGateway|email:jlemire@microsoft.com" ),			//	full
		TEXT( "callto:myGateway|email:jlemire" ),
		TEXT( "callto:myGateway|phone:1 (425) 703-9224" ),
		TEXT( "callto:myGateway|phone:1 (800) RU LEGIT" ),
		TEXT( "callto:myGateway|string:helpdesk" ),
		TEXT( "callto:myGateway|ils:jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ip:157.59.14.64" ),
		TEXT( "callto:myGateway|computer:JLEMIRE-2" ),
		TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2" ),

		TEXT( "callto:email:jlemire@microsoft.com" ),					//	no gateway
		TEXT( "callto:email:jlemire" ),
		TEXT( "callto:phone:1 (425) 703-9224" ),
		TEXT( "callto:phone:1 (800) RU LEGIT" ),
		TEXT( "callto:string:helpdesk" ),
		TEXT( "callto:ils:jlemire@microsoft.com" ),
		TEXT( "callto:ils:msils/jlemire@microsoft.com" ),
		TEXT( "callto:ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:ip:157.59.14.64" ),
		TEXT( "callto:computer:JLEMIRE-2" ),
		TEXT( "callto:computer:\\\\JLEMIRE-2" ),

		TEXT( "callto:myGateway|jlemire@microsoft.com" ),				//	no type
		TEXT( "callto:myGateway|jlemire" ),
		TEXT( "callto:myGateway|1 (425) 703-9224" ),
		TEXT( "callto:myGateway|1 (800) RU LEGIT" ),
		TEXT( "callto:myGateway|helpdesk" ),
		TEXT( "callto:myGateway|jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|msils/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|157.59.14.64" ),
		TEXT( "callto:myGateway|JLEMIRE-2" ),
		TEXT( "callto:myGateway|\\\\JLEMIRE-2" ),

		TEXT( "callto:jlemire@microsoft.com" ),							//	no gateway + no type
		TEXT( "callto:jlemire" ),
		TEXT( "callto:1 (425) 703-9224" ),
		TEXT( "callto:1 (800) RU LEGIT" ),
		TEXT( "callto:helpdesk" ),
		TEXT( "callto:jlemire@microsoft.com" ),
		TEXT( "callto:msils/jlemire@microsoft.com" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:157.59.14.64" ),
		TEXT( "callto:JLEMIRE-2" ),
		TEXT( "callto:\\\\JLEMIRE-2" ),

		//	repeat with params
		TEXT( "callto:myGateway|email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),			//	full
		TEXT( "callto:myGateway|email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),					//	no gateway
		TEXT( "callto:email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),				//	no type
		TEXT( "callto:myGateway|jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),							//	no gateway + no type
		TEXT( "callto:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		//	repeat without callto:
		TEXT( "myGateway|email:jlemire@microsoft.com" ),				//	full
		TEXT( "myGateway|email:jlemire" ),
		TEXT( "myGateway|phone:1 (425) 703-9224" ),
		TEXT( "myGateway|phone:1 (800) RU LEGIT" ),
		TEXT( "myGateway|string:helpdesk" ),
		TEXT( "myGateway|ils:jlemire@microsoft.com" ),
		TEXT( "myGateway|ils:msils/jlemire@microsoft.com" ),
		TEXT( "myGateway|ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "myGateway|ip:157.59.14.64" ),
		TEXT( "myGateway|computer:JLEMIRE-2" ),
		TEXT( "myGateway|computer:\\\\JLEMIRE-2" ),

		TEXT( "email:jlemire@microsoft.com" ),							//	no gateway
		TEXT( "email:jlemire" ),
		TEXT( "phone:1 (425) 703-9224" ),
		TEXT( "phone:1 (800) RU LEGIT" ),
		TEXT( "string:helpdesk" ),
		TEXT( "ils:jlemire@microsoft.com" ),
		TEXT( "ils:msils/jlemire@microsoft.com" ),
		TEXT( "ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "ip:157.59.14.64" ),
		TEXT( "computer:JLEMIRE-2" ),
		TEXT( "computer:\\\\JLEMIRE-2" ),

		TEXT( "myGateway|jlemire@microsoft.com" ),						//	no type
		TEXT( "myGateway|jlemire" ),
		TEXT( "myGateway|1 (425) 703-9224" ),
		TEXT( "myGateway|1 (800) RU LEGIT" ),
		TEXT( "myGateway|helpdesk" ),
		TEXT( "myGateway|jlemire@microsoft.com" ),
		TEXT( "myGateway|msils/jlemire@microsoft.com" ),
		TEXT( "myGateway|msils:80/jlemire@microsoft.com" ),
		TEXT( "myGateway|157.59.14.64" ),
		TEXT( "myGateway|JLEMIRE-2" ),
		TEXT( "myGateway|\\\\JLEMIRE-2" ),

		TEXT( "jlemire@microsoft.com" ),								//	no gateway + no type
		TEXT( "jlemire" ),
		TEXT( "1 (425) 703-9224" ),
		TEXT( "1 (800) RU LEGIT" ),
		TEXT( "helpdesk" ),
		TEXT( "jlemire@microsoft.com" ),
		TEXT( "msils/jlemire@microsoft.com" ),
		TEXT( "msils:80/jlemire@microsoft.com" ),
		TEXT( "msils:80/jlemire@microsoft.com" ),
		TEXT( "157.59.14.64" ),
		TEXT( "JLEMIRE-2" ),
		TEXT( "\\\\JLEMIRE-2" ),

		TEXT( "callto:futuretype:aren't I nicely extensible?" ),
		TEXT( "callto:myGateway|futuretype:aren't I nicely extensible?" )
	};

	static TCHAR *	expectedResults[ elementsof( testUrls ) ]	=
	{
		TEXT( "callto:myGateway|email:jlemire@microsoft.com" ),			//	TEXT( "callto:myGateway|email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|string:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:email:jlemire@microsoft.com" ),
		TEXT( "" ),		//	TEXT( "callto:email:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:string:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "myGateway|email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|email:jlemire" )
		TEXT( "" ),		//	TEXT( "myGateway|phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "myGateway|phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "myGateway|string:helpdesk" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "myGateway|computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "myGateway|computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "email:jlemire" )
		TEXT( "" ),		//	TEXT( "phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "string:helpdesk" )
		TEXT( "" ),		//	TEXT( "ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|jlemire" )
		TEXT( "" ),		//	TEXT( "myGateway|1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "myGateway|1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "myGateway|helpdesk" )
		TEXT( "" ),		//	TEXT( "myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|157.59.14.64" )
		TEXT( "" ),		//	TEXT( "myGateway|JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "myGateway|\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "jlemire" )
		TEXT( "" ),		//	TEXT( "1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "helpdesk" )
		TEXT( "" ),		//	TEXT( "jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "157.59.14.64" )
		TEXT( "" ),		//	TEXT( "JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:futuretype:aren't I nicely extensible?" )
		TEXT( "" )		//	TEXT( "callto:myGateway|futuretype:aren't I nicely extensible?" 
	};

	static int		contexts[ 4 ];
	static TCHAR *	actualResults[ elementsof( testUrls ) * elementsof( contexts ) ];

	HRESULT	result	= S_OK;

	if( InterlockedIncrement( &tested ) == 0 )
	{
		CCalltoProperties	calltoProperties;
		CCalltoCollection	resolvedCalltoCollection;
		CCalltoCollection	disambiguatedCalltoCollection;

		for( int context = 0; context < elementsof( contexts ); context++ )
		{
			CGatekeeperContext::set_enabled( context == 0 );
			CGatewayContext::set_enabled( context == 1 );
			CILSContext::set_enabled( context == 2 );

			for( int nn = 0; nn < elementsof( testUrls ); nn++ )
			{
				HRESULT	testResult	= m_resolver.resolve( this, &calltoProperties, &resolvedCalltoCollection, testUrls[ nn ], false );

				if( testResult != S_OK )
				{
					wsprintf( buffer, TEXT( "NOT RESOLVED!!!\t\tresult:0x%08X:\r\n" ), testResult );

					if( FAILED( testResult ) && (!FAILED( result )) )
					{
						result = testResult;		
					}
					else if( !FAILED( result ) )
					{
						result = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, nn );
					}
				}
				else
				{
					*buffer = NULL;

					for( int level = 0; level < elementsof( confidenceLevels ); level++ )
					{
						const ICallto *	resolvedCallto;

						for(	resolvedCallto = resolvedCalltoCollection.get_first();
								resolvedCallto != NULL;
								resolvedCallto = resolvedCalltoCollection.get_next() )
						{
							if( resolvedCallto->get_confidence() == confidenceLevels[ level ] )
							{
								wsprintf( &buffer[ lstrlen( buffer ) ], TEXT( "\t\t\t%9s: %s\r\n" ), ((confidenceLevels[ level ] == S_CONFIDENCE_CERTITUDE)? TEXT( "CERTITUDE" ): ((confidenceLevels[ level ] == S_CONFIDENCE_HIGH)? TEXT( "HIGH" ): ((confidenceLevels[ level ] == S_CONFIDENCE_MEDIUM)? TEXT( "MEDIUM" ): TEXT( "LOW" )))), resolvedCallto->get_qualifiedName() );
							}
						}
					}

					testResult = m_disambiguator.disambiguate( this, &calltoProperties, &resolvedCalltoCollection, &disambiguatedCalltoCollection );

					if( disambiguatedCalltoCollection.get_count() == 0 )
					{
						wsprintf( buffer, TEXT( "NOT DISAMBIGUATED!!!\t\tresult:0x%08X:\r\n" ), testResult );

						actualResults[ nn + (context * elementsof( testUrls )) ] = NULL;

						if( FAILED( testResult ) && (!FAILED( result )) )
						{
							result = testResult;		
						}
						else if( !FAILED( result ) )
						{
							result = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, nn );
						}
					}
					else
					{
						const ICallto *	disambiguatedCallto	= disambiguatedCalltoCollection.get_first();

						level = disambiguatedCallto->get_confidence();

						wsprintf( &buffer[ lstrlen( buffer ) ], TEXT( "\r\n%9s:\t%s\tresult:0x%08X\r\n" ), ((level == S_CONFIDENCE_CERTITUDE)? TEXT( "CERTITUDE" ): ((level == S_CONFIDENCE_HIGH)? TEXT( "HIGH" ): ((level == S_CONFIDENCE_MEDIUM)? TEXT( "MEDIUM" ): TEXT( "LOW" )))), disambiguatedCallto->get_qualifiedName(), testResult );
					}
				}

				if( (actualResults[ nn + (context * elementsof( testUrls )) ] = new TCHAR [ lstrlen( buffer ) + 1 ]) != NULL )
				{
					lstrcpy( actualResults[ nn + (context * elementsof( testUrls )) ], buffer );
				}
			}
		}

		for( int nn = 0; nn < elementsof( actualResults ); nn++ )
		{
			trace( TEXT( "------------------------------------------------------------------------------\r\n" ) );
			trace( TEXT( "%03d:\tgatekeeper:%-5s\tgateway:%s\tils:%s\r\n\r\n" ), nn, (((nn / elementsof( testUrls )) == 0)? TEXT( "true" ): TEXT( "false" )), (((nn / elementsof( testUrls )) == 1)? TEXT( "true" ): TEXT( "false" )), (((nn / elementsof( testUrls )) == 2)? TEXT( "true" ): TEXT( "false" )) );
			trace( TEXT( "\t\t\t%s\r\n" ), testUrls[ nn % elementsof( testUrls ) ] );
			trace( TEXT( "%s" ), actualResults[ nn ] );
			trace( TEXT( "------------------------------------------------------------------------------\r\n\r\n" ) );
			delete [] actualResults[ nn ];
		}

		m_selfTestResult = result;
	}

	return( result == S_OK );

}	//	End of CNMCallto::selfTest.


//--------------------------------------------------------------------------//
//	Win32 console process entry point.										//
//--------------------------------------------------------------------------//
int
main
(
	int					,//ArgC,
	const char * const	//ArgV[]
){
	CNMCallto	callto;		//	Just instantiating one of these will also cause CCalltoResolver::selfTest() to run...

	callto.callto( TEXT( "jlemire" ), false );	//	not strict...

	return( (int) callto.m_selfTestResult );

}	//	End of main.
#endif	//	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltoresolver.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"


//--------------------------------------------------------------------------//
//	CCalltoResolver::CCalltoResolver.										//
//--------------------------------------------------------------------------//
CCalltoResolver::CCalltoResolver(void):
	m_registeredResolvers( 0 )
{

	addResolver( &m_phoneResolver );
	addResolver( &m_emailResolver );
	addResolver( &m_ipResolver );
	addResolver( &m_computerResolver );
	addResolver( &m_ilsResolver );
	addResolver( &m_unrecognizedTypeResolver );
	addResolver( &m_stringResolver );

}	//	End of CCalltoResolver::CCalltoResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::~CCalltoResolver.										//
//--------------------------------------------------------------------------//
CCalltoResolver::~CCalltoResolver()
{
}	//	End of CCalltoResolver::~CCalltoResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CCalltoResolver::resolve
(
	ICalltoContext * const		calltoContext,
	CCalltoProperties * const	calltoProperties,
	CCalltoCollection * const	resolvedCalltoCollection,
	const TCHAR *				url,
	const bool					strict
){
	HRESULT	result;

	if( (calltoContext == NULL) || (calltoProperties == NULL) || (resolvedCalltoCollection == NULL) )
	{
		result = E_POINTER;
	}
	else
	{
		TCHAR *	params			= StrStrI( url, TEXT( "phone:+" ) );
		
		params = StrChr( (params != NULL)? params + strlen_literal( TEXT( "phone:+" ) ): url, '+' );

		int		paramsLength	= (params == NULL)? 0: lstrlen( params );
		int		urlLength		= lstrlen( url ) - paramsLength + 1;
		int		prefixLength	= 0;

		if( !StrCmpNI_literal( url, TEXT( "callto:" ) ) )
		{
			prefixLength = strlen_literal( TEXT( "callto:" ) );
		}
		else if( StrCmpNI_literal( url, TEXT( "callto://" ) ) )
		{
			prefixLength	= strlen_literal( TEXT( "callto:" ) );
			url				+= strlen_literal( TEXT( "callto://" ) );
			urlLength		-= strlen_literal( TEXT( "callto://" ) ) - strlen_literal( TEXT( "callto:" ) );
		}

		TCHAR *	urlBuffer	= NULL;

		if( (urlBuffer = new TCHAR [ urlLength + prefixLength ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			if( paramsLength > 0 )
			{
				// Save params...
				calltoProperties->set_params( params );
			}

			// Save original callto...
			calltoProperties->set_callto( url, urlLength );

			result = S_FALSE;

			resolvedCalltoCollection->reset();

			if( urlLength > 1 )
			{
				bool	strictChecked	= !strict;

				for( int nn = 0; nn < m_registeredResolvers; nn++ )
				{
					if( prefixLength > 0 )
					{
						lstrcpy( urlBuffer, TEXT( "callto:" ) );	// Prepend default of callto: ...
						lstrcpyn( urlBuffer + strlen_literal( TEXT( "callto:" ) ), url, urlLength );
					}
					else
					{
						lstrcpyn( urlBuffer, url, urlLength );
					}

					if( !strictChecked )
					{
						if( !strictCheck( urlBuffer ) )
						{
							result = E_INVALIDARG;
							break;
						}

						strictChecked = true;
					}

					HRESULT	resolveResult	= m_resolvers[ nn ]->resolve( resolvedCalltoCollection, urlBuffer );

					if( FAILED( resolveResult ) && (!FAILED( result )) )
					{
						result = resolveResult;
					}
				}

				if( !FAILED( result ) )
				{
					result = (resolvedCalltoCollection->get_count() > 0)? S_OK: S_FALSE;
				}
			}
		}

		delete [] urlBuffer;
	}

	return( result );

}	//	End of class CCalltoResolver::resolve.


//--------------------------------------------------------------------------//
//	CCalltoResolver::addResolver.											//
//--------------------------------------------------------------------------//
bool
CCalltoResolver::addResolver
(
	IResolver * const	resolver
){
//assert( resolver != NULL, TEXT( "attempted to add NULL resolver\r\n" ) );
//assert( m_registeredResolvers < elementsof( m_resolvers ), TEXT( "attempted to add to many resolvers: %d\r\n" ), m_registeredResolvers );

	if( (resolver != NULL) && (m_registeredResolvers < elementsof( m_resolvers )) )
	{
		m_resolvers[ m_registeredResolvers++ ] = resolver;
	}

	return( (resolver != NULL) && (m_registeredResolvers <= elementsof( m_resolvers )) );

}	//	End of CCalltoResolver::addResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::strictCheck.											//
//--------------------------------------------------------------------------//
const bool
CCalltoResolver::strictCheck
(
	const TCHAR * const	url
) const
{
//assert( url != NULL, TEXT( "attempted to strictCheck NULL url\r\n" ) );

	return( (url != NULL)	&&
			(StrCmpNI_literal( url, TEXT( "callto:phone:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:email:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:ip:" ) )		||
			StrCmpNI_literal( url, TEXT( "callto:computer:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:ils:" ) )		||
			StrCmpNI_literal( url, TEXT( "callto:string:" ) )	||
			(StrStrI( url, TEXT( "|phone:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|email:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|ip:" ) ) !=  NULL)			||
			(StrStrI( url, TEXT( "|computer:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|ils:" ) ) !=  NULL)			||
			(StrStrI( url, TEXT( "|string:" ) ) !=  NULL)) );

}	//	End of CCalltoResolver::strictCheck.


//--------------------------------------------------------------------------//
//	CPhoneResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CPhoneResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	phoneType;
		TCHAR *	phoneNumber	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:phone:" ) ) )				//	Check for phone type without gateway...
		{
			phoneType	= url;
			phoneNumber	= url + strlen_literal( TEXT( "callto:phone:" ) );
		}
		else if( (phoneType = StrStrI( url, TEXT( "|phone:" ) )) != NULL )	//	Check for phone type with gateway...
		{
			phoneNumber = phoneType + strlen_literal( TEXT( "|phone:" ) );
		}

		if( phoneNumber != NULL )
		{
			//	phone: type was specified for this callto:...
			if( CCalltoContext::toE164( phoneNumber, NULL, 0 ) )
			{
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					CCalltoContext::toE164( phoneNumber, phoneNumber, lstrlen( phoneNumber ) );
					resolvedCallto->set_qualifiedName( url );
					resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

					result = S_OK;
				}
				else
				{
					result = E_OUTOFMEMORY;
				}
			}
		}
		else
		{
			phoneNumber = url + strlen_literal( TEXT( "callto:" ) );

			if( CCalltoContext::isPhoneNumber( phoneNumber ) )
			{
				//	It smells like E164...
				result = E_OUTOFMEMORY;

				CCalltoContext::toE164( phoneNumber, phoneNumber, lstrlen( phoneNumber ) );

				TCHAR *	buffer	= new TCHAR [ lstrlen( phoneNumber ) + strlen_literal( TEXT( "callto:phone:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:phone:%s" ), phoneNumber );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CPhoneResolver::resolve.


//--------------------------------------------------------------------------//
//	CEMailResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CEMailResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	emailType;
		TCHAR *	emailAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:email:" ) ) )				//	Check for email type without gateway...
		{
			emailType		= url;
			emailAddress	= url + strlen_literal( TEXT( "callto:email:" ) );
		}
		else if( (emailType = StrStrI( url, TEXT( "|email:" ) )) != NULL )	//	Check for email type with gateway...
		{
			emailAddress = emailType + strlen_literal( TEXT( "|email:" ) );
		}

		if( emailAddress != NULL )
		{
			//	email: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );
				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			emailAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( (StrChr( emailAddress, ':' ) == NULL)	&&		//	isn't some other type:...
				(StrChr( emailAddress, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( emailAddress, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( emailAddress, '/' ) == NULL)	&&		//	isn't an old style ilsserver/email...
				((StrChr( emailAddress, '.' ) == NULL) ||		//	doesn't have a dot unless it also
				(StrChr( emailAddress, '@' ) != NULL)) )		//	has a @ so it can't be an ip address...
			{
				//	It smells like an email address...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( emailAddress ) + strlen_literal( TEXT( "callto:email:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:email:%s" ), emailAddress );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CEMailResolver::resolve.


//--------------------------------------------------------------------------//
//	CIPResolver::resolve.													//
//--------------------------------------------------------------------------//
HRESULT
CIPResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	ipType;
		TCHAR *	ipAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:ip:" ) ) )				//	Check for ip type without gateway...
		{
			ipType		= url;
			ipAddress	= url + strlen_literal( TEXT( "callto:ip:" ) );
		}
		else if( (ipType = StrStrI( url, TEXT( "|ip:" ) )) != NULL )	//	Check for ip type with gateway...
		{
			ipAddress = ipType + strlen_literal( TEXT( "|ip:" ) );
		}

		if( (ipAddress != NULL) && CCalltoContext::isIPAddress( ipAddress ) )
		{
			//	ip: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			ipAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( CCalltoContext::isIPAddress( ipAddress ) )
			{
				//	It smells like an ip address...
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					TCHAR	buffer[ MAX_PATH ];

					wsprintf( buffer, TEXT( "callto:ip:%s" ), ipAddress );
					resolvedCallto->set_qualifiedName( buffer );
					resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

					result = S_OK;
				}
				else
				{
					result = E_OUTOFMEMORY;
				}
			}
		}
	}

	return( result );

}	//	End of CIPResolver::resolve.


//--------------------------------------------------------------------------//
//	CComputerResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CComputerResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	computerType;
		TCHAR *	hostName	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:computer:" ) ) )					//	Check for computer type without gateway...
		{
			computerType	= url;
			hostName		= url + strlen_literal( TEXT( "callto:computer:" ) );
		}
		else if( (computerType = StrStrI( url, TEXT( "|computer:" ) )) != NULL )	//	Check for computer type with gateway...
		{
			hostName = computerType + strlen_literal( TEXT( "|computer:" ) );
		}

		if( hostName != NULL )
		{
			//	host: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			hostName = url + strlen_literal( TEXT( "callto:" ) );

			TCHAR *	slash	= hostName;

			//	Remove any trailing /....
			while( (slash = StrChr( slash, '/' )) != NULL )
			{
				if( slash[ 1 ] == '\0' )
				{
					slash[ 0 ] = '\0';
					break;
				}

				slash++;
			}

			if( (StrChr( hostName, ':' ) == NULL)	&&		//	isn't some other type:...
				(StrChr( hostName, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( hostName, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( hostName, '/' ) == NULL)	&&		//	doesn't contain a slash (ils)...
				(StrChr( hostName, '@' ) == NULL) )			//	doesn't contain an @...
			{
				//	It smells like a dns host name...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( hostName ) + strlen_literal( TEXT( "callto:computer:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:computer:%s" ), hostName );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence(  StrCmpNI_literal( hostName, TEXT( "\\\\" ) )? S_CONFIDENCE_HIGH: S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CComputerResolver::resolve.


//--------------------------------------------------------------------------//
//	CILSResolver::resolve.													//
//--------------------------------------------------------------------------//
HRESULT
CILSResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		const TCHAR *	ilsType;
		const TCHAR *	emailAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:ils:" ) ) )			//	Check for ils type without gateway...
		{
			ilsType			= url;
			emailAddress	= url + strlen_literal( TEXT( "callto:ils:" ) );
		}
		else if( (ilsType = StrStrI( url, TEXT( "|ils:" ) )) != NULL )	//	Check for ils type with gateway...
		{
			emailAddress = ilsType + strlen_literal( TEXT( "|ils:" ) );
		}

		if( emailAddress != NULL )
		{
			//	ils: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			emailAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( (StrChr( emailAddress, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( emailAddress, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( emailAddress, '/' ) != NULL) )			//	has a /...
			{
				//	It smells like an ilsserver/emailaddress...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( emailAddress ) + strlen_literal( TEXT( "callto:ils:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:ils:%s" ), emailAddress );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CILSResolver::resolve.


//--------------------------------------------------------------------------//
//	CUnrecognizedTypeResolver::resolve.										//
//--------------------------------------------------------------------------//
HRESULT
CUnrecognizedTypeResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	type;
		TCHAR *	unrecognized	= url + strlen_literal( TEXT( "callto:" ) );
		TCHAR *	gateway			= NULL;
		TCHAR *	value			= NULL;

		result = S_FALSE;

		if( ((type = StrChr( unrecognized, ':' )) != NULL)	&&																//	Check for a type, but not a known one...
			(!StrCmpNI_literal( url, TEXT( "callto:phone:" ) )) && (StrStrI( url, TEXT( "|phone:" ) ) == NULL)			&&	//	isn't a phone: type...
			(!StrCmpNI_literal( url, TEXT( "callto:email:" ) )) && (StrStrI( url, TEXT( "|email:" ) ) == NULL)			&&	//	isn't an email: type...
			(!StrCmpNI_literal( url, TEXT( "callto:computer:" ) )) && (StrStrI( url, TEXT( "|computer:" ) ) == NULL)	&&	//	isn't a computer: type...
			(!StrCmpNI_literal( url, TEXT( "callto:ils:" ) )) && (StrStrI( url, TEXT( "|ils:" ) ) == NULL)				&&	//	isn't an ils: type...
			(!StrCmpNI_literal( url, TEXT( "callto:ip:" ) )) && (StrStrI( url, TEXT( "|ip:" ) ) == NULL)				&&	//	isn't an ip: type...
			(!StrCmpNI_literal( url, TEXT( "callto:string:" ) )) && (StrStrI( url, TEXT( "|string:" ) ) == NULL) )			//	isn't an string: type...
		{
			*type++	= NULL;
			value	= type;

			if( (gateway = StrChr( url, '|' )) != NULL )	//	Check for a gateway...
			{
				*gateway++	= NULL;
				type		= gateway;
				gateway		= unrecognized;
			}
		}

		if( value != NULL )
		{
			//	Some unrecognized type was specified...
			result = E_OUTOFMEMORY;

			int	length	= strlen_literal( TEXT( "callto:|%s" ) ) + lstrlen( value );

			if( gateway ==  NULL )
			{
				length += lstrlen( unrecognized );
			}
			else
			{
				length += lstrlen( gateway ) + lstrlen( type );
			}

			TCHAR *	buffer	= new TCHAR [ length ];

			if( buffer != NULL )
			{
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					if( gateway == NULL )
					{
						wsprintf( buffer, TEXT( "callto:%s:%s" ), unrecognized, value );
					}
					else
					{
						wsprintf( buffer, TEXT( "callto:%s|%s:%s" ), gateway, type, value );
					}

					resolvedCallto->set_qualifiedName( buffer );
					resolvedCallto->set_confidence( S_CONFIDENCE_LOW );

					result = S_OK;
				}

				delete [] buffer;
			}
		}
	}

	return( result );

}	//	End of CUnrecognizedTypeResolver::resolve.


//--------------------------------------------------------------------------//
//	CStringResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CStringResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	stringType;
		TCHAR *	string	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:string:" ) ) )					//	Check for string type without gateway...
		{
			stringType	= url;
			string		= url + strlen_literal( TEXT( "callto:string:" ) );
		}
		else if( (stringType = StrStrI( url, TEXT( "|string:" ) )) != NULL )	//	Check for string type with gateway...
		{
			string = stringType + strlen_literal( TEXT( "|string:" ) );
		}

		if( string != NULL )
		{
			//	string: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			string = url + strlen_literal( TEXT( "callto:" ) );

			if( StrChr( string, ':' ) == NULL )
			{
				//	It doesn't have a type so set it to string...
				result = E_OUTOFMEMORY;
				TCHAR *	slash;
				TCHAR *	buffer	= new TCHAR [ lstrlen( string ) + strlen_literal( TEXT( "callto:%s|string:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						if( (slash = StrChr( string, '|' )) == NULL )		//	Check for a gateway...
						{
							wsprintf( buffer, TEXT( "callto:string:%s" ), string );
						}
						else
						{
							*slash++ = NULL;
							wsprintf( buffer, TEXT( "callto:%s|string:%s" ), string, slash );
						}

						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_LOW );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CStringResolver::resolve.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\certui.cpp ===
// File: certui.cpp

#include "precomp.h"
#include "resource.h"
#include "nmmkcert.h"
#include "certui.h"
#include <tsecctrl.h>
#include "SDKInternal.h"
#include "ConfUtil.h"

#define SZ_CRYPTDLGDLL "CRYPTDLG"

extern INmSysInfo2 * g_pNmSysInfo;

//
// While the credentials underlying the certificate we are using
// are in use, we need to keep the certificate context around
// and the store open. So we hold the currently open cert store
// and cert context in these globals:

static PCCERT_CONTEXT g_pCertContext;
static HCERTSTORE g_hCertStore;

TCHAR * FormatCert ( PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL, pIssuerCert = NULL, pCACert = NULL;
    DWORD cbRet = 0;
    CHAR * pSubject = NULL;
    CHAR * pIssuer = NULL;
    DWORD cbSubject = 0;
    DWORD cbIssuer = 0;
    DWORD dwFlags;
    DWORD cbTotalRequired;
    CHAR szLoadStringBuf[512];
    HCERTSTORE hRootStore = NULL;
    HCERTSTORE hCAStore = NULL;
    BOOL fSelfIssued = FALSE;
    TCHAR * pInfo = NULL;
    TCHAR szNotBefore[64];
    TCHAR szNotAfter[64];

    ASSERT(pbEncodedCert);
    ASSERT(cbEncodedCert);

    //
    // Get the certificate from the encoded blob
    //

    pCert = CertCreateCertificateContext ( X509_ASN_ENCODING,
                                            pbEncodedCert,
                                            cbEncodedCert );


    if ( NULL == pCert )
    {
        // Creating the cert context failed
        ERROR_OUT(("Error creating cert context from %x (%d bytes): %x",
            pbEncodedCert, cbEncodedCert, GetLastError()));
        goto cleanup;
    }

    //
    // Get the subject information
    //

    cbSubject = CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_FORMAT_FLAGS,
                        NULL, 0);

    if ( 0 == cbSubject )
    {
        ERROR_OUT(("GetUserInfo: no subject string"));
        goto cleanup;
    }

    pSubject = new CHAR[cbSubject + 1];

    if ( NULL == pSubject )
    {
        ERROR_OUT(("GetUserInfo: error allocating subject name"));
        goto cleanup;
    }

    if ( 0 >= CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_FORMAT_FLAGS,
                        pSubject, cbSubject+1))
    {
        ERROR_OUT(("GetUserInfo: error getting subject string"));
        goto cleanup;
    }

    //
    // Get the issuer information
    //

    cbIssuer = CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Issuer,
                        CERT_FORMAT_FLAGS,
                        NULL, 0);

    if ( 0 == cbIssuer )
    {
        ERROR_OUT(("GetUserInfo: no issuer string"));
        goto cleanup;
    }

    pIssuer = new CHAR[cbIssuer + 1];

    if ( NULL == pIssuer )
    {
        ERROR_OUT(("GetUserInfo: error allocating issuer name"));
    }

    if ( 0 >= CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Issuer,
                        CERT_FORMAT_FLAGS,
                        pIssuer, cbIssuer+1))
    {
        ERROR_OUT(("GetUserInfo: error getting issuer string"));
        goto cleanup;
    }

    //
    // Format the file time from the cert
    //

    SYSTEMTIME stNotBefore;
    SYSTEMTIME stNotAfter;

    FileTimeToSystemTime(&(pCert->pCertInfo->NotBefore), &stNotBefore);
    FileTimeToSystemTime(&(pCert->pCertInfo->NotAfter), &stNotAfter);

    FmtDateTime(&stNotBefore, szNotBefore, CCHMAX(szNotBefore));
    FmtDateTime(&stNotAfter, szNotAfter, CCHMAX(szNotAfter));

    //
    // Open the root store for certificate verification
    //

    hRootStore = CertOpenSystemStore(0, "Root");

    if( NULL == hRootStore )
    {
        ERROR_OUT(("Couldn't open root certificate store"));
        goto cleanup;
    }

    //
    // Get the issuer certificate from the root store and check for problems
    //

    dwFlags =   CERT_STORE_REVOCATION_FLAG |
                CERT_STORE_SIGNATURE_FLAG |
                CERT_STORE_TIME_VALIDITY_FLAG;

    // Get the issuer of this cert

    pIssuerCert = CertGetIssuerCertificateFromStore(
                        hRootStore,
                        pCert,
                        NULL,
                        &dwFlags );

    // If the issuer of the certificate cannot be found in the root store,
    // check the CA store iteratively until we work our way back to a root
    // certificate

    pCACert = pCert;

    while ( NULL == pIssuerCert )
    {
        PCCERT_CONTEXT pTmpCert;

        if ( NULL == hCAStore )
        {
            hCAStore = CertOpenSystemStore(0, "CA");

            if ( NULL == hCAStore )
            {
                ERROR_OUT(("Couldn't open CA certificate store"));
                goto cleanup;
            }
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pTmpCert = CertGetIssuerCertificateFromStore(
                        hCAStore,
                        pCACert,
                        NULL,
                        &dwFlags );

        if ( NULL == pTmpCert )
        {
            TRACE_OUT(("Issuer not found in CA store either"));
            break;
        }

        if ( pCACert != pCert )
            CertFreeCertificateContext(pCACert);
        pCACert = pTmpCert;

        if ((( CERT_STORE_REVOCATION_FLAG & dwFlags ) &&
             !( CERT_STORE_NO_CRL_FLAG & dwFlags )) ||
             ( CERT_STORE_SIGNATURE_FLAG & dwFlags ) ||
             ( CERT_STORE_TIME_VALIDITY_FLAG & dwFlags ))
        {
            TRACE_OUT(("Problem with issuer in CA store: %x", dwFlags));
            break;
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pIssuerCert = CertGetIssuerCertificateFromStore(
                        hRootStore,
                        pCACert,
                        NULL,
                        &dwFlags );

    }

    if ( pCACert != pCert )
        CertFreeCertificateContext ( pCACert );

    //
    // Total up the return buffer required
    //
    // BUGBUG this overestimates the requirements slightly because
    // this formatting buffer contains specifiers which will be
    // replaced during wsprintf
    cbTotalRequired =   cbSubject +
                        cbIssuer +
                        lstrlen(szNotBefore) +
                        lstrlen(szNotAfter) +
                        FLoadString2( IDS_FMTBUFFER, szLoadStringBuf,
                                    sizeof(szLoadStringBuf)) + 1;

    //
    // If there are problems, account for the extra info:
    //

    if ( NULL == pIssuerCert )
    {
        // If after all we couldn't find the issuer check if this is
        // a NetMeeting self-issued certificate and generate an appropriate
        // message if so:

        DWORD dwMagic;
        DWORD cbMagic;

        cbMagic = sizeof(dwMagic);

        // BUGBUG: why is user prop not available for remote context?
        //if (pSecurityInterface->pfn_CertGetCertificateContextProperty(pCert,
        //   CERT_FIRST_USER_PROP_ID, &dwMagic, &cbMagic) &&
        //  cbMagic == sizeof(dwMagic) && dwMagic == NMMKCERT_MAGIC )

        if ( !lstrcmp( pIssuer, SZ_NMROOTNAME ))
        {
            // We're just going to return some generic text about the
            // NetMeeting default certificate


            cbTotalRequired = FLoadString2( IDS_GENERIC_NMDC_TEXT,
                                szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
            fSelfIssued = TRUE;
        }
        else
        {
            cbTotalRequired += FLoadString2( IDS_CERTERR_NOISSUER,
                                szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
    }
    else
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            WARNING_OUT(("Verify: Signature invalid"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_SIG,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            WARNING_OUT(("Verify: Cert expired"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_EXPIRED,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( (dwFlags & CERT_STORE_REVOCATION_FLAG) &&
            !(dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            WARNING_OUT(("Verify: Cert revoked"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_REVOKED,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( 0 == (dwFlags & ~CERT_STORE_NO_CRL_FLAG) )
        {
            // Everything is OK:
            cbTotalRequired += FLoadString2( IDS_CERT_VERIFIED,
                                szLoadStringBuf, sizeof(szLoadStringBuf));
        }
    }


    //
    // Allocate the required buffer
    //

    pInfo = new TCHAR[cbTotalRequired];

    if ( NULL == pInfo )
    {
        ERROR_OUT(("Error allocating FormatCert return buffer"));
        goto cleanup;
    }

    //
    // If we're reporting on a NetMeeting issued certificate, just load
    // the generic text and return.
    //

    if ( fSelfIssued )
    {
        FLoadString( IDS_GENERIC_NMDC_TEXT, pInfo, cbTotalRequired );
        goto cleanup;
    }

    //
    // If we are here we can go ahead and format the data into the buffer
    //

    FLoadString( IDS_FMTBUFFER, szLoadStringBuf,
                sizeof(szLoadStringBuf));

    //
    // Do the formatting
    //

    wsprintf( pInfo, szLoadStringBuf, pSubject, pIssuer,
                            szNotBefore, szNotAfter );

    if ( NULL == pIssuerCert )
    {
        FLoadString( IDS_CERTERR_NOISSUER,
                szLoadStringBuf, sizeof(szLoadStringBuf));
        lstrcat( pInfo, szLoadStringBuf );
    }
    else
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            FLoadString( IDS_CERTERR_SIG,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            FLoadString( IDS_CERTERR_EXPIRED,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
        if ( (dwFlags & CERT_STORE_REVOCATION_FLAG) &&
            !(dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            FLoadString( IDS_CERTERR_REVOKED,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }

        if ( 0 == (dwFlags & ~CERT_STORE_NO_CRL_FLAG) )
        {
            // Everything is OK:
            FLoadString( IDS_CERT_VERIFIED,
                                szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
    }

    ASSERT( cbRet < 1000 ); // Reasonableness check

cleanup:

    if ( NULL != pSubject )
        delete [] pSubject;

    if ( NULL != pIssuer )
        delete [] pIssuer;

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    if ( NULL != pIssuerCert )
    {
        CertFreeCertificateContext ( pIssuerCert );
    }

    if ( NULL != hRootStore )
    {
        if ( !CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG))
        {
            WARNING_OUT(("FormatCert: error closing root store"));
        }
    }

    if ( NULL != hCAStore )
    {
        if ( !CertCloseStore(hCAStore, CERT_CLOSE_STORE_CHECK_FLAG))
        {
            WARNING_OUT(("FormatCert: error closing CA store"));
        }
    }

    return pInfo;
}

BOOL RefreshSelfIssuedCert (VOID)
{
    BOOL bRet = FALSE;
    DWORD dwResult;
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);

    if (reCONF.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                    DEFAULT_SECURITY_AUTHENTICATION))
    {
        return TRUE;
    }

    //
    // If there's no sys info interface, that's probably OK, we're just
    // being called in the setup wizard.
    //

    if (!g_pNmSysInfo)
        return FALSE;

    //
    // Clear old cert out of transport
    //
    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetSelfIssuedCert: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    g_hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                    X509_ASN_ENCODING,
                                    0,
                                    CERT_SYSTEM_STORE_CURRENT_USER,
                                    WSZNMSTORE );
    if ( g_hCertStore )
    {
        //
        // We only expect one cert in here, get it
        //

        g_pCertContext = CertFindCertificateInStore(
                                              g_hCertStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_ANY,
                                              NULL,
                                              NULL);
        if ( g_pCertContext )
        {
            dwResult = -1;

            g_pNmSysInfo->ProcessSecurityData(
                                    TPRTCTRL_SETX509CREDENTIALS,
                                    (DWORD_PTR)g_pCertContext, 0,
                                    &dwResult);
            //
            // g_hCertStore and g_pCertContext now in use
            //

            if ( !dwResult )
            {
                bRet = TRUE;
            }
            else
            {
                ERROR_OUT(("RefreshSelfIssuedCert - failed in T.120"));
            }
        }
        else
        {
            ERROR_OUT(("RefreshPrivacyCert: no cert in %s?", SZNMSTORE));
        }
    }
    else
    {
        WARNING_OUT(("RefreshSelfIssuedCert: error opening %s store %x",
            SZNMSTORE, GetLastError()));
    }
    return bRet;
}

DWORD NumUserCerts(VOID)
{
    DWORD cCerts = 0;
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCert = NULL;

    if ( hStore = CertOpenSystemStore(0, "MY"))
    {
        while ( pCert = CertEnumCertificatesInStore(
                                    hStore, (PCERT_CONTEXT)pCert ))
            cCerts++;
        if ( !CertCloseStore( hStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("NumUserCerts: error closing store"));
        }
    }
    return cCerts;
}

#include "cryptdlg.h"

typedef BOOL (WINAPI *PFN_CERT_SELECT_CERTIFICATE)(PCERT_SELECT_STRUCT_A);

BOOL ChangeCertDlg ( HWND hwndParent, HINSTANCE hInstance,
    PBYTE * ppEncodedCert, DWORD * pcbEncodedCert )
{
    HINSTANCE hCryptDlg = NmLoadLibrary ( SZ_CRYPTDLGDLL ,TRUE);
    PFN_CERT_SELECT_CERTIFICATE pfn_CertSelectCertificate;
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);
    PCCERT_CONTEXT pOldCert = NULL;
    BOOL bRet = FALSE;

    //
    // First, make sure we can get the CRYPTDLG entry point we need
    //

    if ( NULL == hCryptDlg )
    {
        ERROR_OUT(("Error loading CRYPTDLG"));
        return bRet;
    }

    pfn_CertSelectCertificate =
        (PFN_CERT_SELECT_CERTIFICATE)GetProcAddress ( hCryptDlg,
                                "CertSelectCertificateA" );

    if ( NULL == pfn_CertSelectCertificate )
    {
        ERROR_OUT(("Error getting CertSelectCertificate entry point"));
        goto cleanup;
    }

    //
    // Prepare to bring up the choose dialog
    //

    CERT_SELECT_STRUCT_A css;

    ZeroMemory ( &css, sizeof(css) );

    css.dwSize = sizeof(css);
    css.hwndParent = hwndParent;
    css.hInstance = hInstance;

    css.cCertStore = 1;

    HCERTSTORE aCertStore[1];
    aCertStore[0] = CertOpenSystemStore(0, "MY" );

    if ( NULL == aCertStore[0] )
    {
        ERROR_OUT(("Error opening 'my' store"));
        goto cleanup;
    }
    css.arrayCertStore = aCertStore;

    css.szPurposeOid = szOID_PKIX_KP_CLIENT_AUTH; // BUGBUG add server auth?

    PCCERT_CONTEXT pcc;
    pcc = NULL;

    //
    // Now, get access to the current NetMeeting certificate, if any
    //

    LPBYTE pCertID;
    DWORD cbCertID;

    if ( cbCertID = reCONF.GetBinary ( REGVAL_CERT_ID, (void**)&pCertID ))
    {

        while ( pOldCert = CertEnumCertificatesInStore(
                                    aCertStore[0], (PCERT_CONTEXT)pOldCert ))
        {
            if (cbCertID == pOldCert->pCertInfo->SerialNumber.cbData &&
                !memcmp(pCertID, pOldCert->pCertInfo->SerialNumber.pbData,
                                pOldCert->pCertInfo->SerialNumber.cbData))
            {
                // pOldCert must now be freed via CertFreeCertificateContext
                pcc = pOldCert;
                break;
            }
        }
    }

    css.cCertContext = 0;
    css.arrayCertContext = &pcc;

    if (pfn_CertSelectCertificate ( &css ))
    {
        ASSERT(1 == css.cCertContext);

        //
        // It worked, return the new cert
        //

        CoTaskMemFree ( *ppEncodedCert );

        if ( *ppEncodedCert = (PBYTE)CoTaskMemAlloc ( pcc->cbCertEncoded ))
        {
            memcpy ( *ppEncodedCert, pcc->pbCertEncoded, pcc->cbCertEncoded );
            *pcbEncodedCert = pcc->cbCertEncoded;
            bRet = TRUE;
        }
    }

cleanup:

    if ( aCertStore[0] )
        if (!CertCloseStore ( aCertStore[0], 0 ))
        {
            WARNING_OUT(("ChangeCertDlg: error closing store"));
        }

    if ( pOldCert )
    {
        CertFreeCertificateContext(pOldCert);
    }
    if ( hCryptDlg )
        FreeLibrary ( hCryptDlg );

    return bRet;
}

typedef BOOL (WINAPI *PFN_CERT_VIEW_PROPERTIES)(PCERT_VIEWPROPERTIES_STRUCT);

VOID ViewCertDlg ( HWND hwndParent, PCCERT_CONTEXT pCert )
{
    HINSTANCE hCryptDlg = NmLoadLibrary ( SZ_CRYPTDLGDLL, TRUE );
    PFN_CERT_VIEW_PROPERTIES pfn_CertViewProperties;

    //
    // First, make sure we can get the CRYPTDLG entry point we need
    //

    if ( NULL == hCryptDlg )
    {
        ERROR_OUT(("Error loading CRYPTDLG"));
        return;
    }

    pfn_CertViewProperties =
        (PFN_CERT_VIEW_PROPERTIES)GetProcAddress ( hCryptDlg,
                                "CertViewPropertiesA" );

    if ( NULL == pfn_CertViewProperties )
    {
        ERROR_OUT(("Error getting CertViewProperties entry point"));
        goto cleanup;
    }

    CERT_VIEWPROPERTIES_STRUCT    cvp;
    ZeroMemory(&cvp, sizeof(cvp));

    cvp.dwSize = sizeof(cvp);
    cvp.pCertContext = pCert;
    cvp.hwndParent = hwndParent;

    pfn_CertViewProperties ( &cvp );

cleanup:

    if ( hCryptDlg )
        FreeLibrary ( hCryptDlg );

    return;
}

VOID FreeT120EncodedCert ( PBYTE pbEncodedCert )
{
    CoTaskMemFree(pbEncodedCert);
}

BOOL GetT120ActiveCert ( PBYTE * ppbEncodedCert, DWORD * pcbEncodedCert )
{
    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("GetT120ActiveCert: g_pNmSysInfo NULL"));
        return FALSE;
    }

    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(TPRTCTRL_GETX509CREDENTIALS,
                                (DWORD_PTR)ppbEncodedCert,
                                (DWORD_PTR)pcbEncodedCert,
                                &dwResult);
    return ( dwResult == 0 );
}

BOOL SetT120CertInRegistry ( PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    PCCERT_CONTEXT pCert = CertCreateCertificateContext ( X509_ASN_ENCODING,
                                                        pbEncodedCert,
                                                        cbEncodedCert );

    if ( pCert )
    {
        RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);

        //
        // Set the new value
        //

        reCONF.SetValue ( REGVAL_CERT_ID,
                    pCert->pCertInfo->SerialNumber.pbData,
                    pCert->pCertInfo->SerialNumber.cbData );

        CertFreeCertificateContext(pCert);
        return TRUE;
    }
    return FALSE;
}

BOOL SetT120ActiveCert ( BOOL fSelfIssued,
                PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    BOOL bRet = FALSE;
    DWORD dwResult = -1;

    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("SetT120ActiveCert: g_pNmSysInfo NULL"));
        return FALSE;
    }

    //
    // Clear old cert out of transport
    //
    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if (!g_pNmSysInfo)
        return FALSE;

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetT120ActiveCert: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    if ( fSelfIssued )
    {
        g_hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_SYSTEM_STORE_CURRENT_USER,
                                        WSZNMSTORE );
        if ( g_hCertStore )
        {
            //
            // We only expect one cert in here, get it
            //

            g_pCertContext = CertFindCertificateInStore(
                                                  g_hCertStore,
                                                  X509_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);
            if ( g_pCertContext )
            {
                dwResult = -1;

                g_pNmSysInfo->ProcessSecurityData(
                                        TPRTCTRL_SETX509CREDENTIALS,
                                        (DWORD_PTR)g_pCertContext, 0,
                                        &dwResult);
                bRet = ( dwResult == 0 ); // BUGBUG TPRTSEC_NOERROR
            }
            else
            {
                WARNING_OUT(("SetT120ActiveCert: no cert in %s?", SZNMSTORE));
            }
        }
        else
        {
            WARNING_OUT(("SetT120ActiveCert: error opening %s store %x",
                SZNMSTORE, GetLastError()));
        }
    }
    else // !fSelfIssued
    {
        PCCERT_CONTEXT pCert = NULL;
        PCCERT_CONTEXT pCertMatch = CertCreateCertificateContext (
                                                            X509_ASN_ENCODING,
                                                            pbEncodedCert,
                                                            cbEncodedCert );

        if ( pCertMatch )
        {
            //
            // Open the user's store
            //

            if ( g_hCertStore = CertOpenSystemStore(0, "MY"))
            {

                while ( pCert = CertEnumCertificatesInStore(
                                        g_hCertStore, (PCERT_CONTEXT)pCert ))
                {
                    //
                    // Is this the same cert?
                    //

                    if ( ( pCert->pCertInfo->SerialNumber.cbData ==
                        pCertMatch->pCertInfo->SerialNumber.cbData ) &&

                        (!memcmp(pCert->pCertInfo->SerialNumber.pbData,
                            pCertMatch->pCertInfo->SerialNumber.pbData,
                                pCert->pCertInfo->SerialNumber.cbData)))
                    {
                        dwResult = -1;

                        g_pNmSysInfo->ProcessSecurityData(
                                            TPRTCTRL_SETX509CREDENTIALS,
                                            (DWORD_PTR)pCert, 0, &dwResult);

                        bRet = ( dwResult == 0 ); // BUGBUG TPRTSEC_NOERROR
                        break;
                    }
                }
                if ( pCert )
                {
                    // Found it.
                    g_pCertContext = pCert;
                }
                else
                {
                    WARNING_OUT(("SetT120ActiveCert: matching cert not found"));
                }
            }
            else
            {
                ERROR_OUT(("SetT120ActiveCert: can't open my store"));
            }
            CertFreeCertificateContext ( pCertMatch );
        }
    }
    return bRet;
}

static PCCERT_CONTEXT IGetDefaultCert ( BOOL fSystemOnly,
                                HCERTSTORE * phCertStore )
{
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;
    BOOL fNmDefaultCert = TRUE;
    LPBYTE pCertID;

    if ( fSystemOnly )
        fNmDefaultCert = FALSE;
    else
        fNmDefaultCert = !reCONF.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                        DEFAULT_SECURITY_AUTHENTICATION);

    hStore = CertOpenSystemStore(0, fNmDefaultCert ?
                                    SZNMSTORE : "MY");

    if ( NULL != hStore )
    {
        PCCERT_CONTEXT pCert = NULL;
        DWORD cbCertID;

        if (!fNmDefaultCert && ( cbCertID = reCONF.GetBinary (
                        REGVAL_CERT_ID, (void**)&pCertID )))
        {
            while ( pCert = CertEnumCertificatesInStore(
                                        hStore, (PCERT_CONTEXT)pCert ))
            {
                if ( cbCertID == pCert->pCertInfo->SerialNumber.cbData &&
                    !memcmp(pCertID, pCert->pCertInfo->SerialNumber.pbData,
                                    pCert->pCertInfo->SerialNumber.cbData))
                {
                    // pCert must now be freed via CertFreeCertificateContext
                    pCertContext = pCert;
                    break;
                }
            }
        }

        if ( NULL == pCertContext )
        {
            // Delete the (stale) reg entry... the cert might have
            // been deleted by other UI.

            if ( !fNmDefaultCert )
                reCONF.DeleteValue( REGVAL_CERT_ID );

            // Find any old client certificate - if fNmDefaultCert this will be
            // the only one in the store.
            pCertContext = CertFindCertificateInStore(hStore,
                                                      X509_ASN_ENCODING,
                                                      0,
                                                      CERT_FIND_ANY,
                                                      NULL,
                                                      NULL);
        }
    }
    else
    {
        WARNING_OUT(("User store %s not opened!", fNmDefaultCert ? SZNMSTORE : "MY"));
        *phCertStore = NULL;
    }

    // Caller to free cert context
    *phCertStore = hStore;
    return pCertContext;
}

BOOL GetDefaultSystemCert ( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert )
{
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCertContext = IGetDefaultCert(TRUE, &hStore);
    BOOL bRet = FALSE;

    if ( pCertContext )
    {
        DWORD cb;
        PBYTE pb;

        if ( pb = (PBYTE)CoTaskMemAlloc ( pCertContext->cbCertEncoded ))
        {
            memcpy ( pb, pCertContext->pbCertEncoded,
                    pCertContext->cbCertEncoded );
            *ppEncodedCert = pb;
            *pcbEncodedCert = pCertContext->cbCertEncoded;
            bRet = TRUE;
        }
        CertFreeCertificateContext(pCertContext);
    }
    if ( hStore )
    {
        if ( !CertCloseStore ( hStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("GetDefaultSystemCert: error closing store"));
        }
    }
    return bRet;;
}

BOOL InitT120SecurityFromRegistry(VOID)
{
    BOOL bRet = FALSE;

    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("InitT120SecurityFromRegistry: g_pNmSysInfo NULL"));
        return FALSE;
    }

    //
    // Expect this to be called only once on startup
    //
    ASSERT( NULL == g_pCertContext );
    ASSERT( NULL == g_hCertStore );

    g_pCertContext = IGetDefaultCert(FALSE, &g_hCertStore);

    if ( NULL == g_pCertContext )
    {
        WARNING_OUT(("No user certificate found!"));

        // BUGBUG
        // This means the transport will not be ready for secure
        // calls... we return false but what does the caller do?
        //
    }
    else
    {
        DWORD dwResult = -1;

        g_pNmSysInfo->ProcessSecurityData(TPRTCTRL_SETX509CREDENTIALS,
                                (DWORD_PTR)g_pCertContext, 0, &dwResult);
        if ( !dwResult )
            bRet = TRUE;
        else
        {
            ERROR_OUT(("InitT120SecurityFromRegistry: picked up bad cert"));
        }
    }

    return bRet;
}


HRESULT SetCertFromCertInfo ( PCERT_INFO pCertInfo )
{
    HRESULT hRet = S_FALSE;

    ASSERT( pCertInfo );

    if (!g_pNmSysInfo)
        return hRet;

    //
    // Clear old cert out of transport
    //
    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetCertFromCertInfo: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    if ( g_hCertStore = CertOpenSystemStore(0, "MY"))
    {
        //
        // Fix up relative pointers inside pCertInfo: Note that only
        // the pointers relevant to CertGetSubjectCertificateFromStore
        // are fixed up.
        //

        pCertInfo->SerialNumber.pbData += (DWORD_PTR)pCertInfo;
        pCertInfo->Issuer.pbData += (DWORD_PTR)pCertInfo;

        PCCERT_CONTEXT pCert = CertGetSubjectCertificateFromStore(
                                g_hCertStore, X509_ASN_ENCODING, pCertInfo );

        if ( pCert )
        {
            g_pNmSysInfo->ProcessSecurityData(
                                TPRTCTRL_SETX509CREDENTIALS,
                                (DWORD_PTR)pCert, 0, &dwResult);

            if ( 0 == dwResult ) // TPRTSEC_NO_ERROR
            {
                hRet = S_OK;
                g_pCertContext = pCert;
            }
        }
        else
        {
            WARNING_OUT(("SetCertFromCertInfo: matching cert not found"));
        }
    }
    else
    {
        ERROR_OUT(("SetCertFromCertInfo: can't open my store"));
    }
    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltonm.h ===
#if !defined( calltoNM_h )
#define	calltoNM_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"
#include	"calltoDisambiguator.h"


//--------------------------------------------------------------------------//
//	interface INMCallto.													//
//--------------------------------------------------------------------------//
class INMCallto
{
	protected:	//	protected constructors	--------------------------------//

		INMCallto(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~INMCallto(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		callto
		(
			const TCHAR * const	url,
			const bool			strict		= true,
			const bool			uiEnabled	= false,
			INmCall**			ppInternalCall = NULL
		) = 0;

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const = 0;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const = 0;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const = 0;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const = 0;

};	//	End of interface INMCallto.


//--------------------------------------------------------------------------//
//	class CNMCallto.														//
//--------------------------------------------------------------------------//
class CNMCallto:	public	INMCallto,
					private	CCalltoContext
{
	public:		//	public constructors	------------------------------------//

		CNMCallto(void);


	public:		//	public destructor	------------------------------------//

		~CNMCallto();


	public:		//	public methods	(INMCallto)	----------------------------//

		HRESULT
		callto
		(
			const TCHAR * const	url,
			const bool			strict		= true,
			const bool			uiEnabled	= false,
			INmCall**			ppInternalCall = NULL
		);

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const;


	private:	//	private methods	----------------------------------------//

		bool
		selfTest(void);


	public:		//	public members	----------------------------------------//

		HRESULT	m_selfTestResult;


	private:	//	private members	----------------------------------------//

		CCalltoResolver			m_resolver;
		CCalltoDisambiguator	m_disambiguator;

};	//	End of class CNMCallto.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoNM_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calv.h ===
// File calv.h
//
// Address List View class

#ifndef _CALV_H_
#define _CALV_H_

#include "confutil.h"
#include "richaddr.h"

VOID ClearRai(RAI ** ppRai);
RAI * DupRai(RAI * pRai);
RAI * CreateRai(LPCTSTR pszName, NM_ADDR_TYPE addrType, LPCTSTR pszAddr);
BOOL FEnabledNmAddr(DWORD dwAddrType);


///////////////////////////////
// Globals for FEnabledNmAddr
extern BOOL g_fGkEnabled;
extern BOOL g_fGatewayEnabled;
extern BOOL g_bGkPhoneNumberAddressing;


// Generic class for handling I/O to the list for CallDialog
class CALV : public RefCount
{
private:
	BOOL m_fAvailable;  // TRUE if data is available
	int  m_idsName;     // The address type name resource id
	HWND m_hwnd;        // The list view
	int  m_iIcon;       // small icon index
	const int * m_pIdMenu;  // Right click menu data
    bool m_fOwnerDataList;  

public:
	CALV(int ids, int iIcon=0, const int * pIdMenu=NULL, bool fOwnerData = false);
 	~CALV();

	// Return TRUE if there is data available
	BOOL FAvailable(void)          {return m_fAvailable;}
	VOID SetAvailable(BOOL fAvail) {m_fAvailable = fAvail;}
	VOID SetWindow(HWND hwnd)		{m_hwnd = hwnd;}
	HWND GetHwnd(void)             {return m_hwnd;}
	VOID ClearHwnd(void)           {m_hwnd = NULL;}
	BOOL FOwnerData(void)          {return m_fOwnerDataList;}

	int  GetSelection(void);
	VOID SetHeader(HWND hwnd, int ids);
	VOID DeleteItem(int iItem);

	// Get the standard name for the address list
	VOID GetName(LPTSTR psz, int cchMax)
	{
		FLoadString(m_idsName, psz, cchMax);
	}

	VOID DoMenu(POINT pt, const int * pIdMenu);	

	static VOID SetBusyCursor(BOOL fBusy);

	///////////////////////////////////////////////////////////////////////
	// VIRTUAL methods

	virtual int  GetIconId(LPCTSTR psz)           {return m_iIcon;}

	// Put the items into the list control
	virtual VOID ShowItems(HWND hwnd) = 0;  // This must be implemented

	// Destroy all of the data in the list control
	virtual VOID ClearItems(void);

	// Return the string data for the item/column
	virtual BOOL GetSzData(LPTSTR psz, int cchMax, int iItem, int iCol);

	// Return the name (from the first column)
	virtual BOOL GetSzName(LPTSTR psz, int cchMax);
	virtual BOOL GetSzName(LPTSTR psz, int cchMax, int iItem);

	// Return the "callTo" address (from the second column)
	virtual BOOL GetSzAddress(LPTSTR psz, int cchMax);
	virtual BOOL GetSzAddress(LPTSTR psz, int cchMax, int iItem);

	// Get the "Rich" address information
	virtual RAI * GetAddrInfo(void);
	virtual RAI * GetAddrInfo(NM_ADDR_TYPE addType);
	
	virtual LPARAM LParamFromItem(int iItem);

	// Handle a right click notification
	virtual VOID OnRClick(POINT pt);

	// Handle a command
	virtual VOID OnCommand(WPARAM wParam, LPARAM lParam);

	// Default commands
	virtual VOID CmdProperties(void);
	virtual VOID CmdSpeedDial(void);
	virtual VOID CmdRefresh(void);

    virtual void OnListCacheHint( int indexFrom, int indexTo ) 
    {
        ;     
    }

    virtual ULONG OnListFindItem( const TCHAR* szPartialMatchingString ) 
    {
        return TRUE;
    }

    virtual bool IsItemBold( int index ) 
    {
        return false;
    }

    virtual int OnListGetImageForItem( int iIndex ) 
    {
        return II_INVALIDINDEX;
    }
    virtual void OnListGetColumn1Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
    virtual void OnListGetColumn2Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
	virtual void OnListGetColumn3Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
};

#endif /* _CALV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calltoresolver.h ===
#if !defined( calltoResolver_h )
#define	calltoResolver_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"


//--------------------------------------------------------------------------//
//	interface IResolver.													//
//--------------------------------------------------------------------------//
class IResolver
{
	protected:	//	protected constructors	--------------------------------//

		IResolver(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IResolver(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		) = 0;

};	//	End of interface IResolver.


//--------------------------------------------------------------------------//
//	class CPhoneResolver.													//
//--------------------------------------------------------------------------//
class CPhoneResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CPhoneResolver.


//--------------------------------------------------------------------------//
//	class CEMailResolver.													//
//--------------------------------------------------------------------------//
class CEMailResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CEMailResolver.


//--------------------------------------------------------------------------//
//	class CIPResolver.														//
//--------------------------------------------------------------------------//
class CIPResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CIPResolver.


//--------------------------------------------------------------------------//
//	class CComputerResolver.												//
//--------------------------------------------------------------------------//
class CComputerResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CComputerResolver.


//--------------------------------------------------------------------------//
//	class CILSResolver.														//
//--------------------------------------------------------------------------//
class CILSResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CILSResolver.


//--------------------------------------------------------------------------//
//	class CUnrecognizedTypeResolver.										//
//--------------------------------------------------------------------------//
class CUnrecognizedTypeResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CUnrecognizedTypeResolver.


//--------------------------------------------------------------------------//
//	class CStringResolver.													//
//--------------------------------------------------------------------------//
class CStringResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CStringResolver.


//--------------------------------------------------------------------------//
//	class CCalltoResolver.													//
//--------------------------------------------------------------------------//
class CCalltoResolver
{
	public:		//	public constructors	------------------------------------//

		CCalltoResolver();


	public:		//	public destructor	------------------------------------//

		~CCalltoResolver();


	public:		//	public methods	----------------------------------------//

		HRESULT
		resolve
		(
			ICalltoContext * const		calltoContext,
			CCalltoProperties * const	calltoProperties,
			CCalltoCollection * const	resolvedCalltoCollection,
			const TCHAR *				url,
			const bool					strict
		);


	private:	//	private methods	----------------------------------------//

		bool
		addResolver
		(
			IResolver * const	resolver
		);

		const bool
		strictCheck
		(
			const TCHAR * const	url
		) const;


	private:	//	private members	----------------------------------------//

		CPhoneResolver				m_phoneResolver;
		CEMailResolver				m_emailResolver;
		CIPResolver					m_ipResolver;
		CComputerResolver			m_computerResolver;
		CILSResolver				m_ilsResolver;
		CUnrecognizedTypeResolver	m_unrecognizedTypeResolver;
		CStringResolver				m_stringResolver;

		IResolver *					m_resolvers[ 7 ];
		int							m_registeredResolvers;

};	//	End of class CCalltoResolver.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoResolver_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\chcondlg.cpp ===
#include "precomp.h"

/****************************************************************************
*
*    FILE:     ChConDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 6-26-96
*
*    CONTENTS: CChooseConfDlg object
*
****************************************************************************/

#include <ConfWnd.h>
#include "resource.h"
#include "ChConDlg.h"
#include "help_ids.h"
#include "ConfUtil.h"

// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsChooseConf[] = {
IDC_STATIC_CONFNAME,    IDH_MCU_CONF_MAIN,
IDC_CONFNAME_EDIT,      IDH_MCU_CONF_NAME,
IDC_CONFNAME_LISTVIEW,  IDH_MCU_CONF_LIST,
0, 0 // terminator
};

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   CChooseConfDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CChooseConfDlg::CChooseConfDlg(	HWND hwndParent,
								PWSTR* ppwszConferences):
	m_hwndParent		(hwndParent),
	m_ppwszConferences	(ppwszConferences),
	m_hwnd				(NULL)
{
	DebugEntry(CChooseConfDlg::CChooseConfDlg);

	DebugExitVOID(CChooseConfDlg::CChooseConfDlg);
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CChooseConfDlg::DoModal()
{
	DebugEntry(CChooseConfDlg::DoModal);

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_CHOOSECONF),
								m_hwndParent,
								CChooseConfDlg::ChooseConfDlgProc,
								(LPARAM) this);

	DebugExitINT_PTR(CChooseConfDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   ChooseConfDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CChooseConfDlg::ChooseConfDlgProc(HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CChooseConfDlg*) lParam)->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				// Create image list and associate it with the list view:
				HWND hwndLV = ::GetDlgItem(hDlg, IDC_CONFNAME_LISTVIEW);
				if (NULL != hwndLV)
				{
					BOOL fLoadFail = FALSE;
					HIMAGELIST hIML;
					hIML = ImageList_Create( 16, 16, ILC_MASK, 1, 0 );
	 				if (NULL == hIML)
					{
						fLoadFail = TRUE;
					}
					else
					{
						HICON hIcon = ::LoadIcon(	::GetInstanceHandle(),
													MAKEINTRESOURCE(IDI_NET));
						if ((NULL == hIcon) ||
							(-1 == ImageList_AddIcon(hIML, hIcon)))
						{
							fLoadFail = TRUE;
							break;
						}
						::DestroyIcon(hIcon);
					}

					if (FALSE == fLoadFail)
					{
						// Associate the image list with the list view
						ListView_SetImageList(hwndLV, hIML, LVSIL_SMALL);
					}
					
					// TODO: init conf list and name
					PWSTR* ppwszConfNames = ((CChooseConfDlg*) lParam)->m_ppwszConferences;
					ASSERT(ppwszConfNames);
					int i = 0;
					int iItems = 0;
					while (NULL != ppwszConfNames[i])
					{
						// skip empty strings
						if ( 0 != *ppwszConfNames[i] )
						{
							LV_ITEM lvI;        // List view item structure

							// Fill in the LV_ITEM structure
							// The mask specifies the the .pszText, .iImage, .lParam and .state
							// members of the LV_ITEM structure are valid.
							lvI.mask = LVIF_TEXT | LVIF_IMAGE | /* LVIF_PARAM | */ LVIF_STATE;
							 // put focus on first item
							lvI.state = (0 == iItems) ?
											(LVIS_FOCUSED | LVIS_SELECTED) : 0;
							lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
							lvI.iItem = iItems;
							lvI.iSubItem = 0;

							// The parent window is responsible for storing the text. The List view
							// window will send a LVN_GETDISPINFO when it needs the text to display/

                            LPTSTR  szName;
                            BSTR bstrName = ::SysAllocString(ppwszConfNames[i]);
                            if(bstrName)
                            {
							
                                if(SUCCEEDED(BSTR_to_LPTSTR(&szName,bstrName)))
                                {
            	
                                    lvI.pszText = szName;
                                    lvI.iImage = 0;
                                    // lvI.lParam = 0;

                                    if (-1 == ListView_InsertItem(hwndLV, &lvI))
                                    {
                                        ERROR_OUT(("Failed inserting item into list view"));
                                    }
                                    if (0 == iItems)
                                    {
                                        ::SetDlgItemText(hDlg, IDC_CONFNAME_EDIT, lvI.pszText);
                                    }
                                    iItems++;
                                    delete szName;
                                }

                                SysFreeString(bstrName);
                            }
                            
						}
						i++;
					}
				}
			}

			::SetFocus(::GetDlgItem(hDlg, IDC_CONFNAME_EDIT));
			::SendDlgItemMessage(hDlg, IDC_CONFNAME_EDIT, EM_SETSEL, 0, (LPARAM)-1);
			RefreshOk(hDlg);
			bMsgHandled = FALSE; // return FALSE because we set the focus
			break;
		}

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, rgHelpIdsChooseConf);
			break;

		case WM_HELP:
			DoHelp(lParam, rgHelpIdsChooseConf);
			break;

		default:
		{
			CChooseConfDlg* pccd = (CChooseConfDlg*) ::GetWindowLongPtr(	hDlg,
																		DWLP_USER);
			if (NULL != pccd)
			{
				bMsgHandled = pccd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CChooseConfDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					// BUGBUG: how long can a conf name be?
					TCHAR szName[MAX_PATH];
					if (0 != ::GetDlgItemText(	m_hwnd,
												IDC_CONFNAME_EDIT,
												szName,
												CCHMAX(szName)))
					{
						bRet = OnOk(szName);
					}
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_CONFNAME_EDIT:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						RefreshOk(m_hwnd);
					}
					break;
				}
			}
			break;
		}

		case WM_NOTIFY:
		{
			if (IDC_CONFNAME_LISTVIEW == wParam)
			{
				NM_LISTVIEW* pnmv = (NM_LISTVIEW*) lParam;
				ASSERT(pnmv);
				if ((LVN_ITEMCHANGED == pnmv->hdr.code) &&
					(LVIS_SELECTED & pnmv->uNewState))
				{
					TCHAR szName[MAX_PATH];
					if (GetConferenceName(pnmv->iItem, szName, CCHMAX(szName)))
					{
						::SetDlgItemText(m_hwnd, IDC_CONFNAME_EDIT, szName);
					}
				}
				else if (NM_DBLCLK == pnmv->hdr.code)
				{
					int idx = ListView_GetNextItem(
								::GetDlgItem(m_hwnd, IDC_CONFNAME_LISTVIEW),
								-1,
								LVNI_FOCUSED | LVNI_SELECTED);
					if (idx != -1)
					{
						TCHAR szName[MAX_PATH];
						if (GetConferenceName(idx, szName, CCHMAX(szName)))
						{
							OnOk(szName);
						}
					}
				}
			}
			break;
		}
			
		default:
			break;
	}

	return bRet;
}

BOOL CChooseConfDlg::GetConferenceName(int iItem, LPTSTR pszName, int cchName)
{
	LV_ITEM lvI;
	lvI.mask = LVIF_TEXT;
	lvI.iItem = iItem;
	lvI.iSubItem = 0;
	lvI.pszText = pszName;
	lvI.cchTextMax = cchName;
	return ListView_GetItem(
					::GetDlgItem(m_hwnd, IDC_CONFNAME_LISTVIEW),
					&lvI);
}

void CChooseConfDlg::RefreshOk(HWND hwnd)
{
	BOOL fEnable = 0 != ::GetWindowTextLength(
                          GetDlgItem(hwnd, IDC_CONFNAME_EDIT));
	::EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);
}

BOOL CChooseConfDlg::OnOk(LPTSTR pszName)
{
	DebugEntry(CChooseConfDlg::OnOk);

	BOOL bRet = TRUE;

	m_strConfName = pszName;

	::EndDialog(m_hwnd, IDOK);

	DebugExitBOOL(CChooseConfDlg::OnOk, bRet);

	return bRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\calv.cpp ===
// File: calv.cpp

#include "precomp.h"
#include "resource.h"

#include "calv.h"
#include "upropdlg.h"
#include "speedial.h"
#include "dirutil.h"
#include "confroom.h"

///////////////////////////////
// Globals for FEnabledNmAddr
BOOL g_fGkEnabled = FALSE;
BOOL g_fGatewayEnabled = FALSE;
BOOL g_bGkPhoneNumberAddressing = FALSE;


CALV::CALV(int ids, int iIcon, const int * pIdMenu /*=NULL*/, bool fOwnerData /*=false*/ ) :
		m_idsName(ids),
		m_hwnd(NULL),
		m_iIcon(iIcon),
		m_pIdMenu(pIdMenu),
		m_fAvailable(FALSE),
        m_fOwnerDataList( fOwnerData )
{
}

CALV::~CALV()
{
}

VOID CALV::ClearItems(void)
{
	if (NULL != m_hwnd)
	{
		ListView_DeleteAllItems(m_hwnd);
	}
}

VOID CALV::DeleteItem(int iItem)
{
	if (ListView_DeleteItem(GetHwnd(), iItem))
	{
		// Auto-select the next item
		ListView_SetItemState(GetHwnd(), iItem,
			LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
	}
}


int CALV::GetSelection(void)
{
	return ListView_GetNextItem(m_hwnd, -1, LVNI_ALL | LVNI_SELECTED);
}

VOID CALV::SetHeader(HWND hwnd, int ids)
{
	m_hwnd = hwnd;
	DlgCallSetHeader(hwnd, ids);
}


// Return the name (from the first column)
BOOL CALV::GetSzName(LPTSTR psz, int cchMax)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	return GetSzName(psz, cchMax, iItem);
}
BOOL CALV::GetSzName(LPTSTR psz, int cchMax, int iItem)
{
	return GetSzData(psz, cchMax, iItem, IDI_DLGCALL_NAME);
}

// Return the "callTo" address (from the second column)
BOOL CALV::GetSzAddress(LPTSTR psz, int cchMax)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	return GetSzAddress(psz, cchMax, iItem);
}
BOOL CALV::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	return GetSzData(psz, cchMax, iItem, IDI_DLGCALL_ADDRESS);
}


BOOL CALV::GetSzData(LPTSTR psz, int cchMax, int iItem, int iCol)
{
	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.iSubItem = iCol;
	lvi.mask = LVIF_TEXT;
	lvi.pszText = psz;
	lvi.cchTextMax = cchMax;

	return ListView_GetItem(m_hwnd, &lvi);
}


LPARAM CALV::LParamFromItem(int iItem)
{
	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.mask = LVIF_PARAM;
	return ListView_GetItem(GetHwnd(), &lvi) ? lvi.lParam : 0;
}


/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

    General interface to get the rich address info.
-------------------------------------------------------------------------*/
RAI * CALV::GetAddrInfo(void)
{
	return GetAddrInfo(NM_ADDR_ULS);
}

/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

    Utility routine, usually called by GetAddrInfo()
-------------------------------------------------------------------------*/
RAI * CALV::GetAddrInfo(NM_ADDR_TYPE addrType)
{
	TCHAR szName[CCHMAXSZ_NAME];
	if (!GetSzName(szName, CCHMAX(szName)))
		return NULL;

	TCHAR szAddress[CCHMAXSZ_ADDRESS];
	if (!GetSzAddress(szAddress, CCHMAX(szAddress)))
		return NULL;

	return CreateRai(szName, addrType, szAddress);
}



/*  S E T  B U S Y  C U R S O R  */
/*-------------------------------------------------------------------------
    %%Function: SetBusyCursor
    
-------------------------------------------------------------------------*/
VOID CALV::SetBusyCursor(BOOL fBusy)
{
	extern int g_cBusy; // in dlgcall.cpp
	g_cBusy += fBusy ? 1 : -1;
	ASSERT(g_cBusy >= 0);

	// Wiggle the mouse - force user to send a WM_SETCURSOR
	POINT pt;
	if (::GetCursorPos(&pt))
	{
		::SetCursorPos(pt.x, pt.y);
	}
}


/*  D O  M E N U  */
/*-------------------------------------------------------------------------
    %%Function: DoMenu
    
-------------------------------------------------------------------------*/
VOID CALV::DoMenu(POINT pt, const int * pIdMenu)
{
	HMENU hMenu = ::LoadMenu(::GetInstanceHandle(), MAKEINTRESOURCE(IDM_DLGCALL));
	if (NULL == hMenu)
		return;

	HMENU hMenuTrack = ::GetSubMenu(hMenu, 0);
	ASSERT(NULL != hMenu);

	{
		// Bold the "Call" menuitem:
		MENUITEMINFO iInfo;
		iInfo.cbSize = sizeof(iInfo);
		iInfo.fMask = MIIM_STATE;
		if(::GetMenuItemInfo(hMenuTrack, IDM_DLGCALL_CALL, FALSE, &iInfo))
		{
			iInfo.fState |= MFS_DEFAULT;
			::SetMenuItemInfo(hMenuTrack, IDM_DLGCALL_CALL, FALSE, &iInfo);
		}
	}

	// Is anything selected?
	int iSelItem = GetSelection();
	UINT uFlags = (-1 == iSelItem) ? MF_GRAYED : MF_ENABLED;

	::EnableMenuItem(hMenuTrack, IDM_DLGCALL_CALL,
        ((uFlags == MF_GRAYED) || !GetConfRoom()->IsNewCallAllowed())  ?
        MF_GRAYED : MF_ENABLED);
	::EnableMenuItem(hMenuTrack, IDM_DLGCALL_PROPERTIES, uFlags);

	if (NULL != pIdMenu)
	{
		// Additional menu items
		while (0 != *pIdMenu)
		{
			int id = *pIdMenu++;
			if (-1 == id)
			{
				InsertMenu(hMenuTrack, (DWORD) -1, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
			}
			else
			{
				TCHAR sz[CCHMAXSZ];
				if (FLoadString(id, sz, CCHMAX(sz)))
				{
					UINT uf = MF_BYPOSITION | MF_STRING | uFlags;
					if (id >= IDM_DLGCALL_ALWAYS_ENABLED)
					{
						uf = (uf & ~MF_GRAYED) | MF_ENABLED;
					}
					InsertMenu(hMenuTrack, (DWORD) -1, uf, id, sz);
				}
			}
		}
	}

	// Check to see if we have "special" coordinates that signify
	// that we entered here as a result of a keyboard click
	// instead of a mouse click - and if so, get some default coords
	if ((0xFFFF == pt.x) && (0xFFFF == pt.y))
	{
		RECT rc;
		if ((-1 == iSelItem) ||
			(FALSE == ListView_GetItemRect(m_hwnd, iSelItem, &rc, LVIR_ICON)))
		{
			::GetWindowRect(m_hwnd, &rc);
			pt.x = rc.left;
			pt.y = rc.top;
		}
		else
		{
			// Convert from client coords to screen coords
			::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);
			pt.x = rc.left + (RectWidth(rc) / 2);
			pt.y = rc.top + (RectHeight(rc) / 2);
		}
	}

	// Draw and track the "floating" popup 
	::TrackPopupMenu(hMenuTrack, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
	                 pt.x, pt.y, 0, ::GetParent(m_hwnd), NULL);

	::DestroyMenu(hMenu);
}

VOID CALV::OnRClick(POINT pt)
{
	DoMenu(pt, m_pIdMenu);
}


VOID CALV::OnCommand(WPARAM wParam, LPARAM lParam)
{
	WORD wCmd = LOWORD(wParam);
	
	switch (wCmd)
	{
	case IDM_DLGCALL_PROPERTIES:
		CmdProperties();
		break;
	case IDM_DLGCALL_SPEEDDIAL:
		CmdSpeedDial();
		break;
	default:
		break;
	}
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CALV::CmdProperties(void)
{
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddr[CCHMAXSZ_ADDRESS];
	if (!GetSzName(szName, CCHMAX(szName)) ||
		!GetSzAddress(szAddr, CCHMAX(szAddr)))
	{
		return;
	}

	UPROPDLGENTRY rgProp[1] = {
		{IDS_UPROP_ADDRESS, szAddr},
	};

    CUserPropertiesDlg dlgUserProp(m_hwnd, IDI_LARGE);
    dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), szName, NULL);
}


/*  C M D  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: CmdSpeedDial
    
-------------------------------------------------------------------------*/
VOID CALV::CmdSpeedDial(void)
{
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddr[CCHMAXSZ_ADDRESS];
	if (!GetSzName(szName, CCHMAX(szName)) ||
		!GetSzAddress(szAddr, CCHMAX(szAddr)))
	{
		return;
	}

	FCreateSpeedDial(szName, szAddr);
}




/*  C M D  R E F R E S H  */
/*-------------------------------------------------------------------------
    %%Function: CmdRefresh
    
-------------------------------------------------------------------------*/
VOID CALV::CmdRefresh(void)
{
	ClearItems();
	ShowItems(m_hwnd);
}


///////////////////////////////////////////////////////////////////////
// RAI routines


/*  C R E A T E  R A I  */
/*-------------------------------------------------------------------------
    %%Function: CreateRai
    
-------------------------------------------------------------------------*/
RAI * CreateRai(LPCTSTR pszName, NM_ADDR_TYPE addrType, LPCTSTR pszAddr)
{	
	RAI * pRai = new RAI;
	LPTSTR psz = PszAlloc(pszAddr);
	if ((NULL == pRai) || (NULL == psz))
	{
		delete pRai;
		delete psz;
		return NULL;
	}

	lstrcpyn(pRai->szName, pszName, CCHMAX(pRai->szName));
	pRai->cItems = 1;
	pRai->rgDwStr[0].psz = psz;
	pRai->rgDwStr[0].dw = addrType;
	return pRai;
}
	

/*  C L E A R  R A I  */
/*-------------------------------------------------------------------------
    %%Function: ClearRai
    
-------------------------------------------------------------------------*/
VOID ClearRai(RAI ** ppRai)
{
	if (NULL == *ppRai)
		return;

	for (int i = 0; i < (*ppRai)->cItems; i++)
	{
		delete (*ppRai)->rgDwStr[i].psz;
	}
	delete *ppRai;
	*ppRai = NULL;
}

/*  D U P  R A I  */
/*-------------------------------------------------------------------------
    %%Function: DupRai
    
-------------------------------------------------------------------------*/
RAI * DupRai(RAI * pRai)
{
	if (NULL == pRai)
		return NULL;

	RAI * pRaiRet = (RAI *) new BYTE[sizeof(RAI) + (pRai->cItems-1)*sizeof(DWSTR)];
	if (NULL != pRaiRet)
	{
		lstrcpy(pRaiRet->szName, pRai->szName);
		pRaiRet->cItems = pRai->cItems;

		for (int i = 0; i < pRai->cItems; i++)
		{
			pRaiRet->rgDwStr[i].dw = pRai->rgDwStr[i].dw;
			pRaiRet->rgDwStr[i].psz = PszAlloc(pRai->rgDwStr[i].psz);
		}
	}
	
	return pRaiRet;
}


/*  F  E N A B L E D  N M  A D D R  */
/*-------------------------------------------------------------------------
    %%Function: FEnabledNmAddr
-------------------------------------------------------------------------*/
BOOL FEnabledNmAddr(DWORD dwAddrType)
{
	switch (dwAddrType)
		{
	default:
	case NM_ADDR_ULS:
			// We only care about ULS addresses if 
			// we are not in gatekeeper mode...
		return !g_fGkEnabled;

	case NM_ADDR_UNKNOWN:
	case NM_ADDR_IP:
			// We always care aobut these addresses
		return TRUE;

	case NM_ADDR_H323_GATEWAY:
	{
		return !g_fGkEnabled && g_fGatewayEnabled;
	}

	case NM_ADDR_ALIAS_ID:
		return g_fGkEnabled && !g_bGkPhoneNumberAddressing;

	case NM_ADDR_ALIAS_E164:
		return g_fGkEnabled && g_bGkPhoneNumberAddressing;

	case NM_ADDR_PSTN: // old, never enabled
		return FALSE;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\certui.h ===
// File: certui.h

TCHAR * FormatCert ( PBYTE pbEncodedCert, DWORD cbEncodedCert );

//
// Brings up a certificate picker dialog and returns the encoded
// certificate chosen in a buffer. Buffer must be freed via
// FreeT120EncodedCert.
//

BOOL ChangeCertDlg ( HWND hwndParent, HINSTANCE hInstance,
	PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// Brings up system-dependent certificate details UI on the
// certificate specified by the context passed in.
//

VOID ViewCertDlg ( HWND hwndParent, PCCERT_CONTEXT pCert );
//
// Gets the currently active certificate from the transport and
// returns it in the buffer. Buffer must be freed via FreeT120EncodedCert.
//

BOOL GetT120ActiveCert( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// This function returns the user's default certificate as identified
// in the registry (or the first available if nothing is specified in
// the registry. The buffer returned must be freed via FreeT120EncodedCert.

BOOL GetDefaultSystemCert ( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// Sets the active certificate (NOT self issued) in the transprot using
// the supplied buffer as a template. If the cert passed in can't be
// found in the certificate store, then this function fails.
//

BOOL SetT120ActiveCert( BOOL fSelfIssued,
			PBYTE pEncodedCert, DWORD cbEncodedCert );

//
// Reads the registry for the user's initialization settings ( self-issued
// cert or system cert, and which system cert? ) and makes the corresponding
// certificate active in the transport. This function is called when the
// UI is initializing and if user startup settings need to be restored.
//

BOOL InitT120SecurityFromRegistry(VOID);

//
// Frees the passed in buffer.
//

VOID FreeT120EncodedCert( PBYTE pbEncodedCert );

//
// This function updates the registry (used for initialization) by
// saving the serial number of the supplied certificate to the registry.
// The passed in cert must be in the system store, not self-issued.
// 

BOOL SetT120CertInRegistry ( PBYTE pbEncodedCert, DWORD cbEncodedCert );

//
// This function makes the self-issued certificate in the application
// specific store active in the transport.
//

BOOL RefreshSelfIssuedCert (VOID);


//
// Utility function, returns number of certificates in system store
//

DWORD NumUserCerts(VOID);


//
// Takes pointer to CERT_INFO structure and sets cert in transport
//
HRESULT SetCertFromCertInfo ( PCERT_INFO pCertInfo );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\chcondlg.h ===
/****************************************************************************
*
*    FILE:     ChConDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 6-26-96
*
****************************************************************************/

#ifndef _CHCONDLG_H_
#define _CHCONDLG_H_

#include <cstring.hpp>

class CChooseConfDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	CSTRING		m_strConfName;
	PWSTR*		m_ppwszConferences;

	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL		GetConferenceName(int iItem, LPTSTR pszName, int cchName);
	static void	RefreshOk(HWND hwnd);



	// Handlers:
	BOOL		OnOk(LPTSTR pszName);

public:
	// Properties:

	LPCTSTR		GetName()		{ return (LPCTSTR) m_strConfName; };
	
	// Methods:
				CChooseConfDlg(HWND hwndParent, PWSTR* ppwszConferences);
	//			~CChooseConfDlg();
	INT_PTR		DoModal();

	static INT_PTR CALLBACK ChooseConfDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);
};

#endif // _CHCONDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cmdtb.h ===
// File: cmdtb.h

#ifndef _CMDTB_H_
#define _CMDTB_H_

enum {
	CMDTB_END      = 0, // end of list marker
	CMDTB_NEW_CALL = 1, // the first valid toolbar command index
	CMDTB_HANGUP,
	CMDTB_SHARE,
	CMDTB_WHITEBOARD,
	CMDTB_CHAT,
    CMDTB_AGENDA,
//	CMDTB_STOP,
	CMDTB_REFRESH,
	CMDTB_SPEEDDIAL,
	CMDTB_SWITCH,
	CMDTB_DELETE,
	CMDTB_DELETE_ALL,
	CMDTB_SEND_MAIL,
	CMDTB_PROPERTIES,
	CMDTB_BACK,
	CMDTB_FORWARD,
	CMDTB_HOME,
	CMDTB_MAX // count of toolbar items
};

    // CMDTB_STOP is not used anymore.... 
    // There is a bunch of old code that is not yanked from conf yet that needs this....
    // this just allows those files to compile...
#define CMDTB_STOP 666

#endif /* _CMDTB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cmd.h ===
// File: cmd.h
//
// General Commands

#ifndef _CMD_H_
#define _CMD_H_

class CConfRoom;

VOID CmdDoNotDisturb(HWND hwnd);
VOID CmdHostConference(HWND hwnd);
VOID CmdShowAbout(HWND hwnd);
VOID CmdShowReleaseNotes(void);
VOID CmdSpeedDial(void);
VOID CmdLaunchWebPage(WPARAM wCmd);

VOID CmdGoMail(void);
BOOL FEnableCmdGoMail(void);

BOOL FEnableCmdShare(void);

BOOL FEnableCmdBack(void);
BOOL FEnableCmdForward(void);
BOOL FEnableCmdHangup(void);

BOOL FEnableAudioWizard(void);

BOOL FDoNotDisturb(void);
VOID SetDoNotDisturb(BOOL fSet);

VOID CmdViewStatusBar(void);
BOOL CheckMenu_ViewStatusBar(HMENU hMenu);
VOID CmdViewNavBar(void);
BOOL CheckMenu_ViewNavBar(HMENU hMenu);
VOID CmdViewFldrBar(void);
BOOL CheckMenu_ViewFldrBar(HMENU hMenu);

VOID CmdViewAudioBar(void);
BOOL FEnableCmdViewAudioBar(void);
BOOL CheckMenu_ViewAudioBar(HMENU hMenu);

VOID CmdViewTitleBar(void);
BOOL CheckMenu_ViewTitleBar(HMENU hMenu);

VOID LaunchRedirWebPage(LPCTSTR pcszPage, bool bForceFormat=false);

#endif /* _CMD_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confatltrace.h ===
#ifndef __ConfAtltrace_h__
#define __ConfAtltrace_h__


#ifdef _DEBUG

    inline void DbgZPrintAtlTrace(LPTSTR pszFormat,...)
    {
	    va_list v1;
	    va_start(v1, pszFormat);
        DbgZPrintTrace( pszFormat, v1 );
	    va_end(v1);
    }

	
	inline void DbgZPrintAtlTrace2(DWORD category, UINT level, LPSTR lpszFormat, ...)
	{
		DWORD g_dwAtlTraceCategory = 0xffffffff;
		if (category & g_dwAtlTraceCategory && level <= ATL_TRACE_LEVEL)
		{
			va_list v1;
			va_start(v1, lpszFormat);
			DbgZPrintTrace( lpszFormat, v1 );
			va_end(v1);
		}
	}

    #define ATLTRACE DbgZPrintAtlTrace
	#define ATLTRACE2 DbgZPrintAtlTrace2

#endif // _DEBUG


#endif // __ConfAtltrace_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cmd.cpp ===
// File: cmd.cpp
//
// General UI-type commands

#include "precomp.h"

#include "cmd.h"

#include "ConfPolicies.h"
#include <version.h>

#include "conf.h"
#include "confwnd.h"
#include "dshowdlg.h"
#include "dlghost.h"
#include "confroom.h"

#include "taskbar.h"  // for RefreshTaskbarIcon()

#include "getip.h"

// static strings
static const TCHAR g_cszRelNotesFileName[] = TEXT("netmeet.htm");

static BOOL g_fDoNotDisturb = 0;


BOOL FLaunchPsz(LPCTSTR pszPath)
{
	HINSTANCE hInst = ::ShellExecute(::GetMainWindow(),
		NULL, pszPath, NULL, NULL, SW_SHOWNORMAL);

	if ((INT_PTR)hInst <= 32)
	{
		ERROR_OUT(("ShellExecute() failed, rc=%d", (int)((INT_PTR) hInst)));
		return FALSE;
	}

	return TRUE;
}


static VOID LaunchWebPage(LPCTSTR pcszPage)
{
	FLaunchPsz(pcszPage);
}


BOOL IsIEClientInstalled(LPCTSTR pszClient)
{
	RegEntry re(pszClient, HKEY_LOCAL_MACHINE);
	LPTSTR pszDefault = re.GetString(NULL);

	return !FEmptySz(pszDefault);
}

BOOL FEnableCmdGoNews(void)
{
	return IsIEClientInstalled(REGVAL_IE_CLIENTS_NEWS);
}



/*  F  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: FDoNotDisturb

-------------------------------------------------------------------------*/
BOOL FDoNotDisturb(void)
{
	return g_fDoNotDisturb;
}


/*  S E T  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: SetDoNotDisturb

-------------------------------------------------------------------------*/
VOID SetDoNotDisturb(BOOL fSet)
{
	g_fDoNotDisturb = fSet;
}

/*  C M D  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: CmdDoNotDisturb

-------------------------------------------------------------------------*/
VOID CmdDoNotDisturb(HWND hwnd)
{
	// Retrieve the "do not disturb" state:
	BOOL fCallsBlocked = FDoNotDisturb();

	CDontShowDlg dlgDNDWarn(IDS_DO_NOT_DISTURB_WARNING,
			REGVAL_DS_DO_NOT_DISTURB_WARNING, MB_OKCANCEL);

	if ((TRUE == fCallsBlocked) || (IDOK == dlgDNDWarn.DoModal(hwnd)))
	{
		// Toggle the DoNotDisturb state and refresh the UI
		SetDoNotDisturb(!fCallsBlocked);
		RefreshTaskbarIcon(::GetHiddenWindow());
	}
}


/*  C M D  H O S T  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: CmdHostConference

-------------------------------------------------------------------------*/
VOID CmdHostConference(HWND hwnd)
{

	CDlgHost dlgHost;
	if (IDOK != dlgHost.DoModal(hwnd))
		return;
				
	HRESULT hr = ::GetConfRoom()->HostConference(dlgHost.PszName(), dlgHost.PszPassword(), dlgHost.IsSecure(),
        dlgHost.AttendeePermissions(), dlgHost.MaxParticipants());
	if (FAILED(hr))
	{
		DisplayErrMsg(IDS_ERRMSG_HOST);
	}
}

void FormatURL(LPTSTR szURL)
{
	LPTSTR pszFormat = new TCHAR[lstrlen(szURL)+1];
	if (NULL != pszFormat)
	{
		lstrcpy(pszFormat, szURL);

		wsprintf(szURL, pszFormat,
				::GetVersionInfo()->dwMajorVersion,
				::GetVersionInfo()->dwMinorVersion,
				::GetSystemDefaultLCID(),
				::GetUserDefaultLCID());

		delete[] pszFormat;
	}
}

/*  L A U N C H  R E D I R  W E B  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: LaunchRedirWebPage

	Launch a redirector web page.  Used by CmdLaunchWebHelp.

	Note: pcszPage can be a resource ID that is associated with a
	format string that contains the URL and fields for 4 local ID's.

-------------------------------------------------------------------------*/
VOID LaunchRedirWebPage(LPCTSTR pcszPage, bool bForceFormat)
{
	TCHAR szWebPageFormat[1024]; // BUGBUG: MAX_URL??

	ASSERT(NULL != pcszPage);

	if (((UINT_PTR)pcszPage >> 16) == 0)
	{
		// pcszPage is a resource ID
		if (0 == ::LoadString(::GetInstanceHandle(), (UINT)((UINT_PTR) pcszPage),
				szWebPageFormat, CCHMAX(szWebPageFormat)))
		{
			ERROR_OUT(("LaunchRedirWebPage: Unable to find IDS=%08X", (UINT)((UINT_PTR)pcszPage)));
			return;
		}

		pcszPage = szWebPageFormat;
		bForceFormat = true;
	}

	if (bForceFormat)
	{
		lstrcpy(szWebPageFormat, pcszPage);
		FormatURL(szWebPageFormat);

		ASSERT(lstrlen(szWebPageFormat) < CCHMAX(szWebPageFormat));
		pcszPage = szWebPageFormat;
	}

	LaunchWebPage(pcszPage);
}


/*  C M D  L A U N C H  W E B  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: CmdLaunchWebPage

    Display a web page, based on the command id.
-------------------------------------------------------------------------*/
VOID CmdLaunchWebPage(WPARAM wCmd)
{
	LPTSTR psz;

	switch (wCmd)
		{
	default:
		{
			ERROR_OUT(("CmdLaunchWebHelp: Unknown command id=%08X", wCmd));
			// fall through
		}
	case ID_HELP_WEB_FREE:
	case ID_HELP_WEB_FAQ:
	case ID_HELP_WEB_FEEDBACK:
	case ID_HELP_WEB_MSHOME:
	{
		// NOTE: this requires that the format strings are in the same order
		// as the menu command ID's
		LaunchRedirWebPage((LPCTSTR) wCmd - (ID_HELP_WEB_FREE - IDS_WEB_PAGE_FORMAT_FREE));
		break;
	}
	case ID_HELP_WEB_SUPPORT:
    {
        TCHAR sz[ MAX_PATH ];
        bool bForcePrintf = ConfPolicies::GetIntranetSupportURL(sz, CCHMAX(sz));
        LaunchRedirWebPage( sz, bForcePrintf );

        break;
    }
	case ID_HELP_WEB_NEWS:
	{
		RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
		psz = re.GetString(REGVAL_HOME_PAGE);
		if (FEmptySz(psz))
		{
			psz = (LPTSTR) IDS_WEB_PAGE_FORMAT_NEWS;
		}
		LaunchRedirWebPage(psz);
		break;
	}
		
	case IDM_VIDEO_GETACAMERA:
	{
		LaunchRedirWebPage(MAKEINTRESOURCE(IDS_WEB_PAGE_FORMAT_GETCAMERA));
		break;
	}

		} /* switch (wCommand) */
}


/*  C M D  S H O W  R E L E A S E  N O T E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowReleaseNotes

-------------------------------------------------------------------------*/
VOID CmdShowReleaseNotes(void)
{
	if (!FLaunchPsz(g_cszRelNotesFileName))
	{
		::PostConfMsgBox(IDS_RELEASE_NOTES_MISSING);
	}
}


/*  A B O U T  B O X  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: AboutBoxDlgProc

-------------------------------------------------------------------------*/
INT_PTR CALLBACK AboutBoxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_INITDIALOG:
	{
		TCHAR sz[700]; // really large for copyright message
		TCHAR *szIPList[] = {sz, sz+20, sz+40, sz+80};
		TCHAR *szIPDisplay = sz+200;
		int nListSize = sizeof(szIPList)/sizeof(TCHAR*);
		int nCount, nIndex;

		if (0 != ::GetDlgItemText(hDlg, IDC_ABOUT_VERSION_STATIC, sz, CCHMAX(sz)))
		{
			// Retrieved the format buffer from the dialog:
			TCHAR szVisibleText[MAX_PATH];
			wsprintf(szVisibleText, sz, VER_PRODUCTVERSION_STR);
			// Replace the text with text that contains the version number:
			::SetDlgItemText(hDlg, IDC_ABOUT_VERSION_STATIC, szVisibleText);
		}

		// The about box copyright is > 255 characters.
		if (FLoadString(IDS_ABOUT_COPYRIGHT, sz, CCHMAX(sz)))
		{
			::SetDlgItemText(hDlg, IDC_ABOUT_COPYRIGHT, sz);
		}


		// go fetch our IP address and display it to the user
		// we can only display up to 4
		nCount = GetIPAddresses(szIPList, nListSize);
		if (nCount >= 1)
		{
			lstrcpy(szIPDisplay, szIPList[0]);
			for (nIndex = 1; nIndex < nCount; nIndex++)
			{
				lstrcat(szIPDisplay, ", ");
				lstrcat(szIPDisplay, szIPList[nIndex]);
			}
			::SetDlgItemText(hDlg, IDC_IP_ADDRESS, szIPDisplay);
		}
		else
		{
			// on error, don't show anything about IP addresses
			ShowWindow(GetDlgItem(hDlg, IDC_IP_ADDRESS), SW_HIDE);
			ShowWindow(GetDlgItem(hDlg, IDC_IPADDR_STATIC), SW_HIDE);
		}

		break;
	}

	case WM_COMMAND:
	{
		::EndDialog(hDlg, LOWORD(wParam));
		break;
	}

	default:
	{
		return FALSE;
	}
		} /* switch (uMsg) */

	return TRUE;
}


/*  C M D  S H O W  A B O U T  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowAbout

-------------------------------------------------------------------------*/
VOID CmdShowAbout(HWND hwnd)
{
	::DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_ABOUT_BOX),
				hwnd, AboutBoxDlgProc);
}



/*  F  E N A B L E  A U D I O  W I Z A R D  */
/*-------------------------------------------------------------------------
    %%Function: FEnableAudioWizard

-------------------------------------------------------------------------*/
BOOL FEnableAudioWizard(void)
{
	return FIsAudioAllowed() && (NULL == GetActiveConference());
}


///////////////////////////////////////////////////////////////////////////
// Application Sharing commands

BOOL FEnableCmdShare(void)
{
	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return FALSE;
	return pcr->FCanShare();
}



///////////////////////////////////////////////////////////////////////////

BOOL FEnableCmdHangup(void)
{
	return ::FIsConferenceActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confapi.h ===
/*
 *	ConfApi.h
 *
 *	CConfRoom Application Program Interface
 */

#ifndef _CONFAPI_H_
#define _CONFAPI_H_

VOID SetLoggedOn(BOOL fLoggedOn);

#endif /* _CONFAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\conf.h ===
// File: conf.h

#ifndef _CONF_H_
#define _CONF_H_

#include "ConfUtil.h"
#include "callto.h"

class CCallLog;

extern HWND g_hwndDropDown;
extern BOOL g_fHiColor;
extern HFONT g_hfontDlg;

extern CPing*	g_pPing;
extern OSVERSIONINFO g_osvi;
extern BOOL g_fNTDisplayDriverEnabled;
extern CCallLog* g_pInCallLog;
extern ULONG g_uMediaCaps;
extern INmSysInfo2 * g_pNmSysInfo;  // Interface to SysInfo
extern DWORD g_dwSysInfoNotifyCookie;
extern INmManager2 * g_pInternalNmManager;  // Interface to InternalINmManager
extern CCallto *	g_pCCallto;

HRESULT InitConfExe(BOOL fShowUI = TRUE);
inline LPOSVERSIONINFO GetVersionInfo()	{ return &g_osvi; }
inline BOOL IsWindowsNT() { return (VER_PLATFORM_WIN32_NT == g_osvi.dwPlatformId); }

inline CCallLog* GetIncomingCallLog() { return g_pInCallLog; }

BOOL ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam);
VOID CleanUp(BOOL fLogoffWindows=FALSE);
VOID CmdShutdown(void);
VOID HandleConfSettingsChange(DWORD dwSettings);
VOID SignalShutdownStarting(void);

#define WM_DIALMON_FIRST					(WM_USER+100)
#define WM_WINSOCK_ACTIVITY					(WM_DIALMON_FIRST+0)
#define WM_APP_EXITING						(WM_DIALMON_FIRST+3)
VOID SendDialmonMessage(UINT uMsg);
BOOL CheckRemoteControlService();

void LaunchApp(LPCTSTR lpCmdLine);

#endif // _CONF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confapi.cpp ===
/****************************************************************************
*
*	 FILE:	   ConfApi.cpp
*
*	 CONTENTS: CConfRoom Application Programming Interface
*
****************************************************************************/

#include "precomp.h"
#include "global.h"
#include "Conf.h"
#include "confapi.h"
#include "nameres.h"
#include "nmmanager.h"
#include "ConfUtil.h"


// from conf.cpp
extern INmSysInfo2 * g_pNmSysInfo;

BOOL g_fLoggedOn = FALSE;

/*  S E T  L O G G E D  O N  */
/*-------------------------------------------------------------------------
    %%Function: SetLoggedOn
    
-------------------------------------------------------------------------*/
VOID SetLoggedOn(BOOL fLoggedOn)
{
	g_fLoggedOn = fLoggedOn;

	if (NULL == g_pNmSysInfo)
		return;

	g_pNmSysInfo->SetOption(NM_SYSOPT_LOGGED_ON, fLoggedOn);
}


DWORD MapNmAddrTypeToNameType(NM_ADDR_TYPE addrType)
{
	switch (addrType)
		{
	case NM_ADDR_IP:
		return NAMETYPE_IP;

	case NM_ADDR_PSTN:
		return NAMETYPE_PSTN;

	case NM_ADDR_ULS:
		return NAMETYPE_ULS;

	case NM_ADDR_H323_GATEWAY:
		return NAMETYPE_H323GTWY;

	case NM_ADDR_ALIAS_ID:
		return NAMETYPE_ALIAS_ID;

	case NM_ADDR_ALIAS_E164:
		return NAMETYPE_ALIAS_E164;

	case NM_ADDR_UNKNOWN:
	default:
		return NAMETYPE_UNKNOWN;
		}
}

// Return TRUE if NetMeeting should display the incoming file transfer dialog
BOOL FFtDialog(void)
{
	return TRUE;
}

BOOL FUiVisible(void)
{
	HWND hwnd = ::GetMainWindow();
	if (NULL == hwnd)
		return FALSE;

	return IsWindowVisible(hwnd); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\conf.cpp ===
// File: conf.cpp

#include "precomp.h"
#include <mixer.h>
#include <EndSesn.h>
#include "NmLdap.h"

#include "conf.h"
#include "confwnd.h"
#include "taskbar.h"

#include <CR.h>
#include <tsecctrl.h>
#include "iapplet.h"
#include "inodecnt.h"
#include "ConfCpl.h"
#include "confroom.h"
#include "rtoolbar.h"
#include "GenWindow.h"
#include "cmd.h"
#include "confman.h"
#include "splash.h"
#include "calllog.h"
#include "call.h"      // for FreeCallList

#include "popupmsg.h"
#include "floatbar.h"

#include "confman.h"
#include <version.h>
#include <nmremote.h>

#include "wininet.h"
#include "setupapi.h"
#include "autoconf.h"

#include "ConfNmSysInfoNotify.h"
#include "ConfPolicies.h"

#include "DShowDlg.h"
#include "Callto.h"
#include "passdlg.h"

// SDK includes
#include "NetMeeting.h"
#include "NmApp.h"
#include "NmManager.h"		
#include "NmCall.h"			
#include "NmConference.h"
#include "SDKWindow.h"
#include "confapi.h"
#include "FtHook.h"
#include "t120app.h"
#include "certui.h"
#include "dlgcall2.h"
#include "ConfMsgFilter.h"

	
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NetMeeting, CNetMeetingObj)
	OBJECT_ENTRY(CLSID_NmManager, CNmManagerObj)
	OBJECT_ENTRY(CLSID_NmApplet, CNmAppletObj)
END_OBJECT_MAP()


extern VOID SaveDefaultCodecSettings(UINT uBandWidth);
extern int WabReadMe(void);

HRESULT InitSDK();
void CleanupSDK();

///////////////////////////////////////////////////////////////////////////
// Global Variables

LPTSTR g_lpCmdLine = NULL;
CCallLog    * g_pInCallLog     = NULL;  // The incoming call log object
CSimpleArray<ITranslateAccelerator*> *g_pDialogList = NULL;  // Global list of modeless dialogs
CRITICAL_SECTION dialogListCriticalSection; // This is to avoid multiple access to the dialogList
INmSysInfo2 * g_pNmSysInfo     = NULL;  // Interface to SysInfo
INmManager2* g_pInternalNmManager = NULL;
DWORD		  g_dwSysInfoNotifyCookie = 0;
bool		g_bNeedCleanup = false;

bool   g_bEmbedding = FALSE;   // Started with the embedding flag
UINT   g_uEndSessionMsg;       // The "NetMeeting EndSession" message
BOOL   g_fHiColor = FALSE;     // TRUE if we have more than 256 colors
HWND   g_hwndDropDown = NULL;  //
BOOL   g_WSAStarted = FALSE;   // WSAStartup
CCallto *	g_pCCallto	= NULL;

// The flag to indicate if the NetMeeting's NT display driver is enabled.
BOOL   g_fNTDisplayDriverEnabled = FALSE;

OSVERSIONINFO g_osvi;  // The os version info structure global

///////////////////////////////////////////////////////////////////////////
// IPC-related globals:
HANDLE g_hInitialized  = NULL;
HANDLE g_hShutdown  = NULL;


///////////////////////////////////////////////////////////////////////////
// Hidden window-related globals:
CHiddenWindow * g_pHiddenWnd = NULL;
HWND  g_hwndESHidden   = NULL;
const TCHAR g_cszESHiddenWndClassName[] = _TEXT("ConfESHiddenWindow");
LRESULT CALLBACK ESHiddenWndProc(HWND, UINT, WPARAM, LPARAM);

///////////////////////////////////////////////////////////////////////////
// Remote control service related declarations

INT_PTR CALLBACK ServiceRunningDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
VOID RestartRemoteControlService();
const int MAX_REMOTE_TRIES = 30; // number of seconds to wait for service to shut down
const int SERVICE_IN_CALL = 1001;

///////////////////////////////////////////////////////////////////////////
// Media Caps

ULONG g_uMediaCaps = 0;

BOOL FIsAudioAllowed()
{
	return g_uMediaCaps & CAPFLAGS_AUDIO;
}

BOOL FIsReceiveVideoAllowed()
{
	return g_uMediaCaps & CAPFLAG_RECV_VIDEO;
}

BOOL FIsSendVideoAllowed()
{
	return g_uMediaCaps & CAPFLAG_SEND_VIDEO;
}

BOOL FIsAVCapable()
{
	return (FIsAudioAllowed() || FIsReceiveVideoAllowed() || FIsSendVideoAllowed());
}


extern BOOL SetProcessDefaultLayout(int iLayout);
typedef BOOL (WINAPI* PFNSPDL)(int);
#define LAYOUT_LTR 0
int g_iLayout = LAYOUT_LTR;
DWORD g_wsLayout = 0;

VOID CheckLanguageLayout(void)
{
	TCHAR szLayout[CCHMAXUINT];
	if (!FLoadString(IDS_DEFAULT_LAYOUT, szLayout, CCHMAX(szLayout)))
		return;

	g_iLayout = (int) DecimalStringToUINT(szLayout);
	if (0 == g_iLayout)
	{
#ifdef DEBUG
		RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		g_iLayout = re.GetNumber(REGVAL_DBG_RTL, DEFAULT_DBG_RTL);
		if (0 == g_iLayout)
#endif /* DEBUG */
			return;
	}

	HMODULE hmod = GetModuleHandle(TEXT("USER32"));
	if (NULL == hmod)
		return;

	PFNSPDL pfn = (PFNSPDL) GetProcAddress(hmod, "SetProcessDefaultLayout");
	if (NULL == pfn)
		return;

	BOOL fResult = pfn(g_iLayout);
	if (fResult)
	{
		g_wsLayout = WS_EX_NOINHERIT_LAYOUT;
	}
	else
	{
		ERROR_OUT(("Problem with SetProcessDefaultLayout"));
	}
}





///////////////////////////////////////////////////////////////////////////
// External Function Prototypes

// from dbgmenu.cpp
BOOL InitDebugMemoryOptions(void);


///////////////////////////////////////////////////////////////////////////
// Local Function Prototypes

BOOL HandleDialogMessage(LPMSG pMsg);



// This is for command line parsing...
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


// This launches a rundll32.exe which loads msconf.dll which will then wait for 
// us to terminate and make sure that the mnmdd display driver was properly deactivated.
BOOL CreateWatcherProcess()
{
    BOOL bRet = FALSE;
    HANDLE hProcess;

    // open a handle to ourselves that the watcher process can inherit
    hProcess = OpenProcess(SYNCHRONIZE,
                           TRUE,
                           GetCurrentProcessId());
    if (hProcess)
    {
        TCHAR szWindir[MAX_PATH];

        if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
        {
            TCHAR szCmdLine[MAX_PATH * 2];
            PROCESS_INFORMATION pi = {0};
            STARTUPINFO si = {0};

            si.cb = sizeof(si);
            
            wsprintf(szCmdLine, "\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver %ld", szWindir, HandleToLong(hProcess));

            if (CreateProcess(NULL,
                              szCmdLine,
                              NULL,
                              NULL,
                              TRUE, // we want the watcher to inherit hProcess, so we must set bInheritHandles = TRUE
                              0,
                              NULL,
                              NULL,
                              &si,
                              &pi))
            {
                bRet = TRUE;

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }

        CloseHandle(hProcess);
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////

int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPTSTR lpCmdLine, int nCmdShow)
{
	// if there is another instance of NetMeeting shutting down
	// get out of here.  Ideally we should display a message and/or wait for shutdown.
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:ShuttingDown"));
	if (NULL != hEvent)
	{
		DWORD dwResult = WaitForSingleObject(hEvent, INFINITE);
		CloseHandle(hEvent);
		if (WAIT_TIMEOUT == dwResult)
		{
			return TRUE;
		}
	}

	// Init debug output as soon as possible
	ASSERT(::InitDebugMemoryOptions());
	ASSERT(::InitDebugModule(TEXT("CONF")));
	ASSERT(::InitDebugZones());

	g_lpCmdLine = lpCmdLine;

	int nRet = TRUE;


    BOOL fRestartService = FALSE;

    HRESULT hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

	if( SUCCEEDED( hr ) )
	{
			// Init CComModule
		_Module.Init(ObjectMap, hInstance, &LIBID_NetMeetingLib);
		_Module.m_dwThreadID = GetCurrentThreadId();
		_Module.m_hResourceModule = hInstance;
	
		TCHAR szCommandLineSeps[] = _T("-/");

			// Check to see if this is a reg/unreg request or background...
		BOOL fShowUI = TRUE;
		BOOL bRun = TRUE;
		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szCommandLineSeps);
		while (lpszToken != NULL)
		{
			if (lstrcmpi(lpszToken, _T("Embedding"))==0)
			{
				TRACE_OUT(("We are started with the -Embedding flag"));
				g_bEmbedding = TRUE;
			}
			if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				_Module.UpdateRegistryFromResource(IDR_NETMEETING, FALSE);
				nRet = _Module.UnregisterServer(TRUE);

					// These will fail without complaints
				DeleteShortcut(CSIDL_DESKTOP, g_szEmpty);
				DeleteShortcut(CSIDL_APPDATA, QUICK_LAUNCH_SUBDIR);

				bRun = FALSE;
				break;
			}
			if (lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				_Module.UpdateRegistryFromResource(IDR_NETMEETING, TRUE);
				nRet = _Module.RegisterServer(TRUE);
				bRun = FALSE;
				break;
			}

			if (lstrcmpi(lpszToken, g_cszBackgroundSwitch)==0)
			{
				fShowUI = FALSE;
			}

			lpszToken = FindOneOf(lpszToken, szCommandLineSeps);
		}

		if (bRun)
		{
			// Setup and RDS rely on the following event to determine whether NetMeeting is Running
			// this event creation should not be removed and the name should not be changed
			g_hInitialized = ::CreateEvent(NULL, TRUE, FALSE, _TEXT("CONF:Init"));
			if (NULL != g_hInitialized)
			{
				if (ERROR_ALREADY_EXISTS == ::GetLastError())
				{
					// CreateEvent returned a valid handle, but we don't want initialization to
					// succeed if we are running another copy of this exe, so we cleanup and exit
					WARNING_OUT(("Detected another conf.exe - sending a message"));
					IInternalConfExe *	pInternalConfExe;
					
					hr = CoCreateInstance( CLSID_NmManager, NULL, CLSCTX_ALL,
						IID_IInternalConfExe, (LPVOID *) &pInternalConfExe );
					if (SUCCEEDED(hr))
					{
						if(FAILED(pInternalConfExe->Launch()))
						{
							// If we are in INIT_CONTROL mode, then we can't launch NetMeeting or applets
							::ConfMsgBox(NULL, (LPCTSTR) IDS_CANT_START_NM_BECAUSE_SDK_APP_OWNS_NM);

						}
						pInternalConfExe->Release();
					}
				}
				else if(SUCCEEDED(InitHtmlHelpMarshaler(_Module.GetModuleInstance())))
				{
					// We create a seperate watcher process that will cleanup the mnmdd display driver
					// if we terminate unexpectedly. This is necessary since if we do not disable the
					// mirrored driver, all DX games will fail to run
					CreateWatcherProcess();

					//initialize ATL control contaiment code
					AtlAxWinInit();

					hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);

					if( SUCCEEDED( hr ) )
					{
						BOOL fContinue = TRUE;

						if( FAILED(InitSDK()) )
						{
							fContinue = FALSE;
						}

						if(!g_bEmbedding)
						{
							// Before doing anything else, take care of the remote control service.
							fContinue = CheckRemoteControlService();
							fRestartService = fContinue;

							if(fContinue)
							{
								fContinue = SUCCEEDED(InitConfExe(fShowUI));
							}
						}

						if(fContinue)
						{
							TRACE_OUT(("Entering event loop..."));

							MSG msg;
							while (::GetMessage(&msg, NULL, 0, 0))
							{
								BOOL bHandled = FALSE;

								if(g_pPing)  // This is TRUE if InitConfExe has been called...
								{
									bHandled = ::HandleDialogMessage(&msg);
								}
								if(!bHandled)
								{
									::TranslateMessage(&msg);
									::DispatchMessage(&msg);
								}

							}
							TRACE_OUT(("Conf received WM_QUIT"));
						}

						if(g_bNeedCleanup)
						{
							CleanUp();
						}

						CleanupSDK();

						_Module.RevokeClassObjects();
					}
				}
				::CloseHandle(g_hInitialized);
				if (g_hShutdown)
				{
					SetEvent(g_hShutdown);
					::CloseHandle(g_hShutdown);
				}
			}
			else
			{
				ERROR_OUT(("CreateEvent (init) failed!"));
				hr = E_FAIL;
			}

			_Module.Term();
		}
		::CoUninitialize();

        //
        // Restart the remote control service if we need to.
        //
        if (fRestartService)
            RestartRemoteControlService();
	}

#ifdef DEBUG
	::ExitDebugModule();
	TRACE_OUT(("returned from ExitDebugModule"));
    ::DeinitDebugZones();
	TRACE_OUT(("returned from DeinitDebugZones"));
#endif //DEBUG

	return nRet;
}


VOID CheckMachineNameForExtendedChars ( VOID )
{

	DBGENTRY(CheckMachineNameForExtendedChars);

		// First we have to get the computer name
	TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD cchMachineName = CCHMAX(szMachineName);

		// Next we check to see if the computer nami is invalid
	if (GetComputerName(szMachineName, &cchMachineName))
	{
		for ( LPTSTR p = szMachineName; *p != _T('\0'); p++ )
		{
			if ( (WORD)(*p) & 0xFF80 )
			{
					// The machine name is invalid because it contains an invalid character
				CDontShowDlg MachineNameWarningDlg(	IDS_MACHINENAMEWARNING,
													REGVAL_DS_MACHINE_NAME_WARNING,
													DSD_ALWAYSONTOP | MB_SETFOREGROUND | MB_OK
												  );

				MachineNameWarningDlg.DoModal(NULL);

				goto end;
			}
		}
	}
	else
	{
		ERROR_OUT(("GetComputerName() failed, err=%lu", GetLastError()));
		*szMachineName = TEXT('\0');
	}

end:

	DBGEXIT(CheckMachineNameForExtendedChars);
}


VOID HandleConfSettingsChange(DWORD dwSettings)
{
	DebugEntry(HandleConfSettingsChange);
	

	TRACE_OUT(("HandleConfSettingsChange, dwSettings=0x%x", dwSettings));

	// Tell the user if she changed something that won't take
	// effect right away

	if (CSETTING_L_REQUIRESRESTARTMASK & dwSettings)
	{
	    ::ConfMsgBox(NULL, (LPCTSTR) IDS_NEED_RESTART);
	}
	if (CSETTING_L_REQUIRESNEXTCALLMASK & dwSettings)
	{
		if (::FIsConferenceActive())
		{
			::ConfMsgBox(NULL, (LPCTSTR) IDS_NEED_NEXTCALL);
		}
	}
	if (CSETTING_L_BANDWIDTH & dwSettings)
	{
		if (NULL != g_pNmSysInfo)
		{
			int nMegahertz=300, nProcFamily=6;
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			UINT uSysPolBandwidth;
			UINT uBandwidth;
			
			uBandwidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);


#ifdef	_M_IX86
			GetNormalizedCPUSpeed(&nMegahertz, &nProcFamily);
			TRACE_OUT(("Normalized Processor Speed = %d, Processor type = %d\n", nMegahertz, nProcFamily));
#endif

			// convert bandwidth ID (1-4) to bits/sec
			uBandwidth = GetBandwidthBits(uBandwidth, nMegahertz);

			// the existance of a QOS - maximum bandwidth key implies that
			// the user's bandwidth is being over-rided (ONLY if his setting is LAN)

			uSysPolBandwidth = SysPol::GetMaximumBandwidth();

			if ((uSysPolBandwidth > 0) && (uBandwidth >= BW_SLOWLAN_BITS))
			{
				uBandwidth = max(uSysPolBandwidth, BW_144KBS_BITS);
			}

			g_pNmSysInfo->SetOption(NM_SYSOPT_BANDWIDTH, uBandwidth);
		}
	}

	if (CSETTING_L_SHOWTASKBAR & dwSettings)
	{
		// This will remove one if one is already there:
		::RemoveTaskbarIcon(::GetHiddenWindow());
		// This will add the icon if the registry switch is on:
		::AddTaskbarIcon(::GetHiddenWindow());
	}

	if (CSETTING_L_AUDIODEVICE & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnAudioDeviceChanged();
		}
	}

	if (CSETTING_L_AGC & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnAGC_Changed();
		}
	}

	if ((CSETTING_L_AUTOMIC|CSETTING_L_MICSENSITIVITY) & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnSilenceLevelChanged();
		}
	}
	if( CSETTING_L_ULSSETTINGS & dwSettings )
	{
		if(g_pLDAP)
		{
			g_pLDAP->OnSettingsChanged();
		}

		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
			LPCTSTR pcszName = re.GetString(REGVAL_ULS_NAME);

			g_pNmSysInfo->SetProperty(NM_SYSPROP_USER_NAME, CComBSTR(pcszName));
		}
	}
	if (CSETTING_L_FULLDUPLEX & dwSettings)
	{
		RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
		BOOL bFullDuplex = FALSE;
		UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

		if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps))
		{
			bFullDuplex = re.GetNumber(REGVAL_FULLDUPLEX,FULLDUPLEX_DISABLED);
		}

		ASSERT(g_pNmSysInfo);

		if (NULL != g_pNmSysInfo)
		{
			g_pNmSysInfo->SetOption(NM_SYSOPT_FULLDUPLEX, bFullDuplex);
		}
	}

	if (CSETTING_L_CAPTUREDEVICE & dwSettings)
	{
		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(VIDEO_KEY, HKEY_CURRENT_USER);
			DWORD dwCaptureID = re.GetNumber(REGVAL_CAPTUREDEVICEID, 0);

			g_pNmSysInfo->SetOption(NM_SYSOPT_CAPTURE_DEVICE, dwCaptureID);
		}
	}

	if (CSETTING_L_DIRECTSOUND & dwSettings)
	{
		ASSERT(g_pNmSysInfo);

		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			DWORD dwDS = re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED);
			g_pNmSysInfo->SetOption(NM_SYSOPT_DIRECTSOUND, dwDS);
		}
	}

	DebugExitVOID(HandleConfSettingsChange);
}

// DeleteOldRegSettings is called the first time
// this build of NetMeeting is run by the user
// We don't touch UI\Directory as it is populated by the INF file
VOID DeleteOldRegSettings()
{
	// "%KEY_CONFERENCING%\UI"
	HKEY hKey;
	long lRet = ::RegOpenKey(HKEY_CURRENT_USER, UI_KEY, &hKey);
	if (NO_ERROR == lRet)
	{
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_X);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_Y);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_WIDTH);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_HEIGHT);

		::RegCloseKey(hKey);
	}
}

static HRESULT _ValidatePolicySettings()
{
	HRESULT hr = S_OK;

	if( g_pNmSysInfo )
	{
        //
        // LAURABU BUGBUG BOGUS:
        //
        // If security required, and not available, warning
        // If security incoming required/outgoing preferred, warning
        //
	}
	else
	{
		ERROR_OUT(("g_pNmySysInfo should not me NULL"));
		hr = E_UNEXPECTED;				
	}

	return hr;
}

HRESULT InitSDK()
{
	DBGENTRY(InitSDK);
	HRESULT hr = S_OK;

	if(FAILED(hr = CSDKWindow::InitSDK())) goto end;
	if(FAILED(hr = CNmCallObj::InitSDK())) goto end;
	if(FAILED(hr = CNmManagerObj::InitSDK())) goto end;
	if(FAILED(hr = CNmConferenceObj::InitSDK())) goto end;
	if(FAILED(hr = CNetMeetingObj::InitSDK())) goto end;
	if(FAILED(hr = CFt::InitFt())) goto end;


	g_pCCallto = new CCallto;

	ASSERT( g_pCCallto != NULL );
	
	if( g_pCCallto == NULL )
	{
		hr = E_FAIL;
	}

	end:

	DBGEXIT_HR(InitSDK,hr);
	return hr;
}


void CleanupSDK()
{
	DBGENTRY(CleanupSDK);


		// Revoke the old filter object
	CoRegisterMessageFilter(NULL, NULL);


	CNmCallObj::CleanupSDK();
	CNmManagerObj::CleanupSDK();
	CNmConferenceObj::CleanupSDK();
	CSDKWindow::CleanupSDK();
	CNetMeetingObj::CleanupSDK();
	CFt::CloseFtApplet();

	DBGEXIT(CleanupSDK);
}


/*  I N I T  C O N F  E X E  */
/*-------------------------------------------------------------------------
    %%Function: InitConfExe

-------------------------------------------------------------------------*/
HRESULT InitConfExe(BOOL fShowUI)
{

		// Create a message filter object
	CComPtr<IMessageFilter> spMsgFilter;
	CComPtr<IMessageFilter> spOldMsgFilter;
	HRESULT hr = CConfMsgFilter::_CreatorClass::CreateInstance(NULL, IID_IMessageFilter, reinterpret_cast<void**>(&spMsgFilter));
	if(FAILED(hr)) return hr;

		// Register the message filter object
	hr = CoRegisterMessageFilter(spMsgFilter, &spOldMsgFilter);
	if(FAILED(hr)) return hr;

	//	Wipe out default find directory entry...  we no longer wish to persist this...
	//	in some future overhaul / cleanup we should stop using the registry for this...
	RegEntry	re( DLGCALL_MRU_KEY, HKEY_CURRENT_USER );

	re.SetValue( REGVAL_DLGCALL_DEFDIR, TEXT( "" ) );

	LPCTSTR lpCmdLine = g_lpCmdLine;
	TRACE_OUT(("InitConfExe"));

	// Init UI objects (NOTE: we continue if this fails)
	CPopupMsg::Init();
        CPasswordDlg::Init();

	// Allocate dialog list object:
	g_pDialogList = new CSimpleArray<ITranslateAccelerator*>;
	if (NULL == g_pDialogList)
	{
		ERROR_OUT(("Could not allocate g_pDialogList!"));
		return E_FAIL;
	}


	//
	// Initialize the critical section to protect the dialogList
	//
	InitializeCriticalSection(&dialogListCriticalSection);
	
	// Determine if we have MORE THAN 256 colors
	{
		HDC hdc = GetDC(NULL);
		if (NULL != hdc)
		{
			g_fHiColor = 8 < (::GetDeviceCaps(hdc, BITSPIXEL) * ::GetDeviceCaps(hdc, PLANES));
			ReleaseDC(NULL, hdc);
		}
	}

	// Get the default dialog (GUI) font for international
	// REVIEW: should we check the registry for a localized font?
	g_hfontDlg = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
	if (NULL == g_hfontDlg)
	{
		return E_FAIL;
	}

	LoadIconImages();

	// On Windows NT, determine if the NetMeeting display driver is
	// enabled.  Note that this depends on <g_osvi> being initialized.
	//
	// Since NT 5.0 will support dynamic loading of the display driver,
	// we assume that the driver is enabled if the OS major version
	// number is greater than 4.
	if (::IsWindowsNT())
	{
		RegEntry re1(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

		g_fNTDisplayDriverEnabled =
			4 < g_osvi.dwMajorVersion ||
			NT_DRIVER_START_DISABLED !=
				re1.GetNumber(
					REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED,
					NT_DRIVER_START_DISABLED);
	}
	else
	{
		ASSERT(FALSE == g_fNTDisplayDriverEnabled);
	}

	// Check the language layout (UI can be displayed after this point)
	CheckLanguageLayout();

	// AutoConfiguration
	CAutoConf::DoIt();

	TRACE_OUT(("Command Line is \"%s\"", lpCmdLine));

	// Register hidden window class:
	WNDCLASS wcESHidden =
	{
		0L,
		ESHiddenWndProc,
		0,
		0,
		_Module.GetModuleInstance(),
		NULL,
		NULL,
		NULL,
		NULL,
		g_cszESHiddenWndClassName
	};
	
	if (!RegisterClass(&wcESHidden))
	{
		ERROR_OUT(("Could not register hidden wnd classes"));
		return E_FAIL;
	}

	
	// Register the "NetMeeting EndSession" message:
	g_uEndSessionMsg = ::RegisterWindowMessage(NM_ENDSESSION_MSG_NAME);
	
	// Create a hidden window for event processing:
	g_pHiddenWnd = new CHiddenWindow();
	if (NULL == g_pHiddenWnd)
	{
		return(E_FAIL);
	}
	g_pHiddenWnd->Create();

	g_hwndESHidden = ::CreateWindow(	g_cszESHiddenWndClassName,
										_TEXT(""),
										WS_POPUP, // not visible!
										0, 0, 0, 0,
										NULL,
										NULL,
										_Module.GetModuleInstance(),
										NULL);

	HWND hwndHidden = g_pHiddenWnd->GetWindow();

	if ((NULL == hwndHidden) || (NULL == g_hwndESHidden))
	{
		ERROR_OUT(("Could not create hidden windows"));
		return E_FAIL;
	}

	LONG lSoundCaps = SOUNDCARD_NONE;

	// Start the run-once wizard (if needed):
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// check to see if the wizard has been run in UI mode for this build
	DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
	BOOL fRanWizardUI = ((VER_PRODUCTVERSION_W & HIWORD(dwVersion)) == VER_PRODUCTVERSION_W);

	BOOL fForceWizard = FALSE;
	if (!fRanWizardUI)
	{
		dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
		BOOL fRanWizardNoUI = (VER_PRODUCTVERSION_DW == dwVersion);

		// wizard has not been run in UI mode
		if (!fRanWizardNoUI)
		{
			// wizard has not been run before, delete old registry settings
			DeleteOldRegSettings();

			fForceWizard = TRUE;
		}
		else
		{
			// wizard has been run in NoUI mode, we only need to run it if we are in UI mode
			if(fShowUI)
			{
				fForceWizard = TRUE;
			}
		}

		if (fForceWizard)
		{
			WabReadMe();
		}
	}

	hr = ::StartRunOnceWizard(&lSoundCaps, fForceWizard, fShowUI);
	if (FAILED(hr))
	{
		WARNING_OUT(("Did not retrieve necessary info from wizard"));
		ConfMsgBox(NULL, MAKEINTRESOURCE(IDS_ERROR_BAD_ADMIN_SETTINGS));

		return E_FAIL;
	}
	else if( S_FALSE == hr )
	{
		return NM_E_USER_CANCELED_SETUP;
	}

	if (fForceWizard)
	{
		reConf.SetValue(fShowUI ? REGVAL_WIZARD_VERSION_UI :
				REGVAL_WIZARD_VERSION_NOUI, VER_PRODUCTVERSION_DW);
	}

	// Start NetMeeting At Page Once
	if( fShowUI && fForceWizard )
	{
		if( ConfPolicies::IsShowFirstTimeUrlEnabled() )
		{
			CmdLaunchWebPage(ID_HELP_WEB_SUPPORT);
		}
	}

	// The following hack is to fix the don't run wizard twice bug
	// the side effect is that the codec ordering is blown away.
	// this code restores the key in the event that this wizard is not run.
	HKEY hKey;
	long lRet = ::RegOpenKey(HKEY_LOCAL_MACHINE,
			INTERNET_AUDIO_KEY TEXT("\\") REGVAL_ACMH323ENCODINGS , &hKey);
	if (NO_ERROR == lRet)
	{
		::RegCloseKey(hKey);
	}
	else
	{
		RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
		UINT uBandwidth = reAudio.GetNumber ( REGVAL_TYPICALBANDWIDTH, BW_DEFAULT );
		SaveDefaultCodecSettings(uBandwidth);
	}

	// Start the Splash screen only after the wizard is complete
	if (fShowUI)
	{
		::StartSplashScreen(NULL);
	}

	// Init incoming call log:
	g_pInCallLog = new CCallLog(LOG_INCOMING_KEY, TEXT("CallLog"));

	// Init capabilities:

	g_uMediaCaps = CAPFLAG_DATA;

	//
    // NOTE:  THIS IS WHERE TO CHANGE TO DISABLE H323 CALLS FOR INTEL ET AL.
    //

	if(!_Module.DidSDKDisableH323())
	{
		g_uMediaCaps |= CAPFLAG_H323_CC;

		if (SOUNDCARD_NONE != lSoundCaps)
		{
			if (!SysPol::NoAudio())
			{
				g_uMediaCaps |= CAPFLAGS_AUDIO;
			}
		}
		if (!SysPol::NoVideoReceive())
		{
			g_uMediaCaps |= CAPFLAG_RECV_VIDEO;
		}
		if (!SysPol::NoVideoSend())
		{
			g_uMediaCaps |= CAPFLAG_SEND_VIDEO;
		}
	}

	// Create Manager
	hr = CoCreateInstance(CLSID_NmManager2, NULL, CLSCTX_INPROC, IID_INmManager2, (void**)&g_pInternalNmManager);
	if (FAILED(hr))
	{
		ERROR_OUT(("Could not create INmManager"));
		return E_FAIL;
	}

	// Get the INmSysInfo3
	CComPtr<INmSysInfo > spSysInfo;
	if (SUCCEEDED(g_pInternalNmManager->GetSysInfo(&spSysInfo)))
	{
		if (FAILED(spSysInfo->QueryInterface(IID_INmSysInfo2, (void **)&g_pNmSysInfo)))
		{
			ERROR_OUT(("Could not get INmSysInfo2"));
		}
		else
		{
			ASSERT( g_pNmSysInfo );

			CComPtr<INmSysInfoNotify> spNmSysInfoNotify;
			if( SUCCEEDED ( CConfNmSysInfoNotifySink::_CreatorClass::CreateInstance( NULL, IID_INmSysInfoNotify, reinterpret_cast<void**>(&spNmSysInfoNotify))))
			{
				ASSERT(spNmSysInfoNotify);
				ASSERT(0 == g_dwSysInfoNotifyCookie);

				NmAdvise(g_pNmSysInfo, spNmSysInfoNotify, IID_INmSysInfoNotify, &g_dwSysInfoNotifyCookie);
			}
			
		}
	}

	_ValidatePolicySettings();

	hr = g_pInternalNmManager->Initialize(NULL, &g_uMediaCaps);
	if (FAILED(hr))
	{
		UINT_PTR uErrorID;

		switch (hr)
		{
			case UI_RC_NO_NODE_NAME:
			{
				// No error in this case - the user probably cancelled from
				// the intro wizard.
				uErrorID = 0;
				break;
			}
			case UI_RC_BACKLEVEL_LOADED:
			{
				uErrorID = IDS_BACKLEVEL_LOADED;
				break;
			}
			case UI_RC_T120_ALREADY_INITIALIZED:
			{
				uErrorID = IDS_T120_ALREADY_INITIALIZED;
				break;
			}

			case UI_RC_T120_FAILURE:
			{
				WARNING_OUT(("T.120 failed to initialize (winsock problem?)"));
				uErrorID = IDS_CANT_START;
				break;
			}

			default:
			{
				uErrorID = IDS_CANT_START;
				break;
			}
		}
		if (0 != uErrorID)
		{
			::ConfMsgBox(NULL, (LPCTSTR) uErrorID);
		}
		return E_FAIL;
	}

	// force the update of dll settings
	HandleConfSettingsChange(CSETTING_L_BANDWIDTH |
							CSETTING_L_CAPTUREDEVICE |
							CSETTING_L_ULSSETTINGS |
							CSETTING_L_DIRECTSOUND|
							CSETTING_L_FULLDUPLEX);

	if (FALSE == ::ConfRoomInit(_Module.GetModuleInstance()))
	{
		::ConfMsgBox(NULL, (LPCTSTR) IDS_CANT_START);
		return E_FAIL;
	}

	// Now perform the check on the machine name and warn if
	// it is problematic.
	::CheckMachineNameForExtendedChars();

	// Create the main conference manager to make sure
	// we can handle incoming calls, even in background mode
	if (!CConfMan::FCreate(g_pInternalNmManager))
	{
		ERROR_OUT(("Unable to create Conference Manager"));
		return E_FAIL;
	}

	// Initialize winsock  (for name/address resolution)
	{
		WSADATA wsaData;
		int iErr = WSAStartup(0x0101, &wsaData);
		if (0 != iErr)
		{
			ERROR_OUT(("WSAStartup() failed: %i", iErr));
			return E_FAIL;
		}
		g_WSAStarted = TRUE;
	}

	// Initialize T.120 Security settings
	::InitT120SecurityFromRegistry();

    StopSplashScreen();

    CreateConfRoomWindow(fShowUI);

	g_pPing = new CPing;

	if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct )
	{
		//	Initialize gatewayContext...
		RegEntry	reConf1( CONFERENCING_KEY, HKEY_CURRENT_USER );

		if( reConf1.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0 )
		{
			g_pCCallto->SetGatewayName( reConf1.GetString( REGVAL_H323_GATEWAY ) );
			g_pCCallto->SetGatewayEnabled( true );
		}

		if(ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode() && !_Module.DidSDKDisableInitialILSLogon())
		{
			InitNmLdapAndLogon();
		}
	}
	else
	{
		GkLogon();
	}

	if(!_Module.InitControlMode())
	{
		::AddTaskbarIcon(::GetHiddenWindow());
	}

	g_bNeedCleanup = true;
	CNmManagerObj::NetMeetingLaunched();
	return S_OK;
}

VOID CleanUpUi(void)
{
	SysPol::CloseKey();

	if( 0 != g_dwSysInfoNotifyCookie )
	{
		NmUnadvise(g_pNmSysInfo, IID_INmSysInfoNotify, g_dwSysInfoNotifyCookie);
		g_dwSysInfoNotifyCookie = 0;
	}

	if (NULL != g_pNmSysInfo)
	{
		if( IsGatekeeperLoggedOn() )
		{
			g_pNmSysInfo->GkLogoff();
		}

		g_pNmSysInfo->Release();
		g_pNmSysInfo = NULL;
	}

	FreeIconImages();

	CGenWindow::DeleteStandardPalette();
	CGenWindow::DeleteStandardBrush();

	CMainUI::CleanUpVideoWindow();

	CFindSomeone::Destroy();
}

VOID CleanUp(BOOL fLogoffWindows)
{

	FreeCallList();

	// Kill the taskbar icon:
	if (NULL != g_pHiddenWnd)
	{
		HWND hwndHidden = g_pHiddenWnd->GetWindow();

		TRACE_OUT(("Removing taskbar icon..."));
		::RemoveTaskbarIcon(hwndHidden);
		DestroyWindow(hwndHidden);

		g_pHiddenWnd->Release();
		g_pHiddenWnd = NULL;
	}

	// NOTE: during WM_ENDSESSION, we want
	// to log off after doing all other clean-up, in case it gets stuck
	// waiting for the logon thread to complete.
	if (FALSE == fLogoffWindows)
	{
		if(g_pLDAP)
		{
			g_pLDAP->Logoff();

			delete g_pLDAP;
			g_pLDAP = NULL;
		}
	}

	delete g_pCCallto;
	g_pCCallto = NULL;

	delete g_pPing;
	g_pPing = NULL;

	CleanUpUi();

	// These must happen AFTER all the UI is cleaned up
	if(g_pInternalNmManager)
	{
		g_pInternalNmManager->Release();
	}
	CConfMan::Destroy();

	// destroy incoming call log:
	delete g_pInCallLog;
	g_pInCallLog = NULL;

	CPopupMsg::Cleanup();
        CPasswordDlg::Cleanup();
	
	// Code to clean up gracefully

	if (FALSE == fLogoffWindows)
	{
		// NOTE: we intentionally leak this list object when shutting down
		// due to logging off windows, because we don't want to put a NULL
		// check in HandleDialogMessage() and there is no WM_QUIT to guarantee that
		// we've stopped receiving messages when shutting down in that code path

		EnterCriticalSection(&dialogListCriticalSection);

		for( int i = 0; i < g_pDialogList->GetSize(); ++i )
		{
			ASSERT( NULL != (*g_pDialogList)[i] );
			RemoveTranslateAccelerator( (*g_pDialogList)[i] );
		}

		LeaveCriticalSection(&dialogListCriticalSection);
		
		// Delete the dialog list:
		delete g_pDialogList;

		//
		// Delete the critical section
		//
		DeleteCriticalSection(&dialogListCriticalSection);
		
		g_pDialogList = NULL;
	}

	// Auto-disconnect from MSN:
	::SendDialmonMessage(WM_APP_EXITING);
	
	if (g_WSAStarted)
	{
		WSACleanup();
		g_WSAStarted = FALSE;
	}

	delete g_pConfRoom;
    g_pConfRoom = NULL;

	g_bNeedCleanup = false;
}

/*  S E N D  D I A L M O N  M E S S A G E  */
/*-------------------------------------------------------------------------
    %%Function: SendDialmonMessage

	Send a message to the dialing monitor.
	Either WINSOCK_ACTIVITY_TIMER or WM_APP_EXITING.
    (The code comes from Internet Explorer)
-------------------------------------------------------------------------*/
VOID SendDialmonMessage(UINT uMsg)
{
	HWND hwndAutodisconnectMonitor = ::FindWindow(_TEXT("MS_AutodialMonitor"), NULL);
	if (NULL != hwndAutodisconnectMonitor)
	{
		::SendMessage(hwndAutodisconnectMonitor, uMsg, 0, 0);
	}
}

// This window procedure exists for the sole purpose of receiving
// WM_ENDSESSION.  Because of bug 2287, we cannot have the regular
// hidden window handle WM_ENDSESSION.  DCL has subclassed our hidden
// window, and if we unload them inside one of it's messages, then we
// will fault.  It's too bad that we can't find a better fix (such as
// removing the subclass), but we are under time pressure to fix this
// bug for v1.0

LRESULT CALLBACK ESHiddenWndProc(	HWND hwnd, UINT uMsg,
									WPARAM wParam, LPARAM lParam)
{
	if ((WM_ENDSESSION == uMsg) && (TRUE == (BOOL) wParam))
	{
		TRACE_OUT(("Conf received WM_ENDSESSION, fLogoff=%s",
					GetBOOLString((BOOL)lParam)));
		TRACE_OUT(("Conf calling UIEndSession()"));
		CConfRoom::UIEndSession((BOOL) lParam);
		TRACE_OUT(("Conf testing lParam=%d", lParam));
		if ((BOOL) lParam)
		{
			// Logging off:
			TRACE_OUT(("Conf calling CleanUp()"));
			
			// NOTE: Passing TRUE into CleanUp() because we don't
			// want to logoff ULS / de-init name services until after insuring that DCL
			// has cleaned up properly, because it can take enough time that
			// our task might get killed.
			::CleanUp(TRUE);

			//
			// Restart the remote control service if we need to.
			//
			RestartRemoteControlService();
		}
		else
		{
			TRACE_OUT(("Conf not cleaning up - Windows shutting down"));
		}

#if 0 // LONCHANC: it faults 100% on my main dev machine.	
		if( g_pLDAP != NULL )
		{
			g_pLDAP->Logoff();
		}
#endif
		return 0;
	}
	else
	{
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
}


/*  C M D  S H U T D O W N  */
/*-------------------------------------------------------------------------
    %%Function: CmdShutdown

-------------------------------------------------------------------------*/
VOID CmdShutdown(void)
{
	HWND hwndMain = ::GetMainWindow();
	if (NULL != hwndMain)
	{
		// We have UI up, so post a WM_CLOSE with lParam = 1,
		// which indicates a forced "Exit and Stop"
		::PostMessage(hwndMain, WM_CLOSE, 0, 1);
	}
	else
	{
		::PostThreadMessage(_Module.m_dwThreadID, WM_QUIT, 0, 0);
	}
}

void SignalShutdownStarting(void)
{
	if (NULL == g_hShutdown)
	{
		g_hShutdown = ::CreateEvent(NULL, TRUE, FALSE, _TEXT("CONF:ShuttingDown"));
		_Module.RevokeClassObjects();
	}
}


/*  H A N D L E  D I A L O G  M E S S A G E  */
/*-------------------------------------------------------------------------
    %%Function: HandleDialogMessage

	Global modeless dialog handler
-------------------------------------------------------------------------*/
BOOL HandleDialogMessage(LPMSG pMsg)
{
	
	if (g_hwndDropDown != NULL)
	{
		switch (pMsg->message)
			{
		case WM_KEYDOWN:
		{
			if ((VK_ESCAPE != pMsg->wParam) && (VK_TAB != pMsg->wParam))
				break;
			if (0 != SendMessage(g_hwndDropDown, WM_CONF_DROP_KEY,
				pMsg->wParam, (LPARAM) pMsg->hwnd))
			{
				return TRUE; // message was handled
			}
			break;
		}
		
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_NCLBUTTONDOWN:
		case WM_NCRBUTTONDOWN:
		{
			if (g_hwndDropDown == pMsg->hwnd)
				break; // message is for the window, pass along as normal

			if (0 != SendMessage(g_hwndDropDown, WM_CONF_DROP_CLICK,
				0, (LPARAM) pMsg->hwnd))
			{
				return TRUE; // message was handled
			}
			break;
		}

		default:
			break;
			} /* switch (pMsg->message) */
	}

	ASSERT(NULL != g_pDialogList);

	EnterCriticalSection(&dialogListCriticalSection);


	for( int i = 0; i < g_pDialogList->GetSize(); ++i )
	{
		ITranslateAccelerator *pTrans = (*g_pDialogList)[i];
		ASSERT( NULL != pTrans );
		if( S_OK == pTrans->TranslateAccelerator(pMsg, 0) )
		{
			LeaveCriticalSection(&dialogListCriticalSection);
			return TRUE;
		}
	}
	
	LeaveCriticalSection(&dialogListCriticalSection);

	
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////


/*  R E M O T E  P A S S W O R D  D L G  P R O C */
// Handles the dialog box asking if the user wants to start conf.exe even though the remote control
// service is in a call.
INT_PTR CALLBACK ServiceRunningDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		return TRUE;
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case ID_START_CONF:
			EndDialog(hDlg,1);
			break;
		case ID_EXIT:
			EndDialog(hDlg,0);
			break;
		default:
			break;
		}
		return TRUE;
		break;
	}
	return FALSE;
}

BOOL CheckRemoteControlService()
{
	BOOL fContinue = TRUE;
	
	// Store OS version info
	g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
	if (FALSE == ::GetVersionEx(&g_osvi))
	{
		ERROR_OUT(("GetVersionEx() failed!"));
		return FALSE;
	}

	if (::IsWindowsNT()) {
		SC_HANDLE hSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hRemoteControl = NULL;
		SERVICE_STATUS serviceStatus;

		if (hSCManager != NULL) {
			hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);
			DWORD dwError = GetLastError();
			if (hRemoteControl != NULL) {
				// If service is running...
				BOOL fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
				if (fSuccess && serviceStatus.dwCurrentState != SERVICE_STOPPED && serviceStatus.dwCurrentState != SERVICE_PAUSED) {
					if (serviceStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) // Service is in a call
                                        {
											fContinue = (BOOL)DialogBox(::GetInstanceHandle(),MAKEINTRESOURCE(IDD_SERVICE_RUNNING),GetDesktopWindow(),ServiceRunningDlgProc);
                                        }
					if (fContinue) {
						ControlService(hRemoteControl,SERVICE_CONTROL_PAUSE,&serviceStatus);
						for (int i = 0; i < MAX_REMOTE_TRIES; i++) {
							fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
							if (serviceStatus.dwCurrentState == SERVICE_PAUSED)
								break;
							TRACE_OUT(("Waiting for srvc - status is %d...",
								serviceStatus.dwCurrentState));
							Sleep(1000);
						}
						if ( MAX_REMOTE_TRIES == i )
						{
							// If we don't manage to shut down the service
							// we shouldn't try to start - it will only fail.
							WARNING_OUT(("TIMED OUT WAITING FOR SRVC!!"));
							fContinue = FALSE;
						}
					}
				}
				CloseServiceHandle(hRemoteControl);
			}
			CloseServiceHandle(hSCManager);
		}

		return fContinue;
	}
	else {	// Windows 95
            HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_PAUSE_EVENT);
            HANDLE hActiveEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_ACTIVE_EVENT);
            DWORD dwError = GetLastError();
            if (hServiceEvent != NULL && hActiveEvent != NULL) {	// Service is running and is active
                CloseHandle(hActiveEvent);
                HANDLE hCallEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_CALL_EVENT);
                if (hCallEvent != NULL) {		// Service is in a call
                    fContinue = (BOOL)DialogBox(::GetInstanceHandle(),MAKEINTRESOURCE(IDD_SERVICE_RUNNING),GetDesktopWindow(),ServiceRunningDlgProc);
                    CloseHandle(hCallEvent);
                }
                if (fContinue) {
                    SetEvent(hServiceEvent);
                    CloseHandle(hServiceEvent);
                    for (int i = 0; i < MAX_REMOTE_TRIES; i++) {
                        hActiveEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_ACTIVE_EVENT);
                        if (NULL == hActiveEvent)
                            break;
                        TRACE_OUT(("Waiting for srvc"));
                        CloseHandle(hActiveEvent);
                        Sleep(1000);
                    }
                    if ( MAX_REMOTE_TRIES == i ) {
                        // If we don't manage to shut down the service
                        // we shouldn't try to start - it will only fail.
                        WARNING_OUT(("TIMED OUT WAITING FOR SRVC!!"));
                        fContinue = FALSE;
                    }
                }
            }
            return fContinue;
	}
}

VOID RestartRemoteControlService()
{
	RegEntry reLM = RegEntry(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);

	if (!reLM.GetNumber(REMOTE_REG_RUNSERVICE,0))
		return;

	if (ConfPolicies::IsRDSDisabled())
	{
		WARNING_OUT(("RDS launch disallowed by policy"));
		return;
	}
        BOOL fActivate = reLM.GetNumber(REMOTE_REG_ACTIVATESERVICE, DEFAULT_REMOTE_ACTIVATESERVICE);
	if (::IsWindowsNT()) {
		SERVICE_STATUS serviceStatus;
		SC_HANDLE hSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);
		if (hRemoteControl != NULL) {
                    BOOL fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
                    if (SERVICE_STOPPED == serviceStatus.dwCurrentState)
                    {
                        StartService(hRemoteControl,0,NULL);
                    }
                    else
                    {
                        if (fActivate)
                        {
                            ControlService(hRemoteControl, SERVICE_CONTROL_CONTINUE, &serviceStatus);
                        }
                    }
		}
		else
		{
                    WARNING_OUT(("Error starting RDS"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confcpl.h ===
// File: ConfCpl.h
//
// Main header file for Wizards and Options Dialog

#ifndef _CONFCPL_H_
#define _CONFCPL_H_

#include <ConfWiz.h>
#include <AudioWiz.h>
#include "confpolicies.h"
#include "csetting.h"

// CPL-specific WM_USER messages
#define WM_AUDIOCALIBRATE       WM_USER + 200
#define WM_DONEAUDIOCALIBRATE   WM_USER + 201
#define WM_ENDCALIBRATE         WM_USER + 202
#define WM_CALIBTIMELEFT        WM_USER + 203

// from wizard.cpp
extern BOOL g_fSilentWizard;
void HideWizard(HWND hwnd);
void ShowWizard(HWND hwnd);

class CULSWizard;

HRESULT StartRunOnceWizard(LPLONG plSoundCaps, BOOL fForce, BOOL fVisible);
BOOL FLegalEmailSz(PTSTR pszName);
bool IsLegalGateKeeperServerSz(LPCTSTR szServer);
bool IsLegalGatewaySz(LPCTSTR szServer);
bool IsLegalE164Number(LPCTSTR szPhone);
void InitDirectoryServicesDlgInfo( HWND hDlg, CULSWizard* pWiz, bool& bOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch );
void InitGatekeeperDlgInfo( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz, bool &rbCantChangeGkCallingMode );
void SetGKAddressingMode( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz, ConfPolicies::eGKAddressingMode eMode );

BOOL FLegalEmailName(HWND hdlg, UINT id);

VOID FillServerComboBox(HWND hwndCombo);

VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam=0, LPCTSTR pszProc=NULL);

// Global flag keeps setting that changed for windows msg broadcast
extern DWORD g_dwChangedSettings;

// externs to dialog procedures in separate files
extern INT_PTR APIENTRY ConferencingDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY SecurityDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY AudioDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY VideoDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY UserDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY CallOptDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY RemoteDlgProc ( HWND, UINT, WPARAM, LPARAM );

extern int GetBandwidthBits(int id, int megahertz);


#endif /* _CONFCPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confnmsysinfonotify.cpp ===
#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "imsconf3.h"
#include "ConfNmSysInfoNotify.h"
#include "ConfUtil.h"


///////////////////////////////////////
// INmSysInfoNotify
///////////////////////////////////////
STDMETHODIMP CConfNmSysInfoNotifySink::GateKeeperNotify( IN NM_GK_NOTIFY_CODE code )
{
	HRESULT hr = S_OK;

	switch( code )
	{
		case NM_GKNC_REG_CONFIRM:	TRACE_OUT(("NM_GKNC_REG_CONFIRM notification received"));
			SetGkLogonState(NM_GK_LOGGED_ON);
			break;

		case NM_GKNC_LOGON_TIMEOUT: TRACE_OUT(("NM_GKNC_LOGON_TIMEOUT notification received"));
			SetGkLogonState(NM_GK_IDLE);
			PostConfMsgBox(IDS_ERR_GK_LOGON_TIMEOUT);
			break;
		case NM_GKNC_REJECTED:	TRACE_OUT(("NM_GKNC_REJECTED notification received"));
			PostConfMsgBox(IDS_ERR_GK_LOGON_REJECTED);
			SetGkLogonState(NM_GK_IDLE);
			break;

		case NM_GKNC_UNREG_CONFIRM:	TRACE_OUT(("NM_GKNC_UNREG_CONFIRM notification received"));
		case NM_GKNC_UNREG_REQ:	TRACE_OUT(("NM_GKNC_UNREG_REQ notification received"));
			SetGkLogonState(NM_GK_IDLE);
			break;
		default:
			WARNING_OUT(("Unknown notification recieved from GateKeeper"));
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confman.cpp ===
// File: confman.cpp
//
// Conference Manager

#include "precomp.h"

#include "conf.h"
#include "confroom.h"
#include "confman.h"

#include "cr.h"      // for CreateConfRoom
#include "call.h"    // for OnUICallCreated

CConfMan * CConfMan::m_pConfMan = NULL; // There is only one of these

static const UINT g_cuShutdownMsgTimeout = 0x7FFFFFFF; // milliseconds


/*  C  C O N F  M A N  */
/*-------------------------------------------------------------------------
    %%Function: CConfMan
    
-------------------------------------------------------------------------*/
CConfMan::CConfMan(INmManager2 *pManager) :
	RefCount(NULL),
	m_pManager(pManager)
{
	m_pConfMan = this;

	ASSERT(NULL != m_pManager);

	NmAdvise(m_pManager, (INmManagerNotify*)this, IID_INmManagerNotify, &m_dwCookie);
	m_pManager->AddRef();

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CConfMan", this);
}

CConfMan::~CConfMan()
{
	ASSERT(NULL == m_pManager);
	m_pConfMan = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CConfMan", this);
}

BOOL CConfMan::FCreate(INmManager2 *pManager)
{
	if (NULL != m_pConfMan)
		return FALSE;  // already created

	m_pConfMan = new CConfMan(pManager);
	if (NULL == m_pConfMan)
		return FALSE;

	return TRUE;
}

VOID CConfMan::Destroy(void)
{
	if (NULL == m_pConfMan)
		return;

	m_pConfMan->CleanUp();

	// we should only have one more lock on this object
	m_pConfMan->Release();
	// so this will be cleared in the destructor
	ASSERT(NULL == m_pConfMan);
}

VOID CConfMan::CleanUp(void)
{
	if (NULL != m_pManager)
	{
		NmUnadvise(m_pManager, IID_INmManagerNotify, m_dwCookie);

		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->CleanUp();
		}

		m_pManager->Release();
		m_pManager = NULL;
	}

}


/*  G E T  N M  M A N A G E R  */
/*-------------------------------------------------------------------------
    %%Function: GetNmManager
    
-------------------------------------------------------------------------*/
INmManager2 * CConfMan::GetNmManager()
{
	if (NULL == m_pConfMan)
		return NULL;

	INmManager2 * pManager = m_pConfMan->GetINmManager();
	if (NULL != pManager)
	{
		pManager->AddRef();
	}
	return pManager;
}



//////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP_(ULONG) CConfMan::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CConfMan::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConfMan::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmManagerNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmManagerNotify *)this;
		ApiDebugMsg(("CConfMan::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfMan::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////
// INmManagerNotify

STDMETHODIMP CConfMan::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CConfMan::ConferenceCreated(INmConference *pConference)
{
	CConfRoom * m_pConfRoom = ::GetConfRoom();
	ASSERT(NULL != m_pConfRoom);

	if(_Module.IsUIActive())
	{
		m_pConfRoom->BringToFront();
	}

	return m_pConfRoom->OnConferenceCreated(pConference);
}

STDMETHODIMP CConfMan::CallCreated(INmCall *pCall)
{
	OnUICallCreated(pCall);

	return S_OK;
}


VOID CConfMan::AllowAV(BOOL fAllowAV)
{
	CConfMan * pConfMan = CConfMan::GetInstance();
	if (NULL == pConfMan)
		return;

	INmManager2 * pManager = pConfMan->GetINmManager();
	if (NULL == pManager)
		return;

	pManager->AllowH323(fAllowAV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confmsgfilter.h ===
#ifndef __ConfMsgFilter_h__
#define __ConfMsgFilter_h__

/////////////////////////////////////////////////////////////////////////////
// CConfMsgFilter
class ATL_NO_VTABLE CConfMsgFilter : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IMessageFilter
{
public:
	typedef CComCreator< CComObjectNoLock< CConfMsgFilter > > _CreatorClass;
private:
	BEGIN_COM_MAP(CConfMsgFilter)
		COM_INTERFACE_ENTRY(IMessageFilter)
	END_COM_MAP()

	STDMETHOD_(DWORD,HandleInComingCall)
	(
		DWORD dwCallType,
		HTASK htaskCaller,
		DWORD dwTickCount,
		LPINTERFACEINFO lpInterfaceInfo
	)
	{
		return SERVERCALL_ISHANDLED;
	}

	STDMETHOD_(DWORD,RetryRejectedCall)
	(
		HTASK htaskCallee,
		DWORD dwTickCount,
		DWORD dwRejectType
	)
	{
		
		if (SERVERCALL_REJECTED == dwRejectType)
		{
			MessageBox(NULL, _T("Call was rejected"), _T("IMessageFilter"), MB_OK);
			return -1;    
		}
			
		if (dwTickCount < 30000)
			return 200;    

		return -1;
	}

	STDMETHOD_(DWORD,MessagePending)
	(
		HTASK htaskCallee,
		DWORD dwTickCount,
		DWORD dwPendingType
	)
	{
		return PENDINGMSG_WAITNOPROCESS;
	}
};



#endif // __ConfMsgFilter_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confnmsysinfonotify.h ===
#ifndef __ConfNmSysInfoNotify_h__
#define __ConfNmSysInfoNotify_h__

class ATL_NO_VTABLE CConfNmSysInfoNotifySink : 
    public CComObjectRoot,
    public INmSysInfoNotify
{


    
public:

		// We create it as No Lock, but we had better make sure that
		// the lifetime of this object is not greater than the lifetime of
		// the module in which it lives
	typedef CComCreator< CComObjectNoLock< CConfNmSysInfoNotifySink > > _CreatorClass;

    DECLARE_NO_REGISTRY()

// INmSysInfoNotify
	STDMETHOD(GateKeeperNotify)( IN NM_GK_NOTIFY_CODE RasEvent );

    BEGIN_COM_MAP(CConfNmSysInfoNotifySink)
	    COM_INTERFACE_ENTRY(INmSysInfoNotify)
    END_COM_MAP()
};


#endif // __ConfNmSysInfoNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confman.h ===
// File: confman.h

#ifndef _CONFMAN_H_
#define _CONFMAN_H_

#include "SDKInternal.h"

class CConfMan : public RefCount, public INmManagerNotify
{
protected:
	static CConfMan   * m_pConfMan;

public:
	static CConfMan * GetInstance()  {return m_pConfMan;}
	static BOOL       FCreate(INmManager2 *pManager);
	static VOID       Destroy();
	static INmManager2 * GetNmManager();
	static VOID       AllowAV(BOOL fAllowAV);

private:
	INmManager2 * m_pManager;
	DWORD         m_dwCookie;

	VOID         CleanUp(void);
	INmManager2 * GetINmManager()            {return m_pManager;}

public:
	CConfMan::CConfMan(INmManager2 *pManager);
	CConfMan::~CConfMan();

	VOID CheckIca();
	
	//
	// IUnknown methods:
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	//
	// INmManagerNotify methods:
	//
    STDMETHODIMP NmUI(CONFN uNotify);
    STDMETHODIMP ConferenceCreated(INmConference *pConference);
    STDMETHODIMP CallCreated(INmCall *pCall);
};


#endif /* _CONFMAN_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confndui.cpp ===
#include "precomp.h"
#include "resource.h"
#include "confwnd.h"
#include "confapi.h"
#include "ConfUtil.h"


HWND GetMsgBoxParent(void)
{
	return (_Module.IsUIVisible() ? ::GetMainWindow() : HWND_DESKTOP );
}

VOID PostConfMsgBox(UINT uStringID)
{
	::PostMessage(::GetHiddenWindow(), WM_CONF_MSG_BOX, uStringID, 0);
}

static const UINT MAX_CONFMSGBOX_STRING = 1024;
int ConfMsgBox(HWND hwndParent, LPCTSTR pcszMsg, UINT uType)
{
	if(_Module.InitControlMode())
	{
		// Return a reasonable value
		// TODO: Look at MB_DEFBUTTON1
		switch (uType & 0x0F)
		{
		case MB_YESNOCANCEL:
		case MB_YESNO:
			return IDYES;
		case MB_OK:
		case MB_OKCANCEL:
		default:
			return IDOK;
		}
	}

	TCHAR	szTitleBuf[MAX_PATH];
	TCHAR	szMsgBuf[MAX_CONFMSGBOX_STRING];
	LPTSTR	pszTrueMsg = (LPTSTR) pcszMsg;

	if (0 == HIWORD(pcszMsg))
	{
		// The string pointer is actually a resource id:
		if (::LoadString(	::GetInstanceHandle(),
							PtrToUint(pcszMsg),
							szMsgBuf,
							CCHMAX(szMsgBuf)))
		{
			pszTrueMsg = szMsgBuf;
		}
		else
		{
			pszTrueMsg = NULL;
		}
	}

	// The string pointer is actually a resource id:
	::LoadString(	::GetInstanceHandle(),
					IDS_MSGBOX_TITLE,
					szTitleBuf,
					CCHMAX(szTitleBuf));

	ASSERT(pszTrueMsg);
	
	return ::MessageBox(hwndParent,
						pszTrueMsg,
						szTitleBuf,
						uType);
}

VOID DisplayMsgIdsParam(int ids, LPCTSTR pcsz)
{
	if (!_Module.InitControlMode())
	{
		TCHAR szFormat[MAX_CONFMSGBOX_STRING];
		int nLength = ::LoadString(::GetInstanceHandle(), ids, szFormat, CCHMAX(szFormat));
		ASSERT(0 != nLength);

		LPTSTR pszMsg = new TCHAR[nLength + (FEmptySz(pcsz) ? 1 : lstrlen(pcsz))];
		if (NULL == pszMsg)
		{
			ERROR_OUT(("DisplayMsgIdsParam - out of memory"));
			return;
		}

		// Format the message
		wsprintf(pszMsg, szFormat, pcsz);

		if (!::PostMessage(::GetHiddenWindow(), WM_NM_DISPLAY_MSG,
			(WPARAM) MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK, (LPARAM) pszMsg))
		{
			delete [] pszMsg;
			ERROR_OUT(("DisplayMsgIdsParam - out of memory"));
		}
	}
}

int DisplayMsg(LPTSTR pszMsg, UINT uType)
{
	TCHAR szTitle[MAX_PATH];
	FLoadString(IDS_MSGBOX_TITLE, szTitle, CCHMAX(szTitle));

	int id = ::MessageBox(GetMsgBoxParent(), pszMsg, szTitle, uType);

	delete pszMsg;
	return id;
}

VOID DisplayErrMsg(INT_PTR ids)
{
	ConfMsgBox(::GetMainWindow(), (LPCTSTR) ids, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confroom.cpp ===
// File: confroom.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfPolicies.h"
#include "ConfRoom.h"
#include "ConfWnd.h"
#include "cmd.h"
#include "RoomList.h"
#include "RToolbar.h"
#include "TopWindow.h"
#include "FloatBar.h"
#include "StatBar.h"
#include "DShowDlg.h"
#include "SDialDlg.h"
#include "UPropDlg.h"
#include "PopupMsg.h"
#include "splash.h"
#include <version.h>                    // About Box
#include <pbt.h>
#include <EndSesn.h>

#include "taskbar.h"
#include "conf.h"
#include "MenuUtil.h"
#include "call.h"
#include "ConfApi.h"
#include "NmLdap.h"
#include "VidView.h"

#include "dbgMenu.h"
#include "IndeoPal.h"
#include "setupdd.h"
#include "audiowiz.h"
#include <help_ids.h>
#include "cr.h"
#include "audioctl.h"
#include "particip.h"
#include "confman.h"
#include <nmremote.h>
#include <tsecctrl.h>
#include "t120type.h"
#include "iappldr.h"
#include "nmapp.h"
#include "NmDispid.h"
#include "FtHook.h"
#include "NmManager.h"
#include "dlgacd.h"
#include "richaddr.h"
#include "sdkinternal.h"
#include "dlghost.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

//
// GLOBAL CONFROOM
//
CConfRoom * g_pConfRoom;

// ********************************************************
// Initialize GUIDs
//
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <CLinkId.h>
#include <CNotifID.h>
#include <confguid.h>
#include <ilsguid.h>
#undef INITGUID
#pragma data_seg()


INmConference2* GetActiveConference(void)
{
	INmConference2* pConf = NULL;

	if(g_pConfRoom)
	{
		pConf = g_pConfRoom->GetActiveConference();
	}

	return pConf;
}


#ifdef DEBUG
DWORD g_fDisplayViewStatus = 0;  // Display the listview count in the status bar
#endif
DWORD g_dwPlaceCall = nmDlgCallNoFilter;  // Place a Call options

INmConference2* CConfRoom::GetActiveConference(void)
{
	if (NULL != m_pInternalNmConference)
	{
		NM_CONFERENCE_STATE state;
		HRESULT hr = m_pInternalNmConference->GetState(&state);
		ASSERT(SUCCEEDED(hr));
		if (NM_CONFERENCE_IDLE != state)
		{
			return m_pInternalNmConference;
		}
	}

	// no active conference
	return NULL;
}

HRESULT CConfRoom::HostConference
(
    LPCTSTR     pcszName,
    LPCTSTR     pcszPassword,
    BOOL        fSecure,
    DWORD       permitFlags,
    UINT        maxParticipants
)
{
	HRESULT hr = E_FAIL;

	INmConference *pConf = GetActiveConference();
	if (NULL == pConf)
	{
        ULONG   uchCaps;

		INmManager2 *pNmMgr = CConfMan::GetNmManager();
		ASSERT(NULL != pNmMgr);

        uchCaps = NMCH_DATA | NMCH_SHARE | NMCH_FT;
        if (fSecure)
        {
            uchCaps |= NMCH_SECURE;
        }
        else
        {
            uchCaps |= NMCH_AUDIO | NMCH_VIDEO;
        }

		hr = pNmMgr->CreateConferenceEx(&pConf, CComBSTR(pcszName), CComBSTR(pcszPassword),
            uchCaps, permitFlags, maxParticipants);
		if (SUCCEEDED(hr))
		{
			hr = pConf->Host();
            pConf->Release();
		}
		pNmMgr->Release();
	}
	return hr;
}

BOOL CConfRoom::LeaveConference(void)
{
	BOOL fSuccess = TRUE;
	INmConference *pConf = GetActiveConference();

	if (NULL != pConf)
	{
		HCURSOR hCurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		HRESULT hr = pConf->Leave();
		::SetCursor(hCurPrev);
		fSuccess = SUCCEEDED(hr);
	}

	return fSuccess;
}


/*  F  H A S  C H I L D  N O D E S  */
/*-------------------------------------------------------------------------
    %%Function: FHasChildNodes

    Future: Check if ANY participants have this node as their parent.
-------------------------------------------------------------------------*/
BOOL CConfRoom::FHasChildNodes(void)
{
	return m_fTopProvider;
}


/*  G E T  M A I N  W I N D O W  */
/*-------------------------------------------------------------------------
    %%Function: GetMainWindow
    
-------------------------------------------------------------------------*/
HWND GetMainWindow(void)
{
	CConfRoom* pcr = ::GetConfRoom();
	if (NULL == pcr)
		return NULL;

	return pcr->GetTopHwnd();
}


BOOL FIsConferenceActive(void)
{
	CConfRoom *pcr = ::GetConfRoom();
	if (NULL != pcr)
	{
		return pcr->FIsConferenceActive();
	}
	return FALSE;
}

/****************************************************************************
*
*        FUNCTION: UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the UI (flags in cr.h)
*
****************************************************************************/
VOID UpdateUI(DWORD dwUIMask, BOOL fPostMsg)
{
	CConfRoom* pcr;
	if (NULL != (pcr = ::GetConfRoom()))
	{
		if (fPostMsg)
		{
			FORWARD_WM_COMMAND(pcr->GetTopHwnd(), ID_PRIVATE_UPDATE_UI, NULL, dwUIMask, ::PostMessage);
		}
		else
		{
			pcr->UpdateUI(dwUIMask);
		}
	}
	if (CRUI_TASKBARICON & dwUIMask)
	{
		::RefreshTaskbarIcon(::GetHiddenWindow());
	}
}


//
// Start/Stop App Sharing
//
VOID CConfRoom::StartAppSharing()
{
    HRESULT hr;

    ASSERT(!m_pAS);

    hr = CreateASObject(this, 0, &m_pAS);
    if (FAILED(hr))
    {
        ERROR_OUT(("CConfRoom: unable to start App Sharing"));
    }
}


VOID CConfRoom::TerminateAppSharing()
{
    if (m_pAS)
    {
        m_pAS->Release();
        m_pAS = NULL;
    }
}

/****************************************************************************
*
*        FUNCTION: UIEndSession(BOOL fLogoff)
*
*        PURPOSE:  Handles the WM_ENDSESSION at the UI level
*
****************************************************************************/
VOID CConfRoom::UIEndSession(BOOL fLogoff)
{
	DebugEntry(UIEndSession);
	
	CConfRoom* pcr;
	if (NULL != (pcr = ::GetConfRoom()))
	{
		TRACE_OUT(("UIEndSession: calling SaveSettings()"));
		pcr->SaveSettings();
        if (fLogoff)
        {
            pcr->TerminateAppSharing();
        }
	}
	
	DebugExitVOID(UIEndSession);
}


/****************************************************************************
*
*        FUNCTION: ConfRoomInit(HANDLE hInstance)
*
*        PURPOSE: Initializes window data and registers window class
*
****************************************************************************/

BOOL ConfRoomInit(HANDLE hInstance)
{
	// Ensure the common controls are loaded
	INITCOMMONCONTROLSEX icc;
	icc.dwSize = sizeof(icc);
	icc.dwICC = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;
	InitCommonControlsEx(&icc);

	// Fill out the standard window class settings
	WNDCLASSEX  wc;
	ClearStruct(&wc);
	wc.cbSize = sizeof(wc);
	wc.cbWndExtra = (int) sizeof(LPVOID);
	wc.hInstance = _Module.GetModuleInstance();
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hIcon = LoadIcon((HINSTANCE) hInstance, MAKEINTRESOURCE(IDI_CONFROOM));


	// Floating Toolbar
	wc.lpfnWndProc   = CFloatToolbar::FloatWndProc;
	wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	wc.lpszClassName = g_szFloatWndClass;
	RegisterClassEx(&wc);

	// Popup Messages
	wc.lpfnWndProc   = CPopupMsg::PMWndProc;
	wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	wc.lpszClassName = g_szPopupMsgWndClass;
	RegisterClassEx(&wc);

	// Make sure no one changed these on us
	ASSERT(wc.cbSize == sizeof(wc));
	ASSERT(wc.style == 0);
	ASSERT(wc.cbClsExtra == 0);
	ASSERT(wc.cbWndExtra == (int) sizeof(LPVOID));
	ASSERT(wc.hInstance == _Module.GetModuleInstance());
	ASSERT(wc.hCursor == LoadCursor(NULL, IDC_ARROW));

	return TRUE;
}


/*  C R E A T E  C O N F  R O O M  W I N D O W  */
/*-------------------------------------------------------------------------
    %%Function: CreateConfRoomWindow
    
-------------------------------------------------------------------------*/
BOOL CreateConfRoomWindow(BOOL fShowUI) 
{
	if (!g_pConfRoom)
	{
        g_pConfRoom = new CConfRoom;

		if (NULL == g_pConfRoom)
		{
			return FALSE;
		}
	}

    if (g_pConfRoom->FIsClosing())
	{
		return FALSE;
	}

	CTopWindow * pWnd = g_pConfRoom->GetTopWindow();
	if (NULL == pWnd)
	{
		g_pConfRoom->Init();
		
		HWND hwnd = g_pConfRoom->Create(fShowUI);

		if (NULL == hwnd)
		{
			return FALSE;
		}
		g_pConfRoom->UpdateUI(CRUI_TITLEBAR);
	}
	else if (fShowUI)
	{
		// Bring the window to the front
		g_pConfRoom->BringToFront();
	}

	return TRUE;
}



/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   CConfRoom()
*
*        PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CConfRoom::CConfRoom():
	m_pTopWindow                            (NULL),
	m_pAudioControl                 (NULL),
	m_cParticipants         (0),
	m_pPartLocal            (NULL),
	m_fTopProvider          (FALSE),
	m_dwConfCookie                  (0),
	m_pInternalNmConference         (NULL),
    m_pAS                           (NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CConfRoom", this);

	if (!SysPol::AllowAddingServers())
	{
		g_dwPlaceCall |= nmDlgCallNoServerEdit;
	}

	StartAppSharing();

    //
    // Initialize meeting settings to good defaults
    //
    m_fGetPermissions       = FALSE;
    m_settings              = NM_PERMIT_ALL;
    m_attendeePermissions   = NM_PERMIT_ALL;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ~CConfRoom()
*
*        PURPOSE:  Destructor
*
****************************************************************************/

CConfRoom::~CConfRoom()
{
	FreeDbgMenu();

	FreePartList();
	CleanUp();

    // Close the app...
    ::PostThreadMessage(_Module.m_dwThreadID, WM_QUIT, 0, 0);

	if (NULL != m_pTopWindow)
	{
		// Make sure we do not try this multiple times
		CTopWindow *pTopWindow = m_pTopWindow;
		m_pTopWindow = NULL;

		pTopWindow->Release();
	}

	if (!_Module.IsSDKCallerRTC() && m_pAudioControl)
	{
		delete m_pAudioControl;
		m_pAudioControl = NULL;
	}

    g_pConfRoom = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CConfRoom", this);
}

VOID CConfRoom::FreePartList(void)
{
	// Free any remaining participants
	while (0 != m_PartList.GetSize())
	{
		ASSERT(m_PartList[0]);
		OnPersonLeft(m_PartList[0]->GetINmMember());
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the appropriate pieces of the UI
*
****************************************************************************/

VOID CConfRoom::UpdateUI(DWORD dwUIMask)
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return;
	}

	pWnd->UpdateUI(dwUIMask);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Create()
*
*        PURPOSE:  Creates a window
*
****************************************************************************/

HWND CConfRoom::Create(BOOL fShowUI)
{
	ASSERT(NULL == m_pTopWindow);

	m_pTopWindow = new CTopWindow();
	if (NULL == m_pTopWindow)
	{
		return(NULL);
	}

	m_pTopWindow->Create(this, fShowUI);
	return(m_pTopWindow->GetWindow());
}

VOID CConfRoom::CleanUp()
{
	if (NULL != m_pInternalNmConference)
	{
		NmUnadvise(m_pInternalNmConference, IID_INmConferenceNotify2, m_dwConfCookie);
		m_pInternalNmConference->Release();
		m_pInternalNmConference = NULL;
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SaveSettings()
*
*        PURPOSE:  Saves UI settings in the registry
*
****************************************************************************/

VOID CConfRoom::SaveSettings()
{
	DebugEntry(CConfRoom::SaveSettings);
	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);

	if (NULL != m_pTopWindow)
	{
		m_pTopWindow->SaveSettings();
	}

	// Save window elements to the registry:
	reConf.SetValue(REGVAL_SHOW_STATUSBAR, CheckMenu_ViewStatusBar(NULL));

	// NOTE: CMainUI saves its settings in its destructor
	
	DebugExitVOID(CConfRoom::SaveSettings);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   BringToFront()
*
*        PURPOSE:  Restores the window (if minimized) and brings it to the front
*
****************************************************************************/

BOOL CConfRoom::BringToFront()
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return(FALSE);
	}

	return(pWnd->BringToFront());
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ForceWindowResize()
*
*        PURPOSE:  Handles redrawing the window after something changed
*
****************************************************************************/

VOID CConfRoom::ForceWindowResize()
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return;
	}

	pWnd->ForceWindowResize();
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnCommand(WPARAM, LPARAM)
*
*        PURPOSE:  Handles command messages
*
****************************************************************************/

void CConfRoom::OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify)
{
	switch(wCommand)
	{
		case IDM_FILE_HANGUP:
		{
			OnHangup(hwnd);
			break;
		}

        case ID_TB_SHARING:
        {
            CmdShowSharing();
            break;
        }

		case ID_TB_NEWWHITEBOARD:
		{
			CmdShowNewWhiteboard(NULL);
			break;
		}

		case ID_TB_WHITEBOARD:
		{
			CmdShowOldWhiteboard(NULL);
			break;
		}

		case ID_TB_FILETRANSFER:
		{
		    CmdShowFileTransfer();
            break;
		}

		case ID_TB_CHAT:
		{
			CmdShowChat();
			break;
		}

		case ID_TB_NEW_CALL:
		{
			CDlgAcd::newCall( hwnd, this );
		}
		break;

        case IDM_CALL_MEETINGSETTINGS:
        {
            CmdShowMeetingSettings(hwnd);
            break;
        }
	}          
}


HRESULT CConfRoom::FreeAddress( 
    RichAddressInfo **ppAddr)
{
	return CEnumMRU::FreeAddress(ppAddr);
}


HRESULT CConfRoom::CopyAddress( 
    RichAddressInfo *pAddrIn,
    RichAddressInfo **ppAddrOut)
{
	return CEnumMRU::CopyAddress(pAddrIn, ppAddrOut);
}


HRESULT CConfRoom::GetRecentAddresses( 
    IEnumRichAddressInfo **ppEnum)
{
	return CEnumMRU::GetRecentAddresses(ppEnum);
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnCallStarted()
*
*        PURPOSE:  Handles the call started event
*
****************************************************************************/

VOID CConfRoom::OnCallStarted()
{
	DebugEntry(CConfRoom::OnCallStarted);
	// notify ULS

	if(g_pLDAP)
	{
		g_pLDAP->OnCallStarted();
	}

	g_pHiddenWnd->OnCallStarted();

	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnCallStarted();
	}

	DebugExitVOID(CConfRoom::OnCallStarted);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnCallEnded()
*
*        PURPOSE:  Handles the call ended event
*
****************************************************************************/

VOID CConfRoom::OnCallEnded()
{
	DebugEntry(CConfRoom::OnCallEnded);

	if(g_pLDAP)
	{
		g_pLDAP->OnCallEnded();
	}

	if(g_pHiddenWnd)
	{
		g_pHiddenWnd->OnCallEnded();
	}

	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnCallEnded();
	}

	DebugExitVOID(CConfRoom::OnCallEnded);
}

void CConfRoom::OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnChangeParticipant(pPart, uNotify);
	}
}

void CConfRoom::OnChangePermissions()
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnChangePermissions();
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnHangup(BOOL fNeedConfirm)
*
*        PURPOSE:  Handles the action after a user chooses to hang up
*
****************************************************************************/

BOOL CConfRoom::OnHangup(HWND hwndParent, BOOL fNeedConfirm)
{
	DebugEntry(CConfRoom::OnHangup);
	
	BOOL bRet = FALSE;

	CancelAllCalls();

	if (FIsConferenceActive())
	{
		if (T120_NO_ERROR == T120_QueryApplet(APPLET_ID_FT, APPLET_QUERY_SHUTDOWN))
		{
			if ((FALSE == fNeedConfirm) ||
				(	((GetMemberCount() <= 2) ||
					(FALSE == FHasChildNodes()))) ||
				(IDYES == ::ConfMsgBox( hwndParent, 
										(LPCTSTR) IDS_HANGUP_ATTEMPT, 
										MB_YESNO | MB_ICONQUESTION)))
			{
				// BUGBUG: Should we wait for the async response?
				bRet = (0 == LeaveConference());
			}
		}
	}

	DebugExitBOOL(CConfRoom::OnHangup, bRet);

	return bRet;
}

/*  C H E C K  T O P  P R O V I D E R  */
/*-------------------------------------------------------------------------
    %%Function: CheckTopProvider
    
-------------------------------------------------------------------------*/
VOID CConfRoom::CheckTopProvider(void)
{
	if ((NULL == m_pInternalNmConference) || (NULL == m_pPartLocal))
		return;

	INmMember * pMember;
	if (S_OK != m_pInternalNmConference->GetTopProvider(&pMember))
		return;
	ASSERT(NULL != pMember);

	if (m_pPartLocal->GetINmMember() == pMember)
	{
		m_fTopProvider      = TRUE;
	}

    if (m_fGetPermissions)
    {
        ASSERT(m_settings            == NM_PERMIT_ALL);
        ASSERT(m_attendeePermissions == NM_PERMIT_ALL);

        m_fGetPermissions = FALSE;

        //
        // Get the meeting settings from the top provider
        //
        PBYTE pb = NULL;
        ULONG cb = 0;

        if (pMember->GetUserData(g_csguidMeetingSettings, &pb, &cb) == S_OK)
        {
            ASSERT(cb == sizeof(NM30_MTG_PERMISSIONS));
            CopyMemory(&m_settings, pb, min(cb, sizeof(m_settings)));

            CoTaskMemFree(pb);

            WARNING_OUT(("CONF:  Meeting host set permissions 0%08lx",
                m_settings));

            if (!m_fTopProvider)
            {
                //
                // The meeting settings are permissions for everybody else
                // besides the top provider.
                //
                m_attendeePermissions = m_settings;

                if (m_attendeePermissions != NM_PERMIT_ALL)
                {
        			OnChangePermissions();

                    // Bring up meeting settings
                    PostMessage(GetTopHwnd(), WM_COMMAND, IDM_CALL_MEETINGSETTINGS, 0);
                }

            }

        }
    }

}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnPersonJoined(PPARTICIPANT pPart)
*
*        PURPOSE:  Notification - new person has joined the call
*
****************************************************************************/

BOOL CConfRoom::OnPersonJoined(INmMember * pMember)
{
	CParticipant * pPart = new CParticipant(pMember);
	if (NULL == pPart)
	{
		WARNING_OUT(("CConfRoom::OnPersonJoined - Unable to create participant"));
		return FALSE;
	}
	m_PartList.Add(pPart);
	++m_cParticipants;
	if (1 == m_cParticipants)
	{
		OnCallStarted();
	}
	TRACE_OUT(("CConfRoom::OnPersonJoined - Added participant=%08X", pPart));

	OnChangeParticipant(pPart, NM_MEMBER_ADDED);

	// Popup a notification (if it isn't us)
	if (!pPart->FLocal())
	{
        TCHAR szSound[256];

        //
        // Play the "somebody joined" sound
        //
        ::LoadString(::GetInstanceHandle(), IDS_PERSON_JOINED_SOUND,
            szSound, CCHMAX(szSound));
        if (!::PlaySound(szSound, NULL, 
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
    	{
	    	// Use the computer speaker to beep:
		    TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
    		::MessageBeep(0xFFFFFFFF);
	    }
	}
	else
	{
		m_pPartLocal = pPart;
		CheckTopProvider();
	}

	// Title bar shows number of people in conference
	UpdateUI(CRUI_TITLEBAR);

	return TRUE;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnPersonLeft(PPARTICIPANT pPart)
*
*        PURPOSE:  Notification - person has left the call
*
****************************************************************************/

BOOL CConfRoom::OnPersonLeft(INmMember * pMember)
{
	// Find the macthing participant
	CParticipant* pPart = NULL;

	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		pPart = m_PartList[i];
		ASSERT(pPart);
		if( pPart->GetINmMember() == pMember )
		{	
			m_PartList.RemoveAt(i);
			--m_cParticipants;
			if (0 == m_cParticipants)
			{
				OnCallEnded();
			}
			break;
		}
	}

	if (NULL == pPart)
	{
		WARNING_OUT(("Unable to find participant for INmMember=%08X", pMember));
		return FALSE;
	}

	OnChangeParticipant(pPart, NM_MEMBER_REMOVED);

	// Popup a notification (if it isn't us)
	if (!pPart->FLocal())
	{
        TCHAR szSound[256];

        //
        // Play the "somebody left" sound
        //
        ::LoadString(::GetInstanceHandle(), IDS_PERSON_LEFT_SOUND,
            szSound, CCHMAX(szSound));
	    if (!::PlaySound(szSound, NULL, 
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
    	{
	    	// Use the computer speaker to beep:
		    TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
    		::MessageBeep(0xFFFFFFFF);
	    }
	}
	else
	{
		m_pPartLocal = NULL;
		m_fTopProvider = FALSE;
	}

	// Title bar shows number of people in conference
	UpdateUI(CRUI_TITLEBAR);

	// Finally, release the object
	TRACE_OUT(("CConfRoom::OnPersonLeft - Removed participant=%08X", pPart));
	pPart->Release();
	return TRUE;
}


/*  O N  P E R S O N  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnPersonChanged
    
	Notification - a person's information has changed
-------------------------------------------------------------------------*/
VOID CConfRoom::OnPersonChanged(INmMember * pMember)
{
	DBGENTRY(CConfRoom::OnPersonChanged);

	CParticipant * pPart = ParticipantFromINmMember(pMember);
	if (NULL == pPart)
		return;

	pPart->AddRef();
	pPart->Update();
	if (m_fTopProvider && !pPart->FData())
	{
		// Can't be the top provider if there are no data caps
		m_fTopProvider = FALSE;
	}

	if (pPart->FLocal() && !m_fTopProvider)
	{
		// if H.323-only adds T.120, then we may be the top provider
		CheckTopProvider();
	}
	
	OnChangeParticipant(pPart, NM_MEMBER_UPDATED);

	pPart->Release();
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Init()
*
*        PURPOSE:  Object initialization function
*
****************************************************************************/

BOOL CConfRoom::Init()
{
	if (!_Module.IsSDKCallerRTC())
	{
        	m_pAudioControl = new CAudioControl(GetHiddenWindow());
	}
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->RegisterAudioEventHandler(this);
	}


	return (TRUE);
}



VOID CConfRoom::SetSpeakerVolume(DWORD dwLevel)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->SetSpeakerVolume(dwLevel);
		m_pAudioControl->RefreshMixer();
	}
}

VOID CConfRoom::SetRecorderVolume(DWORD dwLevel)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->SetRecorderVolume(dwLevel);
		m_pAudioControl->RefreshMixer();
	}
}

VOID CConfRoom::MuteSpeaker(BOOL fMute)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->MuteAudio(TRUE /* fSpeaker */, fMute);
	}
}

VOID CConfRoom::MuteMicrophone(BOOL fMute)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->MuteAudio(FALSE /* fSpeaker */, fMute);
	}
}

VOID CConfRoom::OnAudioDeviceChanged()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnDeviceChanged();
	}
}

VOID CConfRoom::OnAGC_Changed()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnAGC_Changed();
	}
}

VOID CConfRoom::OnSilenceLevelChanged()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnSilenceLevelChanged();
	}
}



DWORD CConfRoom::GetConferenceStatus(LPTSTR pszStatus, int cchMax, UINT * puID)
{
	ASSERT(NULL != pszStatus);
	ASSERT(NULL != puID);
	ASSERT(cchMax > 0);

	// Check global conference status
	if ( INmConference *pConf = GetActiveConference() )
	{
		// We are in a call.  Find out if it's secure.
		DWORD dwCaps;
		if ( S_OK == pConf->GetNmchCaps(&dwCaps) &&
			( NMCH_SECURE & dwCaps ) )
		{
			*puID = IDS_STATUS_IN_SECURE_CALL;
		}
		else
		{
			*puID = IDS_STATUS_IN_CALL;
		}
	}
	else if (::FDoNotDisturb())
	{
		*puID = IDS_STATUS_DO_NOT_DISTURB;
	}
	else
	{
		*puID = IDS_STATUS_NOT_IN_CALL;
	}
	
#if FALSE
	// We may need to find a new way of doing this if this is still useful info
#ifdef DEBUG
	if (g_fDisplayViewStatus)
	{
		int iCount = (NULL == m_pView) ? LB_ERR :
				ListView_GetItemCount(m_pView->GetHwnd());

		wsprintf(pszStatus, TEXT("%d items"), iCount);
		ASSERT(lstrlen(pszStatus) < cchMax);
	}
	else
#endif /* DEBUG */
#endif // FALSE

	if (0 == ::LoadString(::GetInstanceHandle(), *puID, pszStatus, cchMax))
	{
		WARNING_OUT(("Unable to load string resource=%d", *puID));
		*pszStatus = _T('\0');
	}
	return 0;
}



/*  P A R T I C I P A N T  F R O M  I  N M  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: ParticipantFromINmMember
    
-------------------------------------------------------------------------*/
CParticipant * CConfRoom::ParticipantFromINmMember(INmMember * pMember)
{
	CParticipant *pRet = NULL;
	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		ASSERT( m_PartList[i] );
		if( m_PartList[i]->GetINmMember() == pMember )
		{
			pRet = m_PartList[i];
			break;
		}
		else
		{
			pRet = NULL;
		}
	}
	return pRet;
}

/*  G E T  H 3 2 3  R E M O T E  */
/*-------------------------------------------------------------------------
    %%Function: GetH323Remote
    
    Get the matching H.323 remote user, if there is one
-------------------------------------------------------------------------*/
CParticipant * CConfRoom::GetH323Remote(void)
{
	CParticipant *pRet = NULL;
	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		pRet = m_PartList[i];
		ASSERT( pRet );
		if (!pRet->FLocal() && pRet->FH323())
		{
			break;
		}
		else
		{
			pRet = NULL;
		}
	}
	return pRet;
}


STDMETHODIMP_(ULONG) CConfRoom::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CConfRoom::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConfRoom::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmConferenceNotify) || (riid == IID_INmConferenceNotify2) ||
		(riid == IID_IUnknown))
	{
		*ppv = (INmConferenceNotify2 *)this;
		ApiDebugMsg(("CConfRoom::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfRoom::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CConfRoom::NmUI(CONFN uNotify)
{
	return S_OK;
}


STDMETHODIMP CConfRoom::OnConferenceCreated(INmConference *pConference)
{
	HRESULT hr = S_OK;
	DBGENTRY(CConfRoom::OnConferenceCreated);

	if (NULL != m_pInternalNmConference)
	{
		NmUnadvise(m_pInternalNmConference, IID_INmConferenceNotify2, m_dwConfCookie);
		m_pInternalNmConference->Release();
	}

	pConference->QueryInterface(IID_INmConference2, (void**)&m_pInternalNmConference);
	NmAdvise(m_pInternalNmConference, (INmConferenceNotify2*)this, IID_INmConferenceNotify2, &m_dwConfCookie);

	DBGEXIT_HR(CConfRoom::OnConferenceCreated,hr);
	return hr;
}


STDMETHODIMP CConfRoom::StateChanged(NM_CONFERENCE_STATE uState)
{
	static BOOL s_fInConference = FALSE;

	UpdateUI(CRUI_DEFAULT);

	switch (uState)
		{
	case NM_CONFERENCE_IDLE:
	{
		if (s_fInConference)
		{
			CNetMeetingObj::Broadcast_ConferenceEnded();
			s_fInConference = FALSE;

            //
            // Reset meeting settings
            //
            m_fGetPermissions                       = FALSE;
            m_settings                              = NM_PERMIT_ALL;
            m_attendeePermissions                   = NM_PERMIT_ALL;

			OnChangePermissions();

            //
            // If the call ends, kill the host properties if they are up.
            //
            CDlgHostSettings::KillHostSettings();
		}
		UpdateUI(CRUI_STATUSBAR);
		break;
	}

	case NM_CONFERENCE_INITIALIZING:
		break;
	case NM_CONFERENCE_WAITING:
	case NM_CONFERENCE_ACTIVE:
	default:
	{
		if (!s_fInConference)
		{
				// Start a new conference session
			CFt::StartNewConferenceSession();

			CNetMeetingObj::Broadcast_ConferenceStarted();

			s_fInConference     = TRUE;
            m_fGetPermissions   = TRUE;
		}
		break;
	}
		}


	return S_OK;
}

STDMETHODIMP CConfRoom::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	switch (uNotify)
	{
	case NM_MEMBER_ADDED:
		OnPersonJoined(pMember);
		break;
	case NM_MEMBER_REMOVED:
		OnPersonLeft(pMember);
		break;
	case NM_MEMBER_UPDATED:
		OnPersonChanged(pMember);
		break;
	}
	return S_OK;
}

STDMETHODIMP CConfRoom::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	ULONG nmch;


	if (SUCCEEDED(pChannel->GetNmch(&nmch)))
	{
		TRACE_OUT(("CConfRoom:ChannelChanged type=%08X", nmch));
		switch (nmch)
		{
		case NMCH_AUDIO:
			if (NULL != m_pAudioControl)
			{
				m_pAudioControl->OnChannelChanged(uNotify, pChannel);

						// Notify the Manager object of the audio channels active state
				CNmManagerObj::AudioChannelActiveState(S_OK == pChannel->IsActive(), S_OK == com_cast<INmChannelAudio>(pChannel)->IsIncoming());
			}

			break;
		case NMCH_VIDEO:
		{
			EnterCriticalSection(&dialogListCriticalSection);
			CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
			LeaveCriticalSection(&dialogListCriticalSection);

			// BUGBUG georgep: I guess one of these things could go away after
			// we get the list, but I doubt it will ever happen
			for( int i = 0; i < tempList.GetSize(); ++i )
			{
				IConferenceChangeHandler *pHandler = tempList[i];
				ASSERT( NULL != pHandler );

				pHandler->OnVideoChannelChanged(uNotify, pChannel);
			}
			break;
		}
		default:
			break;
		}
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfRoom::StreamEvent( 
            /* [in] */ NM_STREAMEVENT uEvent,
            /* [in] */ UINT uSubCode,
            /* [in] */ INmChannel __RPC_FAR *pChannel)
{
	return S_OK;
}


/*  C M D  S H O W  C H A T  */
/*-------------------------------------------------------------------------
	%%Function: CmdShowChat
    
-------------------------------------------------------------------------*/
VOID CmdShowChat(void)
{
	T120_LoadApplet(APPLET_ID_CHAT, TRUE , 0, FALSE, NULL);
}


//
// CmdShowFileTransfer()
//
void CConfRoom::CmdShowFileTransfer(void)
{
    ::T120_LoadApplet(APPLET_ID_FT, TRUE, 0, FALSE, NULL);
}


//
// CmdShowSharing()
//
void CConfRoom::CmdShowSharing()
{
    LaunchHostUI();
}


/*  C M D  S H O W  N E W W H I T E B O A R D  */
/*-------------------------------------------------------------------------
	%%Function: CmdShowNewWhiteboard
    
-------------------------------------------------------------------------*/
BOOL CmdShowNewWhiteboard(LPCTSTR szFile)
{
	return ::T120_LoadApplet(APPLET_ID_WB, TRUE , 0, FALSE, (LPSTR)szFile);
	
}


/*  C M D  S H O W  W H I T E B O A R D  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowOldWhiteboard
    
-------------------------------------------------------------------------*/
extern "C" { BOOL WINAPI StartStopOldWB(LPCTSTR lpsz); }

BOOL CmdShowOldWhiteboard(LPCTSTR szFile)
{
    return(StartStopOldWB(szFile));
}


//
// CmdShowMeetingSettings()
//
void CConfRoom::CmdShowMeetingSettings(HWND hwnd)
{
    INmConference2 * pConf;

    pConf = GetActiveConference();
    if (pConf)
    {
        DWORD   caps;
        HRESULT hr;
        BSTR    bstrName;
        LPTSTR  pszName = NULL;

        caps = 0;
        pConf->GetNmchCaps(&caps);

        bstrName = NULL;
        hr = pConf->GetName(&bstrName);
        if (SUCCEEDED(hr))
        {
            BSTR_to_LPTSTR(&pszName, bstrName);
            SysFreeString(bstrName);
        }

        CDlgHostSettings dlgSettings(FTopProvider(), pszName, caps, m_settings);
        dlgSettings.DoModal(hwnd);

        delete pszName;
    }
}



///////////////////////////////////////////////////////////////////////////

/*  F  T O P  P R O V I D E R  */
/*-------------------------------------------------------------------------
    %%Function: FTopProvider
    
-------------------------------------------------------------------------*/
BOOL FTopProvider(void)
{
	CConfRoom * pConfRoom = ::GetConfRoom();
	if (NULL == pConfRoom)
		return FALSE;

	return pConfRoom->FTopProvider();
}


BOOL FRejectIncomingCalls(void)
{
	BOOL bReject = TRUE;
	
	if (!FDoNotDisturb())
	{
		CConfRoom * pConfRoom = ::GetConfRoom();

		if( ( NULL == pConfRoom ) ||
            ((pConfRoom->GetMeetingPermissions() & NM_PERMIT_INCOMINGCALLS) &&
                !pConfRoom->FIsClosing()))
		{

			bReject = FALSE;
		}
	}
	
	return bReject;
}

BOOL CConfRoom::FIsClosing()
{
	return(NULL == m_pTopWindow ? FALSE : m_pTopWindow->FIsClosing());
}

BOOL FIsConfRoomClosing(void)
{
	CConfRoom * pConfRoom = ::GetConfRoom();
	if (NULL == pConfRoom)
		return FALSE;

	return pConfRoom->FIsClosing();
}


/*static*/ HRESULT CConfRoom::HangUp(BOOL bUserPrompt)
{
	DBGENTRY(CConfRoom::HangUp);
	HRESULT hr = S_OK;

	if(g_pConfRoom)
	{
		g_pConfRoom->OnHangup(g_pConfRoom->GetTopHwnd(), bUserPrompt);
	}

	DBGEXIT_HR(CConfRoom::HangUp,hr);
	return hr;
}

BOOL AllowingControl()
{
	BOOL bRet = FALSE;
	if(g_pConfRoom)
	{
        bRet = g_pConfRoom->FIsControllable();
	}
	return bRet;
}

HRESULT AllowControl(bool bAllowControl)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->AllowControl(bAllowControl);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}


bool IsSpeakerMuted()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->IsSpkMuted() ? true : false;
	}

	return true;
}


bool IsMicMuted()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->IsRecMuted() ? true : false;
	}

	return true;
}


CVideoWindow*	GetLocalVideo()
{
	if(g_pConfRoom && g_pConfRoom->m_pTopWindow)
	{
		return g_pConfRoom->m_pTopWindow->GetLocalVideo();
	}

	return NULL;
}


CVideoWindow*	GetRemoteVideo()
{
	if(g_pConfRoom && g_pConfRoom->m_pTopWindow)
	{
		return g_pConfRoom->m_pTopWindow->GetRemoteVideo();
	}

	return NULL;
}


HRESULT SetCameraDialog(ULONG ul)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->SetCameraDialog(ul);
	}

	return E_FAIL;
}

HRESULT GetCameraDialog(ULONG* pul)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->GetCameraDialog(pul);
	}

	return E_FAIL;
}


HRESULT GetImageQuality(ULONG* pul, BOOL bIncoming)
{
	if(bIncoming)
	{
		if(GetRemoteVideo())
		{
			*pul = GetRemoteVideo()->GetImageQuality();
			return S_OK;
		}
	}
	else
	{
		if(GetLocalVideo())
		{
			*pul = GetLocalVideo()->GetImageQuality();
			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT SetImageQuality(ULONG ul, BOOL bIncoming)
{
	if(bIncoming)
	{
		if(GetRemoteVideo())
		{
			return GetRemoteVideo()->SetImageQuality(ul);
		}
	}
	else
	{
		if(GetLocalVideo())
		{
			return GetLocalVideo()->SetImageQuality(ul);
		}
	}

	return E_FAIL;
}



BOOL IsLocalVideoPaused()
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->IsPaused();
	}

	return true;
}


BOOL IsRemoteVideoPaused()
{
	if(GetRemoteVideo())
	{
		return GetRemoteVideo()->IsPaused();
	}

	return true;
}

void PauseLocalVideo(BOOL fPause)
{
	if(GetLocalVideo())
	{
		GetLocalVideo()->Pause(fPause);
	}
}

void PauseRemoteVideo(BOOL fPause)
{
	if(GetRemoteVideo())
	{
		GetRemoteVideo()->Pause(fPause);
	}
}

HRESULT GetRemoteVideoState(NM_VIDEO_STATE *puState)
{
	if(GetRemoteVideo())
	{
		return GetRemoteVideo()->GetVideoState(puState);
	}

	return E_FAIL;
}

HRESULT GetLocalVideoState(NM_VIDEO_STATE *puState)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->GetVideoState(puState);
	}

	return E_FAIL;
}

void MuteSpeaker(BOOL fMute)
{
	if(g_pConfRoom)
	{
		g_pConfRoom->MuteSpeaker(fMute);
	}
}

void MuteMicrophone(BOOL fMute)
{
	if(g_pConfRoom)
	{
		g_pConfRoom->MuteMicrophone(fMute);
	}
}


DWORD GetRecorderVolume()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->GetRecorderVolume();
	}

	return 0;
}

DWORD GetSpeakerVolume()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->GetSpeakerVolume();
	}

	return 0;
}

void SetRecorderVolume(DWORD dw)
{
	if(g_pConfRoom) 
	{
		g_pConfRoom->SetRecorderVolume(dw);
	}
}


void SetSpeakerVolume(DWORD dw)
{
	if(g_pConfRoom) 
	{
		g_pConfRoom->SetSpeakerVolume(dw);
	}
}

HRESULT RevokeControl(UINT gccID)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->RevokeControl(gccID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->GetShareableApps(ppList);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT FreeShareableApps(IAS_HWND_ARRAY * pList)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		g_pConfRoom->FreeShareableApps(pList);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT ShareWindow(HWND hWnd)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(g_pConfRoom)
	{
		if(g_pConfRoom->GetAppSharing())
		{
			hr = g_pConfRoom->CmdShare(hWnd);
		}
	}

	return hr;
}

HRESULT UnShareWindow(HWND hWnd)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(g_pConfRoom)
	{
		if(g_pConfRoom->GetAppSharing())
		{
			hr = g_pConfRoom->CmdUnshare(hWnd);
		}
	}

	return hr;
}


HRESULT GetWindowState(NM_SHAPP_STATE* pState, HWND hWnd)
{
	HRESULT hr = E_FAIL;
		// We don't do error checking, the caller must check for valid ptr.
	ASSERT(pState);

	if(g_pConfRoom)
	{
		IAppSharing* pAS = g_pConfRoom->GetAppSharing();

		if(pAS)
		{
            if (pAS->IsWindowShared(hWnd))
                *pState = NM_SHAPP_SHARED;
            else
                *pState = NM_SHAPP_NOT_SHARED;
            hr = S_OK;
		}
	}

	return hr;
}

CVideoWindow* CConfRoom::GetLocalVideo()
{
	CTopWindow *pMainUI = GetTopWindow();
	return (pMainUI ? pMainUI->GetLocalVideo() : NULL);
}

CVideoWindow* CConfRoom::GetRemoteVideo()
{
	CTopWindow *pMainUI = GetTopWindow();
	return (pMainUI ? pMainUI->GetRemoteVideo() : NULL);
}

VOID CConfRoom::AddConferenceChangeHandler(IConferenceChangeHandler *pch)
{
	EnterCriticalSection(&dialogListCriticalSection);
	m_CallHandlerList.Add(pch);
	LeaveCriticalSection(&dialogListCriticalSection);
}

VOID CConfRoom::RemoveConferenceChangeHandler(IConferenceChangeHandler *pch)
{
	EnterCriticalSection(&dialogListCriticalSection);
	m_CallHandlerList.Remove(pch);
	LeaveCriticalSection(&dialogListCriticalSection);
}

void CConfRoom::OnLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnAudioLevelChange(fSpeaker, dwVolume);
	}
}

void CConfRoom::OnMuteChange(BOOL fSpeaker, BOOL fMute)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnAudioMuteChange(fSpeaker, fMute);
	}
}

BOOL CConfRoom::CanCloseChat(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_CHAT, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}

// Check to see if WB can close
BOOL CConfRoom::CanCloseWhiteboard(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_WB, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}

// Check to see if WB can close
BOOL CConfRoom::CanCloseFileTransfer(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_FT, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}


void CConfRoom::ToggleLdapLogon()
{
	if(NULL == g_pLDAP)
	{
		InitNmLdapAndLogon();
	}
	else 
	{
		if(g_pLDAP->IsLoggedOn() || g_pLDAP->IsBusy())
		{
			g_pLDAP->Logoff();
		}
		else
		{
			g_pLDAP->LogonAsync();
		}
	}
}


HWND CConfRoom::GetTopHwnd()
{
	CTopWindow *pTopWindow = GetTopWindow();
	return(NULL==pTopWindow ? NULL : pTopWindow->GetWindow());
}

HPALETTE CConfRoom::GetPalette()
{
	return(CGenWindow::GetStandardPalette());
}

DWORD CConfRoom::GetCallFlags()
{
	DWORD dwFlags = g_dwPlaceCall;

	INmConference *pConf = GetActiveConference();
                             
    //
    // If we have an active conference, use its security caps.  And they
    // can not be altered by anyone.
    //
	if ( NULL != pConf  )
	{
    	ULONG ulchCaps;

		if ( S_OK == pConf->GetNmchCaps(&ulchCaps))
		{
			if ( NMCH_SECURE & ulchCaps )
			{
				dwFlags |= nmDlgCallSecurityOn;
			}
		}
	}
	else if (NULL != g_pNmSysInfo)
	{
        switch (ConfPolicies::GetSecurityLevel())
        {
            case DISABLED_POL_SECURITY:
                //
                // Security off, and user can't change checkbox
                //
                break;

            case REQUIRED_POL_SECURITY:
                //
                // Security on, and user can't change checkbox
                //
                dwFlags |= nmDlgCallSecurityOn;
                break;

            default:
                //
                // User can change it.
                dwFlags |= nmDlgCallSecurityAlterable;

                //
                // Default depends on OUTGOING_PREFFERED
                //
                if (ConfPolicies::OutgoingSecurityPreferred())
                {
                    dwFlags |= nmDlgCallSecurityOn;
                }
                break;
        }
	}

	return(dwFlags);
}

BOOL CConfRoom::IsSharingAllowed()
{
    //
    // No app sharing, no RDS.
    //
    if (!FIsSharingAvailable())
    {
        return(FALSE);
    }
    else if (!(GetMeetingPermissions() & NM_PERMIT_SHARE))
    {
        return(FALSE);
    }

	return(TRUE);
}

BOOL CConfRoom::IsNewWhiteboardAllowed()
{
    if (ConfPolicies::IsNewWhiteboardEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTWB)
        {
            return(TRUE);
        }
	}
	return(FALSE);
}

BOOL CConfRoom::IsOldWhiteboardAllowed()
{
    if (ConfPolicies::IsOldWhiteboardEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTOLDWB)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}

BOOL CConfRoom::IsChatAllowed()
{
    if (ConfPolicies::IsChatEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTCHAT)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}

BOOL CConfRoom::IsFileTransferAllowed()
{
    if (ConfPolicies::IsFileTransferEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_SENDFILES)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}


BOOL CConfRoom::IsNewCallAllowed()
{
    if (GetMeetingPermissions() & NM_PERMIT_OUTGOINGCALLS)
    {
        return(TRUE);
    }
    return(FALSE);
}


//--------------------------------------------------------------------------//
//	CConfRoom::get_securitySettings.										//
//--------------------------------------------------------------------------//
void
CConfRoom::get_securitySettings
(
	bool &	userAlterable,
	bool &	secure
){
	INmConference *	activeConference	= (g_pConfRoom != NULL)? g_pConfRoom->GetActiveConference(): NULL;

	if( activeConference != NULL )
	{
		ULONG	conferenceCaps;

		if( activeConference->GetNmchCaps( &conferenceCaps ) == S_OK )
		{
			secure = ((conferenceCaps & NMCH_SECURE) != 0);
		}
		else
		{
			ERROR_OUT( ("Bad conference") );

			secure = false;		//	Is there really a reasonable default???
		}

		userAlterable = false;
	}
	else
	{
        switch( ConfPolicies::GetSecurityLevel() )
        {
            case DISABLED_POL_SECURITY:
			{
				secure			= false;
				userAlterable	= false;
			}
			break;

            case REQUIRED_POL_SECURITY:
			{
				secure			= true;
				userAlterable	= false;
			}
			break;

            default:
			{
                secure			= ConfPolicies::OutgoingSecurityPreferred();
				userAlterable	= true;
			}
			break;
        }
	}

}	//	End of CConfRoom::get_securitySettings.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confpolicies.h ===
#ifndef __ConfPolicies_h__
#define __ConfPolicies_h__

#include "resource.h"
#include "ConfUtil.h"
#include "ConfReg.h"

extern bool g_bAutoAccept;

namespace ConfPolicies
{

#if USE_GAL
		inline bool IsGetMyInfoFromGALEnabled( void )
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return rePol.GetNumber( REGVAL_POL_GAL_USE, DEFAULT_POL_GAL_USE ) ? true : false ;
		}

		inline bool GetMyInfoFromGALSucceeded( void )
		{
			RegEntry reIsapi( ISAPI_KEY, HKEY_CURRENT_USER );
			if( NULL == reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) ||
				NULL == reIsapi.GetString( REGVAL_ULS_LAST_NAME ) ||
				NULL == reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) )
			{
				return false;
			}
			else
			{
				return true;
			}
		}

		inline DWORD GetGALName()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_NAME, DEFAULT_POL_GAL_NAME );
		}

		inline DWORD GetGALSurName()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_SURNAME, DEFAULT_POL_GAL_SURNAME );
		}

		inline DWORD GetGALEmail()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_EMAIL, DEFAULT_POL_GAL_EMAIL );
		}

		inline DWORD GetGALLocation()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_LOCATION, DEFAULT_POL_GAL_LOCATION );
		}

		inline DWORD GetGALPhoneNum()
		{

			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_PHONENUM, DEFAULT_POL_GAL_PHONENUM );
		}

		inline DWORD GetGALComment()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_COMMENTS, DEFAULT_POL_GAL_COMMENTS );
		}
#endif // USE_GAL
	inline bool IsShowFirstTimeUrlEnabled( void )
	{
		RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
		return rePol.GetNumber( REGVAL_POL_SHOW_FIRST_TIME_URL, DEFAULT_POL_SHOW_FIRST_TIME_URL ) ? true : false;
	}

    inline bool IsChatEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_CHAT, DEFAULT_POL_NO_CHAT );
    }

    inline bool IsFileTransferEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return(!rePol.GetNumber( REGVAL_POL_NO_FILETRANSFER_SEND, DEFAULT_POL_NO_FILETRANSFER_SEND)
          ||   !rePol.GetNumber( REGVAL_POL_NO_FILETRANSFER_RECEIVE, DEFAULT_POL_NO_FILETRANSFER_RECEIVE));
    }

    inline UINT GetMaxSendFileSize( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return(rePol.GetNumber(REGVAL_POL_MAX_SENDFILESIZE, DEFAULT_POL_MAX_FILE_SIZE));
    }

    inline bool IsOldWhiteboardEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_OLDWHITEBOARD, DEFAULT_POL_NO_OLDWHITEBOARD );
    }

    inline bool IsNewWhiteboardEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_NEWWHITEBOARD, DEFAULT_POL_NO_NEWWHITEBOARD );
    }

	// Returns true if need to add LCID stuff
    inline bool GetIntranetSupportURL( TCHAR *sz, int cchmax )
    {
		bool bRet = false;

            // if the string params are messed up, just return false
        ASSERT( sz && ( cchmax > 0 ) );

            // Try to get the registry value
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        LPCTSTR szTemp = rePol.GetString( REGVAL_POL_INTRANET_SUPPORT_URL );

        if( szTemp[0] )
        {
            // This means that the registry value is there and the query succeeded
            lstrcpyn( sz, szTemp, cchmax );
        }
        else
        {       // There is no reg key, we use the default
            Res2THelper( IDS_WEB_PAGE_FORMAT_SUPPORT, sz, cchmax );
			bRet = true;
        }

		return(bRet);
    }

	// Returns non-empty strings if there is a web dir set by policy
    bool GetWebDirInfo(
		LPTSTR szURL=NULL, int cchmaxURL=0,
		LPTSTR szServer=NULL, int cchmaxServer=0,
		LPTSTR szName=NULL, int cchmaxName=0
		);

    bool IsAutoAcceptCallsOptionEnabled(void);
    bool IsAutoAcceptCallsPersisted(void);
    bool IsAutoAcceptCallsEnabled(void);
    void SetAutoAcceptCallsEnabled(bool bAutoAccept);

	inline int GetSecurityLevel(void)
	{
    	RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
	   	return reConf.GetNumber( REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY);
	}

    //
    // These two are ONLY the end-user setting.  They are not meaningful
    // if the security level is required or disabled, only standard.
    //
    inline bool IncomingSecurityRequired(void)
    {
        RegEntry reIncoming(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return(reIncoming.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED, DEFAULT_SECURITY_INCOMING_REQUIRED) != 0);
    }

    inline bool OutgoingSecurityPreferred(void)
    {
        RegEntry reOutgoing(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return(reOutgoing.GetNumber(REGVAL_SECURITY_OUTGOING_PREFERRED, DEFAULT_SECURITY_OUTGOING_PREFERRED) != 0);
    }


	inline bool IsFullDuplexAllowed(void)
	{
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_FULLDUPLEX, DEFAULT_POL_NO_FULLDUPLEX );
	}

	inline bool IsAdvancedAudioEnabled(void)
	{
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_ADVAUDIO, DEFAULT_POL_NO_ADVAUDIO);
	}

	inline bool GetLocalConferenceParticipantName( TCHAR *sz, int cchmax )
	{

            // if the string params are messed up, just return false
        if( sz && ( cchmax > 0 ) )
        {
                // Try to get the registry value
	     	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		    LPCTSTR szTemp = reULS.GetString( REGVAL_ULS_EMAIL_NAME );

            if( szTemp[0] )
            {
                // This means that the registry value is there and the query succeeded
                lstrcpyn( sz, szTemp, cchmax );
            }
            else
            {       // There is no reg key, we use the default
                lstrcpy( sz, _T("Error, no local user") );
            }
        }
        else
        {   
            return false;
        }

        return true;

	}

	enum eCallingMode { CallingMode_Direct, CallingMode_GateKeeper, CallingMode_Invalid };

	inline eCallingMode GetCallingMode(void)
	{
		eCallingMode eRet = CallingMode_Invalid;
		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        switch( reConf.GetNumber( REGVAL_CALLING_MODE, CALLING_MODE_DIRECT) )
		{
			case CALLING_MODE_DIRECT:
				eRet = CallingMode_Direct;
				break;

			case CALLING_MODE_GATEKEEPER:
				eRet = CallingMode_GateKeeper;
				break;
		}

		return eRet;
	}
	
	inline void GetGKServerName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			lstrcpyn( psz, reConf.GetString(REGVAL_GK_SERVER), cch );
		}
	}

	inline void GetGKAccountName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry	reULS( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

			lstrcpyn( psz, reULS.GetString( REGVAL_ULS_GK_ACCOUNT), cch );
		}
	}

    inline BOOL UserCanChangeCallMode(void)
    {
        RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
        return !reConf.GetNumber(REGVAL_POL_NOCHANGECALLMODE, DEFAULT_POL_NOCHANGECALLMODE);
    }

	inline void GetGatewayServerName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			lstrcpyn( psz, reConf.GetString(REGVAL_GK_SERVER), cch );
		}
	}


	
	enum eGKAddressingMode { GKAddressing_Invalid = 0, GKAddressing_PhoneNum, GKAddressing_Account, GKAddressing_Both };

	inline eGKAddressingMode GetGKAddressingMode(void)
	{
		RegEntry			reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );
		eGKAddressingMode	mode	= GKAddressing_Invalid;

        switch( reConf.GetNumber( REGVAL_GK_METHOD, GKAddressing_Invalid ) )
		{
			case GK_LOGON_USING_PHONENUM:
				mode = GKAddressing_PhoneNum;
				break;

			case GK_LOGON_USING_ACCOUNT:
				mode = GKAddressing_Account;
				break;

			case GK_LOGON_USING_BOTH:
				mode = GKAddressing_Both;
				break;
		}

		return( mode );
	}


	inline bool LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode(void)
	{
        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return !reConf.GetNumber( REGVAL_DONT_LOGON_ULS, DONT_LOGON_ULS_DEFAULT);
	}

	inline bool LogOntoIlsWhenNetMeetingStarts(void)
	{
		return ((ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct) &&
		    (LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode()));
	}

	inline bool RunWhenWindowsStarts(void)
	{
        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return (0 != reConf.GetNumber(REGVAL_CONF_ALWAYS_RUNNING, ALWAYS_RUNNING_DEFAULT));
	}

	inline bool InvalidMyInfo()
	{
        RegEntry reIsapi(ISAPI_KEY, HKEY_CURRENT_USER);

		return ( 
				( NULL == reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) ) ||
				( NULL == reIsapi.GetString( REGVAL_ULS_LAST_NAME )  ) ||
				( NULL == reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) )
				);
	}

	inline bool IsRDSDisabled()
	{
        RegEntry rePol( POLICIES_KEY, HKEY_LOCAL_MACHINE );
        return(rePol.GetNumber( REGVAL_POL_NO_RDS, DEFAULT_POL_NO_RDS ) != FALSE);
	}

    inline bool IsRDSDisabledOnWin9x()
    {
        RegEntry rePol( POLICIES_KEY, HKEY_LOCAL_MACHINE );
        return(rePol.GetNumber ( REGVAL_POL_NO_RDS_WIN9X, DEFAULT_POL_NO_RDS_WIN9X ) != FALSE);
    }

	inline bool isWebDirectoryDisabled(void)
	{
        RegEntry	rePol( POLICIES_KEY, HKEY_CURRENT_USER );

        return( rePol.GetNumber( REGVAL_POL_NO_WEBDIR, DEFAULT_POL_NO_WEBDIR ) != FALSE );
	}

    inline bool IsAdvancedCallingAllowed(void)
    {
        RegEntry    rePol( POLICIES_KEY, HKEY_CURRENT_USER );
        return(!rePol.GetNumber( REGVAL_POL_NO_ADVANCEDCALLING, DEFAULT_POL_NO_ADVANCEDCALLING ));
    }

};


#endif // __ConfPolicies_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confroom.h ===
// File: confroom.h

#ifndef _CONFROOM_H_
#define _CONFROOM_H_

#include <ias.h>
#include "MRUList.h"
#include "AudioCtl.h"
#include "ConfUtil.h"

#include	"callto.h"

class CTopWindow;
class CMainUI;
class CSeparator;
class CRoomListView;
class CConfStatusBar;
class CPopupMsg;
class CFloatToolbar;
class CVideoWindow;
class CParticipant;
class CComponentWnd;
class CAudioControl;
class CCall;

struct IComponentWnd;
struct IConferenceLink;
struct TOOLSMENUSTRUCT;
struct MYOWNERDRAWSTRUCT;
struct RichAddressInfo;

interface IEnumRichAddressInfo;

interface IConferenceChangeHandler : public IUnknown
{

public:
	virtual void OnCallStarted() = 0;
	virtual void OnCallEnded() = 0;

	virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) = 0;
	virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) = 0;

	virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) = 0;

	virtual void OnChangePermissions() = 0;

	virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) = 0;
} ;

class CConfRoom : RefCount, INmConferenceNotify2, IAppSharingNotify, IAudioEvent
{
friend class CNetMeetingObj;
friend bool IsSpeakerMuted();
friend bool IsMicMuted();
friend void MuteSpeaker(BOOL fMute);
friend void MuteMicrophone(BOOL fMute);
friend DWORD GetRecorderVolume();
friend DWORD GetSpeakerVolume();
friend void SetRecorderVolume(DWORD dw);
friend void SetSpeakerVolume(DWORD dw);
friend CVideoWindow*	GetLocalVideo();
friend CVideoWindow*	GetRemoteVideo();


private:
	CTopWindow *		m_pTopWindow;
	CSimpleArray<CParticipant*>			m_PartList;            // CParticipant list
	CCopyableArray<IConferenceChangeHandler*>			m_CallHandlerList;
	CParticipant *      m_pPartLocal;
	UINT                m_cParticipants;

    DWORD               m_dwConfCookie;
	INmConference2 *	m_pInternalNmConference;
	CAudioControl *         m_pAudioControl;
    IAppSharing *           m_pAS;
    NM30_MTG_PERMISSIONS    m_settings;             // Settings for the meeting
    NM30_MTG_PERMISSIONS    m_attendeePermissions;  // Everybody BUT host

	BOOL                m_fTopProvider : 1;        // TRUE if we're the top provider
    BOOL                m_fGetPermissions : 1;


	BOOL        LeaveConference(void);

	VOID        SaveSettings();
	
	// handlers:

	VOID		OnCallStarted();
	VOID		OnCallEnded();

	void		OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify);
	void		OnChangePermissions();

	BOOL        OnPersonJoined(INmMember * pMember);
	BOOL        OnPersonLeft(INmMember * pMember);
	VOID        OnPersonChanged(INmMember * pMember);

	VOID        CheckTopProvider(void);
	DWORD		GetCallFlags();

public:
	CConfRoom();
	~CConfRoom();

	// IUnknown methods:
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	//
	// INmConferenceNotify2 methods:
	//
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CONFERENCE_STATE uState);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	STDMETHODIMP ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	STDMETHODIMP StreamEvent(NM_STREAMEVENT uEvent, UINT uSubCode,INmChannel __RPC_FAR *pChannel);

	STDMETHODIMP OnConferenceCreated(INmConference *pConference);

    //
    // IAppSharingNotify methods
    //
    STDMETHODIMP    OnReadyToShare(BOOL fReady);
    STDMETHODIMP    OnShareStarted(void);
    STDMETHODIMP    OnSharingStarted(void);
    STDMETHODIMP    OnShareEnded(void);
    STDMETHODIMP    OnPersonJoined(IAS_GCC_ID gccMemberID);
    STDMETHODIMP    OnPersonLeft(IAS_GCC_ID gccMemberID);
    STDMETHODIMP    OnStartInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnStopInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnPausedInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnUnpausedInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnControllable(BOOL fControllable);
    STDMETHODIMP    OnStartControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnStopControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnPausedControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnUnpausedControlled(IAS_GCC_ID gccByMemberID);

	virtual void OnLevelChange(BOOL fSpeaker, DWORD dwVolume);
	virtual void OnMuteChange(BOOL fSpeaker, BOOL fMute);

	// end IGenWindow interface

	// Public methods:
	BOOL			Init();
	HWND			Create(BOOL fShowUI);
	VOID			CleanUp();
	BOOL			BringToFront();
	VOID			UpdateUI(DWORD dwUIMask);
	VOID			ForceWindowResize();

	BOOL			FIsClosing();

	CTopWindow *    GetTopWindow()              { return m_pTopWindow; }
	HWND            GetTopHwnd();
	HPALETTE		GetPalette();

	CSimpleArray<CParticipant*>& GetParticipantList() 
												{ return m_PartList;      }

    DWORD           GetMeetingPermissions(void) { return m_attendeePermissions; }
    DWORD           GetMeetingSettings(void) { return m_settings; }
    void            CmdShowFileTransfer(void);
    void            CmdShowSharing(void);
    void            CmdShowMeetingSettings(HWND hwnd);

	HRESULT FreeAddress(RichAddressInfo **ppAddr);
	HRESULT CopyAddress(RichAddressInfo *pAddrIn,
				RichAddressInfo **ppAddrOut);

	HRESULT
	ResolveAndCall
	(
		const HWND						parentWindow,
		const TCHAR * const				displayName,
		const RichAddressInfo * const	rai,
		const bool						secure
	);

    HRESULT GetRecentAddresses(IEnumRichAddressInfo **ppEnum);

	CVideoWindow*	GetLocalVideo();
	CVideoWindow*	GetRemoteVideo();
	CAudioControl*	GetAudioControl() { return(m_pAudioControl); }

	BOOL            FIsConferenceActive(void) { return NULL != GetActiveConference(); }
	INmConference2* GetActiveConference(void);
	INmConference2* GetConference()           { return m_pInternalNmConference; }
	DWORD           GetConferenceStatus(LPTSTR pszStatus, int cchMax, UINT * puID);
	HRESULT         HostConference(LPCTSTR pcszName, LPCTSTR pcszPassword, BOOL fSecure, DWORD permitFlags, UINT maxParticipants);


	void			OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify);

	HRESULT			GetSelectedAddress(LPTSTR pszAddress, UINT cchAddress,
								   LPTSTR pszEmail=NULL, UINT cchEmail=0,
								   LPTSTR pszName=NULL,  UINT cchName=0);

	// Application Sharing Functions
	BOOL    FCanShare();
    BOOL    FIsSharingAvailable();
    void    LaunchHostUI(void);
	BOOL    FInShare();
	BOOL    FIsSharing();
    BOOL    FIsControllable();
    HRESULT GetPersonShareStatus(UINT gcc, IAS_PERSON_STATUS * pas);
    HRESULT AllowControl(BOOL fAllow);
	HRESULT RevokeControl(UINT gccTo);
    HRESULT GiveControl(UINT gccTo);
    HRESULT CancelGiveControl(UINT gccTo);

	// the following methods are used by scrapi only
	HRESULT CmdShare(HWND hwnd);
	HRESULT CmdUnshare(HWND hwnd);
    BOOL    FIsWindowShareable(HWND hwnd);
	BOOL    FIsWindowShared(HWND hwnd);
	HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList);
    HRESULT FreeShareableApps(IAS_HWND_ARRAY* pList);

	// Audio Functions
	VOID			SetSpeakerVolume(DWORD dwLevel);
	VOID			SetRecorderVolume(DWORD dwLevel);
	VOID			MuteSpeaker(BOOL fMute);
	VOID			MuteMicrophone(BOOL fMute);

	VOID			OnAudioDeviceChanged();
	VOID			OnAGC_Changed();
	VOID			OnSilenceLevelChanged();

	// Member Functions
	CParticipant *  GetH323Remote(void);
	CParticipant *  ParticipantFromINmMember(INmMember * pMember);
	CParticipant *  GetLocalParticipant()     {return m_pPartLocal;}
	BOOL            FTopProvider()            {return m_fTopProvider;}

	VOID AddConferenceChangeHandler(IConferenceChangeHandler *pch);
	VOID RemoveConferenceChangeHandler(IConferenceChangeHandler *pch);

	IAppSharing *GetAppSharing() { return(m_pAS); }

	BOOL CanCloseChat(HWND hwndMain);
	BOOL CanCloseWhiteboard(HWND hwndMain);
	BOOL CanCloseFileTransfer(HWND hwndMain);

	void ToggleLdapLogon();

	// Stuff needed by CTopWindow
	UINT        GetMemberCount(void) { return m_cParticipants; }
	BOOL		OnHangup(HWND hwndParent, BOOL fNeedConfirm=TRUE);
	BOOL        FHasChildNodes(void);
    VOID        TerminateAppSharing(void);
	VOID        FreePartList(void);
    VOID        StartAppSharing(void);

	BOOL IsSharingAllowed();
	BOOL IsNewWhiteboardAllowed();
	BOOL IsOldWhiteboardAllowed();
	BOOL IsChatAllowed();
	BOOL IsFileTransferAllowed();
    BOOL IsNewCallAllowed();

	static HRESULT HangUp(BOOL bUserPrompt = TRUE);

	// Global UI shutdown handler:
	static VOID UIEndSession(BOOL fLogoff);

	static
	void
	get_securitySettings
	(
		bool &	userAlterable,
		bool &	secure
	);
};

HRESULT ShareWindow(HWND hWnd);
HRESULT UnShareWindow(HWND hWnd);
HRESULT GetWindowState(NM_SHAPP_STATE* pState, HWND hWnd);

BOOL AllowingControl();

HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList);
HRESULT FreeShareableApps(IAS_HWND_ARRAY * pList);

// Global utility functions
BOOL FTopProvider(void);
BOOL FRejectIncomingCalls(void);
BOOL FIsConfRoomClosing(void);

extern CConfRoom * g_pConfRoom;
inline CConfRoom * GetConfRoom(void)        {return g_pConfRoom; }
inline CTopWindow * GetTopWindow(void)
{ return(NULL == g_pConfRoom ? NULL : g_pConfRoom->GetTopWindow()); }

HRESULT GetShareState(ULONG ulGCCId, NM_SHARE_STATE *puState);


BOOL ConfRoomInit(HANDLE hInstance);
BOOL CreateConfRoomWindow(BOOL fShowUI = TRUE);

DWORD MapNmAddrTypeToNameType(NM_ADDR_TYPE addrType);
HRESULT AllowControl(bool bAllowControl);
HRESULT RevokeControl(UINT gccID);
bool IsSpeakerMuted();
bool IsMicMuted();
DWORD GetRecorderVolume();
DWORD GetSpeakerVolume();

BOOL            CmdShowNewWhiteboard(LPCTSTR szFile);
BOOL            CmdShowOldWhiteboard(LPCTSTR szFile);
VOID            CmdShowChat(void);

void PauseLocalVideo(BOOL fPause);
void PauseRemoteVideo(BOOL fPause);
BOOL IsLocalVideoPaused();
BOOL IsRemoteVideoPaused();
HRESULT GetRemoteVideoState(NM_VIDEO_STATE *puState);
HRESULT GetLocalVideoState(NM_VIDEO_STATE *puState);
HRESULT GetImageQuality(ULONG* pul, BOOL bIncoming);
HRESULT SetImageQuality(ULONG ul, BOOL bIncoming);
HRESULT SetCameraDialog(ULONG ul);
HRESULT GetCameraDialog(ULONG* pul);

#endif // _CONFROOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confver.h ===
/* Version resource specific to conf.exe */

#define VER_DESCRIPTION_STR  "Windows\256 NetMeeting\256\0"
#define VER_INTERNALNAME_STR "conf\0"
#define VER_ORIGNAME_STR     "conf.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confutil.h ===
/*
 *	ConfUtil.h
 *
 *	CConfRoom and app level utility functions
 */

#ifndef _CONFUTIL_H_
#define _CONFUTIL_H_

#include "SDKInternal.h"
 
#define QUICK_LAUNCH_SUBDIR _T("\\Microsoft\\Internet Explorer\\Quick Launch")
void DeleteShortcut(int csidl, LPCTSTR pszSubDir);

// File Transfer
BOOL  FTransferInProgress(VOID);
BOOL  FEnableSendFileMenu(VOID);
BOOL  FEnableCancelSendMenu(VOID);
BOOL  FEnableCancelReceiveMenu(VOID);

// Options Dialog
#define OPTIONS_GENERAL_PAGE         0
#define OPTIONS_SECURITY_PAGE		 1
#define OPTIONS_MYINFO_PAGE          2
#define OPTIONS_FRIENDS_PAGE         3
#define OPTIONS_AUDIO_PAGE           4
#define OPTIONS_VIDEO_PAGE           5
#define OPTIONS_DEFAULT_PAGE         OPTIONS_GENERAL_PAGE

VOID LaunchConfCpl(HWND hwnd, int nStartPage);
BOOL CanLaunchConfCpl();


// Capabilities
extern BOOL FIsAudioAllowed();
extern BOOL FIsSendVideoAllowed();
extern BOOL FIsReceiveVideoAllowed();


// String Functions
BOOL FLoadString(UINT id, LPTSTR psz, UINT cb = MAX_PATH);
BOOL FLoadString1(UINT id, LPTSTR psz, LPVOID pv);
int FLoadString2(UINT id, LPTSTR psz, UINT cb = MAX_PATH);
LPTSTR PszLoadString(UINT id);
LPTSTR PszAlloc(LPCTSTR pszSrc);
VOID FreePsz(LPTSTR psz);
LPTSTR PszFromBstr(PCWSTR pwStr);

int LoadResInt(UINT id, int iDefault);

HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz);
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);


// Other
BOOL GetDefaultName(LPTSTR pszName, int nBufferMax);

LPCTSTR ExtractServerName(LPCTSTR pcszAddr, LPTSTR pszServer, UINT cchMax);
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszServer, LPCTSTR pszEmail, int cchMax);

BOOL FLocalIpAddress(DWORD dwIP);

INmConference2 * GetActiveConference(void);
BOOL FIsConferenceActive(void);


// Forward declaration
interface ITranslateAccelerator;

VOID AddModelessDlg(HWND hwnd);
VOID RemoveModelessDlg(HWND hwnd);
VOID AddTranslateAccelerator(ITranslateAccelerator* pTrans);
VOID RemoveTranslateAccelerator(ITranslateAccelerator* pTrans);

BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle, HWND hwndParent);

VOID DisableControl(HWND hdlg, int id);

VOID KillScrnSaver(void);
int  DxpSz(LPCTSTR pcszName);
BOOL FAnsiSz(LPCTSTR psz);

extern int g_cBusyOperations;
VOID DecrementBusyOperations(void);
VOID IncrementBusyOperations(void);


// Useful Macros
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))



// ZONE bitmasks  (depends on _rgZonesOther)
#define ZONE_API       0x01
#define ZONE_VIDEO     0x02
#define ZONE_WIZARD    0x04
#define ZONE_QOS       0x08
#define ZONE_REFCOUNT  0x10
#define ZONE_OBJECTS   0x20
#define ZONE_UI        0x40
#define ZONE_CALL    0x0080

// Zone indexes
#define iZONE_API      0
#define iZONE_VIDEO    1
#define iZONE_WIZARD   2
#define iZONE_QOS      3
#define iZONE_REFCOUNT 4
#define iZONE_OBJECTS  5
#define iZONE_UI       6
#define iZONE_CALL     7

// Debugging Macros
#ifdef DEBUG
BOOL InitDebugZones(VOID);
VOID DeinitDebugZones(VOID);

extern HDBGZONE ghZoneOther; // initialized in conf.cpp

// Old: requires double brackets  ApiDebugMsg(("x=%d", x));
#define ApiDebugMsg(s)    DBGMSG(ghZoneOther, iZONE_API, s)
#define VideoDebugMsg(s)  DBGMSG(ghZoneOther, iZONE_VIDEO, s)

// General: DbgMsg(iZONE_API, "x=%d", x);
VOID DbgMsg(UINT iZone, PSTR pszFormat,...);

// Specific: DbgMsgApi("x=%d", x);
VOID DbgMsgApi(PSTR pszFormat,...);
VOID DbgMsgVideo(PSTR pszFormat,...);
VOID DbgMsgRefCount(PSTR pszFormat,...);
VOID DbgMsgUI(PSTR pszFormat,...);
VOID DbgMsgCall(PSTR pszFormat,...);


LPCTSTR PszWSALastError(void);
LPCTSTR PszLastError(void);
LPCTSTR PszHResult(HRESULT hr);

// Redefine the standard HR result display macro
#undef DBGEXIT_HR
#define DBGEXIT_HR(s,hr)   DbgZPrintFunction("Exit  " #s "  (result=%s)", PszHResult(hr));

#else

#define ApiDebugMsg(s)
#define VideoDebugMsg(s)

inline void WINAPI DbgMsgNop(LPCTSTR, ...) { }
#define DbgMsgRefCount 1 ? (void)0 : ::DbgMsgNop
#define DbgMsgApi      1 ? (void)0 : ::DbgMsgNop
#define DbgMsgVideo    1 ? (void)0 : ::DbgMsgNop
#define DbgMsgUI       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgCall     1 ? (void)0 : ::DbgMsgNop

inline void WINAPI DbgMsgZoneNop(UINT, LPCTSTR, ...) { }
#define DbgMsg  1 ? (void) 0 : ::DbgMsgZoneNop

#endif /* DEBUG */

interface ITranslateAccelerator : public IUnknown
{
public:
	// Copied from IOleControlSite, but I don't use grfModifiers
	virtual HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	) = 0;
	// Copied from IOleWindow
	virtual HRESULT GetWindow(
		HWND * phwnd  //Pointer to where to return window handle
	) = 0;
} ;

BOOL IsWindowActive(HWND hwnd);

class CTranslateAccel : public ITranslateAccelerator, RefCount
{
private:
	HWND m_hwnd;

public:
	CTranslateAccel(HWND hwnd) : m_hwnd(hwnd)
	{
	}

	HWND GetWindow() const { return(m_hwnd); }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
	{ return(E_NOTIMPL); }
	ULONG STDMETHODCALLTYPE AddRef()
	{ return(RefCount::AddRef()); }
	ULONG STDMETHODCALLTYPE Release()
	{ return(RefCount::Release()); }

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		return(S_FALSE);
	}

	HRESULT GetWindow(
		HWND * phwnd  //Pointer to where to return window handle
	)
	{
		*phwnd = m_hwnd;
		return(S_OK);
	}
} ;

class CTranslateAccelTable : public CTranslateAccel
{
private:
	HACCEL m_hAccel;
	int m_nEntries;

public:
	CTranslateAccelTable(HWND hwnd, HACCEL hAccel) : CTranslateAccel(hwnd), m_hAccel(hAccel)
	{
		m_nEntries = CopyAcceleratorTable(m_hAccel, NULL, 0);
	}

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		HWND hwnd = GetWindow();

		WORD cmd = 0;
		if (!IsAccelerator(m_hAccel, m_nEntries, pMsg, &cmd) || !IsWindowActive(hwnd))
		{
			return(S_FALSE);
		}

		return(::TranslateAccelerator(hwnd, m_hAccel, pMsg) ? S_OK : S_FALSE);
	}
} ;

// Global list of modeless dialogs (declared in conf.cpp)
extern CSimpleArray<ITranslateAccelerator*>* g_pDialogList;
extern CRITICAL_SECTION dialogListCriticalSection;



/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// NmMkCert wrapper
DWORD MakeCertWrap(LPCSTR szFirstName, LPCSTR szLastName, LPCSTR szEmailName,
								DWORD dwFlags );

/////////////////////////////////////////////////////////////////////////////
// MessageBox routines

int  ConfMsgBox(HWND hwndParent, LPCTSTR pcszMsg, UINT uType=(MB_OK | MB_ICONINFORMATION));
VOID PostConfMsgBox(UINT uStringID);
VOID DisplayMsgIdsParam(int ids, LPCTSTR pcsz);
int  DisplayMsg(LPTSTR pcsz, UINT uType);
VOID DisplayErrMsg(INT_PTR ids);

HWND GetMainWindow();
BOOL FDontShowEnabled(LPCTSTR pszKey);


/////////////////////////////////////////////////////////////////////////////
// Icon utilties
VOID LoadIconImages(void);
VOID FreeIconImages(void);
VOID DrawIconSmall(HDC hdc, int iIcon, int x, int y);

extern HIMAGELIST g_himlIconSmall;

// Create an array that can be easily copied
template <class T>
class CCopyableArray : public CSimpleArray<T>
{
public:
	CCopyableArray()
	{
	}

	CCopyableArray(const CCopyableArray<T>& rhs)
	{
		*this = rhs;
	}

	CCopyableArray<T>& operator=(const CCopyableArray<T>& rhs)
	{
		if (&rhs == this)
		{
			return(*this);
		}

		RemoveAll();

		for (int i=0; i<rhs.GetSize(); ++i)
		{
			Add(rhs[i]);
		}

		return(*this);
	}
} ;

HFONT GetDefaultFont(void);

// Dialog utilities
BOOL FEmptyDlgItem(HWND hdlg, UINT id);
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cch);
UINT TrimDlgItemText(HWND hdlg, UINT id);

int  FmtDateTime(LPSYSTEMTIME pst, LPTSTR pszDateTime, int cchMax);

VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast);

BOOL NMGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);


//--------------------------------------------------------------------------//
//	CDirectoryManager class.												//
//--------------------------------------------------------------------------//
class CDirectoryManager
{
	public:		//	public static methods	--------------------------------//

		static
		const TCHAR * const
		get_DomainDirectory(void);

		static
		const TCHAR * const
		get_defaultServer(void);

		static
		void
		set_defaultServer
		(
			const TCHAR * const	serverName
		);

		static
		bool
		isWebDirectory
		(
			const TCHAR * const	directory = NULL
		);

		static
		const TCHAR * const
		get_dnsName
		(
			const TCHAR * const	name
		);

		static
		const TCHAR * const
		get_displayName
		(
			const TCHAR * const	name
		);

		static
		const TCHAR * const
		loadDisplayName(void);

		static
		void
		get_webDirectoryUrl(LPTSTR szWebDir, int cchmax);

		static
		const TCHAR * const
		get_webDirectoryIls(void);

		static
		bool
		isWebDirectoryEnabled(void);


	private:	//	private static members	--------------------------------//

		static bool		m_webEnabled;
		static TCHAR	m_ils[ MAX_PATH ];
		static TCHAR	m_displayName[ MAX_PATH ];
		static TCHAR	m_displayNameDefault[ MAX_PATH ];
		static TCHAR	m_defaultServer[ MAX_PATH ];
		static TCHAR	m_DomainDirectory[ MAX_PATH ];

};	//	End of class CDirectoryManager.

//--------------------------------------------------------------------------//
#endif /* _CONFUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confwnd.cpp ===
// File: HiddenWnd.cpp

#include "precomp.h"

#include "ConfWnd.h"
#include "TaskBar.h"
#include "ConfRoom.h"
#include "Conf.h"
#include "FloatBar.h"
#include "Splash.h"
#include "Cmd.h"
#include "TopWindow.h"

const TCHAR g_cszHiddenWndClassName[] = _TEXT("ConfHiddenWindow");

BOOL CHiddenWindow::Create()
{
	return(CGenWindow::Create(NULL,
								g_szEmpty,
								WS_POPUP, // not visible!
								0,
								0, 0, 0, 0,
								_Module.GetModuleInstance(),
								NULL,
								g_cszHiddenWndClassName
								));
}

VOID CHiddenWindow::OnCallStarted()
{
	::SetTimer(GetWindow(),
				WINSOCK_ACTIVITY_TIMER,
				WINSOCK_ACTIVITY_TIMER_PERIOD,
				NULL);

}

VOID CHiddenWindow::OnCallEnded()
{
	::KillTimer(GetWindow(), WINSOCK_ACTIVITY_TIMER);
}

LRESULT CHiddenWindow::ProcessMessage( HWND hwnd, UINT uMsg,
								WPARAM wParam, LPARAM lParam)
{
	// This window is used for DCL/databeam callbacks and to route
	// WM_COMMAND messages generated by TranslateAccelerator()

	switch(uMsg)
	{
		case WM_CONF_MSG_BOX:
		{
			HWND hwndParent = NULL;
			if (_Module.IsUIVisible())
			{
				CTopWindow *pTop = GetTopWindow();
				if (NULL != pTop)
				{
					hwndParent = pTop->GetWindow();
					if (NULL != hwndParent)
					{
						hwndParent = GetLastActivePopup(hwndParent);
					}
				}
			}

			::ConfMsgBox(	hwndParent,
							(LPCTSTR) wParam,
							MB_OK | MB_ICONINFORMATION |
								MB_SETFOREGROUND);
			break;
		}

		case WM_NM_DISPLAY_MSG:
		{
			return ::DisplayMsg((LPTSTR)lParam, (UINT) wParam);
		}

		case WM_TASKBAR_NOTIFY:
		{
			switch (lParam)
			{
			case WM_RBUTTONUP:
				::OnRightClickTaskbar();
				break;

			case WM_LBUTTONDBLCLK:
				// Kill the timer, so we don't pop up the toolbar
				m_fGotDblClick = TRUE;
				::CreateConfRoomWindow();
				break;

			case WM_LBUTTONUP:
				if (FALSE == GetCursorPos(&m_ptTaskbarClickPos))
				{
					// If GetCursorPos failed, put it at 0,0
					m_ptTaskbarClickPos.x = m_ptTaskbarClickPos.y = 0;
				}

				// Create a timer that will go off one dbl-click's time from now
				::SetTimer(hwnd, TASKBAR_DBLCLICK_TIMER, GetDoubleClickTime(), NULL);
				break;
			}

			return(TRUE);
		}
		
		case WM_TIMER:
		{
			switch (wParam)
			{
				case WINSOCK_ACTIVITY_TIMER:
				{
					::SendDialmonMessage(WM_WINSOCK_ACTIVITY);
					break;
				}

				case TASKBAR_DBLCLICK_TIMER:
				{
					::KillTimer(hwnd, TASKBAR_DBLCLICK_TIMER);

					if (!m_fGotDblClick)
					{
						CFloatToolbar* pft = new CFloatToolbar(::GetConfRoom());
						if (NULL != pft)
						{
							pft->Create(m_ptTaskbarClickPos);
						}
					}

					m_fGotDblClick = FALSE;
					break;
				}

				default:
					break;
			}
			break;
		}

		case MM_MIXM_LINE_CHANGE:
		case MM_MIXM_CONTROL_CHANGE:
		{
			if(GetConfRoom())
			{
				CAudioControl *pAudioControl = GetConfRoom()->GetAudioControl();
				if (NULL != pAudioControl)
				{
					pAudioControl->RefreshMixer();
				}
			}
			break;
		}

		case WM_DESTROY:
		{
			TRACE_OUT(("Conf hidden window received WM_DESTROY"));
			return 0;
		}

		default:
			return CGenWindow::ProcessMessage(hwnd, uMsg, wParam, lParam);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confutil.cpp ===
/****************************************************************************
*
*    FILE:     ConfUtil.cpp
*
*    CONTENTS: CConfRoom and app level utility functions
*
****************************************************************************/

#include "precomp.h"
#include "resource.h"
#include "confwnd.h"
#include "rostinfo.h"
#include "conf.h"
#include "nmmkcert.h"
#include "certui.h"
#include <ulsreg.h>
#include <confreg.h>
#include "shlWAPI.h"
#include "confutil.h"
#include "confpolicies.h"
#include "rend.h"


HFONT g_hfontDlg     = NULL;    // Default dialog font


#ifdef DEBUG
HDBGZONE ghZoneOther = NULL; // Other, conf.exe specific zones
static PTCHAR _rgZonesOther[] = {
	TEXT("UI"),
	TEXT("API"),
	TEXT("Video"),
	TEXT("Wizard"),
	TEXT("QoS"),
	TEXT("RefCount"),
	TEXT("Objects "),
	TEXT("UI Msg"),
	TEXT("Call Control"),
};

BOOL InitDebugZones(VOID)
{
	DBGINIT(&ghZoneOther, _rgZonesOther);
	return TRUE;
}

VOID DeinitDebugZones(VOID)
{
	DBGDEINIT(&ghZoneOther);
}

VOID DbgMsg(UINT iZone, PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & (1 << iZone))
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZone, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgRefCount(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_REFCOUNT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_REFCOUNT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgApi(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_API)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_API, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgVideo(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_VIDEO)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_VIDEO, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgUI(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_UI)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_UI, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgCall(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_UI)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_UI, pszFormat, v1);
		va_end(v1);
	}
}

#endif /* DEBUG */



/*  F  L O A D  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FLoadString

	Load a resource string.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	if (0 == ::LoadString(_Module.GetResourceModule(), id, lpsz, cch))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
		return FALSE;
	}

	return TRUE;
}


/*  F  L O A D  S T R I N G  1 */
/*----------------------------------------------------------------------------
    %%Function: FLoadString1

	Loads a resource string an formats it with the parameter.
	Assumes the resource is less than MAX_PATH characters
----------------------------------------------------------------------------*/
BOOL FLoadString1(UINT id, LPTSTR lpsz, LPVOID p)
{
	TCHAR sz[MAX_PATH];

	if (!FLoadString(id, sz, CCHMAX(sz)))
		return FALSE;

	wsprintf(lpsz, sz, p);

	return TRUE;
}

/*  F  L O A D  S T R I N G  2 */
/*----------------------------------------------------------------------------
    %%Function: FLoadString2

	Load a resource string. Return the length.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
int FLoadString2(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	int length = ::LoadString(_Module.GetResourceModule(), id, lpsz, cch);

	if (0 == length)
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
	}

	return length;
}

/*  P S Z  L O A D  S T R I N G  */
/*-------------------------------------------------------------------------
    %%Function: PszLoadString

    Return the string associated with the resource.
-------------------------------------------------------------------------*/
LPTSTR PszLoadString(UINT id)
{
	TCHAR sz[MAX_PATH];

	if (0 == ::LoadString(::GetInstanceHandle(), id, sz, CCHMAX(sz)))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		sz[0] = _T('\0');
	}

	return PszAlloc(sz);
}


/*  L O A D  R E S  I N T  */
/*-------------------------------------------------------------------------
    %%Function: LoadResInt

    Return the integer associated with the resource string.
-------------------------------------------------------------------------*/
int LoadResInt(UINT id, int iDefault)
{
	TCHAR sz[MAX_PATH];
	if (0 == ::LoadString(::GetInstanceHandle(), id, sz, CCHMAX(sz)))
		return iDefault;

	return RtStrToInt(sz);
}


/*  F  C R E A T E  I L S  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateIlsName

    Combine the server and email names to form an ILS name.
    Return TRUE if the result fit in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszServer, LPCTSTR pszEmail, int cchMax)
{
	ASSERT(NULL != pszDest);

	TCHAR szServer[MAX_PATH];
	if (FEmptySz(pszServer))
	{
		lstrcpyn( szServer, CDirectoryManager::get_defaultServer(), CCHMAX( szServer ) );
		pszServer = szServer;
	}

	if (FEmptySz(pszEmail))
	{
		WARNING_OUT(("FCreateIlsName: Null email name?"));
		return FALSE;
	}

	int cch = lstrlen(pszServer);
	lstrcpyn(pszDest, pszServer, cchMax);
	if (cch >= (cchMax-2))
		return FALSE;

	pszDest += cch;
	*pszDest++ = _T('/');
	cchMax -= (cch+1);
	
	lstrcpyn(pszDest, pszEmail, cchMax);

	return (lstrlen(pszEmail) < cchMax);
}

/*  G E T  D E F A U L T  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: GetDefaultName

-------------------------------------------------------------------------*/
BOOL GetDefaultName(LPTSTR pszName, int nBufferMax)
{
	BOOL bRet = TRUE;

	ASSERT(pszName);
	
	// First, try to get the Registered User Name from Windows:
	
	RegEntry re(WINDOWS_CUR_VER_KEY, HKEY_LOCAL_MACHINE);
	lstrcpyn(pszName, re.GetString(REGVAL_REGISTERED_OWNER), nBufferMax);
	if (_T('\0') == pszName[0])
	{
		// The registered name was empty, try the computer name:

		DWORD dwBufMax = nBufferMax;
		if ((FALSE == ::GetComputerName(pszName, &dwBufMax)) ||
			(_T('\0') == pszName[0]))
		{
			// The computer name was empty, use UNKNOWN:
			bRet = FLoadString(IDS_UNKNOWN, pszName, nBufferMax);
		}
	}

	return bRet;
}


/*  E X T R A C T  S E R V E R  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: ExtractServerName

	Extract the server name from pcszAddr and copy it into pszServer.
	Return a pointer to the remaining data.

	Uses the default server name if none is found.
	Returns a pointer to the 2nd portion of the name.
-------------------------------------------------------------------------*/
LPCTSTR ExtractServerName(LPCTSTR pcszAddr, LPTSTR pszServer, UINT cchMax)
{
	LPCTSTR pchSlash = _StrChr(pcszAddr, _T('/'));

	if (NULL == pchSlash)
	{
		lstrcpyn( pszServer, CDirectoryManager::get_defaultServer(), cchMax );
	}
	else
	{
		lstrcpyn(pszServer, pcszAddr, (int)(1 + (pchSlash - pcszAddr)));
		pcszAddr = pchSlash+1;
	}
	return pcszAddr;
}

BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle, HWND hwndParent)
{
	LPITEMIDLIST pidlRoot;
	if(FAILED(SHGetSpecialFolderLocation(HWND_DESKTOP, CSIDL_DRIVES, &pidlRoot)))
	{
	    return FALSE;
	}

	BROWSEINFO bi;
	ClearStruct(&bi);
	bi.hwndOwner = hwndParent;
	bi.lpszTitle = pszTitle;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;
	bi.pidlRoot = pidlRoot;

	LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
	BOOL fRet = (pidl != NULL);
	if (fRet)
	{
		ASSERT(cchMax >= MAX_PATH);
		SHGetPathFromIDList(pidl, pszFolder);
		ASSERT(lstrlen(pszFolder) < (int) cchMax);
	}

	// Get the shell's allocator to free PIDLs
	LPMALLOC lpMalloc;
	if (SUCCEEDED(SHGetMalloc(&lpMalloc)) && (NULL != lpMalloc))
	{
		if (NULL != pidlRoot)
		{
			lpMalloc->Free(pidlRoot);
		}
		if (pidl)
		{
			lpMalloc->Free(pidl);
		}
		lpMalloc->Release();
	}

	return fRet;
}



/*  D I S A B L E  C O N T R O L  */
/*-------------------------------------------------------------------------
    %%Function: DisableControl

-------------------------------------------------------------------------*/
VOID DisableControl(HWND hdlg, int id)
{
	if ((NULL != hdlg) && (0 != id))
	{
		HWND hwndCtrl = GetDlgItem(hdlg, id);
		ASSERT(NULL != hwndCtrl);
		EnableWindow(hwndCtrl, FALSE);
	}
}



class CDialogTranslate : public CTranslateAccel
{
public:
	CDialogTranslate(HWND hwnd) : CTranslateAccel(hwnd) {}

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		HWND hwnd = GetWindow();

		return(::IsDialogMessage(hwnd, pMsg) ? S_OK : S_FALSE);
	}
} ;


VOID AddTranslateAccelerator(ITranslateAccelerator* pTrans)
{
	EnterCriticalSection(&dialogListCriticalSection);
	if (g_pDialogList->Add(pTrans))
	{
		pTrans->AddRef();
	}
	LeaveCriticalSection(&dialogListCriticalSection);
}

VOID RemoveTranslateAccelerator(ITranslateAccelerator* pTrans)
{
	EnterCriticalSection(&dialogListCriticalSection);
	if (g_pDialogList->Remove(pTrans))
	{
		pTrans->Release();
	}
	LeaveCriticalSection(&dialogListCriticalSection);
}

/*  A D D  M O D E L E S S  D L G  */
/*-------------------------------------------------------------------------
    %%Function: AddModelessDlg

    Add the hwnd to the global dialog list
-------------------------------------------------------------------------*/
VOID AddModelessDlg(HWND hwnd)
{
	ASSERT(NULL != g_pDialogList);

	CDialogTranslate *pDlgTrans = new CDialogTranslate(hwnd);
	if (NULL != pDlgTrans)
	{
		AddTranslateAccelerator(pDlgTrans);
		pDlgTrans->Release();
	}
}

/*  R E M O V E  M O D E L E S S  D L G  */
/*-------------------------------------------------------------------------
    %%Function: RemoveModelessDlg

    Remove the hwnd from the global dialog list
-------------------------------------------------------------------------*/
VOID RemoveModelessDlg(HWND hwnd)
{
	ASSERT(g_pDialogList);

	EnterCriticalSection(&dialogListCriticalSection);

	for (int i=g_pDialogList->GetSize()-1; i>=0; --i)
	{
		ITranslateAccelerator *pTrans = (*g_pDialogList)[i];
		ASSERT(NULL != pTrans);

		HWND hwndTemp = NULL;
		if (S_OK == pTrans->GetWindow(&hwndTemp) && hwndTemp == hwnd)
		{
			RemoveTranslateAccelerator(pTrans);
			break;
		}
	}

	LeaveCriticalSection(&dialogListCriticalSection);

}

/*  K I L L  S C R N  S A V E R  */
/*-------------------------------------------------------------------------
    %%Function: KillScrnSaver

    Remove the screen saver if it is active
-------------------------------------------------------------------------*/
VOID KillScrnSaver(void)
{
	if (!IsWindowsNT())
		return;

	POINT pos;
	::GetCursorPos(&pos);
	::SetCursorPos(0,0);
	::SetCursorPos(pos.x,pos.y);
}

/*  D X P  S Z  */
/*-------------------------------------------------------------------------
    %%Function: DxpSz

    Get the width of the string in pixels.
-------------------------------------------------------------------------*/
int DxpSz(LPCTSTR pcsz)
{
	HWND hwndDesktop = GetDesktopWindow();
	if (NULL == hwndDesktop)
		return 0;

	HDC hdc = GetDC(hwndDesktop);
	if (NULL == hdc)
		return 0;

	HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
	SIZE size;
	int dxp = ::GetTextExtentPoint32(hdc, pcsz, lstrlen(pcsz), &size)
					? size.cx : 0;

	::SelectObject(hdc, hFontOld);
	::ReleaseDC(hwndDesktop, hdc);

	return dxp;
}


/*  F  A N S I  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FAnsiSz

    Return TRUE if the string contains no DBCS characters.
-------------------------------------------------------------------------*/
BOOL FAnsiSz(LPCTSTR psz)
{
	if (NULL != psz)
	{
		char ch;
		while (_T('\0') != (ch = *psz++))
		{
			if (IsDBCSLeadByte(ch))
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////

int	g_cBusyOperations = 0;

VOID DecrementBusyOperations(void)
{
	g_cBusyOperations--;

	POINT pt;
	// Wiggle the mouse - force user to send a WM_SETCURSOR
	if (::GetCursorPos(&pt))
		::SetCursorPos(pt.x, pt.y);
}

VOID IncrementBusyOperations(void)
{
	g_cBusyOperations++;

	POINT pt;
	// Wiggle the mouse - force user to send a WM_SETCURSOR
	if (::GetCursorPos(&pt))
		::SetCursorPos(pt.x, pt.y);
}



/////////////////////////////////////////////////////////////////////////////
// String Utilities

/*  P S Z  A L L O C  */
/*-------------------------------------------------------------------------
    %%Function: PszAlloc

-------------------------------------------------------------------------*/
LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}


VOID FreePsz(LPTSTR psz)
{
	delete [] psz;
}

/*  L  P  T  S  T  R _ T O _  B  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: LPTSTR_to_BSTR

-------------------------------------------------------------------------*/
HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz)
{
	ASSERT(NULL != pbstr);
	if (NULL == psz)
	{
		psz = TEXT(""); // convert NULL strings to empty strings
	}

#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
	if (cch <= 0)
		return E_FAIL;

	// allocate the widestr, +1 for terminating null
	BSTR bstr = SysAllocStringLen(NULL, cch-1); // SysAllocStringLen adds 1
	if (bstr == NULL)
		return E_OUTOFMEMORY;

	MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, cch);
	((LPWSTR)bstr)[cch - 1] = 0;
#else

	BSTR bstr = SysAllocString(psz);
	if (bstr == NULL)
		return E_OUTOFMEMORY;
#endif // UNICODE

	*pbstr = bstr;
	return S_OK;
}

/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR

-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return E_FAIL;

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
		return E_OUTOFMEMORY;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/*  P S Z  F R O M  B S T R  */
/*-------------------------------------------------------------------------
    %%Function: PszFromBstr

-------------------------------------------------------------------------*/
LPTSTR PszFromBstr(PCWSTR pwStr)
{
#ifdef UNICODE
	return PszAlloc(pwStr)
#else
	int cch = WideCharToMultiByte(CP_ACP, 0, pwStr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	// cch is the number of BYTES required, including the null terminator
	LPTSTR psz = new char[cch];
	if (NULL != psz)
	{
		WideCharToMultiByte(CP_ACP, 0, pwStr, -1, psz, cch, NULL, NULL);
	}
	return psz;
#endif /* UNICODE */
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}

extern INmSysInfo2 * g_pNmSysInfo;

////////////////////////////////////////////////////////////////////////////
// Call into the certificate generation module to generate
// a certificate matching the ULS info for secure calling:

DWORD MakeCertWrap
(
    LPCSTR  szFirstName,
	LPCSTR  szLastName,
	LPCSTR  szEmailName,
	DWORD   dwFlags
)
{
	HMODULE hMakeCertLib = NmLoadLibrary(SZ_NMMKCERTLIB, TRUE);
    DWORD dwRet = -1;

	if ( NULL != hMakeCertLib ) {
		PFN_NMMAKECERT pfn_MakeCert =
			(PFN_NMMAKECERT)GetProcAddress ( hMakeCertLib,
			SZ_NMMAKECERTFUNC );

		if ( NULL != pfn_MakeCert ) {
			dwRet = pfn_MakeCert(	szFirstName,
							szLastName,
							szEmailName,
							NULL,
							NULL,
							dwFlags );

			RefreshSelfIssuedCert();
		}
		else
        {
			ERROR_OUT(("GetProcAddress(%s) failed: %x",
						SZ_NMMAKECERTFUNC, GetLastError()));
		}
		FreeLibrary ( hMakeCertLib );
	}
	else
    {
		ERROR_OUT(("NmLoadLibrary(%s) failed: %x", SZ_NMMKCERTLIB,
			GetLastError()));
	}
    return(dwRet);
}


///////////////////////////////////////////////////////////////////////////
// Icon Utilities

HIMAGELIST g_himlIconSmall = NULL;

VOID LoadIconImages(void)
{
	ASSERT(NULL == g_himlIconSmall);
	g_himlIconSmall = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
	if (NULL != g_himlIconSmall)
	{
		HBITMAP hBmp = ::LoadBitmap(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_ICON_IMAGES));
		if (NULL != hBmp)
		{
			ImageList_AddMasked(g_himlIconSmall, hBmp, TOOLBAR_MASK_COLOR);
			::DeleteObject(hBmp);
		}
	}
}

VOID FreeIconImages(void)
{
	if (NULL != g_himlIconSmall)
	{
		ImageList_Destroy(g_himlIconSmall);
		g_himlIconSmall = NULL;
	}	
}


VOID DrawIconSmall(HDC hdc, int iIcon, int x, int y)
{
	ImageList_DrawEx(g_himlIconSmall, iIcon, hdc,
		x, y, DXP_ICON_SMALL, DYP_ICON_SMALL,
		CLR_DEFAULT, CLR_DEFAULT, ILD_NORMAL);
}

// Get the default dialog (GUI) font for international
HFONT GetDefaultFont(void)
{
	if (NULL == g_hfontDlg)
	{
		g_hfontDlg = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
	}

	return g_hfontDlg;
}

/*  F  E M P T Y  D L G  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: FEmptyDlgItem

    Return TRUE if the dialog control is empty
-------------------------------------------------------------------------*/
BOOL FEmptyDlgItem(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	return (0 == GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz)) );
}



/*  T R I M  D L G  I T E M  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: TrimDlgItemText

    Trim the text in the edit control and return the length of the string.
-------------------------------------------------------------------------*/
UINT TrimDlgItemText(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	SetDlgItemText(hdlg, id, sz);
	return lstrlen(sz);
}

/*  G E T  D L G  I T E M  T E X T  T R I M M E D  */
/*-------------------------------------------------------------------------
    %%Function: GetDlgItemTextTrimmed

-------------------------------------------------------------------------*/
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax)
{
	UINT cch = GetDlgItemText(hdlg, id, psz, cchMax);
	if (0 != cch)
	{
		cch = TrimSz(psz);
	}

	return cch;
}


/*  F M T  D A T E  T I M E  */
/*-------------------------------------------------------------------------
    %%Function: FmtDateTime

    Formats the system time using the current setting (MM/DD/YY HH:MM xm)
-------------------------------------------------------------------------*/
int FmtDateTime(LPSYSTEMTIME pst, LPTSTR pszDateTime, int cchMax)
{
    pszDateTime[0] = _T('\0');
    int cch = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                            pst, NULL, pszDateTime, cchMax);
    if ((0 != cch) && ((cchMax - cch) > 0))
    {
        // Tack on a space and then the time.
        // GetDateFormat returns count of chars
        // INCLUDING the NULL terminator, hence the - 1
        LPTSTR pszTime = pszDateTime + (cch - 1);
        pszTime[0] = _T(' ');
        pszTime[1] = _T('\0');
        cch = ::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                pst, NULL, &(pszTime[1]), (cchMax - cch));
    }

    return (cch == 0 ? 0 : lstrlen(pszDateTime));
}

/*  C O M B I N E  N A M E S  */
/*-------------------------------------------------------------------------
    %%Function: CombineNames

	Combine the two names into one string.
	The result is a "First Last" (or Intl'd "Last First") string
-------------------------------------------------------------------------*/
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast)
{
	ASSERT(pszResult);
	TCHAR szFmt[32]; // A small value: String is "%1 %2" or "%2 %1"
	TCHAR sz[1024]; // The result (before truncating to cchResult chars)
	LPCTSTR argw[2];

	argw[0] = pcszFirst;
	argw[1] = pcszLast;

	*pszResult = _T('\0');

	if (FLoadString(IDS_NAME_ORDER, szFmt, CCHMAX(szFmt)))
	{
		if (0 != FormatMessage(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
			szFmt, 0, 0, sz, CCHMAX(sz), (va_list *)argw ))
		{
			lstrcpyn(pszResult, sz, cchResult);
#ifndef _UNICODE
			// (see bug 3907 )
			// lstrcpyn() can clip a DBCS character in half at the end of the string
			// we need to walk the string with ::CharNext() and replace the last byte
			// with a NULL if the last byte is half of a DBCS char.
			PTSTR pszSource = sz;
			while (*pszSource && (pszSource - sz < cchResult))
			{
				PTSTR pszPrev = pszSource;
				pszSource = ::CharNext(pszPrev);
				// If we've reached the first character that didn't get copied into
				// the destination buffer, and the previous character was a double
				// byte character...
				if (((pszSource - sz) == cchResult) && ::IsDBCSLeadByte(*pszPrev))
				{
					// Replace the destination buffer's last character with '\0'
					// NOTE: pszResult[cchResult - 1] is '\0' thanks to lstrcpyn()
					pszResult[cchResult - 2] = _T('\0');
					break;
				}
			}
#endif // ! _UNICODE
		}
	}

}

BOOL NMGetSpecialFolderPath(
    HWND hwndOwner,
    LPTSTR lpszPath,
    int nFolder,
    BOOL fCreate)
{
	LPITEMIDLIST pidl = NULL;

	BOOL fRet = FALSE;

	if (NOERROR == SHGetSpecialFolderLocation(NULL, nFolder, &pidl))
	{
		ASSERT(NULL != pidl);

		if (SHGetPathFromIDList(pidl, lpszPath))
		{
			lstrcat(lpszPath, _TEXT("\\"));
			fRet = TRUE;
		}

		LPMALLOC lpMalloc;
		if (SUCCEEDED(SHGetMalloc(&lpMalloc)))
		{
			ASSERT(NULL != lpMalloc);

			lpMalloc->Free(pidl);
			lpMalloc->Release();
		}
	}
	return fRet;
}


//--------------------------------------------------------------------------//
//	CDirectoryManager static data members.									//
//--------------------------------------------------------------------------//
bool	CDirectoryManager::m_webEnabled						= true;
TCHAR	CDirectoryManager::m_ils[ MAX_PATH ]				= TEXT( "" );
TCHAR	CDirectoryManager::m_displayName[ MAX_PATH ]		= TEXT( "" );
TCHAR	CDirectoryManager::m_displayNameDefault[ MAX_PATH ]	= TEXT( "Microsoft Internet Directory" );
TCHAR	CDirectoryManager::m_defaultServer[ MAX_PATH ]		= TEXT( "" );
TCHAR	CDirectoryManager::m_DomainDirectory[ MAX_PATH ]	= TEXT( "" );

		
//--------------------------------------------------------------------------//
//	CDirectoryManager::get_defaultServer.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_defaultServer(void)
{

	if( m_defaultServer[ 0 ] == '\0' )
	{
		//	defaultServer not yet loaded...
		RegEntry	re( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

		lstrcpyn( m_defaultServer, re.GetString( REGVAL_SERVERNAME ), CCHMAX( m_defaultServer ) );

		if( (m_defaultServer[ 0 ] == '\0') && (get_DomainDirectory() != NULL) )
		{
			//	When no default ils server has been saved in the registry we first try to default it to the
			//	server configured for the domain if any...
			lstrcpy( m_defaultServer, m_DomainDirectory );
		}

		if( (m_defaultServer[ 0 ] == '\0') && isWebDirectoryEnabled() )
		{
			//	When no default ils server has been saved in the registry we default it to m_ils...
			lstrcpy( m_defaultServer, get_webDirectoryIls() );
		}
	}

	return( m_defaultServer );

}	//	End of CDirectoryManager::get_defaultServer.


//--------------------------------------------------------------------------//
//	CDirectoryManager::set_defaultServer.									//
//--------------------------------------------------------------------------//
void
CDirectoryManager::set_defaultServer
(
	const TCHAR * const	serverName
){
	RegEntry	ulsKey( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

	ulsKey.SetValue( REGVAL_SERVERNAME, serverName );

	lstrcpy( m_defaultServer, serverName );

}	//	End of CDirectoryManager::set_defaultServer.


//--------------------------------------------------------------------------//
//	CDirectoryManager::isWebDirectory.										//
//--------------------------------------------------------------------------//
bool
CDirectoryManager::isWebDirectory
(
	const TCHAR * const	directory
){
	TCHAR	buffer[ MAX_PATH ];

	//	If directory is null then the question is "is the default server the web directory?"

	return( isWebDirectoryEnabled() && (lstrcmpi( (directory != NULL)? get_dnsName( directory ): get_defaultServer(), get_webDirectoryIls() ) == 0) );

}	//	End of CDirectoryManager::isWebDirectory.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_dnsName.											//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_dnsName
(
	const TCHAR * const	name
){

	//	Check to see if the specified name matches m_displayName...
	return( (isWebDirectoryEnabled() && (lstrcmpi( name, loadDisplayName() ) == 0))? get_webDirectoryIls() : name );

}	//	End of CDirectoryManager::get_dnsName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_displayName.										//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_displayName
(
	const TCHAR * const	name
){

	//	Check to see if the specified name matches m_ils...
	return( (isWebDirectoryEnabled() && (lstrcmpi( name, get_webDirectoryIls() ) == 0))? loadDisplayName(): name );

}	//	End of CDirectoryManager::get_displayName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::loadDisplayName.										//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::loadDisplayName(void)
{
	using namespace ConfPolicies;

	if( m_displayName[ 0 ] == '\0' )
	{
		GetWebDirInfo( NULL, 0,
			NULL, 0,
			m_displayName, ARRAY_ELEMENTS(m_displayName) );

		if ( '\0' == m_displayName[0] )
		{
			USES_RES2T
			lstrcpy( m_displayName, RES2T( IDS_MS_INTERNET_DIRECTORY ) );

			if( m_displayName[ 0 ] == '\0' )
			{
				//	Loading m_displayName from the resources failed... default to m_displayNameDefault...
				lstrcpy( m_displayName, m_displayNameDefault );
			}
		}
	}

	return( m_displayName );

}	//	End of CDirectoryManager::loadDisplayName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_webDirectoryUrl.									//
//--------------------------------------------------------------------------//
void
CDirectoryManager::get_webDirectoryUrl(LPTSTR szWebDir, int cchmax)
{
	using namespace ConfPolicies;

	if ( !isWebDirectoryEnabled() )
	{
		szWebDir[0] = '\0';
		return;
	}

    GetWebDirInfo( szWebDir, cchmax );
	if ( '\0' != szWebDir[0] )
	{
		// All done
		return;
	}

	void FormatURL(LPTSTR szURL);

	USES_RES2T
	lstrcpyn(szWebDir, RES2T(IDS_WEB_PAGE_FORMAT_WEBVIEW), cchmax);
	FormatURL(szWebDir);

}	//	End of CDirectoryManager::get_webDirectoryUrl.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_webDirectoryIls.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_webDirectoryIls(void)
{
	using namespace ConfPolicies;

	if (!isWebDirectoryEnabled())
	{
		return(TEXT(""));
	}

	if ('\0' == m_ils[0])
	{
		GetWebDirInfo( NULL, 0,
			m_ils, ARRAY_ELEMENTS(m_ils) );
		if ('\0' == m_ils[0])
		{
			lstrcpy(m_ils, TEXT("logon.netmeeting.microsoft.com"));
		}
	}

	return(m_ils);

}	//	End of CDirectoryManager::get_webDirectoryIls.


//--------------------------------------------------------------------------//
//	CDirectoryManager::isWebDirectoryEnabled.								//
//--------------------------------------------------------------------------//
bool
CDirectoryManager::isWebDirectoryEnabled(void)
{
	static bool	policyChecked	= false;

	if( !policyChecked )
	{
		policyChecked	= true;
		m_webEnabled	= !ConfPolicies::isWebDirectoryDisabled();
	}

	return( m_webEnabled );

}	//	End of CDirectoryManager::isWebDirectoryEnabled.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_DomainDirectory.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_DomainDirectory(void)
{
	static bool	bAccessAttempted	= false;	//	only read this info once... if it fails once assume it's not available and don't retry until restarted...

	if( (!bAccessAttempted) && m_DomainDirectory[ 0 ] == '\0' )
	{
		bAccessAttempted = true;

		//	Try to obtain the configured directory for this domain...
		ITRendezvous *	pRendezvous;
		HRESULT			hrResult;

		hrResult = ::CoCreateInstance( CLSID_Rendezvous, NULL, CLSCTX_ALL, IID_ITRendezvous, (void **) &pRendezvous );

		if( (hrResult == S_OK) && (pRendezvous != NULL) )
		{
			IEnumDirectory *	pEnumDirectory;

			hrResult = pRendezvous->EnumerateDefaultDirectories( &pEnumDirectory );

			if( (hrResult == S_OK) && (pEnumDirectory != NULL) )
			{
				ITDirectory *	pDirectory;
				bool			bFoundILS	= false;

				do
				{
					hrResult = pEnumDirectory->Next( 1, &pDirectory, NULL );

					if( (hrResult == S_OK) && (pDirectory != NULL) )
					{
						LPWSTR *		ppServers;
						DIRECTORY_TYPE	type;

						if( pDirectory->get_DirectoryType( &type ) == S_OK )
						{
							if( type == DT_ILS )	//	Found an ILS server configured on the DS... retrieve the name and port...
							{
								bFoundILS = true;
	
								BSTR	pName;
	
								if( pDirectory->get_DisplayName( &pName ) == S_OK )
								{
                                    LPTSTR  szName;
                                    if (SUCCEEDED(BSTR_to_LPTSTR (&szName, pName)))
                                    {    
                                        lstrcpy( m_DomainDirectory, szName );
                                        delete  (szName);
                                    }
                                    SysFreeString( pName );
								}

								ITILSConfig *	pITILSConfig;
	
								hrResult = pDirectory->QueryInterface( IID_ITILSConfig, (void **) &pITILSConfig );

								if( (hrResult == S_OK) && (pITILSConfig != NULL) )
								{
									long	lPort;
		
									if( pITILSConfig->get_Port( &lPort ) == S_OK )
									{
										TCHAR	pszPort[ 32 ];

										wsprintf( pszPort, TEXT( ":%d" ), lPort );
										lstrcat( m_DomainDirectory, pszPort );
									}
	
									pITILSConfig->Release();
								}
							}
						}

						pDirectory->Release();
					}
				}
				while( (!bFoundILS) && (hrResult == S_OK) && (pDirectory != NULL) );

				pEnumDirectory->Release();
			}

			pRendezvous->Release();
		}
	}

	return( (m_DomainDirectory[ 0 ] != '\0')? m_DomainDirectory: NULL );

}	//	End of CDirectoryManager::get_DomainDirectory.


// Returns non-empty strings if there is a web dir set by policy
bool ConfPolicies::GetWebDirInfo(
	LPTSTR szURL, int cchmaxURL,
	LPTSTR szServer, int cchmaxServer,
	LPTSTR szName, int cchmaxName
	)
{
        // if the string params are messed up, just return false
    ASSERT( (!szURL || ( cchmaxURL > 0 ))
		&& (!szServer || ( cchmaxServer > 0 ))
		&& (!szName || ( cchmaxName > 0 ))
		);

	bool bSuccess = false;

        // Try to get the registry value
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    LPCTSTR szTemp;

    szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_URL );
    if( szTemp[0] )
    {
		if (NULL != szURL)
		{
			lstrcpyn( szURL, szTemp, cchmaxURL );
		}

		szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_SERVER );
		if (szTemp[0])
		{
			if (NULL != szServer)
			{
				lstrcpyn( szServer, szTemp, cchmaxServer );
			}

			szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_NAME );
			if( szTemp[0] )
			{
				if  (NULL != szName)
				{
					lstrcpyn( szName, szTemp, cchmaxName );
				}

				// All three values must be specified for success
				bSuccess = true;
			}
		}
    }

	if (!bSuccess)
	{
		// Empty the strings
		if (NULL != szURL   ) szURL   [0] = '\0';
		if (NULL != szServer) szServer[0] = '\0';
		if (NULL != szName  ) szName  [0] = '\0';
	}

	return(bSuccess);
}

bool g_bAutoAccept = false;

bool ConfPolicies::IsAutoAcceptCallsOptionEnabled(void)
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return !rePol.GetNumber( REGVAL_POL_NO_AUTOACCEPTCALLS, DEFAULT_POL_NO_AUTOACCEPTCALLS );
}

bool ConfPolicies::IsAutoAcceptCallsPersisted(void)
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return 0 != rePol.GetNumber( REGVAL_POL_PERSIST_AUTOACCEPTCALLS, DEFAULT_POL_PERSIST_AUTOACCEPTCALLS );
}

bool ConfPolicies::IsAutoAcceptCallsEnabled(void)
{
	bool bRet = false;

    if( IsAutoAcceptCallsOptionEnabled() )
	{
		bRet = g_bAutoAccept;

		if (IsAutoAcceptCallsPersisted())
		{
			// AutoAccept calls is _not_ disabled by the policy... we should check the AUTO_ACCEPT regval
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			if(reConf.GetNumber(REGVAL_AUTO_ACCEPT, g_bAutoAccept) )
			{
				bRet = true;
			}
		}
	}

	return bRet;
}

void ConfPolicies::SetAutoAcceptCallsEnabled(bool bAutoAccept)
{
	g_bAutoAccept = bAutoAccept;

	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
	reConf.SetValue(REGVAL_AUTO_ACCEPT, g_bAutoAccept);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\confwnd.h ===
// File: confwnd.h

#ifndef _CONFWND_H_
#define _CONFWND_H_

#include "GenWindow.h"

class CHiddenWindow : public CGenWindow
{
public:
	CHiddenWindow() : m_fGotDblClick(FALSE) {}

	BOOL Create();

	VOID OnCallStarted();
	VOID OnCallEnded();

protected:
	virtual ~CHiddenWindow() {}

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	POINT m_ptTaskbarClickPos;

	BOOL m_fGotDblClick;
} ;

extern CHiddenWindow * g_pHiddenWnd;
inline HWND GetHiddenWindow()
{
	return g_pHiddenWnd==NULL ? NULL : g_pHiddenWnd->GetWindow();
}

// Hidden window messages:
const UINT WM_CONF_MSG_BOX =            WM_USER + 10;
const UINT WM_CONFOBJ_FLUSH_FRIENDS =   WM_USER + 20;
const UINT WM_FTUI =                    WM_USER + 0x0503;
const UINT WM_STATUSBAR_UPDATE =        WM_USER + 0x0504;

const UINT WM_NM_DISPLAY_MSG =          WM_USER + 0x05FF; // wParam=uType, lParam=pszMsg

const UINT WM_CONF_DROP_KEY =           WM_USER + 0x0600; // wParam=key, lParam=hwnd
const UINT WM_CONF_DROP_CLICK =         WM_USER + 0x0601; // wParam=0, lParam=hwnd

// End Session Hidden window messages:
const UINT WM_TASKBAR_NOTIFY =          WM_USER + 200;

#endif /* _CONFWND_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\csetting.h ===
/*
 * CSetting.h	conferencing setting change broadcast definitions
 *
 * ClausGi 2-19-96
 *
 */

#ifndef _CSETTING_H_
#define _CSETTING_H_


#define STRCSETTINGMSG	TEXT("ConfSettingsChanged")

///////////////////////////////////////////////////
//
// Registered message with above name contains flag
// field in LPARAM, WPARAM is reserved.
//
// The conferencing control panel applet will broadcast the above
// registered message with the bit fields of the changed settings set.
//
//
// bit definitions follow

#define CSETTING_L_ULSRESTRICTION	0x00000001  // removed
#define CSETTING_L_SHOWTASKBAR		0x00000002
#define CSETTING_L_DIRECTSOUND		0x00000004

#define CSETTING_L_FTDIRECTORY		0x00000008
#define CSETTING_L_BANDWIDTH		0x00000400
#define CSETTING_L_FULLDUPLEX		0x00000800
#define CSETTING_L_AUTOACCEPT		0x00001000
#define CSETTING_L_AUTOACCEPTJOIN	0x00002000

#define CSETTING_L_USEULSSERVER 	0x00010000
#define CSETTING_L_FILETRANSFERMODE 0x00020000
#define CSETTING_L_SD_REFRESH		0x00040000  // removed
#define CSETTING_L_MICSENSITIVITY	0x00080000
#define CSETTING_L_AUTOMIC			0x00100000

#define CSETTING_L_ULSSETTINGS		0x00800000
#define CSETTING_L_AUDIODEVICE		0x02000000
#define CSETTING_L_AGC				0x04000000
#define CSETTING_L_VIDEO			0x08000000
#define CSETTING_L_VIDEOSIZE		0x10000000
#define CSETTING_L_COMMWAIT 		0x20000000
#define CSETTING_L_ICAINTRAY        0x40000000
#define CSETTING_L_CAPTUREDEVICE	0x80000000

// This mask is used by the control panel to decide
// if a restart is necessary. If a setting above is
// being handled fully during notification it should
// be removed from the mask below.

#define CSETTING_L_REQUIRESRESTARTMASK	(0)

#define CSETTING_L_REQUIRESNEXTCALLMASK (0)

// Global flag keeps setting that changed for windows msg broadcast
extern DWORD g_dwChangedSettings;

#endif /* _CSETTING_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cplmain.cpp ===
// File: CplMain.cpp

#include "precomp.h"
#include "resource.h"
#include "Conf.h"
#include "ConfCpl.h"
#include "confwnd.h"
#include "ConfPolicies.h"

//*** Global Data *****************************************************

// Global flag keeps setting that changed for windows msg broadcast
DWORD g_dwChangedSettings = 0;

BOOL g_fInOptionsDialog = FALSE;

static const int nMaxPropPages = 7;

INT_PTR CreatePropSheet(HWND hwndOwner, HINSTANCE hInst, int nStartPage)
{
	int pageMap[nMaxPropPages];
	ZeroMemory(pageMap, sizeof(pageMap));

	PROPSHEETPAGE psp[nMaxPropPages];
	ZeroMemory(psp, sizeof(psp));

	RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);

    ASSERT(nStartPage < nMaxPropPages);

    int nPages = 0;

    if (!rePol.GetNumber( REGVAL_POL_NO_GENERALPAGE,
								DEFAULT_POL_NO_GENERALPAGE ))
	{
        pageMap[OPTIONS_GENERAL_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_OPT_GENERAL,
				UserDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}
	if (!rePol.GetNumber( REGVAL_POL_NO_SECURITYPAGE,
								DEFAULT_POL_NO_SECURITYPAGE ))
	{
		pageMap[OPTIONS_SECURITY_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_SECURITY,
				SecurityDlgProc);
		ASSERT(nPages <= nMaxPropPages);

	}
	if (!rePol.GetNumber( REGVAL_POL_NO_AUDIOPAGE,
								DEFAULT_POL_NO_AUDIOPAGE ) &&
		!rePol.GetNumber( REGVAL_POL_NO_AUDIO,
								DEFAULT_POL_NO_AUDIO) &&
		ISSOUNDCARDPRESENT(reAudio.GetNumber( REGVAL_SOUNDCARDCAPS,
								SOUNDCARD_NONE)) )
	{
        pageMap[OPTIONS_AUDIO_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_AUDIO,
				AudioDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}
	if (!rePol.GetNumber( REGVAL_POL_NO_VIDEOPAGE,
								DEFAULT_POL_NO_VIDEOPAGE ) &&
		(!rePol.GetNumber( REGVAL_POL_NO_VIDEO_SEND,
								DEFAULT_POL_NO_VIDEO_SEND) ||
		!rePol.GetNumber( REGVAL_POL_NO_VIDEO_RECEIVE,
								DEFAULT_POL_NO_VIDEO_RECEIVE)))
	{
        pageMap[OPTIONS_VIDEO_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_VIDEO,
				VideoDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}

	// If no pages are allowed, tell the user and get out
	if ( !nPages ) {
		ConfMsgBox ( hwndOwner, (LPCTSTR)IDS_ALLPAGESDISABLED );
		return 0;
	}

	PROPSHEETHEADER psh;
	InitStruct(&psh);

	psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
	psh.hwndParent = hwndOwner;
	psh.hInstance = hInst;
	ASSERT(NULL == psh.hIcon);
	psh.pszCaption = (LPSTR)IDS_CPLNAME;
	psh.nPages = nPages;
	psh.nStartPage = pageMap[nStartPage];

	// JOSEF WHAT IS THIS?????
	psh.ppsp = (LPCPROPSHEETPAGE) psp;

	return (PropertySheet(&psh));
}


/*	L A U N C H  C O N F  C P L  */
/*-------------------------------------------------------------------------
	%%Function: LaunchConfCpl

-------------------------------------------------------------------------*/
VOID LaunchConfCpl(HWND hwnd, int nStartPage)
{

	if (g_fInOptionsDialog)
	{
		return;
	}

	g_fInOptionsDialog = TRUE;
    CreatePropSheet(hwnd, GetInstanceHandle(), nStartPage);
	g_fInOptionsDialog = FALSE;

	// Broadcast change notification if anything changed
	if (g_dwChangedSettings)
	{
		HandleConfSettingsChange(g_dwChangedSettings);
		g_dwChangedSettings = 0;
	}
}

BOOL CanLaunchConfCpl()
{
	return !g_fInOptionsDialog;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cplmsg.h ===
#define WM_AUDIOCALIBRATE		WM_USER + 200
#define WM_DONEAUDIOCALIBRATE	WM_USER + 201
#define WM_ENDCALIBRATE			WM_USER + 202
#define WM_CALIBTIMELEFT		WM_USER + 203
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cr.h ===
/****************************************************************************
*
*    FILE:     CR.h
*
*    PURPOSE:  Conference Room UI interface to external components
*
*    CREATED:  Chris Pirich (ChrisPi) 8-30-95
*
****************************************************************************/

#ifndef _CR_H_
#define _CR_H_

#define	CRUI_TOOLBAR		0x00000100
#define	CRUI_STATUSBAR		0x00000200
#define	CRUI_CALLANIM		0x00000400
#define	CRUI_TITLEBAR		0x00000800
#define	CRUI_TASKBARICON	0x00001000
#define	CRUI_APPICON		0x00002000

#define CRUI_DEFAULT		(CRUI_TOOLBAR | CRUI_STATUSBAR | CRUI_CALLANIM | CRUI_TITLEBAR)

VOID UpdateUI(DWORD dwUIMask, BOOL fPostMsg=FALSE);
#endif // _CR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dbgfiles.h ===
/* DbgFiles.h  - module file names */


/*** OPRAH files ***/
static LPTSTR _rgszModuleOprah[] = {
TEXT("conf.exe"),
TEXT("msconf.dll"),
TEXT("msconfft.dll"),
TEXT("msconfwb.dll"),
TEXT("nmcom.dll"),
TEXT("nminf.dll"),
TEXT("nmwb.dll"),
TEXT("mnmcpi32.dll"),
TEXT("mst120.dll"),
TEXT("nmasn1.dll"),
TEXT("ils.dll"),
TEXT("nmpgmgrp.exe"),
TEXT("nmexchex.exe"),
TEXT("mnmsrvc.exe"),
};

// Audio specific files
static LPTSTR _rgszModuleAudio[] = {
TEXT("dcap32.dll"),
TEXT("h323cc.dll"),
TEXT("lhacm.acm"),
TEXT("nac.dll"),
TEXT("rrcm.dll"),
TEXT("h245.dll"),
TEXT("h245ws.dll"),
TEXT("callcont.dll"),
TEXT("msica.dll"),
};



/*** Windows files ***/
static LPTSTR _rgszModuleWin95[] = {
TEXT("gdi.exe"),
TEXT("user.exe"),
TEXT("krnl386.exe"),
TEXT("comctl32.dll"),
TEXT("user32.dll"),
TEXT("gdi32.dll"),
TEXT("kernel32.dll"),
TEXT("wldap32.dll"),
};


typedef struct tagDbgMod {
        LPSTR * rgsz;
        int     cFiles;
        BOOL    fShow;
        DWORD   id;
} DBGMOD;


DBGMOD _rgModules[] = {
{_rgszModuleOprah,    ARRAY_ELEMENTS(_rgszModuleOprah),    TRUE, IDC_DBG_VER_OPRAH},
{_rgszModuleAudio,    ARRAY_ELEMENTS(_rgszModuleAudio),    TRUE, IDC_DBG_VER_AUDIO},
{_rgszModuleWin95,    ARRAY_ELEMENTS(_rgszModuleWin95),    FALSE, IDC_DBG_VER_WINDOWS},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dbgmenu.cpp ===
/****************************************************************************
*
*    FILE:     DbgMenu.cpp
*
*    CREATED:  Robert Donner (RobD) 2-04-96
*
*    CONTENTS: CDebugMenu object
*
****************************************************************************/

/*
	To add a debug menu option:
		1) Add the text to _rgDbgSz
		2) Add a function call to OnDebugCommand

	To add a checkbox in the debug options dialog:
		2) Use either AddOptionReg or AddOptionPdw with appropriate parameters

	To add a file to the version list
		1) Edit dbgfiles.txt
*/

#include "precomp.h"

#include "particip.h"
#include "DbgMenu.h"
#include "confroom.h"
#include "conf.h"
#include "version.h"
#include "pfnver.h"
#include "dlgacd.h"

#include <ConfCpl.h>

#ifdef DEBUG /*** THIS WHOLE FILE ***/

#include "DbgFiles.h"  // List of files for version info

#include "..\..\core\imember.h"   // for CNmMember
#include "..\..\as\h\gdc.h"       // for GCT compression stuff

CDebugMenu * g_pDbgMenu = NULL;
HWND ghwndVerList;

////////////////////////////
// Local Function Prototypes
VOID DbgSplash(HWND hwnd);
VOID DbgTest2(void);
VOID DbgTest3(void);

VOID DbgWizard(BOOL fVisible);
VOID DbgBreak(void);

VOID UpdateCrtDbgSettings(void);
VOID InitNmDebugOptions(void);
VOID SaveNmDebugOptions(void);

/*** Globals ***/
extern DWORD g_fDisplayFPS;        // vidview.cpp
extern DWORD g_fDisplayViewStatus; // statbar.cpp
extern DWORD g_dwPlaceCall;        // controom.cpp

#define iDbgChecked 1
#define iDbgUnchecked 2
DWORD  _dwDebugModuleFlags;



/*** Debug Menu Data ***/

enum {
	IDM_DBG_OPTIONS = IDM_DEBUG_FIRST,
	IDM_DBG_ZONES,
	IDM_DBG_POLICY,
	IDM_DBG_UI,
	IDM_DBG_VERSION,
	IDM_DBG_MEMBERS,
	IDM_DBG_WIZARD,
	IDM_DBG_BREAK,
	IDM_DBG_SPLASH,
	IDM_DBG_TEST2,
	IDM_DBG_TEST3
};


static DWSTR _rgDbgMenu[] = {
	IDM_DBG_OPTIONS, TEXT("Debug Options..."),
	IDM_DBG_ZONES,   TEXT("Zones..."),
	IDM_DBG_POLICY,  TEXT("System Policies..."),
	IDM_DBG_UI,      TEXT("User Interface..."),
	0, NULL,
	IDM_DBG_VERSION, TEXT("Version Info..."),
	IDM_DBG_MEMBERS, TEXT("Member Info..."),
	0, NULL,
	IDM_DBG_WIZARD,  TEXT("Run Wizard"),
	IDM_DBG_BREAK,   TEXT("Break"),
	0, NULL,
	IDM_DBG_SPLASH,  TEXT("Show/Hide Splash Screen"),
	IDM_DBG_TEST2,   TEXT("Test 2"),
	IDM_DBG_TEST3,   TEXT("Test 3"),
};


BOOL CDebugMenu::OnDebugCommand(WPARAM wCmd)
{
	switch (wCmd)
		{
	case IDM_DBG_OPTIONS: DbgOptions();     break;
	case IDM_DBG_ZONES:   DbgChangeZones(); break;
	case IDM_DBG_POLICY:  DbgSysPolicy();   break;
	case IDM_DBG_UI:      DbgUI();          break;
	case IDM_DBG_VERSION: DbgVersion();     break;
	case IDM_DBG_MEMBERS: DbgMemberInfo();  break;
	case IDM_DBG_WIZARD:  DbgWizard(TRUE);  break;
	case IDM_DBG_BREAK:   DbgBreak();       break;
	case IDM_DBG_SPLASH:  DbgSplash(m_hwnd);break;
	case IDM_DBG_TEST2:   DbgTest2();       break;
	case IDM_DBG_TEST3:   DbgTest3();       break;
	default: break;
		}

	return TRUE;
}




/*** Version Info Data ***/


// FUTURE: Merge these into a single structure
#define cVerInfo 11
#define VERSION_INDEX 3

static PTSTR _rgszVerInfo[cVerInfo] = {
TEXT("InternalName"),
TEXT("Size"),
TEXT("Date"),
TEXT("FileVersion"),
TEXT("FileDescription"),
TEXT("CompanyName"),
TEXT("LegalCopyright"),
TEXT("ProductName"),
TEXT("ProductVersion"),
TEXT("InternalName"),
TEXT("OriginalFilename")
};


static PTSTR _rgVerTitle[cVerInfo] = {
TEXT("Filename"),
TEXT("Size"),
TEXT("Date"),
TEXT("Version"),
TEXT("Description"),
TEXT("Company"),
TEXT("Trademark"),
TEXT("Product"),
TEXT("Version"),
TEXT("Name"),
TEXT("File")
};


static int _rgVerWidth[cVerInfo] = {
 70,
 70,
 70,
 70,
 200,
 70,
 70,
 70,
 70,
 70,
 70
};

static TCHAR _szStringFileInfo[] = TEXT("StringFileInfo");
static TCHAR _szVerIntlUSA[]     = TEXT("040904E4");
static TCHAR _szVerIntlAlt[]     = TEXT("040904B0");
static TCHAR _szVerFormat[]      = TEXT("\\%s\\%s\\%s");


/*** Debug Option Checkboxes ***/

#define DEBUG_DFL_ENABLE_TRACE_MESSAGES  0x0001
#define DEBUG_DFL_LOG_TRACE_MESSAGES     0x0002
#define DEBUG_DFL_DUMP_THREAD_ID         0x0004
#define DEBUG_DFL_ENABLE_CALL_TRACING    0x0008
#define DEBUG_DFL_DUMP_TIME              0x0010
#define DEBUG_DFL_INDENT                 0x2000

/* Static members of DBGOPTCOMPRESS class */

int DBGOPTCOMPRESS::m_total = 0;     // total number of instances of this subclass
int DBGOPTCOMPRESS::m_count = 0;     // internally used counter

DWORD DBGOPTCOMPRESS::m_dwCompression;               // actual compression value
DWORD DBGOPTCOMPRESS::m_dwDefault = GCT_DEFAULT;     // default value
HKEY  DBGOPTCOMPRESS::m_hkey = HKEY_LOCAL_MACHINE;   // key
PTSTR DBGOPTCOMPRESS::m_pszSubKey = AS_DEBUG_KEY;    // subkey
PTSTR DBGOPTCOMPRESS::m_pszEntry = REGVAL_AS_COMPRESSION;   // entry

VOID ShowDbgView(void)
{
	if (ShellExecute(NULL, NULL, "dbgview.exe", NULL, NULL, SW_SHOW) <= (HINSTANCE) 32)
	{
		ConfMsgBox(NULL, TEXT("Unable to start 'DbgView.exe'"));
	}
}



/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   CDebugMenu()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CDebugMenu::CDebugMenu(VOID):
	m_hwnd(NULL),
	m_hMenu(NULL),
	m_hMenuDebug(NULL)
{
	DebugEntry(CDebugMenu::CDebugMenu);

	DebugExitVOID(CDebugMenu::CDebugMenu);
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   InitDebugMenu()
*
*    PURPOSE:  Puts debug menu options on the menu bar
*
****************************************************************************/

VOID CDebugMenu::InitDebugMenu(HWND hwnd)
{
	m_hwnd = hwnd;
	if (NULL == hwnd)
		return;

	m_hMenu = GetMenu(hwnd);
	if (NULL == m_hMenu)
		return;

	m_hMenuDebug = CreateMenu();
	if (NULL == m_hMenuDebug)
		return;

	
	for (int i = 0; i < ARRAY_ELEMENTS(_rgDbgMenu); i++)
	{
		if (0 == _rgDbgMenu[i].dw)
		{
			AppendMenu(m_hMenuDebug, MF_SEPARATOR, 0, 0);
		}
		else if (!AppendMenu(m_hMenuDebug, MF_STRING | MF_ENABLED,
				_rgDbgMenu[i].dw, _rgDbgMenu[i].psz))
		{
			return;
		}
	}

	AppendMenu(m_hMenu, MF_POPUP, (UINT_PTR) m_hMenuDebug, TEXT(" "));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  O P T I O N S
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgOptions()
*
*    PURPOSE:  Brings up the debug options dialog box
*
****************************************************************************/

VOID CDebugMenu::DbgOptions(VOID)
{
	DebugEntry(CDebugMenu::DbgOptions);

	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgOptionsDlgProc, (LPARAM) this);

	DebugExitVOID(CDebugMenu::DbgOptions);
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgOptionsDlgProc()
*
*    PURPOSE:  Dialog Proc for debug options
*
****************************************************************************/

INT_PTR CALLBACK CDebugMenu::DbgOptionsDlgProc(HWND hDlg, UINT uMsg,
											WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitOptionsData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgOptionsMsg(hDlg, uMsg, wParam, lParam);
}


/*  I N I T  O P T I O N S  D L G */
/*----------------------------------------------------------------------------
    %%Function: InitOptionsDlg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::InitOptionsDlg(HWND hDlg)
{
	m_hwndDbgopt = GetDlgItem(hDlg, IDL_DEBUG);
	if (NULL == m_hwndDbgopt)
		return FALSE;

	/* Initialize the list view images */
	{

		HICON hCheckedIcon = LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_CHECKON));
		HICON hUncheckedIcon = LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_CHECKOFF));
		HIMAGELIST hStates = ImageList_Create(16, 16, ILC_MASK, 2, 2);
		if ((NULL == hStates) || (NULL == hCheckedIcon) || (NULL == hUncheckedIcon))
		{
			return FALSE;
		}

		ImageList_AddIcon(hStates, hCheckedIcon);
		ImageList_AddIcon(hStates, hUncheckedIcon);

		// Associate the image list with the list view
		ListView_SetImageList(m_hwndDbgopt, hStates, LVSIL_STATE);
	}

	/* Initialize the column structure */
	{
		LV_COLUMN lvC;
		RECT rc;

		GetClientRect(m_hwndDbgopt, &rc);

		ZeroMemory(&lvC, sizeof(lvC));
		lvC.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH | LVCF_TEXT;
		lvC.fmt = LVCFMT_LEFT;
		lvC.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL)
							- GetSystemMetrics(SM_CXSMICON)
							- 2 * GetSystemMetrics(SM_CXEDGE);

		// Add the column.
		if (-1 == ListView_InsertColumn(m_hwndDbgopt, 0, &lvC))
		{
			ERROR_OUT(("Could not insert column in list view"));
			return FALSE;
		}
	}

	return TRUE;
}


VOID CDebugMenu::InitOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddDbgOptions(&lvI);
	AddASOptions(&lvI);
}



/*  A D D  O P T I O N */
/*----------------------------------------------------------------------------
    %%Function: AddOption

	Add an option line to the listbox
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOption(LV_ITEM * plvItem, CDebugOption * pDbgOpt)
{
	plvItem->pszText = pDbgOpt->m_psz;
	plvItem->lParam = (LPARAM) pDbgOpt;
	plvItem->state &= ~LVIS_STATEIMAGEMASK;

	if (BST_CHECKED == pDbgOpt->m_bst)
		plvItem->state |= INDEXTOSTATEIMAGEMASK(iDbgChecked);
	else if (BST_UNCHECKED == pDbgOpt->m_bst)
		plvItem->state |= INDEXTOSTATEIMAGEMASK(iDbgUnchecked);

	if (-1 == ListView_InsertItem(m_hwndDbgopt, plvItem))
	{
		ERROR_OUT(("problem adding item entry to list view"));
	}
	else
	{
		plvItem->iItem++;
	}
}


/*  A D D  O P T I O N  S E C T I O N */
/*----------------------------------------------------------------------------
    %%Function: AddOptionSection

	Add a simple section title
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionSection(LV_ITEM* plvItem, PTSTR psz)
{
	CDebugOption * pDbgOpt = new CDebugOption(psz);
	if (NULL != pDbgOpt)
		AddOption(plvItem, pDbgOpt);
}


/*  A D D  O P T I O N  P D W */
/*----------------------------------------------------------------------------
    %%Function: AddOptionPdw

	Add an option (global memory flag)
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionPdw(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD * pdw = &_dwDebugModuleFlags)
{
	DBGOPTPDW * pDbgOpt = new DBGOPTPDW(psz, dwMask, pdw);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

/*  A D D  O P T I O N  R E G */
/*----------------------------------------------------------------------------
    %%Function: AddOptionReg

	Add a registry option
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionReg(LV_ITEM* plvItem, PTSTR psz, DWORD dwMask, DWORD dwDefault,
	PTSTR pszEntry, PTSTR pszSubKey = CONFERENCING_KEY, HKEY hkey = HKEY_CURRENT_USER)
{
	DBGOPTREG * pDbgOpt = new DBGOPTREG(psz, dwMask, dwDefault, pszEntry, pszSubKey, hkey);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

/*  A D D  O P T I O N  C O M P R E S S */
/*----------------------------------------------------------------------------
    %%Function: AddOptionCompress

	Add an option (compression data)
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionCompress(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, BOOL bCheckedOn)
{
	DBGOPTCOMPRESS * pDbgOpt = new DBGOPTCOMPRESS(psz, dwMask, bCheckedOn);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

VOID CDebugMenu::AddDbgOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Debug Output____"));

	AddOptionReg(plvItem, TEXT("Use OutputDebugString"), 1,DEFAULT_DBG_OUTPUT,
		REGVAL_DBG_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Output to Window"), 1, DEFAULT_DBG_NO_WIN,
		REGVAL_DBG_WIN_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Ouput to File"), 1, DEFAULT_DBG_NO_FILE,
		REGVAL_DBG_FILE_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	AddOptionReg(plvItem, TEXT("Show ThreadId"), 1, 0,
		REGVAL_DBG_SHOW_THREADID, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Show Module Name"), 1, 0,
		REGVAL_DBG_SHOW_MODULE, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Enable Retail Log Output"), 1, 0,
		REGVAL_RETAIL_LOG, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Show Time"), 1, 0,
		REGVAL_DBG_SHOW_TIME, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Format Time"), 2, 0,
		REGVAL_DBG_SHOW_TIME, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	_dwDebugModuleFlags = GetDebugOutputFlags();
	AddOptionPdw(plvItem, TEXT("Function Level Indenting (conf)"),DEBUG_DFL_INDENT);
}

VOID CDebugMenu::AddPolicyOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Calling____"));
    AddOptionReg(plvItem, TEXT("No Auto-Accept"), 1, DEFAULT_POL_NO_AUTOACCEPTCALLS, REGVAL_POL_NO_AUTOACCEPTCALLS, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Do not allow directory services"), 1, DEFAULT_POL_NO_DIRECTORY_SERVICES, REGVAL_POL_NO_DIRECTORY_SERVICES, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Adding Directory Servers"), 1, 0, REGVAL_POL_NO_ADDING_NEW_ULS, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No changing Call mode"), 1, 0, REGVAL_POL_NOCHANGECALLMODE, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No web directory"), 1, 0, REGVAL_POL_NO_WEBDIR, POLICIES_KEY);
	
	AddOptionSection(plvItem, TEXT("____Applets____"));
	AddOptionReg(plvItem, TEXT("No Chat"), 1, DEFAULT_POL_NO_CHAT, REGVAL_POL_NO_CHAT, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Old Whiteboard"), 1, DEFAULT_POL_NO_OLDWHITEBOARD, REGVAL_POL_NO_OLDWHITEBOARD, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No New Whiteboard"), 1, DEFAULT_POL_NO_NEWWHITEBOARD, REGVAL_POL_NO_NEWWHITEBOARD, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No File Transfer Send"), 1, DEFAULT_POL_NO_FILETRANSFER_SEND, REGVAL_POL_NO_FILETRANSFER_SEND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No File Transfer Receive"), 1, DEFAULT_POL_NO_FILETRANSFER_RECEIVE, REGVAL_POL_NO_FILETRANSFER_RECEIVE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Audio"), 1, DEFAULT_POL_NO_AUDIO, REGVAL_POL_NO_AUDIO, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Video Send"), 1, DEFAULT_POL_NO_VIDEO_SEND, REGVAL_POL_NO_VIDEO_SEND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Video Receive"), 1, DEFAULT_POL_NO_VIDEO_RECEIVE, REGVAL_POL_NO_VIDEO_RECEIVE, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Sharing____"));
	AddOptionReg(plvItem, TEXT("Disable all Sharing features"), 1, DEFAULT_POL_NO_APP_SHARING, REGVAL_POL_NO_APP_SHARING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Prevent the user from sharing"), 1, DEFAULT_POL_NO_SHARING, REGVAL_POL_NO_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing MS-DOS windows"), 1, DEFAULT_POL_NO_MSDOS_SHARING, REGVAL_POL_NO_MSDOS_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing explorer windows"), 1, DEFAULT_POL_NO_EXPLORER_SHARING, REGVAL_POL_NO_EXPLORER_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing the desktop"), 1, DEFAULT_POL_NO_DESKTOP_SHARING, REGVAL_POL_NO_DESKTOP_SHARING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable sharing in true color"), 1, DEFAULT_POL_NO_TRUECOLOR_SHARING, REGVAL_POL_NO_TRUECOLOR_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Prevent the user from allowing control"), 1, DEFAULT_POL_NO_ALLOW_CONTROL, REGVAL_POL_NO_ALLOW_CONTROL, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Options Dialog____"));
	AddOptionReg(plvItem, TEXT("Disable the 'General' page"), 1, DEFAULT_POL_NO_GENERALPAGE, REGVAL_POL_NO_GENERALPAGE, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable the 'Advanced Calling' button"), 1, DEFAULT_POL_NO_ADVANCEDCALLING, REGVAL_POL_NO_ADVANCEDCALLING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable the 'Security' page"), 1, DEFAULT_POL_NO_SECURITYPAGE, REGVAL_POL_NO_SECURITYPAGE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable the 'Audio' page"), 1, DEFAULT_POL_NO_AUDIOPAGE, REGVAL_POL_NO_AUDIOPAGE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable the 'Video' page"), 1, DEFAULT_POL_NO_VIDEOPAGE, REGVAL_POL_NO_VIDEOPAGE, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Audio / NAC____"));
    AddOptionReg(plvItem, TEXT("No changing Direct Sound usage"), 1, 0, REGVAL_POL_NOCHANGE_DIRECTSOUND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable WinSock2"), 1, 0, REGVAL_DISABLE_WINSOCK2, NACOBJECT_KEY, HKEY_LOCAL_MACHINE);

}



VOID CDebugMenu::AddASOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Application Sharing____"));
	AddOptionReg(plvItem, TEXT("Hatch Screen Data"), 1, 0, REGVAL_AS_HATCHSCREENDATA, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("Hatch Bitmap Orders"), 1, 0, REGVAL_AS_HATCHBMPORDERS, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionCompress(plvItem, TEXT("Disable AS persist compression"), GCT_PERSIST_PKZIP, FALSE),
	AddOptionCompress(plvItem, TEXT("Disable AS compression"), GCT_PKZIP, FALSE);
    AddOptionReg(plvItem, TEXT("View own shared apps"), 1, 0, REGVAL_AS_VIEWSELF, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("No AS Flow Control"), 1, 0, REGVAL_AS_NOFLOWCONTROL, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("Disable OM compression"), 1, 0, REGVAL_OM_NOCOMPRESSION, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);

}


VOID CDebugMenu::AddUIOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____User Interface____"));
	AddOptionReg(plvItem, TEXT("Call Progress TopMost"), 1, DEFAULT_DBG_CALLTOP, REGVAL_DBG_CALLTOP, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionPdw(plvItem, TEXT("Display Frames Per Second"), 1, &g_fDisplayFPS);
	AddOptionPdw(plvItem, TEXT("Display View Status"), 1, &g_fDisplayViewStatus);
	AddOptionReg(plvItem, TEXT("Right to Left Layout"), 1, DEFAULT_DBG_RTL, REGVAL_DBG_RTL, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Fake CallTo"), 1, DEFAULT_DBG_FAKE_CALLTO, REGVAL_DBG_FAKE_CALLTO, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	AddOptionSection(plvItem, TEXT("____Place a Call____"));
	AddOptionPdw(plvItem, TEXT("No ILS Filter"),      nmDlgCallNoFilter,    &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No Server Edit"),     nmDlgCallNoServerEdit,&g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No ILS View"),        nmDlgCallNoIls,       &g_dwPlaceCall);
#if USE_GAL
	AddOptionPdw(plvItem, TEXT("No GAL View"),        nmDlgCallNoGal,       &g_dwPlaceCall);
#endif // #if USE_GAL
	AddOptionPdw(plvItem, TEXT("No WAB View"),        nmDlgCallNoWab,       &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No Speed Dial View"), nmDlgCallNoSpeedDial, &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No History View"),    nmDlgCallNoHistory,   &g_dwPlaceCall);
}



/*  T O G G L E  O P T I O N */
/*----------------------------------------------------------------------------
    %%Function: ToggleOption

	Toggle the checkbox for an option
----------------------------------------------------------------------------*/
VOID CDebugMenu::ToggleOption(LV_ITEM * plvI)
{
	UINT state = plvI->state & LVIS_STATEIMAGEMASK;

	if (0 == state)
		return; // nothing to toggle

	plvI->state &= ~LVIS_STATEIMAGEMASK;
	if (state == (UINT) INDEXTOSTATEIMAGEMASK(iDbgChecked))
	{
		((CDebugOption *) (plvI->lParam))->m_bst = BST_UNCHECKED;
		plvI->state |= INDEXTOSTATEIMAGEMASK(iDbgUnchecked);
	}
	else
	{
		((CDebugOption *) (plvI->lParam))->m_bst = BST_CHECKED;
		plvI->state |= INDEXTOSTATEIMAGEMASK(iDbgChecked);
	}

	if (!ListView_SetItem(m_hwndDbgopt, plvI))
	{
		ERROR_OUT(("error setting listview item info"));
	}
}


/*  S A V E  O P T I O N S  D A T A */
/*----------------------------------------------------------------------------
    %%Function: SaveOptionsData

	Save all of the data by calling the Update routine of each item
----------------------------------------------------------------------------*/
BOOL CDebugMenu::SaveOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_PARAM | LVIF_STATE;
	lvI.stateMask = LVIS_STATEIMAGEMASK;

	while (ListView_GetItem(m_hwndDbgopt, &lvI))
	{
		CDebugOption * pDbgOpt = (CDebugOption *) lvI.lParam;
		if (NULL != pDbgOpt)
		{
			pDbgOpt->Update();
		}
		lvI.iItem++;
	}

	return TRUE;
}


/*  F R E E  O P T I O N S  D A T A */
/*----------------------------------------------------------------------------
    %%Function: FreeOptionsData

	Free any allocated data associated with the options list
----------------------------------------------------------------------------*/
VOID CDebugMenu::FreeOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
//	lvI.iItem = 0;
//	lvI.iSubItem = 0;
	lvI.mask = LVIF_PARAM | LVIF_STATE;
	lvI.stateMask = LVIS_STATEIMAGEMASK;

	while (ListView_GetItem(m_hwndDbgopt, &lvI))
	{
		CDebugOption * pDbgOpt = (CDebugOption *) lvI.lParam;
		if (NULL != pDbgOpt)
		{
			delete pDbgOpt;
		}
		lvI.iItem++;
	}
}


/*  O N  N O T I F Y  D B G O P T */
/*----------------------------------------------------------------------------
    %%Function: OnNotifyDbgopt

	Handle any notifications for the debug options dialog
----------------------------------------------------------------------------*/
VOID CDebugMenu::OnNotifyDbgopt(LPARAM lParam)
{
	NM_LISTVIEW FAR * lpnmlv = (NM_LISTVIEW FAR *)lParam;
	ASSERT(NULL != lpnmlv);
	
	switch (lpnmlv->hdr.code)
		{
	case LVN_KEYDOWN:
	{
		LV_ITEM lvI;
		LV_KEYDOWN * lplvkd = (LV_KEYDOWN *)lParam;

		if (lplvkd->wVKey == VK_SPACE)
		{
			ZeroMemory(&lvI, sizeof(lvI));
			lvI.iItem = ListView_GetNextItem(m_hwndDbgopt, -1, LVNI_FOCUSED|LVNI_SELECTED);
//			lvI.iSubItem = 0;
			lvI.mask = LVIF_PARAM | LVIF_STATE;
			lvI.stateMask = LVIS_STATEIMAGEMASK;

			if (ListView_GetItem(m_hwndDbgopt, &lvI))
			{
				ToggleOption(&lvI);
			}
		}
		break;
	}

	case NM_DBLCLK:
	case NM_CLICK:
	{
		LV_ITEM lvI;
		LV_HITTESTINFO lvH;
		int idx;

		ZeroMemory(&lvH, sizeof(lvH));
		GetCursorPos(&lvH.pt);
		ScreenToClient(m_hwndDbgopt, &lvH.pt);

		if ((NM_CLICK == lpnmlv->hdr.code) && ((UINT) lvH.pt.x) > 16)
			break;

		idx = ListView_HitTest(m_hwndDbgopt, &lvH);
		if (-1 == idx)
			break;

		ZeroMemory(&lvI, sizeof(lvI));
		lvI.iItem = idx;
//		lvI.iSubItem = 0;
		lvI.stateMask = LVIS_STATEIMAGEMASK;
		lvI.mask = LVIF_PARAM | LVIF_STATE;

		if (ListView_GetItem(m_hwndDbgopt, &lvI))
		{
			ToggleOption(&lvI);
		}
		break;
	}

	default:
		break;
		}
}


/*  D L G  O P T I O N S  M S G */
/*----------------------------------------------------------------------------
    %%Function: DlgOptionsMsg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::DlgOptionsMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDB_SHOWDBG:
		{
			ShowDbgView();
			return TRUE;
		}

		case IDOK:
			SaveOptionsData(hwnd);
			SetDebugOutputFlags(_dwDebugModuleFlags);
			SetDbgFlags();
			UpdateCrtDbgSettings();
			SaveNmDebugOptions();
			// fall thru to IDCANCEL

		case IDCANCEL:
		{
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}



CDebugOption::CDebugOption()
{
}

CDebugOption::CDebugOption(PTSTR psz, int bst)
{
	m_psz = psz;
	m_bst = bst;
}
CDebugOption::~CDebugOption()
{
}

VOID CDebugOption::Update(void)
{
}

DBGOPTPDW::DBGOPTPDW(PTSTR psz, DWORD dwMask, DWORD * pdw)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_dwMask = dwMask;
	m_pdw =pdw;
	m_bst = IS_FLAG_SET(*m_pdw, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
}

void DBGOPTPDW::Update(void)
{
	if (BST_CHECKED == m_bst)
		SET_FLAG(*m_pdw, m_dwMask);
	else if (BST_UNCHECKED == m_bst)
		CLEAR_FLAG(*m_pdw, m_dwMask);
}

DBGOPTREG::DBGOPTREG(PTSTR psz, DWORD dwMask, DWORD dwDefault,
		PTSTR pszEntry, PTSTR pszSubKey, HKEY hkey)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_dwMask = dwMask;
	m_dwDefault = dwDefault;
	m_pszEntry = pszEntry;
	m_pszSubKey = pszSubKey;
	m_hkey = hkey;

	RegEntry re(m_pszSubKey, m_hkey);
	DWORD dw = re.GetNumber(m_pszEntry, m_dwDefault);
	m_bst = IS_FLAG_SET(dw, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
};

DBGOPTREG::~DBGOPTREG()
{
}


void DBGOPTREG::Update(void)
{
	RegEntry re(m_pszSubKey, m_hkey);
	DWORD dw = re.GetNumber(m_pszEntry, m_dwDefault);
	if (BST_CHECKED == m_bst)
		SET_FLAG(dw, m_dwMask);
	else if (BST_UNCHECKED == m_bst)
		CLEAR_FLAG(dw, m_dwMask);

	re.SetValue(m_pszEntry, dw);
}

DBGOPTCOMPRESS::DBGOPTCOMPRESS(PTSTR psz, DWORD dwMask, BOOL bCheckedOn)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_total++;				// count how many instances we are creating
	m_dwMask = dwMask;
	m_bCheckedOn = bCheckedOn;

	RegEntry re(m_pszSubKey, m_hkey);

	if (m_total == 1)		// we only need to read the registry entry once
		m_dwCompression = re.GetNumber(m_pszEntry, m_dwDefault);

	if (m_bCheckedOn == TRUE)		// check or uncheck the box depending on the semantics
		m_bst = IS_FLAG_SET(m_dwCompression, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
	else
		m_bst = IS_FLAG_SET(m_dwCompression, m_dwMask) ? BST_UNCHECKED : BST_CHECKED;

}

void DBGOPTCOMPRESS::Update(void)
{
	m_count++;					// count number of times this function has been executed

	if (m_bCheckedOn == TRUE)
	{		// set or clear flag depending on semantics and whether the
		if (BST_CHECKED == m_bst)	// user checked the option box
			SET_FLAG(m_dwCompression, m_dwMask);
		else if (BST_UNCHECKED == m_bst)
			CLEAR_FLAG(m_dwCompression, m_dwMask);
	}
	else
	{
		if (BST_CHECKED == m_bst)
			CLEAR_FLAG(m_dwCompression, m_dwMask);
		else if (BST_UNCHECKED == m_bst)
			SET_FLAG(m_dwCompression, m_dwMask);
	}

	if (m_count == m_total)
	{	// if this is the last call, time to update the registry

		// If only GCT_PERSIST_PKZIP is set, then that means the user checked "Disable compression",
		// so set compression to GCT_NOCOMPRESSION
		if (GCT_PERSIST_PKZIP == m_dwCompression)
			m_dwCompression = GCT_NOCOMPRESSION;

		RegEntry re(m_pszSubKey, m_hkey);

		// If user has left everything at default, then simply delete the registry entry.
		if (m_dwCompression != GCT_DEFAULT)
			re.SetValue(m_pszEntry, m_dwCompression);
		else
			re.DeleteValue(m_pszEntry);
	}
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  Z O N E S
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgChangeZones(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgZonesDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgZonesDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitZonesData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgZonesMsg(hDlg, uMsg, wParam, lParam);
}


BOOL CDebugMenu::DlgZonesMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDB_SHOWDBG:
		{
			ShowDbgView();
			return TRUE;
		}

		case IDOK:
			SaveOptionsData(hwnd);
			SaveZonesData();
			SetDbgFlags();

			// fall thru to IDCANCEL

		case IDCANCEL:
		{
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}




VOID CDebugMenu::InitZonesData(HWND hDlg)
{
	LV_ITEM lvI;

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddZones(&lvI);

	SetWindowText(hDlg, TEXT("Debug Zone Settings"));
}


VOID CDebugMenu::AddZones(LV_ITEM * plvItem)
{
	PDBGZONEINFO  prgZones;
	PDBGZONEINFO  pZone;
	UINT cModules;
	UINT iModule;
	UINT iZone;
	UINT cch;
	TCHAR sz[256];
	PTCHAR pch;
	
 	if ((!NmDbgGetAllZoneParams(&prgZones, &cModules)) || (0 == cModules))
 		return; // no zones?

   	for (iModule = 0; iModule < cModules; iModule++)
   	{
		pZone = &prgZones[iModule];
		AddOptionSection(plvItem, TEXT("----------------------------------------"));

		lstrcpy(sz, pZone->pszModule);
		cch = lstrlen(sz);
		if (0 == cch)
			continue;
		for (pch = sz + cch-1; _T(' ') == *pch; pch--)
			;
		lstrcpy(++pch, TEXT(": "));
		pch += 2;
		for (iZone = 0; (iZone < MAXNUM_OF_ZONES) && (*(pZone->szZoneNames[iZone])); iZone++)
		{
	   		lstrcpy(pch, pZone->szZoneNames[iZone]);
			AddOptionPdw(plvItem, sz, 1 << iZone, &pZone->ulZoneMask);
		}
	}

	NmDbgFreeZoneParams(prgZones);
}

VOID CDebugMenu::SaveZonesData(VOID)
{
	RegEntry reZones(ZONES_KEY, HKEY_LOCAL_MACHINE);
	PDBGZONEINFO  prgZones;
	UINT cModules;
	UINT iModule;
	
 	if ((!NmDbgGetAllZoneParams(&prgZones, &cModules)) || (0 == cModules))
 		return; // no zones?

   	for (iModule = 0; iModule < cModules; iModule++)
   	{
		reZones.SetValue(prgZones[iModule].pszModule, prgZones[iModule].ulZoneMask);
	}

	NmDbgFreeZoneParams(prgZones);
}

/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  S Y S  P O L I C Y
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgSysPolicy(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgPolicyDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgPolicyDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;

		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitPolicyData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgPolicyMsg(hDlg, uMsg, wParam, lParam);
}


BOOL CDebugMenu::DlgPolicyMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDOK:
			SaveOptionsData(hwnd);

			// fall thru to IDCANCEL

		case IDCANCEL:
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;

		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}


VOID CDebugMenu::InitPolicyData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddPolicyOptions(&lvI);
	
	ShowWindow(GetDlgItem(hDlg, IDB_SHOWDBG), SW_HIDE);
	SetWindowText(hDlg, TEXT("System Policies"));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  U S E R  I N T E R F A C E
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgUI(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgUIDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgUIDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;

		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitUIData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgPolicyMsg(hDlg, uMsg, wParam, lParam);
}


VOID CDebugMenu::InitUIData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddUIOptions(&lvI);
	
	ShowWindow(GetDlgItem(hDlg, IDB_SHOWDBG), SW_HIDE);
	SetWindowText(hDlg, TEXT("User Interface"));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  V E R S I O N
/////////////////////////////////////////////////////////////////////////////


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgVersion()
*
*    PURPOSE:  Brings up the debug options dialog box
*
****************************************************************************/

VOID CDebugMenu::DbgVersion(VOID)
{
	if (SUCCEEDED(DLLVER::Init()))
	{
		DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_VERSION),
			m_hwnd, CDebugMenu::DbgVersionDlgProc, (LPARAM) this);
	}
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgVersionDlgProc()
*
*    PURPOSE:  Dialog Proc for version information
*
****************************************************************************/

INT_PTR CALLBACK CDebugMenu::DbgVersionDlgProc(HWND hDlg, UINT uMsg,
											WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);

		((CDebugMenu *) lParam)->InitVerDlg(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgVersionMsg(hDlg, uMsg, wParam, lParam);
}

/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DlgVersionMsg()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CDebugMenu::DlgVersionMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDC_DBG_VER_OPRAH:
		case IDC_DBG_VER_AUDIO:
		case IDC_DBG_VER_WINDOWS:
			FillVerList(hwnd);
			return TRUE;

		case IDOK:
		case IDCANCEL:
		{
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

#ifdef NOTUSED
	case WM_NOTIFY:
	{
		if (IDL_DBG_VERINFO != wParam)
			break;

		NM_LISTVIEW * pnmv = (NM_LISTVIEW *) lParam;
		if (pnmv->hdr.code == LVN_COLUMNCLICK)
		{
			ASSERT(pnmv->hdr.hwndFrom == GetDlgItem(hwnd, IDL_DBG_VERINFO));
			SortVerList(pnmv->hdr.hwndFrom, pnmv->iSubItem);
		}
		break;
	}
#endif /* NOTUSED */

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}


/*  I N I T  V E R  D L G */
/*----------------------------------------------------------------------------
    %%Function: InitVerDlg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::InitVerDlg(HWND hDlg)
{
	LV_COLUMN lvc;
	int  iCol;
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_VERINFO);
	ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

	for (int i = 0; i < ARRAY_ELEMENTS(_rgModules); i++)
		CheckDlgButton(hDlg, _rgModules[i].id , _rgModules[i].fShow);

	// Set up columns
	ZeroMemory(&lvc, sizeof(lvc));
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

	for (iCol = 0; iCol < cVerInfo; iCol++)
	{
		lvc.iSubItem = iCol;
		lvc.pszText = _rgVerTitle[iCol];
		lvc.cx = _rgVerWidth[iCol];
		lvc.fmt = (iCol == 1) ? LVCFMT_RIGHT : LVCFMT_LEFT;
		ListView_InsertColumn(hwnd, iCol, &lvc);
	}

	return FillVerList(hDlg);
}


/*  F I L L  V E R  L I S T */
/*----------------------------------------------------------------------------
    %%Function: FillVerList

----------------------------------------------------------------------------*/
BOOL CDebugMenu::FillVerList(HWND hDlg)
{
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_VERINFO);
	ghwndVerList = hwnd;

	ListView_DeleteAllItems(hwnd);

	for (int i = 0; i < ARRAY_ELEMENTS(_rgModules); i++)
	{
		_rgModules[i].fShow = IsDlgButtonChecked(hDlg, _rgModules[i].id);
		if (_rgModules[i].fShow)
			ShowVerInfo(hwnd, _rgModules[i].rgsz, _rgModules[i].cFiles);
	}

	return TRUE;
}


/*  S H O W  V E R  I N F O */
/*----------------------------------------------------------------------------
    %%Function: ShowVerInfo

----------------------------------------------------------------------------*/
VOID CDebugMenu::ShowVerInfo(HWND hwnd, LPTSTR * rgsz, int cFiles)
{
	int   iCol;
	int   iPos;
	DWORD dw;
	DWORD dwSize;
	UINT  cbBytes;
	TCHAR rgch[2048]; // a really big buffer;
	TCHAR szField[256];
	TCHAR szDir[MAX_PATH];
	LPTSTR lpszVerIntl;
	LPTSTR lpsz;
	LV_ITEM lvItem;
	HANDLE  hFind;
	WIN32_FIND_DATA findData;
	SYSTEMTIME sysTime;

	// Get and set data for each line
	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = ListView_GetItemCount(hwnd);
	ListView_SetItemCount(hwnd, lvItem.iItem + cFiles);

	GetInstallDirectory(szDir);

	for (int i = 0; i < cFiles; i++, lvItem.iItem++)
	{
		lvItem.pszText = rgsz[i];
		lvItem.cchTextMax = lstrlen(lvItem.pszText);
		lvItem.lParam = lvItem.iItem;
		iPos = ListView_InsertItem(hwnd, &lvItem);

		// Find file and get attributes (size and creation date)
		wsprintf(rgch, TEXT("%s%s"), szDir, lvItem.pszText);
		hFind = FindFirstFile(rgch, &findData);
		if (INVALID_HANDLE_VALUE == hFind)
		{
			GetSystemDirectory(rgch, sizeof(rgch));
			lstrcat(rgch, TEXT("\\"));
			lstrcat(rgch, lvItem.pszText);
			hFind = FindFirstFile(rgch, &findData);
		}
		if (INVALID_HANDLE_VALUE == hFind)
		{
			ZeroMemory(&findData, sizeof(findData));
			ListView_SetItemText(hwnd, iPos, 1, TEXT("-"));
			ListView_SetItemText(hwnd, iPos, 2, TEXT("-"));
		}
		else
		{
			FindClose(hFind);

			wsprintf(szField, TEXT("%d"), findData.nFileSizeLow);
			ListView_SetItemText(hwnd, iPos, 1, szField);
			FileTimeToSystemTime(&findData.ftLastWriteTime, &sysTime);
			wsprintf(szField, TEXT("%d/%02d/%02d"), sysTime.wYear, sysTime.wMonth, sysTime.wDay);
			ListView_SetItemText(hwnd, iPos, 2, szField);
		}

		// Get version information
		dwSize = DLLVER::GetFileVersionInfoSize(lvItem.pszText, &dw);

		if ((0 == dwSize) || (sizeof(rgch) < dwSize) ||
			!DLLVER::GetFileVersionInfo(lvItem.pszText, dw, dwSize, rgch))
		{
			continue;
		}

		// attempt to determine intl version ("040904E4" or "040904B0")
		wsprintf(szField, _szVerFormat, _szStringFileInfo, _szVerIntlUSA, _rgszVerInfo[VERSION_INDEX]);
		if (DLLVER::VerQueryValue(rgch, szField, (LPVOID *) &lpsz, &cbBytes))
			lpszVerIntl = _szVerIntlUSA;
		else
			lpszVerIntl = _szVerIntlAlt;
		// FUTURE display the language/code page info

		for (iCol = 3; iCol < cVerInfo; iCol++)
		{
			wsprintf(szField, _szVerFormat, _szStringFileInfo, lpszVerIntl, _rgszVerInfo[iCol]);
			if (!DLLVER::VerQueryValue(rgch, szField, (LPVOID *) &lpsz, &cbBytes))
				lpsz = TEXT("-");

			ListView_SetItemText(hwnd, iPos, iCol, lpsz);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  M E M B E R
/////////////////////////////////////////////////////////////////////////////

static DWSTR _rgColMember[] = {
80, TEXT("Name"),
30, TEXT("Ver"),
65, TEXT("GccId"),
65, TEXT("Parent"),
60, TEXT("Flags"),
40, TEXT("Send"),
40, TEXT("Recv"),
45, TEXT("Using"),
90, TEXT("IP"),
80, TEXT("Email"),
120, TEXT("ULS"),
};

enum {
	ICOL_PART_NAME = 0,
	ICOL_PART_VER,
	ICOL_PART_GCCID,
	ICOL_PART_PARENT,
	ICOL_PART_FLAGS,
	ICOL_PART_CAPS_SEND,
	ICOL_PART_CAPS_RECV,
	ICOL_PART_CAPS_INUSE,
	ICOL_PART_IP,
	ICOL_PART_EMAIL,
	ICOL_PART_ULS,
};


VOID CDebugMenu::DbgMemberInfo(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_LIST),
		m_hwnd, CDebugMenu::DbgListDlgProc, (LPARAM) this);
}

VOID CDebugMenu::InitMemberDlg(HWND hDlg)
{
	LV_COLUMN lvc;
	int  iCol;
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_LIST);
	ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

	// Set up columns
	ZeroMemory(&lvc, sizeof(lvc));
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

	for (iCol = 0; iCol < ARRAY_ELEMENTS(_rgColMember); iCol++)
	{
		lvc.iSubItem = iCol;
		lvc.pszText = _rgColMember[iCol].psz;
		lvc.cx = _rgColMember[iCol].dw;
		ListView_InsertColumn(hwnd, iCol, &lvc);
	}

	FillMemberList(hDlg);
	SetWindowText(hDlg, TEXT("Member Information"));
}


VOID CDebugMenu::FillMemberList(HWND hDlg)
{
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_LIST);

	ListView_DeleteAllItems(hwnd);

	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return;

	CSimpleArray<CParticipant*>& rMemberList = pcr->GetParticipantList();

	for( int i = 0; i < rMemberList.GetSize(); ++i )
	{
		ASSERT( rMemberList[i] );
		ShowMemberInfo( hwnd, rMemberList[i] );
	}
}


VOID CDebugMenu::ShowMemberInfo(HWND hwnd, CParticipant * pPart)
{
	HRESULT hr;
	ULONG   ul;
	int     iPos;
	LV_ITEM lvItem;
	TCHAR   sz[MAX_PATH];

	if (NULL == pPart)
		return;

	// Get and set data for each line
	ZeroMemory(&lvItem, sizeof(lvItem));
	
	lvItem.mask = LVIF_TEXT;
	lvItem.pszText = pPart->GetPszName();
	lvItem.cchTextMax = lstrlen(lvItem.pszText);
	lvItem.lParam = (LPARAM) pPart;
	iPos = ListView_InsertItem(hwnd, &lvItem);

	wsprintf(sz, TEXT("%08X"), pPart->GetGccId());
	ListView_SetItemText(hwnd, iPos, ICOL_PART_GCCID, sz);

	INmMember * pMember = pPart->GetINmMember();
	if (NULL != pMember)
	{
		hr = pMember->GetNmVersion(&ul);
		wsprintf(sz, "%d", ul);
		ListView_SetItemText(hwnd, iPos, ICOL_PART_VER, sz);

		wsprintf(sz, TEXT("%08X"), ((CNmMember *) pMember)->GetGccIdParent());
		ListView_SetItemText(hwnd, iPos, ICOL_PART_PARENT, sz);
	}

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetIpAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_IP, sz);

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetUlsAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_ULS, sz);

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetEmailAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_EMAIL, sz);

	DWORD dwFlags = pPart->GetDwFlags();
	wsprintf(sz, TEXT("%s%s%s%s %s%s%s"),
		dwFlags & PF_T120          ? "D" : "",
		dwFlags & PF_H323          ? "H" : "",
		dwFlags & PF_MEDIA_AUDIO   ? "A" : "",
		dwFlags & PF_MEDIA_VIDEO   ? "V" : "",
		pPart->FLocal()            ? "L" : "",
		pPart->FMcu()              ? "M" : "",
		dwFlags & PF_T120_TOP_PROV ? "T" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_FLAGS, sz);

	DWORD uCaps = pPart->GetDwCaps();
	wsprintf(sz, TEXT("%s%s"),
		uCaps & CAPFLAG_SEND_AUDIO ? "A" : "",
		uCaps & CAPFLAG_SEND_VIDEO ? "V" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_SEND,  sz);
	
	wsprintf(sz, TEXT("%s%s"),
		uCaps & CAPFLAG_RECV_AUDIO ? "A" : "",
		uCaps & CAPFLAG_RECV_VIDEO ? "V" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_RECV,  sz);
	
	wsprintf(sz, TEXT("%s%s%s%s"),
		uCaps & CAPFLAG_DATA_IN_USE  ? "D" : "",
		uCaps & CAPFLAG_AUDIO_IN_USE ? "A" : "",
		uCaps & CAPFLAG_VIDEO_IN_USE ? "V" : "",
		uCaps & CAPFLAG_H323_IN_USE  ? "H" : "");

	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_INUSE, sz);
	
	if (pPart->FLocal())
	{
		ListView_SetItemState(hwnd, iPos, LVIS_FOCUSED | LVIS_SELECTED, 0x000F);
	}
}


INT_PTR CALLBACK CDebugMenu::DbgListDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);

		((CDebugMenu *) lParam)->InitMemberDlg(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDOK:
		case IDCANCEL:
		{
			EndDialog(hDlg, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// O T H E R  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////



/*  D B G  W I Z A R D  */
/*-------------------------------------------------------------------------
    %%Function: DbgWizard

-------------------------------------------------------------------------*/
VOID DbgWizard(BOOL fVisible)
{
	LONG lSoundCaps = SOUNDCARD_NONE;
	HRESULT hr = StartRunOnceWizard(&lSoundCaps, TRUE, fVisible);
	TRACE_OUT(("StartRunOnceWizard result=%08X", hr));
}



#if defined (_M_IX86)
#define _DbgBreak() __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

VOID DbgBreak(void)
{
	// Break into the debugger
	_DbgBreak();
}



/////////////////////////////////////////////////////////////////////////////
// T E S T  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

#include "splash.h"
VOID DbgSplash(HWND hwnd)
{
	if (NULL == g_pSplashScreen)
	{
		StartSplashScreen(hwnd);
	}
	else
	{
		StopSplashScreen();
	}
}

VOID DbgTest2(void)
{
	TRACE_OUT(("Test 2 complete"));
}

VOID DbgTest3(void)
{
	TRACE_OUT(("Test 3 complete"));
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

BOOL _FEnsureDbgMenu(void)
{
	if (NULL != g_pDbgMenu)
		return TRUE;

	g_pDbgMenu = new CDebugMenu;
	return (NULL != g_pDbgMenu);
}

VOID FreeDbgMenu(void)
{
	delete g_pDbgMenu;
	g_pDbgMenu = NULL;
}

VOID InitDbgMenu(HWND hwnd)
{
	if (_FEnsureDbgMenu())
		g_pDbgMenu->InitDebugMenu(hwnd);
}

BOOL OnDebugCommand(WPARAM wCmd)
{
	if (!_FEnsureDbgMenu())
		return FALSE;

	return g_pDbgMenu->OnDebugCommand(wCmd);
}


/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

VOID DbgGetComments(LPTSTR psz)
{
	// NetMeeting version
	lstrcpy(psz, "NM3." VERSIONBUILD_STR);


	// OS version
	if (IsWindowsNT())
	{
		RegEntry re(WINDOWS_NT_KEY, HKEY_LOCAL_MACHINE);
		LPTSTR pszVer = re.GetString("CurrentVersion");
		if (0 == lstrcmp(pszVer, "4.0"))
		{
			lstrcat(psz, ", NT4 ");
		}
		else if (0 == lstrcmp(pszVer, "5.0"))
		{
			lstrcat(psz, ", NT5 ");
		}
		else
		{
			lstrcat(psz, ", NT ");
			lstrcat(psz, pszVer);
		}

		pszVer = re.GetString("CSDVersion");
		if (!FEmptySz(pszVer))
		{
			if (0 == lstrcmp(pszVer, "Service Pack 3"))
				lstrcat(psz, "SP-3");
			else
				lstrcat(psz, pszVer);
		}
	}


	// Internet Explorer version
	{
		RegEntry re(TEXT("Software\\Microsoft\\Internet Explorer"), HKEY_LOCAL_MACHINE);
		lstrcat(psz, ", IE");
		lstrcat(psz, re.GetString("Version"));
	}
}
/////////////////////////////////////////////////////////////////////////////


#define STRING_CASE(val)               case val: pcsz = #val; break

LPCTSTR PszLastError(void)
{
	static TCHAR _szErr[MAX_PATH];
	DWORD dwErr = GetLastError();

	if (0 == FormatMessage(
		FORMAT_MESSAGE_FROM_SYSTEM,  // source and processing options
	    NULL,                        // pointer to  message source
	    dwErr,                       // requested message identifier
		0,                           // language identifier for requested message
		_szErr,                      // pointer to message buffer
		CCHMAX(_szErr),              // maximum size of message buffer
		NULL))                       // address of array of message inserts
	{
		wsprintf(_szErr, TEXT("0x%08X (%d)"), dwErr, dwErr);
	}

	return _szErr;
}


LPCTSTR PszWSALastError(void)
{
	LPCTSTR pcsz;
	DWORD dwErr = WSAGetLastError();
	switch (dwErr)
		{
	STRING_CASE(WSAEWOULDBLOCK);
	STRING_CASE(WSAEINPROGRESS);
	STRING_CASE(HOST_NOT_FOUND);
	STRING_CASE(WSATRY_AGAIN);
	STRING_CASE(WSANO_RECOVERY);
	STRING_CASE(WSANO_DATA);
	
	default:
	{
		static TCHAR _szErr[MAX_PATH];
		wsprintf(_szErr, TEXT("0x%08X (%d)"), dwErr, dwErr);
		pcsz = _szErr;
		break;
	}
		}

	return pcsz;
}


/*  P S Z  H  R E S U L T  */
/*-------------------------------------------------------------------------
    %%Function: PszHResult

-------------------------------------------------------------------------*/
LPCTSTR PszHResult(HRESULT hr)
{
   LPCSTR pcsz;
   switch (hr)
   {
// Common HResults
	  STRING_CASE(S_OK);
	  STRING_CASE(S_FALSE);

	  STRING_CASE(E_FAIL);
	  STRING_CASE(E_OUTOFMEMORY);

// NM COM API 2.0
	  STRING_CASE(NM_S_NEXT_CONFERENCE);
	  STRING_CASE(NM_S_ON_RESTART);
	  STRING_CASE(NM_CALLERR_NOT_INITIALIZED);
	  STRING_CASE(NM_CALLERR_MEDIA);
	  STRING_CASE(NM_CALLERR_NAME_RESOLUTION);
	  STRING_CASE(NM_CALLERR_PASSWORD);
	  STRING_CASE(NM_CALLERR_CONFERENCE_NAME);
	  STRING_CASE(NM_CALLERR_IN_CONFERENCE);
	  STRING_CASE(NM_CALLERR_NOT_FOUND);
	  STRING_CASE(NM_CALLERR_MCU);
	  STRING_CASE(NM_CALLERR_REJECTED);
	  STRING_CASE(NM_CALLERR_AUDIO);
	  STRING_CASE(NM_CALLERR_AUDIO_LOCAL);
	  STRING_CASE(NM_CALLERR_AUDIO_REMOTE);
	  STRING_CASE(NM_CALLERR_UNKNOWN);
	  STRING_CASE(NM_E_NOT_INITIALIZED);
	  STRING_CASE(NM_E_CHANNEL_ALREADY_EXISTS);
	  STRING_CASE(NM_E_NO_T120_CONFERENCE);
	  STRING_CASE(NM_E_NOT_ACTIVE);

// NM COM API 3.0
	  STRING_CASE(NM_CALLERR_LOOPBACK);

	default:
		pcsz = GetHRESULTString(hr);
		break;
	}

	return pcsz;
}


/////////////////////////////////////////////////////////////////////////////

/*  I N I T  N M  D E B U G  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitNmDebugOptions

    Initialize NetMeeting UI-specific debug options.
-------------------------------------------------------------------------*/
VOID InitNmDebugOptions(void)
{
    RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	g_fDisplayFPS = re.GetNumber(REGVAL_DBG_DISPLAY_FPS, 0);
	g_fDisplayViewStatus = re.GetNumber(REGVAL_DBG_DISPLAY_VIEWSTATUS, 0);
}

VOID SaveNmDebugOptions(void)
{
    RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	re.SetValue(REGVAL_DBG_DISPLAY_FPS, g_fDisplayFPS);
	re.SetValue(REGVAL_DBG_DISPLAY_VIEWSTATUS, g_fDisplayViewStatus);
}



/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}


/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
	InitNmDebugOptions();
	UpdateCrtDbgSettings();

#if 0
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors
#endif // 0

	return TRUE;
}

#endif /* DEBUG - whole file */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC


/////////////////////////////////////////////////////////////

#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);

//  CertVerifyTrust for WIN16 - like as WinVerifyTrust().
HRESULT
WINAPI CertVerifyTrust16(
    PCCERT_CONTEXT    pcCertToTest,
    DWORD             cCAs,
    HCERTSTORE *      rgCAs,
    DWORD *           pcChain,
    PCCERT_CONTEXT ** prgChain,
    BOOL *            fTrust);
#endif // !WIN16


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dbgmenu.h ===
// File: dbgmenu.h

#ifndef _DBGMENU_H_
#define _DBGMENU_H_

const int IDM_DEBUG          = 50000; // debug menu ID
const int IDM_DEBUG_FIRST    = 50001; // start of menu item range
const int IDM_DEBUG_LAST     = 50099; // end of menu item range



#define AS_DEBUG_KEY                "Software\\Microsoft\\Conferencing\\AppSharing\\Debug"
#define REGVAL_AS_HATCHSCREENDATA   "HatchScreenData"
#define REGVAL_AS_HATCHBMPORDERS    "HatchBitmapOrders"
#define REGVAL_AS_COMPRESSION       "GDCCompression"
#define REGVAL_AS_VIEWSELF          "ViewOwnSharedStuff"
#define REGVAL_AS_NOFLOWCONTROL     "NoFlowControl"
#define REGVAL_OM_NOCOMPRESSION     "NoOMCompression"

// Base debug option classe
class CDebugOption
{
public:
	int   m_bst; // Current Button State (BST_CHECKED, BST_UNCHECKED, BST_INDETERMINATE)
	PTSTR m_psz; // Text to display

	CDebugOption();
	~CDebugOption();
	CDebugOption(PTSTR psz, int bst = BST_INDETERMINATE);

	virtual void Update(void);
};

// Option checkbox data for modifying a memory flag
class DBGOPTPDW : public CDebugOption
{
public:
	DWORD m_dwMask;    // bit to flip
	DWORD * m_pdw;       // pointer to data

	DBGOPTPDW(PTSTR psz, DWORD dwMask, DWORD * pdw);
	DBGOPTPDW();
	void Update(void);
};


// Option checkbox data for modifying a registry entry
class DBGOPTREG : public CDebugOption
{
public:
	DWORD m_dwMask;    // bit to flip
	DWORD m_dwDefault; // default value
	HKEY  m_hkey;      // key
	PTSTR m_pszSubKey; // subkey
	PTSTR m_pszEntry;  // entry

	DBGOPTREG(PTSTR psz,
		DWORD dwMask,
		DWORD dwDefault,
		PTSTR pszEntry,
		PTSTR pszSubKey = CONFERENCING_KEY,
		HKEY hkey = HKEY_CURRENT_USER);
	~DBGOPTREG();

	void Update(void);
};

// Option checkbox data used explicitly for maintaining compression data.
// Because of the use of static variables, this subclass should not be used
// for any other purpose.

class DBGOPTCOMPRESS : public CDebugOption
{
public:
	static DWORD m_dwCompression;  // actual compression value
	static int m_total;         // total number of instances of this subclass
	static int m_count;         // internally used counter

	static DWORD m_dwDefault;   // default value
	static HKEY  m_hkey;        // key
	static PTSTR m_pszSubKey;   // subkey
	static PTSTR m_pszEntry;    // entry

	BOOL m_bCheckedOn;          // if true, a checked option turns a bit on;
                                // otherwise, it turns a bit off
	DWORD m_dwMask;             // which bits in m_dwCompression to change

	DBGOPTCOMPRESS(PTSTR psz,
		DWORD dwMask,
		BOOL bCheckedOn);
	~DBGOPTCOMPRESS();

	void Update(void);
};

class CDebugMenu
{
public:
	HWND        m_hwnd;
	HMENU       m_hMenu;
	HMENU       m_hMenuDebug;
	HWND        m_hwndDbgopt;

    
	CDebugMenu(VOID);
//	~CDebugMenu(VOID);

	VOID        InitDebugMenu(HWND hwnd);
	BOOL        OnDebugCommand(WPARAM wCmd);

// Member Info Menu Item
	VOID DbgMemberInfo(VOID);
	VOID InitMemberDlg(HWND);
	VOID FillMemberList(HWND);
	VOID ShowMemberInfo(HWND, CParticipant *);

	static INT_PTR CALLBACK DbgListDlgProc(HWND, UINT, WPARAM, LPARAM);

// Version Menu Item
	VOID DbgVersion(VOID);
	BOOL DlgVersionMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgVersionDlgProc(HWND, UINT, WPARAM, LPARAM);

	BOOL InitVerDlg(HWND);
	BOOL FillVerList(HWND);
	VOID ShowVerInfo(HWND, LPSTR *, int);


// Debug Options Menu Item
	VOID DbgOptions(VOID);
	BOOL DlgOptionsMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgOptionsDlgProc(HWND, UINT, WPARAM, LPARAM);

	VOID InitOptionsData(HWND);
	VOID AddDbgOptions(LV_ITEM *);
	VOID AddASOptions(LV_ITEM *);

// Debug Zones Menu Item
	VOID DbgChangeZones(VOID);
	VOID AddZones(LV_ITEM *);
	VOID InitZonesData(HWND);
	VOID SaveZonesData(VOID);
	BOOL DlgZonesMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgZonesDlgProc(HWND, UINT, WPARAM, LPARAM);

// System Policy Menu Item
	VOID DbgSysPolicy(VOID);
	VOID InitPolicyData(HWND hDlg);
	VOID AddPolicyOptions(LV_ITEM *);
	BOOL DlgPolicyMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgPolicyDlgProc(HWND, UINT, WPARAM, LPARAM);

// User Interface Menu Item
	VOID DbgUI(VOID);
	VOID InitUIData(HWND hDlg);
	VOID AddUIOptions(LV_ITEM *);
	static INT_PTR CALLBACK DbgUIDlgProc(HWND, UINT, WPARAM, LPARAM);

// General Dialog-Checkbox functions
	BOOL InitOptionsDlg(HWND);
	BOOL SaveOptionsData(HWND);
	VOID FreeOptionsData(HWND);
	VOID ToggleOption(LV_ITEM *);
	VOID OnNotifyDbgopt(LPARAM);

	VOID AddOption(LV_ITEM * plvItem, CDebugOption * pDbgOpt);
	VOID AddOptionPdw(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD * pdw);
	VOID AddOptionReg(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD dwDefault,
		PTSTR pszEntry, PTSTR pszSubKey, HKEY hkey);
	VOID CDebugMenu::AddOptionCompress(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, BOOL bCheckedOn);
	VOID AddOptionSection(LV_ITEM* plvItem, PTSTR psz);
};

// Global Interface
#ifdef DEBUG
VOID InitDbgMenu(HWND hwnd);
VOID FreeDbgMenu(void);
BOOL OnDebugCommand(WPARAM wCmd);
#else
#define InitDbgMenu(hwnd)
#define FreeDbgMenu()
#endif

#endif // _DBGMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgacd.h ===
#if	!defined( CDLGACD_H )
#define	CDLGACD_H
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Header Files.															//
//--------------------------------------------------------------------------//
#include	"MRUList2.h"
#include	"richaddr.h"
#include	"confroom.h"

#define USE_GAL 0


#define NM_CALLDLG_DEFAULT 0x0000
#define NM_CALLDLG_NO_ILS_FILTER 0x0002
#define NM_CALLDLG_NO_ILS 0x0010

#if USE_GAL
#define NM_CALLDLG_NO_GAL 0x0020
#endif // USE_GAL

#define NM_CALLDLG_NO_WAB 0x0040
#define NM_CALLDLG_NO_SPEEDDIAL 0x0080
#define NM_CALLDLG_NO_HISTORY 0x0100

enum NmDlgCallOption
{
	nmDlgCallNormal = NM_CALLDLG_DEFAULT,
	nmDlgCallNoFilter = NM_CALLDLG_NO_ILS_FILTER,
	nmDlgCallNoIls = NM_CALLDLG_NO_ILS,

#if USE_GAL
	nmDlgCallNoGal = NM_CALLDLG_NO_GAL,
#endif // USE_GAL

	nmDlgCallNoWab = NM_CALLDLG_NO_WAB,
	nmDlgCallNoSpeedDial = NM_CALLDLG_NO_SPEEDDIAL,
	nmDlgCallNoHistory = NM_CALLDLG_NO_HISTORY,
	nmDlgCallSecurityAlterable = 0x0200,
	nmDlgCallSecurityOn = 0x0400,
	nmDlgCallNoServerEdit = 0x0800,
};

const DWSTR	_rgMruCall[] =
{
	{	3,			DLGCALL_MRU_KEY					},
	{	MRUTYPE_SZ,	REGVAL_DLGCALL_NAME_MRU_PREFIX	},
	{	MRUTYPE_SZ,	REGVAL_DLGCALL_ADDR_MRU_PREFIX	},
	{	MRUTYPE_DW,	REGVAL_DLGCALL_TYPE_MRU_PREFIX	}
};

enum ACD_MRUFIELDS
{
	ACD_NAME = 0,
	ACD_ADDR,
	ACD_TYPE,
} ;

const int	CENTRYMAX_MRUCALL	= 15;  // maximum number of recent calls


class CAcdMru : public CMRUList2
{
public:
	CAcdMru();

protected:
	int CompareEntry(int iItem, PMRUE pEntry);
} ;

//--------------------------------------------------------------------------//
//	CEnumMRU Class.															//
//--------------------------------------------------------------------------//
class CEnumMRU:	public IEnumRichAddressInfo,
				public RefCount,
				public CAcdMru
{
	public:		//	public constructor	------------------------------------//

		CEnumMRU();

	public:		//	public methods	----------------------------------------//

		ULONG
		STDMETHODCALLTYPE
		AddRef(void);

		ULONG
		STDMETHODCALLTYPE
		Release(void);

	    virtual
		HRESULT
		STDMETHODCALLTYPE
		GetAddress
		(
			long				index,
			RichAddressInfo **	ppAddr
		);


	public:		//	public static methods	--------------------------------//

		static
		HRESULT
		GetRecentAddresses
		(
			IEnumRichAddressInfo **	ppEnum
		);

		static
		HRESULT
		FreeAddress
		(
			RichAddressInfo **	ppAddr
		);

		static
		HRESULT
		CopyAddress
		(
			RichAddressInfo *	pAddrIn,
			RichAddressInfo **	ppAddrOut
		);

};	//	End of class CEnumMRU.


//--------------------------------------------------------------------------//
//	CDlgAcd Class.															//
//--------------------------------------------------------------------------//
class CDlgAcd : public IConferenceChangeHandler
{
	public:		//	public constructor	------------------------------------//

		CDlgAcd(CConfRoom *pConfRoom);


	public:		//	public destructor	------------------------------------//

		virtual
		~CDlgAcd();


	public:		// IConferenceChangeHandler methods
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
		{
			return(E_FAIL);
		}

        virtual ULONG STDMETHODCALLTYPE AddRef( void)
		{
			return(3);
		}

        virtual ULONG STDMETHODCALLTYPE Release( void)
		{
			return(2);
		}

		virtual void OnCallStarted();
		virtual void OnCallEnded();

		virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) {}
		virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) {}

		virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) {}

		virtual void OnChangePermissions() {}

		virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) {}

	public:		//	public methods	----------------------------------------//

		INT_PTR
		doModal
		(
			HWND				parent,
			RichAddressInfo *	rai,
			bool &				secure
		);


	public:		//	public static methods	--------------------------------//

		static
		void
		newCall
		(
			HWND	parentWindow,
			CConfRoom * pConfRoom
		);


	private:	//	private methods	----------------------------------------//

		bool
		onInitDialog
		(
			HWND	dialog
		);

		bool
		onCommand
		(
			int command,
			int	notification
		);

		void
		onEditChange(void);

		void
		onMruSelect
		(
			int	selection
		);

		void
		fillCallMruList(void);

		void
		fillAddressTypesList(void);

		int
		get_editText
		(
			LPTSTR	psz,
			int		cchMax
		);


	private:	//	private static methods	--------------------------------//

		static
		INT_PTR
		CALLBACK
		DlgProcAcd
		(
			HWND	dialog,
			UINT	message,
			WPARAM	wParam,
			LPARAM	lParam
		);


	private:	//	private members	----------------------------------------//

		HWND				m_hwnd;
		HWND				m_nameCombo;
		HWND				m_addressTypeCombo;
		RichAddressInfo *	m_pRai;
		RichAddressInfo *	m_mruRai;
		CConfRoom *			m_pConfRoom;
		bool				m_secure;
		CEnumMRU			m_callMruList;

};	//	End of class CDlgAcd.

//--------------------------------------------------------------------------//
#endif	//	!defined( CDLGACD_H )

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\conf\dlgacd.cpp ===
//--------------------------------------------------------------------------//
//      Header Files.                                                          