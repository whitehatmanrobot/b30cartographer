  HRESULT
//
// Notes:
//
// This function interprets the contents of the data object from MMC and breaks
// it down into three collections within a newly created MMCClipboard object.
//
// UNDONE: next coment says that we hold foreign VB snap-in items natively in
// the clipboard. Recheck this after multi-selection is done.
//
// MMCClipboard.ScopeItems contains scope items owned either by the snap-in or
// by other VB implemented snap-ins. The snap-in can discern by checking
// ScopeItem.ScopeNode.Owned. 
//
// MMCClipboard.ListItems contains list items owned either by the snap-in or
// by other VB implemented snap-ins. The snap-in can discern by checking
// ListItem.Owned.
//
// MMCClipboard.DataObject contains MMCDataObjects representing data exported
// by other snap-ins not implemented in VB.
//
// If there is nothing currently selected (NULL IDataObject) then all of the
// collections will be empty.
//

HRESULT CreateSelection
(
    IDataObject                   *piDataObject, 
    IMMCClipboard                **ppiMMCClipboard,
    CSnapIn                       *pSnapIn,      
    SnapInSelectionTypeConstants  *pSelectionType
)
{
    HRESULT        hr = S_OK;
    IUnknown      *punkClipboard = NULL;
    IMMCClipboard *piMMCClipboard = NULL;
    CMMCClipboard *pMMCClipboard = NULL;

    *ppiMMCClipboard = NULL;
    *pSelectionType = siEmpty;

    // Create a clipboard object to hold the selection

    punkClipboard = CMMCClipboard::Create(NULL);
    if (NULL == punkClipboard)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkClipboard->QueryInterface(IID_IMMCClipboard,
                                    reinterpret_cast<void **>(&piMMCClipboard)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCClipboard, &pMMCClipboard));

    IfFailGo(::InterpretDataObject(piDataObject, pSnapIn, pMMCClipboard));

    // If this is a special data object then set the MMCClipboard.SelectionType
    // to the corresponding special type.

    if (IS_SPECIAL_DATAOBJECT(piDataObject))
    {
        if (DOBJ_NULL == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siEmpty);
        }
        else if (DOBJ_CUSTOMOCX == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siSpecialOcx);
        }
        else if (DOBJ_CUSTOMWEB == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siSpecialWeb);
        }
        else
        {
            ASSERT(FALSE, "Received unknown DOBJ_XXX type");
            pMMCClipboard->SetSelectionType(siEmpty);
        }
    }
    else
    {
        // Ask the MMCClipboard to figure out the selection type based on
        // the objects it contains

        IfFailGo(pMMCClipboard->DetermineSelectionType());
    }

    // Make the clipboard read-only so the snap-in cannot alter its collections

    pMMCClipboard->SetReadOnly(TRUE);

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCClipboard);
    }
    else
    {
        *ppiMMCClipboard = piMMCClipboard;
        *pSelectionType = pMMCClipboard->GetSelectionType();
    }
    QUICK_RELEASE(punkClipboard);
    RRETURN(hr);
}


HRESULT InterpretDataObject
(
    IDataObject   *piDataObject,
    CSnapIn       *pSnapIn,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    CScopeItems    *pScopeItems = NULL;
    CScopeItem     *pScopeItem = NULL;
    CMMCListItems  *pListItems = NULL;
    CMMCListItem   *pListItem = NULL;
    BOOL            fNotFromThisSnapIn = FALSE;
    BOOL            fMultiSelect = FALSE;
    long            i = 0;
    long            cScopeItems = 0;
    long            cListItems = 0;

    // Check for special case dataobjects. For all of these we don't add anything
    // to the MMCClipboard

    // Dataobject can be NULL when in an empty result pane (listview with
    // no items) and the user clicks a toolbar button.

    // Dataobject can be DOBJ_CUSTOMWEB when clicking a toolbar button or
    // dropping a menu button when the result pane contains a listpad,
    // a url view, or a taskpad.

    // Dataobject can be DOBJ_CUSTOMOCX in the same cases when displaying an
    // OCX view.

    IfFalseGo(!IS_SPECIAL_DATAOBJECT(piDataObject), S_OK );

    ::IdentifyDataObject(piDataObject, pSnapIn,
                         &pMMCDataObject, &fNotFromThisSnapIn);

    if (fNotFromThisSnapIn)
    {
        // This is either data from another snap-in or a multiple selection
        // format. Make that determination first.

        IfFailGo(::IsMultiSelect(piDataObject, &fMultiSelect));

        if (fMultiSelect)
        {
            IfFailGo(::InterpretMultiSelect(piDataObject, pSnapIn, pMMCClipboard));
        }
        else
        {
            IfFailGo(::AddForeignDataObject(piDataObject, pMMCClipboard, pSnapIn));
        }
    }
    else
    {
        // This snap-in owns the data object.
        // It represents either a single scope item (that can
        // be either in the scope or result pane), a single list item, or
        // multiples of one or both.

        if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
        {
            IfFailGo(::AddScopeItemToClipboard(pMMCDataObject->GetScopeItem(),
                                               pMMCClipboard));
        }
        else if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
        {
            IfFailGo(::AddListItemToClipboard(pMMCDataObject->GetListItem(),
                                              pMMCClipboard));
        }
        else if (CMMCDataObject::MultiSelect == pMMCDataObject->GetType())
        {
            // Add each element in the data object's ScopeItems and
            // MMCListItems collections to the clipboard

            pScopeItems = pMMCDataObject->GetScopeItems();
            cScopeItems = pScopeItems->GetCount();
            for (i = 0; i < cScopeItems; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pScopeItems->GetItemByIndex(i), &pScopeItem));
                IfFailGo(::AddScopeItemToClipboard(pScopeItem, pMMCClipboard));
            }

            pListItems = pMMCDataObject->GetListItems();
            cListItems = pListItems->GetCount();
            for (i = 0; i < cListItems; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                     pListItems->GetItemByIndex(i), &pListItem));
                IfFailGo(::AddListItemToClipboard(pListItem, pMMCClipboard));
            }
        }
        else
        {
            ASSERT(FALSE, "CMMCDataObject in selection should not be foreign");
        }
    }

Error:
    RRETURN(hr);
}




void IdentifyDataObject
(
    IDataObject     *piDataObject,
    CSnapIn         *pSnapIn,
    CMMCDataObject **ppMMCDataObject,
    BOOL            *pfNotFromThisSnapIn
 
)
{
    CMMCDataObject  *pMMCDataObject = NULL;
    HGLOBAL          hGlobal = NULL;
    DWORD           *pdwInstanceID = 0;
    CMMCDataObject **ppThis = NULL;

    *ppMMCDataObject = NULL;
    *pfNotFromThisSnapIn = TRUE;
    
    if (SUCCEEDED(CSnapInAutomationObject::GetCxxObject(piDataObject,
                                                        &pMMCDataObject)))
    {
        if (pMMCDataObject->GetSnapInInstanceID() == pSnapIn->GetInstanceID())
        {
            *pfNotFromThisSnapIn = FALSE;
            *ppMMCDataObject = pMMCDataObject;
        }
    }
    else
    {
        // This could be a clipboard data object from MMC. In this case MMC's
        // data object holds an IDataObject to our data object and will forward
        // GetData calls to it. So, ask the data object for its snap-in instance
        // ID and, if it matches, then ask it for its this pointer.

        if (SUCCEEDED(::GetData(piDataObject,
                                CMMCDataObject::GetcfSnapInInstanceID(),
                                &hGlobal)))
        {
            pdwInstanceID = (DWORD *)::GlobalLock(hGlobal);
            if ( (NULL != pdwInstanceID) &&
                 (::GlobalSize(hGlobal) >= sizeof(*pdwInstanceID)) )
            {
                if (*pdwInstanceID == pSnapIn->GetInstanceID())
                {
                    (void)::GlobalUnlock(hGlobal);
                    (void)::GlobalFree(hGlobal);
                    hGlobal = NULL;
                    if (SUCCEEDED(::GetData(piDataObject,
                                            CMMCDataObject::GetcfThisPointer(),
                                            &hGlobal)))
                    {
                        ppThis = (CMMCDataObject **)::GlobalLock(hGlobal);
                        if ( (NULL != ppThis) &&
                             (::GlobalSize(hGlobal) >= sizeof(*ppThis)) )
                        {
                            *ppMMCDataObject = *ppThis;
                            *pfNotFromThisSnapIn = FALSE;
                        }
                    }
                }
            }
        }
    }
            
    if (NULL != hGlobal)
    {
        (void)::GlobalUnlock(hGlobal);
        (void)::GlobalFree(hGlobal);
    }
}


HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect)
{
    HRESULT  hr = S_OK;
    DWORD   *pdwMultiSelect = NULL;
    BOOL     fGotData = FALSE;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    *pfMultiSelect = FALSE;

    FmtEtc.cfFormat = CMMCDataObject::GetcfMultiSelectDataObject();
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->GetData(&FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        fGotData = TRUE;
    }
    else if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) || (E_NOTIMPL == hr) )
    {
        hr = S_OK;
    }
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (fGotData)
    {
        pdwMultiSelect = (DWORD *)::GlobalLock(StgMed.hGlobal);

        if (static_cast<DWORD>(1) == *pdwMultiSelect)
        {
            *pfMultiSelect = TRUE;
        }
    }

Error:
    if (NULL != pdwMultiSelect)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }
    RRETURN(hr);
}




HRESULT InterpretMultiSelect
(
    IDataObject   *piDataObject,
    CSnapIn       *pSnapIn,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT          hr = S_OK;
    SMMCDataObjects *pMMCDataObjects = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;
    DWORD            i = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    // Get the SMMCDataObjects structure from MMC

    FmtEtc.cfFormat = CMMCDataObject::GetcfMultiSelectSnapIns();
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->GetData(&FmtEtc, &StgMed);
    if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = SID_E_FORMAT_NOT_AVAILABLE;
    }
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    fGotData = TRUE;

    pMMCDataObjects = (SMMCDataObjects *)::GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCDataObjects)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // For each data object in the array check whether it is owned by this
    // snap-in or not and add it to the corresponding collection in
    // MMCClipboard. Note that we do not call Release on the IDataObject
    // pointers extracted from the HGLOBAL block because MMC does not AddRef()
    // them.

    for (i = 0; i < pMMCDataObjects->count; i++)
    {
        IfFailGo(::InterpretDataObject(pMMCDataObjects->lpDataObject[i],
                                       pSnapIn,
                                       pMMCClipboard));
    }

Error:
    if (NULL != pMMCDataObjects)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }

    RRETURN(hr);
}




HRESULT AddForeignDataObject
(
    IDataObject   *piDataObject,
    CMMCClipboard *pMMCClipboard,
    CSnapIn       *pSnapIn
)
{
    HRESULT          hr = S_OK;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    CMMCDataObject  *pMMCDataObject  = NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    IfFailGo(pMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));

    IfFailGo(piMMCDataObjects->Add(varUnspecified, varUnspecified,
                         reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCDataObject,
                                                   &pMMCDataObject));
    pMMCDataObject->SetType(CMMCDataObject::Foreign);
    pMMCDataObject->SetForeignData(piDataObject);
    pMMCDataObject->SetSnapIn(pSnapIn);

Error:
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// AddListItemToClipboard
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CMMCListItem  *pMMCListItem   [in] list item to be added
//      CMMCClipboard *pMMCClipboard [in] clipboard to which it should be added
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds the specified list item the clipboard's MMCListItems
// collection. The list item's index property will not correspond to its
// position in the clipboard's collection as it represents the position in the
// list item's owning collection.
//

HRESULT AddListItemToClipboard
(
    CMMCListItem  *pMMCListItem,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT        hr = S_OK;
    IMMCListItems *piMMCListItems = NULL;
    CMMCListItems *pMMCListItems = NULL;
    long           lIndex = pMMCListItem->GetIndex();

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    DebugPrintf("Adding list item to selection: %ld %ls\r\n", pMMCListItem->GetIndex(), (pMMCListItem->GetTextPtr() != NULL) ? pMMCListItem->GetTextPtr() : L"<Virtual List Item>");

    IfFailGo(pMMCClipboard->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItems, &pMMCListItems));

    varKey.bstrVal = pMMCListItem->GetKey();
    if (NULL != varKey.bstrVal)
    {
        varKey.vt = VT_BSTR;
    }
    else
    {
        UNSPECIFIED_PARAM(varKey);
    }

    hr = pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                    static_cast<IMMCListItem *>(pMMCListItem));

    ASSERT(SID_E_KEY_NOT_UNIQUE != hr, "Attempted to add non-unique key to MMCClipboard.ListItems");
    IfFailGo(hr);

    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this list item still belongs to its original owning collection.
    // Clipboard.ListItems is documented as having items with invalid index
    // properties.

    pMMCListItem->SetIndex(lIndex);

Error:
    QUICK_RELEASE(piMMCListItems);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// AddScopeItemToClipboard
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CScopeItem    *pScopeItem     [in] Scope item to be added
//      CMMCClipboard *pMMCClipboard  [in] clipboard to which it should be added
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds the specified list item the clipboard's ScopeItems
// collection. The scope item's index property will not correspond to its
// position in the clipboard's collection as it represents the position in the
// SnapIn.ScopeItems (the owning collection).
//


HRESULT AddScopeItemToClipboard
(
    CScopeItem    *pScopeItem,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT      hr = S_OK;
    IScopeItems *piScopeItems = NULL;
    CScopeItems *pScopeItems = NULL;
    long         lIndex = pScopeItem->GetIndex();

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    IfFailGo(pMMCClipboard->get_ScopeItems(reinterpret_cast<ScopeItems **>(&piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItems, &pScopeItems));

    varKey.bstrVal = pScopeItem->GetKey();
    if (NULL != varKey.bstrVal)
    {
        varKey.vt = VT_BSTR;
    }
    else
    {
        UNSPECIFIED_PARAM(varKey);
    }

    hr = pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                  static_cast<IScopeItem *>(pScopeItem));
    ASSERT(SID_E_KEY_NOT_UNIQUE != hr, "Attempted to add non-unique key to MMCClipboard.ScopeItems");
    IfFailGo(hr);

    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this list item still belongs to its original owning collection.
    // Clipboard.ScopeItems is documented as having items with invalid index
    // properties.

    pScopeItem->SetIndex(lIndex);

    DebugPrintf("Adding scope item to selection %ls\r\n", pScopeItem->GetDisplayNamePtr());

Error:
    QUICK_RELEASE(piScopeItems);
    RRETURN(hr);
}



static HRESULT GetObjectArray
(
    SAFEARRAY        *psaObjects,
    LONG             *pcObjects,
    IUnknown HUGEP ***pppunkObjects
)
{
    HRESULT          hr = S_OK;
    LONG             lUBound = 0;
    LONG             lLBound = 0;

    *pppunkObjects = NULL;
    *pcObjects = 0;

    // Check that we received a one-dimensional array of interface pointer sized
    // elements and that it contains IUnknown or IDispatch pointers.

    if ( (1 != ::SafeArrayGetDim(psaObjects)) ||
         (sizeof(IUnknown *) != ::SafeArrayGetElemsize(psaObjects)) ||
         (0 == (psaObjects->fFeatures & (FADF_UNKNOWN | FADF_DISPATCH)) )
       )
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get access to the array data

    hr = ::SafeArrayAccessData(psaObjects,
                               reinterpret_cast<void HUGEP **>(pppunkObjects));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Get the number of elements by doing the math on lower and upper bounds
    // on the first (and only) dimension of the array

    hr = ::SafeArrayGetLBound(psaObjects, 1, &lLBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psaObjects, 1, &lUBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    *pcObjects = (lUBound - lLBound) + 1L;

Error:
    if ( FAILED(hr) && (NULL != *pppunkObjects) )
    {
        (void)::SafeArrayUnaccessData(psaObjects);
    }
    RRETURN(hr);
}



HRESULT DataObjectFromSingleObject
(
    IUnknown     *punkObject,
    MMC_COOKIE   *pCookie,
    IDataObject **ppiDataObject
)
{
    HRESULT       hr = S_OK;
    CMMCListItem *pMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;
    CScopeItem   *pScopeItem = NULL;
    IScopeItem   *piScopeItem = NULL;

    hr = punkObject->QueryInterface(IID_IScopeItem,
                                    reinterpret_cast<void **>(&piScopeItem));
    if (FAILED(hr))
    {
        hr = punkObject->QueryInterface(IID_IMMCListItem,
                                        reinterpret_cast<void **>(&piMMCListItem));
    }
    if (FAILED(hr))
    {
        // Not a scope item and not a list item. Can't use it.
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get the object's data object and cookie

    if (NULL != piScopeItem)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem,
                                                       &pScopeItem));
        *ppiDataObject = static_cast<IDataObject *>(pScopeItem->GetData());
        if (pScopeItem->IsStaticNode())
        {
            *pCookie = 0;
        }
        else
        {
            *pCookie = reinterpret_cast<MMC_COOKIE>(pScopeItem);
        }
    }
    else
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                       &pMMCListItem));
        *ppiDataObject = static_cast<IDataObject *>(pMMCListItem->GetData());
        *pCookie = reinterpret_cast<MMC_COOKIE>(pMMCListItem);
    }
    (*ppiDataObject)->AddRef();
    
Error:
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}


HRESULT DataObjectFromObjectArray
(
    IUnknown HUGEP **ppunkObjects,
    LONG             cObjects,
    MMC_COOKIE      *pCookie,
    IDataObject    **ppiDataObject
)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkDataObject = CMMCDataObject::Create(NULL);
    CMMCDataObject  *pMMCDataObject = NULL;
    IUnknown        *punkScopeItems = CScopeItems::Create(NULL);
    CScopeItems     *pScopeItems = NULL;
    CScopeItem      *pScopeItem = NULL;
    IScopeItem      *piScopeItem = NULL;
    IUnknown        *punkListItems = CMMCListItems::Create(NULL);
    CMMCListItems   *pMMCListItems = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    IMMCListItem    *piMMCListItem = NULL;
    long             lIndex = 0;
    LONG             i = 0;
    BOOL             fHaveArray = FALSE;
    CSnapIn         *pSnapIn = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    // Check that we created an MMCDataObject and the scope and list item
    // collections

    if ( (NULL == punkDataObject) || (NULL == punkScopeItems) ||
         (NULL == punkListItems) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get C++ pointers for the data object and the collections

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                  &pMMCDataObject));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeItems,
                                                   &pScopeItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkListItems,
                                                   &pMMCListItems));

    // Iterate through the objects and build the scope item and list item
    // collections. When adding an item owned by another collection,
    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this item still belongs to its original owning collection (either
    // SnapIn.ScopeItems or ResultView.ListView.ListItems)

    for (i = 0; i < cObjects; i++)
    {
        // Check for NULLs. This can happen when the snap-in does something like:
        //
        // Dim Objects(2) As Object
        // Set Object(1) = SomeScopeItem
        // Set Object(2) = SomeOtherScopeItem
        //
        // With the default option base of zero this is actually a 3 element
        // array where element zero has not been set (it will have default
        // initialization of zero).

        if (NULL == ppunkObjects[i])
        {
            continue;
        }

        // QI to determine whether this object is a scope item or a list item

        hr = ppunkObjects[i]->QueryInterface(IID_IScopeItem,
                                             reinterpret_cast<void **>(&piScopeItem));
        if (FAILED(hr))
        {
            hr = ppunkObjects[i]->QueryInterface(IID_IMMCListItem,
                                      reinterpret_cast<void **>(&piMMCListItem));
        }
        if (FAILED(hr))
        {
            // Not a scope item and not a list item. Can't use it.
            hr = SID_E_INVALIDARG;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Add the object to the appropriate collection

        if (NULL != piScopeItem)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem,
                                                           &pScopeItem));
            lIndex = pScopeItem->GetIndex();
            varKey.bstrVal = pScopeItem->GetKey();
            if (NULL != varKey.bstrVal)
            {
                varKey.vt = VT_BSTR;
            }
            else
            {
                UNSPECIFIED_PARAM(varKey);
            }
            IfFailGo(pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                              piScopeItem));
            pScopeItem->SetIndex(lIndex);

            if (NULL == pSnapIn)
            {
                pSnapIn = pScopeItem->GetSnapIn();
            }
            RELEASE(piScopeItem);
        }
        else
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                           &pMMCListItem));
            lIndex = pMMCListItem->GetIndex();
            varKey.bstrVal = pMMCListItem->GetKey();
            if (NULL != varKey.bstrVal)
            {
                varKey.vt = VT_BSTR;
            }
            else
            {
                UNSPECIFIED_PARAM(varKey);
            }
            IfFailGo(pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                                piMMCListItem));
            pMMCListItem->SetIndex(lIndex);
            if (NULL == pSnapIn)
            {
                pSnapIn = pMMCListItem->GetSnapIn();
            }
            RELEASE(piMMCListItem);
        }
    }

    // Put the arrays of scopitems and listitems into the data object

    pMMCDataObject->SetScopeItems(pScopeItems);
    pMMCDataObject->SetListItems(pMMCListItems);

    // Set the dataobject type to multiselect because we populated its
    // collections rather than its individual scope or list item.

    pMMCDataObject->SetType(CMMCDataObject::MultiSelect);

    // Give the dataobject a pointer to the owning CSnapIn

    pMMCDataObject->SetSnapIn(pSnapIn);

    // Return the IDataObject

    IfFailGo(punkDataObject->QueryInterface(IID_IDataObject,
                                            reinterpret_cast<void **>(ppiDataObject)));

    // Return the cookie. This is exactly the same kind of data object that we
    // would return from IComponent::QueryDataObject(MMC_MULTI_SELECT_COOKIE) so
    // return that special cookie.

    *pCookie = MMC_MULTI_SELECT_COOKIE;

Error:
    QUICK_RELEASE(punkDataObject);
    QUICK_RELEASE(punkScopeItems);
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(punkListItems);
    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}

HRESULT DataObjectFromObjects(VARIANT       varObjects,
                              MMC_COOKIE   *pCookie,
                              IDataObject **ppiDataObject)
{
    HRESULT          hr = S_OK;
    LONG             cObjects = 0;
    BOOL             fHaveArray = FALSE;
    IUnknown        *punkObject = NULL; // Not AddRef()ed
    IUnknown HUGEP **ppunkObjects = NULL;

    // Check that the variant contains one of the following:
    // IUnknown, IDispatch, array of IUnknown, array of IDispatch

    if ( (varObjects.vt == (VT_ARRAY | VT_UNKNOWN)) ||
         (varObjects.vt == (VT_ARRAY | VT_DISPATCH)) )
    {
        IfFailGo(::GetObjectArray(varObjects.parray, &cObjects, &ppunkObjects));
        fHaveArray = TRUE;
    }
    else if (varObjects.vt == VT_UNKNOWN)
    {
        punkObject = varObjects.punkVal;
    }
    else if (varObjects.vt == VT_DISPATCH)
    {
        punkObject = static_cast<IUnknown *>(varObjects.pdispVal);
    }
    else
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // If it is a single object then figure out which type and get its existing
    // data object

    if (NULL != punkObject)
    {
        IfFailGo(::DataObjectFromSingleObject(punkObject, pCookie, ppiDataObject));
    }
    else
    {
        // It is an array. Create a new multi-select data object for it
        IfFailGo(::DataObjectFromObjectArray(ppunkObjects, cObjects,
                                             pCookie, ppiDataObject));
    }

Error:
    if (fHaveArray)
    {
        (void)::SafeArrayUnaccessData(varObjects.parray);
    }
    RRETURN(hr);
}



HRESULT GetSnapInCLSID
(
    BSTR   bstrNodeTypeGUID,
    char   szClsid[],
    size_t cbClsid
)
{
    HRESULT  hr = S_OK;
    long     lRc = ERROR_SUCCESS;
    BSTR     bstrGUID = NULL;
    char    *pszKeyName = NULL;
    HKEY     hkey = NULL;
    WCHAR   *pwszClsid = NULL;
    DWORD    cbValue = cbClsid;

    IfFailGo(::CreateKeyNameW(KEY_SNAPIN_CLSID, KEY_SNAPIN_CLSID_LEN,
                              bstrNodeTypeGUID, &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0, KEY_QUERY_VALUE,
                         &hkey);
    if (ERROR_SUCCESS == lRc)
    {
        // Read the key's default value
        lRc = ::RegQueryValueEx(hkey, NULL, NULL, NULL,
                                (LPBYTE)szClsid, &cbValue);
    }
    if (ERROR_SUCCESS != lRc)
    {
        hr = HRESULT_FROM_WIN32(lRc);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    else if (0 == ::strlen(szClsid))
    {
        hr = SID_E_INTERNAL;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }
    RRETURN(hr);
}



HRESULT GetData
(
    IDataObject *piDataObject,
    CLIPFORMAT   cf,
    HGLOBAL     *phData
)
{
    HRESULT hr = S_OK;
    HGLOBAL hGlobal = NULL;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, 512);
    if (NULL == hGlobal)
    {
        hr = HRESULT_FROM_WIN32(hr);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    FmtEtc.cfFormat = cf;
    FmtEtc.dwAspect = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;
    StgMed.hGlobal = hGlobal;

    hr = piDataObject->GetDataHere(&FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        *phData = StgMed.hGlobal;
    }

Error:
    if ( FAILED(hr) && (NULL != hGlobal) )
    {
        (void)::GlobalFree(hGlobal);
    }
    RRETURN(hr);
}


HRESULT GetStringData
(
    IDataObject *piDataObject,
    CLIPFORMAT   cf,
    BSTR        *pbstrData
)
{
    HGLOBAL  hGlobal = NULL;
    HRESULT  hr = ::GetData(piDataObject, cf, &hGlobal);
    OLECHAR *pwszData = NULL;

    if (SUCCEEDED(hr))
    {
        pwszData = (OLECHAR *)::GlobalLock(hGlobal);
        if (NULL != pwszData)
        {
            *pbstrData = ::SysAllocString(pwszData);
            if (NULL == *pbstrData)
            {
                hr = SID_E_OUTOFMEMORY;
            }
            (void)::GlobalUnlock(hGlobal);
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (NULL != hGlobal)
    {
        (void)::GlobalFree(hGlobal);
    }
    RRETURN(hr);
}


HRESULT WriteSafeArrayToStream
(
    SAFEARRAY             *psa,
    IStream               *piStream,
    WriteSafeArrayOptions  Option
)
{
    HRESULT     hr = S_OK;
    ULONG       cbToWrite = 0;
    ULONG       cbWritten = 0;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    void HUGEP *pvArrayData = NULL;

    hr = ::SafeArrayAccessData(psa, &pvArrayData);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Get its size. As we only allow one-dimensional Byte arrays, the lower
    // and upper bounds of the 1st dimension will give us the size in bytes.

    hr = ::SafeArrayGetLBound(psa, 1, &lLBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psa, 1, &lUBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Write the bytes to the stream.

    cbToWrite = (lUBound - lLBound) + 1L;

    // If requested write the length to the stream

    if (WriteLength == Option)
    {
        hr = piStream->Write(&cbToWrite, sizeof(cbToWrite), &cbWritten);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
        if (cbWritten != sizeof(cbToWrite))
        {
            hr = SID_E_INCOMPLETE_WRITE;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }
    
    hr = piStream->Write(pvArrayData, cbToWrite, &cbWritten);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(psa);
    }

    RRETURN(hr);
}


HRESULT GetImageIndex
(
    IMMCListView *piMMCListView,
    VARIANT       varIndex,
    int          *pnIndex
)
{
    HRESULT        hr = S_OK;
    long           lIndex = 0;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    IMMCImage     *piMMCImage = NULL;

    // Look up the image in ListView.Icons.ListImages and get its index property.

    IfFailGo(piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
    IfFalseGo(NULL != piMMCImageList, S_OK);
    IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImages->get_Item(varIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(piMMCImage->get_Index(&lIndex));
    *pnIndex = static_cast<int>(lIndex);

Error:
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CheckVariantForCrossThreadUsage
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  *pvar        [in, out] Variant to check
//
// Output:
//      If VARIANT is object, array or VARIANT BYREF then element is
//      dereferenced and VT_BYREF is removed.
//
//      Checks for supported types and array types. Unsupported types
//      will return SID_E_INVALIDARG. See switch statements for supported
//      types.
//
//
// Notes:
//
// VT_UNKNOWN and VT_DISPATCH are supported types. If present the caller must
// marshal the interface pointers. Anything else is usable across threads
// providing there are no problems of simultaneous access.
//

HRESULT CheckVariantForCrossThreadUsage(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    // Dereference the complex VARIANT types

    if (0 != (pvar->vt & VT_BYREF))
    {
        switch (pvar->vt & ~VT_BYREF)
        {
            case VT_UNKNOWN:
                pvar->punkVal = *(pvar->ppunkVal);
                pvar->vt = VT_UNKNOWN;
                break;

            case VT_DISPATCH:
                pvar->pdispVal = *(pvar->ppdispVal);
                pvar->vt = VT_DISPATCH;
                break;

            case VT_ARRAY:
                pvar->parray = *(pvar->pparray);
                pvar->vt = VT_ARRAY;
                break;

            case VT_VARIANT:
                *pvar = *(pvar->pvarVal);
                pvar->vt = VT_VARIANT;
                break;

            default:
                break;
        }
    }

    // Weed out unsupported base types

    switch (pvar->vt & ~VT_ARRAY)
    {
        case VT_UI1:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
            break;

        default:
            hr = SID_E_INVALIDARG;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Weed out unsupported array types

    if ( (pvar->vt & VT_ARRAY) != 0 )
    {
        switch (pvar->vt)
        {
            case VT_I4:
            case VT_UI1:
            case VT_I2:
            case VT_R4:
            case VT_R8:
            case VT_BOOL:
            case VT_ERROR:
            case VT_DATE:
            case VT_CY:
            case VT_BSTR:
                break;

            default:
                hr = SID_E_INVALIDARG;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


HRESULT GetColumnSetID
(
    BSTR           bstrColSetID,
    SColumnSetID **ppSColumnSetID
)
{
    HRESULT hr = S_OK;
    DWORD   cbColSetID = 0;

    *ppSColumnSetID = NULL;

    if (!ValidBstr(bstrColSetID))
    {
        hr = SID_E_INVALID_COLUMNSETID;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    cbColSetID = ::wcslen(bstrColSetID) * sizeof(WCHAR);
    *ppSColumnSetID = (SColumnSetID *)CtlAllocZero(sizeof(SColumnSetID) + cbColSetID);

    if (NULL == *ppSColumnSetID)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    (*ppSColumnSetID)->dwFlags = 0;
    (*ppSColumnSetID)->cBytes = cbColSetID;
    ::memcpy((*ppSColumnSetID)->id, bstrColSetID, cbColSetID);

Error:
    RRETURN(hr);
}


HRESULT PropertyBagFromStream
(
    IStream       *piStream,
    _PropertyBag **pp_PropertyBag
)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;
    ULONG         cbRead = 0;
    ULONG         cbToRead = 0;
    void HUGEP   *pvArrayData = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Read the array length from the stream

    hr = piStream->Read(&cbToRead, sizeof(cbToRead), &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (cbRead != sizeof(cbToRead))
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Allocate a SafeArray of VT_UI1 of that size and access its data

    var.parray = ::SafeArrayCreateVector(VT_UI1, 1, cbToRead);
    if (NULL == var.parray)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    var.vt = VT_ARRAY | VT_UI1;

    hr = ::SafeArrayAccessData(var.parray, &pvArrayData);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Read the data from the stream

    hr = piStream->Read(pvArrayData, cbToRead, &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (cbRead != cbToRead)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Unaccess the SafeArray so it can be cleaned up in VariantClear() below

    hr = ::SafeArrayUnaccessData(var.parray);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    pvArrayData = NULL;

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Set its contents from the data

    IfFailGo(p_PropertyBag->put_Contents(var));

    // Return it to the caller

    p_PropertyBag->AddRef();
    *pp_PropertyBag = p_PropertyBag;

Error:
    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(var.parray);
    }
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag)
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdef.cpp ===
//=--------------------------------------------------------------------------=
// scitdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scitdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CScopeItemDef::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_ScopeItemDefGeneralPP,
    &CLSID_ScopeItemDefColHdrsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItemDef::CScopeItemDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_SCOPEITEMDEF,
                            static_cast<IScopeItemDef *>(this),
                            static_cast<CScopeItemDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeItemDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItemDef::~CScopeItemDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    (void)::VariantClear(&m_varFolder);
    FREESTRING(m_bstrDefaultDataFormat);
    FREESTRING(m_bstrDefaultView);
    RELEASE(m_piViewDefs);
    RELEASE(m_piChildren);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piColumnHeaders);
    InitMemberVariables();
}

void CScopeItemDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;

    ::VariantInit(&m_varFolder);

    m_bstrDefaultDataFormat = NULL;
    m_AutoCreate = VARIANT_FALSE;
    m_bstrDefaultView = NULL;
    m_HasChildren = VARIANT_TRUE;
    m_Extensible = VARIANT_TRUE;
    m_piViewDefs = NULL;
    m_piChildren = NULL;

    ::VariantInit(&m_varTag);

    m_piColumnHeaders = NULL;
}

IUnknown *CScopeItemDef::Create(IUnknown * punkOuter)
{
    CScopeItemDef *pScopeItemDef = New CScopeItemDef(punkOuter);
    if (NULL == pScopeItemDef)
    {
        return NULL;
    }
    else
    {
        return pScopeItemDef->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                          IScopeItemDef Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItemDef::put_Folder(VARIANT varFolder)
{
    HRESULT hr = S_OK;
    long    lFolder = 0;

    // This property can be entered in the property browser at design time.
    // Its default value is an empty string. If the user types in a number
    // then VB will convert it to a string. If the user does not use the
    // same number as the key of the image, then the runtime won't find the
    // image. To prevent this, we check if the property is a string, and if so,
    // then we check if it is only digits. If it is only digits then we convert
    // it to VT_I4.

    if (VT_BSTR == varFolder.vt)
    {
        hr = ::ConvertToLong(varFolder, &lFolder);
        if (S_OK == hr)
        {
            varFolder.vt = VT_I4;
            varFolder.lVal = lFolder;
        }
    }
    IfFailGo(SetVariant(varFolder, &m_varFolder, DISPID_SCOPEITEMDEF_FOLDER));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=


HRESULT CScopeItemDef::OnSetHost()
{
    HRESULT hr = S_OK;
    IfFailRet(SetObjectHost(m_piChildren));
    IfFailRet(SetObjectHost(m_piViewDefs));
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDef::Persist()
{
    HRESULT hr = S_OK;
    GUID    NodeTypeGUID = GUID_NULL;

    WCHAR   wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    VARIANT varTagDefault;
    VariantInit(&varTagDefault);

    VARIANT varFolderDefault;
    VariantInit(&varFolderDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    // On InitNew generate a node type GUID

    if (InitNewing())
    {
        IfFailGo(::CoCreateGuid(&NodeTypeGUID));
        if (0 ==::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                  sizeof(wszNodeTypeGUID) /
                                  sizeof(wszNodeTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, wszNodeTypeGUID, OLESTR("NodeTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailGo(PersistVariant(&m_varFolder, varFolderDefault, OLESTR("Folder")));

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

    IfFailGo(PersistSimpleType(&m_AutoCreate, VARIANT_FALSE, OLESTR("AutoCreate")));

    IfFailGo(PersistBstr(&m_bstrDefaultView, L"", OLESTR("DefaultView")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 6) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_HasChildren, VARIANT_TRUE, OLESTR("HasChildren")));
    }

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                           OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                           OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_ScopeItemDefs,
                           OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                           OLESTR("Children")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    // Tell ViewDefs that all collections should serialize keys only as the
    // actual objects are stored in the master collections owned by
    // SnapInDesignerDef. We only need to serialize the view names. 

    if (InitNewing())
    {
        IfFailGo(UseKeysOnly(m_piViewDefs));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeItemDef == riid)
    {
        *ppvObjOut = static_cast<IScopeItemDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtutil.h ===
//=--------------------------------------------------------------------------=
// rtutil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Runtime Utility Functions
//
//=--------------------------------------------------------------------------=

#ifndef _RTUTIL_DEFINED_
#define _RTUTIL_DEFINED_


class CMMCListItems;
class CMMCListItem;
class CScopeItem;
class CSnapIn;
class CMMCClipboard;
class CMMCDataObject;
class CScopePaneItem;

struct IMMCListItem;
struct IMMCListItems;
struct IMMCImages;
struct IMMCClipboard;

// Test whether a VARIANT contains an object

BOOL IsObject(VARIANT var);

// Test whether a VARIANT contains a string and return the BSTR

BOOL IsString(VARIANT var, BSTR *pbstr);

// Convert a VARIANT to a long

HRESULT ConvertToLong(VARIANT var, long *pl);

// String conversion routines. Returned buffer is freed using CtlFree().

HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
HRESULT WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr);
HRESULT BSTRFromANSI(char *pszAnsi, BSTR *pbstr);

// Allocate a buffer using CoTaskMemAlloc() and copy a string to it

HRESULT CoTaskMemAllocString(WCHAR *pwszString, LPOLESTR *ppszOut);

// Create registry key names using a prefix and suffix. These routines
// concatenate the two strings into a buffer allocated with CtlAlloc()

HRESULT CreateKeyName(char *pszPrefix, size_t cbPrefix,
                      char *pszSuffix, size_t cbSuffix,
                      char **ppszKeyName);

HRESULT CreateKeyNameW(char *pszPrefix, size_t cbPrefix,
                       WCHAR *pwszSuffix,
                       char  **ppszKeyName);


// Get HBITMAP or HICON out of an image list item

HRESULT GetPicture(IMMCImages *piMMCImages,
                   VARIANT     varIndex,
                   short       TypeNeeded,
                   OLE_HANDLE *phPicture);


// Get HBITMAP or HICON out of an IPictureDisp

HRESULT GetPictureHandle(IPictureDisp *piPictureDisp,
                         short         TypeNeeded,
                         OLE_HANDLE   *phPicture);


// Set a picture object with an empty bitmap

HRESULT CreateEmptyBitmapPicture(IPictureDisp **ppiPictureDisp);
HRESULT CreateIconPicture(IPictureDisp **ppiPictureDisp, HICON hicon);
HRESULT CreatePicture(IPictureDisp **ppiPictureDisp, PICTDESC *pDesc);


// Create a copy of a bitmap

HRESULT CopyBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy);

// Clone a persistable object using serialization to a stream on an HGLOBAL

HRESULT CloneObject(IUnknown *punkSrc, IUnknown *punkDest);

// Clone a list item (uses CloneObject)

HRESULT CloneListItem(CMMCListItem *pMMCListItemSrc,
                      IMMCListItem **ppiMMCListItemClone);

// Clones a list item and adds it a specified collection

HRESULT CloneListItemIntoCollection(CMMCListItem  *pListItemSrc,
                                    IMMCListItems *piMMCListItems);


// Convert SnapInViewModeConstants to MMC_VIEW_STYLE_XXXX contants and vice-versa

void VBViewModeToMMCViewMode(SnapInViewModeConstants  VBViewMode,
                             long                    *pMMCViewMode);

void MMCViewModeToVBViewMode(long                     MMCViewMode,
                             SnapInViewModeConstants *pVBViewMode);


// Create an MMCClipboard object holding the selection represented by
// an IDataObject received from MMC

HRESULT CreateSelection(IDataObject                   *piDataObject, 
                        IMMCClipboard                **ppiMMCClipboard,
                        CSnapIn                       *pSnapIn,      
                        SnapInSelectionTypeConstants  *pSelectionType);

// Clones a single list item into MMCClipboard.ListItems

HRESULT AddListItemToClipboard(CMMCListItem  *pMMCListItem,
                               CMMCClipboard *pMMCClipboard);

// Clones a single scope item into MMCClipboard.ScopeItems

HRESULT AddScopeItemToClipboard(CScopeItem    *pScopeItem,
                                CMMCClipboard *pMMCClipboard);

// Extracts the snap-in's CLSID from
// HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type GUID>

HRESULT GetSnapInCLSID(BSTR bstrNodeTypeGUID, char szClsid[], size_t cbClsid);


// Extract the specified data using IDataObject->GetDataHere() with TYMED_HGLOBAL

HRESULT GetData(IDataObject *piDataObject, CLIPFORMAT cf, HGLOBAL *phData);


// Extract the specified string data using IDataObject->GetDataHere() with
// TYMED_HGLOBAL and copy it to a newly allocated BSTR

HRESULT GetStringData(IDataObject *piDataObject, CLIPFORMAT cf, BSTR *pbstrData);


// Write the contents of a one-dimensional VT_UI1 SafeArray to a stream.
// Optionally write the length of the array before the data.

enum WriteSafeArrayOptions { WriteLength, DontWriteLength };

HRESULT WriteSafeArrayToStream(SAFEARRAY             *psa,
                               IStream               *piStream,
                               WriteSafeArrayOptions  Option);


// Look up an image in MMCListView.Icons.ListImages and get its index property.
   
HRESULT GetImageIndex(IMMCListView *piMMCListView,
                      VARIANT       varIndex,
                      int          *pnIndex);


// Given a data object, check whether it represents a multiple selection
// i.e. supports CCF_MMC_MULTISELECT_DATAOBJECT(TRUE)

HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect);


// Given a multi-select data object from MMC (i.e. supports
// CCF_MMC_MULTISELECT_DATAOBJECT(TRUE) and CCF_MULTI_SELECT_SNAPINS), add the
// contained data objects to an MMCClipboard

HRESULT InterpretMultiSelect(IDataObject   *piDataObject,
                             CSnapIn       *pSnapIn,
                             CMMCClipboard *pMMCClipboard);


// Add a foreign data object to an MMCClipboard object

HRESULT AddForeignDataObject(IDataObject   *piDataObject,
                             CMMCClipboard *pMMCClipboard,
                             CSnapIn       *pSnapIn);


// Determine whether an IDataObject belongs to the snap-in.

void IdentifyDataObject(IDataObject     *piDataObject,
                        CSnapIn         *pSnapIn,
                        CMMCDataObject **ppMMCDataObject,
                        BOOL            *pfNotFromThisSnapIn);


// Add the contents of a data object to an MMCClipboard

HRESULT InterpretDataObject(IDataObject   *piDataObject,
                            CSnapIn       *pSnapIn,
                            CMMCClipboard *pMMCClipboard);

// Create an instance of a CSnapInAutomationObject derived class

template <class InterfaceType>
HRESULT CreateObject
(
    UINT            idObject,
    REFIID          iidObject,
    InterfaceType **ppiInterface
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkObject = NULL;

    // Double check that the create function exists

    if (NULL == CREATEFNOFOBJECT(idObject))
    {
        hr = SID_E_INTERNAL;
        GLOBAL_EXCEPTION_CHECK(hr);
    }

    // Create the object

    punkObject = CREATEFNOFOBJECT(idObject)(NULL);
    IfFalseGo(NULL != punkObject, SID_E_OUTOFMEMORY);

    // Get IPersistStreamInit on the object and load it

    H_IfFailGo(punkObject->QueryInterface(iidObject,
                                       reinterpret_cast<void **>(ppiInterface)));

Error:
    QUICK_RELEASE(punkObject);
    H_RRETURN(hr);
}
                     

// Get an MMCDataObject and a cookie for a VARIANT containing either a single
// ScopeItem, a single MMCListItem, or an array of Object containing ScopeItems
// and/or MMCListItems

HRESULT DataObjectFromObjects(VARIANT       varObjects,
                              MMC_COOKIE   *pCookie,
                              IDataObject **ppiDataObject);

// Get an MMCDataObject and a cookie for an IUnknown* on either a ScopeItem or
// an MMCListItem

HRESULT DataObjectFromSingleObject(IUnknown     *punkObject,
                                   MMC_COOKIE   *pCookie,
                                   IDataObject **ppiDataObject);

// Get an MMCDataObject and a cookie for an array of IUnknown*s on ScopeItems
// and/or MMCListItems

HRESULT DataObjectFromObjectArray(IUnknown HUGEP **ppunkObjects,
                                  LONG             cObjects,
                                  MMC_COOKIE      *pCookie,
                                  IDataObject    **ppiDataObject);

// Checks for supported types when using a VARIANT across threads.

HRESULT CheckVariantForCrossThreadUsage(VARIANT *pvar);

// Allocates an SNodeID2 structure and fills it with the specified column set
// ID string. Caller must free returned pointer with CtlFree().

HRESULT GetColumnSetID(BSTR           bstrColSetID, SColumnSetID **ppColumnSetID);

// Creates a property bag and fills it with the contents of a stream that
// contains the previously saved contents of a property bag

HRESULT PropertyBagFromStream(IStream *piStream, _PropertyBag **pp_PropertyBag);


#endif // _RTUTIL_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdef.h ===
//=--------------------------------------------------------------------------=
// scitdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMDEF_DEFINED_
#define _SCOPEITEMDEF_DEFINED_


class CScopeItemDef : public CSnapInAutomationObject,
                      public CPersistence,
                      public IScopeItemDef
{
    private:
        CScopeItemDef(IUnknown *punkOuter);
        ~CScopeItemDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeItemDef

        BSTR_PROPERTY_RW(CScopeItemDef,         Name,  DISPID_SCOPEITEMDEF_NAME);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       Index, long, DISPID_SCOPEITEMDEF_INDEX);
        BSTR_PROPERTY_RW(CScopeItemDef,         Key, DISPID_SCOPEITEMDEF_KEY);
        BSTR_PROPERTY_RW(CScopeItemDef,         NodeTypeName, DISPID_SCOPEITEMDEF_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CScopeItemDef,         NodeTypeGUID, DISPID_SCOPEITEMDEF_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW(CScopeItemDef,         DisplayName,  DISPID_SCOPEITEMDEF_DISPLAY_NAME);

        VARIANT_PROPERTY_RO(CScopeItemDef,      Folder, DISPID_SCOPEITEMDEF_FOLDER);
        STDMETHOD(put_Folder)(VARIANT varFolder);
        
        BSTR_PROPERTY_RW(CScopeItemDef,         DefaultDataFormat,  DISPID_SCOPEITEMDEF_DEFAULT_DATA_FORMAT);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       AutoCreate, VARIANT_BOOL, DISPID_SCOPEITEMDEF_AUTOCREATE);
        BSTR_PROPERTY_RW(CScopeItemDef,         DefaultView,  DISPID_SCOPEITEMDEF_DEFAULTVIEW);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       Extensible,  VARIANT_BOOL, DISPID_SCOPEITEMDEF_EXTENSIBLE);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       HasChildren,  VARIANT_BOOL, DISPID_SCOPEITEMDEF_HAS_CHILDREN);
        OBJECT_PROPERTY_RO(CScopeItemDef,       ViewDefs, IViewDefs, DISPID_SCOPEITEMDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CScopeItemDef,       Children, IScopeItemDefs, DISPID_SCOPEITEMDEF_CHILDREN);
        VARIANTREF_PROPERTY_RW(CScopeItemDef,   Tag, DISPID_SCOPEITEMDEF_TAG);
        OBJECT_PROPERTY_RW(CScopeItemDef,       ColumnHeaders, IMMCColumnHeaders, DISPID_SCOPEITEMDEF_COLUMN_HEADERS);

    // Public Utility Methods

    public:
        BOOL Extensible() { return VARIANTBOOL_TO_BOOL(m_Extensible); }
        BSTR GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItemDef,           // name
                                &CLSID_ScopeItemDef,    // clsid
                                "ScopeItemDef",         // objname
                                "ScopeItemDef",         // lblname
                                &CScopeItemDef::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IScopeItemDef,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _SCOPEITEMDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdefs.cpp ===
//=--------------------------------------------------------------------------=
// scitdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scitdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItemDefs::CScopeItemDefs(IUnknown *punkOuter) :
    CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>(
                      punkOuter,
                      OBJECT_TYPE_SCOPEITEMDEFS,
                      static_cast<IScopeItemDefs *>(this),
                      static_cast<CScopeItemDefs *>(this),
                      CLSID_ScopeItemDef,
                      OBJECT_TYPE_SCOPEITEMDEF,
                      IID_IScopeItemDef,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeItemDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItemDefs::~CScopeItemDefs()
{
}

IUnknown *CScopeItemDefs::Create(IUnknown * punkOuter)
{
    CScopeItemDefs *pScopeItemDefs = New CScopeItemDefs(punkOuter);
    if (NULL == pScopeItemDefs)
    {
        return NULL;
    }
    else
    {
        return pScopeItemDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDefs::Persist()
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piScopeItemDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>::Persist(piScopeItemDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IScopeItemDefs == riid)
    {
        *ppvObjOut = static_cast<IScopeItemDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdefs.h ===
//=--------------------------------------------------------------------------=
// scitdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMDEFS_DEFINED_
#define _SCOPEITEMDEFS_DEFINED_

#include "collect.h"

class CScopeItemDefs : public CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>,
                       public CPersistence
{
    protected:
        CScopeItemDefs(IUnknown *punkOuter);
        ~CScopeItemDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItemDefs,           // name
                                &CLSID_ScopeItemDefs,    // clsid
                                "ScopeItemDefs",         // objname
                                "ScopeItemDefs",         // lblname
                                &CScopeItemDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IScopeItemDefs,     // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _SCOPEITEMDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitem.cpp ===
//=--------------------------------------------------------------------------=
// scopitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "scopitem.h"
#include "scopnode.h"
#include "colhdrs.h"
#include "lsubitms.h"
#include "xtensons.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItem::CScopeItem(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPEITEM,
                           static_cast<IScopeItem *>(this),
                           static_cast<CScopeItem *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_ScopeItem,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItem::~CScopeItem()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varFolder);
    RELEASE(m_piData);
    FREESTRING(m_bstrDefaultDataFormat);
    RELEASE(m_piDynamicExtensions);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piScopeNode);
    RELEASE(m_piColumnHeaders);
    RELEASE(m_piListSubItems);
    RELEASE(m_piScopeItemDef);
    RELEASE(m_piDynamicExtensions);
    FREESTRING(m_bstrNodeID);
    InitMemberVariables();
}

void CScopeItem::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varFolder);

    m_piData = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_piDynamicExtensions = NULL;
    m_SlowRetrieval = VARIANT_FALSE;
    m_bstrNodeID = NULL;

    ::VariantInit(&m_varTag);

    m_piScopeNode = NULL;
    m_Pasted = VARIANT_FALSE;
    m_piColumnHeaders = NULL;
    m_piListSubItems = NULL;

    m_fIsStatic = FALSE;
    m_pSnapIn = NULL;
    m_pScopeNode = NULL;
    m_piScopeItemDef = NULL;
    m_pData = NULL;
    m_piDynamicExtensions = NULL;
    m_Bold = VARIANT_FALSE;
}

IUnknown *CScopeItem::Create(IUnknown * punkOuter)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkScopeItem = NULL;
    IUnknown        *punkScopeNode = NULL;
    IUnknown        *punkMMCColumnHeaders = NULL;
    IUnknown        *punkMMCListSubItems = NULL;
    IUnknown        *punkMMCDataObject = NULL;

    CScopeItem *pScopeItem = New CScopeItem(punkOuter);

    IfFalseGo(NULL != pScopeItem, SID_E_OUTOFMEMORY);
    punkScopeItem = pScopeItem->PrivateUnknown();

    // Create contained objects

    punkScopeNode = CScopeNode::Create(NULL);
    if (NULL == punkScopeNode)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopeNode->QueryInterface(IID_IScopeNode,
                                           reinterpret_cast<void **>(&pScopeItem->m_piScopeNode)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pScopeItem->m_piScopeNode, &pScopeItem->m_pScopeNode));
    pScopeItem->m_pScopeNode->SetScopeItem(pScopeItem);

    punkMMCColumnHeaders = CMMCColumnHeaders::Create(NULL);
    if (NULL == punkMMCColumnHeaders)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCColumnHeaders->QueryInterface(IID_IMMCColumnHeaders,
                    reinterpret_cast<void **>(&pScopeItem->m_piColumnHeaders)));

    punkMMCListSubItems = CMMCListSubItems::Create(NULL);
    if (NULL == punkMMCListSubItems)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCListSubItems->QueryInterface(IID_IMMCListSubItems,
                     reinterpret_cast<void **>(&pScopeItem->m_piListSubItems)));

    punkMMCDataObject = CMMCDataObject::Create(NULL);
    if (NULL == punkMMCDataObject)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCDataObject->QueryInterface(IID_IMMCDataObject,
                              reinterpret_cast<void **>(&pScopeItem->m_piData)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pScopeItem->m_piData, &pScopeItem->m_pData));
    pScopeItem->m_pData->SetType(CMMCDataObject::ScopeItem);
    pScopeItem->m_pData->SetScopeItem(pScopeItem);

Error:
    QUICK_RELEASE(punkScopeNode);
    QUICK_RELEASE(punkMMCColumnHeaders);
    QUICK_RELEASE(punkMMCListSubItems);
    QUICK_RELEASE(punkMMCDataObject);
    if (FAILED(hr))
    {
        RELEASE(punkScopeItem);
    }
    return punkScopeItem;
}

LPOLESTR CScopeItem::GetDisplayNamePtr()
{
    return m_pScopeNode->GetDisplayNamePtr();
}

void CScopeItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pData->SetSnapIn(pSnapIn);
}

void CScopeItem::SetScopeItemDef(IScopeItemDef *piScopeItemDef)
{
    RELEASE(m_piScopeItemDef);
    if (NULL != piScopeItemDef)
    {
        piScopeItemDef->AddRef();
    }
    m_piScopeItemDef = piScopeItemDef;
}

void CScopeItem::SetData(IMMCDataObject *piMMCDataObject)
{
    RELEASE(m_piData);
    if (NULL != piMMCDataObject)
    {
        piMMCDataObject->AddRef();
    }
    m_piData = piMMCDataObject;
}

HRESULT CScopeItem::GetImageIndex(int *pnImage)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    IMMCImage     *piMMCImage = NULL;
    long           lIndex = 0;

    *pnImage = 0;

    IfFalseGo(NULL != m_pSnapIn, S_OK);

    IfFalseGo(VT_EMPTY != m_varFolder.vt, S_OK);

    IfFailGo(m_pSnapIn->get_SmallFolders(reinterpret_cast<MMCImageList **>(&piMMCImageList)));

    // If there is an image list then get the item and return its index

    if (NULL != piMMCImageList)
    {
        IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
        IfFailGo(piMMCImages->get_Item(m_varFolder, reinterpret_cast<MMCImage **>(&piMMCImage)));
        IfFailGo(piMMCImage->get_Index(&lIndex));
        *pnImage = static_cast<int>(lIndex);
    }

Error:
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT CScopeItem::RemoveChild(IScopeNode *piScopeNode)
{
    HRESULT       hr = S_OK;
    VARIANT_BOOL  fvarOwned = VARIANT_FALSE;
    CScopeNode   *pScopeNode = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    IfFailGo(piScopeNode->get_Owned(&fvarOwned));

    if (VARIANT_TRUE == fvarOwned)
    {
        IfFailGo(m_pSnapIn->GetScopeItems()->Remove(
                                      pScopeNode->GetScopeItem()->GetNamePtr()));
    }
    else
    {
        // This case would occur for a child belonging to a namespace extension
        // of the snap-in

        hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(
                                              pScopeNode->GetHSCOPEITEM(), TRUE);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CScopeItem::GiveHSCOPITEMToDynamicExtensions(HSCOPEITEM hsi)
{
    HRESULT      hr = S_OK;
    CExtensions *pExtensions = NULL;

    // If we have not yet populated ScopeItem.DynamicExtensions then there
    // is nothing to do.

    IfFalseGo(NULL != m_piDynamicExtensions, S_OK);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piDynamicExtensions,
                                                  &pExtensions));
    IfFailGo(pExtensions->SetHSCOPEITEM(hsi));

Error:
    RRETURN(hr);
}

HRESULT CScopeItem::SetFolder(VARIANT varFolder)
{
    HRESULT  hr = S_OK;
    int      nImage = 0;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // Check for a good VT

    if ( (!IS_VALID_INDEX_TYPE(varFolder)) && (!ISEMPTY(varFolder)) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the new value is an empty string or a NULL string then change that to
    // VT_EMPTY as they mean the same thing.

    if (VT_BSTR == varFolder.vt)
    {
        if (NULL == varFolder.bstrVal)
        {
            varFolder.vt = VT_EMPTY;
        }
        else if (0 == ::wcslen(varFolder.bstrVal))
        {
            varFolder.vt = VT_EMPTY;
        }
    }

    // Set ScopeItem.Folder

    IfFailGo(SetVariant(varFolder, &m_varFolder, DISPID_SCOPEITEM_FOLDER));

    // If being set to Empty then nothing else to do.

    IfFalseGo(!ISEMPTY(varFolder), S_OK);

    // If ScopeItem is disconnected (user created it with Dim) or this
    // is the static node, then we're done

    IfFalseGo(NULL != m_pSnapIn, S_OK);

    // Make sure we have the HSCOPEITEM. The static node scope item is
    // created before the HSCOPEITEM is available.

    IfFalseGo(m_pScopeNode->HaveHsi(), S_OK);

    // OK, this is a real scope item. If the snap-in has scope pane image
    // lists then we need to change the image index in the console.

    // Check if the index is valid in the snap-in scope pane image lists.

    hr = GetImageIndex(&nImage);

    // If it is a bad index then return invalid arg.

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check for other possible errors

    IfFailGo(hr);

    // Index is good. Change it in the console.
    // Adjust the open image index by the total images. See
    // CSnapIn::AddScopeItemImages() in snapin.cpp for explanation.

    sdi.nImage = nImage;
    sdi.nOpenImage = nImage + static_cast<int>(m_pSnapIn->GetImageCount());
    sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
    sdi.ID = m_pScopeNode->GetHSCOPEITEM();

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          IScopeItem Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItem::put_Folder(VARIANT varFolder)
{
    HRESULT  hr = S_OK;

    IfFailGo(SetFolder(varFolder));

    // If this is the static node then set SnapIn.StaticFolder too

    if ( m_fIsStatic && (NULL != m_pSnapIn) )
    {
        IfFailGo(m_pSnapIn->SetStaticFolder(varFolder));
    }

Error:

    RRETURN(hr);
}


STDMETHODIMP CScopeItem::get_Folder(VARIANT *pvarFolder)
{
    RRETURN(GetVariant(pvarFolder, m_varFolder));
}


STDMETHODIMP CScopeItem::get_SubItems
(
    short Index,
    BSTR *pbstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->get_Text(pbstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}

STDMETHODIMP CScopeItem::put_SubItems
(
    short Index,
    BSTR  bstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->put_Text(bstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}



STDMETHODIMP CScopeItem::PropertyChanged(VARIANT Data)
{
    HRESULT      hr = S_OK;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Fire ScopeItems_PropertyChanged for this scope item with the specified
    // data.
    
    m_pSnapIn->GetScopeItems()->FirePropertyChanged(
                                                 static_cast<IScopeItem *>(this),
                                                 Data);

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeItem::RemoveChildren()
{
    HRESULT      hr = S_OK;
    IScopeNode  *piChild = NULL;
    IScopeNode  *piNextChild = NULL;
    CScopeNode  *pChild = NULL;
    CScopeItems *pScopeItems = NULL;
    CScopeItem  *pScopeItem = NULL;
    long         cScopeItems = 0;
    long         i = 0;


    // If this is a ScopeItem a user created with Dim As New then return an error

    if ( (NULL == m_pScopeNode) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    // The call to IConsoleNameSpace2::DeleteItem will generate
    // MMCN_REMOVE_CHILDREN notifications for the children of this node but
    // not for this node itself so we need to remove its children.
    // Unfortunately, after the DeleteItem call, we can no longer navigate
    // the scope tree to find this node's children because MMC will have
    // deleted them even though we still have the ScopeItems for them. The
    // solution is to enumerate the children first and mark each one for
    // removal. After the DeleteItem call we will then traverse the collection
    // and remove each marked ScopeItem.

    IfFailGo(m_pScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piChild)));

    while (NULL != piChild)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piChild, &pChild));
        pChild->MarkForRemoval();
        IfFailGo(piChild->get_Next(reinterpret_cast<ScopeNode **>(&piNextChild)));
        RELEASE(piChild);
        piChild = piNextChild;
        piNextChild = NULL;
    }

    // Tell MMC to delete the children of this item.

    hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(m_pScopeNode->GetHSCOPEITEM(),
                                                        FALSE);
    EXCEPTION_CHECK_GO(hr);

    // Remove all of the marked child  scope items
    pScopeItems = m_pSnapIn->GetScopeItems();
    cScopeItems = pScopeItems->GetCount();

    i = 0;
    while (i < cScopeItems)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                  pScopeItems->GetItemByIndex(i), &pScopeItem));
        if (pScopeItem->GetScopeNode()->MarkedForRemoval())
        {
            // This function will also remove all of the corresponding
            // ScopePaneItems in all of the existing Views.
            
            IfFailGo(pScopeItems->RemoveByNode(pScopeItem->GetScopeNode(), FALSE));

            // Update the count of ScopeItems because it just changed when we
            // removed this ScopeItem.
            cScopeItems = pScopeItems->GetCount();
        }
        else
        {
            // We only increment the index when we don't remove a ScopeItem.
            // When a ScopeItem is removed, the indexes of all ScopeItems
            // after it are decremented.
            i++;
        }
    }

Error:
    QUICK_RELEASE(piChild);
    QUICK_RELEASE(piNextChild);
    RRETURN(hr);
}





STDMETHODIMP CScopeItem::get_DynamicExtensions(Extensions **ppExtensions)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkExtensions = NULL;
    CExtensions  *pExtensions = NULL;
    IExtension   *piExtension = NULL;
    VARIANT_BOOL  fvarExtensible = VARIANT_TRUE;

    // If the node is not extensible then return an error.

    if (m_fIsStatic)
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_Extensible(&fvarExtensible));
    }
    else if (NULL != m_piScopeItemDef)
    {
        IfFailGo(m_piScopeItemDef->get_Extensible(&fvarExtensible));
    }

    if (VARIANT_FALSE == fvarExtensible)
    {
        hr = SID_E_NOT_EXTENSIBLE;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piDynamicExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));

    IfFailGo(pExtensions->Populate(m_pScopeNode->GetNodeTypeGUID(),
                                   CExtensions::Dynamic));


    // Give the extension's a back pointer to the snap-in and our HSCOPEITEM
    // if we have it. For all ScopeItems except the static node we should
    // have the HSCOPEITEM by the time a snap-in can call this method (i.e.
    // access ScopeItem.DynamicExtensions). For the static node, the snap-in
    // will receive ScopeItems_Initialize before MMC has given us its HSCOPEITEM.
    
    IfFailGo(pExtensions->SetSnapIn(m_pSnapIn));

    if (m_pScopeNode->HaveHsi())
    {
        IfFailGo(pExtensions->SetHSCOPEITEM(m_pScopeNode->GetHSCOPEITEM()));
    }

    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                             reinterpret_cast<void **>(&m_piDynamicExtensions)));

Error:

    if (SUCCEEDED(hr))
    {
        m_piDynamicExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piDynamicExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    RRETURN(hr);
}




STDMETHODIMP CScopeItem::put_Bold(VARIANT_BOOL fvarBold)
{
    HRESULT hr = S_OK;
    UINT    nCurrentState = 0;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    if ( (NULL == m_pScopeNode) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    m_Bold = fvarBold;

    IfFalseGo(m_pScopeNode->HaveHsi(), S_OK);

    sdi.mask = SDI_STATE;
    sdi.ID = m_pScopeNode->GetHSCOPEITEM();
    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    nCurrentState = sdi.nState;
    
    if (VARIANT_TRUE == fvarBold)
    {
        sdi.nState &= ~MMC_SCOPE_ITEM_STATE_NORMAL;
        sdi.nState |= MMC_SCOPE_ITEM_STATE_BOLD;
    }
    else
    {
        sdi.nState |= MMC_SCOPE_ITEM_STATE_NORMAL;
        sdi.nState &= ~MMC_SCOPE_ITEM_STATE_BOLD;
    }

    if (nCurrentState != sdi.nState)
    {
        hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItem::Persist()
{
    HRESULT hr = S_OK;
    BSTR    bstrImagesKey = NULL;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varFolder, varDefault, OLESTR("Folder")));

    // NOTE: we don't persist data because there is no way to guarantee that
    // all objects in there are persistable

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

    IfFailGo(PersistObject(&m_piDynamicExtensions, CLSID_Extensions, OBJECT_TYPE_EXTENSIONS, IID_IExtensions, OLESTR("DynamicExtensions")));

    IfFailGo(PersistSimpleType(&m_SlowRetrieval, VARIANT_FALSE, OLESTR("SlowRetrieval")));

    // We don't persist the tag because it may contain a non-persistable
    // object. Any runtime code that needs to clone a scopeitem using
    // persistence must copy the tag.

    if (InitNewing())
    {
        IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));
    }

    IfFailGo(PersistObject(&m_piScopeNode, CLSID_ScopeNode,
                           OBJECT_TYPE_SCOPENODE, IID_IScopeNode,
                           OLESTR("ScopeNode")));

    IfFailGo(PersistSimpleType(&m_Pasted, VARIANT_FALSE, OLESTR("Pasted")));

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    IfFailGo(PersistObject(&m_piListSubItems, CLSID_MMCListSubItems,
                           OBJECT_TYPE_MMCLISTSUBITEMS, IID_IMMCListSubItems,
                           OLESTR("ListSubItems")));

    IfFailGo(PersistSimpleType(&m_Bold, VARIANT_FALSE, OLESTR("Bold")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeItem == riid)
    {
        *ppvObjOut = static_cast<IScopeItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitem.h ===
//=--------------------------------------------------------------------------=
// scopitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItem class definition - implements ScopeItem object
//
//=--------------------------------------------------------------------------=


#ifndef _SCOPITEM_DEFINED_
#define _SCOPITEM_DEFINED_

#include "dataobj.h"
#include "scopitms.h"
#include "scopnode.h"
#include "snapin.h"

class CSnapIn;
class CMMCDataObject;
class CScopeNode;

class CScopeItem : public CSnapInAutomationObject,
                   public CPersistence,
                   public IScopeItem
{
    private:
        CScopeItem(IUnknown *punkOuter);
        ~CScopeItem();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeItem
        BSTR_PROPERTY_RW(CScopeItem,        Name,                       DISPID_SCOPEITEM_NAME);
        SIMPLE_PROPERTY_RW(CScopeItem,      Index,                      long, DISPID_SCOPEITEM_INDEX);
        BSTR_PROPERTY_RW(CScopeItem,        Key,                        DISPID_SCOPEITEM_KEY);

        STDMETHOD(put_Folder)(VARIANT varFolder);
        STDMETHOD(get_Folder)(VARIANT *pvarFolder);

        COCLASS_PROPERTY_RO(CScopeItem,     Data,                       MMCDataObject, IMMCDataObject, DISPID_SCOPEITEM_DATA);
        BSTR_PROPERTY_RW(CScopeItem,        DefaultDataFormat,          DISPID_SCOPEITEM_DEFAULT_DATA_FORMAT);

        STDMETHOD(get_DynamicExtensions)(Extensions **ppExtensions);

        SIMPLE_PROPERTY_RW(CScopeItem,      SlowRetrieval,              VARIANT_BOOL, DISPID_SCOPEITEM_SLOW_RETRIEVAL);
        BSTR_PROPERTY_RW(CScopeItem,        NodeID,                     DISPID_SCOPEITEM_NODE_ID);
        VARIANTREF_PROPERTY_RW(CScopeItem,  Tag,                        DISPID_SCOPEITEM_TAG);
        COCLASS_PROPERTY_RO(CScopeItem,     ScopeNode,                  ScopeNode, IScopeNode, DISPID_SCOPEITEM_SCOPENODE);
        SIMPLE_PROPERTY_RW(CScopeItem,      Pasted,                     VARIANT_BOOL, DISPID_SCOPEITEM_PASTED);
        COCLASS_PROPERTY_RW(CScopeItem,     ColumnHeaders,              MMCColumnHeaders, IMMCColumnHeaders, DISPID_SCOPEITEM_COLUMN_HEADERS);

        STDMETHOD(get_SubItems)(short Index, BSTR *pbstrItem);
        STDMETHOD(put_SubItems)(short Index, BSTR bstrItem);

        COCLASS_PROPERTY_RW(CScopeItem,     ListSubItems,               MMCListSubItems, IMMCListSubItems, DISPID_SCOPEITEM_LIST_SUBITEMS);

        SIMPLE_PROPERTY_RO(CScopeItem,      Bold,                       VARIANT_BOOL, DISPID_SCOPEITEM_BOLD);
        STDMETHOD(put_Bold)(VARIANT_BOOL fvarBold);

        STDMETHOD(PropertyChanged(VARIANT Data));
        STDMETHOD(RemoveChildren());

    // Public utility methods
        BOOL IsStaticNode() { return m_fIsStatic; }
        void SetStaticNode() { m_fIsStatic = TRUE; }
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        BSTR GetNamePtr() { return m_bstrName; }
        LPOLESTR GetDisplayNamePtr();
        IScopeItemDef *GetScopeItemDef() { return m_piScopeItemDef; }
        void SetScopeItemDef(IScopeItemDef *piScopeItemDef);
        CScopeNode *GetScopeNode() { return m_pScopeNode; }
        void SetData(IMMCDataObject *piMMCDataObject);
        HRESULT GetImageIndex(int *pnImage);
        CMMCDataObject *GetData() { return m_pData; }
        IExtensions *GetDynamicExtensions() { return m_piDynamicExtensions; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        BSTR GetKey() { return m_bstrKey; }
        BSTR GetNodeID() { return m_bstrNodeID; }
        BOOL SlowRetrieval() { return VARIANTBOOL_TO_BOOL(m_SlowRetrieval); }
        HRESULT GiveHSCOPITEMToDynamicExtensions(HSCOPEITEM hsi);
        HRESULT SetFolder(VARIANT varFolder);

     // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT RemoveChild(IScopeNode *piScopeNode);
                
        BOOL            m_fIsStatic;           // TRUE=ScopeItem is for static node
        CSnapIn        *m_pSnapIn;             // bakc ptr to snap-in
        CScopeNode     *m_pScopeNode;          // ScopeItem.ScopeNode
        IScopeItemDef  *m_piScopeItemDef;      // ptr to design time def
        IExtensions    *m_piDynamicExtensions; // ScopeItem.DynamicExtensions
        VARIANT         m_varFolder;           // ScopeItem.Folder
        CMMCDataObject *m_pData;               // ScopeItem.Data
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItem,                 // name
                                &CLSID_ScopeItem,          // clsid
                                "ScopeItem",               // objname
                                "ScopeItem",               // lblname
                                CScopeItem::Create,        // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopeItem,           // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SCOPITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitms.h ===
//=--------------------------------------------------------------------------=
// scopitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItems class definition - implements ScopeItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMS_DEFINED_
#define _SCOPEITEMS_DEFINED_

#include "collect.h"
#include "scopitem.h"
#include "snapin.h"

class CSnapIn;
class CScopeItem;
class CSnapInCollection;
   
class CScopeItems : public CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>
{
    protected:
        CScopeItems(IUnknown *punkOuter);
        ~CScopeItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        void FireExpand(IScopeItem *piScopeItem);
        void FireCollapse(IScopeItem *piScopeItem);
        void FireExpandSync(IScopeItem *piScopeItem, BOOL *pfHandled);
        void FireCollapseSync(IScopeItem *piScopeItem, BOOL *pfHandled);
        void FireGetDisplayInfo(IScopeItem *piScopeItem);

        void FirePropertyChanged(IScopeItem *piScopeItem, VARIANT Data);
        void FireRename(IScopeItem *piScopeItem, BSTR bstrNewName);
        void FireHelp(IScopeItem *piScopeItem);
        void FireRemoveChildren(IScopeNode *piScopeNode);

        HRESULT AddStaticNode(CScopeItem **ppScopeItem);
        HRESULT RemoveStaticNode(CScopeItem *pScopeItem);
        HRESULT AddAutoCreateChildren(IScopeItemDefs *piScopeItemDefs,
                                      IScopeItem     *piParentScopeItem);
        void SetSnapIn(CSnapIn *pSnapIn);
        HRESULT RemoveChildrenOfNode(IScopeNode *piScopeNode);
        HRESULT RemoveByNode(IScopeNode *piScopeNode, BOOL fRemoveChildren);
        HRESULT RemoveScopeItemByKey(VARIANT varKey);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // IScopeItems

        STDMETHOD(get_Item)(VARIANT Index, IScopeItem **ppiScopeItem);

        STDMETHOD(Add)(BSTR                              Name,
                       ScopeNode                        *ScopeNodeRelative,
                       SnapInNodeRelationshipConstants   RelativeRelationship,
                       VARIANT                           HasChildren,
                       ScopeItem                       **ppScopeItem);

        STDMETHOD(AddPreDefined)(BSTR                              NodeTypeName,
                                 BSTR                              Name,
                                 ScopeNode                        *ScopeNodeRelative,
                                 SnapInNodeRelationshipConstants   RelativeRelationship,
                                 VARIANT                           HasChildren,
                                 ScopeItem                       **ppScopeItem);

        STDMETHOD(Remove)(BSTR Name);
        STDMETHOD(Clear)();

    private:


        HRESULT CreateScopeItem(BSTR bstrName, IScopeItem **ppiScopeItem);
        HRESULT RemoveScopeItemByName(BSTR bstrName);
        HRESULT InternalAddNew(BSTR                              bstrName,
                               BSTR                              bstrDisplayName,
                               BSTR                              bstrNodeTypeName,
                               BSTR                              bstrNodeTypeGUID,
                               IScopeNode                       *ScopeNodeRelative,
                               SnapInNodeRelationshipConstants   RelativeRelationship,
                               BOOL                              fHasChildren,
                               IScopeItem                      **ppiScopeItem);
        HRESULT InternalAddPredefined(BSTR                              bstrName,
                                      IScopeItemDef                    *piScopeItemDef,
                                      IScopeNode                       *ScopeNodeRelative,
                                      SnapInNodeRelationshipConstants   RelativeRelationship,
                                      VARIANT                           HasChildren,
                                      IScopeItem                      **ppiScopeItem);
        void FireInitialize(IScopeItem *piScopeItem);
        void FireTerminate(IScopeItem *piScopeItem);
        void InitMemberVariables();

        CSnapIn *m_pSnapIn; // bakc ptr to snap-in

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtExpand[1];
        static EVENTINFO m_eiExpand;

        static VARTYPE   m_rgvtCollapse[1];
        static EVENTINFO m_eiCollapse;

        static VARTYPE   m_rgvtExpandSync[2];
        static EVENTINFO m_eiExpandSync;

        static VARTYPE   m_rgvtCollapseSync[2];
        static EVENTINFO m_eiCollapseSync;

        static VARTYPE   m_rgvtGetDisplayInfo[1];
        static EVENTINFO m_eiGetDisplayInfo;

        static VARTYPE   m_rgvtQueryPagesFor[2];
        static EVENTINFO m_eiQueryPagesFor;

        static VARTYPE   m_rgvtCreatePropertyPages[2];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtPropertyChanged[2];
        static EVENTINFO m_eiPropertyChanged;

        static VARTYPE   m_rgvtRename[2];
        static EVENTINFO m_eiRename;

        static VARTYPE   m_rgvtHelp[1];
        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtRemoveChildren[1];
        static EVENTINFO m_eiRemoveChildren;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItems,                 // name
                                &CLSID_ScopeItems,          // clsid
                                "ScopeItems",               // objname
                                "ScopeItems",               // lblname
                                &CScopeItems::Create,       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IScopeItems,           // dispatch IID
                                &DIID_DScopeItemsEvents,    // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _SCOPEITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\siautobj.h ===
//=--------------------------------------------------------------------------=
// siautobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInAutomationObject class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SIAUTOBJ_DEFINED_
#define _SIAUTOBJ_DEFINED_

class CMMCDataObject;

//=--------------------------------------------------------------------------=
//
//          Helper Macros for Defining Common Property Types
//
//=--------------------------------------------------------------------------=


#define BSTR_PROPERTY_RO(ClassName, PropertyName, dispid) \
        BSTR m_bstr##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(BSTR *pbstrValue) \
        { \
            return GetBstr(pbstrValue, m_bstr##PropertyName); \
        }

#define BSTR_PROPERTY_RW(ClassName, PropertyName, dispid) \
        BSTR_PROPERTY_RO(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(BSTR bstrNewValue) \
        { \
            return SetBstr(bstrNewValue, &m_bstr##PropertyName, dispid); \
        }


// Simple properties: long, short, enums, etc.

#define SIMPLE_PROPERTY_RO(ClassName, PropertyName, PropertyType, dispid) \
        PropertyType m_##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(PropertyType *pValue) \
        { \
            return GetSimpleType(pValue, m_##PropertyName); \
        }

#define SIMPLE_PROPERTY_RW(ClassName, PropertyName, PropertyType, dispid) \
        SIMPLE_PROPERTY_RO(ClassName, PropertyName, PropertyType, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(PropertyType NewValue) \
        { \
            return SetSimpleType(NewValue, &m_##PropertyName, dispid); \
        }



#define VARIANT_PROPERTY_RO(ClassName, PropertyName, dispid) \
        VARIANT m_var##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(VARIANT *pvarValue) \
        { \
            return GetVariant(pvarValue, m_var##PropertyName); \
        }


#define VARIANT_PROPERTY_RW(ClassName, PropertyName, dispid) \
        VARIANT_PROPERTY_RO(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(VARIANT varNewValue) \
        { \
            return SetVariant(varNewValue, &m_var##PropertyName, dispid); \
        }



#define VARIANTREF_PROPERTY_RW(ClassName, PropertyName, dispid) \
        VARIANT_PROPERTY_RW(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(VARIANT varNewValue) \
        { \
            return SetVariant(varNewValue, &m_var##PropertyName, dispid); \
        }



#define OBJECT_PROPERTY_RO(ClassName, PropertyName, InterfaceName, dispid) \
        InterfaceName *m_pi##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(InterfaceName **ppiInterface) \
        { \
            return GetObject(ppiInterface, m_pi##PropertyName); \
        }



#define OBJECT_PROPERTY_RW(ClassName, PropertyName, InterfaceName, dispid) \
        OBJECT_PROPERTY_RO(ClassName, PropertyName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(InterfaceName *piInterface) \
        { \
            return SetObject(piInterface,\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }


#define OBJECT_PROPERTY_WO(ClassName, PropertyName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(InterfaceName *piInterface) \
        { \
            return SetObject(piInterface,\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }


#define COCLASS_PROPERTY_RO(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        InterfaceName *m_pi##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(CoClassName **ppCoClass) \
        { \
            InterfaceName *piInterface = NULL; \
            HRESULT        hr = GetObject(&piInterface, m_pi##PropertyName); \
            if (SUCCEEDED(hr)) \
            { \
                *ppCoClass = reinterpret_cast<CoClassName *>(piInterface); \
            } \
            else\
            { \
                *ppCoClass = NULL; \
            } \
            H_RRETURN(hr); \
        }

#define COCLASS_PROPERTY_RW(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        COCLASS_PROPERTY_RO(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(CoClassName *pCoClass) \
        { \
            return SetObject(reinterpret_cast<InterfaceName *>(pCoClass),\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }

//=--------------------------------------------------------------------------=
//
//          Helper Macros for Defining Common Property Types that Map to
//          a Contained Object's Properties
//
//=--------------------------------------------------------------------------=

// This is used by CListViewDef that contains a ListView object and exposes
// its properties at design time

#define X_PROPERTY_RW(ClassName, PropertyName, PropertyType, dispid, ContainedObject) \
    STDMETHODIMP ClassName##::get_##PropertyName(PropertyType *pValue) \
    { \
        HRESULT hr = S_OK; \
        if (NULL == m_pi##ContainedObject) \
        { \
            hr = SID_E_INTERNAL; \
            EXCEPTION_CHECK_GO(hr); \
        } \
        H_IfFailRet(m_pi##ContainedObject->get_##PropertyName(pValue)); \
    Error: \
        H_RRETURN(hr); \
    } \
    STDMETHODIMP ClassName##::put_##PropertyName(PropertyType NewValue) \
    { \
        HRESULT hr = S_OK; \
        if (NULL == m_pi##ContainedObject) \
        { \
            hr = SID_E_INTERNAL; \
            EXCEPTION_CHECK_GO(hr); \
        } \
        H_IfFailGo(m_pi##ContainedObject->put_##PropertyName(NewValue)); \
        hr = PropertyChanged(dispid); \
    Error: \
        H_RRETURN(hr); \
    }

//=--------------------------------------------------------------------------=
//
//                  Helper Macros for VARIANT parameters
//
//=--------------------------------------------------------------------------=

// Detect if an optional parameter was passed

#define ISPRESENT(var) \
    ( !((VT_ERROR == (var).vt) && (DISP_E_PARAMNOTFOUND == (var).scode)) )


// Give a VARIANT the value of a missing optional parameter

#define UNSPECIFIED_PARAM(var) { ::VariantInit(&var); \
                                 var.vt = VT_ERROR; \
                                 var.scode = DISP_E_PARAMNOTFOUND; }

#define ISEMPTY(var) (VT_EMPTY == (var).vt)

//=--------------------------------------------------------------------------=
//
// Convert a VARIANT_BOOL to a BOOL
// (the opposite is available in vb98ctls\include\ipserver.h)
//
//=--------------------------------------------------------------------------=

#define VARIANTBOOL_TO_BOOL(f) (VARIANT_TRUE == (f)) ? TRUE : FALSE

//=--------------------------------------------------------------------------=
//
// Negate a VARIANT_BOOL
//
//=--------------------------------------------------------------------------=

#define NEGATE_VARIANTBOOL(f) (VARIANT_TRUE == (f)) ? VARIANT_FALSE : VARIANT_TRUE

//=--------------------------------------------------------------------------=
//
// Validate a BSTR
//
// Checks that the BSTR is not NULL and is not an empty string
//
//=--------------------------------------------------------------------------=

#define ValidBstr(bstr) ( (NULL != (bstr)) ? (0 != ::wcslen(bstr)) : FALSE )

//=--------------------------------------------------------------------------=
//
// class CSnapInAutomationObject
//
// This is the base class for all objects in the designer object model. It
// derives from the framework's CAutomationObjectWEvents. It implements
// interfaces needed by most objects and sends IPropertySinkNotify notifications
// when a property value is changed.
//
// Note: all classes deriving from CSnapInAutomationObject must use
// DEFINE_AUTOMATIONOBJECTWEVENTS2 even if they do not have an event interface.
// This is necessary because CSnapInAutomationObject derives from
// CAutomationObjectWEvents. If the object does not have events then specify
// NULL for its events IID.
// This was done for simplicity reasons even though CAutomationObjectWEvents
// requires some additional memory over CAutomationObject.
//
// This class implements IObjectModel for all classes. The constructor takes
// a C++ pointer to the derived-most class that is available at any time
// by calling CSnapInAutomationObject::GetCxxObject on any interface pointer
// on the object. This eliminates any potential casting errors.
//
// This class also implements ISpecifyPropertyPages for any object that needs
// it. A class that needs this interface need only pass an array of its
// property page CLSIDs to the CSnapInAutomationObject constructor.
//
//=--------------------------------------------------------------------------=

class CSnapInAutomationObject : public CAutomationObjectWEvents,
                                public IObjectModel,
                                public ISpecifyPropertyPages,
                                public ISupportErrorInfo,
                                public CError
{
    protected:

        CSnapInAutomationObject(IUnknown     *punkOuter,
                                int           nObjectType,
                                void         *piMainInterface,
                                void         *pThis,
                                ULONG         cPropertyPages,
                                const GUID  **rgpPropertyPageCLSIDs,
                                CPersistence *pPersistence);

        ~CSnapInAutomationObject();

        DECLARE_STANDARD_SUPPORTERRORINFO();

        // Property get/set helpers

        // Get/set BSTR
        
        HRESULT SetBstr(BSTR bstrNew, BSTR *pbstrProperty, DISPID dispid);

        HRESULT GetBstr(BSTR *pbstrOut, BSTR bstrProperty);

        // Get/set VARIANT

        HRESULT SetVariant(VARIANT varNew, VARIANT *pvarProperty, DISPID dispid);

        HRESULT GetVariant(VARIANT *pvarOut, VARIANT varProperty);

        // Get set simple types - C types and enumerations

        template <class SimpleType> HRESULT GetSimpleType(SimpleType *pOut,
                                                          SimpleType  Property)
        {
            *pOut = Property;
            return S_OK;
        }

        template <class SimpleType> HRESULT SetSimpleType(SimpleType  NewValue,
                                                          SimpleType *pProperty,
                                                          DISPID      dispid)
        {
            HRESULT    hr = S_OK;
            SimpleType OldValue = *pProperty;

            // We keep a copy of the old value in case the change notification
            // fails. See PropertyChanged() in siautobj.cpp for how that works.
            
            *pProperty = NewValue;
            H_IfFailGo(PropertyChanged(dispid));

        Error:
            if (FAILED(hr))
            {
                *pProperty = OldValue;
            }
            H_RRETURN(hr);
        }

        // Get/set interface pointers

        template <class IObjectInterface>
        HRESULT SetObject(IObjectInterface  *piInterface,
                          REFIID             iidInterface,
                          IObjectInterface **ppiInterface,
                          DISPID             dispid)
        {
            HRESULT           hr = S_OK;
            IObjectInterface *piRequestedInterface = NULL;
            IObjectInterface *piOldValue = *ppiInterface;

            // If the new value is non-NULL then QI it to be sure it supports
            // the specified interface.

            if (NULL != piInterface)
            {
                hr = piInterface->QueryInterface(iidInterface,
                               reinterpret_cast<void **>(&piRequestedInterface));
                H_IfFalseRet(SUCCEEDED(hr), SID_E_INVALIDARG);
            }

            // The new interface pointer supports the specified
            // interface and it can be used. We have stored the old value
            // of the property in case the change is not accepted. (See
            // PropertyChanged() in siautobj.cpp for how that works). Store
            // the new property value.

            *ppiInterface = piRequestedInterface;

            H_IfFailGo(PropertyChanged(dispid));

            // Change was accepted. Release the old interface pointer.

            QUICK_RELEASE(piOldValue);

        Error:
            if (FAILED(hr))
            {
                // Either the QI failed or the change was refused. Revert to
                // the old value.

                *ppiInterface = piOldValue;

                // If the QI succeeded then we need to release it.
                QUICK_RELEASE(piRequestedInterface);
            }
            H_RRETURN(hr);
        }

        template <class IObjectInterface>
        HRESULT GetObject(IObjectInterface **ppiInterface,
                          IObjectInterface  *piInterface)
        {
            if (NULL != piInterface)
            {
                piInterface->AddRef();
            }
            *ppiInterface = piInterface;
            return S_OK;
        }

        // Helpers to call IObjectModelHost methods

        // Use this method to set dirty flag, notify prop sink and notify UI
        // after property has changed.

        HRESULT PropertyChanged(DISPID dispid);

        // Use this method to notify UI that there has been a property change

        HRESULT UIUpdate(DISPID dispid);

        // Use this method to get a this pointer from an IUnknown

    public:

        // GetCxxObject: static method that returns a typed C++ this pointer
        // for the object.
        
        template <class CObject>
        static HRESULT GetCxxObject(IUnknown *punkObject, CObject **ppObject)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFailRet(punkObject->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            *ppObject = static_cast<CObject *>(piObjectModel->GetThisPointer());
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Specializations of GetCxxObject

        static HRESULT GetCxxObject(IDataObject *piDataObject, CMMCDataObject **ppMMCDataObject);
        static HRESULT GetCxxObject(IMMCDataObject *piDataObject, CMMCDataObject **ppMMCDataObject);

    protected:

        // You must override this method to pass IObjectModel::SetHost
        // to contained objects.

        virtual HRESULT OnSetHost();

        // Use this method to pass SetHost notification to contained objects

        template <class IObjectInterface>
        HRESULT SetObjectHost(IObjectInterface *piInterface)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFalseRet(NULL != piInterface, S_OK);

            H_IfFailRet(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            hr = piObjectModel->SetHost(m_piObjectModelHost);
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Use this method to ask contained objects to release the host

        template <class IObjectInterface>
        HRESULT RemoveObjectHost(IObjectInterface *piInterface)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFalseRet(NULL != piInterface, S_OK);

            H_IfFailRet(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            hr = piObjectModel->SetHost(NULL);
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Use this method to get a non-AddRef()ed pointer to the host
        IObjectModelHost *GetHost() { return m_piObjectModelHost; }

        // Use this method in collections to notify the object model host of an
        // addition
        
        template <class IObjectInterface>
        HRESULT NotifyAdd(IObjectInterface *piInterface)
        {
            IUnknown *punkObject = NULL;
            HRESULT   hr = S_OK;

            H_IfFalseRet(NULL != m_piObjectModelHost, S_OK);
            H_IfFailRet(piInterface->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&punkObject)));
            hr = m_piObjectModelHost->Add(m_Cookie, punkObject);
            punkObject->Release();
            H_RRETURN(hr);
        }


        // Use this method in collections to notify the object model host of a
        // deletion

        template <class IObjectInterface>
        HRESULT NotifyDelete(IObjectInterface *piInterface)
        {
            HRESULT       hr = S_OK;
            IUnknown     *punkObject = NULL;
            IObjectModel *piObjectModel = NULL;
            long          Cookie = 0;

            H_IfFalseRet(NULL != m_piObjectModelHost, S_OK);
            H_IfFailRet(piInterface->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&punkObject)));
            H_IfFailGo(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            H_IfFailGo(piObjectModel->GetCookie(&Cookie));
            hr = m_piObjectModelHost->Delete(Cookie, punkObject);

        Error:
            QUICK_RELEASE(punkObject);
            QUICK_RELEASE(piObjectModel);
            H_RRETURN(hr);
        }

        // Helper methods for objects with ImageList properties
        HRESULT GetImages(IMMCImageList **ppiMMCImageListOut,
                          BSTR            bstrImagesKey,
                          IMMCImageList **ppiMMCImageListProperty);
        HRESULT SetImages(IMMCImageList  *pMMCImageListIn,
                          BSTR           *pbstrImagesKey,
                          IMMCImageList **ppiMMCImageListProperty);

        // These methods retrieve master collections held by SnapInDesignerDef

    public:
        HRESULT GetToolbars(IMMCToolbars **ppiMMCToolbars);
        HRESULT GetImageLists(IMMCImageLists **ppiMMCImageLists);
        HRESULT GetImageList(BSTR bstrKey, IMMCImageList **ppiMMCImageList);
        HRESULT GetSnapInViewDefs(IViewDefs **ppiViewDefs);
        HRESULT GetViewDefs(IViewDefs **ppiViewDefs);
        HRESULT GetListViewDefs(IListViewDefs **ppiListViewDefs);
        HRESULT GetOCXViewDefs(IOCXViewDefs **ppiOCXViewDefs);
        HRESULT GetURLViewDefs(IURLViewDefs **ppiURLViewDefs);
        HRESULT GetTaskpadViewDefs(ITaskpadViewDefs **ppiTaskpadViewDefs);
        HRESULT GetProjectName(BSTR *pbstrProjectName);

        // This method returns the runtime/designtime indicator from the
        // object model host

        HRESULT GetAtRuntime(BOOL *pfRuntime);

        // This method returns the DISPID set by IObjectModel::SetDISPID()

        DISPID GetDispid() { return m_DISPID; }

        // This method persists the DISPID

    protected:
        HRESULT PersistDISPID();

        // This method is used in collection persistence to determine
        // whether to serialize the whole object or just the key

        BOOL KeysOnly() { return m_fKeysOnly; }

        // This method allows an object to set its on KeysOnly
        
        void SetKeysOnly(BOOL fKeysOnly) { m_fKeysOnly = fKeysOnly; }

        // Override this method to set KeysOnly on contained objects. It is
        // called when an object as asked to serialize keys only. Call
        // UseKeysOnly() to pass on the request to contained objects.

        virtual HRESULT OnKeysOnly() { return S_OK; }

        // Use this method to tell a contained collection to serialize keys only

        template <class ICollectionObject>
        HRESULT UseKeysOnly(ICollectionObject *piCollectionObject)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFailGo(piCollectionObject->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel)));
            hr = piObjectModel->SerializeKeysOnly(TRUE);

        Error:
            QUICK_RELEASE(piObjectModel);
            H_RRETURN(hr);
        }

    // ISpecifyPropertyPages
        STDMETHOD(GetPages(CAUUID *pPropertyPages));

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        // IObjectModel
        STDMETHOD(SetHost)(IObjectModelHost *piObjectModelHost);
        STDMETHOD(SetCookie)(long Cookie);
        STDMETHOD(GetCookie)(long *pCookie);
        STDMETHOD(IncrementUsageCount)();
        STDMETHOD(DecrementUsageCount)();
        STDMETHOD(GetUsageCount)(long *plCount);
        STDMETHOD(SetDISPID)(DISPID dispid);
        STDMETHOD(GetDISPID)(DISPID *pdispid);
        STDMETHOD(SerializeKeysOnly)(BOOL fKeysOnly);
        STDMETHOD_(void *, GetThisPointer)();
        STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
        
        long              m_Cookie;                 // IObjectModel cookie
        BOOL              m_fKeysOnly;              // TRUE=collection is keys-only
        IObjectModelHost *m_piObjectModelHost;      // ptr to object model host
        const GUID      **m_rgpPropertyPageCLSIDs;  // CLSID for ISpecifyPropertyPage
        ULONG             m_cPropertyPages;         // # of property pages
        DISPID            m_DISPID;                 // DISPID of object
        void             *m_pThis;                  // outermost class' this pointer

        long              m_lUsageCount; // Determines how many collections
                                         // the object belongs to. For
                                         // objects not in a collection may
                                         // be used for any reference counting
                                         // purpose that is separate from the
                                         // object's COM ref count.
                

        // Persistence stuff - needed to set dirty flag after property set
        CPersistence *m_pPersistence;
        void SetDirty();

        // Initialization
        void InitMemberVariables();

};

#endif // _SIAUTOBJ_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\siautobj.cpp ===
//=--------------------------------------------------------------------------=
// siautobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInAutomationObject class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobj.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInAutomationObject::CSnapInAutomationObject
(
    IUnknown      *punkOuter,
    int            nObjectType,
    void          *piMainInterface,
    void          *pThis,
    ULONG          cPropertyPages,
    const GUID   **rgpPropertyPageCLSIDs,
    CPersistence  *pPersistence
) : CAutomationObjectWEvents(punkOuter,
                             nObjectType,
                             piMainInterface),
    CError(static_cast<CAutomationObject *>(this))
{
    InitMemberVariables();
    m_pPersistence = pPersistence;
    m_cPropertyPages = cPropertyPages;
    m_rgpPropertyPageCLSIDs = rgpPropertyPageCLSIDs;
    m_pThis = pThis;
}

#pragma warning(default:4355)  // using 'this' in constructor


void CSnapInAutomationObject::InitMemberVariables()
{
    m_Cookie = 0;
    m_DISPID = 0;
    m_fKeysOnly = FALSE;
    m_piObjectModelHost = NULL;
    m_pPersistence = NULL;
    m_cPropertyPages = 0;
    m_rgpPropertyPageCLSIDs = NULL;
    m_lUsageCount = 0;
}

CSnapInAutomationObject::~CSnapInAutomationObject()
{
    RELEASE(m_piObjectModelHost);
    InitMemberVariables();
}

HRESULT CSnapInAutomationObject::SetBstr
(
    BSTR    bstrNew,
    BSTR   *pbstrProperty,
    DISPID  dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrNewCopy = NULL;
    BSTR    bstrOld = *pbstrProperty;

    // Copy the BSTR

    if (NULL != bstrNew)
    {
        bstrNewCopy = ::SysAllocString(bstrNew);
        IfFalseGo(NULL != bstrNewCopy, SID_E_OUTOFMEMORY);
    }

    // Set the property

    *pbstrProperty = bstrNewCopy;

    // Inform any interested parties of the change.
    
    IfFailGo(PropertyChanged(dispid));

    // Change was accepted. Free the old value.
    
    FREESTRING(bstrOld);

Error:
    if (FAILED(hr))
    {
        // Revert to original property value
        *pbstrProperty = bstrOld;

        // Free the copy if we made of the new value
        FREESTRING(bstrNewCopy);

        // If we generated the error then generate the exception info for it
        if (SID_E_OUTOFMEMORY == hr)
        {
            EXCEPTION_CHECK(hr);
        }
    }
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetBstr
(
    BSTR *pbstrOut,
    BSTR bstrProperty
)
{
    IfFalseRet(NULL != pbstrOut, SID_E_INVALIDARG);

    if (NULL != bstrProperty)
    {
        *pbstrOut = ::SysAllocString(bstrProperty);
        IfFalseRet(NULL != *pbstrOut, SID_E_OUTOFMEMORY);
    }
    else
    {
        *pbstrOut = NULL;
    }

    return S_OK;
}


HRESULT CSnapInAutomationObject::SetVariant
(
    VARIANT  varNew,
    VARIANT *pvarProperty,
    DISPID   dispid
)
{
    HRESULT hr = S_OK;

    VARIANT varNewCopy;
    ::VariantInit(&varNewCopy);

    VARIANT varOld;
    ::VariantInit(&varOld);

    // Make a copy of the old property value. We will need this in order to
    // revert in the case where the change was refused by the object model host.

    varOld = *pvarProperty;

    // Check if the variant type is supported. We accept all of these types
    // and arrays of these types.
    // NTBUGS 354572 Allow arrays as well as simple type

    switch (varNew.vt & (~VT_ARRAY))
    {
        case VT_I4:
        case VT_UI1:
        case VT_I2:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
        case VT_EMPTY:
            break;

        default:
            hr = SID_E_UNSUPPORTED_TYPE;
            EXCEPTION_CHECK_GO(hr);
    }

    // Make a local copy of the new VARIANT first. We need to do this
    // because VariantCopy() first calls VariantClear() on the destination
    // and then attempts to copy the source. If the source cannot be copied
    // we do not want to free the destination.
    
    hr = ::VariantCopy(&varNewCopy, &varNew);
    EXCEPTION_CHECK_GO(hr);

    // Copy in the new value

    *pvarProperty = varNewCopy;

    // Inform the object model host and VB of the change.

    IfFailGo(PropertyChanged(dispid));

    // Property change was accepted. Free the old value. We don't error check
    // this call because if it fails then there is no way to roll back at this
    // point as the host/VB have already accepted the change. Also, a failure
    // would at most cause a leak.

    (void)::VariantClear(&varOld);

Error:
    if (FAILED(hr))
    {
        // Revert to the old property value
        *pvarProperty = varOld;

        // Free the copy of the new value if we made it.
        (void)::VariantClear(&varNewCopy);
    }
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetVariant
(
    VARIANT *pvarOut,
    VARIANT  varProperty
)
{
    // Call VariantInit() on the destination in case it is not initialized
    // because VariantCopy() will first call VariantClear() which requires
    // an initialized VARIANT.

    ::VariantInit(pvarOut);
    return ::VariantCopy(pvarOut, &varProperty);
}


HRESULT CSnapInAutomationObject::UIUpdate(DISPID dispid)
{
    if (NULL != m_piObjectModelHost)
    {
        RRETURN(m_piObjectModelHost->Update(m_Cookie, PrivateUnknown(), dispid));
    }
    else
    {
        return S_OK;
    }
}

HRESULT CSnapInAutomationObject::PropertyChanged(DISPID dispid)
{
    HRESULT hr = S_OK;

    // First ask the object model host if the change can be made. In practice
    // this should only be the designer checking that a name is unique for
    // objects that have typeinfo.
    
    IfFailGo(UIUpdate(dispid));

    // Mark the object dirty
    
    SetDirty();

    // Inform the IPropertyNotifySink guys. In practice that should be only in
    // the designer when the VB property browser monitors updates. It is also
    // used by CMMCListViewDef at design time to catch property updates to
    // its contained MMCListView object.
    
    m_cpPropNotify.DoOnChanged(dispid);

Error:
    RRETURN(hr);
}


STDMETHODIMP CSnapInAutomationObject::SetHost
(
    IObjectModelHost *piObjectModelHost
)
{
    RELEASE(m_piObjectModelHost);
    if (NULL != piObjectModelHost)
    {
        piObjectModelHost->AddRef();
        m_piObjectModelHost = piObjectModelHost;
    }
    RRETURN(OnSetHost());
}


STDMETHODIMP CSnapInAutomationObject::SetCookie(long Cookie)
{
    m_Cookie = Cookie;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::GetCookie(long *pCookie)
{
    *pCookie = m_Cookie;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::IncrementUsageCount()
{
    m_lUsageCount++;
    return S_OK;
}

STDMETHODIMP CSnapInAutomationObject::DecrementUsageCount()
{
    HRESULT hr = S_OK;

    if (m_lUsageCount > 0)
    {
        m_lUsageCount--;
    }
    else
    {
        ASSERT(FALSE, "Object usage count decremented past zero");
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    return hr;
}

STDMETHODIMP CSnapInAutomationObject::GetUsageCount(long *plCount)
{
    if (NULL != plCount)
    {
        *plCount = m_lUsageCount;
    }
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::SetDISPID(DISPID dispid)
{
    m_DISPID = dispid;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::GetDISPID(DISPID *pdispid)
{
    *pdispid = m_DISPID;
    return S_OK;
}

HRESULT CSnapInAutomationObject::PersistDISPID()
{
    HRESULT hr = S_OK;

    if (NULL == m_pPersistence)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_pPersistence->PersistSimpleType(&m_DISPID, (DISPID)0, OLESTR("DISPID")));

Error:
    RRETURN(hr);
}


STDMETHODIMP CSnapInAutomationObject::SerializeKeysOnly(BOOL fKeysOnly)
{
    m_fKeysOnly = fKeysOnly;
    if (m_fKeysOnly)
    {
        RRETURN(OnKeysOnly());
    }
    else
    {
        return S_OK;
    }
}


STDMETHODIMP_(void *) CSnapInAutomationObject::GetThisPointer()
{
    return m_pThis;
}

STDMETHODIMP CSnapInAutomationObject::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piObjectModelHost->GetSnapInDesignerDef(ppiSnapInDesignerDef);

Error:
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::OnSetHost()
{
    return S_OK;
}


void CSnapInAutomationObject::SetDirty()
{
    if (NULL != m_pPersistence)
    {
        m_pPersistence->SetDirty();
    }
}


HRESULT CSnapInAutomationObject::GetImages
(
    IMMCImageList **ppiMMCImageListOut,
    BSTR            bstrImagesKey,
    IMMCImageList **ppiMMCImageListProperty
)
{
    HRESULT hr = S_OK;

    // If there is no key then the image list has never been set

    if (NULL == bstrImagesKey)
    {
        *ppiMMCImageListOut = NULL;
        return S_OK;
    }
    else if (L'\0' == bstrImagesKey[0])
    {
        *ppiMMCImageListOut = NULL;
        return S_OK;
    }

    // If we have a key but no image list then we are after a load and haven't
    // yet retrieved the image list from the master ImageLists collection.

    if (NULL == *ppiMMCImageListProperty)
    {
        IfFailRet(GetImageList(bstrImagesKey, ppiMMCImageListProperty));
    }

    RRETURN(GetObject(ppiMMCImageListOut, *ppiMMCImageListProperty));
}

HRESULT CSnapInAutomationObject::SetImages
(
    IMMCImageList  *piMMCImageListIn,
    BSTR           *pbstrImagesKey,
    IMMCImageList **ppiMMCImageListProperty
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrNewImagesKey = NULL;
    IMMCImageList  *piMMCImageListFromMaster = NULL;

    // If setting to nothing then release our key and image list.
    if (NULL == piMMCImageListIn)
    {
        if (NULL != *ppiMMCImageListProperty)
        {
            (*ppiMMCImageListProperty)->Release();
            *ppiMMCImageListProperty = NULL;
        }
        if (NULL != *pbstrImagesKey)
        {
            ::SysFreeString(*pbstrImagesKey);
            *pbstrImagesKey = NULL;
        }
        return S_OK;
    }

    // First get the key of the new list

    IfFailGo(piMMCImageListIn->get_Key(&bstrNewImagesKey));

    // Check if the new image list is already in the master collection. If not
    // then return an error.

    // UNDONE: this would preclude a runtime setting of an image list property
    // Maybe if not in master then add it to master

    hr = GetImageList(bstrNewImagesKey, &piMMCImageListFromMaster);
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFailGo(hr);
    }

    // Set our image list property and key

    if (NULL != *pbstrImagesKey)
    {
        ::SysFreeString(*pbstrImagesKey);
    }
    *pbstrImagesKey = bstrNewImagesKey;

    if (NULL != *ppiMMCImageListProperty)
    {
        (*ppiMMCImageListProperty)->Release();
    }
    piMMCImageListIn->AddRef();
    *ppiMMCImageListProperty = piMMCImageListIn;


Error:
    if (FAILED(hr))
    {
        FREESTRING(bstrNewImagesKey);
    }
    QUICK_RELEASE(piMMCImageListFromMaster);
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetToolbars
(
    IMMCToolbars **ppiMMCToolbars
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_Toolbars(ppiMMCToolbars));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}




HRESULT CSnapInAutomationObject::GetImageLists
(
    IMMCImageLists **ppiMMCImageLists
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ImageLists(ppiMMCImageLists));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetImageList
(
    BSTR            bstrKey,
    IMMCImageList **ppiMMCImageList
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    IMMCImageLists     *piMMCImageLists = NULL;
    VARIANT             varIndex;

    ::VariantInit(&varIndex);
    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = bstrKey;
    
    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));
    hr = piMMCImageLists->get_Item(varIndex, ppiMMCImageList);
    
Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piMMCImageLists);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetSnapInViewDefs
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    ISnapInDef         *piSnapInDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));
    IfFailGo(piSnapInDef->get_ViewDefs(ppiViewDefs));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetViewDefs
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ViewDefs(ppiViewDefs));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetListViewDefs
(
    IListViewDefs **ppiListViewDefs
)
{
    HRESULT             hr = S_OK;
    IViewDefs          *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(ppiListViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetOCXViewDefs
(
    IOCXViewDefs **ppiOCXViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_OCXViews(ppiOCXViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetURLViewDefs
(
    IURLViewDefs **ppiURLViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_URLViews(ppiURLViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetTaskpadViewDefs
(
    ITaskpadViewDefs **ppiTaskpadViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_TaskpadViews(ppiTaskpadViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetAtRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piObjectModelHost) || (NULL == pfRuntime) )
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetRuntime(pfRuntime));

Error:
    if (FAILED(hr))
    {
        *pfRuntime = FALSE;
    }
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetProjectName(BSTR *pbstrProjectName)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ProjectName(pbstrProjectName));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}




STDMETHODIMP CSnapInAutomationObject::GetPages(CAUUID *pPropertyPages)
{
    HRESULT  hr = S_OK;
    ULONG    i = 0;

    if (0 == m_cPropertyPages)
    {
        pPropertyPages->cElems = 0;
        pPropertyPages->pElems = NULL;
        goto Error;
    }

    pPropertyPages->pElems =
              (GUID *)::CoTaskMemAlloc(sizeof(GUID) * m_cPropertyPages);

    if (NULL == pPropertyPages->pElems)
    {
        pPropertyPages->cElems = 0;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pPropertyPages->cElems = m_cPropertyPages;

    for (i = 0; i < m_cPropertyPages; i++)
    {
        pPropertyPages->pElems[i] = *m_rgpPropertyPageCLSIDs[i];
    }
    

Error:
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetCxxObject
(
    IDataObject     *piDataObject,
    CMMCDataObject **ppMMCDataObject
)
{
    HRESULT         hr = S_OK;
    IMMCDataObject *piMMCDataObject = NULL;

    *ppMMCDataObject = NULL;

    IfFailGo(piDataObject->QueryInterface (IID_IMMCDataObject,
                                  reinterpret_cast<void **>(&piMMCDataObject)));

    IfFailGo(GetCxxObject(piMMCDataObject, ppMMCDataObject));

Error:
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetCxxObject
(
    IMMCDataObject  *piMMCDataObject,
    CMMCDataObject **ppMMCDataObject
)
{
    *ppMMCDataObject = static_cast<CMMCDataObject *>(piMMCDataObject);
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInAutomationObject::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IObjectModel == riid)
    {
        *ppvObjOut = static_cast<IObjectModel *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISupportErrorInfo == riid)
    {
        *ppvObjOut = static_cast<ISupportErrorInfo *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( (IID_ISpecifyPropertyPages == riid) && (0 != m_cPropertyPages) )
    {
        *ppvObjOut = static_cast<ISpecifyPropertyPages *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CAutomationObjectWEvents::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopnode.cpp ===
//=--------------------------------------------------------------------------=
// scopnode.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeNode class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "views.h"
#include "scopnode.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopeNode::CScopeNode(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPENODE,
                           static_cast<IScopeNode *>(this),
                           static_cast<CScopeNode *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeNode,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeNode::~CScopeNode()
{
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    
    InitMemberVariables();
}

void CScopeNode::InitMemberVariables()
{
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_hsi = NULL;
    m_pSnapIn = NULL;
    m_pScopeItem = NULL;
    m_fHaveHsi = FALSE;
    m_fMarkedForRemoval = FALSE;
}

IUnknown *CScopeNode::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopeNode = NULL;

    CScopeNode *pScopeNode = New CScopeNode(punkOuter);

    IfFalseGo(NULL != pScopeNode, SID_E_OUTOFMEMORY);
    punkScopeNode = pScopeNode->PrivateUnknown();

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(punkScopeNode);
    }
    return punkScopeNode;
}

HRESULT CScopeNode::GetScopeNode
(
    HSCOPEITEM   hsi,
    IDataObject *piDataObject,
    CSnapIn     *pSnapIn,
    IScopeNode **ppiScopeNode
)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkScopeNode = NULL;
    CScopeNode  *pScopeNode = NULL;
    CScopeItems *pScopeItems = pSnapIn->GetScopeItems();
    long         cScopeItems = pScopeItems->GetCount();
    long         i = 0;
    IScopeItem  *piScopeItem = NULL; // not AddRef()ed
    CScopeItem  *pScopeItem = NULL;

    // Need to determine whether the HSCOPEITEM belongs to us or not.
    // Iterate through the ScopeItems collection and check the hsi
    // against each scope item's HSI.

    for (i = 0; i < cScopeItems; i++)
    {
        piScopeItem = pScopeItems->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
        if (hsi == pScopeItem->GetScopeNode()->GetHSCOPEITEM())
        {
            // Matched. AddRef the scope node and return it.
            *ppiScopeNode = static_cast<IScopeNode *>(pScopeItem->GetScopeNode());
            (*ppiScopeNode)->AddRef();
            goto Cleanup;
        }
    }

    // The scope item is foreign. Create a ScopeNode for it.

    punkScopeNode = CScopeNode::Create(NULL);
    if (NULL == punkScopeNode)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeNode, &pScopeNode));

    // Set the scope node's properties

    pScopeNode->SetHSCOPEITEM(hsi);
    pScopeNode->SetSnapIn(pSnapIn);

    // Note that we do not set its ScopeItem pointer because we don't own it.
    // If the user gets ScopeNode.Owned it will come back False because there
    // is no ScopeItem pointer.

    // Unfortunately, an IDataObject is needed to get the display name and
    // node type GUID. If we don't have one these properties will remain
    // NULL.

    if (NULL != piDataObject)
    {
        hr = ::GetStringData(piDataObject, CMMCDataObject::GetcfDisplayName(),
                             &pScopeNode->m_bstrDisplayName);
        if (DV_E_FORMATETC == hr)
        {
            hr = S_OK; // if the format was not available it is not an error
        }
        IfFailGo(hr);

        hr = ::GetStringData(piDataObject, CMMCDataObject::GetcfSzNodeType(),
                             &pScopeNode->m_bstrNodeTypeGUID);
        if (DV_E_FORMATETC == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

    *ppiScopeNode = static_cast<IScopeNode *>(pScopeNode);
    (*ppiScopeNode)->AddRef();

Cleanup:
Error:
    QUICK_RELEASE(punkScopeNode);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                          IScopeNode Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeNode::get_Parent(ScopeNode **ppParent)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiParent = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppParent = NULL;

    // Get the parent from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetParentItem(m_hsi, &hsiParent, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the parent's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it.

    IfFailGo(GetScopeNode(hsiParent, NULL, m_pSnapIn,
                          reinterpret_cast<IScopeNode **>(ppParent)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_HasChildren(VARIANT_BOOL *pfvarHasChildren)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;

    *pfvarHasChildren = VARIANT_FALSE;

    IfFailGo(get_Child(reinterpret_cast<ScopeNode **>(&piScopeNode)));
    if (NULL != piScopeNode)
    {
        *pfvarHasChildren = VARIANT_TRUE;
    }

Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}

STDMETHODIMP CScopeNode::put_HasChildren(VARIANT_BOOL fvarHasChildren)
{
    HRESULT hr = S_OK;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    sdi.mask = SDI_CHILDREN;
    sdi.ID = m_hsi;

    if (VARIANT_TRUE == fvarHasChildren)
    {
        sdi.cChildren = 1;
    }
    else
    {
        sdi.cChildren = 0;
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}

STDMETHODIMP CScopeNode::get_Child(ScopeNode **ppChild)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiChild = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppChild = NULL;

    // Get the Child from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetChildItem(m_hsi, &hsiChild, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the child item's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it. If there is no child item then MMC returns a
    // NULL HSCOPEITEM

    if (NULL != hsiChild)
    {
        IfFailGo(GetScopeNode(hsiChild, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppChild)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_FirstSibling(ScopeNode **ppFirstSibling)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiFirstSibling = NULL;
    HSCOPEITEM  hsiParent = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppFirstSibling = NULL;

    // MMC does not supply the first sibling so we need to get the parent
    // of this node and then get its child

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetParentItem(m_hsi, &hsiParent, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Parent could be NULL if the user crawled all the way up to the console
    // root. In that case we just return NULL as there is no first sibling.

    IfFalseGo(NULL != hsiParent, S_OK);

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetChildItem(hsiParent, &hsiFirstSibling, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // If this scope node is the first sibling then just return it

    if (m_hsi == hsiFirstSibling)
    {
        AddRef();
        *ppFirstSibling = reinterpret_cast<ScopeNode *>(static_cast<IScopeNode *>(this));
    }

    // Now we have the first sibling item's HSCOPEITEM and cookie but we need to
    // get a ScopeNode object for it. MMC should not have returned NULL but
    // we'll double check anyway.

    else if (NULL != hsiFirstSibling)
    {
        IfFailGo(GetScopeNode(hsiFirstSibling, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppFirstSibling)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_Next(ScopeNode **ppNext)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiNext = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppNext = NULL;

    // Get the next item from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(m_hsi, &hsiNext, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the next item's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it. If there is no next item then MMC returns a
    // NULL HSCOPEITEM

    if (NULL != hsiNext)
    {
        IfFailGo(GetScopeNode(hsiNext, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppNext)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_LastSibling(ScopeNode **ppLastSibling)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiNextSibling = NULL;
    HSCOPEITEM  hsiLastSibling = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppLastSibling = NULL;

    // MMC does not supply the last sibling so we need to do GetNext until
    // we hit the last one.

    hsiLastSibling = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(m_hsi, &hsiNextSibling, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    while (NULL != hsiNextSibling)
    {
        hsiLastSibling = hsiNextSibling;

        hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(hsiLastSibling,
                                                             &hsiNextSibling,
                                                             &lCookie);
        EXCEPTION_CHECK_GO(hr);

    }

    // If this scope node is the last sibling then just return it

    if (m_hsi == hsiLastSibling)
    {
        AddRef();
        *ppLastSibling = reinterpret_cast<ScopeNode *>(static_cast<IScopeNode *>(this));
    }

    // Now we have the last sibling's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it.

    else
    {
        IfFailGo(GetScopeNode(hsiLastSibling, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppLastSibling)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_ExpandedOnce(VARIANT_BOOL *pfvarExpandedOnce)
{
    HRESULT       hr = S_OK;
    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarExpandedOnce = VARIANT_FALSE;

    // If we don't yet have the HSI then the node hasn't been expanded yet

    IfFalseGo(m_fHaveHsi, S_OK);

    sdi.mask = SDI_STATE;
    sdi.ID = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    if ( (sdi.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) != 0 )
    {
        *pfvarExpandedOnce = VARIANT_TRUE;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_Owned(VARIANT_BOOL *pfvarOwned)
{
    if (NULL != m_pScopeItem)
    {
        *pfvarOwned = VARIANT_TRUE;
    }
    else
    {
        *pfvarOwned = VARIANT_FALSE;
    }

    return S_OK;
}


STDMETHODIMP CScopeNode::ExpandInNameSpace()
{
    HRESULT hr = S_OK;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->Expand(m_hsi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CScopeNode::get_DisplayName(BSTR *pbstrDisplayName)
{
    RRETURN(GetBstr(pbstrDisplayName, m_bstrDisplayName));
}


STDMETHODIMP CScopeNode::put_DisplayName(BSTR bstrDisplayName)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarOwned = VARIANT_FALSE;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // If it is not one of ours then return an error.

    if (NULL == m_pScopeItem)
    {
        hr = SID_E_CANT_CHANGE_UNOWNED_SCOPENODE;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the property

    IfFailGo(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                     DISPID_SCOPENODE_DISPLAY_NAME));

    // If this ScopeItem represents the static node then we also need to
    // change SnapIn.DisplayName as it also represents the display name
    // for the static node.
    
    if (m_pScopeItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->SetDisplayName(bstrDisplayName));
    }

    // Tell MMC we're changing the display name
    // (if we already have our HSCOPEITEM)

    IfFalseGo(m_fHaveHsi, S_OK);
    
    sdi.mask = SDI_STR;

    if (m_pScopeItem->IsStaticNode())
    {
        // MMC allows passing the string for the static node
        sdi.displayname = m_bstrDisplayName;
    }
    else
    {
        // MMC requires using MMC_CALLBACK for dynamic nodes
        sdi.displayname = MMC_CALLBACK;
    }
    sdi.ID = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeNode::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, L"", OLESTR("NodeTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    // NOTE: we do not serialize any navigational properties such as parent,
    // first sibling etc. as these are all extracted from MMC calls.

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeNode::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeNode == riid)
    {
        *ppvObjOut = static_cast<IScopeNode *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopnode.h ===
//=--------------------------------------------------------------------------=
// scopnode.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeNode class definition - implements ScopeNode object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPENODE_DEFINED_
#define _SCOPENODE_DEFINED_

#include "dataobj.h"
#include "snapin.h"
#include "scopitem.h"

class CSnapIn;
class CScopeItem;


class CScopeNode : public CSnapInAutomationObject,
                   public CPersistence,
                   public IScopeNode
{
    private:
        CScopeNode(IUnknown *punkOuter);
        ~CScopeNode();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeNode
        BSTR_PROPERTY_RW(CScopeNode, NodeTypeName, DISPID_SCOPENODE_NODE_TYPE_NAME);
        BSTR_PROPERTY_RW(CScopeNode, NodeTypeGUID, DISPID_SCOPENODE_NODE_TYPE_GUID);

        STDMETHOD(get_DisplayName)(BSTR *pbstrDisplayName);
        STDMETHOD(put_DisplayName)(BSTR bstrDisplayName);

        STDMETHOD(get_Parent)(ScopeNode **ppParent);

        STDMETHOD(get_HasChildren)(VARIANT_BOOL *pfvarHasChildren);
        STDMETHOD(put_HasChildren)(VARIANT_BOOL fvarHasChildren);

        STDMETHOD(get_Child)(ScopeNode **ppChild);
        STDMETHOD(get_FirstSibling)(ScopeNode **ppFirstSibling);
        STDMETHOD(get_Next)(ScopeNode **ppNext);
        STDMETHOD(get_LastSibling)(ScopeNode **ppLastSibling);
        STDMETHOD(get_ExpandedOnce)(VARIANT_BOOL *pfvarExpandedOnce);
        STDMETHOD(get_Owned)(VARIANT_BOOL *pfvarOwned);

        STDMETHOD(ExpandInNameSpace)();

    // Non-interface public utility methods

        void SetHSCOPEITEM(HSCOPEITEM hsi) { m_hsi = hsi; m_fHaveHsi = TRUE; }
        HSCOPEITEM GetHSCOPEITEM() { return m_hsi; }
        BOOL HaveHsi() { return m_fHaveHsi; }

        LPOLESTR GetDisplayNamePtr() { return static_cast<LPOLESTR>(m_bstrDisplayName); }

        BSTR GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }

        void SetScopeItem(CScopeItem *pScopeItem) { m_pScopeItem = pScopeItem; }
        CScopeItem *GetScopeItem() { return m_pScopeItem; }

        void MarkForRemoval() { m_fMarkedForRemoval = TRUE; }
        BOOL MarkedForRemoval() { return m_fMarkedForRemoval; }

        static HRESULT GetScopeNode(HSCOPEITEM   hsi,
                                    IDataObject *piDataObject,
                                    CSnapIn     *pSnapIn,
                                    IScopeNode **ppiScopeNode);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        HSCOPEITEM  m_hsi;               // HSCOPEITEM for node
        BOOL        m_fHaveHsi;          // TRUE=m_hsi contains HSCOPEITEM
        CSnapIn    *m_pSnapIn;           // back ptr to snap-in
        CScopeItem *m_pScopeItem;        // back ptr to ScopeItem
        BSTR        m_bstrDisplayName;   // ScopeNode.DisplayName
        BOOL        m_fMarkedForRemoval; // Used during MMCN_REMOVECHILDREN
                                         // to determine which nodes have to be
                                         // removed
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeNode,                 // name
                                &CLSID_ScopeNode,          // clsid
                                "ScopeNode",               // objname
                                "ScopeNode",               // lblname
                                CScopeNode::Create,        // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopeNode,           // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SCOPENODE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitms.cpp ===
//=--------------------------------------------------------------------------=
// scopitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scopitms.h"
#include "scopnode.h"
#include "scitdefs.h"
#include "scitdef.h"

// for ASSERT and FAIL
//
SZTHISFILE;

VARTYPE CScopeItems::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiInitialize =
{
    DISPID_SCOPEITEMS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CScopeItems::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiTerminate =
{
    DISPID_SCOPEITEMS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};



VARTYPE CScopeItems::m_rgvtExpand[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiExpand =
{
    DISPID_SCOPEITEMS_EVENT_EXPAND,
    sizeof(m_rgvtExpand) / sizeof(m_rgvtExpand[0]),
    m_rgvtExpand
};


VARTYPE CScopeItems::m_rgvtCollapse[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiCollapse =
{
    DISPID_SCOPEITEMS_EVENT_COLLAPSE,
    sizeof(m_rgvtCollapse) / sizeof(m_rgvtCollapse[0]),
    m_rgvtCollapse
};



VARTYPE CScopeItems::m_rgvtExpandSync[2] = { VT_UNKNOWN, VT_BYREF | VT_BOOL };

EVENTINFO CScopeItems::m_eiExpandSync =
{
    DISPID_SCOPEITEMS_EVENT_EXPAND_SYNC,
    sizeof(m_rgvtExpandSync) / sizeof(m_rgvtExpandSync[0]),
    m_rgvtExpandSync
};


VARTYPE CScopeItems::m_rgvtCollapseSync[2] = { VT_UNKNOWN, VT_BYREF | VT_BOOL };

EVENTINFO CScopeItems::m_eiCollapseSync =
{
    DISPID_SCOPEITEMS_EVENT_COLLAPSE_SYNC,
    sizeof(m_rgvtCollapseSync) / sizeof(m_rgvtCollapseSync[0]),
    m_rgvtCollapseSync
};



VARTYPE CScopeItems::m_rgvtGetDisplayInfo[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiGetDisplayInfo =
{
    DISPID_SCOPEITEMS_EVENT_GET_DISPLAY_INFO,
    sizeof(m_rgvtGetDisplayInfo) / sizeof(m_rgvtGetDisplayInfo[0]),
    m_rgvtGetDisplayInfo
};


VARTYPE CScopeItems::m_rgvtPropertyChanged[2] =
{
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CScopeItems::m_eiPropertyChanged =
{
    DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGED,
    sizeof(m_rgvtPropertyChanged) / sizeof(m_rgvtPropertyChanged[0]),
    m_rgvtPropertyChanged
};


VARTYPE CScopeItems::m_rgvtRename[2] =
{
    VT_UNKNOWN,
    VT_BSTR
};

EVENTINFO CScopeItems::m_eiRename =
{
    DISPID_SCOPEITEMS_EVENT_RENAME,
    sizeof(m_rgvtRename) / sizeof(m_rgvtRename[0]),
    m_rgvtRename
};


VARTYPE CScopeItems::m_rgvtHelp[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopeItems::m_eiHelp =
{
    DISPID_SCOPEITEMS_EVENT_HELP,
    sizeof(m_rgvtHelp) / sizeof(m_rgvtHelp[0]),
    m_rgvtHelp
};


VARTYPE CScopeItems::m_rgvtRemoveChildren[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopeItems::m_eiRemoveChildren =
{
    DISPID_SCOPEITEMS_EVENT_REMOVE_CHILDREN,
    sizeof(m_rgvtRemoveChildren) / sizeof(m_rgvtRemoveChildren[0]),
    m_rgvtRemoveChildren
};



#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItems::CScopeItems(IUnknown *punkOuter) :
   CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>(
                                              punkOuter,
                                              OBJECT_TYPE_SCOPEITEMS,
                                              static_cast<IScopeItems *>(this),
                                              static_cast<CScopeItems *>(this),
                                              CLSID_ScopeItem,
                                              OBJECT_TYPE_SCOPEITEM,
                                              IID_IScopeItem,
                                              NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CScopeItems::InitMemberVariables()
{
    m_pSnapIn = NULL;
}

CScopeItems::~CScopeItems()
{
    InitMemberVariables();
}

IUnknown *CScopeItems::Create(IUnknown * punkOuter)
{
    CScopeItems *pScopeItems = New CScopeItems(punkOuter);
    if (NULL == pScopeItems)
    {
        return NULL;
    }
    else
    {
        return pScopeItems->PrivateUnknown();
    }
}


HRESULT CScopeItems::CreateScopeItem
(
    BSTR         bstrName,
    IScopeItem **ppiScopeItem
)
{
    HRESULT     hr = S_OK;
    IScopeItem *piScopeItem = NULL;
    IUnknown   *punkScopeItem = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    punkScopeItem = CScopeItem::Create(NULL);
    if (NULL == punkScopeItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopeItem->QueryInterface(IID_IScopeItem,
                                           reinterpret_cast<void **>(&piScopeItem)));

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::AddExisting(
                                                                   varIndex,
                                                                   varKey,
                                                                   piScopeItem);
    IfFailGo(hr);
    IfFailGo(piScopeItem->put_Name(bstrName));

Error:
    if (SUCCEEDED(hr))
    {
        *ppiScopeItem = piScopeItem;
    }
    else
    {
        QUICK_RELEASE(piScopeItem);
        *ppiScopeItem = NULL;
    }

    QUICK_RELEASE(punkScopeItem);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveScopeItemByName(BSTR bstrName)
{
    HRESULT hr = S_OK;

    VARIANT varKey;
    ::VariantInit(&varKey);

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = RemoveScopeItemByKey(varKey);

    RRETURN(hr);
}

HRESULT CScopeItems::RemoveScopeItemByKey(VARIANT varKey)
{
    HRESULT          hr = S_OK;
    CViews          *pViews = m_pSnapIn->GetViews();
    CView           *pView = NULL;
    long             cViews = 0;
    long             i = 0;
    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    IScopePaneItem  *piScopePaneItem = NULL;
    IScopeItem      *piScopeItem = NULL;
    CScopeItem      *pScopeItem = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get the ScopeItem to make sure it exists

    IfFailGo(get_Item(varKey, &piScopeItem));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));

    cViews = pViews->GetCount();

    // Remove the ScopeItem from all Views' ScopePaneItem collections

    for (i = 0; i < cViews; i++)
    {
        // Get the next View
        
        IfFailGo(CSnapInAutomationObject::GetCxxObject(pViews->GetItemByIndex(i),
                                                       &pView));
        pScopePaneItems = pView->GetScopePaneItems();

        // Check if View.ScopePaneItems has a member for this ScopeItem
        
        hr = pScopePaneItems->GetItemByName(pScopeItem->GetNamePtr(),
                                            &piScopePaneItem);
        if (SUCCEEDED(hr))
        {
            // There is a member. Remove it from View.ScopePaneItems
            
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                           &pScopePaneItem));
            varIndex.vt = VT_I4;;
            varIndex.lVal = pScopePaneItem->GetIndex();
            IfFailGo(pScopePaneItems->Remove(varIndex));
            RELEASE(piScopePaneItem);
        }
        else
        {
            if (SID_E_ELEMENT_NOT_FOUND == hr)
            {
                hr = S_OK;
            }
            IfFailGo(hr);
        }
    }

    // Remove it from the ScopeItem collection

    hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::Remove(varKey);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}



HRESULT CScopeItems::AddStaticNode(CScopeItem **ppScopeItem)
{
    HRESULT        hr = S_OK;
    IScopeItem    *piScopeItem = NULL;
    CScopeItem    *pScopeItem = NULL;
    IScopeNode    *piScopeNode = NULL;
    CScopeNode    *pScopeNode = NULL;
    BSTR           bstrProp = NULL;

    VARIANT        varProp;
    ::VariantInit(&varProp);

    BSTR bstrName = ::SysAllocString(STATIC_NODE_KEY);

    // Create the scope item

    if (NULL == bstrName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CreateScopeItem(bstrName, &piScopeItem));

    // Set its properties from the snap-in definiton

    IfFailGo(m_pSnapIn->get_StaticFolder(&varProp));
    if (VT_EMPTY != varProp.vt)
    {
        IfFailGo(piScopeItem->put_Folder(varProp));
    }
    (void)::VariantClear(&varProp);

    // Set ScopeNode properties too

    IfFailGo(piScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

    IfFailGo(m_pSnapIn->get_NodeTypeName(&bstrProp));
    IfFailGo(piScopeNode->put_NodeTypeName(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(m_pSnapIn->get_NodeTypeGUID(&bstrProp));
    IfFailGo(piScopeNode->put_NodeTypeGUID(bstrProp));
    IfFailGo(piScopeItem->put_NodeID(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(m_pSnapIn->get_DisplayName(&bstrProp));
    IfFailGo(piScopeNode->put_DisplayName(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetStaticNode();
    pScopeItem->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeNode->SetSnapIn(m_pSnapIn);

    *ppScopeItem = pScopeItem;

    // Tell the snap-in that a scope item was born.

    FireInitialize(piScopeItem);

Error:

    // Note: the returned C++ pointer is not AddRef()ed. At this point
    // the collection has the only ref on the scope item.

    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
    }

    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piScopeNode);
    FREESTRING(bstrName);
    FREESTRING(bstrProp);
    (void)::VariantClear(&varProp);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveStaticNode(CScopeItem *pScopeItem)
{
    HRESULT     hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Fire ScopeItems_Terminate

    FireTerminate(pScopeItem);

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it
    pScopeItem->SetData(NULL);

    // Remove it from the collection

    varIndex.vt = VT_I4;
    varIndex.lVal = pScopeItem->GetIndex();

    IfFailGo(RemoveScopeItemByKey(varIndex));

Error:
    RRETURN(hr);
}


void CScopeItems::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}


void CScopeItems::FireInitialize(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Initialize(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiInitialize, piScopeItem);
}


void CScopeItems::FireTerminate(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Terminate(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiTerminate, piScopeItem);
}


void CScopeItems::FireExpand(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Expand(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiExpand, piScopeItem);
}


void CScopeItems::FireCollapse(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Collapse(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiCollapse, piScopeItem);
}


void CScopeItems::FireExpandSync(IScopeItem *piScopeItem, BOOL *pfHandled)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);
    
    DebugPrintf("Firing ScopeItems_ExpandSync(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiExpandSync, piScopeItem, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CScopeItems::FireCollapseSync(IScopeItem *piScopeItem, BOOL *pfHandled)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ScopeItems_CollapseSync(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiCollapseSync, piScopeItem, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CScopeItems::FireGetDisplayInfo(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_GetDisplayInfo(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiGetDisplayInfo, piScopeItem);
}


void CScopeItems::FirePropertyChanged
(
    IScopeItem *piScopeItem,
    VARIANT     Data
)
{
    DebugPrintf("Firing ScopeItems_PropertyChanged(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiPropertyChanged, piScopeItem, Data);
}


void CScopeItems::FireRename
(
    IScopeItem *piScopeItem,
    BSTR        bstrNewName
)
{
    DebugPrintf("Firing ScopeItems_Rename(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiRename, piScopeItem, bstrNewName);
}


void CScopeItems::FireHelp
(
    IScopeItem *piScopeItem
)
{
    DebugPrintf("Firing ScopeItems_Help(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiHelp, piScopeItem);
}



void CScopeItems::FireRemoveChildren
(
    IScopeNode *piScopeNode
)
{
    DebugPrintf("Firing ScopeItems_RemoveChildren\r\n");

    FireEvent(&m_eiRemoveChildren, piScopeNode);
}



HRESULT CScopeItems::InternalAddNew
(
    BSTR                              bstrName,
    BSTR                              bstrDisplayName,
    BSTR                              bstrNodeTypeName,
    BSTR                              bstrNodeTypeGUID,
    IScopeNode                       *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    BOOL                              fHasChildren,
    IScopeItem                      **ppiScopeItem
)
{
    HRESULT     hr = S_OK;
    CScopeItem *pScopeItem = NULL;
    IScopeItem *piScopeItem = NULL;
    IScopeNode *piScopeNode = NULL;
    CScopeNode *pScopeNode = NULL;
    CScopeNode *pScopeNodeRelative = NULL;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    hr = CreateScopeItem(bstrName, &piScopeItem);
    IfFailGo(hr);

    // Set default values for properties

    IfFailGo(piScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

    IfFailGo(piScopeNode->put_NodeTypeName(bstrNodeTypeName));
    IfFailGo(piScopeNode->put_NodeTypeGUID(bstrNodeTypeGUID));
    IfFailGo(piScopeNode->put_DisplayName(bstrDisplayName));

    // The Node ID defaults to the node type GUID
    
    IfFailGo(piScopeItem->put_NodeID(bstrNodeTypeGUID));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeNode->SetSnapIn(m_pSnapIn);

    // Now add the scope item to the scope pane

    IfFailGo(CSnapInAutomationObject::GetCxxObject(ScopeNodeRelative, &pScopeNodeRelative));

    
    sdi.mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;

    switch (RelativeRelationship)
    {
        case siParent:
            sdi.mask |= SDI_PARENT;
            break;

        case siPrevious:
            sdi.mask |= SDI_PREVIOUS;
            break;

        case siNext:
            sdi.mask |= SDI_NEXT;
            break;

        case siFirst:
            sdi.mask |= SDI_FIRST;
            break;
    }

    sdi.displayname = MMC_CALLBACK;
    sdi.lParam = reinterpret_cast<LPARAM>(pScopeItem);
    sdi.relativeID = pScopeNodeRelative->GetHSCOPEITEM();
    sdi.cChildren = fHasChildren ? 1 : 0;

    // scope pane holds a ref - it will be released when the scope item is removed
    pScopeItem->AddRef();


    // Check whether we already have IConsoleNameSpace2 from MMC. This could
    // happen if the snap-in calls ScopeItems.Add/Predefined during
    // ScopeItems_Initialize for the static node. That event is fired when
    // the snap-in first gets IComponentData::QueryDataObject() for the zero
    // cookie which is before IComponentData::Initialize. (See
    // CSnapIn::QueryDataObject() in snapin.cpp).
    
    if (NULL == m_pSnapIn->GetIConsoleNameSpace2())
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->InsertItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    // Store the HSCOPEITEM returned from MMC

    pScopeNode->SetHSCOPEITEM(sdi.ID);

    *ppiScopeItem = piScopeItem;

Error:
    QUICK_RELEASE(piScopeNode);
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
        piScopeItem->Release();
    }
    RRETURN(hr);
}


HRESULT CScopeItems::InternalAddPredefined
(
    BSTR                              bstrName,
    IScopeItemDef                    *piScopeItemDef,
    IScopeNode                       *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    IScopeItem                      **ppiScopeItem
)
{
    HRESULT            hr = S_OK;
    IScopeItem        *piScopeItem = NULL;
    CScopeItem        *pScopeItem = NULL;
    BSTR               bstrNodeTypeName = NULL;
    BSTR               bstrDisplayName = NULL;
    BSTR               bstrNodeTypeGUID = NULL;
    BSTR               bstrDefaultDataFormat = NULL;
    VARIANT_BOOL       fvarHasChildren = VARIANT_FALSE;
    IMMCColumnHeaders *piDefColHdrs = NULL;
    IMMCColumnHeaders *piItemColHdrs = NULL;

    VARIANT         varProp;
    ::VariantInit(&varProp);

    // Get relevant properties and add the scope item.
    // If name is unspecified then use node type name as name

    IfFailGo(piScopeItemDef->get_NodeTypeName(&bstrNodeTypeName));
    if (NULL == bstrName)
    {
        bstrName = bstrNodeTypeName;
    }
    IfFailGo(piScopeItemDef->get_NodeTypeGUID(&bstrNodeTypeGUID));
    IfFailGo(piScopeItemDef->get_DisplayName(&bstrDisplayName));

    // If the caller passed the option HasChildren parameter then use it
    // otherwise use the design time setting.

    if (ISPRESENT(HasChildren))
    {
        if (VT_BOOL == HasChildren.vt)
        {
            fvarHasChildren = HasChildren.boolVal;
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        IfFailGo(piScopeItemDef->get_HasChildren(&fvarHasChildren));
    }

    IfFailGo(InternalAddNew(bstrName,
                            bstrDisplayName,
                            bstrNodeTypeName,
                            bstrNodeTypeGUID,
                            ScopeNodeRelative,
                            RelativeRelationship,
                            VARIANTBOOL_TO_BOOL(fvarHasChildren),
                            &piScopeItem));

    // Set remaining properties from definition

    IfFailGo(piScopeItemDef->get_Folder(&varProp));
    IfFailGo(piScopeItem->put_Folder(varProp));
    (void)::VariantClear(&varProp);

    IfFailGo(piScopeItemDef->get_Tag(&varProp));
    IfFailGo(piScopeItem->put_Tag(varProp));
    (void)::VariantClear(&varProp);

#if defined(USING_SNAPINDATA)

    IfFailGo(piScopeItemDef->get_DefaultDataFormat(&bstrDefaultDataFormat));
    IfFailGo(piScopeItem->put_DefaultDataFormat(bstrDefaultDataFormat));

#endif

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetScopeItemDef(piScopeItemDef);

    // For column headers the easiest way is to use serialization. We save
    // the headers from the definition into a stream and then load the new
    // scope item's headers from that stream

    IfFailGo(piScopeItemDef->get_ColumnHeaders(&piDefColHdrs));
    IfFailGo(piScopeItem->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piItemColHdrs)));
    IfFailGo(::CloneObject(piDefColHdrs, piItemColHdrs));

    FireInitialize(piScopeItem);

    *ppiScopeItem = piScopeItem;

Error:
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
        piScopeItem->Release();
    }
    QUICK_RELEASE(piDefColHdrs);
    QUICK_RELEASE(piItemColHdrs);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrNodeTypeGUID);
    FREESTRING(bstrDefaultDataFormat);
    (void)::VariantClear(&varProp);
    RRETURN(hr);
}


HRESULT CScopeItems::AddAutoCreateChildren
(
    IScopeItemDefs *piScopeItemDefs,
    IScopeItem     *piParentScopeItem
)
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piChildScopeItemDef = NULL;
    IScopeNode     *piParentScopeNode = NULL;
    IScopeItem     *piChildScopeItem = NULL;
    IScopeItem     *piExistingChild = NULL;
    long            cChildren = 0;
    VARIANT_BOOL    fvarAutoCreate = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrNodeTypeName = NULL;
    BSTR            bstrParentName = NULL;
    size_t          cchNodeTypeName = 0;;
    size_t          cchParentName = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varHasChildren;
    UNSPECIFIED_PARAM(varHasChildren);

    IfFailGo(piScopeItemDefs->get_Count(&cChildren));
    IfFalseGo(cChildren != 0, S_OK);
    IfFailGo(piParentScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piParentScopeNode)));

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cChildren)
    {
        IfFailGo(piScopeItemDefs->get_Item(varIndex, &piChildScopeItemDef));
        IfFailGo(piChildScopeItemDef->get_AutoCreate(&fvarAutoCreate));

        if (VARIANT_TRUE == fvarAutoCreate)
        {
            // NTBUGS 350731
            // Check if there already is a node using the node type name. If
            // so then the snap-in has called ScopeItems.AddPredefined more
            // than once for the same node type. In that case we prefix the
            // node type name with the parent's ScopeItem.Name

            IfFailGo(piChildScopeItemDef->get_NodeTypeName(&bstrNodeTypeName));

            varKey.vt = VT_BSTR;
            varKey.bstrVal = bstrNodeTypeName;
            hr = get_Item(varKey, &piExistingChild);

            if (FAILED(hr))
            {
                if (SID_E_ELEMENT_NOT_FOUND == hr)
                {
                    // This is the first call for this node type. Use the
                    // node type name for ScopeItem.Name

                    hr = S_OK;
                    bstrName = bstrNodeTypeName;
                    bstrNodeTypeName = NULL; // Set NULL so we don't free it
                }
                IfFailGo(hr);
            }
            else
            {
                // Child does exist. Create the child's name by concatenating
                // <Parent Name>.<Child Node Type Name>

                IfFailGo(piParentScopeItem->get_Name(&bstrParentName));

                cchNodeTypeName = ::wcslen(bstrNodeTypeName);
                cchParentName = ::wcslen(bstrParentName);

                bstrName = ::SysAllocStringLen(NULL,
                                               cchNodeTypeName +
                                               1 + // for .
                                               cchParentName +
                                               1); // for terminating null char
                if (NULL == bstrName)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                ::memcpy(bstrName, bstrParentName,
                         cchParentName * sizeof(WCHAR));
                
                bstrName[cchParentName] = L'.';

                ::memcpy(&bstrName[cchParentName + 1],
                         bstrNodeTypeName, (cchNodeTypeName + 1) * sizeof(WCHAR));
            }
            
            IfFailGo(InternalAddPredefined(bstrName,
                                           piChildScopeItemDef,
                                           piParentScopeNode,
                                           siParent,
                                           varHasChildren,
                                           &piChildScopeItem));
            RELEASE(piChildScopeItem);
        }

        FREESTRING(bstrName);
        FREESTRING(bstrNodeTypeName);
        RELEASE(piExistingChild);
        RELEASE(piChildScopeItemDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piChildScopeItemDef);
    QUICK_RELEASE(piParentScopeNode);
    QUICK_RELEASE(piChildScopeItem);
    QUICK_RELEASE(piExistingChild);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrParentName);
    FREESTRING(bstrName);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveChildrenOfNode(IScopeNode *piScopeNode)
{
    HRESULT     hr = S_OK;
    IScopeNode *piChild1 = NULL;
    IScopeNode *piChild2 = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get each child of the specified node and remove it. RemoveByNode() will
    // recursively call back in here to remove the child's children.

    IfFailGo(piScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piChild1)));

    while (NULL != piChild1)
    {
        IfFailGo(piChild1->get_Next(reinterpret_cast<ScopeNode **>(&piChild2)));
        IfFailGo(RemoveByNode(piChild1, TRUE));
        RELEASE(piChild1);
        if (NULL != piChild2)
        {
            IfFailGo(piChild2->get_Next(reinterpret_cast<ScopeNode **>(&piChild1)));
            IfFailGo(RemoveByNode(piChild2, TRUE));
            RELEASE(piChild2);
        }
    }

Error:
    QUICK_RELEASE(piChild1);
    QUICK_RELEASE(piChild2);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveByNode(IScopeNode *piScopeNode, BOOL fRemoveChildren)
{
    HRESULT       hr = S_OK;
    VARIANT_BOOL  fvarOwned = VARIANT_FALSE;
    CScopeNode   *pScopeNode = NULL;
    CScopeItem   *pScopeItem = NULL;
    IScopeNode   *piChild1 = NULL;
    IScopeNode   *piChild2 = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // If the node is not ours then don't do anything

    IfFailGo(piScopeNode->get_Owned(&fvarOwned));

    IfFalseGo(VARIANT_TRUE == fvarOwned, S_OK);

    // Remove the node's children if requested

    if (fRemoveChildren)
    {
        IfFailGo(RemoveChildrenOfNode(piScopeNode));
    }
    
    // Fire ScopeItems_Terminate

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeItem = pScopeNode->GetScopeItem();

    FireTerminate(pScopeItem);

    // Remove it from the collection. This will remove the collection's ref on
    // the scope item.

    varIndex.vt = VT_I4;
    varIndex.lVal = pScopeItem->GetIndex();
    IfFailGo(RemoveScopeItemByKey(varIndex));

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it

    pScopeItem->SetData(NULL);

    // Remove the ref we held for presence in MMC. The scope item should die
    // with this release but its ScopeNode is still alive because the caller
    // of this function has a ref on it.

    pScopeItem->Release(); 

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          IScopeItems Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItems::get_Item(VARIANT Index, IScopeItem **ppiScopeItem)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;
    CScopeNode *pScopeNode = NULL;
    CScopeItem *pScopeItem = NULL;

    if (NULL == ppiScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If index is not an object then let CSnapInCollection handle it

    if ( (VT_UNKNOWN != Index.vt) && (VT_DISPATCH != Index.vt) )
    {
        hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::get_Item(
                                                                  Index,
                                                                  ppiScopeItem);
        goto Error;
    }

    // If it is an object then it must support IScopeNode

    if ( (VT_UNKNOWN == Index.vt) && (NULL != Index.punkVal) )
    {
        hr = Index.punkVal->QueryInterface(IID_IScopeNode,
                                       reinterpret_cast<void **>(&piScopeNode));
    }
    else if ( (VT_DISPATCH == Index.vt) && (NULL != Index.pdispVal) )
    {
        hr = Index.pdispVal->QueryInterface(IID_IScopeNode,
                                       reinterpret_cast<void **>(&piScopeNode));
    }
    else
    {
        hr = SID_E_INVALIDARG;
    }

    // Translate E_NOINTERFACE to E_INVALIDARG because is it means they passed
    // us some other object

    if (FAILED(hr))
    {
        if (E_NOINTERFACE == hr)
        {
            hr = SID_E_INVALIDARG;
        }
        if (SID_E_INVALIDARG == hr)
        {
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // We have a valid IScopeNode. Now Get the CScopeNode and check if it has
    // a valid CScopeItem pointer.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    pScopeItem = pScopeNode->GetScopeItem();

    // If the ScopeItem pointer comes back NULL then this is disconnected
    // ScopeNode object that doesn't belong to a ScopeItem. The user could
    // create one of these by using Dim Node As New ScopeNode.

    if (NULL == pScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // We're in business. AddRef the scope item and return it.

    pScopeItem->AddRef();
    *ppiScopeItem = static_cast<IScopeItem *>(pScopeItem);

Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}


STDMETHODIMP CScopeItems::Add
(
    BSTR                              Name,
    ScopeNode                        *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    ScopeItem                       **ppScopeItem
)
{
    HRESULT     hr = S_OK;
    GUID        NodeTypeGUID = GUID_NULL;
    BSTR        bstrNodeTypeGUID = NULL;
    BOOL        fHasChildren = TRUE;
    IScopeItem *piScopeItem = NULL;

    WCHAR wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    if ( (!ValidBstr(Name)) || (NULL == ScopeNodeRelative) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::CoCreateGuid(&NodeTypeGUID));
    if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                               sizeof(wszNodeTypeGUID) /
                               sizeof(wszNodeTypeGUID[0])))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    bstrNodeTypeGUID = ::SysAllocString(wszNodeTypeGUID);
    if (NULL == bstrNodeTypeGUID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(HasChildren))
    {
        if (VT_BOOL == HasChildren.vt)
        {
            fHasChildren = VARIANTBOOL_TO_BOOL(HasChildren.boolVal);
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(InternalAddNew(Name,               // Name
                            Name,               // Display name
                            Name,               // Node type name
                            bstrNodeTypeGUID,
                            reinterpret_cast<IScopeNode *>(ScopeNodeRelative),
                            RelativeRelationship,
                            fHasChildren,
                            &piScopeItem));

    FireInitialize(piScopeItem);

    *ppScopeItem = reinterpret_cast<ScopeItem *>(piScopeItem);

Error:
    FREESTRING(bstrNodeTypeGUID);
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(Name);
        piScopeItem->Release();
    }
    RRETURN(hr);
}



STDMETHODIMP CScopeItems::AddPreDefined
(
    BSTR                              NodeTypeName,
    BSTR                              Name,
    ScopeNode                        *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    ScopeItem                       **ppScopeItem
)
{
    HRESULT         hr = S_OK;
    IScopeItemDefs *piScopeItemDefs = NULL;
    CScopeItemDefs *pScopeItemDefs = NULL;
    IScopeItemDef  *piScopeItemDef = NULL;
    IScopeItem     *piScopeItem = NULL;
    BOOL            fHasChildren = FALSE;

    if ( (!ValidBstr(NodeTypeName)) || (!ValidBstr(Name)) ||
         (NULL == ScopeNodeRelative) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the scope item definiton. Check AutoCreate nodes first.

    IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
    hr = pScopeItemDefs->GetItemByName(NodeTypeName, &piScopeItemDef);

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        // Not in AutoCreate, try other nodes
        RELEASE(piScopeItemDefs);
        IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_OtherNodes(&piScopeItemDefs));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
        hr = pScopeItemDefs->GetItemByName(NodeTypeName, &piScopeItemDef);
    }

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        // User passed a bad node type name
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFailGo(hr);
    }
    RELEASE(piScopeItemDefs);

    IfFailGo(InternalAddPredefined(
                              Name,
                              piScopeItemDef,
                              reinterpret_cast<IScopeNode *>(ScopeNodeRelative),
                              RelativeRelationship,
                              HasChildren,
                              &piScopeItem));

    *ppScopeItem = reinterpret_cast<ScopeItem *>(piScopeItem);

Error:
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(Name);
        piScopeItem->Release();
    }
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piScopeItemDef);
    RRETURN(hr);
}



STDMETHODIMP CScopeItems::Remove(BSTR Name)
{
    HRESULT     hr = S_OK;
    IScopeItem *piScopeItem = NULL;
    CScopeItem *pScopeItem = NULL;
    HSCOPEITEM  hsi = NULL;
    
    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = Name;
   
    if (ReadOnly())
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the scope item. This checks its existence and leaves a ref on it
    // so we can fire ScopeItems_Terminate.

    IfFailGo(get_Item(varIndex, &piScopeItem));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));

    // If this is the static node then don't allow the removal as MMC controls
    // its lifetime

    if (pScopeItem->IsStaticNode())
    {
        hr = SID_E_CANT_REMOVE_STATIC_NODE;
        EXCEPTION_CHECK_GO(hr);
    }

    // Remove it from MMC. Pass TRUE to indicate that this item should be
    // deleted along with all of its children.

    // NTBUGS 356327: We need to do this before removing the ScopeItem from the
    // collection because during the IConsoleNameSpace2::DeleteItem() call, MMC
    // could call IComponent::GetResultViewType(). If we delete the ScopeItem,
    // first, and it had a corresponding ScopePaneItem, then
    // CView::GetResultViewType()would create a new ScopePaneItem and attach
    // it to the ScopeItem that is about to be deleted. If the snap-in later
    // adds another ScopeItem using the same key, (e.g. FileExplorer refreshes
    // its drives under "My Computer" after running its config wizard), then
    // when the user selects that ScopeItem, CView will use the existing
    // ScopePaneItem which points to the old deleted ScopeItem.

    hsi = pScopeItem->GetScopeNode()->GetHSCOPEITEM();
    hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(hsi, TRUE);
    EXCEPTION_CHECK_GO(hr);

    // Remove it from the collection. This will also remove any corresponding
    // ScopePaneItems in all views.

    IfFailGo(RemoveScopeItemByKey(varIndex));

    // Fire ScopeItems_Terminate

    FireTerminate(piScopeItem);

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it
    pScopeItem->SetData(NULL);

    // Remove the ref we held for presence in MMC
    piScopeItem->Release(); 

Error:
    QUICK_RELEASE(piScopeItem); // if successful, ScopeItem should die here
    RRETURN(hr);
}


STDMETHODIMP CScopeItems::Clear()
{
    // Disallow this operation because it would remove the static node. MMC
    // controls the static node's lifetime.
    
    HRESULT hr = SID_E_CANT_REMOVE_STATIC_NODE;
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopeItems == riid)
    {
        *ppvObjOut = static_cast<IScopeItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sidesdef.cpp ===
//=--------------------------------------------------------------------------=
// sidesdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesignerDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sidesdef.h"
#include "menus.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDesignerDef::CSnapInDesignerDef(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPINDESIGNERDEF,
                           static_cast<ISnapInDesignerDef *>(this),
                           static_cast<CSnapInDesignerDef *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_SnapInDesignerDef,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSnapInDesignerDef::~CSnapInDesignerDef()
{
    RELEASE(m_piSnapInDef);
    RELEASE(m_piExtensionDefs);
    RELEASE(m_piAutoCreateNodes);
    RELEASE(m_piOtherNodes);
    RELEASE(m_piImageLists);
    RELEASE(m_piMenus);
    RELEASE(m_piToolbars);
    RELEASE(m_piViewDefs);
    RELEASE(m_piDataFormats);
    RELEASE(m_piRegInfo);
    FREESTRING(m_bstrProjectName);
    InitMemberVariables();
}

void CSnapInDesignerDef::InitMemberVariables()
{
    m_piSnapInDef = NULL;
    m_piExtensionDefs = NULL;
    m_piAutoCreateNodes = NULL;
    m_piOtherNodes = NULL;
    m_piImageLists = NULL;
    m_piMenus = NULL;
    m_piToolbars = NULL;
    m_piViewDefs = NULL;
    m_piDataFormats = NULL;
    m_piRegInfo = NULL;
    m_TypeinfoCookie = 0;
    m_bstrProjectName = NULL;
}

IUnknown *CSnapInDesignerDef::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;

    CSnapInDesignerDef *pSnapInDesignerDef = New CSnapInDesignerDef(punkOuter);
    if (NULL == pSnapInDesignerDef)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // The RegInfo object is not serialized so need to create it now

    IfFailGo(CreateObject(OBJECT_TYPE_REGINFO,
                          IID_IRegInfo,
                          &pSnapInDesignerDef->m_piRegInfo));

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pSnapInDesignerDef)
        {
            delete pSnapInDesignerDef;
        }
        return NULL;
    }
    else
    {
        return pSnapInDesignerDef->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::Persist()
{
    HRESULT       hr = S_OK;
    IMMCMenuDefs *piMMCMenuDefs = NULL;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piImageLists, CLSID_MMCImageLists,
                            OBJECT_TYPE_MMCIMAGELISTS, IID_IMMCImageLists,
                            OLESTR("ImageLists")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 8) )
    {
        // Project was created prior to menu object model change. Load it
        // and convert it to an MMCMenus collection.

        IfFailGo(PersistObject(&piMMCMenuDefs, CLSID_MMCMenuDefs,
                                OBJECT_TYPE_MMCMENUDEFS, IID_IMMCMenuDefs,
                                OLESTR("Menus")));
        RELEASE(m_piMenus);
        IfFailGo(CreateObject(OBJECT_TYPE_MMCMENUS, IID_IMMCMenus, &m_piMenus));
        IfFailGo(CMMCMenus::Convert(piMMCMenuDefs, m_piMenus));
    }
    else
    {
        IfFailGo(PersistObject(&m_piMenus, CLSID_MMCMenus,
                                OBJECT_TYPE_MMCMENUS, IID_IMMCMenus,
                                OLESTR("Menus")));
    }

    IfFailGo(PersistObject(&m_piToolbars, CLSID_MMCToolbars,
                            OBJECT_TYPE_MMCTOOLBARS, IID_IMMCToolbars,
                            OLESTR("Toolbars")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                            OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                            OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piDataFormats, CLSID_DataFormats,
                            OBJECT_TYPE_DATAFORMATS, IID_IDataFormats,
                            OLESTR("DataFormats")));

    // Now persist nodes and extensions

    IfFailGo(PersistObject(&m_piSnapInDef, CLSID_SnapInDef,
                            OBJECT_TYPE_SNAPINDEF, IID_ISnapInDef,
                            OLESTR("SnapInDef")));

    IfFailGo(PersistObject(&m_piExtensionDefs, CLSID_ExtensionDefs,
                            OBJECT_TYPE_EXTENSIONDEFS, IID_IExtensionDefs,
                            OLESTR("ExtensionDefs")));

    IfFailGo(PersistObject(&m_piAutoCreateNodes, CLSID_ScopeItemDefs,
                            OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                            OLESTR("AutoCreateNodes")));

    IfFailGo(PersistObject(&m_piOtherNodes, CLSID_ScopeItemDefs,
                            OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                            OLESTR("OtherNodes")));

    IfFailGo(PersistSimpleType(&m_TypeinfoCookie, 0L, OLESTR("TypeinfoCookie")));

    IfFailGo(PersistBstr(&m_bstrProjectName, L"", OLESTR("ProjectName")));

    // Note: we do not serialize registation info because it is regenerated
    // every time VB calls IDesignerRegistration::GetRegistrationInfo()

Error:
    QUICK_RELEASE(piMMCMenuDefs);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISnapInDesignerDef == riid)
    {
        *ppvObjOut = static_cast<ISnapInDesignerDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piSnapInDef));

    IfFailRet(SetObjectHost(m_piExtensionDefs));

    IfFailRet(SetObjectHost(m_piAutoCreateNodes));

    IfFailRet(SetObjectHost(m_piOtherNodes));

    IfFailRet(SetObjectHost(m_piImageLists));

    IfFailRet(SetObjectHost(m_piMenus));

    IfFailRet(SetObjectHost(m_piToolbars));

    IfFailRet(SetObjectHost(m_piViewDefs));

    IfFailRet(SetObjectHost(m_piDataFormats));

    IfFailRet(SetObjectHost(m_piRegInfo));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sidesdef.h ===
//=--------------------------------------------------------------------------=
// sidesdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesignerDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINDESIGNERDEF_DEFINED_
#define _SNAPINDESIGNERDEF_DEFINED_


class CSnapInDesignerDef : public CSnapInAutomationObject,
                           public CPersistence,
                           public ISnapInDesignerDef
{
    private:
        CSnapInDesignerDef(IUnknown *punkOuter);
        ~CSnapInDesignerDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISnapInDesignerDef

        OBJECT_PROPERTY_RO(CSnapInDesignerDef, SnapInDef,       ISnapInDef,     DISPID_SNAPINDESIGNERDEF_SNAPINDEF);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ExtensionDefs,   IExtensionDefs, DISPID_SNAPINDESIGNERDEF_EXTENSIONDEFS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, AutoCreateNodes, IScopeItemDefs, DISPID_SNAPINDESIGNERDEF_AUTOCREATE_NODES);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, OtherNodes,      IScopeItemDefs, DISPID_SNAPINDESIGNERDEF_OTHER_NODES);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ImageLists,      IMMCImageLists, DISPID_SNAPINDESIGNERDEF_IMAGELISTS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, Menus,           IMMCMenus,      DISPID_SNAPINDESIGNERDEF_MENUS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, Toolbars,        IMMCToolbars,   DISPID_SNAPINDESIGNERDEF_TOOLBARS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ViewDefs,        IViewDefs,      DISPID_SNAPINDESIGNERDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, DataFormats,     IDataFormats,   DISPID_SNAPINDESIGNERDEF_DATA_FORMATS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, RegInfo,         IRegInfo,       DISPID_SNAPINDESIGNERDEF_REGINFO);
        SIMPLE_PROPERTY_RW(CSnapInDesignerDef, TypeinfoCookie,  long,           DISPID_SNAPINDESIGNERDEF_TYPEINFO_COOKIE);
        BSTR_PROPERTY_RW(CSnapInDesignerDef,   ProjectName,                     DISPID_SNAPINDESIGNERDEF_PROJECTNAME);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapInDesignerDef,           // name
                                &CLSID_SnapInDesignerDef,    // clsid
                                "SnapInDesignerDef",         // objname
                                "SnapInDesignerDef",         // lblname
                                &CSnapInDesignerDef::Create, // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_ISnapInDesignerDef,     // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _SNAPINDESIGNERDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapin.h ===
//=--------------------------------------------------------------------------=
// snapin.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapIn class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPIN_DEFINED_
#define _SNAPIN_DEFINED_

#include "dataobj.h"
#include "scopitms.h"
#include "scopitem.h"
#include "views.h"
#include "view.h"
#include "spanitms.h"
#include "resviews.h"
#include "extsnap.h"
#include "ctxtmenu.h"
#include "prpsheet.h"
#include "xtensons.h"
#include "xtenson.h"
#include "strtable.h"

class CMMCDataObject;
class CScopeItems;
class CScopeItem;
class CViews;
class CView;
class CScopePaneItems;
class CResultViews;
class CExtensionSnapIn;
class CContextMenu;
class CControlbar;
class CMMCStringTable;



//=--------------------------------------------------------------------------=
//
// class CSnapIn
//
// This is the object that the VB runtime will CoCreate and aggregate when
// MMC CoCreates the user's snap-in DLL created in the VB IDE.
// It implements IComponentData, persistence, interfaces required by the VB
// runtime, and MMC extension interfaces.
//
// at runtime, this class also serves as the object model host for the design
// time definition objects.
//=--------------------------------------------------------------------------=

class CSnapIn : public CSnapInAutomationObject,
                public ISnapIn,
                public IPersistStreamInit,
                public IPersistStream,
                public IObjectModelHost,
                public IProvideDynamicClassInfo,
                public IOleObject,
                public ISnapinAbout,
                public IComponentData,
                public IExtendContextMenu,
                public IExtendControlbar,
                public IExtendControlbarRemote,
                public IExtendPropertySheet2,
                public IExtendPropertySheetRemote,
                public IRequiredExtensions,
                public ISnapinHelp2,
                public IMMCRemote
{
    private:
        CSnapIn(IUnknown *punkOuter);
        ~CSnapIn();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();

    // IDispatch methods. Can't use DECLARE_STANDARD_DISPATCH() because
    // we need to handle dynamic property gets in Invoke for image lists,
    // toolbars, and menus

        STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut);
        STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames,
                                 UINT cnames, LCID lcid, DISPID *rgdispid);
        STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags,
                          DISPPARAMS *pdispparams, VARIANT *pVarResult,
                          EXCEPINFO *pexcepinfo, UINT *puArgErr);



    // ISnapIn
        BSTR_PROPERTY_RW(CSnapIn,    Name,                  DISPID_SNAPIN_NAME);
        BSTR_PROPERTY_RW(CSnapIn,    NodeTypeName,          DISPID_SNAPIN_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CSnapIn,    NodeTypeGUID,          DISPID_SNAPIN_NODE_TYPE_GUID);

        BSTR_PROPERTY_RO(CSnapIn,    DisplayName,           DISPID_SNAPIN_DISPLAY_NAME);
        STDMETHOD(put_DisplayName)(BSTR bstrDisplayName);

        SIMPLE_PROPERTY_RW(CSnapIn,  Type,                  SnapInTypeConstants, DISPID_SNAPIN_TYPE);
        BSTR_PROPERTY_RW(CSnapIn,    HelpFile,              DISPID_SNAPIN_HELP_FILE);
        BSTR_PROPERTY_RW(CSnapIn,    LinkedTopics,          DISPID_SNAPIN_LINKED_TOPICS);
        BSTR_PROPERTY_RW(CSnapIn,    Description,           DISPID_SNAPIN_DESCRIPTION);
        BSTR_PROPERTY_RW(CSnapIn,    Provider,              DISPID_SNAPIN_PROVIDER);
        BSTR_PROPERTY_RW(CSnapIn,    Version,               DISPID_SNAPIN_VERSION);
        COCLASS_PROPERTY_RW(CSnapIn, SmallFolders,          MMCImageList, IMMCImageList, DISPID_SNAPIN_SMALL_FOLDERS);
        COCLASS_PROPERTY_RW(CSnapIn, SmallFoldersOpen,      MMCImageList, IMMCImageList, DISPID_SNAPIN_SMALL_FOLDERS_OPEN);
        COCLASS_PROPERTY_RW(CSnapIn, LargeFolders,          MMCImageList, IMMCImageList, DISPID_SNAPIN_LARGE_FOLDERS);
        OBJECT_PROPERTY_RW(CSnapIn,  Icon,                  IPictureDisp, DISPID_SNAPIN_ICON);
        OBJECT_PROPERTY_RW(CSnapIn,  Watermark,             IPictureDisp, DISPID_SNAPIN_WATERMARK);
        OBJECT_PROPERTY_RW(CSnapIn,  Header,                IPictureDisp, DISPID_SNAPIN_HEADER);
        OBJECT_PROPERTY_RW(CSnapIn,  Palette,               IPictureDisp, DISPID_SNAPIN_PALETTE);
        SIMPLE_PROPERTY_RW(CSnapIn,  StretchWatermark,      VARIANT_BOOL,  DISPID_SNAPIN_STRETCH_WATERMARK);
        VARIANT_PROPERTY_RO(CSnapIn, StaticFolder,          DISPID_SNAPIN_STATIC_FOLDER);
        STDMETHOD(put_StaticFolder)(VARIANT varFolder);
        COCLASS_PROPERTY_RO(CSnapIn, ScopeItems,            ScopeItems, IScopeItems, DISPID_SNAPIN_SCOPEITEMS);
        COCLASS_PROPERTY_RO(CSnapIn, Views,                 Views, IViews, DISPID_SNAPIN_VIEWS);
        COCLASS_PROPERTY_RO(CSnapIn, ExtensionSnapIn,       ExtensionSnapIn,     IExtensionSnapIn, DISPID_SNAPIN_EXTENSION_SNAPIN);
        COCLASS_PROPERTY_RO(CSnapIn, ScopePaneItems,        ScopePaneItems, IScopePaneItems, DISPID_SNAPIN_SCOPE_PANE_ITEMS);
        COCLASS_PROPERTY_RO(CSnapIn, ResultViews,           ResultViews, IResultViews, DISPID_SNAPIN_RESULT_VIEWS);
        SIMPLE_PROPERTY_RO(CSnapIn,  RuntimeMode,           SnapInRuntimeModeConstants, DISPID_SNAPIN_RUNTIME_MODE);

        STDMETHOD(get_TaskpadViewPreferred)(VARIANT_BOOL *pfvarPreferred);

        STDMETHOD(get_RequiredExtensions)(Extensions **ppExtensions);
        
        STDMETHOD(get_Clipboard)(MMCClipboard **ppMMCClipboard);

        SIMPLE_PROPERTY_RW(CSnapIn,  Preload, VARIANT_BOOL, DISPID_SNAPIN_PRELOAD);

        STDMETHOD(get_StringTable)(MMCStringTable **ppMMCStringTable);

        STDMETHOD(get_CurrentView)(View **ppView);
        STDMETHOD(get_CurrentScopePaneItem)(ScopePaneItem **ppScopePaneItem);
        STDMETHOD(get_CurrentScopeItem)(ScopeItem **ppScopeItem);
        STDMETHOD(get_CurrentResultView)(ResultView **ppResultView);
        STDMETHOD(get_CurrentListView)(MMCListView **ppListView);
        STDMETHOD(get_MMCCommandLine)(BSTR *pbstrCmdLine);

        STDMETHOD(ConsoleMsgBox)(BSTR     Prompt,
                                 VARIANT  Buttons,
                                 VARIANT  Title,
                                 int     *pnResult);

        STDMETHOD(ShowHelpTopic)(BSTR Topic);
        STDMETHOD(Trace)(BSTR Message);
        STDMETHOD(FireConfigComplete)(IDispatch *pdispConfigObject);
        STDMETHOD(FormatData)(VARIANT                Data,
                              long                   StartingIndex,
                              SnapInFormatConstants  Format,
                              VARIANT               *BytesUsed,
                              VARIANT               *pvarFormattedData);

    // IPersistStreamInit and IPersistStream methods
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);
        STDMETHOD(InitNew)();

    // IProvideDynamicClassInfo
        STDMETHOD(GetClassInfo)(ITypeInfo **ppTypeInfo);
        STDMETHOD(GetDynamicClassInfo)(ITypeInfo **ppTypeInfo, DWORD *pdwCookie);
        STDMETHOD(FreezeShape)(void);

    // IOleObject

        STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
        STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
        STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp,
                               LPCOLESTR szContainerObj);
        STDMETHOD(Close)(DWORD dwSaveOption);
        STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker *pmk);
        STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
                             IMoniker **ppmk);
        STDMETHOD(InitFromData)(IDataObject *pDataObject,
                               BOOL fCreation,
                               DWORD dwReserved);
        STDMETHOD(GetClipboardData)(DWORD dwReserved,
                                   IDataObject **ppDataObject);
        STDMETHOD(DoVerb)(LONG iVerb,
                          LPMSG lpmsg,
                          IOleClientSite *pActiveSite,
                          LONG lindex,
                          HWND hwndParent,
                          LPCRECT lprcPosRect);
        STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
        STDMETHOD(Update)();
        STDMETHOD(IsUpToDate)();
        STDMETHOD(GetUserClassID)(CLSID *pClsid);
        STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
        STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
        STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
        STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
        STDMETHOD(Unadvise)(DWORD dwConnection);
        STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
        STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
        STDMETHOD(SetColorScheme)(LOGPALETTE *pLogpal);


    // ISnapinAbout
        STDMETHOD(GetSnapinDescription)(LPOLESTR *ppszDescription);

        STDMETHOD(GetProvider)(LPOLESTR *ppszName);

        STDMETHOD(GetSnapinVersion)(LPOLESTR *ppszVersion);

        STDMETHOD(GetSnapinImage)(HICON *phAppIcon);

        STDMETHOD(GetStaticFolderImage)(HBITMAP  *phSmallImage,
                                        HBITMAP  *phSmallImageOpen,
                                        HBITMAP  *phLargeImage,
                                        COLORREF *pclrMask);


    // IComponentData
        STDMETHOD(CompareObjects)(IDataObject *piDataObject1, IDataObject *piDataObject2);
        STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pItem);
        STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, IDataObject ** ppiDataObject);
        STDMETHOD(Notify)(IDataObject *pDataObject, MMC_NOTIFY_TYPE event, long Arg, long Param);
        STDMETHOD(CreateComponent)(IComponent **ppiComponent);
        STDMETHOD(Initialize)(IUnknown *punkConsole);
        STDMETHOD(Destroy)();

    // IExtendControlbar
        STDMETHOD(SetControlbar)(IControlbar *piControlbar);
        STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
                                    LPARAM arg, LPARAM param);

    // IExtendControlbarRemote
        STDMETHOD(MenuButtonClick)(IDataObject   *piDataObject,
                                   int             idCommand,
                                   POPUP_MENUDEF **ppPopupMenuDef);
        STDMETHOD(PopupMenuClick)(IDataObject *piDataObject,
                                  UINT         uIDItem,
                                  IUnknown    *punkParam);

    // IExtendContextMenu
        STDMETHOD(AddMenuItems)(IDataObject          *piDataObject,
                                IContextMenuCallback *piContextMenuCallback,
                                long                 *plInsertionAllowed);
        STDMETHOD(Command)(long lCommandID, IDataObject *piDataObject);

    // IExtendPropertySheet2
        STDMETHOD(CreatePropertyPages)(IPropertySheetCallback *piPropertySheetCallback,
                                       LONG_PTR handle,
                                       IDataObject *piDataObject);
        STDMETHOD(QueryPagesFor)(IDataObject *piDataObject);
        STDMETHOD(GetWatermarks)(IDataObject *piDataObject,
                                 HBITMAP     *phbmWatermark,
                                 HBITMAP     *phbmHeader,
                                 HPALETTE    *phPalette,
                                 BOOL        *bStretch);

    // IExtendPropertySheetRemote
        STDMETHOD(CreatePropertyPageDefs)(IDataObject          *piDataObject,
                                          WIRE_PROPERTYPAGES **ppPages);

    // IRequiredExtensions
        STDMETHOD(EnableAllExtensions)();
        STDMETHOD(GetFirstExtension)(CLSID *pclsidExtension);
        STDMETHOD(GetNextExtension)(CLSID *pclsidExtension);

    // ISnapinHelp
        STDMETHOD(GetHelpTopic)(LPOLESTR *ppwszHelpFile);

    // ISnapinHelp2
        STDMETHOD(GetLinkedTopics)(LPOLESTR *ppwszTopics);

    // IMMCRemote
        STDMETHOD(ObjectIsRemote)();
        STDMETHOD(SetMMCExePath)(char *pszPath);
        STDMETHOD(SetMMCCommandLine)(char *pszCmdLine);

    // IObjectModelHost
        STDMETHOD(Update)(long ObjectCookie, IUnknown *punkObject, DISPID dispid) { return S_OK; }
        STDMETHOD(Add)(long CollectionCookie, IUnknown *punkNewObject)  { return S_OK; }
        STDMETHOD(Delete)(long ObjectCookie, IUnknown *punkObject)  { return S_OK; }
        STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
        STDMETHOD(GetRuntime)(BOOL *pfRuntime);

    // Public utility methods
        ISnapInDef         *GetSnapInDef() { return m_piSnapInDef; }
        ISnapInDesignerDef *GetSnapInDesignerDef() { return m_piSnapInDesignerDef; }
        CScopeItem         *GetStaticNodeScopeItem() { return m_pStaticNodeScopeItem; }
        CScopeItems        *GetScopeItems() { return m_pScopeItems; }
        CScopePaneItems    *GetScopePaneItems() { return m_pScopePaneItems; }
        CResultViews       *GetResultViews() { return m_pResultViews; }
        IConsole2          *GetIConsole2() { return m_piConsole2; }
        IConsoleNameSpace2 *GetIConsoleNameSpace2() { return m_piConsoleNameSpace2; }
        CViews             *GetViews() { return m_pViews; }
        CView              *GetCurrentView() { return m_pCurrentView; }
        void                SetCurrentView(CView *pView) { m_pCurrentView = pView; }
        long                GetImageCount() { return m_cImages; }
        char               *GetMMCExePath() { return m_szMMCEXEPath; }
        WCHAR              *GetMMCExePathW() { return m_pwszMMCEXEPath; }
        BSTR                GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }
        BSTR                GetDisplayName() { return m_bstrDisplayName; }
        HRESULT             GetSnapInPath(OLECHAR **ppwszPath,
                                          size_t   *pcbSnapInPath);
        SnapInRuntimeModeConstants GetRuntimeMode() { return m_RuntimeMode; }
        void SetRuntimeMode(SnapInRuntimeModeConstants Mode) { m_RuntimeMode = Mode; }
        DWORD GetInstanceID() { return m_dwInstanceID; }
        BOOL GetPreload() { return VARIANTBOOL_TO_BOOL(m_Preload); }
        void FireHelp() { FireEvent(&m_eiHelp); }
        SnapInTypeConstants GetType() { return m_Type; }
        HRESULT SetStaticFolder(VARIANT varFolder);
        BOOL WeAreRemote() { return m_fWeAreRemote; }

        // Sets SnapIn.DisplayName without changing it in MMC
        HRESULT SetDisplayName(BSTR bstrDisplayName);

        CExtensionSnapIn *GetExtensionSnapIn() { return m_pExtensionSnapIn; }
        CControlbar *GetControlbar() { return m_pControlbar; }

        // These methods are used to keep track of the currently active
        // controlbar. They are called by both CSnapIn's and CView's
        // IExtendControlbar method implementations on entry and exit to each
        // method of that interface. Tracking the active controlbar allows 
        // MMCToolbar to find the instance of IToolbar or IMenuButton that it
        // should use when the snap-in alters the toolbar or menubutton (e.g.
        // enable/disable buttons). This is necessary because a single MMCToolbar
        // object is shared among multiple views. This sharing allows events
        // to be on MMCToolbar rather than a collection of MMCToolbars.

        CControlbar* GetCurrentControlbar() { return m_pControlbarCurrent; }

        void SetCurrentControlbar(CControlbar* pControlbar)
        { m_pControlbarCurrent = pControlbar; }

        // Converts an unqualified URL to a fully qualified res:// URL for the
        // snap-in's DLL.

        HRESULT ResolveResURL(WCHAR *pwszURL, OLECHAR **ppwszResolvedURL);

        // Set and remove the object model host on design time definitions
        
        HRESULT SetDesignerDefHost();
        HRESULT RemoveDesignerDefHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        void ReleaseConsoleInterfaces();
        HRESULT AddScopeItemImages();
        HRESULT GetScopeItemImage(VARIANT varImageIndex, int *pnIndex);
        HRESULT SetSnapInPropertiesFromState();
        HRESULT GetStaticNodeDataObject(IDataObject       **ppiDataObject,
                                        DATA_OBJECT_TYPES   context);
        HRESULT SetObjectModelHost(IUnknown *punkObject);
        HRESULT RemoveObjectModelHost(IUnknown *punkObject);
        HRESULT SetObjectModelHostIfNotSet(IUnknown *punkObject, BOOL *pfWasSet);

        enum ExpandType { Expand, ExpandSync };
        
        HRESULT OnExpand(ExpandType Type, IDataObject *piDataObject,
                         BOOL fExpanded, HSCOPEITEM hsi, BOOL *pfHandled);
        HRESULT OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName);
        HRESULT OnPreload(IDataObject *piDataObject, HSCOPEITEM hsi);
        HRESULT OnDelete(IDataObject *piDataObject);
        HRESULT OnRemoveChildren(IDataObject *piDataObject, HSCOPEITEM hsi);

        HRESULT FindMenu(IMMCMenus *piMMCMenus, DISPID dispid,
                         BOOL *pfFound, IMMCMenu **ppiMMCMenu);

        HRESULT AddDynamicNameSpaceExtensions(CScopeItem *pScopeItem);

        HRESULT GetScopeItemExtensions(CExtensions    *pExtensions,
                                       IScopeItemDefs *piScopeItemDefs);
        HRESULT GetListItemExtensions(CExtensions   *pExtensions,
                                      IListViewDefs *piListViewDefs);
        HRESULT FireReadProperties(IStream *piStream);
        HRESULT StoreStaticHSI(CScopeItem *pScopeItem,
                               CMMCDataObject *pMMCDataObject, HSCOPEITEM hsi);
        HRESULT ExtractBSTR(long cBytes, BSTR bstr, BSTR *pbstrOut, long *pcbUsed);
        HRESULT ExtractBSTRs(long cBytes, BSTR bstr, VARIANT *pvarOut, long *pcbUsed);
        HRESULT ExtractObject(long cBytes, void *pvData, IUnknown **ppunkObject, long *pcbUsed,
                              SnapInFormatConstants Format);
        HRESULT InternalCreatePropertyPages(IPropertySheetCallback  *piPropertySheetCallback,
                                            LONG_PTR                 handle,
                                            IDataObject             *piDataObject,
                                            WIRE_PROPERTYPAGES     **ppPages);
        HRESULT SetMMCExePath();
        HRESULT CompareListItems(CMMCListItem *pMMCListItem1,
                                 CMMCListItem *pMMCListItem2,
                                 BOOL         *pfEqual);


        ISnapInDesignerDef *m_piSnapInDesignerDef;   // serialized state
        ISnapInDef         *m_piSnapInDef;           // from serialzation
        IOleClientSite     *m_piOleClientSite;       // VB runtime client site
        CScopeItems        *m_pScopeItems;           // SnapIn.ScopeItems
        CScopeItem         *m_pStaticNodeScopeItem;  // ptr to ScopeItem for static node
        CExtensionSnapIn   *m_pExtensionSnapIn;      // SnapIn.ExtensionSnapIn
        CViews             *m_pViews;                // SnapIn.Views
        CView              *m_pCurrentView;          // SnapIn.CurrentView
        CScopePaneItems    *m_pScopePaneItems;       // hidden collection used
                                                     // for event firing only
        CResultViews       *m_pResultViews;          // same here
        IConsole2          *m_piConsole2;            // MMC interface
        IConsoleNameSpace2 *m_piConsoleNameSpace2;   // MMC interface
        IImageList         *m_piImageList;           // MMC interface
        IDisplayHelp       *m_piDisplayHelp;         // MMC interface
        IStringTable       *m_piStringTable;         // MMC interface
        HSCOPEITEM          m_hsiRootNode;           // HSCOPEITEM for static node
        BOOL                m_fHaveStaticNodeHandle; // TRUE=m_hsiRootNode is valid
        DWORD               m_dwTypeinfoCookie;      // for VB runtime, comes from serialization
        long                m_cImages;               // used to calculate image
                                                     // indexes for
                                                     // IComponentData::GetDisplayInfo
        IID                 m_IID;                   // dynamic IID from typeinfo

        CContextMenu       *m_pContextMenu;         // implements MMC's
                                                    // IExtendContextMenu and
                                                    // our IContextMenu


        CControlbar        *m_pControlbar;          // Implements MMC's
                                                    // IExtendControlbar and our
                                                    // IMMCControlbar

        CControlbar        *m_pControlbarCurrent;   // Pointer to CControlbar
                                                    // object currently executing
                                                    // an IExtendControlbar
                                                    // method. This could be
                                                    // the one belonging to
                                                    // CSnapIn (for extensions)
                                                    // or one belonging to a View

        BOOL                m_fWeAreRemote;         // indicates whether
                                                    // the snap-in is being
                                                    // run remotely (in an F5
                                                    // for source debugging)

        char                m_szMMCEXEPath[MAX_PATH];// When running remotely
                                                     // the proxy will give us
                                                     // MMC.EXE's path so we can
                                                     // build taskpad display
                                                     // strings. When running
                                                     // locally we initialize
                                                     // with GetModuleFileName().

        WCHAR              *m_pwszMMCEXEPath;        // Wide version of same
        size_t              m_cbMMCExePathW;         // size of it in bytes without
                                                     // terminating null char

        OLECHAR            *m_pwszSnapInPath;        // Fully qualified file
                                                     // name of snap-in's DLL.
                                                     // Used when resolving
                                                     // relative res:// URLs in
                                                     // a taskpad.
        size_t             m_cbSnapInPath;           // Length in bytes of path
                                                     // without terminating null.

        DWORD              m_dwInstanceID;           // Set with GetTickCount()
                                                     // to uniquely identify a
                                                     // a snap-in instance. Used
                                                     // when interpreting data
                                                     // objects to determine
                                                     // whether a VB sourced
                                                     // selection comes from the
                                                     // same snap-in.

        IExtensions       *m_piRequiredExtensions;   // From IDL. Collection
                                                     // of registered extensions
                                                     // for the snap-in.

        long               m_iNextExtension;         // Used to implement required
                                                     // extension enumeration for
                                                     // IRequiredExtensions

        IMMCStringTable   *m_piMMCStringTable;       // From IDL. StringTable
                                                     // object that wraps MMC's
                                                     // IStringTable.

        char              *m_pszMMCCommandLine;      // MMC command line set
                                                     // from proxy

        // Event parameter definitions
        
        static EVENTINFO m_eiLoad;

        static EVENTINFO m_eiUnload;

        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtQueryConfigurationWizard[1];
        static EVENTINFO m_eiQueryConfigurationWizard;

        static VARTYPE   m_rgvtCreateConfigurationWizard[1];
        static EVENTINFO m_eiCreateConfigurationWizard;

        static VARTYPE   m_rgvtConfigurationComplete[1];
        static EVENTINFO m_eiConfigurationComplete;

        static VARTYPE   m_rgvtWriteProperties[1];
        static EVENTINFO m_eiWriteProperties;

        static VARTYPE   m_rgvtReadProperties[1];
        static EVENTINFO m_eiReadProperties;

        static EVENTINFO m_eiPreload;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapIn,                 // name
                                &CLSID_SnapIn,          // clsid
                                "SnapIn",               // objname
                                "SnapIn",               // lblname
                                &CSnapIn::Create,       // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_ISnapIn,           // dispatch IID
                                &DIID_DSnapInEvents,    // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _SNAPIN_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkey.h ===
//=--------------------------------------------------------------------------=
// sortkey.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSortKey class definition - implememnts SortKey object
//
//=--------------------------------------------------------------------------=

#ifndef _SORTKEY_DEFINED_
#define _SORTKEY_DEFINED_

#include "colhdrs.h"

class CSortKey : public CSnapInAutomationObject,
                 public ISortKey
{
    private:
        CSortKey(IUnknown *punkOuter);
        ~CSortKey();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISortKey

    public:

        SIMPLE_PROPERTY_RW(CSortKey, Index,     long,                     DISPID_SORTKEY_INDEX);
        BSTR_PROPERTY_RW(CSortKey,   Key,                                 DISPID_SORTKEY_KEY);
        SIMPLE_PROPERTY_RW(CSortKey, Column,    long,                     DISPID_SORTKEY_COLUMN);
        SIMPLE_PROPERTY_RW(CSortKey, SortOrder, SnapInSortOrderConstants, DISPID_SORTKEY_SORTORDER);
        SIMPLE_PROPERTY_RW(CSortKey, SortIcon,  VARIANT_BOOL,             DISPID_SORTKEY_SORTICON);

    // Public Utility methods

    public:

        long GetIndex() { return m_Index; }
        long GetColumn() { return m_Column; }
        SnapInSortOrderConstants GetSortOrder() { return m_SortOrder; }
        BOOL GetSortIcon() { return VARIANTBOOL_TO_BOOL(m_SortIcon); }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SortKey,            // name
                                &CLSID_SortKey,     // clsid
                                "SortKey",          // objname
                                "SortKey",          // lblname
                                &CSortKey::Create,  // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ISortKey,      // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _SORTKEY_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkey.cpp ===
//=--------------------------------------------------------------------------=
// sortkey.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sortkey.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSortKey::CSortKey(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_SORTKEY,
                            static_cast<ISortKey *>(this),
                            static_cast<CSortKey *>(this),
                            0,     // no property pages
                            NULL,  // no property pages
                            NULL)  // no peristence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSortKey::~CSortKey()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CSortKey::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Column = 0;
    m_SortOrder = siAscending;
    m_SortIcon = VARIANT_TRUE;
}


IUnknown *CSortKey::Create(IUnknown * punkOuter)
{
    CSortKey *pSortKey = New CSortKey(punkOuter);
    if (NULL == pSortKey)
    {
        return NULL;
    }
    else
    {
        return pSortKey->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSortKey::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_ISortKey == riid)
    {
        *ppvObjOut = static_cast<ISortKey *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapindef.h ===
//=--------------------------------------------------------------------------=
// snapindef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINDEF_DEFINED_
#define _SNAPINDEF_DEFINED_


class CSnapInDef : public CSnapInAutomationObject,
                   public CPersistence,
                   public ISnapInDef,
                   public IPerPropertyBrowsing
{
    private:
        CSnapInDef(IUnknown *punkOuter);
        ~CSnapInDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISnapInDef

        BSTR_PROPERTY_RW(CSnapInDef,        Name,                  DISPID_SNAPINDEF_NAME);
        BSTR_PROPERTY_RW(CSnapInDef,        NodeTypeName,          DISPID_SNAPINDEF_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CSnapInDef,        NodeTypeGUID,          DISPID_SNAPINDEF_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW(CSnapInDef,        DisplayName,           DISPID_SNAPINDEF_DISPLAY_NAME);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Type,                  SnapInTypeConstants, DISPID_SNAPINDEF_TYPE);
        BSTR_PROPERTY_RW(CSnapInDef,        HelpFile,              DISPID_SNAPINDEF_HELP_FILE);
        BSTR_PROPERTY_RW(CSnapInDef,        LinkedTopics,          DISPID_SNAPINDEF_LINKED_TOPICS);
        BSTR_PROPERTY_RW(CSnapInDef,        Description,           DISPID_SNAPINDEF_DESCRIPTION);
        BSTR_PROPERTY_RW(CSnapInDef,        Provider,              DISPID_SNAPINDEF_PROVIDER);
        BSTR_PROPERTY_RW(CSnapInDef,        Version,               DISPID_SNAPINDEF_VERSION);

        STDMETHOD(get_SmallFolders)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_SmallFolders)(IMMCImageList *piMMCImageList);

        STDMETHOD(get_SmallFoldersOpen)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_SmallFoldersOpen)(IMMCImageList *piMMCImageList);

        STDMETHOD(get_LargeFolders)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_LargeFolders)(IMMCImageList *piMMCImageList);

        // For Icon we need some integrity checking on the put so declare a
        // an RO object property to let CSnapInAutomationObject handle the get
        // and then handle the put explicitly.
        
        OBJECT_PROPERTY_RO(CSnapInDef,      Icon,                  IPictureDisp, DISPID_SNAPINDEF_ICON);
        STDMETHOD(putref_Icon)(IPictureDisp *piIcon);


        OBJECT_PROPERTY_RW(CSnapInDef,      Watermark,             IPictureDisp, DISPID_SNAPINDEF_WATERMARK);
        OBJECT_PROPERTY_RW(CSnapInDef,      Header,                IPictureDisp, DISPID_SNAPINDEF_HEADER);
        OBJECT_PROPERTY_RW(CSnapInDef,      Palette,               IPictureDisp, DISPID_SNAPINDEF_PALETTE);
        SIMPLE_PROPERTY_RW(CSnapInDef,      StretchWatermark,      VARIANT_BOOL,  DISPID_SNAPINDEF_STRETCH_WATERMARK);

        VARIANT_PROPERTY_RO(CSnapInDef,     StaticFolder,          DISPID_SNAPINDEF_STATIC_FOLDER);
        STDMETHOD(put_StaticFolder)(VARIANT varFolder);

        BSTR_PROPERTY_RW(CSnapInDef,        DefaultView,           DISPID_SNAPINDEF_DEFAULTVIEW);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Extensible,            VARIANT_BOOL, DISPID_SNAPINDEF_EXTENSIBLE);
        OBJECT_PROPERTY_RO(CSnapInDef,      ViewDefs,              IViewDefs, DISPID_SNAPINDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CSnapInDef,      Children,              IScopeItemDefs, DISPID_SNAPINDEF_CHILDREN);
        BSTR_PROPERTY_RW(CSnapInDef,        IID,                   DISPID_SNAPINDEF_IID);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Preload,               VARIANT_BOOL, DISPID_SNAPINDEF_PRELOAD);
      
     // IPerPropertyBrowsing
        STDMETHOD(GetDisplayString)(DISPID dispID, BSTR *pBstr);
        STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid);
        STDMETHOD(GetPredefinedStrings)(DISPID      dispID,
                                        CALPOLESTR *pCaStringsOut,
                                        CADWORD    *pCaCookiesOut);
        STDMETHOD(GetPredefinedValue)(DISPID   dispID,
                                      DWORD    dwCookie,
                                      VARIANT *pVarOut);

     // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Variable to hold values for SnapInDef properties that have custom
        // get/put functions.

        IMMCImageList     *m_piSmallFolders;
        IMMCImageList     *m_piSmallFoldersOpen;
        IMMCImageList     *m_piLargeFolders;
        BSTR               m_bstrSmallFoldersKey;
        BSTR               m_bstrSmallFoldersOpenKey;
        BSTR               m_bstrLargeFoldersKey;

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2]; // should be 3 when extension enabled again
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapInDef,           // name
                                &CLSID_SnapInDef,    // clsid
                                "SnapInDef",         // objname
                                "SnapInDef",         // lblname
                                &CSnapInDef::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_ISnapInDef,     // dispatch IID
                                NULL,                // event IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _SNAPINDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkeys.cpp ===
//=--------------------------------------------------------------------------=
// sortkeys.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sortkeys.h"
#include "sortkey.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSortKeys::CSortKeys(IUnknown *punkOuter) :
    CSnapInCollection<ISortKey, SortKey, ISortKeys>(
                      punkOuter,
                      OBJECT_TYPE_SORTKEYS,
                      static_cast<ISortKeys *>(this),
                      static_cast<CSortKeys *>(this),
                      CLSID_SortKey,
                      OBJECT_TYPE_SORTKEY,
                      IID_ISortKey,
                      NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CSortKeys::InitMemberVariables()
{
    m_pView = NULL;
    m_bstrColumnSetID = NULL;
}

CSortKeys::~CSortKeys()
{
    InitMemberVariables();
    FREESTRING(m_bstrColumnSetID);
}

IUnknown *CSortKeys::Create(IUnknown * punkOuter)
{
    CSortKeys *pSortKeys = New CSortKeys(punkOuter);
    if (NULL == pSortKeys)
    {
        return NULL;
    }
    else
    {
        return pSortKeys->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                      ISortKeys Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CSortKeys::Add
(
    VARIANT   Index,
    VARIANT   Key,
    VARIANT   Column,
    VARIANT   SortOrder,
    VARIANT   SortIcon,
    SortKey **ppSortKey
)
{
    HRESULT   hr = S_OK;
    ISortKey *piSortKey = NULL;
    CSortKey *pSortKey = NULL;
    long      lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<ISortKey, SortKey, ISortKeys>::Add(Index, Key, &piSortKey);
    IfFailGo(hr);

    if (ISPRESENT(Column))
    {
        hr = ::VariantChangeType(&varCoerced, &Column, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_Column(varCoerced.lVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(SortOrder))
    {
        hr = ::VariantChangeType(&varCoerced, &SortOrder, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_SortOrder(static_cast<SnapInSortOrderConstants>(varCoerced.lVal)));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(SortIcon))
    {
        hr = ::VariantChangeType(&varCoerced, &SortIcon, 0, VT_BOOL);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_SortIcon(varCoerced.boolVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    *ppSortKey = reinterpret_cast<SortKey *>(piSortKey);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piSortKey);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


STDMETHODIMP CSortKeys::Persist()
{
    HRESULT        hr = S_OK;
    IColumnData   *piColumnData = NULL; // Not AddRef()ed
    long           i = 0;
    long           cSortKeys = 0;
    MMC_SORT_DATA *pSortData;
    CSortKey      *pSortKey = NULL;
    SColumnSetID  *pSColumnSetID = NULL;

    MMC_SORT_SET_DATA SortSetData;
    ::ZeroMemory(&SortSetData, sizeof(SortSetData));

    if (NULL == m_pView)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    piColumnData = m_pView->GetIColumnData();
    if (NULL == piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::GetColumnSetID(m_bstrColumnSetID, &pSColumnSetID));

    SortSetData.cbSize = sizeof(SortSetData);
    cSortKeys = GetCount();

    if (0 == cSortKeys)
    {
        SortSetData.nNumItems = 0;
        SortSetData.pSortData = NULL;
    }
    else
    {
        SortSetData.nNumItems = static_cast<int>(cSortKeys);
        SortSetData.pSortData = (MMC_SORT_DATA *)CtlAllocZero(cSortKeys * sizeof(MMC_SORT_DATA));
        if (NULL == SortSetData.pSortData)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        for (i = 0, pSortData = SortSetData.pSortData;
             i < cSortKeys;
             i++, pSortData++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                           &pSortKey));
            if (siDescending == pSortKey->GetSortOrder())
            {
                pSortData->dwSortOptions = RSI_DESCENDING;
            }

            if (VARIANT_FALSE == pSortKey->GetSortIcon())
            {
                pSortData->dwSortOptions |= RSI_NOSORTICON;
            }
            pSortData->nColIndex = static_cast<int>(pSortKey->GetColumn() - 1L);
        }
    }

    hr = piColumnData->SetColumnSortData(pSColumnSetID, &SortSetData);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }
    if (NULL != SortSetData.pSortData)
    {
        CtlFree(SortSetData.pSortData);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSortKeys::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_ISortKeys == riid)
    {
        *ppvObjOut = static_cast<ISortKeys *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ISortKey, SortKey, ISortKeys>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapindef.cpp ===
//=--------------------------------------------------------------------------=
// snapindef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapindef.h"

// for ASSERT and FAIL
//
SZTHISFILE



const GUID *CSnapInDef::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_SnapInDefGeneralPP,
    &CLSID_SnapInDefImageListPP,
    // &CLSID_SnapInDefExtensionsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDef::CSnapInDef(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPINDEF,
                           static_cast<ISnapInDef *>(this),
                           static_cast<CSnapInDef *>(this),
                           sizeof(m_rgpPropertyPageCLSIDs) /
                               sizeof(m_rgpPropertyPageCLSIDs[0]),
                           m_rgpPropertyPageCLSIDs,
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_SnapInDef,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSnapInDef::~CSnapInDef()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrHelpFile);
    FREESTRING(m_bstrLinkedTopics);
    FREESTRING(m_bstrDescription);
    FREESTRING(m_bstrProvider);
    FREESTRING(m_bstrVersion);
    RELEASE(m_piSmallFolders);
    RELEASE(m_piSmallFoldersOpen);
    RELEASE(m_piLargeFolders);
    RELEASE(m_piIcon);
    RELEASE(m_piWatermark);
    RELEASE(m_piHeader);
    RELEASE(m_piPalette);
    (void)::VariantClear(&m_varStaticFolder);
    FREESTRING(m_bstrSmallFoldersKey);
    FREESTRING(m_bstrSmallFoldersOpenKey);
    FREESTRING(m_bstrLargeFoldersKey);
    FREESTRING(m_bstrDefaultView);
    RELEASE(m_piViewDefs);
    RELEASE(m_piChildren);
    FREESTRING(m_bstrIID);
    InitMemberVariables();
}

void CSnapInDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_Type = siStandAlone;
    m_bstrHelpFile = NULL;
    m_bstrLinkedTopics = NULL;
    m_bstrDescription = NULL;
    m_bstrProvider = NULL;
    m_bstrVersion = NULL;
    m_piSmallFolders = NULL;
    m_piSmallFoldersOpen = NULL;
    m_piLargeFolders = NULL;
    m_piIcon = NULL;
    m_piWatermark = NULL;
    m_piHeader = NULL;
    m_piPalette = NULL;
    m_StretchWatermark = VARIANT_FALSE;

    ::VariantInit(&m_varStaticFolder);

    m_bstrSmallFoldersKey= NULL;
    m_bstrSmallFoldersOpenKey= NULL;
    m_bstrLargeFoldersKey= NULL;
    m_bstrDefaultView = NULL;
    m_Extensible = VARIANT_TRUE;
    m_piViewDefs = NULL;
    m_piChildren = NULL;
    m_bstrIID = NULL;
    m_Preload = VARIANT_FALSE;
}



IUnknown *CSnapInDef::Create(IUnknown * punkOuter)
{
    CSnapInDef *pSnapInDef = New CSnapInDef(punkOuter);
    if (NULL == pSnapInDef)
    {
        return NULL;
    }
    else
    {
        return pSnapInDef->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
//                       ISnapInDef Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDef::get_SmallFolders(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrSmallFoldersKey, &m_piSmallFolders));
}

STDMETHODIMP CSnapInDef::putref_SmallFolders(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrSmallFoldersKey, &m_piSmallFolders));
}


STDMETHODIMP CSnapInDef::get_SmallFoldersOpen(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrSmallFoldersOpenKey, &m_piSmallFoldersOpen));
}

STDMETHODIMP CSnapInDef::putref_SmallFoldersOpen(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrSmallFoldersOpenKey, &m_piSmallFoldersOpen));
}


STDMETHODIMP CSnapInDef::get_LargeFolders(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrLargeFoldersKey, &m_piLargeFolders));
}

STDMETHODIMP CSnapInDef::putref_LargeFolders(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrLargeFoldersKey, &m_piLargeFolders));
}


STDMETHODIMP CSnapInDef::putref_Icon(IPictureDisp *piIcon)
{
    HRESULT   hr = S_OK;
    IPicture *piPicture = NULL;
    short     PictureType = PICTYPE_UNINITIALIZED;

    if (NULL == piIcon)
    {
        hr = SID_E_CANT_DELETE_ICON;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piIcon->QueryInterface(IID_IPicture,
                                    reinterpret_cast<void **>(&piPicture)));

    IfFailGo(piPicture->get_Type(&PictureType));

    if (PICTYPE_ICON != PictureType)
    {
        hr = SID_E_ICON_REQUIRED;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(SetObject(piIcon, IID_IPictureDisp, &m_piIcon,
                       DISPID_SNAPINDEF_ICON));

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


STDMETHODIMP CSnapInDef::put_StaticFolder(VARIANT varFolder)
{
    HRESULT hr = S_OK;
    long    lFolder = 0;

    // This property can be entered in the property browser at design time.
    // Its default value is an empty string. If the user types in a number
    // then VB will convert it to a string. If the user does not use the
    // same number as the key of the image, then the runtime won't find the
    // image. To prevent this, we check if the property is a string, and if so,
    // then we check if it is only digits. If it is only digits then we convert
    // it to VT_I4.

    if (VT_BSTR == varFolder.vt)
    {
        hr = ::ConvertToLong(varFolder, &lFolder);
        if (S_OK == hr)
        {
            varFolder.vt = VT_I4;
            varFolder.lVal = lFolder;
        }
    }
    IfFailGo(SetVariant(varFolder, &m_varStaticFolder, DISPID_SNAPINDEF_STATIC_FOLDER));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                 IPerPropertyBrowsing Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDef::GetDisplayString(DISPID dispID, BSTR *pBstr)
{
    *pBstr = NULL;
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::MapPropertyToPage(DISPID dispID, CLSID *pClsid)
{
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::GetPredefinedStrings
(
    DISPID      dispID,
    CALPOLESTR *pCaStringsOut,
    CADWORD    *pCaCookiesOut
)
{
    // Initialize structures because VB doesn't always pass them in intialized

    if (NULL != pCaStringsOut)
    {
        pCaStringsOut->cElems = 0;
        pCaStringsOut->pElems = NULL;
    }

    if (NULL != pCaCookiesOut)
    {
        pCaCookiesOut->cElems = 0;
        pCaCookiesOut->pElems = NULL;
    }
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::GetPredefinedValue
(
    DISPID   dispID,
    DWORD    dwCookie,
    VARIANT *pVarOut
)
{
    ::VariantInit(pVarOut);
    return E_NOTIMPL;
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::Persist()
{
    HRESULT hr = S_OK;
    GUID    NodeTypeGUID = GUID_NULL;
    HICON   hiconDefault = NULL;

    WCHAR   wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    VARIANT varIndexDefault;
    ::VariantInit(&varIndexDefault);

    varIndexDefault.vt = VT_I4;
    varIndexDefault.lVal = 0;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    // On InitNew generate a node type GUID

    if (InitNewing())
    {
        hr = ::CoCreateGuid(&NodeTypeGUID);
        EXCEPTION_CHECK_GO(hr);
        if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                   sizeof(wszNodeTypeGUID) /
                                   sizeof(wszNodeTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, wszNodeTypeGUID, OLESTR("NodeTypeGUID")));

    // If this is a project being loaded from a template then NodeTypeGUID will
    // be all zeroes. We use this is as a flag to indicate that a new GUID needs
    // to be created.

    if (Loading())
    {
        hr = ::CLSIDFromString(m_bstrNodeTypeGUID, &NodeTypeGUID);
        EXCEPTION_CHECK_GO(hr);
        if (GUID_NULL == NodeTypeGUID)
        {
            hr = ::CoCreateGuid(&NodeTypeGUID);
            EXCEPTION_CHECK_GO(hr);
            if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                       sizeof(wszNodeTypeGUID) /
                                       sizeof(wszNodeTypeGUID[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            FREESTRING(m_bstrNodeTypeGUID);
            m_bstrNodeTypeGUID = ::SysAllocString(wszNodeTypeGUID);
            if (NULL == m_bstrNodeTypeGUID)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailGo(PersistSimpleType(&m_Type, siStandAlone, OLESTR("Type")));

    IfFailGo(PersistBstr(&m_bstrHelpFile, L"", OLESTR("HelpFile")));

    // If we are loading from a persistence version < 0,2 then skip LinkedTopics

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 2) )
    {
    }
    else
    {
        IfFailGo(PersistBstr(&m_bstrLinkedTopics, L"", OLESTR("LinkedTopics")));
    }

    IfFailGo(PersistBstr(&m_bstrDescription, L"", OLESTR("Description")));

    IfFailGo(PersistBstr(&m_bstrProvider, L"", OLESTR("Provider")));

    IfFailGo(PersistBstr(&m_bstrVersion, L"", OLESTR("Version")));

    IfFailGo(PersistBstr(&m_bstrSmallFoldersKey, L"", OLESTR("SmallFolders")));

    if (InitNewing())
    {
        RELEASE(m_piSmallFolders);
    }

    IfFailGo(PersistBstr(&m_bstrSmallFoldersOpenKey, L"", OLESTR("SmallFoldersOpen")));

    if (InitNewing())
    {
        RELEASE(m_piSmallFoldersOpen);
    }

    IfFailGo(PersistBstr(&m_bstrLargeFoldersKey, L"", OLESTR("LargeFolders")));

    if (InitNewing())
    {
        RELEASE(m_piLargeFolders);
    }

    if (InitNewing())
    {
        // For a new snap-in use the MMC icon as the default
        hiconDefault = ::LoadIcon(GetResourceHandle(),
                                  MAKEINTRESOURCE(IDI_ICON_DEFAULT));
        if (NULL == hiconDefault)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(::CreateIconPicture(&m_piIcon, hiconDefault));
        // Note that if we could not create the picture there is no need
        // to call ::DestroyIcon() as icons loaded from a resource are
        // not explicitly destoryed
    }
    else
    {
        IfFailRet(PersistPicture(&m_piIcon, OLESTR("Icon")));
    }

    if ( (Loading()) && (0 == GetMinorVersion()) && (0 == GetMajorVersion()) )
    {
        // Version 0.0 did not yet have watermarks so don't try to load them.
        // In this case we need to create empty pictures for the new properties.

        IfFailGo(::CreateEmptyBitmapPicture(&m_piWatermark));
        IfFailGo(::CreateEmptyBitmapPicture(&m_piHeader));
        IfFailGo(::CreateEmptyBitmapPicture(&m_piPalette));
    }
    else
    {
        IfFailRet(PersistPicture(&m_piWatermark, OLESTR("Watermark")));

        IfFailRet(PersistPicture(&m_piHeader, OLESTR("Header")));

        IfFailRet(PersistPicture(&m_piPalette, OLESTR("Palette")));

        IfFailGo(PersistSimpleType(&m_StretchWatermark, VARIANT_FALSE, OLESTR("StretchWatermark")));
    }

    IfFailGo(PersistVariant(&m_varStaticFolder, varIndexDefault, OLESTR("StaticFolder")));

    IfFailGo(PersistBstr(&m_bstrDefaultView, L"", OLESTR("DefaultView")));

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                           OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                           OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_ScopeItemDefs,
                           OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                           OLESTR("Children")));

    IfFailGo(PersistBstr(&m_bstrIID, L"", OLESTR("IID")));

    IfFailGo(PersistSimpleType(&m_Preload, VARIANT_FALSE, OLESTR("Preload")));

    // Tell ViewDefs that all collections should serialize keys only as the
    // actual objects are stored in the master collections owned by
    // SnapInDesignerDef. We only need to serialize the view names.

    if (InitNewing())
    {
        IfFailGo(UseKeysOnly(m_piViewDefs));
    }

Error:
   RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISnapInDef == riid)
    {
        *ppvObjOut = static_cast<ISnapInDef *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPerPropertyBrowsing == riid)
    {
        *ppvObjOut = static_cast<IPerPropertyBrowsing *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piChildren));
    IfFailRet(SetObjectHost(m_piViewDefs));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapin.cpp ===
//=--------------------------------------------------------------------------=
// snapin.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapIn class implementation
//
//=--------------------------------------------------------------------------=


// Need to define this because vb98ctls\include\debug.h has a switch that
// removes OutputDebugString calls in a release build. SnapIn.Trace needs
// to use OutputDebugString in a release build.

#define USE_OUTPUTDEBUGSTRING_IN_RETAIL

#include "pch.h"
#include "common.h"
#include <wininet.h>
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "view.h"
#include "scopnode.h"
#include "image.h"
#include "images.h"
#include "imglists.h"
#include "imglist.h"
#include "toolbars.h"
#include "toolbar.h"
#include "menu.h"
#include "menus.h"
#include "ctlbar.h"
#include "enumtask.h"
#include "clipbord.h"
#include "scitdefs.h"
#include "scitdef.h"
#include "lvdefs.h"
#include "lvdef.h"
#include "sidesdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

// Event parameter definitions
   
EVENTINFO CSnapIn::m_eiLoad =
{
    DISPID_SNAPIN_EVENT_LOAD,
    0,
    NULL
};

EVENTINFO CSnapIn::m_eiUnload =
{
    DISPID_SNAPIN_EVENT_UNLOAD,
    0,
    NULL
};


EVENTINFO CSnapIn::m_eiHelp =
{
    DISPID_SNAPIN_EVENT_HELP,
    0,
    NULL
};

VARTYPE CSnapIn::m_rgvtQueryConfigurationWizard[1] =
{
    VT_BYREF | VT_BOOL
};

EVENTINFO CSnapIn::m_eiQueryConfigurationWizard =
{
    DISPID_SNAPIN_EVENT_QUERY_CONFIGURATION_WIZARD,
    sizeof(m_rgvtQueryConfigurationWizard) / sizeof(m_rgvtQueryConfigurationWizard[0]),
    m_rgvtQueryConfigurationWizard
};


VARTYPE CSnapIn::m_rgvtCreateConfigurationWizard[1] =
{
    VT_UNKNOWN
};

EVENTINFO CSnapIn::m_eiCreateConfigurationWizard =
{
    DISPID_SNAPIN_EVENT_CREATE_CONFIGURATION_WIZARD,
    sizeof(m_rgvtCreateConfigurationWizard) / sizeof(m_rgvtCreateConfigurationWizard[0]),
    m_rgvtCreateConfigurationWizard
};



VARTYPE CSnapIn::m_rgvtConfigurationComplete[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiConfigurationComplete =
{
    DISPID_SNAPIN_EVENT_CONFIGURATION_COMPLETE,
    sizeof(m_rgvtConfigurationComplete) / sizeof(m_rgvtConfigurationComplete[0]),
    m_rgvtConfigurationComplete
};


VARTYPE CSnapIn::m_rgvtWriteProperties[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiWriteProperties =
{
    DISPID_SNAPIN_EVENT_WRITE_PROPERTIES,
    sizeof(m_rgvtWriteProperties) / sizeof(m_rgvtWriteProperties[0]),
    m_rgvtWriteProperties
};


VARTYPE CSnapIn::m_rgvtReadProperties[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiReadProperties =
{
    DISPID_SNAPIN_EVENT_READ_PROPERTIES,
    sizeof(m_rgvtReadProperties) / sizeof(m_rgvtReadProperties[0]),
    m_rgvtReadProperties
};


EVENTINFO CSnapIn::m_eiPreload =
{
    DISPID_SNAPIN_EVENT_PRELOAD,
    0,
    NULL
};


// UNDONE: need to support GetIDsOfNames for dynamic properties in case
// VB code passes Me to another object as Object. In that case static properties
// would work but accessing a dynamic would give "object doesn't support that
// property or method".

#pragma warning(disable:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CSnapIn constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkOuter [in] Outer unknown for aggregation
//
// Output:
//    None
//
// Notes:
//
CSnapIn::CSnapIn(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPIN,
                           static_cast<ISnapIn *>(this),
                           static_cast<CSnapIn *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CSnapIn destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
// Free all strings, release all interfaces
//
CSnapIn::~CSnapIn()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrHelpFile);
    FREESTRING(m_bstrLinkedTopics);
    FREESTRING(m_bstrDescription);
    FREESTRING(m_bstrProvider);
    FREESTRING(m_bstrVersion);
    RELEASE(m_piSmallFolders);
    RELEASE(m_piSmallFoldersOpen);
    RELEASE(m_piLargeFolders);
    RELEASE(m_piIcon);
    RELEASE(m_piWatermark);
    RELEASE(m_piHeader);
    RELEASE(m_piPalette);
    (void)::VariantClear(&m_varStaticFolder);
    RELEASE(m_piScopeItems);
    RELEASE(m_piViews);
    RELEASE(m_piExtensionSnapIn);
    RELEASE(m_piScopePaneItems);
    RELEASE(m_piResultViews);
    RELEASE(m_piRequiredExtensions);
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
    RELEASE(m_piOleClientSite);
    RELEASE(m_piMMCStringTable);

    if (NULL != m_pControlbar)
    {
        m_pControlbar->Release();
    }

    if (NULL != m_pContextMenu)
    {
        m_pContextMenu->Release();
    }

    if (NULL != m_pwszMMCEXEPath)
    {
        CtlFree(m_pwszMMCEXEPath);
    }

    if (NULL != m_pwszSnapInPath)
    {
        CtlFree(m_pwszSnapInPath);
    }
    if (NULL != m_pszMMCCommandLine)
    {
        CtlFree(m_pszMMCCommandLine);
    }
    ReleaseConsoleInterfaces();
    InitMemberVariables();
}

//=--------------------------------------------------------------------------=
// CSnapIn::ReleaseConsoleInterfaces
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
// Release all MMC interface pointers
//
void CSnapIn::ReleaseConsoleInterfaces()
{
    RELEASE(m_piConsole2);
    RELEASE(m_piConsoleNameSpace2);
    RELEASE(m_piImageList);
    RELEASE(m_piDisplayHelp);
    RELEASE(m_piStringTable);
}


//=--------------------------------------------------------------------------=
// CSnapIn::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
//
void CSnapIn::InitMemberVariables()
{
    m_bstrName = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_Type = siStandAlone;
    m_bstrHelpFile = NULL;
    m_bstrLinkedTopics = NULL;
    m_bstrDescription = NULL;
    m_bstrProvider = NULL;
    m_bstrVersion = NULL;
    m_piSmallFolders = NULL;
    m_piSmallFoldersOpen = NULL;
    m_piLargeFolders = NULL;
    m_piIcon = NULL;
    m_piWatermark = NULL;
    m_piHeader = NULL;
    m_piPalette = NULL;
    m_StretchWatermark = VARIANT_FALSE;
    ::VariantInit(&m_varStaticFolder);

    m_piScopeItems = NULL;
    m_piViews = NULL;
    m_piExtensionSnapIn = NULL;
    m_piScopePaneItems = NULL;
    m_piResultViews = NULL;
    m_RuntimeMode = siRTUnknown;
    m_piRequiredExtensions = NULL;
    m_Preload = VARIANT_FALSE;
    m_piSnapInDesignerDef = NULL;
    m_piSnapInDef = NULL;
    m_piOleClientSite = NULL;
    m_pScopeItems = NULL;
    m_pStaticNodeScopeItem = NULL;
    m_pExtensionSnapIn = NULL;
    m_pViews = NULL;
    m_pCurrentView = NULL;
    m_pScopePaneItems = NULL;
    m_pResultViews = NULL;
    m_piConsole2 = NULL;
    m_piConsoleNameSpace2 = NULL;
    m_piImageList = NULL;
    m_piDisplayHelp = NULL;
    m_piStringTable = NULL;
    m_hsiRootNode = NULL;
    m_fHaveStaticNodeHandle = FALSE;
    m_dwTypeinfoCookie = 0;
    m_cImages = 0;
    m_IID = IID_NULL;
    m_pControlbar = NULL;
    m_pContextMenu = NULL;
    m_fWeAreRemote = FALSE;
    ::ZeroMemory(m_szMMCEXEPath, sizeof(m_szMMCEXEPath));
    m_pwszMMCEXEPath = NULL;
    m_pwszSnapInPath = NULL;
    m_cbSnapInPath = 0;
    m_dwInstanceID = ::GetTickCount();
    m_iNextExtension = 0;
    m_piMMCStringTable = NULL;
    m_pControlbarCurrent = NULL;
    m_pszMMCCommandLine = NULL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Create
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkOuter [in] Outer unknown for aggregation
//
// Output:
//    IUnknown * on newly created CSnapIn object
//
// Notes:
//
// Called by the framework when the VB runtime CoCreates a snap-in. Creates
// a CSnapIn object and then all contained objects. Registers MMC clipformats.
//
IUnknown *CSnapIn::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkSnapIn = NULL;
    IUnknown *punk = NULL;

    CSnapIn *pSnapIn = New CSnapIn(punkOuter);

    IfFalseGo(NULL != pSnapIn, SID_E_OUTOFMEMORY);
    punkSnapIn = pSnapIn->PrivateUnknown();

    // Create contained objects
    punk = CViews::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IViews,
                               reinterpret_cast<void **>(&pSnapIn->m_piViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pViews));
    RELEASE(punk);

    punk = CScopeItems::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IScopeItems,
                          reinterpret_cast<void **>(&pSnapIn->m_piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pScopeItems));
    pSnapIn->m_pScopeItems->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CScopePaneItems::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IScopePaneItems,
                      reinterpret_cast<void **>(&pSnapIn->m_piScopePaneItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pScopePaneItems));
    pSnapIn->m_pScopePaneItems->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CResultViews::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IResultViews,
                                  reinterpret_cast<void **>(&pSnapIn->m_piResultViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pResultViews));
    pSnapIn->m_pResultViews->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CExtensionSnapIn::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IExtensionSnapIn,
                                  reinterpret_cast<void **>(&pSnapIn->m_piExtensionSnapIn)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pExtensionSnapIn));
    pSnapIn->m_pExtensionSnapIn->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CControlbar::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pControlbar));
    pSnapIn->m_pControlbar->SetSnapIn(pSnapIn);
    punk = NULL;

    punk = CContextMenu::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pContextMenu));
    pSnapIn->m_pContextMenu->SetSnapIn(pSnapIn);
    punk = NULL;

    // Make sure we have all clipboard formats so that all code can use them
    // freely without having to check if registration succeded.

    IfFailGo(CMMCDataObject::RegisterClipboardFormats());

Error:
    QUICK_RELEASE(punk);
    if (FAILED(hr))
    {
        RELEASE(punkSnapIn);
    }
    return punkSnapIn;
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to set object model host
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::SetObjectModelHost(IUnknown *punkObject)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));

    IfFailGo(piObjectModel->SetHost(static_cast<IObjectModelHost *>(this)));

Error:
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetObjectModelHostIfNotSet
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to set object model host
//    BOOL     *pfWasSet   [out] Returns flag indicating if object model host
//                               was already set
//
// Output:
//    HRESULT
//
// Notes:
//
// Checks whether the object already has the objet mode host, and if not then
// sets it.
//
HRESULT CSnapIn::SetObjectModelHostIfNotSet(IUnknown *punkObject, BOOL *pfWasSet)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    *pfWasSet = FALSE;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));

    if (SUCCEEDED(piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef)))
    {
        *pfWasSet = TRUE;
    }
    else
    {
        IfFailGo(piObjectModel->SetHost(static_cast<IObjectModelHost *>(this)));
    }

Error:
    QUICK_RELEASE(piObjectModel);
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::RemoveObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to remove object model host
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::RemoveObjectModelHost(IUnknown *punkObject)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                        reinterpret_cast<void **>(&piObjectModel)));

    IfFailGo(piObjectModel->SetHost(NULL));

Error:
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetSnapInPropertiesFromState
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
//
// Sets snap-in properties from design time state
//
HRESULT CSnapIn::SetSnapInPropertiesFromState()
{
    HRESULT       hr = S_OK;
    unsigned long ulTICookie = 0;
    BSTR          bstrIID = NULL;

    IfFailGo(m_piSnapInDef->get_Name(&m_bstrName));
    IfFailGo(m_piSnapInDef->get_NodeTypeName(&m_bstrNodeTypeName));
    IfFailGo(m_piSnapInDef->get_NodeTypeGUID(&m_bstrNodeTypeGUID));
    IfFailGo(m_piSnapInDef->get_DisplayName(&m_bstrDisplayName));
    IfFailGo(m_piSnapInDef->get_Type(&m_Type));
    IfFailGo(m_piSnapInDef->get_HelpFile(&m_bstrHelpFile));
    IfFailGo(m_piSnapInDef->get_LinkedTopics(&m_bstrLinkedTopics));
    IfFailGo(m_piSnapInDef->get_Description(&m_bstrDescription));
    IfFailGo(m_piSnapInDef->get_Provider(&m_bstrProvider));
    IfFailGo(m_piSnapInDef->get_Version(&m_bstrVersion));

    IfFailGo(m_piSnapInDef->get_SmallFolders(&m_piSmallFolders));
    IfFailGo(m_piSnapInDef->get_SmallFoldersOpen(&m_piSmallFoldersOpen));
    IfFailGo(m_piSnapInDef->get_LargeFolders(&m_piLargeFolders));

    IfFailGo(m_piSnapInDef->get_Icon(&m_piIcon));
    IfFailGo(m_piSnapInDef->get_Watermark(&m_piWatermark));
    IfFailGo(m_piSnapInDef->get_Header(&m_piHeader));
    IfFailGo(m_piSnapInDef->get_Palette(&m_piPalette));
    IfFailGo(m_piSnapInDef->get_StretchWatermark(&m_StretchWatermark));
    IfFailGo(m_piSnapInDef->get_StaticFolder(&m_varStaticFolder));
    IfFailGo(m_piSnapInDef->get_Preload(&m_Preload));

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.

    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    m_dwTypeinfoCookie = static_cast<DWORD>(ulTICookie);

    // Get the dynamic IID created in the snap-in's type info.

    IfFailGo(m_piSnapInDef->get_IID(&bstrIID));
    hr = ::CLSIDFromString(bstrIID, static_cast<LPCLSID>(&m_IID));
    EXCEPTION_CHECK_GO(hr);

Error:
    FREESTRING(bstrIID);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapInPath
//=--------------------------------------------------------------------------=
//
// Parameters:
//    OLECHAR **ppwszPath     [out] ptr to full path of snap-in DLL. Caller
//                                  should not free this memory
//    size_t   *pcbSnapInPath [out] length of path in bytes, without terminating
//                                  NULL character
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::GetSnapInPath
(
    OLECHAR **ppwszPath,
    size_t   *pcbSnapInPath
)
{
    HRESULT  hr = S_OK;
    size_t   cbClsid = 0;
    char     szKeySuffix[256] = "";
    char     szPath[MAX_PATH] = "";
    DWORD    cbPath = sizeof(szPath);
    char    *pszKeyName = NULL;
    long     lRc = ERROR_SUCCESS;
    HKEY     hkey = NULL;

    static char   szClsidKey[] = "CLSID\\";
    static size_t cbClsidKey = sizeof(szClsidKey) - 1;

    static char   szInProcServer32[] = "\\InProcServer32";
    static size_t cbInProcServer32 = sizeof(szInProcServer32);

    // If we already got the snap-in path then just return it

    IfFalseGo(NULL == m_pwszSnapInPath, S_OK);

    // Get the snap-in's CLSID

    IfFailGo(::GetSnapInCLSID(m_bstrNodeTypeGUID,
                              szKeySuffix,
                              sizeof(szKeySuffix)));

    // Append "\InProcServer32". First ensure that there is enough room.

    cbClsid = ::strlen(szKeySuffix);

    if ( (cbClsid + cbInProcServer32) > sizeof(szKeySuffix) )
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Append it and then create the complete key name.
    
    ::memcpy(&szKeySuffix[cbClsid], szInProcServer32, cbInProcServer32);

    // Open HKEY_CLASSES_ROOT\CLSID\<snap-in clsid>\InProcServer32 and read its
    // default value which contains the full path to the snap-in.

    IfFailGo(::CreateKeyName(szClsidKey, cbClsidKey,
                             szKeySuffix, ::strlen(szKeySuffix),
                             &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, pszKeyName, 0, KEY_QUERY_VALUE, &hkey);
    if (ERROR_SUCCESS == lRc)
    {
        // Read the key's default value
        lRc = ::RegQueryValueEx(hkey, NULL, NULL, NULL,
                                (LPBYTE)szPath, &cbPath);
    }
    if (ERROR_SUCCESS != lRc)
    {
        hr = HRESULT_FROM_WIN32(lRc);
        EXCEPTION_CHECK_GO(hr);
    }
    else if (0 == ::strlen(szPath))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::WideStrFromANSI(szPath, &m_pwszSnapInPath));
    m_cbSnapInPath = ::wcslen(m_pwszSnapInPath) * sizeof(OLECHAR);

Error:
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }
    *ppwszPath = m_pwszSnapInPath;
    *pcbSnapInPath = m_cbSnapInPath;
    RRETURN(hr);
}






//=--------------------------------------------------------------------------=
// CSnapIn::ResolveResURL
//=--------------------------------------------------------------------------=
//
// Parameters:
//      WCHAR    *pwszURL          [in] URL to be resolved
//      OLECHAR **ppwszResolvedURL [in] fully qualified URL
//
// Output:
//      HRESULT
//
// Notes:
//
// If the URL begins with any protocol specifier (e.g. http:// or res://) then
// it is copied as except for the special case of res://mmc.exe/. Anything that
// starts with the unqualified path to mmc.exe ("res://mmc.exe/") is resolved to
// the full path of mmc.exe in which the snap-in is running by calling
// GetModulesFileName(NULL). This is done to allow snap-ins to use resources
// supplied by MMC such as the GLYPH100 and GLYPH110 fonts. For example, the
// snap-in can specify "res://mmc.exe/glyph100.eot" and it will be resolved to
// "res://<full path>/mmc.exe/glyph100.eot".
//
// If a URL does not begin with a protocol specifier then a res:// URL is
// constructed using the complete path to the snap-in's DLL.
//
// 
// Returned URL is allocated with CoTaskMemAlloc(). Caller must free it.
//

HRESULT CSnapIn::ResolveResURL(WCHAR *pwszURL, OLECHAR **ppwszResolvedURL)
{
    HRESULT  hr = S_OK;
    char    *pszURL = NULL;
    OLECHAR *pwszResolvedURL = NULL;
    OLECHAR *pwszPath = NULL; // not allocated, no need to free
    size_t   cbPath = 0;
    size_t   cbURL = 0;
    BOOL     fUseMMCPath = FALSE;

    URL_COMPONENTS UrlComponents;
    ::ZeroMemory(&UrlComponents, sizeof(UrlComponents));

    static OLECHAR wszRes[] = L"res://";
    static size_t  cbRes = sizeof(wszRes) - sizeof(WCHAR);

    static OLECHAR wszMMCRes[] = L"res://mmc.exe/";
    static size_t  cchMMCRes = (sizeof(wszMMCRes) - sizeof(WCHAR)) / sizeof(WCHAR);

    // Check if it starts with letters followed by ://

    // Get the URL length

    cbURL = (::wcslen(pwszURL) + 1) * sizeof(WCHAR); // includes null character

    // Crack it - request only a pointer to the scheme

    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.dwSchemeLength = static_cast<DWORD>(1);

    // Need an ANSI version of the URL.
    IfFailGo(::ANSIFromWideStr(pwszURL, &pszURL));

    if (::InternetCrackUrl(pszURL,
                            static_cast<DWORD>(::strlen(pszURL)),
                            0, // no flags
                            &UrlComponents))
    {
        if (NULL != UrlComponents.lpszScheme)
        {
            // The API found a scheme. If it is not res:// then just copy it
            // and return it unchanged.

            if (pwszURL != ::wcsstr(pwszURL, wszRes))
            {
                IfFailGo(::CoTaskMemAllocString(pwszURL, &pwszResolvedURL));
                goto Cleanup;
            }
        }
    }

    // Either there's no scheme or there is a res://. The API doesn't recognize
    // res:// when IE4 is installed so we need to check for it.

    if (cbURL > cbRes) // check > because cbURL includes null and cbRes doesn't
    {
        if (0 == ::memcmp(pwszURL, wszRes, cbRes))
        {
            // Does the URL start with "res://mmc.exe/"?
            if (pwszURL == ::wcsstr(pwszURL, wszMMCRes))
            {
                fUseMMCPath = TRUE;
                pwszURL += cchMMCRes;
            }
            else
            {
                // It starts with res::// and it does not reference mmc.exe so
                // just copy it.
                IfFailGo(::CoTaskMemAllocString(pwszURL, &pwszResolvedURL));
                goto Cleanup;
            }
        }
    }

    // No scheme, assume it's a relative URL. Need to build a res:// URL.
    // First, get the path.

    if (fUseMMCPath)
    {
        IfFalseGo(NULL != m_pwszMMCEXEPath, SID_E_INTERNAL);
        pwszPath = m_pwszMMCEXEPath;
        cbPath = m_cbMMCExePathW;
    }
    else
    {
        IfFailGo(GetSnapInPath(&pwszPath, &cbPath));
    }

    // Allocate the buffer.

    pwszResolvedURL = (OLECHAR *)::CoTaskMemAlloc(cbRes +
                                                  cbPath +
                                                  sizeof(WCHAR) + // for slash
                                                  cbURL);
    if (NULL == pwszResolvedURL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Concatenate the pieces: res://, snap-in path, slash, and relative url
    // e.g. "res://c:\MyProject\MySnapIn.dll/#2/MyMouseOverBitmap"

    ::memcpy(pwszResolvedURL, wszRes, cbRes);

    ::memcpy(((BYTE *)pwszResolvedURL) + cbRes, pwszPath, cbPath);

    *(OLECHAR *)(((BYTE *)pwszResolvedURL) + cbRes + cbPath) = L'/';
    

    // Fix for Ntbug9#141998 - Yojain
    cbURL = (::wcslen(pwszURL) + 1) * sizeof(WCHAR); // includes null character


    ::memcpy(((BYTE *)pwszResolvedURL) + cbRes + cbPath + sizeof(WCHAR),
            pwszURL, cbURL);

    *ppwszResolvedURL = pwszResolvedURL;

Cleanup:
Error:
    if (FAILED(hr))
    {
        *ppwszResolvedURL = NULL;
    }
    else
    {
        *ppwszResolvedURL = pwszResolvedURL;
    }
    if (NULL != pszURL)
    {
        ::CtlFree(pszURL);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnExpand
//=--------------------------------------------------------------------------=
//
// Parameters:
//  ExpandType   Type         [in] Expand or ExpandSync
//  IDataObject *piDataObject [in] IDataObject from notification
//  BOOL         fExpanded    [in] TRUE=expanding, FALSE=collapsing
//  HSCOPEITEM   hsi          [in] HSCOPEITEM of node
//  BOOL        *pfHandled    [out] flag returned here indicating if event was
//                                  handled
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_EXPAND and MMCN_EXPANDSYNC handler for IComponentData::Notify
//

HRESULT CSnapIn::OnExpand
(
    ExpandType   Type,
    IDataObject *piDataObject,
    BOOL         fExpanded,
    HSCOPEITEM   hsi,
    BOOL        *pfHandled
)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;
    IMMCDataObjects *piMMCDataObjects  = NULL;
    IMMCDataObject  *piMMCDataObject  = NULL;
    CScopeItem      *pScopeItem = NULL;
    IScopeNode      *piScopeNode = NULL;
    CScopeNode      *pScopeNode = NULL;
    IScopeItemDefs  *piScopeItemDefs = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IScopeNode      *piScopeNodeFirstChild = NULL;
    BOOL             fNotFromThisSnapIn = FALSE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));


    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Determine who owns the data object. Easiest way is to create an
    // MMCClipboard object with the selection as that code figures out all that
    // stuff.

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, this,
                               &SelectionType));


    // Handle the extension case first as it is simpler

    if (IsForeign(SelectionType))
    {
        // Set runtime mode as we now know that the snap-in was created as a
        // namespace extension.

        m_RuntimeMode = siRTExtension;
        
        // Get the 1st data object from MMCClipboard.DataObjects

        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;
        IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

        // Create a ScopeNode object for the expandee

        IfFailGo(CScopeNode::GetScopeNode(hsi, piDataObject, this, &piScopeNode));

        // Fire ExtensionSnapIn_Expand/Sync or ExtensionSnapIn_Collapse/Sync

        if (fExpanded)
        {
            if (Expand == Type)
            {
                m_pExtensionSnapIn->FireExpand(piMMCDataObject, piScopeNode);
                *pfHandled = TRUE;
            }
            else
            {
                m_pExtensionSnapIn->FireExpandSync(piMMCDataObject, piScopeNode,
                                                   pfHandled);
            }
        }
        else
        {
            if (Expand == Type)
            {
                m_pExtensionSnapIn->FireCollapse(piMMCDataObject, piScopeNode);
                *pfHandled = TRUE;
            }
            else
            {
                m_pExtensionSnapIn->FireCollapseSync(piMMCDataObject, piScopeNode,
                                                     pfHandled);
            }
        }
        goto Cleanup;
    }

    // Its a scope item we own. Get the CMMCDataObject for it.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
    

    if ( CMMCDataObject::ScopeItem == pMMCDataObject->GetType() ) 
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        IfFailGo(pScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

        if (pScopeItem->IsStaticNode())
        {
            IfFailGo(StoreStaticHSI(pScopeItem, pMMCDataObject, hsi));
        }

        // If node is expanding and this is the first time then add any
        // auto-create children

        if (fExpanded)
        {
            // Check whether we have already expanded this node. This could happen
            // in the case where the snap-in did not handle MMCN_EXPANDSYNC and
            // we are coming through here a 2nd time for MMCN_EXPAND on the same
            // node. An important implication here is that the runtime always
            // expands the auto-creates on MMCN_EXPANDSYNC even if the snap-in
            // didn't handle it. Either way, the snap-in always knows that
            // auto-creates have been created before the ScopeItems_Expand or
            // ScopeItems_ExpandSync events are fired.

            // Unfortunately, at this point checking ScopeNode.ExpandedOnce won't
            // help because MMC sets that flag before sending the expand
            // notifications. We also can't check the ScopeNode.Children because
            // MMC doesn't properly support that (it would fail but it will
            // always come back as zero). The only thing left is to try getting
            // the first child of the expanding node. If it is not there then
            // assume it is the first time and add the auto-creates.

            IfFailGo(piScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piScopeNodeFirstChild)));
            if (NULL == piScopeNodeFirstChild)
            {
                if (pScopeItem->IsStaticNode())
                {
                    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
                }
                else
                {
                    if (NULL != pScopeItem->GetScopeItemDef())
                    {
                        IfFailGo(pScopeItem->GetScopeItemDef()->get_Children(&piScopeItemDefs));
                    }
                }
                if (NULL != piScopeItemDefs)
                {
                    IfFailGo(m_pScopeItems->AddAutoCreateChildren(piScopeItemDefs,
                                                                  pScopeItem));
                }
            }
        }

        // Fire the ScopeItems_Expand/Sync or ScopeItems_Collapse/Sync

        if (fExpanded)
        {
            if (Expand == Type)
            {
                m_pScopeItems->FireExpand(pScopeItem);
                *pfHandled = TRUE;
            }
            else
            {
                m_pScopeItems->FireExpandSync(pScopeItem, pfHandled);
            }

            // Check ScopeItem.DynamicExtensions for any that have
            // NameSpaceEnabled=True and call IConsoleNameSpace2::AddExtension
            // for them

            IfFailGo(AddDynamicNameSpaceExtensions(pScopeItem));
        }
        else
        {
            if (Expand == Type)
            {
                m_pScopeItems->FireCollapse(pScopeItem);
                *pfHandled = TRUE;
            }
            else
            {
                m_pScopeItems->FireCollapseSync(pScopeItem, pfHandled);
            }
        }
    }

Cleanup:
Error:
    QUICK_RELEASE(piScopeNode);
    QUICK_RELEASE(piScopeNodeFirstChild);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::StoreStaticHSI
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CScopeItem     *pScopeItem     [in] scope item of static node
//  CMMCDataObject *pMMCDataObject [in] data object of static node
//  HSCOPEITEM      hsi            [in] HSCOPEITEM of static node
//
// Output:
//    HRESULT
//
// Notes:
// Called when the snap-in receives the HSCOPEITEM for the static node.
// See below for processing
//
HRESULT CSnapIn::StoreStaticHSI
(
    CScopeItem     *pScopeItem,
    CMMCDataObject *pMMCDataObject,
    HSCOPEITEM      hsi
)
{
    HRESULT hr = S_OK;

    // We have the static node HSCOPEITEM so we now know that the snap-in was
    // created as primary.

    m_RuntimeMode = siRTPrimary;

    // If this context is scope pane then store the static node handle
    // and set it in the scope node. Also use this opportunity to
    // add any auto-create children to the static node.

    if ( (CCT_SCOPE == pMMCDataObject->GetContext()) &&
         (!m_fHaveStaticNodeHandle) )
    {
        m_hsiRootNode = hsi;
        pScopeItem->GetScopeNode()->SetHSCOPEITEM(hsi);
        IfFailGo(pScopeItem->GiveHSCOPITEMToDynamicExtensions(hsi));
        m_fHaveStaticNodeHandle = TRUE;
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnRename
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of node
//  OLECHAR     *pwszNewName  [in] new name entered by user
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_RENAME handler for rename verb in scope pane (for IComponentData::Notify)
// See below for processing
//
HRESULT CSnapIn::OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BSTR            bstrNewName = NULL;
    CScopeItem     *pScopeItem = NULL;

    // If this is not our data object then ignore it (that should never be
    // the case)
    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    bstrNewName = ::SysAllocString(pwszNewName);
    if (NULL == bstrNewName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // The data object should definitely represent a scope item but we'll double
    // check

    if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        m_pScopeItems->FireRename(static_cast<IScopeItem *>(pScopeItem),
                                  bstrNewName);
    }

Error:
    FREESTRING(bstrNewName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnPreload
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of node
//  HSCOPEITEM   hsi          [in] HSCOPEITEM of static node
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_PRELOAD handler for IComponentData::Notify
// See below for processing
//
HRESULT CSnapIn::OnPreload(IDataObject *piDataObject, HSCOPEITEM hsi)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;

    // The IDataObject should be for our static node so the next lines should
    // always succeed and execute

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));

    if ( (CMMCDataObject::ScopeItem == pMMCDataObject->GetType()) &&
         pMMCDataObject->GetScopeItem()->IsStaticNode() )
    {
        IfFailGo(StoreStaticHSI(pMMCDataObject->GetScopeItem(),
                                pMMCDataObject, hsi));
    }

    // Fire SnapIn_Preload

    DebugPrintf("Firing SnapIn_Preload\r\n");

    FireEvent(&m_eiPreload);
        
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::AddDynamicNameSpaceExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CScopeItem *pScopeItem [in] Scope item for which dynamic namespace extensions
//                              need to be added
//
// Output:
//    HRESULT
//
// Notes:
// Calls IConsoleNameSpace2->AddExtension for all extensions in
// ScopeItem.DynamicExtensions that have NameSpaceEnabled=True
//
HRESULT CSnapIn::AddDynamicNameSpaceExtensions(CScopeItem *pScopeItem)
{
    HRESULT      hr = S_OK;
    IExtensions *piExtensions = NULL; // Not AddRef()ed
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;
    long         cExtensions = 0;
    long         i = 0;
    CLSID        clsid = CLSID_NULL;
    HSCOPEITEM   hsi = pScopeItem->GetScopeNode()->GetHSCOPEITEM();

    // Get ScopeItem.DynamicExtensions. If it is NULL then the user has not
    // populated it and there is nothing to do.

    piExtensions = pScopeItem->GetDynamicExtensions();
    IfFalseGo(NULL != piExtensions, S_OK);

    // If the collection is there but empty then there is still nothing to do.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piExtensions, &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_OK);

    // Iterate through the collection and check for items that have
    // NameSpaceEnabled=True. For each such item call
    // IConsoleNameSpace2::AddExtension()

    for (i = 0; i < cExtensions; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pExtensions->GetItemByIndex(i), &pExtension));

        if (pExtension->NameSpaceEnabled())
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), &clsid);
            EXCEPTION_CHECK_GO(hr);

            hr = m_piConsoleNameSpace2->AddExtension(hsi, &clsid);
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::AddScopeItemImages
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//    HRESULT
//
// Notes:
// 
// Adds images from SnapIn.SmallFolders, SnapIn.SmallFoldersOpen, and
// SnapIn.LargeFolders to scope pane image list.
//
// This only happens once during IComponentData::Initialize. The snap-in cannot
// dynamically add images to the scope pane image list after that time. If a
// snap-in has dynamic images, it must set them in these image lists
// SnapIn_Preload.
//
HRESULT CSnapIn::AddScopeItemImages()
{
    HRESULT     hr = S_OK;
    IMMCImages *piSmallImages = NULL;
    IMMCImages *piSmallOpenImages = NULL;
    IMMCImages *piLargeImages = NULL;
    CMMCImages *pSmallImages = NULL;
    CMMCImages *pSmallOpenImages = NULL;
    CMMCImages *pLargeImages = NULL;
    long        cImages = 0;
    HBITMAP     hbmSmall = NULL;
    HBITMAP     hbmSmallOpen = NULL;
    HBITMAP     hbmLarge = NULL;
    HBITMAP     hbmLargeOpen = NULL;
    OLE_COLOR   OleColorMask = 0;
    COLORREF    ColorRef = RGB(0x00,0x00,0x00);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Make sure that all image lists are set

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(NULL != m_piSmallFoldersOpen, S_OK);
    IfFalseGo(NULL != m_piLargeFolders, S_OK);

    // Get their images collections

    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piSmallImages)));
    IfFailGo(m_piSmallFoldersOpen->get_ListImages(reinterpret_cast<MMCImages **>(&piSmallOpenImages)));
    IfFailGo(m_piLargeFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piLargeImages)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSmallImages, &pSmallImages));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSmallOpenImages, &pSmallOpenImages));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piLargeImages, &pLargeImages));

    // Make sure they contain images and that their counts all match
    // CONSIDER: log an error here if image counts don't match

    cImages = pSmallImages->GetCount();
    IfFalseGo(0 != cImages, S_OK);
    IfFalseGo(cImages == pSmallOpenImages->GetCount(), S_OK);
    IfFalseGo(cImages == pLargeImages->GetCount(), S_OK);
    
    // Use the mask color from SmallFolders. The other choice would have
    // been to add a mask color property to SnapIn which would have been
    // even more redundant.

    IfFailGo(m_piSmallFolders->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));

    // MMC requires a large open bitmap in the SetImageStrip but never actually
    // uses it. The user is not required to supply large open folders at design
    // time so we use a generic one stored in our RC.

    hbmLargeOpen = ::LoadBitmap(GetResourceHandle(),
                                MAKEINTRESOURCE(IDB_BITMAP_LARGE_OPEN_FOLDER));
    if (NULL == hbmLargeOpen)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I4;

    // Now add the images to MMC's image list. To make life easier for the
    // VB developer, they define 3 image lists where the index is the same
    // in each one (small, small open, and large). MMC only has one image list
    // containing both small and large images so we use index + cImages for
    // the open folders. Images are added one at a time because we do not
    // want to combine all the bitmaps into a strip.

    for (varIndex.lVal = 1L; varIndex.lVal <= cImages; varIndex.lVal++)
    {
        IfFailGo(::GetPicture(piSmallImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmSmall)));

        IfFailGo(::GetPicture(piSmallOpenImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmSmallOpen)));

        IfFailGo(::GetPicture(piLargeImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmLarge)));

        IfFailGo(m_piImageList->ImageListSetStrip(
                                              reinterpret_cast<long*>(hbmSmall),
                                              reinterpret_cast<long*>(hbmLarge),
                                              varIndex.lVal,
                                              ColorRef));

        IfFailGo(m_piImageList->ImageListSetStrip(
                                          reinterpret_cast<long*>(hbmSmallOpen),
                                          reinterpret_cast<long*>(hbmLargeOpen),
                                          varIndex.lVal + cImages,
                                          ColorRef));
    }

    // Record the number of images so we can calculate the index when MMC asks
    // for it in IComponentData::GetDisplayInfo() (see CSnapIn::::GetDisplayInfo())

    m_cImages = cImages;

Error:
    if (NULL != hbmLargeOpen)
    {
        (void)::DeleteObject(hbmLargeOpen);
    }
    QUICK_RELEASE(piSmallImages);
    QUICK_RELEASE(piSmallOpenImages);
    QUICK_RELEASE(piLargeImages);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetScopeItemImage
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT varImageIndex [in] Image index or key specified by the snap-in
//  int *pnIndex          [in] Actual index in image list
//
// Output:
//    HRESULT
//
// Notes:
// This function verifies that the specified VARIANT is a valid index or key
// for a scope item image and returns the index.
// VB pseudo code of what it does:
// *pnIndex = SnapIn.SmallFolders(varImageIndex).Index
//
// Using SnapIn.SmallFolders is arbitrary. As snap-ins must have the same
// images in all 3 image lists (SmallFolders, SmallFoldersOpen, and
// LargeFolders), any one is good enough. Techinically, we should check all
// 3 but the perf hit is not worth it.
//
HRESULT CSnapIn::GetScopeItemImage(VARIANT varImageIndex, int *pnIndex)
{
    HRESULT     hr = S_OK;
    IMMCImages *piMMCImages = NULL;
    IMMCImage  *piMMCImage = NULL;
    long        lIndex = 0;

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(VT_EMPTY != varImageIndex.vt, S_OK);
    
    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImages->get_Item(varImageIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(piMMCImage->get_Index(&lIndex));
    *pnIndex = static_cast<int>(lIndex);

Error:
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetScopeItemExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CExtensions    *pExtensions     [in] Extensions collection to populate
//  IScopeItemDefs *piScopeItemDefs [in] Design time node definitions to
//                                       examine for extensibility
//
// Output:
//    HRESULT
//
// Notes:
// Iterates through the ScopeItemDefs collection and all of it children
// recursively. For each node that is extensible, Extension objects are added to
// the Extensions collection for each snap-in that extends the node type.
//
HRESULT CSnapIn::GetScopeItemExtensions
(
    CExtensions    *pExtensions,
    IScopeItemDefs *piScopeItemDefs
)
{
    HRESULT         hr = S_OK;
    CScopeItemDefs *pScopeItemDefs = NULL;
    IScopeItemDefs *piChildren = NULL;
    IScopeItemDef  *piScopeItemDef = NULL; // Not AddRef()ed
    CScopeItemDef  *pScopeItemDef = NULL;
    long            cScopeItemDefs = 0;
    long            i = 0;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
    cScopeItemDefs = pScopeItemDefs->GetCount();
    IfFalseGo(0 != cScopeItemDefs, S_OK);

    // Go through the collection and get the extensions from the registry for
    // each scope item that is marked extensible.

    for (i = 0; i < cScopeItemDefs; i++)
    {
        piScopeItemDef = pScopeItemDefs->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDef,
                                                       &pScopeItemDef));
       if (pScopeItemDef->Extensible())
       {
           IfFailGo(pExtensions->Populate(pScopeItemDef->GetNodeTypeGUID(),
                                          CExtensions::All));
       }

       // Do the same for the scope item's children
       IfFailGo(piScopeItemDef->get_Children(&piChildren));
       IfFailGo(GetScopeItemExtensions(pExtensions, piChildren));
       RELEASE(piChildren);
    }

    
Error:
    QUICK_RELEASE(piChildren);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetListItemExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CExtensions   *pExtensions    [in] Extensions collection to populate
//  IListViewDefs *piListViewDefs [in] Design time list view definitions to
//                                       examine for extensibility
//
// Output:
//    HRESULT
//
// Notes:
// Iterates through the ListViewDefs collection.
// For each list view that is extensible, Extension objects are added to
// the Extensions collection for each snap-in that extends the node type.
//
HRESULT CSnapIn::GetListItemExtensions
(
    CExtensions   *pExtensions,
    IListViewDefs *piListViewDefs
)
{
    HRESULT        hr = S_OK;
    CListViewDefs *pListViewDefs = NULL;
    CListViewDef  *pListViewDef = NULL;
    long           cListViewDefs = 0;
    long           i = 0;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piListViewDefs, &pListViewDefs));
    cListViewDefs = pListViewDefs->GetCount();
    IfFalseGo(0 != cListViewDefs, S_OK);

    // Go through the collection and get the extensions from the registry for
    // each scope item that is marked extensible.

    for (i = 0; i < cListViewDefs; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                               pListViewDefs->GetItemByIndex(i), &pListViewDef));
        if (pListViewDef->Extensible())
        {
            IfFailGo(pExtensions->Populate(pListViewDef->GetItemTypeGUID(),
                                           CExtensions::All));
        }
    }

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CSnapIn::OnDelete
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] Data object for item user requested to delete
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_DELETE handler for IComponentData::Notify
//
HRESULT CSnapIn::OnDelete(IDataObject *piDataObject)
{
    if (NULL != m_pCurrentView)
    {
        RRETURN(m_pCurrentView->OnDelete(piDataObject));
    }
    else
    {
        ASSERT(FALSE, "Received IComponentData::Notify(MMCN_DELETE) and there is no current view");
        return S_OK;
    }
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnRemoveChildren
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] Data object for node whose children are
//                                 being removed
//  HSCOPEITEM   hsi          [in] HSCOPEITEM for node whose children are
//                                 being removed
// Output:
//    HRESULT
//
// Notes:
// MMCN_REMOVECHILDREN handler for IComponentData::Notify
//
HRESULT CSnapIn::OnRemoveChildren(IDataObject *piDataObject, HSCOPEITEM hsi)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;

    // Get a ScopeNode object for the parent

    IfFailGo(CScopeNode::GetScopeNode(hsi, piDataObject, this, &piScopeNode));

    // Fire ScopeItems_RemoveChildren

    m_pScopeItems->FireRemoveChildren(piScopeNode);
    
    // Traverse the tree and remove the ScopeItem object from our ScopeItems
    // collection for each node we own that is a descendant of the parent

    IfFailGo(m_pScopeItems->RemoveChildrenOfNode(piScopeNode));
    
Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::ExtractBSTR
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long  cBytes   [in] Maximum bytes to examine in buffer
//   BSTR  bstr     [in] Buffer pointer assumed to be a BSTR
//   BSTR *pbstrOut [out] Copy of BSTR returned here. Caller must SysFreeString
//   long *pcbUsed  [out] Bytes in BSTR (including terminating null char) 
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The bstr parameter is assumed
// to point to a null-terminated BSTR. This function scans until it finds a
// null char or reaches the end of the buffer. If BSTR found, then copies
// it using SysAllocString and returns to caller
//
HRESULT CSnapIn::ExtractBSTR
(
    long  cBytes,
    BSTR  bstr,
    BSTR *pbstrOut,
    long *pcbUsed
)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cChars = cBytes / sizeof(WCHAR);
    BOOL    fFound = FALSE;

    *pbstrOut = NULL;
    *pcbUsed = 0;

    if (cChars < 1)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    while ( (i < cChars) && (!fFound) )
    {
        if (L'\0' == bstr[i])
        {
            *pbstrOut = ::SysAllocString(bstr);
            if (NULL == *pbstrOut)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            *pcbUsed = (i + 1) * sizeof(WCHAR);
            fFound = TRUE;
        }
        else
        {
            i++;
        }
    }

    if (!fFound)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ExtractBSTR
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long  cBytes     [in] Maximum bytes to examine in buffer
//   BSTR  bstr       [in] Buffer pointer assumed to contain mulitple concatenated
//                         null-terminated BSTRs
//   VARIANT *pvarOut [out] Array of BSTR returned here. Caller must VariantClear
//   long *pcbUsed    [out] Total bytes in array
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The bstr parameter is assumed
// to point to multiple concatenated null-terminated BSTRs. This function scans
// until it finds a double null char or reaches the end of the buffer. If BSTRs
// are found they are returned in a SafeArray inside the VARIANT.
//
HRESULT CSnapIn::ExtractBSTRs
(
    long     cBytes,
    BSTR     bstr,
    VARIANT *pvarOut,
    long    *pcbUsed
)
{
    HRESULT     hr = S_OK;
    SAFEARRAY  *psa = NULL;
    long        cBytesUsed = 0;
    long        cTotalBytesUsed = 0;
    long        cBytesLeft = cBytes;
    long        i = 0;
    long        cChars = cBytes / sizeof(WCHAR);
    BSTR        bstrNext = NULL;
    BSTR HUGEP *pbstr = NULL;
    BOOL        fFound = FALSE;

    SAFEARRAYBOUND sabound;
    ::ZeroMemory(&sabound, sizeof(sabound));

    ::VariantInit(pvarOut);
    *pcbUsed = NULL;

    // Create an empty array of strings. If the buffer starts with a double
    // null then this is what will be returned.
   
    sabound.cElements = 0;
    sabound.lLbound = 1L;
    psa = ::SafeArrayCreate(VT_BSTR, 1, &sabound);
    if (NULL == psa)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    while ( (i < cChars) && (!fFound) )
    {
        if (L'\0' == bstr[i])
        {
            // Double null found. End of the line.
            cTotalBytesUsed += sizeof(WCHAR);
            fFound = TRUE;
            break;
        }

        // Extract the next BSTR and adjust remaining byte counts

        IfFailGo(ExtractBSTR(cBytesLeft, &bstr[i], &bstrNext, &cBytesUsed));
        cTotalBytesUsed += cBytesUsed;
        i += (cBytesUsed / sizeof(WCHAR));
        cBytesLeft -= cBytesUsed;

        // ReDim the SafeArray and add the new BSTR
        
        sabound.cElements++;
        hr = ::SafeArrayRedim(psa, &sabound);
        EXCEPTION_CHECK_GO(hr);

        hr = ::SafeArrayAccessData(psa,
                                   reinterpret_cast<void HUGEP **>(&pbstr));
        EXCEPTION_CHECK_GO(hr);

        pbstr[sabound.cElements - 1L] = bstrNext;
        bstrNext = NULL;
        hr = ::SafeArrayUnaccessData(psa);
        EXCEPTION_CHECK_GO(hr);
        pbstr = NULL;
    }

    if (!fFound)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Return the SafeArray to the caller

    pvarOut->vt = VT_ARRAY | VT_BSTR;
    pvarOut->parray = psa;
    
    *pcbUsed = cTotalBytesUsed;

Error:
    FREESTRING(bstrNext);
    if (FAILED(hr))
    {
        if (NULL != pbstr)
        {
            (void)::SafeArrayUnaccessData(psa);
        }

        if (NULL != psa)
        {
            ::SafeArrayDestroy(psa);
        }
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ExtractObject
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long                    cBytes      [in]  Maximum bytes to examine in buffer
//   void                   *pvData      [in]  ptr to buffer
//   IUnknown              **ppunkObject [out] object's IUnknown returned here
//                                             caller must Release
//   long                   *pcbUsed     [out] Total bytes used in buffer to
//                                             extract object
//   SnapInFormatConstants   Format      [in]  siPersistedObject or
//                                             siObjectReference
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The buffer is assumed to contain
// one of the two forms of an object. The persisted object contains the stream
// that the object saved itself to. The object reference contains the stream
// that the object's IUnknown was marshaled to.
//
HRESULT CSnapIn::ExtractObject
(
    long                    cBytes, 
    void                   *pvData,
    IUnknown              **ppunkObject,
    long                   *pcbUsed,
    SnapInFormatConstants   Format
)
{
    HRESULT  hr = S_OK;
    HGLOBAL  hglobal = NULL;
    IStream *piStream = NULL;

    LARGE_INTEGER li;
    ::ZeroMemory(&li, sizeof(li));

    ULARGE_INTEGER uli;
    ::ZeroMemory(&uli, sizeof(uli));

    // Copy the data to an HGLOBAL

    hglobal = ::GlobalAlloc(GMEM_FIXED, cBytes);
    if (NULL == hglobal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(reinterpret_cast<void *>(hglobal), pvData, cBytes);

    // Create a stream on the HGLOBAL

    hr = ::CreateStreamOnHGlobal(hglobal,
                                 FALSE, // Don't call GlobalFree on release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    if (siObject == Format)
    {
        // Load the object from that stream

        hr = ::OleLoadFromStream(piStream, IID_IUnknown,
                                 reinterpret_cast<void **>(ppunkObject));
    }
    else
    {
        // Unmarshal the object from the stream

        hr = ::CoUnmarshalInterface(piStream, IID_IUnknown,
                                    reinterpret_cast<void **>(ppunkObject));
    }
    EXCEPTION_CHECK_GO(hr);

    // Get the current stream pointer to determine how many bytes were used

    hr = piStream->Seek(li, STREAM_SEEK_CUR, &uli);
    EXCEPTION_CHECK_GO(hr);

    *pcbUsed = uli.LowPart;
    
Error:
    QUICK_RELEASE(piStream);
    if (NULL != hglobal)
    {
        (void)::GlobalFree(hglobal);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::InternalCreatePropertyPages
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IPropertySheetCallback  *piPropertySheetCallback [in] MMC interface
//
//   LONG_PTR             handle       [in]  MMC propsheet handle (not used)
//
//   IDataObject         *piDataObject [in]  data object of item(s) for which
//                                           properties verb was invoked
//   WIRE_PROPERTYPAGES **ppPages      [out] If debugging, then property page
//                                           definitions returned here. Caller
//                                           does not free these as MIDL-
//                                           generated stub will free them.
//
// Output:
//    HRESULT
//
// Notes:
// Handles calls to IExtendPropertySheet2::CreatePropertyPages and
// IExtendPropertySheetRemote::CreatePropertyPageDefs (used when debugging).
//
HRESULT CSnapIn::InternalCreatePropertyPages
(
    IPropertySheetCallback  *piPropertySheetCallback,
    LONG_PTR                 handle,
    IDataObject             *piDataObject,
    WIRE_PROPERTYPAGES     **ppPages
)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;
    BSTR             bstrProjectName = NULL;
    CPropertySheet  *pPropertySheet = NULL;
    BOOL             fWizard = FALSE;
    IUnknown        *punkPropertySheet = CPropertySheet::Create(NULL);
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    BOOL             fFiringEventHere = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Check that we have a CPropertySheet and get its this pointer.

    if (NULL == punkPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertySheet,
                                                   &pPropertySheet));

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, this,
                               &SelectionType));

    // If this is not a foreign data object then this is a primary snap-in
    // being asked to create its pages for a configuration wizard or for
    // a properties verb invoked on a single scope item.

    if (!IsForeign(SelectionType))
    {
        hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
        IfFailGo(hr);

        // If this is a configuration wizard then tell the CPropertySheet

        if (CCT_SNAPIN_MANAGER == pMMCDataObject->GetContext())
        {
            fWizard = TRUE;
            pPropertySheet->SetWizard();
        }
    }

    // For configuration wizards and foreign data objects we will be firing
    // an event to allow the snap-in to add its pages. Prepare the
    // CPropertySheet to accept AddPage and AddWizardPage calls from the snap-in
    // during that event.

    if ( fWizard || (siSingleForeign == SelectionType) )
    {
        fFiringEventHere = TRUE;

        // If this is a remote call (will happen during source debugging) then
        // tell the CPropertySheet so it can accumulate the property page info
        // rather than calling IPropertySheetCallback::AddPage.

        if (NULL != ppPages)
        {
            pPropertySheet->YouAreRemote();
        }

        // Give the property sheet its callback, handle, the object, and the
        // project name which is the left hand portion of the prog ID. If this
        // is a configuration wizard then also pass our this pointer to that
        // the property page can ask us to fire ConfigurationComplete when the
        // user clicks the finish button. (See CPropertyPageWrapper::OnWizFinish()
        // in ppgwrap.cpp for how this is used).

        IfFailGo(m_piSnapInDesignerDef->get_ProjectName(&bstrProjectName));

        pPropertySheet->SetCallback(piPropertySheetCallback, handle,
                                    static_cast<LPOLESTR>(bstrProjectName),
                                    fWizard ? NULL : piMMCClipboard,
                                    fWizard ? static_cast<ISnapIn *>(this) : NULL,
                                    fWizard);
    }

    // Let the snap-in add its property pages. If this request is from the
    // snap-in manager then fire SnapIn_CreateConfigurationWizard. If it is not
    // a foreign data object then it must be for a single scope item in a loaded
    // primary snap-in so let the current view handle it. If it is a foreign
    // data object then fire ExtensionSnapIn_CreatePropertyPages.

    if (fWizard)
    {
        FireEvent(&m_eiCreateConfigurationWizard,
                  static_cast<IMMCPropertySheet *>(pPropertySheet));
    }
    else if (siSingleForeign == SelectionType)
    {
        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;
        IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

        m_pExtensionSnapIn->FireCreatePropertyPages(piMMCDataObject,
                               static_cast<IMMCPropertySheet *>(pPropertySheet));
    }
    else
    {
        if (NULL != m_pCurrentView)
        {
            IfFailGo(m_pCurrentView->InternalCreatePropertyPages(
                                                         piPropertySheetCallback,
                                                         handle,
                                                         piDataObject,
                                                         ppPages));
        }
        else
        {
            ASSERT(FALSE, "CSnapIn Received IExtendPropertySheet2::CreatePropertyPages() and there is no current view");
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // If we fired the event here and we are remote then we need to ask
    // CPropertySheet for its accumulated property page descriptors to return to
    // the stub.

    if (fFiringEventHere)
    {
        if (NULL != ppPages)
        {
            *ppPages = pPropertySheet->TakeWirePages();
        }
    }

Error:
    if (NULL != pPropertySheet)
    {
        // Tell the property sheet to release its refs on all that stuff we
        // gave it above.

        (void)pPropertySheet->SetCallback(NULL, NULL, NULL, NULL, NULL, fWizard);
    }

    FREESTRING(bstrProjectName);

    // Release our ref on the property sheet as the individual pages will addref
    // it and then release it when they are destroyed. If the snap-in did not
    // add any pages then our release here will destroy the property sheet.

    QUICK_RELEASE(punkPropertySheet);

    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetDisplayName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR bstrDisplayName [in] new SnapIn.DisplayName value
//
// Output:
//    HRESULT
//
// Notes:
// Sets SnapIn.DisplayName
//
HRESULT CSnapIn::SetDisplayName(BSTR bstrDisplayName)
{
    RRETURN(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                    DISPID_SNAPIN_DISPLAY_NAME));
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCExePath
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// If not running under the debugger then calls GetModuleFileName to set
// m_szMMCEXEPath, m_pwszMMCEXEPath, and m_cbMMCExePathW
//
HRESULT CSnapIn::SetMMCExePath()
{
    HRESULT hr = S_OK;
    DWORD   cbFileName = 0;

    // If we are remote then the proxy will call IMMCRemote::SetExePath() to
    // give us the path. If not, then we need to get it here.

    IfFalseGo((!m_fWeAreRemote), S_OK);

    cbFileName = ::GetModuleFileName(NULL,  // get executable that loaded us
                                     m_szMMCEXEPath,
                                     sizeof(m_szMMCEXEPath));
    if (0 == cbFileName)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // Get the wide version also as various parts of the code will need it.

    if (NULL != m_pwszMMCEXEPath)
    {
        CtlFree(m_pwszMMCEXEPath);
        m_pwszMMCEXEPath = NULL;
    }

    IfFailGo(::WideStrFromANSI(m_szMMCEXEPath, &m_pwszMMCEXEPath));
    m_cbMMCExePathW = ::wcslen(m_pwszMMCEXEPath) * sizeof(WCHAR);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetDisplayName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT varFolder [in] new SnapIn.StaticFolder value
//
// Output:
//    HRESULT
//
// Notes:
// Sets SnapIn.StaticFolder
//
HRESULT CSnapIn::SetStaticFolder(VARIANT varFolder)
{
    RRETURN(SetVariant(varFolder, &m_varStaticFolder, DISPID_SNAPIN_STATIC_FOLDER));
}



//=--------------------------------------------------------------------------=
// CSnapIn::CompareListItems
//=--------------------------------------------------------------------------=
//
// Parameters:
//   CMMCListItem *pMMCListItem1 [in] 1st list item to compare
//   CMMCListItem *pMMCListItem2 [in] 1st list item to compare
//   BOOL         *pfEqual       [out] TRUE returned here if equal
//
// Output:
//    HRESULT
//
// Notes:
// Determines whether two MMCListItem objects represent the same underlying data
//
HRESULT CSnapIn::CompareListItems
(
    CMMCListItem *pMMCListItem1,
    CMMCListItem *pMMCListItem2,
    BOOL         *pfEqual
)
{
    HRESULT hr = S_OK;

    *pfEqual = FALSE;

    // Simplest test: the pointers are equal
    if (pMMCListItem1 == pMMCListItem2)
    {
        *pfEqual = TRUE;
    }
    else
    {
        // Compare MMCListItem.ID. List items could be from different list views
        // or different instances of the same list view.
        IfFalseGo(ValidBstr(pMMCListItem1->GetID()), S_OK);
        IfFalseGo(ValidBstr(pMMCListItem2->GetID()), S_OK);

        if (::_wcsicmp(pMMCListItem1->GetID(), pMMCListItem2->GetID()) == 0)
        {
            *pfEqual = TRUE;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetDesignerDefHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// Sets object model host on m_piSnapInDesignerDef
//
HRESULT CSnapIn::SetDesignerDefHost()
{
    RRETURN(SetObjectModelHost(m_piSnapInDesignerDef));
}

//=--------------------------------------------------------------------------=
// CSnapIn::RemoveDesignerDefHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// Removes object model host from m_piSnapInDesignerDef
//
HRESULT CSnapIn::RemoveDesignerDefHost()
{
    RRETURN(RemoveObjectModelHost(m_piSnapInDesignerDef));
}


//=--------------------------------------------------------------------------=
//                          ISnapIn Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::put_StaticFolder                                         [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT varFolder [in] new value for SnapIn.StaticFolder
//
// Output:
//    HRESULT
//
// Notes:
// Implements setting of SnapIn.StaticFolder
//
STDMETHODIMP CSnapIn::put_StaticFolder(VARIANT varFolder)
{
    HRESULT hr = S_OK;

    // If there already is a static node scope item then change it there.
    // That method will call our SetStaticFolder in order to set the
    // value of SnapIn.StaticFolder

    if (NULL != m_pStaticNodeScopeItem)
    {
        IfFailGo(m_pStaticNodeScopeItem->put_Folder(varFolder));
    }
    else
    {
        IfFailGo(SetStaticFolder(varFolder));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::put_DisplayName                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR bstrDisplayName [in] new value for SnapIn.DisplayName
//
// Output:
//    HRESULT
//
// Notes:
// Implements setting of SnapIn.DisplayName
//
STDMETHODIMP CSnapIn::put_DisplayName(BSTR bstrDisplayName)
{
    HRESULT hr = S_OK;

    // If there already is a ScopeItem for the static node then
    // set its display name too as they must match. Setting
    // ScopeItem.ScopeNode.DisplayName will change it in MMC
    // by calling IConsoleNameSpace2::SetItem() and then call back into
    // CSnapIn::SetDisplayName() to set our local property

    if (NULL == m_pStaticNodeScopeItem)
    {
        // Set our local property value only

        IfFailGo(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                         DISPID_SNAPIN_DISPLAY_NAME));
    }
    else
    {
        IfFailGo(m_pStaticNodeScopeItem->GetScopeNode()->put_DisplayName(bstrDisplayName));
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_TaskpadViewPreferred                                 [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT_BOOL *pfvarPreferred [out] MMC 1.1's taskpad view preferred option
//                                       returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.TaskpadViewPreferred
//
STDMETHODIMP CSnapIn::get_TaskpadViewPreferred(VARIANT_BOOL *pfvarPreferred)
{
    HRESULT hr = S_OK;

    if (NULL == m_piConsole2)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->IsTaskpadViewPreferred();
    EXCEPTION_CHECK_GO(hr);

    if (S_OK == hr)
    {
        *pfvarPreferred = VARIANT_TRUE;
    }
    else
    {
        *pfvarPreferred = VARIANT_FALSE;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_RequiredExtensions                                   [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    Extensions **ppExtensions [out] Extensions collection returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.RequiredExtensions
//
STDMETHODIMP CSnapIn::get_RequiredExtensions(Extensions **ppExtensions)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkExtensions = NULL;
    CExtensions    *pExtensions = NULL;
    IScopeItemDefs *piScopeItemDefs = NULL;
    IViewDefs      *piViewDefs = NULL;
    IListViewDefs  *piListViewDefs = NULL;

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piRequiredExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));

    // Get the extensions from registry for the static node, for all extensible
    // scope items, and for all extensible list items.

    IfFailGo(pExtensions->Populate(m_bstrNodeTypeGUID, CExtensions::All));

    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(GetScopeItemExtensions(pExtensions, piScopeItemDefs));

    RELEASE(piScopeItemDefs);
    
    IfFailGo(m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs));
    IfFailGo(GetScopeItemExtensions(pExtensions, piScopeItemDefs));

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(GetListItemExtensions(pExtensions, piListViewDefs));

    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                            reinterpret_cast<void **>(&m_piRequiredExtensions)));
Error:

    if (SUCCEEDED(hr))
    {
        m_piRequiredExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piRequiredExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_Clipboard                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCClipboard **ppMMCClipboard [out] Clipboard object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.Clipboard
//
STDMETHODIMP CSnapIn::get_Clipboard(MMCClipboard **ppMMCClipboard)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    if (NULL == ppMMCClipboard)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the dataobject currently on the system clipboard

    hr = ::OleGetClipboard(&piDataObject);
    EXCEPTION_CHECK_GO(hr);

    // Create the selection and return it to the caller.

    IfFailGo(::CreateSelection(piDataObject,
                               reinterpret_cast<IMMCClipboard **>(ppMMCClipboard),
                               this, &SelectionType));

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_StringTable                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCStringTable **ppMMCStringTable [out] StringTable object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.StringTable
//
STDMETHODIMP CSnapIn::get_StringTable(MMCStringTable **ppMMCStringTable)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkMMCStringTable = NULL;
    CMMCStringTable *pMMCStringTable = NULL;

    // If we already created the object then just return it.

    IfFalseGo(NULL == m_piMMCStringTable, S_OK);

    // This is the first GET on this property so we need to create the object

    punkMMCStringTable = CMMCStringTable::Create(NULL);
    if (NULL == punkMMCStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCStringTable->QueryInterface(IID_IMMCStringTable,
                                reinterpret_cast<void **>(&m_piMMCStringTable)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCStringTable,
                                                   &pMMCStringTable));

    // Pass the object MMC's IStringTable
    
    pMMCStringTable->SetIStringTable(m_piStringTable);

Error:
    if (SUCCEEDED(hr))
    {
        m_piMMCStringTable->AddRef();
        *ppMMCStringTable = reinterpret_cast<MMCStringTable *>(m_piMMCStringTable);
    }

    QUICK_RELEASE(punkMMCStringTable);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentView                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    View **ppView [out] Current View object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentView
//
STDMETHODIMP CSnapIn::get_CurrentView(View **ppView)
{
    HRESULT hr = S_OK;

    *ppView = NULL;

    if (NULL != m_pCurrentView)
    {
        IfFailGo(m_pCurrentView->QueryInterface(IID_IView,
                                           reinterpret_cast<void **>(ppView)));
    }
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentScopePaneItem                                  [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ScopePaneItem **ppScopePaneItem [out] Current ScopePaneItem object
//                                          returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentScopePaneItem
//
STDMETHODIMP CSnapIn::get_CurrentScopePaneItem(ScopePaneItem **ppScopePaneItem)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppScopePaneItem = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->QueryInterface(IID_IScopePaneItem,
                                  reinterpret_cast<void **>(ppScopePaneItem)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentScopeItem                                     [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ScopeItem **ppScopeItem [out] Current ScopeItem object
//                                  returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentScopeItem
//
STDMETHODIMP CSnapIn::get_CurrentScopeItem(ScopeItem **ppScopeItem)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppScopeItem = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetScopeItem()->QueryInterface(IID_IScopeItem,
                                      reinterpret_cast<void **>(ppScopeItem)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentResultView                                    [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ResultView **ppResultView [out] Current ResultView object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentResultView
//
STDMETHODIMP CSnapIn::get_CurrentResultView(ResultView **ppResultView)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppResultView = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetResultView()->QueryInterface(IID_IResultView,
                                     reinterpret_cast<void **>(ppResultView)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentListView                                      [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCListView **ppMMCListView [out] Current MMCListView object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentListView
//
STDMETHODIMP CSnapIn::get_CurrentListView(MMCListView **ppListView)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppListView = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetResultView()->GetListView()->QueryInterface(
                                       IID_IMMCListView,
                                       reinterpret_cast<void **>(ppListView)));
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_MMCCommandLine                                       [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR *pbstrCmdLine  [out] MMC command line returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.MMCCommandLine
//
STDMETHODIMP CSnapIn::get_MMCCommandLine(BSTR *pbstrCmdLine)
{
    HRESULT hr = S_OK;
    LPTSTR  pszCmdLine = NULL;

    *pbstrCmdLine = NULL;

    // If we are remote then m_pszMMCCommandLine might have been set by the
    // proxy during IComponentData::Initialize by calling
    // IMMCRemote::SetMMCCommandline (see CSnapIn::SetMMCCommandline)

    if (NULL != m_pszMMCCommandLine)
    {
        pszCmdLine = m_pszMMCCommandLine;
    }
    else
    {
        pszCmdLine = ::GetCommandLine();
    }

    if (NULL != pszCmdLine)
    {
        IfFailGo(::BSTRFromANSI(pszCmdLine, pbstrCmdLine));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ConsoleMsgBox                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Prompt   [in] Message box text
//   VARIANT  Buttons  [in] Optional. Button constants (vbOKOnly etc.) These
//                          have the same values as the Win32 MB_OK etc.
//   VARIANT  Title    [in] Optional. Message box title
//   int     *pnResult [out] Iconsole2->MessageBox result returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.ConsoleMsgBox
//
STDMETHODIMP CSnapIn::ConsoleMsgBox(BSTR     Prompt,
                                    VARIANT  Buttons,
                                    VARIANT  Title,
                                    int     *pnResult)
{
    HRESULT hr = S_OK;
    LPCWSTR pwszTitle = static_cast<LPCWSTR>(m_bstrDisplayName);
    UINT    uiButtons = MB_OK;

    VARIANT varI4Buttons;
    ::VariantInit(&varI4Buttons);

    VARIANT varStringTitle;
    ::VariantInit(&varStringTitle);

    if (NULL == m_piConsole2)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(Buttons))
    {
        hr = ::VariantChangeType(&varI4Buttons, &Buttons, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        uiButtons = static_cast<UINT>(varI4Buttons.lVal);
    }

    if (ISPRESENT(Title))
    {
        hr = ::VariantChangeType(&varStringTitle, &Title, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        pwszTitle = static_cast<LPCWSTR>(varStringTitle.bstrVal);
    }
    else if (NULL == pwszTitle)
    {
        pwszTitle = L"";
    }
    
    if (NULL == Prompt)
    {
        Prompt = L"";
    }

    hr = m_piConsole2->MessageBox(static_cast<LPCWSTR>(Prompt),
                                  static_cast<LPCWSTR>(pwszTitle),
                                  static_cast<UINT>(uiButtons),
                                  pnResult);
    EXCEPTION_CHECK(hr);

Error:
    (void)::VariantClear(&varStringTitle);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ShowHelpTopic                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Topic   [in] Help topic to display
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.ShowHelpTopic
//
STDMETHODIMP CSnapIn::ShowHelpTopic(BSTR Topic)
{
    HRESULT  hr = S_OK;
    LPOLESTR pwszTopic = NULL;

    if (NULL == m_piDisplayHelp)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
    }
    else
    {
        // MMC requires allocating a copy of the topic that it will free

        IfFailGo(::CoTaskMemAllocString(Topic, &pwszTopic));
        hr = m_piDisplayHelp->ShowTopic(pwszTopic);
    }

Error:

    // If IDisplayHelp::ShowTopic() failed then we need to free the string
    
    if ( FAILED(hr) && (NULL != pwszTopic) )
    {
        ::CoTaskMemFree(pwszTopic);
    }

    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Trace                                                    [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Message   [in] Message to pass to OutputDebugStringA
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.Trace
//
STDMETHODIMP CSnapIn::Trace(BSTR Message)
{
    HRESULT  hr = S_OK;
    char    *pszMessage = NULL;

    // Convert to ANSI so this will work on Win9x

    IfFailGo(::ANSIFromWideStr(Message, &pszMessage));

    ::OutputDebugStringA(pszMessage);
    ::OutputDebugStringA("\n\r");

Error:
     if (NULL != pszMessage)
     {
         ::CtlFree(pszMessage);
     }
     RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::FireConfigComplete                                       [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDispatch *pdispConfigObject [in] Configuration object passed to
//                                     MMCPropertySheet.AddWizardPage
//
// Output:
//    HRESULT
//
// Notes:
// This is a hidden and restricted method of the ISnapIn interface used
// internally by property pages when the user clicks the Finish button on
// on a configuration wizard. Fires SnapIn_ConfigurationComplete. See
// CPropertyPageWrapper class in ppgwrap.cpp for more info.
//
STDMETHODIMP CSnapIn::FireConfigComplete(IDispatch *pdispConfigObject)
{
    FireEvent(&m_eiConfigurationComplete, pdispConfigObject);
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapIn::FormatData                                               [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   VARIANT                Data              [in]  VARIANT containing BYTE
//                                                  array of raw data
//   long                   StartingIndex     [in]  One-based index to start
//                                                  extracting from in Data
//   SnapInFormatConstants  Format            [in]  Type of data to extract
//                                                  from Data
//   VARIANT               *BytesUsed         [in]  Bytes used within Data to
//                                                  extract requested type
//   VARIANT               *pvarFormattedData [out] Data type requested returned
//                                                  in this variant
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.FormatData
//
STDMETHODIMP CSnapIn::FormatData
(
    VARIANT                Data,
    long                   StartingIndex,
    SnapInFormatConstants  Format,
    VARIANT               *BytesUsed,
    VARIANT               *pvarFormattedData
)
{
    HRESULT     hr = S_OK;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    LONG        cBytes = 0;
    LONG        cBytesUsed = 0;
    GUID        guid = GUID_NULL;
    void HUGEP *pvArrayData = NULL;

    WCHAR   wszGUID[64];
    ::ZeroMemory(wszGUID, sizeof(wszGUID));

    // If the data was in a Variant then VB will pass it as a pointer to
    // that Variant. That could easily happen if the snap-in does something like:
    //
    // Dim v As Variant
    // Dim l As Long
    // v = Data.GetData("SomeFormat")
    // l = FormatData(v, siLong)

    if ( (VT_BYREF | VT_VARIANT) == Data.vt )
    {
        // Just copy the referenced Variant into the passed Variant. We
        // have no need for the reference after this and the Data parameter
        // is read-only so we can clobber its contents safely.
        Data = *(Data.pvarVal);
    }

    // Now we have the real Variant. Is must contain a one-dimensional array of
    // Byte

    if ( (VT_ARRAY | VT_UI1) != Data.vt )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the caller wants bytes used returned then it should have been passed
    // as a pointer to a long

    if (ISPRESENT(*BytesUsed))
    {
        if ( (VT_BYREF | VT_I4) != BytesUsed->vt )
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        *(BytesUsed->plVal) = 0;
    }

    
    if (1 != ::SafeArrayGetDim(Data.parray))
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    ::VariantInit(pvarFormattedData);

    hr = ::SafeArrayAccessData(Data.parray, &pvArrayData);
    EXCEPTION_CHECK_GO(hr);

    // Get its size. As we only allow one-dimensional Byte arrays, the lower
    // and upper bounds of the 1st dimension will give us the size in bytes.

    hr = ::SafeArrayGetLBound(Data.parray, 1, &lLBound);
    EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(Data.parray, 1, &lUBound);
    EXCEPTION_CHECK_GO(hr);

    // Get the length of the array

    cBytes = (lUBound - lLBound) + 1L;

    // Check that StartingIndex is within bounds.

    if ( (StartingIndex < lLBound) || (StartingIndex > lUBound) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Increment the data pointer to the starting index.

    pvArrayData = ((BYTE HUGEP *)pvArrayData) + (StartingIndex - lLBound);

    // Decrement the available byte count by the starting index

    cBytes -= (StartingIndex - lLBound);

    // Convert the data to the correct format in the returned VARIANT

    switch (Format)
    {
        case siInteger:
            if (cBytes < sizeof(SHORT))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->iVal = *(SHORT *)pvArrayData;
            cBytesUsed = sizeof(SHORT);
            pvarFormattedData->vt = VT_I2;
            break;

        case siLong:
            if (cBytes < sizeof(LONG))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->lVal = *(LONG *)pvArrayData;
            cBytesUsed = sizeof(LONG);
            pvarFormattedData->vt = VT_I4;
            break;

        case siSingle:
            if (cBytes < sizeof(FLOAT))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->fltVal = *(FLOAT *)pvArrayData;
            cBytesUsed = sizeof(FLOAT);
            pvarFormattedData->vt = VT_R4;
            break;

        case siDouble:
            if (cBytes < sizeof(DOUBLE))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->dblVal = *(DOUBLE *)pvArrayData;
            cBytesUsed = sizeof(DOUBLE);
            pvarFormattedData->vt = VT_R8;
            break;

        case siBoolean:
            if (cBytes < sizeof(VARIANT_BOOL))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->boolVal = *(VARIANT_BOOL *)pvArrayData;
            cBytesUsed = sizeof(VARIANT_BOOL);
            pvarFormattedData->vt = VT_BOOL;
            break;

        case siCBoolean:
            if (cBytes < sizeof(BOOL))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->boolVal = BOOL_TO_VARIANTBOOL(*(BOOL *)pvArrayData);
            cBytesUsed = sizeof(BOOL);
            pvarFormattedData->vt = VT_BOOL;
            break;

        case siDate:
            if (cBytes < sizeof(DATE))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->date = *(DATE *)pvArrayData;
            cBytesUsed = sizeof(DATE);
            pvarFormattedData->vt = VT_DATE;
            break;

        case siCurrency:
            if (cBytes < sizeof(CY))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->cyVal = *(CY *)pvArrayData;
            cBytesUsed = sizeof(CY);
            pvarFormattedData->vt = VT_CY;
            break;

        case siGUID:
            if (cBytes < sizeof(GUID))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            ::memcpy(&guid, pvArrayData, sizeof(GUID));
            if (0 == ::StringFromGUID2(guid, wszGUID,
                                       sizeof(wszGUID) / sizeof(wszGUID[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->bstrVal = ::SysAllocString(wszGUID);
            if (NULL == pvarFormattedData->bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->vt = VT_BSTR;
            cBytesUsed = sizeof(GUID);
            break;

        case siString:
            IfFailGo(ExtractBSTR(cBytes, (BSTR)pvArrayData, &pvarFormattedData->bstrVal,
                                 &cBytesUsed));
            pvarFormattedData->vt = VT_BSTR;
            break;

        case siMultiString:
            IfFailGo(ExtractBSTRs(cBytes, (BSTR)pvArrayData, pvarFormattedData,
                                  &cBytesUsed));
            pvarFormattedData->vt = VT_ARRAY | VT_BSTR;
            break;

        case siObject:
        case siObjectInstance:
            IfFailGo(ExtractObject(cBytes, pvArrayData, &pvarFormattedData->punkVal,
                                   &cBytesUsed, Format));
            pvarFormattedData->vt = VT_UNKNOWN;
            break;

        default:
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
            break;
    }


Error:
    if (ISPRESENT(*BytesUsed) && SUCCEEDED(hr) )
    {
        *(BytesUsed->plVal) = cBytesUsed;
    }

    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(Data.parray);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          ISnapinAbout Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinDescription                                [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszDescription [out] SnapIn.Description returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinDescription
//
STDMETHODIMP CSnapIn::GetSnapinDescription(LPOLESTR *ppszDescription)
{
    RRETURN(::CoTaskMemAllocString(m_bstrDescription, ppszDescription));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetProvider                                         [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszName [out] SnapIn.Provider returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetProvider
//
STDMETHODIMP CSnapIn::GetProvider(LPOLESTR *ppszName)
{
    RRETURN(::CoTaskMemAllocString(m_bstrProvider, ppszName));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinVersion                                    [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszVersion [out] SnapIn.Version returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinVersion
//
STDMETHODIMP CSnapIn::GetSnapinVersion(LPOLESTR *ppszVersion)
{
    RRETURN(::CoTaskMemAllocString(m_bstrVersion, ppszVersion));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinImage                                      [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   HICON *phAppIcon [out] SnapIn.Icon returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinImage
//
STDMETHODIMP CSnapIn::GetSnapinImage(HICON *phAppIcon)
{
    HRESULT hr = S_OK;
    HICON   hAppIcon = NULL;

    *phAppIcon = NULL;

    IfFalseGo(NULL != m_piIcon, S_OK);

    hr = ::GetPictureHandle(m_piIcon, PICTYPE_ICON,
                            reinterpret_cast<OLE_HANDLE *>(&hAppIcon));
    EXCEPTION_CHECK_GO(hr);

    // BUGBUG: Fix this after MMC is fixed.
    // Due to a bug in MMC 1.1 we need to make a copy of the icon
    // and return it. If not, MMC will release the snap-in and then use
    // the icon. Releasing the snap-in will cause the picture object to be
    // freed and the icon destroyed. By making a copy the snap-in will
    // leak this resources. Use GDI function to copy icon.

    *phAppIcon = ::CopyIcon(hAppIcon);
    if (NULL == *phAppIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetStaticFolderImage                                [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   HBITMAP  *phSmallImage     [out] SnapIn.SmallFolders(StaticFolder)
//   HBITMAP  *phSmallImageOpen [out] SnapIn.SmallFoldersOpen(StaticFolder)
//   HBITMAP  *phLargeImage     [out] SnapIn.LargeFolders(StaticFolder)
//   COLORREF *pclrMask         [out] SnapIn.SmallFolders.MaskColor
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetStaticFolderImage
//
STDMETHODIMP CSnapIn::GetStaticFolderImage(HBITMAP  *phSmallImage,
                                           HBITMAP  *phSmallImageOpen,
                                           HBITMAP  *phLargeImage,
                                           COLORREF *pclrMask)
{
    HRESULT     hr = S_OK;
    HBITMAP     hSmallImage = NULL;
    HBITMAP     hSmallImageOpen = NULL;
    HBITMAP     hLargeImage = NULL;
    IMMCImages *piMMCImages = NULL;
    OLE_COLOR   OleColorMask = 0;
    COLORREF    ColorRef = RGB(0x00,0x00,0x00);

    *phSmallImage = NULL;
    *phSmallImageOpen = NULL;
    *phLargeImage = NULL;
    *pclrMask = 0;

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(NULL != m_piSmallFoldersOpen, S_OK);
    IfFalseGo(NULL != m_piLargeFolders, S_OK);
    IfFalseGo(VT_EMPTY != m_varStaticFolder.vt, S_OK);
    
    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hSmallImage)));
    RELEASE(piMMCImages);

    IfFailGo(m_piSmallFoldersOpen->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hSmallImageOpen)));
    RELEASE(piMMCImages);

    IfFailGo(m_piLargeFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hLargeImage)));

    // Due to a bug in MMC 1.1 we need to make copies of these bitmaps
    // and return them. If not, MMC 1.1 will release the snap-in and then use
    // the bitmaps. Releasing the snap-in will cause the image lists to be
    // freed and the bitmaps destroyed. By making a copy the snap-in will
    // leak these resources. This is fixed in MMC 1.2 but at this point in a
    // snap-in's life it has no way of knowing the MMC version so we need to
    // leak it in 1.2 as well. Use function in rtutil.cpp to copy bitmap.

    IfFailGo(::CopyBitmap(hSmallImage,     phSmallImage));
    IfFailGo(::CopyBitmap(hSmallImageOpen, phSmallImageOpen));
    IfFailGo(::CopyBitmap(hLargeImage,     phLargeImage));

    // Use the mask color from SmallFolders. The other choice would have
    // been to add a mask color property to SnapIn which would have been
    // even more redundant.

    IfFailGo(m_piSmallFolders->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));
    *pclrMask = ColorRef;

Error:
    if (FAILED(hr))
    {
        if (NULL != *phSmallImage)
        {
            (void)::DeleteObject(*phSmallImage);
            *phSmallImage = NULL;
        }
        if (NULL != *phSmallImageOpen)
        {
            (void)::DeleteObject(*phSmallImageOpen);
            *phSmallImageOpen = NULL;
        }
        if (NULL != *phLargeImage)
        {
            (void)::DeleteObject(*phLargeImage);
            *phLargeImage = NULL;
        }
    }
    QUICK_RELEASE(piMMCImages);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IComponentData Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CompareObjects                                    [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDataObject *piDataObject1 [in] 1st data object to compare
//   IDataObject *piDataObject2 [in] 2nd data object to compare
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::CompareObjects
//
STDMETHODIMP CSnapIn::CompareObjects(IDataObject *piDataObject1, IDataObject *piDataObject2)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObject1 = NULL;
    CMMCDataObject *pMMCDataObject2 = NULL;
    BOOL            f1NotFromThisSnapIn = FALSE;
    BOOL            f2NotFromThisSnapIn = FALSE;
    CScopeItems    *pScopeItems1 = NULL;
    CScopeItems    *pScopeItems2 = NULL;
    CMMCListItems  *pMMCListItems1 = NULL;
    CMMCListItems  *pMMCListItems2 = NULL;
    CMMCListItem   *pMMCListItem1 = NULL;
    CMMCListItem   *pMMCListItem2 = NULL;
    BOOL            fEqual = FALSE;
    long            cObjects = 0;
    long            i = 0;

    // Determine whethere the data objects belong to this snap-in

    ::IdentifyDataObject(piDataObject1, this, &pMMCDataObject1,
                         &f1NotFromThisSnapIn);

    ::IdentifyDataObject(piDataObject2, this, &pMMCDataObject2,
                         &f2NotFromThisSnapIn);

    IfFalseGo( (!f1NotFromThisSnapIn) && (!f2NotFromThisSnapIn), S_FALSE);

    // Make sure they are the same type (e.g. single scope item)
    
    IfFalseGo(pMMCDataObject1->GetType() == pMMCDataObject2->GetType(), S_FALSE);

    // Based on the type compare their referenced scope items and list items.
    // ScopeItems can be compared for pointer equality as there can only be
    // one instance of a given scope item. List items, can come from different
    // list views and represent the same underlying data so the comparison is
    // more difficulty. See CSnapIn::CompareListItems (above) for more info.
    
    switch(pMMCDataObject1->GetType())
    {
        case CMMCDataObject::ScopeItem:
            if ( pMMCDataObject1->GetScopeItem() ==
                 pMMCDataObject2->GetScopeItem() )
            {
                hr = S_OK;
            }
            break;

        case CMMCDataObject::ListItem:
            IfFailGo(CompareListItems(pMMCDataObject1->GetListItem(),
                                      pMMCDataObject2->GetListItem(),
                                      &fEqual));
            if (fEqual)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
            break;

        case CMMCDataObject::MultiSelect:
            // Need to compare each of the scope items and list items contained
            // by the 2 data objects. This case could occur when an array of
            // objects is passed to MMCPropertySheetProvider.CreatePropertySheet
            // and the same array is passed to
            // MMCPropertySheetProvider.FindPropertySheet

            pScopeItems1 = pMMCDataObject1->GetScopeItems();
            pScopeItems2 = pMMCDataObject2->GetScopeItems();
            cObjects = pScopeItems1->GetCount();
            IfFalseGo(cObjects == pScopeItems2->GetCount(), S_FALSE);
            for (i = 0; i < cObjects; i++)
            {
                IfFalseGo(pScopeItems1->GetItemByIndex(i) ==
                          pScopeItems2->GetItemByIndex(i), S_FALSE);
            }

            pMMCListItems1 = pMMCDataObject1->GetListItems();
            pMMCListItems2 = pMMCDataObject2->GetListItems();
            cObjects = pMMCListItems1->GetCount();
            IfFalseGo(cObjects == pMMCListItems2->GetCount(), S_FALSE);
            for (i = 0; i < cObjects; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                            pMMCListItems1->GetItemByIndex(i), &pMMCListItem1));
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                            pMMCListItems2->GetItemByIndex(i), &pMMCListItem2));

                IfFailGo(CompareListItems(pMMCListItem1, pMMCListItem2, &fEqual));
                IfFalseGo(fEqual, S_FALSE);
            }
            hr = S_OK;
            break;

        default:
            break;
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetDisplayInfo                                    [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   SCOPEDATAITEM *psdi [in] Scope item for which display info is needed
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::GetDisplayInfo
//
STDMETHODIMP CSnapIn::GetDisplayInfo(SCOPEDATAITEM *psdi)
{
    HRESULT     hr = S_OK;
    CScopeItem *pScopeItem = reinterpret_cast<CScopeItem *>(psdi->lParam);

    VARIANT varImageIndex;
    ::VariantInit(&varImageIndex);

    // Zero lParam indicates static node

    if (NULL == pScopeItem)
    {
        pScopeItem = m_pStaticNodeScopeItem;
    }

    IfFalseGo(NULL != pScopeItem, SID_E_INTERNAL);

    // For SDI_STR return ScopeItem.ScopeNode.DisplayName

    if ( SDI_STR == (psdi->mask & SDI_STR) )
    {
        psdi->displayname = pScopeItem->GetDisplayNamePtr();
    }

    // For SDI_IMAGE return SnapIn.SmallFolders(ScopeItem.Folder).Index

    else if ( SDI_IMAGE == (psdi->mask & SDI_IMAGE) )
    {
        IfFailGo(pScopeItem->get_Folder(&varImageIndex));
        IfFailGo(GetScopeItemImage(varImageIndex, &psdi->nImage));
    }

    // For SDI_OPENIMAGE return SnapIn.SmallFolders(ScopeItem.Folder).Index adjusted

    else if ( SDI_OPENIMAGE == (psdi->mask & SDI_OPENIMAGE) )
    {
        IfFailGo(pScopeItem->get_Folder(&varImageIndex));
        IfFailGo(GetScopeItemImage(varImageIndex, &psdi->nOpenImage));
        // Adjust for open image index (see CSnapIn::AddScopeItemImages())
        psdi->nOpenImage += static_cast<int>(m_cImages);
    }

Error:
    (void)::VariantClear(&varImageIndex);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::QueryDataObject                                   [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long                cookie         [in] 0 for static node or CScopeItem ptr
//   DATA_OBJECT_TYPES   type           [in] CCT_SCOPE, CCT_RESULT,
//                                           CCT_SNAPIN_MANAGER, CCT_UNINITIALIZED
//   IDataObject       **ppiDataObject  [out] data object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::QueryDataObject
//
STDMETHODIMP CSnapIn::QueryDataObject
(
    long                cookie,
    DATA_OBJECT_TYPES   type,
    IDataObject       **ppiDataObject
)
{
    HRESULT         hr = S_OK;
    CScopeItem     *pScopeItem = NULL;

    DebugPrintf("IComponentData::QueryDataObject(cookie=%08.8X, type=%08.8X)\r\n", cookie, type);

    // Zero cookie is static node. If we havent added a ScopeItem for static
    // node then do it now
    
    if (0 == cookie)
    {
        if (NULL == m_pStaticNodeScopeItem)
        {
            IfFailGo(m_pScopeItems->AddStaticNode(&m_pStaticNodeScopeItem));
            m_RuntimeMode = siRTPrimary;
        }
        pScopeItem = m_pStaticNodeScopeItem;
    }
    else
    {
        // Any other cookie is just the CScopeItem pointer

        pScopeItem = reinterpret_cast<CScopeItem *>(cookie);
    }

    // Set the ScopeItem's data object's context and return the data object

    pScopeItem->GetData()->SetContext(type);

    hr = pScopeItem->GetData()->QueryInterface(IID_IDataObject,
                                    reinterpret_cast<void **>(ppiDataObject));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Notify                                            [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDataObject     *piDataObject [in] target of the notification
//   MMC_NOTIFY_TYPE  event        [in] notification
//   long             Arg          [in or out] defined by notificaton
//   long             Param        [in or out] defined by notificaton
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Notify
//
STDMETHODIMP CSnapIn::Notify
(
    IDataObject     *piDataObject,
    MMC_NOTIFY_TYPE  event,
    long             Arg,
    long             Param
)
{
    HRESULT                hr = S_OK;
    BOOL                   fHandled = FALSE;
    MMC_EXPANDSYNC_STRUCT *pExpandSync = NULL;

    switch (event)
    {
        case MMCN_DELETE:
            DebugPrintf("IComponentData::Notify(MMCN_DELETE)\r\n");
            hr = OnDelete(piDataObject);
            break;

        case MMCN_EXPAND:
            DebugPrintf("IComponentData::Notify(MMCN_EXPAND)\r\n");
            hr = OnExpand(Expand,
                          piDataObject,
                          static_cast<BOOL>(Arg),
                          static_cast<HSCOPEITEM>(Param),
                          &fHandled);
            break;

        case MMCN_EXPANDSYNC:
            DebugPrintf("IComponentData::Notify(MMCN_EXPANDSYNC)\r\n");
            pExpandSync = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(Param);
            hr = OnExpand(ExpandSync,
                          piDataObject,
                          pExpandSync->bExpanding,
                          pExpandSync->hItem,
                          &pExpandSync->bHandled);
            break;

        case MMCN_PRELOAD:
            DebugPrintf("IComponentData::Notify(MMCN_PRELOAD)\r\n");
            hr = OnPreload(piDataObject, static_cast<HSCOPEITEM>(Arg));
            break;

        case MMCN_RENAME:
            DebugPrintf("IComponentData::Notify(MMCN_RENAME)\r\n");
            hr = OnRename(piDataObject, (OLECHAR *)Param);
            break;

        case MMCN_REMOVE_CHILDREN:
            DebugPrintf("IComponentData::Notify(MMCN_REMOVE_CHILDREN)\r\n");
            hr = OnRemoveChildren(piDataObject, static_cast<HSCOPEITEM>(Arg));
            break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::CreateComponent                                   [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IComponent **ppiComponent [out] IComponent returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::CreateComponent
//
STDMETHODIMP CSnapIn::CreateComponent(IComponent **ppiComponent)
{
    HRESULT  hr = S_OK;
    IView   *piView = NULL;
    CView   *pView = NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add a new View to SnapIn.Views and get its IComponent

    IfFailGo(m_piViews->Add(varUnspecified, varUnspecified, &piView));
    IfFailGo(piView->QueryInterface(IID_IComponent,
                                    reinterpret_cast<void **>(ppiComponent)));

    // Give the View a back pointer to the snap-in

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piView, &pView));
    pView->SetSnapIn(this);

    // Set Views.CurrentView and SnapIn.CurrentView
    
    m_pViews->SetCurrentView(piView);
    m_pCurrentView = pView;

    // The new View is considered active so its CControlbar becomes the
    // active one.
    
    SetCurrentControlbar(pView->GetControlbar());

    // If this view was created because the snap-in called View.NewWindow with
    // siCaption then set View.Caption.

    IfFailGo(piView->put_Caption(m_pViews->GetNextViewCaptionPtr()));

    // Make sure we have the MMC.EXE path so we can build taskpad and res
    // URLS

    IfFailGo(SetMMCExePath());

    // Fire Views_Initialize

    m_pViews->FireInitialize(piView);

Error:
    if (FAILED(hr))
    {
        *ppiComponent = NULL;
    }
    QUICK_RELEASE(piView);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Initialize                                        [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IUnknown *punkConsole [in] MMC's IConsole
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Initialize
//
STDMETHODIMP CSnapIn::Initialize(IUnknown *punkConsole)
{
    HRESULT hr = S_OK;

    // In theory, this method should never be called twice but as a precaution
    // we'll release any existing console interfaces.

    ReleaseConsoleInterfaces();

    // Acquire all the console interfaces needed for the life of the snap-in

    IfFailGo(punkConsole->QueryInterface(IID_IConsole2,
                                     reinterpret_cast<void **>(&m_piConsole2)));

    IfFailGo(punkConsole->QueryInterface(IID_IConsoleNameSpace2,
                            reinterpret_cast<void **>(&m_piConsoleNameSpace2)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IDisplayHelp,
                                   reinterpret_cast<void **>(&m_piDisplayHelp)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IStringTable,
                                   reinterpret_cast<void **>(&m_piStringTable)));


    hr = m_piConsole2->QueryScopeImageList(&m_piImageList);
    EXCEPTION_CHECK(hr);

    // Call IImageList::ImageListSetStrip to set the scope pane images
    
    IfFailGo(AddScopeItemImages());

    // Make sure we have the MMC.EXE path so we can build taskpad and res
    // URLS

    IfFailGo(SetMMCExePath());

    // Set object model host on design time definitions and the View collection
    // These will be removed in IComponent::Destroy (CSnapIn::Destroy

    IfFailGo(SetObjectModelHost(m_piSnapInDesignerDef));
    IfFailGo(SetObjectModelHost(m_piViews));

    DebugPrintf("Firing SnapIn_Load\r\n");

    FireEvent(&m_eiLoad);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Destroy                                           [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Destroy
//
STDMETHODIMP CSnapIn::Destroy()
{
    HRESULT hr = S_OK;

    // Fire SnapIn_Unload to tell the snap-in we are being unloaded from MMC

    DebugPrintf("Firing SnapIn_Unload\r\n");

    FireEvent(&m_eiUnload);

    // The scope item for the static node must be removed here because it is not
    // destroyed like all the other elements in the collection that represent
    // real scope items.

    if ( (NULL != m_pScopeItems) && (NULL != m_pStaticNodeScopeItem) )
    {
        m_pScopeItems->RemoveStaticNode(m_pStaticNodeScopeItem);
    }

    // Release all interfaces held on the console now. If we didn't this now
    // then there could be circular ref counts between us and MMC.

    ReleaseConsoleInterfaces();

    // Tell all of our contained objects to remove their refs on us as their
    // object model host. This is also done now to avoid circular ref counts.

    IfFailGo(RemoveObjectModelHost(m_piViews));
    IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));

    // Remove the current view from SnapIn.Views as it holds a ref on the View
    m_pViews->SetCurrentView(NULL);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IExtendControlbar Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::ControlbarNotify                               [IExtendControlbar]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IControlbar *piControlbar [in] MMC interface
//
// Output:
//    HRESULT
//
// Notes:
// Implements IExtendControlbar::ControlbarNotify
//
STDMETHODIMP CSnapIn::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    BOOL         fWasSet = TRUE;
    CControlbar *pPrevControlbar = GetCurrentControlbar();

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->SetControlbar(piControlbar);

    // Restore the previous current controlbar

    SetCurrentControlbar(pPrevControlbar);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ControlbarNotify                               [IExtendControlbar]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   MMC_NOTIFY_TYPE  event        [in] notification
//   long             Arg          [in or out] defined by notificaton
//   long             Param        [in or out] defined by notificaton
//
// Output:
//    HRESULT
//
// Notes:
// Implements IExtendControlbar::ControlbarNotify
//
STDMETHODIMP CSnapIn::ControlbarNotify
(
    MMC_NOTIFY_TYPE event,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT      hr = S_OK;
    BOOL         fWasSet = TRUE;
    CControlbar *pPrevControlbar = GetCurrentControlbar();

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    switch (event)
    {
        case MMCN_SELECT:
            hr = m_pControlbar->OnControlbarSelect(
                                         reinterpret_cast<IDataObject *>(param),
                                         (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
            break;

        case MMCN_BTN_CLICK:
            hr = m_pControlbar->OnButtonClick(
                                           reinterpret_cast<IDataObject *>(arg),
                                           static_cast<int>(param));
            break;

        case MMCN_MENU_BTNCLICK:
            hr = m_pControlbar->OnMenuButtonClick(
                                     reinterpret_cast<IDataObject *>(arg),
                                     reinterpret_cast<MENUBUTTONDATA *>(param));
            break;
    }

    // Restore the previous current controlbar

    SetCurrentControlbar(pPrevControlbar);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IExtendControlbarRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::MenuButtonClick                          [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and the return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CSnapIn::PopupMenuClick()).
//

STDMETHODIMP CSnapIn::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->MenuButtonClick(piDataObject, idCommand, ppPopupMenuDef);

    // Restore the previous current controlbar

    SetCurrentControlbar(NULL);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::PopupMenuClick                           [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CSnapIn::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CSnapIn::MenuButtonClick() above for more info.
//

STDMETHODIMP CSnapIn::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->PopupMenuClick(piDataObject, uiIDItem, punkParam);

    // Remove the current controlbar

    SetCurrentControlbar(NULL);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IExtendContextMenu Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::AddMenuItems                                  [IExtendContextMenu]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject          *piDataObject           [in] data object of selected
//                                                    items
//
//  IContextMenuCallback *piContextMenuCallback  [in] MMC callback interface to
//                                                    add menu items
//
//  long                 *plInsertionAllowed     [in, out] determines where
//                                                         in menu insertions
//                                                         may be made. Snap-in
//                                                         may turn off bits
//                                                         to prevent further
//                                                         insertions
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendedContextMenu::AddMenuItems
//
// MMC uses IExtendedContextMenu on the snap-in's main object in two cases.
// 1. To allow an extension snap-in to extend context menus displayed for the
// primary snap-in it is extending.
// 2. In a primary snap-in, when a context menu is displayed for a scope item in
// the scope pane, the snap-in may add to the top, new and task menus. Adding to
// the view menu is done separately using the IExtendContextMenu on the object
// that implements IComponent (CView in view.cpp).
//
// CContextMenu object handles both cases.
//
STDMETHODIMP CSnapIn::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed
)
{
    HRESULT         hr = S_OK;
    BOOL            fWasSet = TRUE;
    CScopePaneItem *pSelectedItem = NULL;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure menu extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and menu extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

    // Only pass the currently selected item if it is active meaning that it is
    // currently displaying the contents of the result pane.
    
    if (NULL != m_pCurrentView)
    {
        pSelectedItem = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();

        // Check for NULL. This can happen in the case where a snap-in is added
        // to a console and its static node is expanded using the plus sign only.
        // If the Console Root is selected and the user right clicks a
        // snap-in scope item there will be no currently selected item.
        
        if (NULL != pSelectedItem)
        {
            if (!pSelectedItem->Active())
            {
                pSelectedItem = NULL;
            }
        }
    }

    // Let CContextMenu handle the event
    
    IfFailGo(m_pContextMenu->AddMenuItems(piDataObject,
                                          piContextMenuCallback,
                                          plInsertionAllowed,
                                          pSelectedItem));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Command                                       [IExtendContextMenu]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long         lCommandID   [in] menu item clicked
//  IDataObject *piDataObject [in] data object of selected item(s)
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendedContextMenu::Command
//
STDMETHODIMP CSnapIn::Command
(
    long         lCommandID,
    IDataObject *piDataObject
)
{
    HRESULT         hr = S_OK;
    BOOL            fWasSet = TRUE;
    CScopePaneItem *pSelectedItem = NULL;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure menu extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and menu extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

    // If there is a current view get its currently selected ScopePaneItem

    if (NULL != m_pCurrentView)
    {
        pSelectedItem = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
    }

    // Let CContextMenu handle the event

    IfFailGo(m_pContextMenu->Command(lCommandID, piDataObject, pSelectedItem));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IExtendPropertySheet2 Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CreatePropertyPages                        [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IPropertySheetCallback *piPropertySheetCallback [in] MMC interface
//  LONG_PTR                handle                  [in] MMC propsheet handle
//                                                       (not used)
//  IDataObject            *piDataObject            [in] data object of selected
//                                                       item(s)
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::CreatePropertyPages
//
STDMETHODIMP CSnapIn::CreatePropertyPages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // Let the internal routine handle the event

    IfFailGo(InternalCreatePropertyPages(piPropertySheetCallback, handle,
                                         piDataObject, NULL));
    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::QueryPagesFor                              [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of selected item(s)
//
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::QueryPagesFor
//
STDMETHODIMP CSnapIn::QueryPagesFor(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    VARIANT_BOOL    fvarHavePages = VARIANT_FALSE;
    BOOL            fWasSet = TRUE;

    // This should be one of our data objects. If not then ignore it.

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_FALSE);

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // If its the snap-in manager then fire SnapIn_QueryConfigurationWizard

    if (CCT_SNAPIN_MANAGER == pMMCDataObject->GetContext())
    {
        DebugPrintf("Firing SnapIn_QueryConfigurationWizard\r\n");

        FireEvent(&m_eiQueryConfigurationWizard, &fvarHavePages);

        if (VARIANT_TRUE == fvarHavePages)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        // Not the snap-in manager. Let the View handle it as it is no
        // different than an IExtendPropertySheet2::QueryPagesFor on
        // the IComponent object (the View).

        if (NULL != m_pCurrentView)
        {
            IfFailGo(m_pCurrentView->QueryPagesFor(piDataObject));
        }
        else
        {
            ASSERT(FALSE, "CSnapIn Received IExtendPropertySheet2::QueryPagesFor() and there is no current view");
            hr = S_FALSE;
        }
    }

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetWatermarks                              [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::GetWatermarks
//
// We return S_OK from this method to indicate to MMC that we do not have
// any watermarks. VB snap-ins cannot implement wizard97 style wizards using
// this method. They must use Image objects on the property page to simulate
// the watermarks. See the designer end-user docs section
// "Creating Wizard97-Style Wizards" under "Programming Techniques".
//
STDMETHODIMP CSnapIn::GetWatermarks
(
    IDataObject *piDataObject,
    HBITMAP     *phbmWatermark,
    HBITMAP     *phbmHeader,
    HPALETTE    *phPalette,
    BOOL        *bStretch
)
{
    HRESULT   hr = S_OK;
    IPicture *piPicture = NULL;


    *phbmWatermark = NULL;
    *phbmHeader = NULL;
    *phPalette = NULL;
    *bStretch = FALSE;

    // UNDONE:
    // There is a painting problem with watermarks and they are overwritten
    // by VB's property page painting so disable them for now.
    
    return S_OK;

    if (NULL != m_piWatermark)
    {
        // UNDONE: need to use CopyBitmap() to upgrade bitmaps that have
        // a lower color depth than the screen
        IfFailGo(::GetPictureHandle(m_piWatermark, PICTYPE_BITMAP,
                                 reinterpret_cast<OLE_HANDLE *>(phbmWatermark)));
    }
    
    if (NULL != m_piHeader)
    {
        // UNDONE: need to use CopyBitmap() to upgrade bitmaps that have
        // a lower color depth than the screen
        IfFailGo(::GetPictureHandle(m_piHeader, PICTYPE_BITMAP,
                                    reinterpret_cast<OLE_HANDLE *>(phbmHeader)));
    }

    if ( (NULL != m_piWatermark) || (NULL != m_piHeader) )
    {
        IfFailGo(m_piPalette->QueryInterface(IID_IPicture,
                                         reinterpret_cast<void **>(&piPicture)));

        IfFailGo(piPicture->get_hPal(reinterpret_cast<OLE_HANDLE *>(phPalette)));

        if (VARIANT_TRUE == m_StretchWatermark)
        {
            *bStretch = TRUE;
        }
    }

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                    IExtendPropertySheetRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CreatePropertyPageDefs                [IExtendPropertySheetRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject         *piDataObject [in] data object of selected item(s)
//                                                       
//  WIRE_PROPERTYPAGES **ppPages      [out] Property page defs returned here.
//                                          These will be freed by the
//                                          MIDL-generated stub
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheetRemote::CreatePropertyPageDefs
//
// This interface is used instead of IExtendPropertySheet2 when running under
// the debugger. This method is called by the
// IExtendPropertySheet2::CreatePropertyPages proxy in mmcproxy.dll.
//
STDMETHODIMP CSnapIn::CreatePropertyPageDefs
(
    IDataObject         *piDataObject,
    WIRE_PROPERTYPAGES **ppPages
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // Let internal routine handle this call

    IfFailGo(InternalCreatePropertyPages(NULL, NULL, piDataObject, ppPages));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IRequiredExtensions Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::EnableAllExtensions                          [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::EnableAllExtensions
//
//
STDMETHODIMP CSnapIn::EnableAllExtensions()
{
    HRESULT      hr = S_FALSE;
    CExtensions *pExtensions = NULL;
    IExtension  *piExtension = NULL; // Not AddRef()ed
    long         cExtensions = 0;
    long         i = 0;
    VARIANT_BOOL fvarEnabled = VARIANT_FALSE;

    SnapInExtensionTypeConstants Type = siStatic;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piRequiredExtensions,
                                                   &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_FALSE);

    // Iterate through the collection and look for any disabled static extension.
    // If one is found then return S_FALSE.

    for (i = 0; i < cExtensions; i++)
    {
        piExtension = pExtensions->GetItemByIndex(i);

        IfFailGo(piExtension->get_Type(&Type));
        if (siStatic != Type)
        {
            continue;
        }

        IfFailGo(piExtension->get_Enabled(&fvarEnabled));
        IfFalseGo(VARIANT_TRUE == fvarEnabled, S_FALSE);
    }

    // All statics are enabled - return S_OK to indicate that to MMC.
    
    hr = S_OK;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetFirstExtension                            [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pclsidExtension [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::GetFirstExtension
//
//
STDMETHODIMP CSnapIn::GetFirstExtension(CLSID *pclsidExtension)
{
    HRESULT hr = S_OK;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled.

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    // Initialize the enumerator and return the first enabled extension

    m_iNextExtension = 0;

    IfFailGo(GetNextExtension(pclsidExtension));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetNextExtension                            [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pclsidExtension [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::GetNextExtension
//
//
STDMETHODIMP CSnapIn::GetNextExtension(CLSID *pclsidExtension)
{
    HRESULT      hr = S_FALSE;
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;
    long         cExtensions = 0;
    BOOL         fEnabledFound = FALSE;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled.

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piRequiredExtensions,
                                                   &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_FALSE);

    // Iterate through the collection starting at the current position and look
    // for the next enabled extension.  If one is found then return S_OK to
    // indicate to MMC that it should require that extension. Note that we do
    // not distinguish here between static and dynamic extensions. This is the
    // opportunity for the snap-in to preload a dynamic extension if desired.

    while ( (!fEnabledFound) && (m_iNextExtension < cExtensions) )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                    pExtensions->GetItemByIndex(m_iNextExtension), &pExtension));

        m_iNextExtension++;

        if (pExtension->Enabled())
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), pclsidExtension);
            EXCEPTION_CHECK_GO(hr);
            fEnabledFound = TRUE;
        }
    }

    hr = fEnabledFound ? S_OK : S_FALSE;

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                           ISnapinHelp Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetHelpTopic                                         [ISnapinHelp]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  LPOLESTR *ppwszHelpFile [out] complete path to help file returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles ISnapinHelp::GetHelpTopic
//
STDMETHODIMP CSnapIn::GetHelpTopic(LPOLESTR *ppwszHelpFile)
{
    HRESULT  hr = S_OK;
    size_t   cchHelpFile = 0;
    size_t   cbHelpFile = 0;
    OLECHAR *pwszSnapInPath = NULL; // not allocated, no need to free
    size_t   cbSnapInPath = 0;
    BOOL     fRelative = FALSE;
    OLECHAR *pwszFullPath = NULL;
    OLECHAR *pchLastBackSlash = NULL;

    // If SnapIn.HelpFile has not been set then return S_FALSE to tell MMC
    // that we don't have a help file.

    IfFalseGo(ValidBstr(m_bstrHelpFile), S_FALSE);

    // If the help file name is relative then convert to a fully qualified path

    cchHelpFile = ::wcslen(m_bstrHelpFile);

    // If it starts with a backslash then consider it fully qualified.

    if (L'\\' == m_bstrHelpFile[0])
    {
        fRelative = FALSE;
    }
    else if (cchHelpFile > 3) // enough room for C:\ ?
    {
        // If it does not have :\ in the 2nd and 3rd characters then consider it
        // relative

        if ( (L':' != m_bstrHelpFile[1]) || (L'\\' != m_bstrHelpFile[2] ) )
        {
            fRelative = TRUE;
        }
    }
    else
    {
        fRelative = TRUE;
    }

    if (fRelative)
    {
        // Find last backslash in snap-in path.

        IfFailGo(GetSnapInPath(&pwszSnapInPath, &cbSnapInPath));

        pchLastBackSlash = ::wcsrchr(pwszSnapInPath, L'\\');
        if (NULL == pchLastBackSlash)
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        // Determine how many bytes of the snap-in path we need

        cbSnapInPath = ((pchLastBackSlash + 1) - pwszSnapInPath) * sizeof(OLECHAR);
        
        cbHelpFile = cchHelpFile * sizeof(OLECHAR);

        pwszFullPath = (OLECHAR *)::CtlAllocZero(cbSnapInPath +
                                                 cbHelpFile +
                                                 sizeof(OLECHAR)); // for null
        if (NULL == pwszFullPath)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        ::memcpy(pwszFullPath, pwszSnapInPath, cbSnapInPath);

        ::memcpy((BYTE *)pwszFullPath + cbSnapInPath, m_bstrHelpFile, cbHelpFile);
    }
    else
    {
        pwszFullPath = m_bstrHelpFile;
    }

    IfFailGo(::CoTaskMemAllocString(pwszFullPath, ppwszHelpFile));

Error:
    if ( fRelative && (NULL != pwszFullPath) )
    {
        ::CtlFree(pwszFullPath);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                           ISnapinHelp2 Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetLinkedTopics                                     [ISnapinHelp2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  LPOLESTR *ppwszTopics [out] Linked topics returned here.
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles ISnapinHelp2::GetLinkedTopics
//
STDMETHODIMP CSnapIn::GetLinkedTopics(LPOLESTR *ppwszTopics)
{
    HRESULT hr = S_OK;

    *ppwszTopics = NULL;

    // If SnapIn.LinkTopics has not been set then return S_FALSE to tell MMC
    // that we don't have a linked topics.

    IfFalseGo(ValidBstr(m_bstrLinkedTopics), S_FALSE);

    // UNDONE need to resolve relative paths of all help files.

    IfFailGo(::CoTaskMemAllocString(m_bstrLinkedTopics, ppwszTopics));

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                    IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetClassID                                    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pClsid [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::GetClassID
//
STDMETHODIMP CSnapIn::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_SnapIn;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapIn::InitNew                                       [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::InitNew
//
STDMETHODIMP CSnapIn::InitNew()
{
    HRESULT hr = S_OK;

    RELEASE(m_piSnapInDesignerDef);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::Load                                          [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IStream *piStream [in] stream to load from
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::Load
//
STDMETHODIMP CSnapIn::Load(IStream *piStream)
{
    HRESULT         hr = S_OK;
    CLSID           clsid = CLSID_NULL;
    IUnknown       *punkSnapInDesignerDef = NULL;
    IPersistStream *piPersistStream = NULL;
    _PropertyBag   *p_PropertyBag = NULL;

    // This may be a VB serialization load or it may be a console load. To
    // distinguish the two we read the CLSID from the beginning of the stream.
    // If is is CLSID_SnapInDesignerDef the is is a VB serialization load.
    // If it is CLSID_PropertyBag then it is a console load.

    // Read the CLSID

    hr = ::ReadClassStm(piStream, &clsid);
    EXCEPTION_CHECK_GO(hr);

    // Check the CLSID

    if (CLSID_PropertyBag == clsid)
    {
        // Transfer the stream contents to a property bag

        IfFailGo(::PropertyBagFromStream(piStream, &p_PropertyBag));

        // Fire Snapin_ReadProperties

        FireEvent(&m_eiReadProperties, p_PropertyBag);
    }
    else if (CLSID_SnapInDesignerDef == clsid)
    {
        // Load the SnapInDesignerDef object. This is the snap-in definition
        // serialized in the designer as the runtime state.

        RELEASE(m_piSnapInDesignerDef);
        punkSnapInDesignerDef = CSnapInDesignerDef::Create(NULL);
        if (NULL == punkSnapInDesignerDef)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkSnapInDesignerDef->QueryInterface(IID_ISnapInDesignerDef,
                           reinterpret_cast<void **>(&m_piSnapInDesignerDef)));

        IfFailGo(punkSnapInDesignerDef->QueryInterface(IID_IPersistStream,
            reinterpret_cast<void **>(&piPersistStream)));

        IfFailGo(piPersistStream->Load(piStream));

        // Get the SnapInDef object to make fetching properties from the state easy

        RELEASE(m_piSnapInDef);
        IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&m_piSnapInDef));

        // Set the SnapIn properties. Set object model host so image lists
        // can be found by using a key into SnapInDesignerDef.ImageLists.

        IfFailGo(SetObjectModelHost(m_piSnapInDesignerDef));
        IfFailGo(SetSnapInPropertiesFromState());
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    else
    {
        // Neither CLSID is there. Stream is corrupt.
        hr = SID_E_SERIALIZATION_CORRUPT
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    QUICK_RELEASE(punkSnapInDesignerDef);
    QUICK_RELEASE(piPersistStream);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::Save                                          [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IStream *piStream    [in] stream to save to
//  BOOL     fClearDirty [in] TRUE=clear snap-in's dirty flag so GetDirty would
//                            return S_FALSE
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::Save
//
STDMETHODIMP CSnapIn::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Unlike Load, Save can only come from MMC so create a property bag.
    // fire the event and save it to the stream.

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    EXCEPTION_CHECK_GO(hr);

    // Fire Snapin_WriteProperties

    FireEvent(&m_eiWriteProperties, p_PropertyBag);

    // Write CLSID_PropertyBag to the beginning of the stream

    hr = ::WriteClassStm(piStream, CLSID_PropertyBag);
    EXCEPTION_CHECK_GO(hr);

    // Get the stream contents in a SafeArray of Byte

    IfFailGo(p_PropertyBag->get_Contents(&var));

    // Write the SafeArray contents to the stream

    IfFailGo(::WriteSafeArrayToStream(var.parray, piStream, WriteLength));

Error:
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::IsDirty                                       [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::IsDirty
//
// The designer object model does not have any way for a snap-in to indicate
// that a snap-in is dirty. This was an oversight discovered too late in the
// product cycle. There should have been a property SnapIn.Changed to control
// the return value from this function.
//
// To avoid a situation where a snap-in needs to save something we always return
// S_OK to indicate that the snap-in is dirty and should be saved. The only
// problem this may cause is that when a console is opened in author mode and
// the user does not do anything that requires a save (e.g. selected a node
// in the scope pane) then they will be prompted to save unnecessarily.
//
STDMETHODIMP CSnapIn::IsDirty()
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSizeMax                                    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  ULARGE_INTEGER* puliSize [out] size returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::GetSizeMax
//
STDMETHODIMP CSnapIn::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
//                          IOleObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::SetClientSite                                         [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IOleClientSite *piOleClientSite [in] new client site
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetClientSite
//
STDMETHODIMP CSnapIn::SetClientSite(IOleClientSite *piOleClientSite)
{
    RELEASE(m_piOleClientSite);
    if (NULL != piOleClientSite)
    {
        RRETURN(piOleClientSite->QueryInterface(IID_IOleClientSite,
                                reinterpret_cast<void **>(&m_piOleClientSite)));
    }
    else
    {
        return S_OK;
    }
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClientSite                                         [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IOleClientSite **ppiOleClientSite [in] current client site returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetClientSite
//
STDMETHODIMP CSnapIn::GetClientSite(IOleClientSite **ppiOleClientSite)
{
    if (NULL != m_piOleClientSite)
    {
        m_piOleClientSite->AddRef();
    }
    *ppiOleClientSite = m_piOleClientSite;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetHostNames                                          [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetHostNames
//
STDMETHODIMP CSnapIn::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Close                                                 [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Close
//
STDMETHODIMP CSnapIn::Close(DWORD dwSaveOption)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetMoniker                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetMoniker
//
STDMETHODIMP CSnapIn::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetMoniker                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetMoniker
//
STDMETHODIMP CSnapIn::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppmk
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::InitFromData                                          [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::InitFromData
//
STDMETHODIMP CSnapIn::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClipboardData                                      [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetClipboardData
//
STDMETHODIMP CSnapIn::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::DoVerb                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::DoVerb
//
STDMETHODIMP CSnapIn::DoVerb
(
    LONG            iVerb,
    LPMSG           lpmsg,
    IOleClientSite *pActiveSite,
    LONG            lindex,
    HWND            hwndParent,
    LPCRECT         lprcPosRect
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::EnumVerbs                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::EnumVerbs
//
STDMETHODIMP CSnapIn::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Update                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Update
//
STDMETHODIMP CSnapIn::Update()
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::IsUpToDate                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::IsUpToDate
//
STDMETHODIMP CSnapIn::IsUpToDate()
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Update                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pClsid [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetUserClassID
//
STDMETHODIMP CSnapIn::GetUserClassID(CLSID *pClsid)
{
    if (NULL != pClsid)
    {
        *pClsid = CLSID_SnapIn;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetUserType                                           [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetUserType
//
STDMETHODIMP CSnapIn::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetExtent                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetExtent
//
STDMETHODIMP CSnapIn::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetExtent                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetExtent
//
STDMETHODIMP CSnapIn::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Advise                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Advise
//
STDMETHODIMP CSnapIn::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Unadvise                                              [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Unadvise
//
STDMETHODIMP CSnapIn::Unadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::EnumAdvise                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::EnumAdvise
//
STDMETHODIMP CSnapIn::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Advise                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  DWORD  dwAspect  [in] not used
//  DWORD *pdwStatus [in] misc status bits returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetMiscStatus
//
STDMETHODIMP CSnapIn::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    return OLEMISC_INVISIBLEATRUNTIME;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetColorScheme                                        [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetColorScheme
//
STDMETHODIMP CSnapIn::SetColorScheme(LOGPALETTE *pLogpal)
{
    return E_NOTIMPL;
}


//=--------------------------------------------------------------------------=
//                   IProvideDynamicClassInfo Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetDynamicClassInfo             [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
//  ITypeInfo **ppTypeInfo [out] snap-in's dynamic typeinfo returned here
//  DWORD      *pdwCookie  [in]  typeinfo cookie from design time returned here
//
// Output:
//    HRESULT
//
// Notes:
//
// Handles IProvideDynamicClassInfo::GetDynamicClassInfo
//
STDMETHODIMP CSnapIn::GetDynamicClassInfo(ITypeInfo **ppTypeInfo, DWORD *pdwCookie)
{
    *pdwCookie = m_dwTypeinfoCookie;

    // Let IProvideClassInfo::GetClassInfo return the typeinfo
    
    RRETURN(GetClassInfo(ppTypeInfo));
}

//=--------------------------------------------------------------------------=
// CSnapIn::FreezeShape    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
//
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
//
// Handles IProvideDynamicClassInfo::FreezeShape
// Not used at runtime because typeinfo can only change at design time.
//
STDMETHODIMP CSnapIn::FreezeShape(void)
{
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClassInfo                                   [IProvideClassInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
//  ITypeInfo **ppTypeInfo [out] snap-in's dynamic typeinfo returned here
// Output:
//    HRESULT
//
// Notes:
//
//
// Handles IProvideClassInfo::GetClassInfo
//

STDMETHODIMP CSnapIn::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    ITypeLib *piTypeLib = NULL;
    HRESULT   hr = S_OK;

    IfFalseGo(NULL != ppTypeInfo, S_OK);

    // Load our typelib using registry information

    hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                          1,
                          0,
                          LOCALE_SYSTEM_DEFAULT,
                          &piTypeLib);
    IfFailGo(hr);

    // Get the ITypeInfo for CLSID_SnapIn (the top level object)

    hr = piTypeLib->GetTypeInfoOfGuid(CLSID_SnapIn, ppTypeInfo);

Error:
    QUICK_RELEASE(piTypeLib);
    return hr;
}


//=--------------------------------------------------------------------------=
//                        IObjectModelHost Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapInDesignerDef                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ISnapInDesignerDef **ppiSnapInDesignerDef [out] return designer's
//                                                    ISnapInDesignerDef here
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IObjectModelHost::GetSnapInDesignerDef
//
// Called from an extensibility object when it needs access to the top of
// the object model.
//
//

STDMETHODIMP CSnapIn::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piSnapInDesignerDef) || (NULL == ppiSnapInDesignerDef) )
    {
        *ppiSnapInDesignerDef = NULL;
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        m_piSnapInDesignerDef->AddRef();
        *ppiSnapInDesignerDef = m_piSnapInDesignerDef;
    }
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetRuntime                                      [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BOOL *pfRuntime [out] return flag indiciating whether host is runtime
//                          or designer
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IObjectModelHost::GetRuntime
//
// Called from any object when it needs to determine if it is running at runtime
// or at design time.
//
STDMETHODIMP CSnapIn::GetRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;
    
    if (NULL == pfRuntime)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        *pfRuntime = TRUE;
    }

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                          IDispatch Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::GetTypeInfoCount                                       [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    UINT *pctinfo [out] return count of typeinfo interfaces supported here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetTypeInfoCount
//
STDMETHODIMP CSnapIn::GetTypeInfoCount(UINT *pctinfo)
{
    RRETURN(CSnapInAutomationObject::GetTypeInfoCount(pctinfo));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetTypeInfoCount                                       [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   UINT        itinfo        [in]  which typeinfo requested (0=IDispatch)
//   LCID        lcid          [in]  locale of typeinfo
//   ITypeInfo **ppTypeInfoOut [out] snap-in's typeinfo returned here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetTypeInfo
//
STDMETHODIMP CSnapIn::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    RRETURN(CSnapInAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetIDsOfNames                                          [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   REFIID    riid      [in] IID for which DISPIDs are needed
//   OLECHAR **rgszNames [in] names for which DISPIDs are needed
//   UINT      cnames    [in] # of names
//   LCID      lcid      [in] locale of names
//   DISPID   *rgdispid  [out] DISPIDs returned here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetIDsOfNames
//
// Defers to base class which means that any objects added to typeinfo at design
// time (e.g. toolbar, image list or menu) cannot be retrieved late bound. This
// means that when the snap-in passes Me to a subroutine, it cannot pass it
// As Object, it must pass it As SnapIn so that VB will use the dual interface.
//
STDMETHODIMP CSnapIn::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cnames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    // UNDONE: need to implement this for dispids >= DISPID_DYNAMIC_BASE
    // so dynamic props can be fetched late bound

    RRETURN(CSnapInAutomationObject::GetIDsOfNames(riid, rgszNames, cnames,
                                                   lcid, rgdispid));
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetIDsOfNames                                          [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   DISPID      dispid      [in] DISPID of method or property
//   REFIID      riid        [in] dispatch IID
//   LCID        lcid        [in] locale of caller
//   WORD        wFlags      [in] DISPATCH_METHOD, DISPATCH_PROPERTYGET etc.
//   DISPPARAMS *pdispparams [in] parameters to method
//   VARIANT    *pvarResult  [out] return value of method
//   EXCEPINFO  *pexcepinfo  [out] exception details if DISP_E_EXCEPTION returned
//   UINT       *puArgErr    [out] index of 1st incorrect argument
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetIDsOfNames
//
// For static properties and methods we defer to the base class in the
// framework. For dynamic properties (toolbars, menus and image lists) we need
// to search the design time definitions for an object with a matching DISPID.
// VB will always do a DISPATCH_PROPERTYGET on these objects.
//
STDMETHODIMP CSnapIn::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT         hr = S_OK;
    IMMCToolbars   *piMMCToolbars = NULL;
    CMMCToolbars   *pMMCToolbars = NULL;
    IMMCToolbar    *piMMCToolbar = NULL; // Not AddRef()ed
    CMMCToolbars   *pMMCToolbar = NULL;
    IMMCImageLists *piMMCImageLists = NULL;
    CMMCImageLists *pMMCImageLists = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    CMMCImageList  *pMMCImageList = NULL;
    BOOL            fFound = FALSE;
    IMMCMenus      *piMMCMenus = NULL;
    IMMCMenu       *piMMCMenu = NULL;
    long            cObjects = 0;
    long            i = 0;
    
    // For static methods and properties just pass it on to the framework.

    if (dispid < DISPID_DYNAMIC_BASE)
    {
        RRETURN(CSnapInAutomationObject::Invoke(dispid, riid, lcid, wFlags,
                                                pdispparams, pvarResult,
                                                pexcepinfo, puArgErr));
    }

    // It's a static property. Need to find the object among toolbars,
    // image lists, and menus.

    // First try toolbars.

    IfFailGo(m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbars, &pMMCToolbars));
    cObjects = pMMCToolbars->GetCount();

    for (i = 0; (i < cObjects) && (!fFound); i++)
    {
        piMMCToolbar = pMMCToolbars->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar,
                                                       &pMMCToolbar));
        if (pMMCToolbar->GetDispid() == dispid)
        {
            pvarResult->vt = VT_DISPATCH;
            piMMCToolbar->AddRef();
            pvarResult->pdispVal = static_cast<IDispatch *>(piMMCToolbar);
            fFound = TRUE;
        }
    }

    IfFalseGo(!fFound, S_OK);

    // Not a toolbar. Try image lists.

    IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImageLists, &pMMCImageLists));
    cObjects = pMMCImageLists->GetCount();

    for (i = 0; (i < cObjects) && (!fFound); i++)
    {
        piMMCImageList = pMMCImageLists->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImageList,
                                                       &pMMCImageList));
        if (pMMCImageList->GetDispid() == dispid)
        {
            pvarResult->vt = VT_DISPATCH;
            piMMCImageList->AddRef();
            pvarResult->pdispVal = static_cast<IDispatch *>(piMMCImageList);
            fFound = TRUE;
        }
    }

    IfFalseGo(!fFound, S_OK);

    // Not an image list. Try menus.

    IfFailGo(m_piSnapInDesignerDef->get_Menus(&piMMCMenus));
    IfFailGo(FindMenu(piMMCMenus, dispid, &fFound, &piMMCMenu));
    if (fFound)
    {
        pvarResult->vt = VT_DISPATCH;
        pvarResult->pdispVal = static_cast<IDispatch *>(piMMCMenu);
    }

    IfFalseGo(!fFound, S_OK);

    
    // If we're here then its a bad dispid. Pass it on to the base class
    // and it will fill in the exception stuff

    hr = CSnapInAutomationObject::Invoke(dispid, riid, lcid, wFlags,
                                         pdispparams, pvarResult,
                                         pexcepinfo, puArgErr);

Error:
    QUICK_RELEASE(piMMCToolbars);
    QUICK_RELEASE(piMMCImageLists);
    QUICK_RELEASE(piMMCMenus);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::FindMenu
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IMMCMenus  *piMMCMenus [in]  menus collection to search
//   DISPID      dispid     [in]  DISPID to search for
//   BOOL       *pfFound    [out] TRUE returned here if menu found
//   IMMCMenu  **ppiMMCMenu [out] menu returned here if found
//    
// Output:
//      HRESULT
//
// Notes:
//
// Recursively searches the MMCMenus collection and children for an MMCMenu
// object that has the specified DISPID.
//
HRESULT CSnapIn::FindMenu(IMMCMenus *piMMCMenus, DISPID dispid, BOOL *pfFound, IMMCMenu **ppiMMCMenu)
{
    HRESULT         hr = S_OK;
    IMMCMenus      *piMMCChildMenus = NULL;
    CMMCMenus      *pMMCMenus = NULL;
    IMMCMenu       *piMMCMenu = NULL; // Not AddRef()ed
    CMMCMenu       *pMMCMenu = NULL;
    long            cObjects = 0;
    long            i = 0;

    *pfFound = FALSE;
    *ppiMMCMenu = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenus, &pMMCMenus));
    cObjects = pMMCMenus->GetCount();

    for (i = 0; (i < cObjects) && (!*pfFound); i++)
    {
        // Get the next MMCMenu object
        
        piMMCMenu = pMMCMenus->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

        // If the DISPID is a match then we've found it
        
        if (pMMCMenu->GetDispid() == dispid)
        {
            *pfFound = TRUE;
            piMMCMenu->AddRef();
            *ppiMMCMenu = piMMCMenu;
        }
        else
        {
            // DISPID did not match. Get the children of the MMCMenu and
            // make a recursive call to search them.
            
            IfFailGo(piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCChildMenus)));
            IfFailGo(FindMenu(piMMCChildMenus, dispid, pfFound, ppiMMCMenu));
            RELEASE(piMMCChildMenus);
        }
    }


Error:
    QUICK_RELEASE(piMMCChildMenus);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                            IMMCRemote Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::ObjectIsRemote                                        [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::ObjectIsRemote
//
// Called from proxy in mmcproxy.dll to tell the runtime that it is running
// remotely. Used during debugging.
//
STDMETHODIMP CSnapIn::ObjectIsRemote()
{
    m_fWeAreRemote = TRUE;
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCExePath                                         [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   char *pszPath [in] path to MMC.EXE
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::SetMMCExePath
//
// Called from proxy in mmcproxy.dll to give the remotely running runtime
// the path to MMC.EXE.
//
STDMETHODIMP CSnapIn::SetMMCExePath(char *pszPath)
{
    HRESULT hr = S_OK;
    size_t  cbToCopy = 0;

    // The path may already have been set. The proxy makes this call in
    // both IComponentData::Initialize and IComponentData::CreateComponent.
    // See IComponentData_CreateComponent_Proxy in
    // \mmc.vb\vb98ctls\mmcproxy\proxy.c for why this is done.

    IfFalseGo(NULL == m_pwszMMCEXEPath, S_OK);

    IfFalseGo(NULL != pszPath, E_INVALIDARG);

    cbToCopy = (::strlen(pszPath) + 1) * sizeof(char);

    IfFalseGo(cbToCopy <= sizeof(m_szMMCEXEPath), E_INVALIDARG);

    ::memcpy(m_szMMCEXEPath, pszPath, cbToCopy);
    
    // Get the wide version also as various parts of the code will need it.

    IfFailGo(::WideStrFromANSI(m_szMMCEXEPath, &m_pwszMMCEXEPath));
    m_cbMMCExePathW = ::wcslen(m_pwszMMCEXEPath) * sizeof(WCHAR);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCCommandLine                                     [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   char *pszCmdLine [in] command line used to start MMC.EXE
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::SetMMCCommandLine
//
// Called from proxy in mmcproxy.dll to give the remotely running runtime
// the MMC.EXE command line.
//
STDMETHODIMP CSnapIn::SetMMCCommandLine(char *pszCmdLine)
{
    HRESULT hr = S_OK;
    size_t  cbCmdLine = ::strlen(pszCmdLine) + 1;

    if (NULL != m_pszMMCCommandLine)
    {
        CtlFree(m_pszMMCCommandLine);
        m_pszMMCCommandLine = NULL;
    }

    m_pszMMCCommandLine = (char *)CtlAlloc(cbCmdLine);
    if (NULL == m_pszMMCCommandLine)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pszMMCCommandLine, pszCmdLine, cbCmdLine);
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::InternalQueryInterface                            [CUnknownObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   REFIID riid        [in] IID requested
//   void **ppvObjOut   [out] object interface returned
//    
// Output:
//      HRESULT
//
// Notes:
//
// Overrides CUnknownObject::InternalQueryInterface
//
// Called from the framework when it cannot answer a QI
//
HRESULT CSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    HRESULT hr = S_OK;
    
    if ( (IID_ISnapIn == riid) || (m_IID == riid) )
    {
        *ppvObjOut = static_cast<ISnapIn *>(this);
        ExternalAddRef();
    }
    else if (IID_IPersistStream == riid)
    {
        // We need to support IPersistStream in addition to IPersistStreamInit
        // because the VB runtime will not pass IPersistStreamInit QIs from an
        // external source to the base class (meaning us). When MMC saves a
        // console file it QIs for IPersistStorage, IPersistStream and
        // IPersistStreamInit. As VB blocks IPersistStreamInit, supporting
        // IPersistStream is the only way to respond to this. When the snap-in
        // is loaded due to a CoCreateInstance call then the VB runtime QIs for
        // IPersistStreamInit.
        
        *ppvObjOut = static_cast<IPersistStream *>(this);
        ExternalAddRef();
    }
    else if (IID_IPersistStreamInit == riid)
    {
        *ppvObjOut = static_cast<IPersistStreamInit *>(this);
        ExternalAddRef();
    }
    else if (IID_IProvideDynamicClassInfo == riid)
    {
        *ppvObjOut = static_cast<IProvideDynamicClassInfo *>(this);
        ExternalAddRef();
    }
    else if (IID_IComponentData == riid)
    {
        *ppvObjOut = static_cast<IComponentData *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinAbout == riid)
    {
        // This means that we were created for ISnapInAbout only and there
        // will be no opportunity to remove the object model host so remove
        // it now.
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
        IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));
        IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));
        m_RuntimeMode = siRTSnapInAbout;
        *ppvObjOut = static_cast<ISnapinAbout *>(this);
        ExternalAddRef();
    }
    else if (IID_IObjectModelHost == riid)
    {
        *ppvObjOut = static_cast<IObjectModelHost *>(this);
        ExternalAddRef();
    }
    else if (IID_IOleObject == riid)
    {
        *ppvObjOut = static_cast<IOleObject *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendContextMenu == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendContextMenu *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendControlbar == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendControlbar *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendControlbarRemote == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendControlbarRemote *>(this);
        ExternalAddRef();
    }
    else if ( (IID_IExtendPropertySheet == riid) ||
              (IID_IExtendPropertySheet2 == riid) )
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendPropertySheet2 *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendPropertySheetRemote == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendPropertySheetRemote *>(this);
        ExternalAddRef();
    }
    else if (IID_IRequiredExtensions == riid)
    {
        *ppvObjOut = static_cast<IRequiredExtensions *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinHelp == riid)
    {
        *ppvObjOut = static_cast<ISnapinHelp *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinHelp2 == riid)
    {
        *ppvObjOut = static_cast<ISnapinHelp2 *>(this);
        ExternalAddRef();
    }
    else if (IID_IMMCRemote == riid)
    {
        *ppvObjOut = static_cast<IMMCRemote *>(this);
        ExternalAddRef();
    }
    else
        hr = CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\stub_mmc_i.c ===
#include <mmc_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkeys.h ===
//=--------------------------------------------------------------------------=
// sortkeys.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSortKeys class definition - implements SortKeys collection
//
//=--------------------------------------------------------------------------=

#ifndef _SORTKEYS_DEFINED_
#define _SORTKEYS_DEFINED_

#include "collect.h"
#include "view.h"

class CSortKeys : public CSnapInCollection<ISortKey, SortKey, ISortKeys>
{
    protected:
        CSortKeys(IUnknown *punkOuter);
        ~CSortKeys();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISortKeys
        BSTR_PROPERTY_RW(CSortKeys, ColumnSetID, DISPID_SORTKEYS_COLUMN_SET_ID);
        STDMETHOD(Add)(VARIANT   Index,
                       VARIANT   Key,
                       VARIANT   Column,
                       VARIANT   SortOrder,
                       VARIANT   SortIcon,
                       SortKey **ppSortKey);
        STDMETHOD(Persist)();

    // Public utility methods

    public:

        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CView *m_pView; // back ptr to owning view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SortKeys,           // name
                                &CLSID_SortKeys,    // clsid
                                "SortKeys",         // objname
                                "SortKeys",         // lblname
                                &CSortKeys::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ISortKeys,     // dispatch IID
                                NULL,               // no events IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _SORTKEYS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitem.h ===
//=--------------------------------------------------------------------------=
// spanitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItem class definition - implements ScopePaneItem object
//
//=--------------------------------------------------------------------------=

#ifndef _SPANITEM_DEFINED_
#define _SPANITEM_DEFINED_

#include "dataobj.h"
#include "scopitem.h"
#include "spanitms.h"
#include "resviews.h"
#include "resview.h"

class CScopeItem;
class CScopePaneItems;
class CResultView;

class CScopePaneItem : public CSnapInAutomationObject,
                       public IScopePaneItem
{
    private:
        CScopePaneItem(IUnknown *punkOuter);
        ~CScopePaneItem();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopePaneItem
        BSTR_PROPERTY_RW(CScopePaneItem,        Name,                       DISPID_SCOPEPANEITEM_NAME);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      Index,                      long, DISPID_SCOPEPANEITEM_INDEX);
        BSTR_PROPERTY_RW(CScopePaneItem,        Key,                        DISPID_SCOPEPANEITEM_KEY);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ScopeItem,                  ScopeItem, IScopeItem, DISPID_SCOPEPANEITEM_SCOPEITEM);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      ResultViewType,             SnapInResultViewTypeConstants, DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE);
        BSTR_PROPERTY_RW(CScopePaneItem,        DisplayString,              DISPID_SCOPEPANEITEM_DISPLAY_STRING);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      HasListViews,               VARIANT_BOOL, DISPID_SCOPEPANEITEM_HAS_LISTVIEWS);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ResultView,                 ResultView, IResultView, DISPID_SCOPEPANEITEM_RESULTVIEW);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ResultViews,                ResultViews, IResultViews, DISPID_SCOPEPANEITEM_RESULTVIEWS);
        BSTR_PROPERTY_RW(CScopePaneItem,        ColumnSetID,                DISPID_SCOPEPANEITEM_COLUMN_SET_ID);

        COCLASS_PROPERTY_RO(CScopePaneItem,     Parent,                     ScopePaneItems, IScopePaneItems, DISPID_SCOPEPANEITEM_PARENT);
        VARIANTREF_PROPERTY_RW(CScopePaneItem,  Tag,                        DISPID_SCOPEPANEITEM_TAG);

        STDMETHOD(DisplayNewResultView)(BSTR DisplayString, 
                                        SnapInResultViewTypeConstants ViewType);

        STDMETHOD(DisplayMessageView)(BSTR                               TitleText,
                                      BSTR                               BodyText,
                                      SnapInMessageViewIconTypeConstants IconType);

    // Public utility methods

        BOOL IsStaticNode() { return m_fIsStatic; }
        void SetStaticNode() { m_fIsStatic = TRUE; }

        void SetSelected(BOOL fSelected) { m_fvarSelected = fSelected ? VARIANT_TRUE : VARIANT_FALSE; }

        void SetSnapIn(CSnapIn *pSnapIn);
        void SetScopeItem(CScopeItem *pScopeItem);
        CScopeItem *GetScopeItem() { return m_pScopeItem; }
        void SetScopeItemDef(IScopeItemDef *piScopeItemDef);

        void SetResultView(CResultView *pResultView);
        CResultView *GetResultView() { return m_pResultView; }
        HRESULT DestroyResultView();

        CResultViews *GetResultViews() { return m_pResultViews; }

        LPOLESTR GetActualDisplayString() { return m_pwszActualDisplayString; }
        SnapInResultViewTypeConstants GetActualResultViewType() { return m_ActualResultViewType; }

        void SetDefaultResultViewType(SnapInResultViewTypeConstants Type) { m_DefaultResultViewType = Type; }
        HRESULT SetDefaultDisplayString(BSTR bstrString);

        BSTR GetDisplayString() { return m_bstrDisplayString; }

        void SetParent(CScopePaneItems *pScopePaneItems);
        CScopePaneItems *GetParent() { return m_pScopePaneItems; }

        HRESULT DetermineResultView();
        BOOL HasListViews() { return VARIANTBOOL_TO_BOOL(m_HasListViews); }

        HRESULT SetPreferredTaskpad(BSTR bstrViewName);

        HRESULT CreateNewResultView(long          lViewOptions,
                                    IResultView **ppiResultView);

        void SetActive(BOOL fActive) { m_fActive = fActive; }
        BOOL Active() { return m_fActive; }

        BSTR GetColumnSetID() { return m_bstrColumnSetID; }

        long GetIndex() { return m_Index; }

        HRESULT OnListViewSelected();


    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT DetermineActualResultViewType();
        HRESULT GetDefaultViewInfo();
        HRESULT SetViewInfoFromDefaults();
        HRESULT CloneListView(IListViewDef *piListViewDef);
        HRESULT CloneTaskpadView(ITaskpadViewDef *piTaskpadViewDef);
        HRESULT BuildTaskpadDisplayString(IListViewDefs *piListViewDefs);

        BOOL                           m_fIsStatic;      // TRUE=this is static node
        VARIANT_BOOL                   m_fvarSelected;   // not used
        CSnapIn                       *m_pSnapIn;        // back ptr to snap-in
        CScopeItem                    *m_pScopeItem;     // back ptr to ScopeItem
        IScopeItemDef                 *m_piScopeItemDef; // back ptr to ScopeItemDef
        CResultView                   *m_pResultView;    // ScopePaneItem.ResultView
        CResultViews                  *m_pResultViews;   // ScopePaneItem.ResultViews
        CScopePaneItems               *m_pScopePaneItems;//ScopePaneItem.Parent

        // These variables hold the real result view type and display string.
        // When using a predefined
        // result view (ResultView.Type = siPredefined) this says what it really
        // is (e.g. siURLView, siListView etc.)

        SnapInResultViewTypeConstants  m_ActualResultViewType;
        OLECHAR                       *m_pwszActualDisplayString;

        // For nodes defined at design time that have default result view defined

        SnapInResultViewTypeConstants  m_DefaultResultViewType;
        BSTR                           m_bstrDefaultDisplayString;

        BOOL                           m_fActive; // TRUE=scope pane item
                                                  // has active result pane

        // These variables are used to store the message view parameters when
        // the snap-in calls DisplayMessageView. The flag indicates whether we
        // are storing those parameters so that the subsequent call to
        // DetermineResultView() will use them.

        BSTR                                m_bstrTitleText;
        BSTR                                m_bstrBodyText;
        SnapInMessageViewIconTypeConstants  m_IconType;
        BOOL                                m_fHaveMessageViewParams;

        // If the scope item has a taskpad defined at design time that is marked
        // to be used when the user has set "taskpad view preferred" in MMC
        // then this variable contains its name.
        
        BSTR                           m_bstrPreferredTaskpad;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopePaneItem,             // name
                                &CLSID_ScopePaneItem,      // clsid
                                "ScopePaneItem",           // objname
                                "ScopePaneItem",           // lblname
                                NULL,                      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopePaneItem,       // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SPANITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitms.cpp ===
//=--------------------------------------------------------------------------=
// spanitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "spanitms.h"
#include "spanitem.h"
#include "scopnode.h"
#include "tpdvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE


VARTYPE CScopePaneItems::m_rgvtInitialize[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopePaneItems::m_eiInitialize =
{
    DISPID_SCOPEPANEITEMS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};


VARTYPE CScopePaneItems::m_rgvtTerminate[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopePaneItems::m_eiTerminate =
{
    DISPID_SCOPEPANEITEMS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};




VARTYPE CScopePaneItems::m_rgvtGetResultViewInfo[3] =
{
    VT_UNKNOWN,
    VT_I4 | VT_BYREF,
    VT_BSTR | VT_BYREF
};

EVENTINFO CScopePaneItems::m_eiGetResultViewInfo =
{
    DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW_INFO,
    sizeof(m_rgvtGetResultViewInfo) / sizeof(m_rgvtGetResultViewInfo[0]),
    m_rgvtGetResultViewInfo
};

VARTYPE CScopePaneItems::m_rgvtGetResultView[2] =
{
    VT_UNKNOWN,
    VT_VARIANT | VT_BYREF
};

EVENTINFO CScopePaneItems::m_eiGetResultView =
{
    DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW,
    sizeof(m_rgvtGetResultView) / sizeof(m_rgvtGetResultView[0]),
    m_rgvtGetResultView
};






#pragma warning(disable:4355)  // using 'this' in constructor

CScopePaneItems::CScopePaneItems(IUnknown *punkOuter) :
   CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>(
                     punkOuter,
                     OBJECT_TYPE_SCOPEPANEITEMS,
                     static_cast<IScopePaneItems *>(this),
                     static_cast<CScopePaneItems *>(this),
                     CLSID_ScopePaneItem,
                     OBJECT_TYPE_SCOPEPANEITEM,
                     IID_IScopePaneItem,
                     NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CScopePaneItems::InitMemberVariables()
{
    m_piSelectedItem = NULL;
    m_piParent = NULL;
    m_pSnapIn = NULL;
    m_pParentView = NULL;
    m_pStaticNodeItem = NULL;
    m_pSelectedItem = NULL;
}

CScopePaneItems::~CScopePaneItems()
{
    RELEASE(m_piSelectedItem);
    InitMemberVariables();
}

IUnknown *CScopePaneItems::Create(IUnknown * punkOuter)
{
    CScopePaneItems *pScopePaneItems = New CScopePaneItems(punkOuter);
    if (NULL == pScopePaneItems)
    {
        return NULL;
    }
    else
    {
        return pScopePaneItems->PrivateUnknown();
    }
}


HRESULT CScopePaneItems::CreateScopePaneItem
(
    BSTR             bstrName,
    IScopePaneItem **ppiScopePaneItem
)
{
    HRESULT         hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;
    IUnknown       *punkScopePaneItem = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    punkScopePaneItem = CScopePaneItem::Create(NULL);
    if (NULL == punkScopePaneItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopePaneItem->QueryInterface(IID_IScopePaneItem,
                                  reinterpret_cast<void **>(&piScopePaneItem)));

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::AddExisting(
                                                               varIndex,
                                                               varKey,
                                                               piScopePaneItem);
    IfFailGo(hr);
    IfFailGo(piScopePaneItem->put_Name(bstrName));

    IfFailGo(SetObjectHost(piScopePaneItem));

Error:
    if (SUCCEEDED(hr))
    {
        *ppiScopePaneItem = piScopePaneItem;
    }
    else
    {
        QUICK_RELEASE(piScopePaneItem);
        *ppiScopePaneItem = NULL;
    }

    QUICK_RELEASE(punkScopePaneItem);
    RRETURN(hr);
}



HRESULT CScopePaneItems::AddNode
(
    CScopeItem      *pScopeItem,
    CScopePaneItem **ppScopePaneItem
)
{
    HRESULT                        hr = S_OK;
    IScopeNode                    *piScopeNode = NULL;
    CScopeNode                    *pScopeNode = NULL;
    CScopePaneItem                *pScopePaneItem = NULL;
    IScopePaneItem                *piScopePaneItem = NULL;
    IViewDefs                     *piViewDefs = NULL;
    IListViewDefs                 *piListViewDefs = NULL;
    BSTR                           bstrProp = NULL;
    long                           cListViewDefs = 0;
    SnapInResultViewTypeConstants  ResultViewType = siUnknown;

    // Create the scope pane item

    IfFailGo(CreateScopePaneItem(pScopeItem->GetNamePtr(), &piScopePaneItem));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem, &pScopePaneItem));

    // Set its properties from the scope item

    IfFailGo(pScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    // If there is a default view then set the result view type to "predfined"

    if (pScopeItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_DefaultView(&bstrProp));
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        if (NULL != pScopeItem->GetScopeItemDef())
        {
            IfFailGo(pScopeItem->GetScopeItemDef()->get_ViewDefs(&piViewDefs));
            IfFailGo(pScopeItem->GetScopeItemDef()->get_DefaultView(&bstrProp));
        }
    }

    if ( (NULL != bstrProp) && (L'\0' != *bstrProp) )
    {
        ResultViewType = siPreDefined;
    }
    else
    {
        // No default view. Type is unknown and display string is NULL
        ResultViewType = siUnknown;
    }

    pScopePaneItem->SetDefaultResultViewType(ResultViewType);
    IfFailGo(pScopePaneItem->SetDefaultDisplayString(bstrProp));

    FREESTRING(bstrProp);

    // Check if the scope item has a taskpad marked to be used when
    // the user has checked the "taskpad view preferred" option. If there is
    // one the give its name to the ScopePaneItem.

    IfFailGo(SetPreferredTaskpad(piViewDefs, pScopePaneItem));

    // Determine the initial value of HasListViews based on the presence of
    // a design time listview definition. The default is False so only need
    // to set it if there are some listviews.

    if (NULL != piViewDefs)
    {
        IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
        IfFailGo(piListViewDefs->get_Count(&cListViewDefs));
        if (0 != cListViewDefs)
        {
            IfFailGo(piScopePaneItem->put_HasListViews(VARIANT_TRUE));
        }
    }

    if (pScopeItem->IsStaticNode())
    {
        pScopePaneItem->SetStaticNode();
        m_pStaticNodeItem = pScopePaneItem;
    }

    pScopePaneItem->SetSnapIn(m_pSnapIn);
    pScopePaneItem->SetScopeItem(pScopeItem);
    pScopePaneItem->SetParent(this);

    // Set the default ColumnSetID from the scope item's node type. The snap-in
    // may change this at any time but it is best to do so during the
    // ScopePaneItems_Initialize event fired below

    IfFailGo(pScopePaneItem->put_ColumnSetID(pScopeItem->GetScopeNode()->GetNodeTypeGUID()));

    *ppScopePaneItem = pScopePaneItem;

    FireScopePaneItemsInitialize(static_cast<IScopePaneItem *>(pScopePaneItem));

Error:

    // Note: the returned C++ pointer is not AddRef()ed. At this point
    // the collection has the only ref on the scope pane item.

    QUICK_RELEASE(piScopePaneItem);
    QUICK_RELEASE(piScopeNode);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    FREESTRING(bstrProp);
    RRETURN(hr);
}


HRESULT CScopePaneItems::SetPreferredTaskpad
(
    IViewDefs      *piViewDefs,
    CScopePaneItem *pScopePaneItem
)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    long              cTaskpads = 0;
    BOOL              fFound = FALSE;
    BSTR              bstrName = NULL;
    VARIANT_BOOL      fvarUseForPreferred = VARIANT_FALSE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // A code-define scope item won't have any predefined result views

    IfFalseGo(NULL != piViewDefs, S_OK);

    // Check if the scope item has taskpads defined at design time

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->get_Count(&cTaskpads));
    IfFalseGo(0 != cTaskpads, S_OK);

    // Look for the first one marked to be used when the user has set
    // "taskpad view preferred" option in MMC.

    varIndex.vt = VT_I4;
    
    for (varIndex.lVal = 1L;
         (varIndex.lVal <= cTaskpads) && (!fFound);
         varIndex.lVal++)
    {
        IfFailGo(piTaskpadViewDefs->get_Item(varIndex, &piTaskpadViewDef));
        IfFailGo(piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&fvarUseForPreferred));
        if (VARIANT_TRUE == fvarUseForPreferred)
        {
            fFound = TRUE;
            IfFailGo(piTaskpadViewDef->get_Name(&bstrName));
            IfFailGo(pScopePaneItem->SetPreferredTaskpad(bstrName));
        }
        RELEASE(piTaskpadViewDef);
    }

Error:
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    RRETURN(hr);
}



void CScopePaneItems::FireGetResultViewInfo
(
    IScopePaneItem                *piScopePaneItem,
    SnapInResultViewTypeConstants *pViewType,
    BSTR                          *pbstrDisplayString
)
{
    DebugPrintf("Firing ScopePaneItems_FireGetResultViewInfo(%ls, %ld, %ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr(), *pViewType, ((*pbstrDisplayString) == NULL) ? L"" : (*pbstrDisplayString));

    FireEvent(&m_eiGetResultViewInfo,
              piScopePaneItem,
              pViewType,
              pbstrDisplayString);
}



void CScopePaneItems::FireScopePaneItemsInitialize
(
    IScopePaneItem *piScopePaneItem
)
{
    if (NULL != m_pSnapIn)
    {
        DebugPrintf("Firing ScopePaneItems_Initialize(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

        m_pSnapIn->GetScopePaneItems()->FireEvent(&m_eiInitialize, piScopePaneItem);
    }
}

BOOL CScopePaneItems::FireGetResultView
(
    IScopePaneItem *piScopePaneItem,
    VARIANT        *pvarIndex
)
{
    ::VariantInit(pvarIndex);

    DebugPrintf("Firing ScopePaneItems_GetResultView(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

    FireEvent(&m_eiGetResultView, piScopePaneItem, pvarIndex);

    if (VT_EMPTY == pvarIndex->vt)
    {
        return FALSE; // consider this as event not handled
    }
    else
    {
        return TRUE;
    }
}




void CScopePaneItems::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CScopePaneItems::SetParentView(CView *pView)
{
    m_pParentView = pView;

    // We don't AddRef the interface pointer as our lifetime is governed
    // by out parent view and we need to avoid circular refcounting problems.
    // When user code fetches the Parent property, m_iParent will be
    // AddRef()ed before returning it to the VBA caller.

    m_piParent = static_cast<IView *>(pView);
}


void CScopePaneItems::SetSelectedItem(CScopePaneItem *pScopePaneItem)
{
    m_pSelectedItem = pScopePaneItem;
    RELEASE(m_piSelectedItem);
    m_piSelectedItem = static_cast<IScopePaneItem *>(pScopePaneItem);
    m_piSelectedItem->AddRef();
}


STDMETHODIMP CScopePaneItems::Remove(VARIANT Index)
{
    HRESULT     hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;

    // Get the scope pane item. This checks its existence and leaves a ref on it
    // so we can fire ScopePaneItems_Terminate.

    IfFailGo(get_Item(Index, &piScopePaneItem));

    // Remove it from the collection

    hr =  CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::Remove(Index);
    IfFailGo(hr);

    if (NULL != m_pSnapIn)
    {
        // Fire ScopePaneItems_Terminate

        DebugPrintf("Firing ScopePaneItems_Terminate(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

        m_pSnapIn->GetScopePaneItems()->FireEvent(&m_eiTerminate, piScopePaneItem);
    }

Error:
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopePaneItems == riid)
    {
        *ppvObjOut = static_cast<IScopePaneItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitem.cpp ===
//=--------------------------------------------------------------------------=
// spanitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapin.h"
#include "views.h"
#include "spanitem.h"
#include "ocxvdef.h"
#include "urlvdef.h"
#include "tpdvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopePaneItem::CScopePaneItem(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPEPANEITEM,
                           static_cast<IScopePaneItem *>(this),
                           static_cast<CScopePaneItem *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopePaneItem::~CScopePaneItem()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrDisplayString);
    FREESTRING(m_bstrPreferredTaskpad);
    RELEASE(m_piResultView);
    RELEASE(m_piResultViews);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrColumnSetID);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    FREESTRING(m_bstrDefaultDisplayString);
    RELEASE(m_piScopeItemDef);
    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);
    InitMemberVariables();
}

void CScopePaneItem::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piScopeItem = NULL;
    m_ResultViewType = siUnknown;
    m_bstrDisplayString = NULL;
    m_HasListViews = VARIANT_FALSE;
    m_piResultView = NULL;
    m_piResultViews = NULL;
    m_fvarSelected = VARIANT_FALSE;
    m_piParent = NULL;

    ::VariantInit(&m_varTag);

    m_bstrColumnSetID = NULL;
    m_fIsStatic = FALSE;
    m_pSnapIn = NULL;
    m_pScopeItem = NULL;
    m_pResultView = NULL;
    m_pResultViews = NULL;
    m_pScopePaneItems = NULL;
    m_ActualResultViewType = siUnknown;
    m_pwszActualDisplayString = NULL;
    m_DefaultResultViewType = siUnknown;
    m_bstrDefaultDisplayString = NULL;
    m_bstrPreferredTaskpad = NULL;
    m_piScopeItemDef = NULL;
    m_fActive = FALSE;
    m_bstrTitleText = NULL;
    m_bstrBodyText = NULL;
    m_IconType = siIconNone;
    m_fHaveMessageViewParams = FALSE;
}

IUnknown *CScopePaneItem::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopePaneItem = NULL;
    IUnknown *punkResultViews = NULL;

    CScopePaneItem *pScopePaneItem = New CScopePaneItem(punkOuter);

    IfFalseGo(NULL != pScopePaneItem, SID_E_OUTOFMEMORY);
    punkScopePaneItem = pScopePaneItem->PrivateUnknown();

    punkResultViews = CResultViews::Create(NULL);
    IfFalseGo(NULL != punkResultViews, SID_E_OUTOFMEMORY);
    IfFailGo(punkResultViews->QueryInterface(IID_IResultViews,
                                  reinterpret_cast<void **>(&pScopePaneItem->m_piResultViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkResultViews, &pScopePaneItem->m_pResultViews));
    pScopePaneItem->m_pResultViews->SetScopePaneItem(pScopePaneItem);

Error:
    QUICK_RELEASE(punkResultViews);
    if (FAILED(hr))
    {
        RELEASE(punkScopePaneItem);
    }
    return punkScopePaneItem;
}


void CScopePaneItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pResultViews->SetSnapIn(pSnapIn);
}

void CScopePaneItem::SetScopeItem(CScopeItem *pScopeItem)
{
    m_pScopeItem = pScopeItem;
    m_piScopeItem = static_cast<IScopeItem *>(pScopeItem);
}


void CScopePaneItem::SetResultView(CResultView *pResultView)
{
    m_pResultView = pResultView;
    RELEASE(m_piResultView);
    m_piResultView = static_cast<IResultView *>(pResultView);
    m_piResultView->AddRef();
}


void CScopePaneItem::SetParent(CScopePaneItems *pScopePaneItems)
{
    m_pScopePaneItems = pScopePaneItems;
    m_piParent = static_cast<IScopePaneItems *>(pScopePaneItems);
}

void CScopePaneItem::SetScopeItemDef(IScopeItemDef *piScopeItemDef)
{
    RELEASE(m_piScopeItemDef);
    piScopeItemDef->AddRef();
    m_piScopeItemDef = piScopeItemDef;
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::DetermineResultView
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Fires GetResultViewInfo. If handled then sets ResultViewType
// and ResultViewDisplayString from returned values, creates a new result view
// of this type and sets ResultView.
//
// If not handled and the ResultViews collection is not empty then fires
// GetResultView.
//
// If not handled or the collection is empty then uses current ResultViewType
// and ResultViewDisplayString, creates a new result view of this type and sets
// ResultView.
//
// If the current ResultViewType is siUnknown then it is set to siListView.
// This means that if the VB dev does not set anything at design time or runtime
// the snap-in will display a listview.
//
// If a new ResultView is created then ResultViews_Initialize is fired. 
//
// If this function returns successfully then ResultViewType,
// ResultViewDisplayString, and ResultView have valid values.

HRESULT CScopePaneItem::DetermineResultView()
{
    HRESULT                        hr = S_OK;
    SnapInResultViewTypeConstants  ViewTypeCopy = siUnknown;
    BSTR                           bstrDisplayStringCopy = NULL;
    long                           cResultViews = 0;
    IResultView                   *piResultView = NULL;
    BOOL                           fEventHandled = FALSE;
    BOOL                           fNeedNewResultView = TRUE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get the default result view type and display string. See the comment
    // header for SetViewInfoFromDefaults() for an explanation of how defaults
    // can be set. If defaults were not set then a code-defined listview is used
    // i.e. ResultViewType=siListView and DisplayString=NULL. Either way, upon
    // return from this call m_ResultViewType and m_bstrDisplayString will be
    // set correctly.

    IfFailGo(SetViewInfoFromDefaults());

    // Give the snap-in a chance to examine and potentially change the result 
    // view type and display string by firing ScopePaneItems_GetResultViewInfo.
    // Set the passed in parameters to the defaults. Make a copy of the defaults
    // so we can check whether they were changed.

    ViewTypeCopy = m_ResultViewType;
    if (NULL != m_bstrDisplayString)
    {
        // Note that we can't just copy the pointer because:
        // 1) We don't know whether VBA might optimize the replacement of
        // an out parameters by reusing the same space when it fits.
        // 2) oleaut32.dll does BSTR memory caching and it could easily
        // reuse the same memory if VBA calls SysFreeString() followed by
        // SysAllocString() for something that fits.

        bstrDisplayStringCopy = ::SysAllocString(m_bstrDisplayString);
        if (NULL == bstrDisplayStringCopy)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    m_pSnapIn->GetScopePaneItems()->FireGetResultViewInfo(
                                            static_cast<IScopePaneItem *>(this),
                                            &m_ResultViewType,
                                            &m_bstrDisplayString);

    // If the snap-in set the display string to an empty string ("") then
    // free that string and change it to NULL.

    if (NULL != m_bstrDisplayString)
    {
        if (L'\0' == *m_bstrDisplayString)
        {
            FREESTRING(m_bstrDisplayString);
        }
    }

    // Determine whether the snap-in handled the event i.e. changed the view
    // type or display string
    
    if (ViewTypeCopy != m_ResultViewType)
    {
        fEventHandled = TRUE;
    }
    else
    {
        if (NULL == bstrDisplayStringCopy)
        {
            if (NULL != m_bstrDisplayString)
            {
                fEventHandled = TRUE;
            }
        }
        else // display string before event was non-NULL
        {
            if (NULL == m_bstrDisplayString) // Did snap-in change it to NULL?
            {
                fEventHandled = TRUE;
            }
            else if (::wcscmp(m_bstrDisplayString, bstrDisplayStringCopy) != 0)
            {
                // string contents have changed
                fEventHandled = TRUE;
            }
        }
    }

    if (!fEventHandled)
    {
        // GetResultViewInfo was not handled. If there are any existing result
        // views then try ScopePaneItems_GetResultView to allow the snap-in to
        // choose one for reuse.

        IfFailGo(m_piResultViews->get_Count(&cResultViews));
        if (0 != cResultViews)
        {
            fEventHandled = m_pSnapIn->GetScopePaneItems()->FireGetResultView(
                                            static_cast<IScopePaneItem *>(this),
                                            &varIndex);
            if (fEventHandled)
            {
                // Event was handled. Check for valid index. If not then use
                // current type and display string.

                hr = m_piResultViews->get_Item(varIndex, reinterpret_cast<ResultView **>(&piResultView));
                EXCEPTION_CHECK_GO(hr);

                fNeedNewResultView = FALSE;
            }
        }
    }

    if (fNeedNewResultView)
    {
        // We need a new result view. Create one and set its type and
        // display string from what we just established above.

        IfFailGo(CreateNewResultView(MMC_VIEW_OPTIONS_NONE, &piResultView));
    }
    else
    {
        // We're using an existing result view. Update the ScopePaneItem's
        // view type, display string, actual view type, and actual display string

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &m_pResultView));

        IfFailGo(piResultView->get_Type(&m_ResultViewType));
        FREESTRING(m_bstrDisplayString);
        IfFailGo(piResultView->get_DisplayString(&m_bstrDisplayString));

        m_ActualResultViewType = m_pResultView->GetActualType();

        if (NULL != m_pwszActualDisplayString)
        {
            ::CoTaskMemFree(m_pwszActualDisplayString);
            m_pwszActualDisplayString = NULL;
        }

        if (NULL != m_pResultView->GetActualDisplayString())
        {
            IfFailGo(::CoTaskMemAllocString(m_pResultView->GetActualDisplayString(),
                                            &m_pwszActualDisplayString));
        }
    }

    RELEASE(m_piResultView);
    m_piResultView = piResultView;
    piResultView = NULL;

Error:
    ASSERT(NULL != m_pResultView, "CScopePaneItem::DetermineResultView did not set a current result view");

    FREESTRING(bstrDisplayStringCopy);
    QUICK_RELEASE(piResultView);
    (void)::VariantClear(&varIndex);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CScopePaneItem::CreateNewResultView
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long          lViewOptions  [in]  For listviews, any MMC_VIEW_OPTIONS_XXX
//                                     or MMC_VIEW_OPTIONS_NONE
//   IResultView **ppiResultView [out] new ResultView object returned here
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds a new ResultView to ScopePaneItem.ResultViews, set its
// display string and type, sets its actual string and type, sets
// ResultView.ListView properties from the view options, makes it the
// current ResultView (i.e. sets m_pResultView pointing to it), and fires
// ResultViews_Initialize. Returns IResultView on the new ResultView.
//

HRESULT CScopePaneItem::CreateNewResultView(long lViewOptions, IResultView **ppiResultView)
{
    HRESULT      hr = S_OK;
    IResultView *piResultView = NULL;
    BSTR         bstrDefaultItemTypeGUID = NULL;
    WCHAR        wszDefaultItemTypeGUID[64] = L"";
    GUID         guidDefaultItemType = GUID_NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    IfFailGo(m_piResultViews->Add(varUnspecified, varUnspecified, &piResultView));
    IfFailGo(piResultView->put_Type(m_ResultViewType));
    IfFailGo(piResultView->put_DisplayString(m_bstrDisplayString));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &m_pResultView));
    m_pResultView->SetSnapIn(m_pSnapIn);
    m_pResultView->SetScopePaneItem(this);

    // At this point the result view type is set but it may be predefined
    // at design time. Now Determine the real result view type and, if it's
    // a listview or taskpad, initialize ResultView.Listview or
    // ResultView.Taskpad from the design time settings (e.g. column header
    // definitions, images, tasks, etc).

    IfFailGo(DetermineActualResultViewType());

    // If this is a listview or a listpad then set HasListViews so the View
    // object can determine whether to allow listview options on the view menu.

    if ( (siListView == m_ActualResultViewType) ||
         (siListpad == m_ActualResultViewType) )
    {
        m_HasListViews = VARIANT_TRUE;
    }

    // Tell the ResultView the truth about its real nature

    m_pResultView->SetActualType(m_ActualResultViewType);
    m_pResultView->SetActualDisplayString(m_pwszActualDisplayString);

    // Set properties based on view options

    if ( (lViewOptions & MMC_VIEW_OPTIONS_MULTISELECT) != 0 )
    {
        m_pResultView->GetListView()->SetMultiSelect(TRUE);
    }

    if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) != 0 )
    {
        m_pResultView->GetListView()->SetVirtual(TRUE);
    }

    // If this is a code-defined listview then give the result view
    // a default item type GUID. The snap-in can always change it, but this
    // will prevent errors if the snap-in decides to access
    // MMCListItem.DynamicExtensions if the item type GUID has not been set by
    // the snap-in and has not been set from a default in a pre-defined listview.

    if ( (siPreDefined != m_ResultViewType) &&
         (siListView == m_ActualResultViewType) )
    {
        hr = ::CoCreateGuid(&guidDefaultItemType);
        EXCEPTION_CHECK_GO(hr);

        if (0 == ::StringFromGUID2(guidDefaultItemType, wszDefaultItemTypeGUID,
                                   sizeof(wszDefaultItemTypeGUID) /
                                   sizeof(wszDefaultItemTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        bstrDefaultItemTypeGUID = ::SysAllocString(wszDefaultItemTypeGUID);
        if (NULL == bstrDefaultItemTypeGUID)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(m_pResultView->put_DefaultItemTypeGUID(bstrDefaultItemTypeGUID));
    }
    else if (siMessageView == m_ActualResultViewType)
    {
        // This is a message view. If there are preset parameters from a
        // previous call to DisplayMessageView then set them in
        // ResultView.MessageView.

        if (m_fHaveMessageViewParams)
        {
            // reset the flag so that DisplayMessageView can be used again
            m_fHaveMessageViewParams = FALSE;

            IfFailGo(m_pResultView->GetMessageView()->put_TitleText(m_bstrTitleText));
            FREESTRING(m_bstrTitleText);

            IfFailGo(m_pResultView->GetMessageView()->put_BodyText(m_bstrBodyText));
            FREESTRING(m_bstrBodyText);

            IfFailGo(m_pResultView->GetMessageView()->put_IconType(m_IconType));
        }
    }

    // At this point the new ResultView is fully initialized and we can
    // let the user muck with it in ResultViews_Initialize

    m_pResultView->SetInInitialize(TRUE);
    m_pSnapIn->GetResultViews()->FireInitialize(piResultView);
    m_pResultView->SetInInitialize(FALSE);

Error:
    FREESTRING(bstrDefaultItemTypeGUID);
    if (FAILED(hr))
    {
        QUICK_RELEASE(piResultView);
    }
    else
    {
        *ppiResultView = piResultView;
    }
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CScopePaneItem::SetViewInfoFromDefaults
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// The snap-in may have set ScopePaneItem.ResultViewType and
// ScopePaneItem.ResultViewDisplayString or they may have been set in response
// to a View menu selection. If ResultViewType is siUnknown then we assume that
// it has not been set and we use the default values. Default values are
// assigned at design time by setting the default view on a scope item
// defintion.
// If there is no default value the we use a listview.
//

HRESULT CScopePaneItem::SetViewInfoFromDefaults()
{
    HRESULT      hr = S_OK;
    BSTR         bstrDisplayString = NULL;
    VARIANT_BOOL fvarTaskpadViewPreferred = VARIANT_FALSE;

    // If ResultViewType has been set then use it

    IfFalseGo(siUnknown == m_ResultViewType, S_OK);

    // Dump the old display string. Even if we fail to allocate a new one
    // the NULL will default to a listview.

    FREESTRING(m_bstrDisplayString);
    m_ResultViewType = siListView;

    // Check if the user set the "taskpad view preferred" option in MMC

    IfFailGo(m_pSnapIn->get_TaskpadViewPreferred(&fvarTaskpadViewPreferred));

    // If it is set then and there is a taskpad defined for this
    // scope item that is to be used in this case, then use it.

    if ( (VARIANT_TRUE == fvarTaskpadViewPreferred) &&
         (NULL != m_bstrPreferredTaskpad) )
    {
        bstrDisplayString = m_bstrPreferredTaskpad;
        m_ResultViewType = siPreDefined;
    }
    else if (siUnknown != m_DefaultResultViewType)
    {
        // Not using a taskpad because of the user option.
        // Take default if there is one

        bstrDisplayString = m_bstrDefaultDisplayString;
        m_ResultViewType = m_DefaultResultViewType;
    }
    else
    {
        // There is no default. Use a listview.

        m_ResultViewType = siListView;
    }

    // If there is a display string then set it.

    if (NULL != bstrDisplayString)
    {
        m_bstrDisplayString = ::SysAllocString(bstrDisplayString);
        if (NULL == m_bstrDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


HRESULT CScopePaneItem::SetDefaultDisplayString(BSTR bstrString)
{
    HRESULT hr = S_OK;
    BSTR bstrNewString = NULL;

    if (NULL != bstrString)
    {
        bstrNewString = ::SysAllocString(bstrString);
        if (NULL == bstrNewString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    FREESTRING(m_bstrDefaultDisplayString);
    m_bstrDefaultDisplayString = bstrNewString;

Error:
    RRETURN(hr);
}

HRESULT CScopePaneItem::SetPreferredTaskpad(BSTR bstrViewName)
{
    HRESULT hr = S_OK;
    BSTR bstrNewString = NULL;

    if (NULL != bstrViewName)
    {
        bstrNewString = ::SysAllocString(bstrViewName);
        if (NULL == bstrNewString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    FREESTRING(m_bstrPreferredTaskpad);
    m_bstrPreferredTaskpad = bstrNewString;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::DetermineActualResultViewType
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Upon entry to this function the ResultViewType and ResultViewDisplayString
// properties are set both in the ScopePaneItem and in the current result view
// pointed to by m_pResultView.
//
// If the result view type is predefined then the definition must be read
// and the actual type and display string returned.
//
// If the type is a listview and the type came from a design time setting,
// the ListViewDef.ListView is cloned into ResultView.ListView.
//
// The same is done for a taskpad into ResultView.Taskpad
// 
// For OCX and URL views only the type and ProgID/URL are needed from the
// the design time definition.
//
// In all cases, this function sets m_ActualResultViewType and
// m_pwszActualDisplayString. 


HRESULT CScopePaneItem::DetermineActualResultViewType()
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;

    IListViewDefs    *piListViewDefs = NULL;
    IListViewDef     *piListViewDef = NULL;

    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDef      *piOCXViewDef = NULL;
    COCXViewDef      *pOCXViewDef = NULL;
    CLSID             clsidOCX = CLSID_NULL;

    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDef      *piURLViewDef = NULL;
    CURLViewDef      *pURLViewDef = NULL;

    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    CTaskpadViewDef  *pTaskpadViewDef = NULL;

    BSTR              bstrDisplayString = NULL;
    VARIANT_BOOL      fvarAlwaysCreateNewOCX = VARIANT_FALSE;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varTag;
    ::VariantInit(&varTag);

    // If the view is not predefined then use the type and display string as is
    // for all but message view. In that case we need to set the actual display
    // string to MMC's message view OCX CLSID.

    if (siPreDefined != m_ResultViewType)
    {
        m_ActualResultViewType = m_ResultViewType;

        if (siMessageView == m_ResultViewType)
        {
            hr = ::StringFromCLSID(CLSID_MessageView,
                                   &m_pwszActualDisplayString);
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            IfFailGo(::CoTaskMemAllocString(m_bstrDisplayString,
                                            &m_pwszActualDisplayString));
        }
        return S_OK;
    }

    // The view is predefined. Need to get its definition.

    IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_ViewDefs(&piViewDefs));

    // It could be any type of view so try each one.

    varKey.vt = VT_BSTR;
    varKey.bstrVal = m_bstrDisplayString;

    // Dump the old actual view info and default to listview.

    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
        m_pwszActualDisplayString = NULL;
    }
    m_ActualResultViewType = siListView;

    // Check for a list view

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));

    hr = piListViewDefs->get_Item(varKey, &piListViewDef);
    if (SUCCEEDED(hr))
    {
        // It's a listview. Type and display string are already set but
        // we need to clone the listview configuration set at design time.
        IfFailGo(CloneListView(piListViewDef));
        goto Error;
    }
    else 
    {
        // Make sure the error is "element not found" before trying other types
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check for an OCX view

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));

    hr = piOCXViewDefs->get_Item(varKey, &piOCXViewDef);
    if (SUCCEEDED(hr))
    {
        IfFailGo(piOCXViewDef->get_ProgID(&bstrDisplayString));

        hr = ::CLSIDFromProgID(bstrDisplayString, &clsidOCX);
        EXCEPTION_CHECK_GO(hr);

        hr = ::StringFromCLSID(clsidOCX, &m_pwszActualDisplayString);
        EXCEPTION_CHECK_GO(hr);

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDef, &pOCXViewDef));
        IfFailGo(pOCXViewDef->SetActualDisplayString(m_pwszActualDisplayString));

        IfFailGo(piOCXViewDef->get_AlwaysCreateNewOCX(&fvarAlwaysCreateNewOCX));
        m_pResultView->SetAlwaysCreateNewOCX(fvarAlwaysCreateNewOCX);

        IfFailGo(piOCXViewDef->get_Tag(&varTag));
        IfFailGo(m_pResultView->put_Tag(varTag));

        m_ActualResultViewType = siOCXView;
        goto Error;
    }
    else 
    {
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check if default is a URL view

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));

    hr = piURLViewDefs->get_Item(varKey, &piURLViewDef);
    if (SUCCEEDED(hr))
    {
        IfFailGo(piURLViewDef->get_URL(&bstrDisplayString));
        IfFailGo(::CoTaskMemAllocString(bstrDisplayString,
                                        &m_pwszActualDisplayString));

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDef, &pURLViewDef));
        IfFailGo(pURLViewDef->SetActualDisplayString(m_pwszActualDisplayString));

        IfFailGo(piURLViewDef->get_Tag(&varTag));
        IfFailGo(m_pResultView->put_Tag(varTag));

        m_ActualResultViewType = siURLView;
        goto Error;
    }
    else 
    {
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check for a taskpad

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));

    hr = piTaskpadViewDefs->get_Item(varKey, &piTaskpadViewDef);
    if (SUCCEEDED(hr))
    {
        // It's a taskpad. We need to clone the taskpad configuration set
        // at design time.
        IfFailGo(CloneTaskpadView(piTaskpadViewDef));

        IfFailGo(BuildTaskpadDisplayString(piListViewDefs));

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDef, &pTaskpadViewDef));
        IfFailGo(pTaskpadViewDef->SetActualDisplayString(m_pwszActualDisplayString));
    }
    else 
    {
        // Make sure the error is "element not found" before trying other types
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piOCXViewDef);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piURLViewDef);
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    RRETURN(hr);
}


HRESULT CScopePaneItem::CloneListView(IListViewDef *piListViewDef)
{
    HRESULT             hr = S_OK;
    IMMCListView       *piMMCListViewDT = NULL;
    IMMCListView       *piMMCListViewRT = NULL;
    BSTR                bstrItemTypeGUID = NULL;

    // Get the design time and runtime listview objects. Clone the runtime
    // from the design time.

    IfFailGo(piListViewDef->get_ListView(&piMMCListViewDT));
    IfFailGo(m_pResultView->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListViewRT)));
    IfFailGo(::CloneObject(piMMCListViewDT, piMMCListViewRT));

    IfFailGo(piListViewDef->get_DefaultItemTypeGUID(&bstrItemTypeGUID));
    IfFailGo(m_pResultView->put_DefaultItemTypeGUID(bstrItemTypeGUID));

Error:
    QUICK_RELEASE(piMMCListViewDT);
    QUICK_RELEASE(piMMCListViewRT);
    FREESTRING(bstrItemTypeGUID);
    RRETURN(hr);
}



HRESULT CScopePaneItem::CloneTaskpadView(ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT   hr = S_OK;
    ITaskpad *piTaskpadDT = NULL;
    ITaskpad *piTaskpadRT = NULL;

    // Get the design time and runtime Taskpadview objects

    IfFailGo(piTaskpadViewDef->get_Taskpad(&piTaskpadDT));
    IfFailGo(m_pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpadRT)));
    IfFailGo(::CloneObject(piTaskpadDT, piTaskpadRT));

Error:
    QUICK_RELEASE(piTaskpadDT);
    QUICK_RELEASE(piTaskpadRT);
    RRETURN(hr);
}



HRESULT CScopePaneItem::BuildTaskpadDisplayString(IListViewDefs *piListViewDefs)
{
    HRESULT                     hr = S_OK;
    ITaskpad                   *piTaskpad = NULL;
    IListViewDef               *piListViewDef = NULL;
    OLECHAR                    *pwszMMCExePath = NULL;
    OLECHAR                    *pwszHash = NULL;
    size_t                      cchMMCExePath = 0;
    size_t                      cchString = 0;
    BSTR                        bstrURL = NULL;
    BSTR                        bstrName = NULL;
    size_t                      cchName = 0;
    size_t                      cchListpad = 0;
    WCHAR                      *pwszListpadHtm = NULL;
    SnapInTaskpadTypeConstants  TaskpadType = Default;
    SnapInListpadStyleConstants ListpadStyle = siVertical;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Determine the taskpad type so that we can build the display string.

    IfFailGo(m_pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Type(&TaskpadType));

    if ( (Default == TaskpadType) || (Listpad == TaskpadType) )
    {
        // Using an MMC template.
        // The URL needs to be
        // res://<MMC.EXE full path>/<template name>#<taskpad name>

        // Get the EXE path as a wide string
        
        pwszMMCExePath = m_pSnapIn->GetMMCExePathW();

        cchMMCExePath = ::wcslen(pwszMMCExePath);

        // Get the taskpad name to follow the "#"

        IfFailGo(piTaskpad->get_Name(&bstrName));

        cchName = ::wcslen(bstrName);

        // Determine the buffer size needed and allocate it. Add 1 for the "#"
        // and 1 for the terminating null.

        cchString = CCH_RESURL + cchMMCExePath + cchName + 2;

        if (Default == TaskpadType)
        {
            cchString += CCH_DEFAULT_TASKPAD;
            m_ActualResultViewType = siTaskpad;
        }
        else
        {
            IfFailGo(piTaskpad->get_ListpadStyle(&ListpadStyle));

            if (siVertical == ListpadStyle)
            {
                cchString += CCH_LISTPAD;
                cchListpad = CCH_LISTPAD;
                pwszListpadHtm = LISTPAD;
            }
            else
            {
                cchString += CCH_LISTPAD_HORIZ;
                cchListpad = CCH_LISTPAD_HORIZ;
                pwszListpadHtm = LISTPAD_HORIZ;
            }
            m_ActualResultViewType = siListpad;
        }

        m_pwszActualDisplayString =
                          (OLECHAR *)::CoTaskMemAlloc(cchString * sizeof(WCHAR));

        if (NULL == m_pwszActualDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        // Concatenate the pieces ("res://", path, .htm, "#", and taskpad name)

        ::memcpy(m_pwszActualDisplayString, RESURL, CCH_RESURL * sizeof(WCHAR));

        ::memcpy(&m_pwszActualDisplayString[CCH_RESURL], pwszMMCExePath,
                 cchMMCExePath * sizeof(WCHAR));

        if (Default == TaskpadType)
        {
            ::memcpy(&m_pwszActualDisplayString[CCH_RESURL + cchMMCExePath],
                     DEFAULT_TASKPAD,
                     CCH_DEFAULT_TASKPAD * sizeof(WCHAR));

            pwszHash = &m_pwszActualDisplayString[CCH_RESURL +
                                                  cchMMCExePath +
                                                  CCH_DEFAULT_TASKPAD];
        }
        else
        {
            ::memcpy(&m_pwszActualDisplayString[CCH_RESURL + cchMMCExePath],
                     pwszListpadHtm,
                     cchListpad * sizeof(WCHAR));

            pwszHash = &m_pwszActualDisplayString[CCH_RESURL +
                                                  cchMMCExePath +
                                                  cchListpad];
        }

        *pwszHash = L'#';

        // Concatenate the name (along with its terminating null)
        
        ::memcpy(pwszHash + 1, bstrName, (cchName + 1) * sizeof(WCHAR));
    }
    else // custom taskpad
    {
        // Get the URL for the taskpad template as that is the display string

        IfFailGo(piTaskpad->get_URL(&bstrURL));
        IfFailGo(m_pSnapIn->ResolveResURL(bstrURL, &m_pwszActualDisplayString));
        m_ActualResultViewType = siCustomTaskpad;
    }

    // If not a listpad then we're done
    
    IfFalseGo(Listpad == TaskpadType, S_OK);

    // It is a listpad, If there is an associated listview definition then
    // we node to clone it into ResultView.ListView just as we would for a
    // listview.

    IfFailGo(piTaskpad->get_ListView(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Assume a NULL or zero length string means no listview

    IfFalseGo(ValidBstr(varKey.bstrVal), S_OK);

    // Get the listview definition

    hr = piListViewDefs->get_Item(varKey, &piListViewDef);
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_UNKNOWN_LISTVIEW;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    // Clone it into ResultView.ListView

    IfFailGo(CloneListView(piListViewDef));
    
Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piListViewDef);
    FREESTRING(bstrName);
    FREESTRING(bstrURL);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



HRESULT CScopePaneItem::DestroyResultView()
{
    HRESULT hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFalseGo(NULL != m_pResultView, S_OK);

    varIndex.vt = VT_I4;

    IfFailGo(m_piResultView->get_Index(&varIndex.lVal));
    IfFailGo(m_piResultViews->Remove(varIndex));

    m_pSnapIn->GetResultViews()->FireTerminate(m_piResultView);

    RELEASE(m_piResultView);

    m_pResultView = NULL;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::OnListViewSelected()
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// If a non-listview is in the result pane for this scope item and the
// user selects one of the listviews from the View menu (small, large,
// list, detailed, filtered), then CContextMenu::Command() will call this
// function. This function searches for the first pre-defined listview for the
// scope item. If found is sets m_bstrDisplayString to the listview name and
// m_ResultViewType to siPredefined. If the scope item does not have any
// predefined listviews then it sets m_bstrDisplayString to NULL and 
// m_ResultViewType to siListView, which indicates a code-defined listview.
// During MMC's subsequent IComponent::GetResultViewType() call, CView will
// call DetermineResultView() and that function will use the values set here.
//
HRESULT CScopePaneItem::OnListViewSelected()
{
    HRESULT        hr = S_OK;
    IScopeItemDef *piScopeItemDef = NULL; // not AddRef()ed
    IViewDefs     *piViewDefs = NULL;
    IListViewDefs *piListViewDefs = NULL;
    IListViewDef  *piListViewDef = NULL;
    long           cListViewDefs = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Set up for a code-defined listview. If we find a predefined listview then
    // we'll change it.

    FREESTRING(m_bstrDisplayString);
    m_ResultViewType = siListView;

    // If this is the static node then get its view definitions
    if (m_fIsStatic)
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        // Not the static node.
        // Is there a design time definition for this scope item?

        piScopeItemDef = m_pScopeItem->GetScopeItemDef();
        IfFalseGo(NULL != piScopeItemDef, S_OK);

        // Get the listview definitions

        IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
    }

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));

    // Check that there is at least one listview defined
    
    IfFailGo(piListViewDefs->get_Count(&cListViewDefs));
    IfFalseGo(0 != cListViewDefs, S_OK);

    // Get the name of the listview and set it as the display string.
    // Set the type to siPreDefined.
    
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
    IfFailGo(piListViewDef->get_Name(&m_bstrDisplayString));

    m_ResultViewType = siPreDefined;
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IScopePaneItem Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CScopePaneItem::DisplayNewResultView
(
    BSTR                          DisplayString, 
    SnapInResultViewTypeConstants ViewType
)
{
    HRESULT    hr = S_OK;
    HSCOPEITEM hsi = NULL;

    // Set our display string and view type from parameters

    IfFailGo(SetBstr(DisplayString, &m_bstrDisplayString,
                     DISPID_SCOPEPANEITEM_DISPLAY_STRING));

    IfFailGo(SetSimpleType(ViewType, &m_ResultViewType,
                           DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE));

    // Crawl up the hierarchy to the view that owns this scope pane item
    // and get its IConsole2 to reselect the scope item.

    hsi = m_pScopeItem->GetScopeNode()->GetHSCOPEITEM();

    hr = m_pScopePaneItems->GetParentView()->GetIConsole2()->SelectScopeItem(hsi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopePaneItem::DisplayMessageView
(
    BSTR                               TitleText,
    BSTR                               BodyText,
    SnapInMessageViewIconTypeConstants IconType
)
{
    HRESULT    hr = S_OK;

    // Store the parameters so that we can set them when the new result view
    // is created.

    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);

    if (NULL == TitleText)
    {
        TitleText = L"";
    }
    
    if (NULL == BodyText)
    {
        BodyText = L"";
    }

    m_bstrTitleText = ::SysAllocString(TitleText);
    m_bstrBodyText = ::SysAllocString(BodyText);
    if ( (NULL == m_bstrTitleText) || (NULL == m_bstrBodyText) )
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    m_IconType = IconType;
    m_fHaveMessageViewParams = TRUE;

    // Initiate display of the new result view.

    IfFailGo(DisplayNewResultView(NULL, siMessageView));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopePaneItem == riid)
    {
        *ppvObjOut = static_cast<IScopePaneItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItem::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piResultViews));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\strtable.cpp ===
//=--------------------------------------------------------------------------=
// strtable.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCStringTable class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "strtable.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCStringTable::CMMCStringTable(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_STRINGTABLE,
                           static_cast<IMMCStringTable *>(this),
                           static_cast<CMMCStringTable *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();

    // This class makes the assumption that an MMC_STRING_ID (typedefed as a
    // DWORD in mmc.idl) is the same size as a long. The following code checks
    // that assumption and ASSERTS if it is not true.

    ASSERT(sizeof(DWORD) == sizeof(long), "CMMCStringTable will not work because sizeof(DWORD) != sizeof(long)");
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCStringTable::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCStringTable = NULL;

    CMMCStringTable *pMMCStringTable = New CMMCStringTable(punkOuter);

    if (NULL == pMMCStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkMMCStringTable = pMMCStringTable->PrivateUnknown();

Error:
    return punkMMCStringTable;
}



CMMCStringTable::~CMMCStringTable()
{
    RELEASE(m_piStringTable);
    InitMemberVariables();
}

void CMMCStringTable::InitMemberVariables()
{
    m_piStringTable = NULL;
}



void CMMCStringTable::SetIStringTable(IStringTable *piStringTable)
{
    RELEASE(m_piStringTable);
    if (NULL != piStringTable)
    {
        piStringTable->AddRef();
    }
    m_piStringTable = piStringTable;
}


//=--------------------------------------------------------------------------=
//                      IMMCStringTable Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CMMCStringTable::get_Item(long ID, BSTR *pbstrString)
{
    HRESULT  hr = S_OK;
    ULONG    cchString = 0;
    WCHAR   *pwszString = NULL;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the string's length and allocate a buffer. MMC returns the
    // length in characters without the terminating null.

    hr = m_piStringTable->GetStringLength(static_cast<MMC_STRING_ID>(ID),
                                          &cchString);
    EXCEPTION_CHECK_GO(hr);

    pwszString = (WCHAR *)::CtlAllocZero( (cchString + 1) * sizeof(OLECHAR) );
    if (NULL == pwszString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->GetString(static_cast<MMC_STRING_ID>(ID),
                                    cchString + 1, pwszString, NULL);
    EXCEPTION_CHECK_GO(hr);

    *pbstrString = ::SysAllocString(pwszString);
    if (NULL == *pbstrString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszString)
    {
        ::CtlFree(pwszString);
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::get__NewEnum(IUnknown **ppunkEnum)
{
    HRESULT           hr = S_OK;
    CEnumStringTable *pEnumStringTable = NULL;
    IEnumString      *piEnumString = NULL;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->Enumerate(&piEnumString);
    EXCEPTION_CHECK_GO(hr);

    pEnumStringTable = New CEnumStringTable(piEnumString);

    if (NULL == pEnumStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }


Error:
    QUICK_RELEASE(piEnumString);
    if (FAILED(hr))
    {
        if (NULL != pEnumStringTable)
        {
            delete pEnumStringTable;
        }
        *ppunkEnum = NULL;
    }
    else
    {
        *ppunkEnum = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(pEnumStringTable));
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Add(BSTR String, long *plID)
{
    HRESULT       hr = S_OK;
    MMC_STRING_ID id = 0;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->AddString(static_cast<LPCOLESTR>(String), &id);
    EXCEPTION_CHECK_GO(hr);

    *plID = static_cast<long>(id);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCStringTable::Find(BSTR String, long *plID)
{
    HRESULT       hr = S_OK;
    MMC_STRING_ID id = 0;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->FindString(static_cast<LPCOLESTR>(String), &id);
    EXCEPTION_CHECK_GO(hr);

    *plID = static_cast<long>(id);

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Remove(long ID)
{
    HRESULT hr = S_OK;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->DeleteString(static_cast<MMC_STRING_ID>(ID));
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Clear()
{
    HRESULT hr = S_OK;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->DeleteAllStrings();
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCStringTable::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCStringTable == riid)
    {
        *ppvObjOut = static_cast<IMMCStringTable *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}









//=--------------------------------------------------------------------------=
//                      CEnumStringTable Methods
//=--------------------------------------------------------------------------=

#pragma warning(disable:4355)  // using 'this' in constructor

CEnumStringTable::CEnumStringTable(IEnumString *piEnumString) :
   CSnapInAutomationObject(NULL,
                           OBJECT_TYPE_ENUMSTRINGTABLE,
                           static_cast<IEnumVARIANT *>(this),
                           static_cast<CEnumStringTable *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
    if (NULL != piEnumString)
    {
        piEnumString->AddRef();
    }
    m_piEnumString = piEnumString;
}

#pragma warning(default:4355)  // using 'this' in constructor


CEnumStringTable::~CEnumStringTable()
{
    RELEASE(m_piEnumString);
    InitMemberVariables();
}

void CEnumStringTable::InitMemberVariables()
{
    m_piEnumString = NULL;
}



//=--------------------------------------------------------------------------=
//                        IEnumVariant Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CEnumStringTable::Next
(
    unsigned long   celt,
    VARIANT        *rgvar,
    unsigned long  *pceltFetched
)
{
    HRESULT        hr = S_OK;
    unsigned long  i = 0;
    ULONG          celtFetched = 0; 
    LPOLESTR      *ppStrings = NULL;

    // Initialize result array.

    for (i = 0; i < celt; i++)
    {
        ::VariantInit(&rgvar[i]);
    }

    // Allocate the string pointer array

    ppStrings = (LPOLESTR *)::CtlAllocZero(celt * sizeof(LPOLESTR));
    if (NULL == ppStrings)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the strings from MMC

    hr = m_piEnumString->Next(celt, ppStrings, &celtFetched);
    EXCEPTION_CHECK_GO(hr);

    // Put each string into a BSTR in a VARIANT for return to the snap-in

    for (i = 0; i < celtFetched; i++) 
    {
        rgvar[i].bstrVal = ::SysAllocString(ppStrings[i]);
        if (NULL == rgvar[i].bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        rgvar[i].vt = VT_BSTR;
    }

Error:

    // If we got any strings from MMC then free them and free the array.

    if (NULL != ppStrings)
    {
        for (i = 0; i < celtFetched; i++) 
        {
            if (NULL != ppStrings[i])
            {
                ::CoTaskMemFree(ppStrings[i]);
            }
        }
        ::CtlFree(ppStrings);
    }

    // If we managed to get some strings into BSTRs but something then failed, we
    // need to free the BSTR that were allocated.

    if (FAILED(hr))
    {
        for (i = 0; i < celt; i++)
        {
            (void)::VariantClear(&rgvar[i]);
        }
    }

    // If the caller requested the number of elements fetched then return it.
    
    if (pceltFetched != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *pceltFetched = celtFetched;
        }
        else
        {
            *pceltFetched = 0;
        }
    }

    RRETURN(hr);
}



STDMETHODIMP CEnumStringTable::Skip
(
    unsigned long celt
)
{
    HRESULT hr = m_piEnumString->Skip(celt);
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



STDMETHODIMP CEnumStringTable::Reset()
{
    HRESULT hr = m_piEnumString->Reset();
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CEnumStringTable::Clone(IEnumVARIANT **ppenum)
{
    HRESULT hr = S_OK;

    CEnumStringTable *pClone = New CEnumStringTable(m_piEnumString);

    if (NULL == pClone)
    {
        *ppenum = NULL;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppenum = static_cast<IEnumVARIANT *>(pClone);

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CEnumStringTable::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IEnumVARIANT == riid)
    {
        *ppvObjOut = static_cast<IEnumVARIANT *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitms.h ===
//=--------------------------------------------------------------------------=
// spanitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItems class definition - implements ScopePaneItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEPANEITEMS_DEFINED_
#define _SCOPEPANEITEMS_DEFINED_

#include "collect.h"
#include "spanitem.h"
#include "view.h"
#include "snapin.h"

class CView;
class CScopePaneItem;

class CScopePaneItems : public CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>
{
    protected:
        CScopePaneItems(IUnknown *punkOuter);
        ~CScopePaneItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        HRESULT AddNode(CScopeItem *pScopeItem,
                        CScopePaneItem **ppScopePaneItem);
        CScopePaneItem *GetStaticNodeItem() { return m_pStaticNodeItem; }
        void SetSnapIn(CSnapIn *pSnapIn);
        void SetParentView(CView *pView);
        CView *GetParentView() { return m_pParentView; }
        void SetSelectedItem(CScopePaneItem *pScopePaneItem);
        CScopePaneItem *GetSelectedItem() { return m_pSelectedItem; }
        STDMETHOD(Remove)(VARIANT Index);

    // Event firing methods
        void FireScopePaneItemsInitialize(IScopePaneItem *piScopePaneItem);
        void FireGetResultViewInfo(IScopePaneItem                *piScopePaneItem,
                                   SnapInResultViewTypeConstants *pViewType,
                                   BSTR                          *pbstrDisplayString);

        BOOL FireGetResultView(IScopePaneItem *piScopePaneItem,
                               VARIANT        *pvarIndex);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    public:

    // IScopePaneItems
        COCLASS_PROPERTY_RO(CScopePaneItems, SelectedItem, ScopePaneItem, IScopePaneItem, DISPID_SCOPEPANEITEMS_SELECTED_ITEM);
        COCLASS_PROPERTY_RO(CScopePaneItems, Parent, View, IView, DISPID_SCOPEPANEITEMS_PARENT);

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


    private:

        void InitMemberVariables();
        HRESULT CreateScopePaneItem(BSTR bstrName,
                                    IScopePaneItem **ppiScopePaneItem);
        HRESULT SetPreferredTaskpad(IViewDefs      *piViewDefs,
                                    CScopePaneItem *pScopePaneItem);

        CSnapIn        *m_pSnapIn;          // back ptr to snap-in
        CView          *m_pParentView;      // ScopePaneItems.Parent
        CScopePaneItem *m_pStaticNodeItem;  // ptr to ScopePaneItem for static node
        CScopePaneItem *m_pSelectedItem;    // ScopePaneItems.SelectedItem

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtGetResultViewInfo[3];
        static EVENTINFO m_eiGetResultViewInfo;

        static VARTYPE   m_rgvtGetResultView[2];
        static EVENTINFO m_eiGetResultView;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopePaneItems,              // name
                                &CLSID_ScopePaneItems,       // clsid
                                "ScopePaneItems",            // objname
                                "ScopePaneItems",            // lblname
                                NULL,                        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IScopePaneItems,        // dispatch IID
                                &DIID_DScopePaneItemsEvents, // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _SCOPEPANEITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\strtable.h ===
//=--------------------------------------------------------------------------=
// strtable.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCStringTable class definition - implements MMCStringTable collection
//
//=--------------------------------------------------------------------------=

#ifndef _STRTABLE_DEFINED_
#define _STRTABLE_DEFINED_

#include "snapin.h"

class CMMCStringTable : public CSnapInAutomationObject,
                        public IMMCStringTable
{
    private:
        CMMCStringTable(IUnknown *punkOuter);
        ~CMMCStringTable();

    public:
        static IUnknown *Create(IUnknown * punk);
        void SetIStringTable(IStringTable *piStringTable);
    
    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCStringTable methods

        STDMETHOD(get_Item)(long ID, BSTR *pbstrString);
        STDMETHOD(get__NewEnum)(IUnknown **ppunkEnum);
        STDMETHOD(Add)(BSTR String, long *plID);
        STDMETHOD(Find)(BSTR String, long *plID);
        STDMETHOD(Remove)(long ID);
        STDMETHOD(Clear)();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        IStringTable *m_piStringTable; // MMC interface
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(StringTable,                // name
                                NULL,                       // clsid
                                "StringTable",              // objname
                                "StringTable",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCStringTable,       // dispatch IID
                                NULL,                       // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


class CEnumStringTable : public CSnapInAutomationObject,
                         public IEnumVARIANT

{
    public:
        CEnumStringTable(IEnumString *piEnumString);
        ~CEnumStringTable();

    private:

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        // IEnumVARIANT
        STDMETHOD(Next)(unsigned long   celt,
                        VARIANT        *rgvar,
                        unsigned long  *pceltFetched);        
        STDMETHOD(Skip)(unsigned long celt);        
        STDMETHOD(Reset)();        
        STDMETHOD(Clone)(IEnumVARIANT **ppenum);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

        void InitMemberVariables();

        IEnumString *m_piEnumString;
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(EnumStringTable,            // name
                                NULL,                       // clsid
                                "StringTable",              // objname
                                "StringTable",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IEnumVARIANT,          // dispatch IID
                                NULL,                       // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe



#endif // _STRTABLE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\task.cpp ===
//=--------------------------------------------------------------------------=
// task.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTask class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "task.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTask::CTask(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASK,
                            static_cast<ITask *>(this),
                            static_cast<CTask *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Task,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTask::~CTask()
{
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    FREESTRING(m_bstrMouseOverImage);
    FREESTRING(m_bstrMouseOffImage);
    FREESTRING(m_bstrFontFamily);
    FREESTRING(m_bstrEOTFile);
    FREESTRING(m_bstrSymbolString);
    FREESTRING(m_bstrHelpString);
    FREESTRING(m_bstrURL);
    FREESTRING(m_bstrScript);
    InitMemberVariables();
}

void CTask::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Visible = VARIANT_TRUE;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    m_ImageType = siNoImage;
    m_bstrMouseOverImage = NULL;
    m_bstrMouseOffImage = NULL;
    m_bstrFontFamily = NULL;
    m_bstrEOTFile = NULL;
    m_bstrSymbolString = NULL;
    m_bstrHelpString = NULL;
    m_ActionType = siNotify;
    m_bstrURL = NULL;
    m_bstrScript = NULL;
}

IUnknown *CTask::Create(IUnknown * punkOuter)
{
    CTask *pTask = New CTask(punkOuter);
    if (NULL == pTask)
    {
        return NULL;
    }
    else
    {
        return pTask->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTask::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 10) )
    {
    }
    else
    {
        IfFailRet(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));
    }

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailRet(PersistSimpleType(&m_ImageType, siNoImage, OLESTR("ImageType")));

    IfFailRet(PersistBstr(&m_bstrMouseOverImage, L"", OLESTR("MouseOverImage")));

    IfFailRet(PersistBstr(&m_bstrMouseOffImage, L"", OLESTR("MouseOffImage")));

    IfFailRet(PersistBstr(&m_bstrFontFamily, L"", OLESTR("FontFamily")));

    IfFailRet(PersistBstr(&m_bstrEOTFile, L"", OLESTR("EOTFile")));

    IfFailRet(PersistBstr(&m_bstrSymbolString, L"", OLESTR("SymbolString")));

    IfFailRet(PersistBstr(&m_bstrHelpString, L"", OLESTR("HelpString")));

    IfFailRet(PersistSimpleType(&m_ActionType, siNotify, OLESTR("ActionType")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    IfFailRet(PersistBstr(&m_bstrScript, L"", OLESTR("Script")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTask::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITask == riid)
    {
        *ppvObjOut = static_cast<ITask *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\stub_mssnapr_i.c ===
#define IID_IMMCListView My_IID_IMMCListView
#define IID_INodeType    My_IID_INodeType
#include <mssnapr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tlver.h ===
//=--------------------------------------------------------------------------=
// tlver.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Type library version definitions
//
//=--------------------------------------------------------------------------=

#define TLIB_VERSION        1.0
#define TLIB_VERSION_MAJOR  1
#define TLIB_VERSION_MINOR  0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tls.h ===
//=--------------------------------------------------------------------------=
// tls.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTls class definition
//
// This object manages TLS on behalf of all objects in the designer runtime.
//
//=--------------------------------------------------------------------------=

#ifndef _TLS_DEFINED_
#define _TLS_DEFINED_

// Any code in the designer runtime that needs TLS needs to reserve a slot
// by adding a #define for itself (e.g. TLS_SLOT_PPGWRAP) and incrementing
// TLS_SLOT_COUNT. To use TLS call CTls::Set and CTls::Get rather than the
// Win32 TlsSetValue/TlsGetValue.

#define TLS_SLOT_PPGWRAP 0
#define TLS_SLOT_COUNT   1


class CTls
{
public:
    static void Initialize();
    static void Destroy();

    static HRESULT Set(UINT uiSlot, void *pvData);
    static HRESULT Get(UINT uiSlot, void **ppvData);
    
private:
    static DWORD m_adwTlsIndexes[TLS_SLOT_COUNT];
    static BOOL m_fAllocedTls;
};

#endif // _TLS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\taskpad.cpp ===
//=--------------------------------------------------------------------------=
// taskpad.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpad class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "taskpad.h"
#include "tasks.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CTaskpad::CTaskpad(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASKPAD,
                            static_cast<ITaskpad *>(this),
                            static_cast<CTaskpad *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Taskpad,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpad::~CTaskpad()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrTitle);
    FREESTRING(m_bstrDescriptiveText);
    FREESTRING(m_bstrURL);
    FREESTRING(m_bstrMouseOverImage);
    FREESTRING(m_bstrMouseOffImage);
    FREESTRING(m_bstrFontFamily);
    FREESTRING(m_bstrEOTFile);
    FREESTRING(m_bstrSymbolString);
    FREESTRING(m_bstrListpadTitle);
    FREESTRING(m_bstrListpadButtonText);
    FREESTRING(m_bstrListView);
    RELEASE(m_piTasks);
    InitMemberVariables();
}

void CTaskpad::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Type = Default;
    m_bstrTitle = NULL;
    m_bstrDescriptiveText = NULL;
    m_bstrURL = NULL;
    m_BackgroundType = siNoImage;
    m_bstrMouseOverImage = NULL;
    m_bstrMouseOffImage = NULL;
    m_bstrFontFamily = NULL;
    m_bstrEOTFile = NULL;
    m_bstrSymbolString = NULL;
    m_ListpadStyle = siVertical;
    m_bstrListpadTitle = NULL;
    m_ListpadHasButton = VARIANT_FALSE;
    m_bstrListpadButtonText = NULL;
    m_bstrListView = NULL;
    m_piTasks = NULL;
}


IUnknown *CTaskpad::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    CTaskpad *pTaskpad = New CTaskpad(punkOuter);
    IUnknown *punkTasks = CTasks::Create(NULL);

    if ( (NULL == pTaskpad) || (NULL == punkTasks) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkTasks->QueryInterface(IID_ITasks,
                               reinterpret_cast<void **>(&pTaskpad->m_piTasks)));

Error:
    QUICK_RELEASE(punkTasks);
    if (FAILEDHR(hr))
    {
        if (NULL != pTaskpad)
        {
            delete pTaskpad;
        }
        return NULL;
    }
    else
    {
        return pTaskpad->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpad::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Type, Default, OLESTR("Type")));

    IfFailRet(PersistBstr(&m_bstrTitle, L"", OLESTR("Title")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    IfFailRet(PersistBstr(&m_bstrDescriptiveText, L"", OLESTR("DescriptiveText")));

    IfFailRet(PersistSimpleType(&m_BackgroundType, siNoImage, OLESTR("BackgroundType")));

    IfFailRet(PersistBstr(&m_bstrMouseOverImage, L"", OLESTR("MouseOverImage")));

    IfFailRet(PersistBstr(&m_bstrMouseOffImage, L"", OLESTR("MouseOffImage")));

    IfFailRet(PersistBstr(&m_bstrFontFamily, L"", OLESTR("FontFamily")));

    IfFailRet(PersistBstr(&m_bstrEOTFile, L"", OLESTR("EOTFile")));

    IfFailRet(PersistBstr(&m_bstrSymbolString, L"", OLESTR("SymbolString")));

    IfFailRet(PersistSimpleType(&m_ListpadStyle, siVertical, OLESTR("ListpadStyle")));

    IfFailRet(PersistBstr(&m_bstrListpadTitle, L"", OLESTR("ListpadTitle")));

    IfFailRet(PersistSimpleType(&m_ListpadHasButton, VARIANT_FALSE, OLESTR("ListpadHasButton")));

    IfFailRet(PersistBstr(&m_bstrListpadButtonText, L"", OLESTR("ListpadButtonText")));

    IfFailRet(PersistBstr(&m_bstrListView, L"", OLESTR("ListView")));

    IfFailRet(PersistObject(&m_piTasks, CLSID_Tasks,
                            OBJECT_TYPE_TASKS, IID_ITasks, OLESTR("Tasks")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpad::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITaskpad == riid)
    {
        *ppvObjOut = static_cast<ITaskpad *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tls.cpp ===
//=--------------------------------------------------------------------------=
// tls.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTls class implementation
//
// This object manages TLS on behalf of all objects in the designer runtime.
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tls.h"

// for ASSERT and FAIL
//
SZTHISFILE

DWORD CTls::m_adwTlsIndexes[TLS_SLOT_COUNT];
BOOL CTls::m_fAllocedTls = FALSE;

#define INVALID_INDEX (DWORD)0xFFFFFFFF

//=--------------------------------------------------------------------------=
// CTls::Initialize
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Calls TlsAlloc() for all slots. This is called from InitializeLibrary in
// main.cpp that is called by the framework during DllMain when the dll is
// loaded.
//
void CTls::Initialize()
{
    UINT i = 0;

    m_fAllocedTls = TRUE;

    for (i = 0; i < TLS_SLOT_COUNT; i++)
    {
        m_adwTlsIndexes[i] = ::TlsAlloc();
    }
}


//=--------------------------------------------------------------------------=
// CTls::Initialize
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Calls TlsFree() for all slots that have allocated TLS. This is called from
// UninitializeLibrary in main.cpp that is called by the framework during
// DllMain when the dll is unloaded.
//
void CTls::Destroy()
{
    UINT i = 0;

    if (m_fAllocedTls)
    {
        for (i = 0; i < TLS_SLOT_COUNT; i++)
        {
            if (INVALID_INDEX != m_adwTlsIndexes[i])
            {
                (void)::TlsFree(m_adwTlsIndexes[i]);
                m_adwTlsIndexes[i] = INVALID_INDEX;
            }
        }
        m_fAllocedTls = FALSE;
    }
}


//=--------------------------------------------------------------------------=
// CTls::Set
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Checks slot number validity and calls TlsSetValue. Use this function
// rather than TlsSetValue directly.
//
HRESULT CTls::Set(UINT uiSlot, void *pvData)
{
    HRESULT hr = S_OK;

    IfFalseGo(m_fAllocedTls, SID_E_INTERNAL);
    IfFalseGo(uiSlot < TLS_SLOT_COUNT, SID_E_INVALIDARG);
    IfFalseGo(INVALID_INDEX != m_adwTlsIndexes[uiSlot], SID_E_OUTOFMEMORY);
    IfFalseGo(::TlsSetValue(m_adwTlsIndexes[uiSlot], pvData), HRESULT_FROM_WIN32(::GetLastError()));

Error:
    GLOBAL_EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CTls::Get
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Checks slot number validity and calls TlsGetValue. Use this function
// rather than TlsGetValue directly.
//
HRESULT CTls::Get(UINT uiSlot, void **ppvData)
{
    HRESULT hr = S_OK;

    IfFalseGo(m_fAllocedTls, SID_E_INTERNAL);
    IfFalseGo(uiSlot < TLS_SLOT_COUNT, SID_E_INVALIDARG);
    IfFalseGo(INVALID_INDEX != m_adwTlsIndexes[uiSlot], SID_E_OUTOFMEMORY);

    *ppvData = ::TlsGetValue(m_adwTlsIndexes[uiSlot]);
    if (NULL == *ppvData)
    {
        if (NO_ERROR != ::GetLastError())
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }

Error:
    GLOBAL_EXCEPTION_CHECK(hr);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tasks.cpp ===
//=--------------------------------------------------------------------------=
// tasks.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTasks class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tasks.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTasks::CTasks(IUnknown *punkOuter) :
    CSnapInCollection<ITask, Task, ITasks>(punkOuter,
                                           OBJECT_TYPE_TASKS,
                                           static_cast<ITasks *>(this),
                                           static_cast<CTasks *>(this),
                                           CLSID_Task,
                                           OBJECT_TYPE_TASK,
                                           IID_ITask,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Tasks,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CTasks::~CTasks()
{
}

IUnknown *CTasks::Create(IUnknown * punkOuter)
{
    CTasks *pTasks = New CTasks(punkOuter);
    if (NULL == pTasks)
    {
        return NULL;
    }
    else
    {
        return pTasks->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTasks::Persist()
{
    HRESULT  hr = S_OK;
    ITask   *piTask = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<ITask, Task, ITasks>::Persist(piTask);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          ITasks Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CTasks::Add
(
    VARIANT   Index,
    VARIANT   Key, 
    VARIANT   Text,
    Task    **ppTask
)
{
    HRESULT hr = S_OK;
    VARIANT varText;
    ::VariantInit(&varText);
    ITask *piTask = NULL;

    hr = CSnapInCollection<ITask, Task, ITasks>::Add(Index, Key, &piTask);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piTask->put_Text(varText.bstrVal));
    }

    *ppTask = reinterpret_cast<Task *>(piTask);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piTask);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTasks::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_ITasks == riid)
    {
        *ppvObjOut = static_cast<ITasks *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ITask, Task, ITasks>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\task.h ===
//=--------------------------------------------------------------------------=
// task.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTask class definition - implements Task object
//
//=--------------------------------------------------------------------------=

#ifndef _TASK_DEFINED_
#define _TASK_DEFINED_

class CTask : public CSnapInAutomationObject,
              public CPersistence,
              public ITask
{
    private:
        CTask(IUnknown *punkOuter);
        ~CTask();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        long GetIndex() { return m_Index; }
        BOOL Visible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BSTR GetText() { return m_bstrText; }
        SnapInTaskpadImageTypeConstants GetImageType() { return m_ImageType; }
        BSTR GetMouseOverImage() { return m_bstrMouseOverImage; }
        BSTR GetMouseOffImage() { return m_bstrMouseOffImage; }
        BSTR GetFontfamily() { return m_bstrFontFamily; }
        BSTR GetEOTFile() { return m_bstrEOTFile; }
        BSTR GetSymbolString() { return m_bstrSymbolString; }
        BSTR GetHelpString() { return m_bstrHelpString; }
        SnapInActionTypeConstants GetActionType() { return m_ActionType; }
        BSTR GetURL() { return m_bstrURL; }
        BSTR GetScript() { return m_bstrScript; }

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITask

        SIMPLE_PROPERTY_RW(CTask,       Index,          long,                               DISPID_TASK_INDEX);
        BSTR_PROPERTY_RW(CTask,         Key,                                                DISPID_TASK_KEY);
        SIMPLE_PROPERTY_RW(CTask,       Visible,        VARIANT_BOOL,                       DISPID_TASK_VISIBLE);
        VARIANTREF_PROPERTY_RW(CTask,   Tag,                                                DISPID_TASK_TAG);
        BSTR_PROPERTY_RW(CTask,         Text,                                               DISPID_TASK_TEXT);
        SIMPLE_PROPERTY_RW(CTask,       ImageType,      SnapInTaskpadImageTypeConstants,    DISPID_TASK_IMAGE_TYPE);
        BSTR_PROPERTY_RW(CTask,         MouseOverImage,                                     DISPID_TASK_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTask,         MouseOffImage,                                      DISPID_TASK_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTask,         FontFamily,                                         DISPID_TASK_FONT_FAMILY);
        BSTR_PROPERTY_RW(CTask,         EOTFile,                                            DISPID_TASK_EOT_FILE);
        BSTR_PROPERTY_RW(CTask,         SymbolString,                                       DISPID_TASK_SYMBOL_STRING);
        BSTR_PROPERTY_RW(CTask,         HelpString,                                         DISPID_TASK_HELP_STRING);
        SIMPLE_PROPERTY_RW(CTask,       ActionType,     SnapInActionTypeConstants,          DISPID_TASK_ACTION_TYPE);
        BSTR_PROPERTY_RW(CTask,         URL,                                                DISPID_TASK_URL);
        BSTR_PROPERTY_RW(CTask,         Script,                                             DISPID_TASK_SCRIPT);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Task,               // name
                                &CLSID_Task,        // clsid
                                "Task",             // objname
                                "Task",             // lblname
                                &CTask::Create,     // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITask,         // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASK_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tasks.h ===
//=--------------------------------------------------------------------------=
// tasks.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTasks class definition - implements Tasks collection
//
//=--------------------------------------------------------------------------=

#ifndef _TASKS_DEFINED_
#define _TASKS_DEFINED_

#include "collect.h"

class CTasks : public CSnapInCollection<ITask, Task, ITasks>,
               public CPersistence
{
    protected:
        CTasks(IUnknown *punkOuter);
        ~CTasks();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITasks
        STDMETHOD(Add)(VARIANT   Index,
                       VARIANT   Key, 
                       VARIANT   Text,
                       Task    **ppTask);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Tasks,              // name
                                &CLSID_Tasks,       // clsid
                                "Tasks",            // objname
                                "Tasks",            // lblname
                                &CTasks::Create,    // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITasks,        // dispatch IID
                                NULL,               // no events IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASKS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\taskpad.h ===
//=--------------------------------------------------------------------------=
// taskpad.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpad class definition - implements Taskpad object
//
//=--------------------------------------------------------------------------=

#ifndef _TASKPAD_DEFINED_
#define _TASKPAD_DEFINED_

class CTaskpad : public CSnapInAutomationObject,
                 public CPersistence,
                 public ITaskpad
{
    private:
        CTaskpad(IUnknown *punkOuter);
        ~CTaskpad();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITaskpad
        BSTR_PROPERTY_RW(CTaskpad,       Name,                                               DISPID_TASKPAD_NAME);
        SIMPLE_PROPERTY_RW(CTaskpad,     Type,              SnapInTaskpadTypeConstants,      DISPID_TASKPAD_TYPE);
        BSTR_PROPERTY_RW(CTaskpad,       Title,                                              DISPID_TASKPAD_TITLE);
        BSTR_PROPERTY_RW(CTaskpad,       DescriptiveText,                                    DISPID_TASKPAD_DESCRIPTIVE_TEXT);
        BSTR_PROPERTY_RW(CTaskpad,       URL,                                                DISPID_TASKPAD_URL);
        SIMPLE_PROPERTY_RW(CTaskpad,     BackgroundType,    SnapInTaskpadImageTypeConstants, DISPID_TASKPAD_BACKGROUND_TYPE);
        BSTR_PROPERTY_RW(CTaskpad,       MouseOverImage,                                     DISPID_TASKPAD_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTaskpad,       MouseOffImage,                                      DISPID_TASKPAD_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTaskpad,       FontFamily,                                         DISPID_TASKPAD_FONT_FAMILY);
        BSTR_PROPERTY_RW(CTaskpad,       EOTFile,                                            DISPID_TASKPAD_EOT_FILE);
        BSTR_PROPERTY_RW(CTaskpad,       SymbolString,                                       DISPID_TASKPAD_SYMBOL_STRING);
        SIMPLE_PROPERTY_RW(CTaskpad,     ListpadStyle,      SnapInListpadStyleConstants,     DISPID_TASKPAD_LISTPAD_STYLE);
        BSTR_PROPERTY_RW(CTaskpad,       ListpadTitle,                                       DISPID_TASKPAD_LISTPAD_TITLE);
        SIMPLE_PROPERTY_RW(CTaskpad,     ListpadHasButton,  VARIANT_BOOL,                    DISPID_TASKPAD_LISTPAD_HAS_BUTTON);
        BSTR_PROPERTY_RW(CTaskpad,       ListpadButtonText,                                  DISPID_TASKPAD_LISTPAD_BUTTON_TEXT);
        BSTR_PROPERTY_RW(CTaskpad,       ListView,                                           DISPID_TASKPAD_LISTVIEW);
        COCLASS_PROPERTY_RO(CTaskpad,    Tasks,             Tasks, ITasks,                   DISPID_TASKPAD_TASKS);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Taskpad,            // name
                                &CLSID_Taskpad,     // clsid
                                "Taskpad",          // objname
                                "Taskpad",          // lblname
                                &CTaskpad::Create,  // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITaskpad,      // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASKPAD_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbars.cpp ===
//=--------------------------------------------------------------------------=
// toolbars.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbars class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "toolbars.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCToolbars::CMMCToolbars(IUnknown *punkOuter) :
    CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>(
                                             punkOuter,
                                             OBJECT_TYPE_MMCTOOLBARS,
                                             static_cast<IMMCToolbars *>(this),
                                             static_cast<CMMCToolbars *>(this),
                                             CLSID_MMCToolbar,
                                             OBJECT_TYPE_MMCTOOLBAR,
                                             IID_IMMCToolbar,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCToolbars,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCToolbars::~CMMCToolbars()
{
}

IUnknown *CMMCToolbars::Create(IUnknown * punkOuter)
{
    CMMCToolbars *pMMCToolbars = New CMMCToolbars(punkOuter);
    if (NULL == pMMCToolbars)
    {
        return NULL;
    }
    else
    {
        return pMMCToolbars->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbars::Persist()
{
    HRESULT       hr = S_OK;
    IMMCToolbar  *piMMCToolbar = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>::Persist(piMMCToolbar);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbars::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCToolbars == riid)
    {
        *ppvObjOut = static_cast<IMMCToolbars *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbar.h ===
//=--------------------------------------------------------------------------=
// toolbar.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbar class definition - implements MMCToolbar object
//
//=--------------------------------------------------------------------------=

#ifndef _TOOLBAR_DEFINED_
#define _TOOLBAR_DEFINED_

#include "buttons.h"
#include "button.h"
#include "snapin.h"

class CMMCButtons;
class CMMCButton;

class CMMCToolbar : public CSnapInAutomationObject,
                    public CPersistence,
                    public IMMCToolbar
{
    private:
        CMMCToolbar(IUnknown *punkOuter);
        ~CMMCToolbar();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCToolbar

        SIMPLE_PROPERTY_RW(CMMCToolbar, Index, long, DISPID_TOOLBAR_INDEX);
        BSTR_PROPERTY_RW(CMMCToolbar, Key, DISPID_TOOLBAR_KEY);
        COCLASS_PROPERTY_RO(CMMCToolbar, Buttons, MMCButtons, IMMCButtons, DISPID_TOOLBAR_BUTTONS);

        STDMETHOD(get_ImageList)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_ImageList)(MMCImageList *pMMCImageList);

        BSTR_PROPERTY_RW(CMMCToolbar, Name, DISPID_TOOLBAR_NAME);
        VARIANTREF_PROPERTY_RW(CMMCToolbar, Tag, DISPID_TOOLBAR_TAG);

    // Public utility methods
    public:

        void FireButtonClick(IMMCClipboard *piMMCClipboard,
                             IMMCButton    *piMMCButton);
                                       
        void FireButtonDropDown(IMMCClipboard *piMMCClipboard,
                                IMMCButton    *piMMCButton);

        void FireButtonMenuClick(IMMCClipboard  *piMMCClipboard,
                                 IMMCButtonMenu *piMMCButtonMenu);
        
        HRESULT IsToolbar(BOOL *pfIsToolbar);
        HRESULT IsMenuButton(BOOL *pfIsMenuButton);
        HRESULT Attach(IUnknown *punkControl);
        void Detach();
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        CSnapIn *GetSnapIn() { return m_pSnapIn; }

        // Determines whether the toolbar is attached to an MMC toolbar or
        // menu button
        
        BOOL Attached();

        // Adds a button to the MMC toolbar

        HRESULT AddButton(IToolbar *piToolbar, CMMCButton *pMMCButton);

        // Removes a button from the MMC toolbar
        
        HRESULT RemoveButton(long lButtonIndex);

        // Get and set button and menu button state

        HRESULT GetButtonState(CMMCButton       *pMMCButton,
                               MMC_BUTTON_STATE  State,
                               BOOL             *pfValue);

        HRESULT SetButtonState(CMMCButton       *pMMCButton,
                               MMC_BUTTON_STATE  State,
                               BOOL              fValue);
        
        HRESULT SetMenuButtonState(CMMCButton       *pMMCButton,
                                   MMC_BUTTON_STATE  State,
                                   BOOL              fValue);

        HRESULT SetMenuButtonText(CMMCButton *pMMCButton,
                                  BSTR        bstrText,
                                  BSTR        bstrToolTipText);

        // Note there is no GetMenuButtonState because MMC does not support it

        // Given a command ID returns the owning toolbar and button

        static HRESULT GetToolbarAndButton(int           idButton,
                                           CMMCToolbar **ppMMCToolbar,
                                           CMMCButton  **ppMMCButton,
                                           CSnapIn      *pSnapIn);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT AttachToolbar(IToolbar *piToolbar);
        HRESULT AddToolbarImages(IToolbar *piToolbar);
        HRESULT AttachMenuButton(IMenuButton *piMenuButton);

        CSnapIn           *m_pSnapIn;         // back ptr to snap-in
        IMMCImageList     *m_piImages;        // MMCToolbar.Images
        BSTR               m_bstrImagesKey;   // Key of MMCToolbar.ImageList
                                              // in SnapInDesignerDef.ImageLists
        CMMCButtons       *m_pButtons;        // MMCToolbar.Buttons
        BOOL               m_fIAmAToolbar;    // TRUE=MMCToolbar is a toolbar
        BOOL               m_fIAmAMenuButton; // TRUE=MMCToolbar is a menu button
        long               m_cAttaches;       // no. of times toolbar has been
                                              // attached to an MMC controlbar

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];

        // Event parameter definitions

        static VARTYPE   m_rgvtButtonClick[2];
        static EVENTINFO m_eiButtonClick;

        static VARTYPE   m_rgvtButtonDropDown[2];
        static EVENTINFO m_eiButtonDropDown;

        static VARTYPE   m_rgvtButtonMenuClick[2];
        static EVENTINFO m_eiButtonMenuClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCToolbar,                  // name
                                &CLSID_MMCToolbar,           // clsid
                                "MMCToolbar",                // objname
                                "MMCToolbar",                // lblname
                                &CMMCToolbar::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCToolbar,            // dispatch IID
                                &DIID_DMMCToolbarEvents,     // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _TOOLBAR_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdef.h ===
//=--------------------------------------------------------------------------=
// tpdvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TPDVDEF_DEFINED_
#define _TPDVDEF_DEFINED_


class CTaskpadViewDef : public CSnapInAutomationObject,
                        public CPersistence,
                        public ITaskpadViewDef
{
    private:
        CTaskpadViewDef(IUnknown *punkOuter);
        ~CTaskpadViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITaskpadViewDef

        BSTR_PROPERTY_RW(CTaskpadViewDef,       Name,  DISPID_TASKPADVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     Index, long, DISPID_TASKPADVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       Key, DISPID_TASKPADVIEWDEF_KEY);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_TASKPADVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       ViewMenuText, DISPID_TASKPADVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       ViewMenuStatusBarText, DISPID_TASKPADVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     UseWhenTaskpadViewPreferred, VARIANT_BOOL, DISPID_TASKPADVIEWDEF_USE_WHEN_TASKPAD_VIEW_PREFERRED);
        OBJECT_PROPERTY_RO(CTaskpadViewDef,     Taskpad, ITaskpad, DISPID_TASKPADVIEWDEF_TASKPAD);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(TaskpadViewDef,           // name
                                &CLSID_TaskpadViewDef,    // clsid
                                "TaskpadViewDef",         // objname
                                "TaskpadViewDef",         // lblname
                                &CTaskpadViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_ITaskpadViewDef,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _TPDVDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbar.cpp ===
//=--------------------------------------------------------------------------=
// toolbar.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbar class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "toolbar.h"
#include "toolbars.h"
#include "button.h"
#include "images.h"
#include "image.h"
#include "ctlbar.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// Macro: MAKE_BUTTON_ID()
//
// The command ID is an int in MMCBUTTON but in practice only the
// low word of that int is received in an MMCN_BTN_CLICK notification.
// So, we have 16 bits to indentify both an MMCToolbar object and
// one of its buttons. We use the high 8 bits for the index of the
// toolbar in SnapInDesignerDef.Toolbars and the lower 8 for the index
// of the button in MMCToolbar.Buttons. This means that there can only
// be 256 toolbars and only 256 buttons per toolbar.
//=--------------------------------------------------------------------------=

#define MAKE_BUTTON_ID(pMMCButton) MAKEWORD(pMMCButton->GetIndex(), m_Index)



// Macro: MAKE_MENUBUTTON_ID()
//
// The command for a menu button is the C++ pointer to the MMCButton object
// that owns it.

#define MAKE_MENUBUTTON_ID(pMMCButton) reinterpret_cast<int>(pMMCButton)

const GUID *CMMCToolbar::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_MMCToolbarGeneralPP,
    &CLSID_MMCToolbarButtonsPP
};



VARTYPE CMMCToolbar::m_rgvtButtonClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonClick =
{
    DISPID_TOOLBAR_EVENT_BUTTON_CLICK,
    sizeof(m_rgvtButtonClick) / sizeof(m_rgvtButtonClick[0]),
    m_rgvtButtonClick
};



VARTYPE CMMCToolbar::m_rgvtButtonDropDown[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonDropDown =
{
    DISPID_TOOLBAR_EVENT_BUTTON_DROPDOWN,
    sizeof(m_rgvtButtonDropDown) / sizeof(m_rgvtButtonDropDown[0]),
    m_rgvtButtonDropDown
};



VARTYPE CMMCToolbar::m_rgvtButtonMenuClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonMenuClick =
{
    DISPID_TOOLBAR_EVENT_BUTTON_MENU_CLICK,
    sizeof(m_rgvtButtonMenuClick) / sizeof(m_rgvtButtonMenuClick[0]),
    m_rgvtButtonMenuClick
};




#pragma warning(disable:4355)  // using 'this' in constructor

CMMCToolbar::CMMCToolbar(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCTOOLBAR,
                            static_cast<IMMCToolbar *>(this),
                            static_cast<CMMCToolbar *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCToolbar,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCToolbar::~CMMCToolbar()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piButtons);
    RELEASE(m_piImages);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrImagesKey);
    Detach();
    InitMemberVariables();
}

void CMMCToolbar::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_piButtons = NULL;
    m_bstrName = NULL;
    ::VariantInit(&m_varTag);
    m_piImages = NULL;
    m_bstrImagesKey = NULL;
    m_pButtons = NULL;
    m_fIAmAToolbar = FALSE;
    m_fIAmAMenuButton = FALSE;
    m_cAttaches = 0;
}

IUnknown *CMMCToolbar::Create(IUnknown * punkOuter)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkToolbar = NULL;
    IUnknown    *punkButtons = NULL;
    CMMCToolbar *pMMCToolbar = New CMMCToolbar(punkOuter);

    IfFalseGo(NULL != pMMCToolbar, SID_E_OUTOFMEMORY);
    punkToolbar = pMMCToolbar->PrivateUnknown();

    punkButtons = CMMCButtons::Create(NULL);
    IfFalseGo(NULL != punkButtons, SID_E_OUTOFMEMORY);

    IfFailGo(punkButtons->QueryInterface(IID_IMMCButtons,
                         reinterpret_cast<void **>(&pMMCToolbar->m_piButtons)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkButtons,
                                                   &pMMCToolbar->m_pButtons));
    pMMCToolbar->m_pButtons->SetToolbar(pMMCToolbar);

Error:
    QUICK_RELEASE(punkButtons);
    if (FAILED(hr))
    {
        RELEASE(punkToolbar);
    }
    return punkToolbar;
}


HRESULT CMMCToolbar::IsToolbar(BOOL *pfIsToolbar)
{
    HRESULT     hr = S_OK;
    CMMCButton *pMMCButton = NULL;
    long        i = 0;
    long        cButtons = m_pButtons->GetCount();

    *pfIsToolbar = FALSE;

    // If there are no buttons, then this is not a toolbar

    IfFalseGo(0 != cButtons, S_OK);

    while (i < cButtons)
    {
        
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));
        IfFalseGo(pMMCButton->GetStyle() != siDropDown, S_OK);
        i++;
    }

    *pfIsToolbar = TRUE;
    m_fIAmAToolbar = TRUE;
    m_fIAmAMenuButton = FALSE;

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::IsMenuButton(BOOL *pfIsMenuButton)
{
    HRESULT     hr = S_OK;
    CMMCButton *pMMCButton = NULL;
    long        i = 0;
    long        cButtons = m_pButtons->GetCount();

    *pfIsMenuButton = FALSE;

    // If there are no button definitions, then this is not a menu button

    IfFalseGo(0 != cButtons, S_OK);

    while (i < cButtons)
    {

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));
        IfFalseGo(siDropDown == pMMCButton->GetStyle(), S_OK);
        i++;
    }

    *pfIsMenuButton = TRUE;
    m_fIAmAMenuButton = TRUE;
    m_fIAmAToolbar = FALSE;

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::Attach(IUnknown *punkControl)
{
    HRESULT      hr = S_OK;
    IToolbar    *piToolbar = NULL;
    IMenuButton *piMenuButton = NULL;

    // Increment attachment count
    m_cAttaches++;

    // Pass control to AttachXxxx methods

    if (m_fIAmAToolbar)
    {
        IfFailGo(punkControl->QueryInterface(IID_IToolbar,
                                      reinterpret_cast<void **>(&piToolbar)));
        IfFailGo(AttachToolbar(piToolbar));
    }
    else if (m_fIAmAMenuButton)
    {
        IfFailGo(punkControl->QueryInterface(IID_IMenuButton,
                                   reinterpret_cast<void **>(&piMenuButton)));
        IfFailGo(AttachMenuButton(piMenuButton));
    }

Error:
    if (FAILED(hr))
    {
        Detach();
    }
    QUICK_RELEASE(piToolbar);
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}

void CMMCToolbar::Detach()
{
    m_cAttaches--;
}


HRESULT CMMCToolbar::AttachToolbar(IToolbar *piToolbar)
{
    HRESULT       hr = S_OK;
    CMMCButton   *pMMCButton = NULL;
    long          i = 0;
    long          cButtons = m_pButtons->GetCount();

    // Add the images

    IfFailGo(AddToolbarImages(piToolbar));

    // Add the buttons

    for (i = 0; i < cButtons; i++)
    {
        // Get the button definition

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));

        IfFailGo(AddButton(piToolbar, pMMCButton));
    }

Error:
    RRETURN(hr);
}

HRESULT CMMCToolbar::AddToolbarImages(IToolbar *piToolbar)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    CMMCImages    *pMMCImages = NULL;
    CMMCImage     *pMMCImage = NULL;
    long           cImages = 0;
    long           i = 0;
    HBITMAP        hbitmap = NULL;
    OLE_COLOR      OleColorMask = 0;
    COLORREF       ColorRefMask = RGB(0x00,0x00,0x00);

    BITMAP bitmap;
    ::ZeroMemory(&bitmap, sizeof(bitmap));

    // Make sure we have an image list. If no VB code has done a get
    // on MMCToolbar.ImageList then we have yet to pull the image list
    // from the master collection. Doing our own get will take care
    // of that. We immediately release it because the get will put it
    // into m_piImages.

    if (NULL == m_piImages)
    {
        IfFailGo(get_ImageList(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        RELEASE(piMMCImageList);
    }

    // Now if there is no image list then the project was saved without
    // an image list specified in the toolbar definition.

    if (NULL == m_piImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGELIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the image collection

    IfFailGo(m_piImages->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImages, &pMMCImages));

    /// Make sure it contains images

    cImages = pMMCImages->GetCount();
    if (0 == cImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGES;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the mask color

    IfFailGo(m_piImages->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRefMask));

    // Add the bitmaps to the MMC toolbar

    for (i = 0; i < cImages; i++)
    {
        // Get the bitmap handle

        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                     pMMCImages->GetItemByIndex(i), &pMMCImage));

        IfFailGo(pMMCImage->GetPictureHandle(PICTYPE_BITMAP, 
                                    reinterpret_cast<OLE_HANDLE *>(&hbitmap)));
        // Get the bitmap definition so we can get its size in pixels. (IPicture
        // returns size in HIMETRIC so we would have to convert it to pixels).

        if (::GetObject(hbitmap, sizeof(BITMAP), (LPSTR)&bitmap) <= 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        // Add one bitmap to the MMC toolbar

        hr = piToolbar->AddBitmap(1, hbitmap, bitmap.bmWidth, bitmap.bmHeight,
                                  ColorRefMask);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (SID_E_INVALIDARG == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    RRETURN(hr);
}


HRESULT CMMCToolbar::AddButton(IToolbar *piToolbar, CMMCButton *pMMCButton)
{
    HRESULT       hr = S_OK;
    IMMCImages   *piMMCImages = NULL;
    IMMCImage    *piMMCImage = NULL;
    long          lImageIndex = 0;

    SnapInButtonStyleConstants Style = siDefault;

    MMCBUTTON MMCButton;
    ::ZeroMemory(&MMCButton, sizeof(MMCButton));

    if (NULL == m_piImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGELIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the images collection so that we can get the numeric image index

    IfFailGo(m_piImages->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));

    // Get the button attributes and translate them into an MMCBUTTON

    // Get the image and get its index

    hr = piMMCImages->get_Item(pMMCButton->GetImage(), reinterpret_cast<MMCImage **>(&piMMCImage));
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_TOOLBAR_IMAGE_NOT_FOUND;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(piMMCImage->get_Index(&lImageIndex));
    RELEASE(piMMCImage);
    MMCButton.nBitmap = static_cast<int>(lImageIndex - 1L);

    // See the top of the file for how we create button IDs

    MMCButton.idCommand = MAKE_BUTTON_ID(pMMCButton);

    // Tell the button who owns it. This allows the button to handle
    // property changes that must be sent to MMC via IToolbar

    pMMCButton->SetToolbar(this);

    // Get the buttons type

    Style = pMMCButton->GetStyle();

    if ( siDefault == (Style & siDefault) )
    {
        MMCButton.fsType |= TBSTYLE_BUTTON;
    }

    if ( siCheck == (Style & siCheck) )
    {
        MMCButton.fsType |= TBSTYLE_CHECK;
    }

    if ( siButtonGroup == (Style & siButtonGroup) )
    {
        MMCButton.fsType |= TBSTYLE_GROUP;
    }

    if ( siSeparator == (Style & siSeparator) )
    {
        MMCButton.fsType |= TBSTYLE_SEP;
    }

    // Set the button state.

    if (siPressed == pMMCButton->GetValue())
    {
        if (TBSTYLE_CHECK == MMCButton.fsType)
        {
            MMCButton.fsState |= TBSTATE_CHECKED;
        }
        else
        {
            MMCButton.fsState |= TBSTATE_PRESSED;
        }
    }

    if (VARIANT_TRUE == pMMCButton->GetEnabled())
    {
        MMCButton.fsState |= TBSTATE_ENABLED;
    }

    if (VARIANT_FALSE == pMMCButton->GetVisible())
    {
        MMCButton.fsState |= TBSTATE_HIDDEN;
    }

    if (VARIANT_TRUE == pMMCButton->GetMixedState())
    {
        MMCButton.fsState |= TBSTATE_INDETERMINATE;
    }

    // Get the caption and tooltip text

    MMCButton.lpButtonText = pMMCButton->GetCaption();
    MMCButton.lpTooltipText = pMMCButton->GetToolTipText();

    // Ask MMC to add the button

    hr = piToolbar->InsertButton(static_cast<int>(pMMCButton->GetIndex() - 1L),
                                 &MMCButton);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT CMMCToolbar::RemoveButton(long lButtonIndex)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;
    
    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->DeleteButton(static_cast<int>(lButtonIndex - 1L));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL              fValue
)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;

    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->SetButtonState(MAKE_BUTTON_ID(pMMCButton), State, fValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}



HRESULT CMMCToolbar::GetButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL             *pfValue
)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;

    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->GetButtonState(MAKE_BUTTON_ID(pMMCButton), State, pfValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetMenuButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL              fValue
)
{
    HRESULT      hr = S_OK;
    IMenuButton *piMenuButton = NULL;

    IfFailGo(CControlbar::GetMenuButton(m_pSnapIn, this, &piMenuButton));

    hr = piMenuButton->SetButtonState(MAKE_MENUBUTTON_ID(pMMCButton), State,
                                      fValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetMenuButtonText
(
    CMMCButton *pMMCButton,
    BSTR        bstrText,
    BSTR        bstrToolTipText
)
{
    HRESULT      hr = S_OK;
    IMenuButton *piMenuButton = NULL;

    IfFailGo(CControlbar::GetMenuButton(m_pSnapIn, this, &piMenuButton));

    hr = piMenuButton->SetButton(MAKE_MENUBUTTON_ID(pMMCButton),
                                   static_cast<LPOLESTR>(bstrText),
                                   static_cast<LPOLESTR>(bstrToolTipText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}


HRESULT CMMCToolbar::AttachMenuButton(IMenuButton *piMenuButton)
{
    HRESULT         hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    long            i = 0;
    long            cButtons = m_pButtons->GetCount();
    int             idButton = 0;

    // The toolbar contains one or more buttons that each contain one or more
    // menu buttons. We need to iterate through the buttons and add each menu
    // button.

    for (i = 0; i < cButtons; i++)
    {
        // Get the button definition

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));

        // Tell the button who owns it.

        pMMCButton->SetToolbar(this);

        // Ask MMC to add the button. We use a pointer to the button's C++
        // object as its command ID.

        hr = piMenuButton->AddButton(MAKE_MENUBUTTON_ID(pMMCButton),
                                     pMMCButton->GetCaption(),
                                     pMMCButton->GetToolTipText());

        EXCEPTION_CHECK_GO(hr);

        // Use the button's Enabled and Visible properties to set the initial
        // visual state of the menu button.

        hr = piMenuButton->SetButtonState(
                                 MAKE_MENUBUTTON_ID(pMMCButton),
                                 ENABLED,
                                 VARIANTBOOL_TO_BOOL(pMMCButton->GetEnabled()));
        EXCEPTION_CHECK_GO(hr);

        hr = piMenuButton->SetButtonState(
                                MAKE_MENUBUTTON_ID(pMMCButton),
                                HIDDEN,
                                !VARIANTBOOL_TO_BOOL(pMMCButton->GetVisible()));
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::GetToolbarAndButton
(
    int           idButton,
    CMMCToolbar **ppMMCToolbar,
    CMMCButton  **ppMMCButton,
    CSnapIn      *pSnapIn
)
{
    HRESULT             hr = S_OK;
    IMMCToolbars       *piMMCToolbars = NULL;
    CMMCToolbars       *pMMCToolbars = NULL;
    CMMCToolbar        *pMMCToolbar = NULL;
    CMMCButton         *pMMCButton = NULL;
    long                lToolbarIndex = HIBYTE(LOWORD(idButton)) - 1;
    long                lButtonIndex = LOBYTE(LOWORD(idButton)) - 1;

    *ppMMCToolbar = NULL;
    *ppMMCButton = NULL;

    IfFailGo(pSnapIn->GetSnapInDesignerDef()->get_Toolbars(&piMMCToolbars));
    
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbars, &pMMCToolbars));

    IfFalseGo(pMMCToolbars->GetCount() > lToolbarIndex, SID_E_INTERNAL);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                    pMMCToolbars->GetItemByIndex(lToolbarIndex),
                                    &pMMCToolbar));

    IfFalseGo(pMMCToolbar->m_pButtons->GetCount() > lButtonIndex, SID_E_INTERNAL);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                          pMMCToolbar->m_pButtons->GetItemByIndex(lButtonIndex),
                          &pMMCButton));

    *ppMMCToolbar = pMMCToolbar;
    *ppMMCButton = pMMCButton;

Error:
    if (SID_E_INTERNAL == hr)
    {
        GLOBAL_EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piMMCToolbars);
    RRETURN(hr);
}


BOOL CMMCToolbar::Attached()
{
    return (m_cAttaches > 0);
}



void CMMCToolbar::FireButtonClick
(
    IMMCClipboard *piMMCClipboard,
    IMMCButton    *piMMCButton
)
{
    DebugPrintf("Firing %ls_ButtonClick(%ls)\r\n", m_bstrName, (static_cast<CMMCButton *>(piMMCButton))->GetCaption());

    FireEvent(&m_eiButtonClick, piMMCClipboard, piMMCButton);
}



void CMMCToolbar::FireButtonDropDown
(
    IMMCClipboard *piMMCClipboard,
    IMMCButton    *piMMCButton
)
{
    DebugPrintf("Firing %ls_ButtonDropDown(%ls)\r\n", m_bstrName, (static_cast<CMMCButton *>(piMMCButton))->GetCaption());

    FireEvent(&m_eiButtonDropDown, piMMCClipboard, piMMCButton);
}




void CMMCToolbar::FireButtonMenuClick
(
    IMMCClipboard  *piMMCClipboard,
    IMMCButtonMenu *piMMCButtonMenu
)
{
    DebugPrintf("Firing %ls_ButtonMenuClick(%ls)\r\n", m_bstrName, (static_cast<CMMCButtonMenu *>(piMMCButtonMenu))->GetText());

    FireEvent(&m_eiButtonMenuClick, piMMCClipboard, piMMCButtonMenu);
}



//=--------------------------------------------------------------------------=
//                       IMMCToolbar Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCToolbar::get_ImageList(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList), m_bstrImagesKey, &m_piImages));
}

STDMETHODIMP CMMCToolbar::putref_ImageList(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList), &m_bstrImagesKey, &m_piImages));
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::Persist()
{
    HRESULT      hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistObject(&m_piButtons, CLSID_MMCButtons,
                           OBJECT_TYPE_MMCBUTTONS, IID_IMMCButtons,
                           OLESTR("Buttons")));

    if ( InitNewing() || Loading() )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piButtons, &m_pButtons));
        m_pButtons->SetToolbar(this);
    }

    IfFailGo(PersistBstr(&m_bstrImagesKey, L"", OLESTR("Images")));

    IfFailGo(PersistDISPID());

    if ( InitNewing() )
    {
        RELEASE(m_piImages);
    }

Error:

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCToolbar == riid)
    {
        *ppvObjOut = static_cast<IMMCToolbar *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::OnSetHost()
{
    RRETURN(SetObjectHost(m_piButtons));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbars.h ===
//=--------------------------------------------------------------------------=
// toolbars.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbars class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TOOLBARS_DEFINED_
#define _TOOLBARS_DEFINED_

#include "collect.h"

class CMMCToolbars : public CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>,
                     public CPersistence
{
    protected:
        CMMCToolbars(IUnknown *punkOuter);
        ~CMMCToolbars();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCToolbars,              // name
                                &CLSID_MMCToolbars,       // clsid
                                "MMCToolbars",            // objname
                                "MMCToolbars",            // lblname
                                &CMMCToolbars::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCToolbars,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _TOOLBARS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdef.cpp ===
//=--------------------------------------------------------------------------=
// tpdvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tpdvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CTaskpadViewDef::CTaskpadViewDef
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IUnknown *punkOuter [in] outer unknown for aggregation
//
// Output:
//
// Notes:
//
// This object does not support ISpecifyPropertyPages because in the
// the designer it is not the selected object (the contained Taskpad
// object is handed to VB for the property browser). Taskpad also does not
// support ISpecifyPropertyPages because the taskpad property pages (see
// mssnapd\pstaskp.cpp) need the ITaskpadViewDef interface and that is not
// available from the ITaskpad that the property page would receive if the
// user hit the Custom ... button in the property browser. When the user
// selects the properties button or context menu item within the designer
// it is the designer itself that is calling OleCreatePropertyFrame() so
// it can pass the ITaskpadViewDef as the object (see
// CSnapInDesigner::ShowTaskpadViewProperties() in mssnapd\taskpvw.cpp).
//

CTaskpadViewDef::CTaskpadViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASKPADVIEWDEF,
                            static_cast<ITaskpadViewDef *>(this),
                            static_cast<CTaskpadViewDef *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_TaskpadViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpadViewDef::~CTaskpadViewDef()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    RELEASE(m_piTaskpad);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();
}

void CTaskpadViewDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_UseWhenTaskpadViewPreferred = VARIANT_FALSE;
    m_piTaskpad = NULL;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CTaskpadViewDef::Create(IUnknown * punkOuter)
{
    CTaskpadViewDef *pTaskpadViewDef = New CTaskpadViewDef(punkOuter);
    if (NULL == pTaskpadViewDef)
    {
        return NULL;
    }
    else
    {
        return pTaskpadViewDef->PrivateUnknown();
    }
}



HRESULT CTaskpadViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}



//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CTaskpadViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
//

HRESULT CTaskpadViewDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piTaskpad));
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDef::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistSimpleType(&m_UseWhenTaskpadViewPreferred, VARIANT_FALSE, OLESTR("UseWhenTaskpadViewPreferred")));

    IfFailRet(PersistObject(&m_piTaskpad, CLSID_Taskpad,
                            OBJECT_TYPE_TASKPAD, IID_ITaskpad,
                            OLESTR("Taskpad")));
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITaskpadViewDef == riid)
    {
        *ppvObjOut = static_cast<ITaskpadViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdefs.h ===
//=--------------------------------------------------------------------------=
// tpdvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TPDVDEFS_DEFINED_
#define _TPDVDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class CTaskpadViewDefs : public CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>,
                         public CPersistence
{
    protected:
        CTaskpadViewDefs(IUnknown *punkOuter);
        ~CTaskpadViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(TaskpadViewDefs,           // name
                                &CLSID_TaskpadViewDefs,    // clsid
                                "TaskpadViewDefs",         // objname
                                "TaskpadViewDefs",         // lblname
                                &CTaskpadViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_ITaskpadViewDefs,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _TPDVDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdefs.cpp ===
//=--------------------------------------------------------------------------=
// tpdvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tpdvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTaskpadViewDefs::CTaskpadViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>(
                                          punkOuter,
                                          OBJECT_TYPE_TASKPADVIEWDEFS,
                                          static_cast<ITaskpadViewDefs *>(this),
                                          static_cast<CTaskpadViewDefs *>(this),
                                          CLSID_TaskpadViewDef,
                                          OBJECT_TYPE_TASKPADVIEWDEF,
                                          IID_ITaskpadViewDef,
                                          static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_TaskpadViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpadViewDefs::~CTaskpadViewDefs()
{
}

IUnknown *CTaskpadViewDefs::Create(IUnknown * punkOuter)
{
    CTaskpadViewDefs *pTaskpadViewDefs = New CTaskpadViewDefs(punkOuter);
    if (NULL == pTaskpadViewDefs)
    {
        return NULL;
    }
    else
    {
        return pTaskpadViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDefs::Persist()
{
    HRESULT          hr = S_OK;
    ITaskpadViewDef *piTaskpadViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::Persist(piTaskpadViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_ITaskpadViewDefs == riid)
    {
        *ppvObjOut = static_cast<ITaskpadViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::GetMaster(ITaskpadViewDefs **ppiMasterTaskpadViewDefs)
{
    H_RRETURN(GetTaskpadViewDefs(ppiMasterTaskpadViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\viewdefs.cpp ===
//=--------------------------------------------------------------------------=
// viewdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "viewdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CViewDefs::CViewDefs(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_VIEWDEFS,
                            static_cast<IViewDefs *>(this),
                            static_cast<CViewDefs *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CViewDefs::~CViewDefs()
{
    RELEASE(m_piListViews);
    RELEASE(m_piOCXViews);
    RELEASE(m_piURLViews);
    RELEASE(m_piTaskpadViews);
    InitMemberVariables();
}

void CViewDefs::InitMemberVariables()
{
    m_piListViews = NULL;
    m_piOCXViews = NULL;
    m_piURLViews = NULL;
    m_piTaskpadViews = NULL;
}

IUnknown *CViewDefs::Create(IUnknown * punkOuter)
{
    CViewDefs *pViewDefs = New CViewDefs(punkOuter);
    if (NULL == pViewDefs)
    {
        return NULL;
    }
    else
    {
        return pViewDefs->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piListViews, CLSID_ListViewDefs,
                           OBJECT_TYPE_LISTVIEWDEFS, IID_IListViewDefs,
                           OLESTR("ListViews")));

    IfFailGo(PersistObject(&m_piOCXViews, CLSID_OCXViewDefs,
                           OBJECT_TYPE_OCXVIEWDEFS, IID_IOCXViewDefs,
                           OLESTR("OCXViews")));

    IfFailGo(PersistObject(&m_piURLViews, CLSID_URLViewDefs,
                           OBJECT_TYPE_URLVIEWDEFS, IID_IURLViewDefs,
                           OLESTR("URLViews")));

    IfFailGo(PersistObject(&m_piTaskpadViews, CLSID_TaskpadViewDefs,
                           OBJECT_TYPE_TASKPADVIEWDEFS, IID_ITaskpadViewDefs,
                           OLESTR("TaskpadViews")));
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IViewDefs == riid)
    {
        *ppvObjOut = static_cast<IViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListViews));
    IfFailRet(SetObjectHost(m_piOCXViews));
    IfFailRet(SetObjectHost(m_piURLViews));
    IfFailRet(SetObjectHost(m_piTaskpadViews));

    return S_OK;
}

HRESULT CViewDefs::OnKeysOnly()
{
    HRESULT hr = S_OK;

    IfFailRet(UseKeysOnly(m_piListViews));
    IfFailRet(UseKeysOnly(m_piOCXViews));
    IfFailRet(UseKeysOnly(m_piURLViews));
    IfFailRet(UseKeysOnly(m_piTaskpadViews));

    return S_OK;;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\viewdefs.h ===
//=--------------------------------------------------------------------------=
// viewdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _VIEWDEFS_DEFINED_
#define _VIEWDEFS_DEFINED_


class CViewDefs : public CSnapInAutomationObject,
                  public CPersistence,
                  public IViewDefs
{
    private:
        CViewDefs(IUnknown *punkOuter);
        ~CViewDefs();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IViewDefs

        OBJECT_PROPERTY_RO(CViewDefs, ListViews, IListViewDefs, DISPID_VIEWDEFS_LIST_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, OCXViews, IOCXViewDefs, DISPID_VIEWDEFS_OCX_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, URLViews, IURLViewDefs, DISPID_VIEWDEFS_URL_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, TaskpadViews, ITaskpadViewDefs, DISPID_VIEWDEFS_TASKPAD_VIEWS);
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        virtual HRESULT OnKeysOnly();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ViewDefs,              // name
                                &CLSID_ViewDefs,       // clsid
                                "ViewDefs",            // objname
                                "ViewDefs",            // lblname
                                &CViewDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IViewDefs,        // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _VIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\view.h ===
//=--------------------------------------------------------------------------=
// view.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CView class definition - implements View object
//
//=--------------------------------------------------------------------------=

#ifndef _VIEW_DEFINED_
#define _VIEW_DEFINED_

#include "spanitms.h"
#include "resview.h"
#include "listview.h"
#include "listitem.h"
#include "ctxtmenu.h"
#include "converbs.h"
#include "prpsheet.h"
#include "ctlbar.h"
#include "enumtask.h"
#include "clipbord.h"
#include "ctxtprov.h"
#include "pshtprov.h"

class CScopePaneItems;
class CSnapIn;
class CResultView;
class CMMCListView;
class CMMCListItem;
class CMMCToolbars;
class CMMCButton;
class CMMCButtonMenu;
class CContextMenu;
class CMMCConsoleVerbs;
class CControlbar;
class CEnumTask;
class CMMCContextMenuProvider;
class CMMCPropertySheetProvider;

//=--------------------------------------------------------------------------=
//
// class CView
//
// This is the object created in CSnapIn::CreateComponent to implement
// IComponentData::CreateComponent. It implements IComponent, persistence,
// MMC extension interfaces, and MMC virtual list and sorting interfaces.
//
// It is exposed to the VB programmer as the View object.
//
//=--------------------------------------------------------------------------=

class CView : public CSnapInAutomationObject,
              public IView,
              public IPersistStreamInit,
              public IPersistStream,
              public IComponent,
              public IExtendControlbar,
              public IExtendControlbarRemote,
              public IExtendContextMenu,
              public IExtendPropertySheet2,
              public IExtendPropertySheetRemote,
              public IExtendTaskPad,
              public IResultOwnerData,
              public IResultDataCompare,
              public IResultDataCompareEx
{
    public:
        CView(IUnknown *punkOuter);
        ~CView();
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IView
        BSTR_PROPERTY_RW(      CView,   Name,                                                                       DISPID_VALUE);
        SIMPLE_PROPERTY_RW(    CView,   Index,                 long,                                                DISPID_VIEW_INDEX);
        BSTR_PROPERTY_RW(      CView,   Key,                                                                        DISPID_VIEW_KEY);
        OBJECT_PROPERTY_RO(    CView,   ScopePaneItems,        IScopePaneItems,                                     DISPID_VIEW_SCOPEPANEITEMS);
        BSTR_PROPERTY_RW(      CView,   Caption,                                                                    DISPID_VIEW_CAPTION);
        VARIANTREF_PROPERTY_RW(CView,   Tag,                                                                        DISPID_VIEW_TAG);
        COCLASS_PROPERTY_RO(   CView,   ContextMenuProvider,   MMCContextMenuProvider,   IMMCContextMenuProvider,   DISPID_VIEW_CONTEXT_MENU_PROVIDER);
        COCLASS_PROPERTY_RO(   CView,   PropertySheetProvider, MMCPropertySheetProvider, IMMCPropertySheetProvider, DISPID_VIEW_PROPERTY_SHEET_PROVIDER);

        STDMETHOD(get_MMCMajorVersion)(long *plVersion);
        STDMETHOD(get_MMCMinorVersion)(long *plVersion);

        STDMETHOD(get_ColumnSettings)(BSTR ColumnSetID, ColumnSettings **ppColumnSettings);
        STDMETHOD(get_SortSettings)(BSTR ColumnSetID, SortKeys **ppSortKeys);

        STDMETHOD(SetStatusBarText)(BSTR Text);
        STDMETHOD(SelectScopeItem)(ScopeItem *ScopeItem, VARIANT ViewType, VARIANT DisplayString);
        STDMETHOD(PopupMenu)(MMCMenu *Menu, long Left, long Top);
        STDMETHOD(ExpandInTreeView)(ScopeNode *ScopeNode);
        STDMETHOD(CollapseInTreeView)(ScopeNode *ScopeNode);
        STDMETHOD(NewWindow)(ScopeNode                      *ScopeNode,
                             SnapInNewWindowOptionConstants  Options,
                             VARIANT                         Caption);

    // IComponent
        STDMETHOD(Initialize(IConsole *piConsole);
        STDMETHOD(Notify)(IDataObject * piDataObject,
                          MMC_NOTIFY_TYPE event,
                          long arg, long param);
        STDMETHOD(Destroy)(long cookie));
        STDMETHOD(QueryDataObject)(long cookie,
                                   DATA_OBJECT_TYPES type,
                                   IDataObject **ppiDataObject);
        STDMETHOD(GetResultViewType)(long cookie,
                                     LPOLESTR *ppViewType,
                                     long *pViewOptions);
        STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *piResultDataItem);
        STDMETHOD(CompareObjects)(IDataObject *piDataObjectA,
                                  IDataObject *piDataObjectB);

    // IExtendControlbar
        STDMETHOD(SetControlbar)(IControlbar *piControlbar);
        STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
                                    LPARAM arg, LPARAM param);

    // IExtendControlbarRemote
        STDMETHOD(MenuButtonClick)(IDataObject   *piDataObject,
                                  int             idCommand,
                                  POPUP_MENUDEF **ppPopupMenuDef);
        STDMETHOD(PopupMenuClick)(IDataObject *piDataObject,
                                  UINT         uIDItem,
                                  IUnknown    *punkParam);

    // IExtendContextMenu - public so CSnapIn can forward calls
        STDMETHOD(AddMenuItems)(IDataObject          *piDataObject,
                                IContextMenuCallback *piContextMenuCallback,
                                long                 *plInsertionAllowed);
        STDMETHOD(Command)(long lCommandID, IDataObject *piDataObject);

    // IExtendPropertySheet2
        STDMETHOD(CreatePropertyPages)(IPropertySheetCallback *piPropertySheetCallback,
                                       LONG_PTR handle,
                                       IDataObject *piDataObject);
        STDMETHOD(QueryPagesFor)(IDataObject *piDataObject);
        STDMETHOD(GetWatermarks)(IDataObject *piDataObject,
                                 HBITMAP     *phbmWatermark,
                                 HBITMAP     *phbmHeader,
                                 HPALETTE    *phPalette,
                                 BOOL        *bStretch);

    // IExtendPropertySheetRemote
        STDMETHOD(CreatePropertyPageDefs)(IDataObject         *piDataObject,
                                          WIRE_PROPERTYPAGES **ppPages);

    // IResultOwnerData
        STDMETHOD(FindItem)(RESULTFINDINFO *pFindInfo, int *pnFoundIndex);
        STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex);
        STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

    // IResultDataCompare
        STDMETHOD(Compare)(LPARAM      lUserParam,
                           MMC_COOKIE  cookieA,
                           MMC_COOKIE  cookieB,
                           int        *pnResult);

    // IResultDataCompareEx
        STDMETHOD(Compare)(RDCOMPARE *prdc, int *pnResult);

    // IExtendTaskPad
        STDMETHOD(TaskNotify)(IDataObject *piDataObject,
                              VARIANT     *arg,
                              VARIANT     *param);

        STDMETHOD(EnumTasks)(IDataObject  *piDataObject,
                             LPOLESTR      pwszTaskGroup,
                             IEnumTASK   **ppEnumTASK);

        STDMETHOD(GetTitle)(LPOLESTR pwszGroup, LPOLESTR *ppwszTitle);

        STDMETHOD(GetDescriptiveText)(LPOLESTR  pwszGroup,
                                      LPOLESTR *ppwszDescriptiveText);

        STDMETHOD(GetBackground)(LPOLESTR                 pwszGroup,
                                 MMC_TASK_DISPLAY_OBJECT *pTDO);

        STDMETHOD(GetListPadInfo)(LPOLESTR          pwszGroup,
                                  MMC_LISTPAD_INFO *pListPadInfo);


    // IPersistStreamInit and IPersistStream methods
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);
        STDMETHOD(InitNew)();

    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // Non-interface public methods
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        IConsole2 *GetIConsole2() { return m_piConsole2; }
        IConsoleVerb *GetIConsoleVerb() { return m_piConsoleVerb; } 
        IResultData *GetIResultData() { return m_piResultData; }
        IHeaderCtrl2 *GetIHeaderCtrl2() { return m_piHeaderCtrl2; }
        IColumnData *GetIColumnData() { return m_piColumnData; }
        CScopePaneItems *GetScopePaneItems() { return m_pScopePaneItems; }
        HRESULT InsertListItem(CMMCListItem *pMMCListItem);

        enum HeaderOptions { RemoveHeaders, DontRemoveHeaders };
        enum ListItemOptions { KeepListItems, DontKeepListItems };

        HRESULT CleanOutConsoleListView(HeaderOptions   HeaderOption,
                                        ListItemOptions ListItemOption);

        HRESULT GetCurrentListViewSelection(IMMCClipboard  **ppiMMCClipboard,
                                            CMMCDataObject **ppMMCDataObject);

        void ListItemUpdate(CMMCListItem *pMMCListItem);
        HRESULT OnDelete(IDataObject *piDataObject);
        CControlbar *GetControlbar() { return m_pControlbar; }

        HRESULT InternalCreatePropertyPages(IPropertySheetCallback  *piPropertySheetCallback,
                                            LONG_PTR                 handle,
                                            IDataObject             *piDataObject,
                                            WIRE_PROPERTYPAGES     **ppPages);
    private:

        void InitMemberVariables();
        void ReleaseConsoleInterfaces();
        HRESULT PopulateListView(CResultView *pResultView);
        HRESULT SetColumnHeaders(IMMCListView *piMMCListView);
        HRESULT InsertListItems(IMMCListView *piMMCListView);
        HRESULT OnInitOCX(IUnknown *punkControl);
        HRESULT OnShow(BOOL fShow, HSCOPEITEM hsi);
        HRESULT ActivateResultView(CScopePaneItem *pSelectedItem,
                                   CResultView    *pResultView);
        HRESULT DeactivateResultView(CScopePaneItem *pSelectedItem,
                                     CResultView    *pResultView);
        HRESULT OnSelect(IDataObject *piDataObject,
                         BOOL fScopeItem, BOOL fSelected);
        HRESULT GetImage(CMMCListItem *pMMCListItem, int *pnImage);
        HRESULT OnButtonClick(IDataObject *piDataObject, MMC_CONSOLE_VERB verb);
        HRESULT OnAddImages(IDataObject *piDataObject, IImageList *piImageList,
                            HSCOPEITEM hsi);
        HRESULT OnColumnClick(long lColumn, long lSortOptions);
        HRESULT OnDoubleClick(IDataObject *piDataObject);
        void OnActivate(BOOL fActivated);
        void OnMinimized(BOOL fMinimized);
        HRESULT OnListpad(IDataObject *piDataObject, BOOL fAttaching);
        HRESULT OnRestoreView(IDataObject       *piDataObject,
                              MMC_RESTORE_VIEW *pMMCRestoreView,
                              BOOL             *pfRestored);
        HRESULT FindMatchingViewDef(MMC_RESTORE_VIEW              *pMMCRestoreView,
                                    CScopePaneItem                *pScopePaneItem,
                                    BSTR                          *pbstrDisplayString,
                                    SnapInResultViewTypeConstants *pType,
                                    BOOL                          *pfFound);
        HRESULT FixupTaskpadDisplayString(SnapInResultViewTypeConstants   TaskpadType,
                                          BOOL                            fUsingListpad3,
                                          OLECHAR                        *pwszRestoreString,
                                          OLECHAR                       **ppwszFixedString);
        HRESULT ParseRestoreInfo(MMC_RESTORE_VIEW              *pMMCRestoreView,
                                 SnapInResultViewTypeConstants *pType);
        HRESULT IsTaskpad(OLECHAR                       *pwszDisplayString, 
                          SnapInResultViewTypeConstants *pType,
                          BOOL                          *pfUsingWrongNames,
                          BOOL                          *pfUsingListpad3);

        
        HRESULT GetScopeItemDisplayString(CScopeItem *pScopeItem, int nCol,
                                          LPOLESTR *ppwszString);
        HRESULT EnumPrimaryTasks(CEnumTask *pEnumTask);
        HRESULT EnumExtensionTasks(IMMCClipboard *piMMCClipboard,
                                   LPOLESTR pwszTaskGroup, CEnumTask *pEnumTask);
        HRESULT OnExtensionTaskNotify(IMMCClipboard *piMMCClipboard,
                                      VARIANT *arg, VARIANT *param);
        HRESULT OnPrimaryTaskNotify(VARIANT *arg, VARIANT *param);
        HRESULT OnRefresh(IDataObject *piDataObject);
        HRESULT OnPrint(IDataObject *piDataObject);
        HRESULT OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName);
        HRESULT OnViewChange(IDataObject *piDataObject, long idxListItem);
        HRESULT OnQueryPaste(IDataObject *piDataObjectTarget,
                             IDataObject *piDataObjectSource);
        HRESULT OnPaste(IDataObject  *piDataObjectTarget,
                        IDataObject  *piDataObjectSource,
                        IDataObject **ppiDataObjectRetToSource);
        HRESULT OnCutOrMove(IDataObject *piDataObjectFromTarget);
        HRESULT CreateMultiSelectDataObject(IDataObject **ppiDataObject);
        void OnDeselectAll();
        HRESULT OnContextHelp(IDataObject *piDataObject);
                
        enum VirtualListItemOptions { FireGetItemData, FireGetItemDisplayInfo };
        
        HRESULT GetVirtualListItem(long lIndex, CMMCListView *pMMCListView,
                                   VirtualListItemOptions Option,
                                   CMMCListItem **ppMMCListItem);
        HRESULT OnColumnsChanged(IDataObject *piDataObject,
                                 MMC_VISIBLE_COLUMNS *pVisibleColumns);
        HRESULT OnFilterButtonClick(long lColIndex, RECT *pRect);
        HRESULT OnFilterChange(MMC_FILTER_CHANGE_CODE ChangeCode, long lColIndex);
        HRESULT OnPropertiesVerb(IDataObject *piDataObject);
        HRESULT GetScopePaneItem(CScopeItem      *pScopeItem,
                                 CScopePaneItem **ppScopePaneItem);
        HRESULT GetCompareObject(RDITEMHDR     *pItemHdr,
                                 CScopeItem   **ppScopeItem,
                                 CMMCListItem **ppMMCListItem,
                                 IDispatch    **ppdispItem);
        HRESULT AddMenu(CMMCMenu *pMMCMenu, HMENU hMenu, CMMCMenus *pMMCMenus);

        CSnapIn          *m_pSnapIn;
        CScopePaneItems  *m_pScopePaneItems;
        IConsole2        *m_piConsole2;
        IResultData      *m_piResultData; 
        IHeaderCtrl2     *m_piHeaderCtrl2;
        IColumnData      *m_piColumnData;
        IImageList       *m_piImageList;
        IConsoleVerb     *m_piConsoleVerb;

        CMMCConsoleVerbs *m_pMMCConsoleVerbs;   // IMMCConsoleVerb implementation

        CContextMenu     *m_pContextMenu;       // implements MMC's
                                                // IExtendContextMenu and
                                                // our IContextMenu

        CControlbar      *m_pControlbar;        // Implements MMC's
                                                // IExtendControlbar and our
                                                // IMMCControlbar

        ITasks           *m_piTasks;            // Tasks collection for
                                                // IExtendTaskpad

        BOOL              m_fVirtualListView;   // TRUE=m_piResultData is
                                                // currently referencing a
                                                // virtual listview.

        BOOL              m_fPopulatingListView;// TRUE=currently populating
                                                // listview

        CMMCListItem     *m_pCachedMMCListItem; // When display info is first
                                                // requested for a virtual list
                                                // item we fire ResultViews_
                                                // GetVirtualItemDisplayInfo once
                                                // and then store that listitem
                                                // until another item is
                                                // requested or until the snap-in
                                                // changes a dislay property on
                                                // the listitem.

        // IMMCContextMenuProvider implementation
        
        CMMCContextMenuProvider *m_pMMCContextMenuProvider;

        // IMMCPropertySheetProvider implementation

        CMMCPropertySheetProvider *m_pMMCPropertySheetProvider;

        // Cached string of CLSID_MessageView
        static OLECHAR m_wszCLSID_MessageView[39];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(View,                   // name
                                &CLSID_View,            // clsid
                                "View",                 // objname
                                "View",                 // lblname
                                &CView::Create,         // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IView,             // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _VIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdef.cpp ===
//=--------------------------------------------------------------------------=
// urlvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "urlvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CURLViewDef::m_rgpPropertyPageCLSIDs[1] = { &CLSID_URLViewDefGeneralPP };


#pragma warning(disable:4355)  // using 'this' in constructor

CURLViewDef::CURLViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_URLVIEWDEF,
                            static_cast<IURLViewDef *>(this),
                            static_cast<CURLViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_URLViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CURLViewDef::~CURLViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrURL);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();
}

void CURLViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;

    ::VariantInit(&m_varTag);

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrURL = NULL;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CURLViewDef::Create(IUnknown * punkOuter)
{
    CURLViewDef *pURLViewDef = New CURLViewDef(punkOuter);
    if (NULL == pURLViewDef)
    {
        return NULL;
    }
    else
    {
        return pURLViewDef->PrivateUnknown();
    }
}


HRESULT CURLViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDef::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IURLViewDef == riid)
    {
        *ppvObjOut = static_cast<IURLViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdefs.h ===
//=--------------------------------------------------------------------------=
// urlvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _URLVIEWDEFS_DEFINED_
#define _URLVIEWDEFS_DEFINED_

#define MASTER_COLLECTION

#include "collect.h"

class CURLViewDefs : public CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>,
                     public CPersistence
{
    protected:
        CURLViewDefs(IUnknown *punkOuter);
        ~CURLViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(URLViewDefs,           // name
                                &CLSID_URLViewDefs,    // clsid
                                "URLViewDefs",         // objname
                                "URLViewDefs",         // lblname
                                &CURLViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IURLViewDefs,     // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _URLVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\view.cpp ===
//=--------------------------------------------------------------------------=
// view.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "view.h"
#include "spanitms.h"
#include "listview.h"
#include "colhdrs.h"
#include "colhdr.h"
#include "colsets.h"
#include "listitms.h"
#include "listitem.h"
#include "lsubitms.h"
#include "lsubitem.h"
#include "scopitms.h"
#include "scopitem.h"
#include "scitdef.h"
#include "views.h"
#include "ocxvdef.h"
#include "ocxvdefs.h"
#include "urlvdef.h"
#include "urlvdefs.h"
#include "tpdvdef.h"
#include "tpdvdefs.h"
#include "menu.h"
#include "sortkeys.h"

// for ASSERT and FAIL
//
SZTHISFILE

OLECHAR CView::m_wszCLSID_MessageView[39] = { L'\0' };

#pragma warning(disable:4355)  // using 'this' in constructor

CView::CView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_VIEW,
                            static_cast<IView *>(this),
                            static_cast<CView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CView::~CView()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrCaption);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piScopePaneItems);
    RELEASE(m_piContextMenuProvider);
    RELEASE(m_piPropertySheetProvider);
    if (NULL != m_pMMCConsoleVerbs)
    {
        m_pMMCConsoleVerbs->Release();
    }
    if (NULL != m_pContextMenu)
    {
        m_pContextMenu->Release();
    }
    if (NULL != m_pControlbar)
    {
        m_pControlbar->Release();
    }
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
    }
    RELEASE(m_piTasks);
    InitMemberVariables();
}

void CView::ReleaseConsoleInterfaces()
{
    (void)CleanOutConsoleListView(RemoveHeaders, DontKeepListItems);
    RELEASE(m_piConsole2);
    RELEASE(m_piResultData); 
    RELEASE(m_piHeaderCtrl2);
    RELEASE(m_piColumnData);
    RELEASE(m_piImageList);
    RELEASE(m_piConsoleVerb);
}




void CView::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrCaption = NULL;

    ::VariantInit(&m_varTag);

    m_piScopePaneItems = NULL;
    m_pScopePaneItems = NULL;
    m_piContextMenuProvider = NULL;
    m_pMMCContextMenuProvider = NULL;
    m_piPropertySheetProvider = NULL;
    m_pMMCPropertySheetProvider = NULL;
    m_pSnapIn = NULL;

    m_piConsole2 = NULL;
    m_piResultData = NULL; 
    m_piHeaderCtrl2 = NULL;
    m_piColumnData = NULL;
    m_piImageList = NULL;
    m_piConsoleVerb = NULL;
    m_pMMCConsoleVerbs = NULL;
    m_pContextMenu = NULL;
    m_pControlbar = NULL;
    m_piTasks = NULL;
    m_fVirtualListView = FALSE;
    m_fPopulatingListView = FALSE;
    m_pCachedMMCListItem = NULL;
}




IUnknown *CView::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopePaneItems = CScopePaneItems::Create(NULL);
    IUnknown *punkContextMenu = CContextMenu::Create(NULL);
    IUnknown *punkControlbar = CControlbar::Create(NULL);
    IUnknown *punkMMCConsoleVerbs = CMMCConsoleVerbs::Create(NULL);
    IUnknown *punkMMCContextMenuProvider = CMMCContextMenuProvider::Create(NULL);
    IUnknown *punkMMCPropertySheetProvider = CMMCPropertySheetProvider::Create(NULL);
    CView    *pView = New CView(punkOuter);

    if ( (NULL == pView)                        ||
         (NULL == punkScopePaneItems)           ||
         (NULL == punkContextMenu)              ||
         (NULL == punkControlbar)               ||
         (NULL == punkMMCConsoleVerbs)          ||
         (NULL == punkMMCContextMenuProvider)   ||
         (NULL == punkMMCPropertySheetProvider)
       )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopePaneItems->QueryInterface(IID_IScopePaneItems,
                      reinterpret_cast<void **>(&pView->m_piScopePaneItems)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pView->m_piScopePaneItems,
                                                   &pView->m_pScopePaneItems));
    pView->m_pScopePaneItems->SetParentView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkContextMenu,
                                                   &pView->m_pContextMenu));
    
    pView->m_pContextMenu->SetView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkControlbar,
                                                   &pView->m_pControlbar));
    pView->m_pControlbar->SetView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCConsoleVerbs,
                                                   &pView->m_pMMCConsoleVerbs));
    IfFailGo(pView->m_pMMCConsoleVerbs->SetView(pView));

    IfFailGo(punkMMCContextMenuProvider->QueryInterface(
                    IID_IMMCContextMenuProvider,
                    reinterpret_cast<void **>(&pView->m_piContextMenuProvider)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCContextMenuProvider,
                                             &pView->m_pMMCContextMenuProvider));

    IfFailGo(punkMMCPropertySheetProvider->QueryInterface(
                  IID_IMMCPropertySheetProvider,
                  reinterpret_cast<void **>(&pView->m_piPropertySheetProvider)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                            punkMMCPropertySheetProvider,
                                           &pView->m_pMMCPropertySheetProvider));

Error:
    QUICK_RELEASE(punkScopePaneItems);
    QUICK_RELEASE(punkMMCContextMenuProvider);
    QUICK_RELEASE(punkMMCPropertySheetProvider);
    if (FAILEDHR(hr))
    {
        if (NULL != pView)
        {
            delete pView;
        }
        else
        {
            // Managed to create contained objects but not view.
            QUICK_RELEASE(punkScopePaneItems);
            QUICK_RELEASE(punkContextMenu);
            QUICK_RELEASE(punkControlbar);
            QUICK_RELEASE(punkMMCConsoleVerbs);
            QUICK_RELEASE(punkMMCContextMenuProvider);
            QUICK_RELEASE(punkMMCPropertySheetProvider);
        }
        return NULL;
    }
    else
    {
        return pView->PrivateUnknown();
    }
}



void CView::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pScopePaneItems->SetSnapIn(pSnapIn);
    m_pContextMenu->SetSnapIn(pSnapIn);
    m_pControlbar->SetSnapIn(pSnapIn);
}



HRESULT CView::OnInitOCX(IUnknown *punkControl)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->SetControl(punkControl));

Error:
    RRETURN(hr);
}



HRESULT CView::OnShow(BOOL fShow, HSCOPEITEM hsi)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    IfFalseGo(hsi == pSelectedItem->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM(), SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (fShow)
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siURLView:
            case siOCXView:
            case siMessageView:
                IfFailGo(ActivateResultView(pSelectedItem, pResultView));
                break;
        }
    }
    else
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siURLView:
            case siOCXView:
            case siTaskpad:
            case siListpad:
            case siMessageView:
                IfFailGo(DeactivateResultView(pSelectedItem, pResultView));
                break;
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CView::ActivateResultView
(
    CScopePaneItem *pSelectedItem,
    CResultView    *pResultView
)
{
    HRESULT       hr = S_OK;
    CMMCListView *pListView = NULL;
    
    // ASSERT(!pSelectedItem->Active(), "CView::ActivateResultView() called for an active ScopePaneItem");

    // The result pane is about to be shown. Fire ResultViews_Activate
    // so that the snap-in knows the result view is about to be displayed.

    // First clean out the current contents of the listview (if any)

    if (siListView == pResultView->GetActualType())
    {
        IfFailGo(CleanOutConsoleListView(RemoveHeaders, DontKeepListItems));
    }

    pSelectedItem->SetActive(TRUE);
    pResultView->SetInActivate(TRUE);

    // For virtual list views we need to set up column headers first because the
    // snap-in will set the item count during ResultViews_Activate and MMC
    // does not permit inserting columns after the item count has been set. This
    // means that snap-ins setting up columns programmatically should do so in
    // ResultViews_Initialize.

    if (siListView == pResultView->GetActualType())
    {
        pListView = pResultView->GetListView();
        if (pListView->IsVirtual())
        {
            IfFailGo(SetColumnHeaders(pListView));
        }
    }
    
    m_pSnapIn->GetResultViews()->FireActivate(pResultView);
    pResultView->SetInActivate(FALSE);

    // If the result view type is a listview or a listpad then we need to
    // populate it in the console

    switch (pResultView->GetActualType())
    {
        case siListView:
        case siListpad:
            IfFailGo(PopulateListView(pResultView));
            break;

        case siMessageView:
            IfFailGo(pResultView->GetMessageView()->Populate());
            break;
    }

Error:
    RRETURN(hr);
}



HRESULT CView::DeactivateResultView
(
    CScopePaneItem *pSelectedItem,
    CResultView    *pResultView
)
{
    HRESULT hr = S_OK;
    BOOL    fKeep = FALSE;

    // Under certain circumstances MMCN_SHOW(FALSE) can be sent twice so we
    // need to check whether the ResultView has already been deactivated.

    // Sample scenario for this case:
    // Node displays taskpad.
    // User clicks task that has URL action.
    // HTML page uses MMCCtrl to send task notify on button push. Snap-in
    // reselects node during notify to redisplay taskpad.
    // Taskpad is redisplayed. User hits back button.
    // Snap-in gets MMCN_SHOW(FALSE)
    // HTML page is displayed again.
    // User hits forward button to return to taskpad.
    // Snap-in gets MMCN_SHOW(FALSE) again.

    IfFalseGo(pSelectedItem->Active(), S_OK);

    // The result pane is going away. Give the snap-in a chance to clean up
    // and decide whether to keep the result view in ResultViews_Deactivate 

    pSelectedItem->SetActive(FALSE);

    m_pSnapIn->GetResultViews()->FireDeactivate(pResultView, &fKeep);

    if (!fKeep)
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siListpad:
                IfFailGo(CleanOutConsoleListView(RemoveHeaders, DontKeepListItems));
                break;
        }
        IfFailGo(pSelectedItem->DestroyResultView());
    }
    else
    {
        // Keeping the result view alive. If it is a list view we still
        // need to release the refs we added for presence in the MMC
        // list view but we want to keep the MMCListItems collection alive.

        switch (pResultView->GetActualType())
        {
            case siListView:
            case siListpad:
                IfFailGo(CleanOutConsoleListView(RemoveHeaders, KeepListItems));
                break;
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CView::OnListpad
(
    IDataObject *piDataObject,
    BOOL         fAttaching
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    IImageList     *piImageList = NULL;
    HSCOPEITEM      hsi = NULL;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    // Check that this is our scope item.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

    // It should belong to our currently selected scope pane item.

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    hsi = pMMCDataObject->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM();
    IfFalseGo(hsi == pSelectedItem->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM(), SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // We've got the scope item. This notification is essentially MMCN_ADD_IMAGES
    // followed by MMCN_SHOW for listpads so let those routines handle it.

    // For images we need to call IConsole2::QueryResultImageList() because it is
    // not passed in as with MMCN_ADD_IMAGES.
    
    if (fAttaching)
    {
        IfFailGo(m_piConsole2->QueryResultImageList(&piImageList));
        IfFailGo(OnAddImages(piDataObject, piImageList, hsi));
        IfFailGo(ActivateResultView(pSelectedItem, pResultView));
    }
    else
    {
        IfFailGo(DeactivateResultView(pSelectedItem, pResultView));
    }

Error:
    QUICK_RELEASE(piImageList);
    RRETURN(hr);
}




HRESULT CView::OnRestoreView
(
    IDataObject      *piDataObject,
    MMC_RESTORE_VIEW *pMMCRestoreView,
    BOOL             *pfRestored
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    CScopeItem     *pScopeItem = NULL;
    CScopePaneItem *pScopePaneItem = NULL;
    CResultViews   *pResultViews = NULL;
    CResultView    *pResultView = NULL;
    IResultView    *piResultView = NULL;
    long            cResultViews = 0;
    long            i = 0;
    BSTR            bstrResultViewDisplayString = NULL;
    BSTR            bstrDisplayString = NULL;
    BOOL            fFoundViewDef = FALSE;

    SnapInResultViewTypeConstants Type = siUnknown;

    // UNDONE: until MMC 1.2 is fixed if the display string is "" then change
    // it to NULL.

    if (NULL != pMMCRestoreView->pViewType)
    {
        if (L'\0' == pMMCRestoreView->pViewType[0])
        {
            pMMCRestoreView->pViewType = NULL;
        }
    }

    // Reset our virtual list view flag because we are transitioning to a new
    // result view.

    m_fVirtualListView = FALSE;

    // We always restore. If FALSE is returned here, for history navigation MMC
    // will generate a menu command MMCC_STANDARD_VIEW_SELECT which is
    // meaningless for us. For column persistence, (e.g. the user selected a
    // node that has persisted column configuration), if FALSE is returned
    // MMC will call IComponent::GetResultViewType(). While we could handle the
    // GetResultViewType() call, the logic is already here to handle the
    // MMCN_RESTORE_VIEW and we have no way to differentiate between these two
    // different circumstances.
    
    *pfRestored = TRUE;

    // The IDataObject should represent one of our scope items and it should
    // already have a ScopePaneItem as we are restoring a previously displayed
    // result view. If any of these checks fail we still return S_OK because
    // MMC ignores the return.

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_OK);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), S_OK);

    IfFailGo(GetScopePaneItem(pMMCDataObject->GetScopeItem(), &pScopePaneItem));

    // Set the scope item as currently selected as we would in
    // GetResultViewType() and mark it as active.

    m_pScopePaneItems->SetSelectedItem(pScopePaneItem);
    pScopePaneItem->SetActive(TRUE);

    // This result view was already displayed for this scope item at some point.
    // If it was a predefined then we can scan its view definitions for one
    // that has a matching actual display string. If it is a listview then the
    // display string will be NULL and we will find the first defined listview
    // (if any).

    IfFailGo(FindMatchingViewDef(pMMCRestoreView, pScopePaneItem,
                                 &bstrDisplayString, &Type, &fFoundViewDef));

    if (!fFoundViewDef)
    {
        // No predefined view matched. We must assume it was defined in code.
        // We need to determine its type by examining the restored display string.

        IfFailGo(ParseRestoreInfo(pMMCRestoreView, &Type));
        bstrDisplayString = static_cast<BSTR>(pMMCRestoreView->pViewType);
    }

    // At this point we have display string & type. Set them in the ScopePaneItem.

    ASSERT(siUnknown != Type, "OnRestoreView does not have view type as expected");

    IfFailGo(pScopePaneItem->put_DisplayString(bstrDisplayString));
    IfFailGo(pScopePaneItem->put_ResultViewType(Type));

    // The snap-in may have kept the ResultView alive so we need to scan
    // ScopePaneItem.ResultViews for a matching view type and display string.
    // If found and it is code-defined then get its type so we don't make the
    // potential mixup between a URL view and a custom taskpad as they cannot
    // be discerned by examining the display string. If not found then the
    // snap-in must live with that mixup. We document this danger of using
    // code-defined views but it should not be significant because a custom
    // taskpad mistaken for a URL view can still generate TaskNotify events.

    // Check for NULL. That would be the case for a listview defined in VB code.

    if (NULL != bstrDisplayString)
    {
        pResultViews = pScopePaneItem->GetResultViews();
        cResultViews = pResultViews->GetCount();

        for (i = 0; i < cResultViews; i++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pResultViews->GetItemByIndex(i),
                                                 &pResultView));
            bstrResultViewDisplayString = pResultView->GetDisplayString();
            if (NULL != bstrResultViewDisplayString)
            {
                if (0 == ::wcscmp(bstrResultViewDisplayString,
                                  bstrDisplayString))
                {
                    pScopePaneItem->SetResultView(pResultView);
                    break;
                }
            }
            pResultView = NULL;
        }
    }

    // If we didn't find a ResultView then create a new one using the
    // ScopePaneItem's last view type and display string settings

    if (NULL == pResultView)
    {
        IfFailGo(pScopePaneItem->CreateNewResultView(
                                                   pMMCRestoreView->lViewOptions,
                                                   &piResultView));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &pResultView));
        pScopePaneItem->SetResultView(pResultView);
    }


    if ( (pMMCRestoreView->lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) != 0 )
    {
        m_fVirtualListView = TRUE;
    }

Error:
    if (fFoundViewDef)
    {
        FREESTRING(bstrDisplayString);
    }
    QUICK_RELEASE(piResultView);
    RRETURN(hr);
}





HRESULT CView::FindMatchingViewDef
(
    MMC_RESTORE_VIEW              *pMMCRestoreView,
    CScopePaneItem                *pScopePaneItem,
    BSTR                          *pbstrDisplayString,
    SnapInResultViewTypeConstants *pType,
    BOOL                          *pfFound
)
{
    HRESULT                     hr = S_OK;

    IViewDefs                  *piViewDefs = NULL;
    IScopeItemDef              *piScopeItemDef = NULL; // not AddRef()ed
    
    IListViewDefs              *piListViewDefs = NULL;
    IListViewDef               *piListViewDef = NULL;

    IOCXViewDefs               *piOCXViewDefs = NULL;
    COCXViewDefs               *pOCXViewDefs = NULL;
    COCXViewDef                *pOCXViewDef = NULL;
    CLSID                       clsidOCX = CLSID_NULL;

    IURLViewDefs               *piURLViewDefs = NULL;
    CURLViewDefs               *pURLViewDefs = NULL;
    CURLViewDef                *pURLViewDef = NULL;

    ITaskpadViewDefs           *piTaskpadViewDefs = NULL;
    CTaskpadViewDefs           *pTaskpadViewDefs = NULL;
    CTaskpadViewDef            *pTaskpadViewDef = NULL;

    long                        cViews = 0;
    long                        i = 0;

    OLECHAR                    *pwszActualDisplayString = NULL;
    OLECHAR                    *pwszFixedString = NULL;
    BOOL                        fUsingWrongNames = FALSE;
    BOOL                        fUsingListpad3 = FALSE;

    SnapInResultViewTypeConstants TaskpadType = siUnknown;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Initialize out parameters

    *pbstrDisplayString = NULL;
    *pType = siUnknown;
    *pfFound = FALSE;

    // Get the appropriate ViewDefs collection

    if (pScopePaneItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        piScopeItemDef = pScopePaneItem->GetScopeItem()->GetScopeItemDef();
        if (NULL != piScopeItemDef)
        {
            IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
        }
    }

    // If this is a code defined scope item then it won't have any predefined
    // views.

    IfFalseGo(NULL != piViewDefs, S_OK);

    // If the restored display string is NULL then look for the first listview.
    // If none is found then this is a code-defined listview.

    if (NULL == pMMCRestoreView->pViewType)
    {
        *pType = siListView;
        
        IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
        IfFailGo(piListViewDefs->get_Count(&cViews));
        IfFalseGo(0 != cViews, S_OK);

        // As we cannot discern between defined listviews, we need to take
        // the first one. This is why we do not recommend using multiple
        // listviews for a single scope item.

        varKey.vt = VT_I4;
        varKey.lVal = 1L;
        IfFailGo(piListViewDefs->get_Item(varKey, &piListViewDef));
        IfFailGo(piListViewDef->get_Name(pbstrDisplayString));
        *pType = siPreDefined;
        *pfFound = TRUE;
        goto Error;
    }

    // The restored display string is not NULL. Now just scan all the predefined
    // views for one that matches.

    // NOTE: we do not have to do real get_Item calls when scanning the
    // collections because if the view was previously displayed then the
    // collection has already been synced with its master and contains real
    // items. (See CSnapInCollection::get_Item() in collect.h).

    // Check for an OCX view

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDefs, &pOCXViewDefs));
    cViews = pOCXViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pOCXViewDefs->GetItemByIndex(i),
                                                 &pOCXViewDef));
        pwszActualDisplayString = pOCXViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pMMCRestoreView->pViewType))
            {
                IfFailGo(pOCXViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

    // Check for a URL view

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDefs, &pURLViewDefs));
    cViews = pURLViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pURLViewDefs->GetItemByIndex(i),
                                                 &pURLViewDef));
        pwszActualDisplayString = pURLViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pMMCRestoreView->pViewType))
            {
                IfFailGo(pURLViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

    // Check for a taskpad. Due to an MMC bug there can be circumstances where
    // the restored display string for a taskpad might contain "reload.htm"
    // instead of "default.htm". Listpads also might have "reload2.htm" instead
    // of "listpad.htm". The view def will have stored the original correct
    // display string so if the string is a taskpad/listpad with the alternate
    // names then make a correct copy of it and use that for the comparison.

    // First check whether it is indeed a taskpad or a listpad by parsing the
    // string.

    IfFailGo(IsTaskpad(pMMCRestoreView->pViewType, &TaskpadType,
                       &fUsingWrongNames, &fUsingListpad3));
    IfFalseGo(siUnknown != TaskpadType, S_OK);

    // Now check for the "reload" names and fixup the string.

    if (fUsingWrongNames)
    {
        IfFailGo(FixupTaskpadDisplayString(TaskpadType, fUsingListpad3,
                                           pMMCRestoreView->pViewType,
                                           &pwszFixedString));
    }
    else
    {
        pwszFixedString = pMMCRestoreView->pViewType;
    }

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDefs, &pTaskpadViewDefs));
    cViews = pTaskpadViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pTaskpadViewDefs->GetItemByIndex(i),
                                             &pTaskpadViewDef));
        pwszActualDisplayString = pTaskpadViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pwszFixedString))
            {
                IfFailGo(pTaskpadViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piTaskpadViewDefs);
    (void)::VariantClear(&varKey);

    if ( (fUsingWrongNames) && (NULL != pwszFixedString) )
    {
        ::CtlFree(pwszFixedString);
    }
    RRETURN(hr);

}

//=--------------------------------------------------------------------------=
// CView::FixupTaskpadDisplayString
//=--------------------------------------------------------------------------=
//
// Parameters:
//  SnapInResultViewTypeConstants TaskpadType [in] siTaskpad or siListpad
//  OLECHAR *pwszRestoreString  [in] display string from MMCN_RESTORE_VIEW
//  OLECHAR **ppwszFixedString  [out] string with reload/reload2 changed
//                                    to default/listpad
//
// Output:
//      HRESULT
//
// Notes:
//
// Examines a restored display string and checks for an MMC bug where default
// taskpads may use "reload.htm" instead of "default.htm". Also checks for
// listpads that may use "reload2.htm" instead of "listpad.htm". If found
// then replaces these names with their correct counterparts.
//
// This function assumes that the restore strings has been parsed and that it
// was found to contain either a default taskpad or listpad using the incorrect
// names.
//
// Caller must free string with CtlFree().
//


HRESULT CView::FixupTaskpadDisplayString
(
    SnapInResultViewTypeConstants   TaskpadType,
    BOOL                            fUsingListpad3,
    OLECHAR                        *pwszRestoreString,
    OLECHAR                       **ppwszFixedString
)
{
    HRESULT  hr = S_OK;
    OLECHAR *pwszFixedString = NULL;
    size_t   cchRestoreString = ::wcslen(pwszRestoreString);
    size_t   cchFixedString = 0;
    OLECHAR *pwszReplace = NULL;
    OLECHAR *pwszOldString = NULL;
    OLECHAR *pwszNewString = NULL;
    size_t   cchOldString = 0;
    size_t   cchNewString = 0;
    size_t   cchStart = 0;

    *ppwszFixedString = 0;

    ASSERT( ((siTaskpad == TaskpadType) || (siListpad == TaskpadType)), "CView::FixupTaskpadDisplayString received bad taskpad type");

    if (siTaskpad == TaskpadType)
    {
        cchFixedString = cchRestoreString - CCH_DEFAULT_TASKPAD2 +
                         CCH_DEFAULT_TASKPAD;

        pwszOldString = DEFAULT_TASKPAD2;
        cchOldString = CCH_DEFAULT_TASKPAD2;

        pwszNewString = DEFAULT_TASKPAD;
        cchNewString = CCH_DEFAULT_TASKPAD;
    }
    else if (!fUsingListpad3)
    {
        cchFixedString = cchRestoreString - CCH_LISTPAD2 + CCH_LISTPAD;

        pwszOldString = LISTPAD2;
        cchOldString = CCH_LISTPAD2;

        pwszNewString = LISTPAD;
        cchNewString = CCH_LISTPAD;
    }
    else
    {
        cchFixedString = cchRestoreString - CCH_LISTPAD3 + CCH_LISTPAD_HORIZ;

        pwszOldString = LISTPAD3;
        cchOldString = CCH_LISTPAD3;

        pwszNewString = LISTPAD_HORIZ;
        cchNewString = CCH_LISTPAD_HORIZ;
    }

    pwszFixedString = (OLECHAR *)::CtlAlloc((cchFixedString + 1) * sizeof(WCHAR));
    if (NULL == pwszFixedString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pwszReplace = ::wcsstr(pwszRestoreString, pwszOldString);

    cchStart = pwszReplace - pwszRestoreString;

    ::memcpy(pwszFixedString, pwszRestoreString,
             cchStart * sizeof(WCHAR));

    ::memcpy(pwszFixedString + cchStart,
             pwszNewString,
             cchNewString * sizeof(WCHAR));

    ::wcscpy(pwszFixedString + cchStart + cchNewString,
             pwszRestoreString + cchStart + cchOldString);

    *ppwszFixedString = pwszFixedString;

Error:
    if (FAILED(hr))
    {
        if (NULL != pwszFixedString)
        {
            ::CtlFree(pwszFixedString);
        }
    }
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::ParseRestoreInfo
//=--------------------------------------------------------------------------=
//
// Parameters:
//  MMC_RESTORE_VIEW              *pMMCRestoreView [in] from MMC
//  SnapInResultViewTypeConstants *pType           [out] type found
//
// Output:
//      HRESULT
//
// Notes:
//
// Examines a restored display string and determines the result view type.
// A listview has a NULL or empty display string
// An OCX view starts with '{'.
// A message view also starts with '{' but it contains CLSID_MessageView.
// A default taskpad starts with "res://" and ends with "default.htm"
// or "listpad.htm".
// Anything else is assumed to be a URL view. We could mistake a
// custom taskpad for a URL view but it won't really matter as any
// MMCCtrl.TaskNotify calls will still invoke our
// IExtendTaskpad::TaskNotify.
//

HRESULT CView::ParseRestoreInfo
(
    MMC_RESTORE_VIEW              *pMMCRestoreView,
    SnapInResultViewTypeConstants *pType
)
{
    HRESULT hr = S_OK;
    BOOL    fUsingWrongNames = FALSE;
    BOOL    fUsingListpad3 = FALSE;

    *pType = siUnknown;

    if (NULL == pMMCRestoreView->pViewType)
    {
        *pType = siListView;
    }
    else if (L'{' == *pMMCRestoreView->pViewType)
    {
        // Could be an OCX view or a message view. Check the CLSID to see
        // if it is MMC's CLSID_MessageView. If we haven't cached the string
        // yet then do so now.

        if (L'\0' == m_wszCLSID_MessageView[0])
        {
            if (0 == ::StringFromGUID2(CLSID_MessageView, m_wszCLSID_MessageView,
                                       sizeof(m_wszCLSID_MessageView) /
                                       sizeof(m_wszCLSID_MessageView[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }
        }
        if (::wcscmp(m_wszCLSID_MessageView, pMMCRestoreView->pViewType) == 0)
        {
            *pType = siMessageView;
        }
        else
        {
            *pType = siOCXView;
        }
    }
    else 
    {
        IfFailGo(IsTaskpad(pMMCRestoreView->pViewType, pType,
                           &fUsingWrongNames, &fUsingListpad3));
        
        if (siUnknown == *pType) // not a taskpad
        {
            // assume URL view
            *pType = siURLView;
        }
    }

Error:
    RRETURN(hr);
}




HRESULT CView::IsTaskpad
(
    OLECHAR                       *pwszDisplayString, 
    SnapInResultViewTypeConstants *pType,
    BOOL                          *pfUsingWrongNames,
    BOOL                          *pfUsingListpad3
)
{
    HRESULT  hr = S_OK;
    OLECHAR *pwszMMCExePath = m_pSnapIn->GetMMCExePathW();
    size_t   cchMMCExePath = ::wcslen(pwszMMCExePath);
    OLECHAR *pwszTaskpadName = NULL;
    size_t   cchDisplayString = ::wcslen(pwszDisplayString);
    size_t   cchRemaining = 0;

    *pType = siUnknown;
    *pfUsingWrongNames = FALSE;
    *pfUsingListpad3 = FALSE;

    // Check if string starts with "res://"

    IfFalseGo(cchDisplayString > CCH_RESURL, S_OK);

    IfFalseGo( (0 == ::memcmp(pwszDisplayString, RESURL,
                              CCH_RESURL * sizeof(WCHAR))), S_OK);

    // Check res:// is followed by the MMC.EXE path

    IfFalseGo(cchDisplayString > CCH_RESURL + cchMMCExePath, S_OK);

    IfFalseGo( (0 == ::memcmp(&pwszDisplayString[CCH_RESURL], pwszMMCExePath,
                              cchMMCExePath * sizeof(WCHAR))), S_OK);

    // Check if MMC path is followed by "/default.htm" or "/reload.htm" meaning
    // it is a default taskpad

    pwszTaskpadName = &pwszDisplayString[CCH_RESURL + cchMMCExePath];
    cchRemaining = ::wcslen(pwszTaskpadName);

    if (cchRemaining >= CCH_DEFAULT_TASKPAD)
    {
        if ( 0 == ::memcmp(pwszTaskpadName, DEFAULT_TASKPAD,
                           CCH_DEFAULT_TASKPAD * sizeof(WCHAR)))
        {
            *pType = siTaskpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if  (cchRemaining >= CCH_DEFAULT_TASKPAD2)
    {
        if ( 0 == ::memcmp(pwszTaskpadName, DEFAULT_TASKPAD2,
                           CCH_DEFAULT_TASKPAD2 * sizeof(WCHAR)))
        {
            *pType = siTaskpad;
            *pfUsingWrongNames = TRUE;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    // It isn't a taskpad so:
    // Check if MMC path is followed by "/listpad.htm" or "/reload2.htm" or "/reload3.htm"
    // meaning it is a listpad

    if (cchRemaining >= CCH_LISTPAD)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD,
                           CCH_LISTPAD * sizeof(WCHAR)))
        {
            *pType = siListpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD2)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD2,
                           CCH_LISTPAD2 * sizeof(WCHAR)))
        {
            *pType = siListpad;
            *pfUsingWrongNames = TRUE;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD_HORIZ)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD_HORIZ,
                           CCH_LISTPAD_HORIZ * sizeof(WCHAR)))
        {
            *pType = siListpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD3)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD3,
                           CCH_LISTPAD3 * sizeof(WCHAR)))
        {
            *pType = siListpad;
            *pfUsingWrongNames = TRUE;
            *pfUsingListpad3 = TRUE;
        }
    }

Error:
    RRETURN(hr);
}




HRESULT CView::PopulateListView(CResultView *pResultView)
{
    HRESULT                hr = S_OK;
    CMMCListView          *pMMCListView = pResultView->GetListView();
    long                   MMCViewMode = MMCLV_VIEWSTYLE_ICON;
    MMC_RESULT_VIEW_STYLE  StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
    MMC_RESULT_VIEW_STYLE  StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    DWORD                  dwSortOptions = 0;

    // Set flag so that column change events are not fired if we set a filter
    
    m_fPopulatingListView = TRUE;
    
    // Set up the column headers from ResultView.ListView.ColumnHeaders. If this
    // is not a virtual list view. For virtuals it was done prior to the
    // ResultViews_Activate event.

    // For non-virtuals, also add all the listitems currently in
    // ResultView.ListView.ListItems

    if (!pMMCListView->IsVirtual())
    {
        IfFailGo(SetColumnHeaders(pMMCListView));
        IfFailGo(InsertListItems(pMMCListView));
    }

    // Set the view mode. This must be done after setting up the column headers
    // because if using report view there must be column headers.
    // CONSIDER: log an error if there are no headers and in report view

    VBViewModeToMMCViewMode(pMMCListView->GetView(), &MMCViewMode);

    // If MMC < 1.2 and view mode is filtered then switch it to report

    if ( (NULL == m_piColumnData) && (MMCLV_VIEWSTYLE_FILTERED == MMCViewMode) )
    {
        MMCViewMode = MMCLV_VIEWSTYLE_REPORT;
    }

    hr = m_piResultData->SetViewMode(MMCViewMode);
    EXCEPTION_CHECK_GO(hr);

    // Get other view style attributes and set view styles in MMC

    if (pMMCListView->MultiSelect())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_SINGLESEL;
    }
    else
    {
        StyleToAdd = MMC_SINGLESEL;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    if (pMMCListView->HideSelection())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_SHOWSELALWAYS;
    }
    else
    {
        StyleToAdd = MMC_SHOWSELALWAYS;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    if (pMMCListView->SortHeader())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_NOSORTHEADER;
    }
    else
    {
        StyleToAdd = MMC_NOSORTHEADER;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    // If listview is marked as sorted then ask MMC to sort it. Use the internal
    // routine rather than a real GET as that would call into IColumnData.

    if (pMMCListView->Sorted())
    {
        // Set the Sorted property (even though it is already set) as that
        // will call IResultData::Sort() and update it in IColumnData.
        IfFailGo(pMMCListView->put_Sorted(VARIANT_TRUE));
    }

    // If this is a filtered listview then set filter change timeout

    if (siFiltered == pMMCListView->GetView())
    {
        hr = pMMCListView->put_FilterChangeTimeOut(pMMCListView->GetFilterChangeTimeout());
        if (SID_E_MMC_FEATURE_NOT_AVAILABLE == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

Error:
    m_fPopulatingListView = FALSE;
    RRETURN(hr);
}


HRESULT CView::SetColumnHeaders(IMMCListView *piMMCListView)
{
    HRESULT            hr = S_OK;
    IMMCColumnHeaders *piMMCColumnHeaders = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    CMMCColumnHeader  *pMMCColumnHeader = NULL;
    short              sWidth = 0;
    int                nFormat = 0;
    long               cHeaders = 0;
    long               i = 0;

    // Reset MMC's header control

    IfFailGo(m_piConsole2->SetHeader(m_piHeaderCtrl2));

    // Set up the headers

    IfFailGo(piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piMMCColumnHeaders)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeaders,
                                                   &pMMCColumnHeaders));
    cHeaders = pMMCColumnHeaders->GetCount();
    IfFalseGo(cHeaders > 0, S_OK);

    for (i = 0; i < cHeaders; i++)
    {
        // Don't do a real GET on any of the properties as they will use
        // IHeaderCtrl2 and IColumnData at runtime. Using these backdoor functions
        // also improves perf.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                            pMMCColumnHeaders->GetItemByIndex(i),
                                            &pMMCColumnHeader));

        switch (pMMCColumnHeader->GetAlignment())
        {
            case siColumnLeft:
                nFormat = LVCFMT_LEFT;
                break;

            case siColumnRight:
                nFormat = LVCFMT_RIGHT;
                break;

            case siColumnCenter:
                nFormat = LVCFMT_CENTER;
                break;

            default:
                nFormat = LVCFMT_LEFT;
                break;
        }

        sWidth = pMMCColumnHeader->GetWidth();
        if (siColumnAutoWidth == sWidth)
        {
            sWidth = MMCLV_AUTO;
        }

        // If the column is hidden then check that we are on MMC >= 1.2.
        // If not then ignore the hidden setting.
        if ( (pMMCColumnHeader->Hidden()) && (NULL != m_piColumnData) )
        {
            sWidth = static_cast<short>(HIDE_COLUMN);
        }

        hr = m_piHeaderCtrl2->InsertColumn(static_cast<int>(i),
                                           (LPCWSTR)pMMCColumnHeader->GetText(),
                                           nFormat,
                                           static_cast<int>(sWidth));
        EXCEPTION_CHECK_GO(hr);

        // If the column has a filter then set it. If this is MMC < 1.2 then
        // ignore filter properties.

        hr = pMMCColumnHeader->SetFilter();
        if (SID_E_MMC_FEATURE_NOT_AVAILABLE == hr) // MMC < 1.2
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piMMCColumnHeaders);
    RRETURN(hr);
}





HRESULT CView::InsertListItems(IMMCListView *piMMCListView)
{
    HRESULT           hr = S_OK;
    IMMCListItems    *piMMCListItems = NULL;
    CMMCListItems    *pMMCListItems = NULL;
    CMMCListItem     *pMMCListItem = NULL;
    long              cListItems = 0;
    long              i = 0;

    IfFailGo(piMMCListView->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItems, &pMMCListItems));
    cListItems = pMMCListItems->GetCount();

    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                               pMMCListItems->GetItemByIndex(i), &pMMCListItem));
        IfFailGo(InsertListItem(pMMCListItem));
    }

Error:
    QUICK_RELEASE(piMMCListItems);
    RRETURN(hr);
}


HRESULT CView::InsertListItem(CMMCListItem *pMMCListItem)
{
    HRESULT        hr = S_OK;
    CMMCListItems *pMMCListItems = pMMCListItem->GetListItems();
    CMMCListView  *pMMCListView = NULL;
    CResultView   *pResultView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Check whether the owning ResultView is in its Initialize event. If
    // so then don't add to MMC just yet. The listitems will be added to MMC
    // during MMCN_SHOW.

    IfFalseGo(NULL != pMMCListItems, S_OK);
    pMMCListView = pMMCListItems->GetListView();
    IfFalseGo(NULL != pMMCListView, S_OK);
    pResultView = pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, S_OK);
    IfFalseGo(!pResultView->InInitialize(), S_OK);

    rdi.mask = RDI_STR | RDI_PARAM | RDI_INDEX;
    rdi.str = MMC_CALLBACK;
    rdi.lParam = reinterpret_cast<LPARAM>(pMMCListItem);
    rdi.nIndex = static_cast<int>(pMMCListItem->GetIndex() - 1L);

    hr = m_piResultData->InsertItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    pMMCListItem->SetHRESULTITEM(rdi.itemID);

    // Add a reference while the listitem is in the MMC listview.
    
    pMMCListItem->AddRef();

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CView::CleanOutConsoleListView
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called when the result pane is being destroyed. If the
// result pane contains a listview and it is not virtual then we have a bunch
// of AddRef()ed IMMCListItem pointers sitting in IResultData. We need to
// iterate through these and release them.
//
HRESULT CView::CleanOutConsoleListView
(
    HeaderOptions   HeaderOption,
    ListItemOptions ListItemOption
)
{
    HRESULT        hr = S_OK;
    CMMCListItem  *pMMCListItem = NULL; 

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    if (RemoveHeaders == HeaderOption)
    {
        if (NULL != m_piConsole2)
        {
            (void)m_piConsole2->SetHeader(NULL);
        }
    }

    // If there is a cached list item from a virtual result view then
    // get rid of it.
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
        m_pCachedMMCListItem = NULL;
    }

    IfFalseGo(NULL != m_piResultData, S_OK);
    IfFalseGo(!m_fVirtualListView, S_OK);

    // Even though we don't need RDI_STATE MMC requires it on GetNextItem.
    
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    hr = m_piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while (-1 != rdi.nIndex)
    {
        if (!rdi.bScopeItem)
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(rdi.lParam);

            // Release the ref we held on the list item for its presence in MMC

            pMMCListItem->Release();
        }

        hr = m_piResultData->GetNextItem(&rdi);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CView::OnSelect
(
    IDataObject *piDataObject,
    BOOL         fScopeItem,
    BOOL         fSelected
)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));
    // Fire Views_Select

    m_pSnapIn->GetViews()->FireSelect(
                           static_cast<IView *>(this),
                           piMMCClipboard,
                           BOOL_TO_VARIANTBOOL(fSelected),
                           static_cast<IMMCConsoleVerbs *>(m_pMMCConsoleVerbs));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}





HRESULT CView::GetImage(CMMCListItem *pMMCListItem, int *pnImage)
{
    HRESULT       hr = S_OK;
    IMMCListView *piMMCListView = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(pMMCListItem->get_Icon(&varIndex));
    IfFalseGo(VT_EMPTY != varIndex.vt, S_OK);

    // The user specified an index in ListItem.Icon. Attempt to fetch that
    // image from the listview's image list and get its numerical index

    IfFailGo(m_pScopePaneItems->GetSelectedItem()->
             GetResultView()->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListView)));

    IfFailGo(::GetImageIndex(piMMCListView, varIndex, pnImage));

Error:
    QUICK_RELEASE(piMMCListView);
    RRETURN(hr);
}





HRESULT CView::OnAddImages
(
    IDataObject *piDataObject,
    IImageList  *piImageList,
    HSCOPEITEM   hsi
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    IMMCListView   *piMMCListView = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    IMMCImageList  *piMMCImageListSmall = NULL;
    IMMCImages     *piMMCImages = NULL;
    IMMCImages     *piMMCImagesSmall = NULL;
    long            lCount = 0;
    long            lCountSmall = 0;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hBitmapSmall = NULL;
    OLE_COLOR       OleColorMask = 0;
    COLORREF        ColorRef = RGB(0x00,0x00,0x00);
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection. It will always be a single item: a scope item owned
    // by the snap-in or a foreign scope item if this is a namespace extension.

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if ( (siSingleScopeItem != SelectionType) &&
         (siSingleForeign != SelectionType) )
    {
        ASSERT(FALSE, "MMCN_ADDIMAGES receive data object that is not for a single scope item or a foreign data object");
        hr = SID_E_INTERNAL;
    }
    IfFailGo(hr);

    // Get large and small image lists. Make sure they are both present.
    // For an owned scope item these come from ResultView.ListView.LargeIcons
    // and ResultView.ListView.Icons. For a foreign scope item they come from
    // SnapIn.LargeFolders and SnapIn.SmallFolders.

    if (siSingleScopeItem == SelectionType)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

        IfFailGo(pResultView->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListView)));

        IfFailGo(piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        IfFalseGo(NULL != piMMCImageList, S_OK);

        IfFailGo(piMMCListView->get_SmallIcons(reinterpret_cast<MMCImageList **>(&piMMCImageListSmall)));
        IfFalseGo(NULL != piMMCImageListSmall, S_OK);
    }
    else // namespace extension's node appearing in its parent's listview
    {
        IfFalseGo(NULL != m_pSnapIn, SID_E_INTERNAL);

        IfFailGo(m_pSnapIn->get_LargeFolders(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        IfFalseGo(NULL != piMMCImageList, S_OK);

        IfFailGo(m_pSnapIn->get_SmallFolders(reinterpret_cast<MMCImageList **>(&piMMCImageListSmall)));
        IfFalseGo(NULL != piMMCImageListSmall, S_OK);
    }

    IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImageListSmall->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImagesSmall)));

    // Make sure they both have the same number of images

    IfFailGo(piMMCImages->get_Count(&lCount));
    IfFalseGo(0 != lCount, S_OK);

    IfFailGo(piMMCImagesSmall->get_Count(&lCountSmall));
    // UNDONE: log an error here if counts not equal
    IfFalseGo(lCountSmall == lCount, S_OK);

    // Get the mask color as a COLORREF

    IfFailGo(piMMCImageList->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));

    // Now get each pair of small and large images and add them to the result
    // view's image list

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= lCount; varIndex.lVal++)
    {
        IfFailGo(GetPicture(piMMCImages, varIndex, PICTYPE_BITMAP,
                            reinterpret_cast<OLE_HANDLE *>(&hBitmap)));

        IfFailGo(GetPicture(piMMCImagesSmall, varIndex, PICTYPE_BITMAP,
                            reinterpret_cast<OLE_HANDLE *>(&hBitmapSmall)));

        IfFailGo(piImageList->ImageListSetStrip(reinterpret_cast<long*>(hBitmapSmall),
                                                reinterpret_cast<long*>(hBitmap),
                                                varIndex.lVal,
                                                ColorRef));
    }

Error:
    QUICK_RELEASE(piMMCListView);
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImageListSmall);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImagesSmall);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnButtonClick(IDataObject *piDataObject, MMC_CONSOLE_VERB verb)
{
    HRESULT hr = S_OK;

    switch (verb)
    {
        case MMC_VERB_OPEN:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_OPEN");
            break;
            
        case MMC_VERB_COPY:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_COPY");
            break;
            
        case MMC_VERB_PASTE:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_PASTE");
            break;

        case MMC_VERB_DELETE:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_DELETE");
            break;

        case MMC_VERB_PROPERTIES:
            hr = OnPropertiesVerb(piDataObject);
            break;

        case MMC_VERB_RENAME:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_RENAME");
            break;
            
        case MMC_VERB_REFRESH:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_REFRESH");
            break;

        case MMC_VERB_PRINT:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_PRINT");
            break;

        case MMC_VERB_CUT:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_CUT");
            break;

        default:
            break;
    }
    RRETURN(hr);
}



HRESULT CView::OnColumnClick(long lColumn, long lSortOptions)
{
    HRESULT hr = S_OK;

    SnapInSortOrderConstants  siSortOption = siAscending;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (RSI_DESCENDING == lSortOptions)
    {
        siSortOption = siDescending;
    }

    // Fire the event and adjut the column number to one based
    
    m_pSnapIn->GetResultViews()->FireColumnClick(
                                         static_cast<IResultView *>(pResultView),
                                         lColumn + 1L,
                                         siSortOption);
Error:
    RRETURN(hr);
}




HRESULT CView::OnDoubleClick(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BOOL            fDoDefault = TRUE;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it and tell MMC to do default
    // action. (Should never happen).

    ASSERT(SUCCEEDED(hr), "CView::OnDoubleClick received foreign data object");

    IfFalseGo(SUCCEEDED(hr), S_FALSE);

    // There may or may not be a selected item and an existing result view.
    // In a primary snap-in there will not be a result view when double clicking
    // the static node in the result pane when the console root is selected.

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }

    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        m_pSnapIn->GetResultViews()->FireListItemDblClick(pResultView,
                                                          pMMCDataObject->GetListItem(),
                                                          &fDoDefault);
    }
    else if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        m_pSnapIn->GetResultViews()->FireScopeItemDblClick(pResultView,
                                                           pMMCDataObject->GetScopeItem(),
                                                           &fDoDefault);
    }

    if (fDoDefault)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Error:
    RRETURN(hr);
}


void CView::OnActivate(BOOL fActivated)
{
    if (fActivated)
    {
        m_pSnapIn->GetViews()->FireActivate(static_cast<IView *>(this));
        m_pSnapIn->SetCurrentView(this);
        m_pSnapIn->GetViews()->SetCurrentView(this);
        m_pSnapIn->SetCurrentControlbar(m_pControlbar);
    }
    else
    {
        m_pSnapIn->GetViews()->FireDeactivate(static_cast<IView *>(this));
    }
}



void CView::OnMinimized(BOOL fMinimized)
{
    if (fMinimized)
    {
        m_pSnapIn->GetViews()->FireMinimize(static_cast<IView *>(this));
    }
    else
    {
        m_pSnapIn->GetViews()->FireMaximize(static_cast<IView *>(this));
    }
}



HRESULT CView::EnumExtensionTasks
(
    IMMCClipboard *piMMCClipboard,
    LPOLESTR       pwszTaskGroup,
    CEnumTask     *pEnumTask
)
{
    HRESULT          hr = S_OK;
    BSTR             bstrGroupName = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    IUnknown        *punkTasks = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // This might be the first time we find out that the snap-in is running as
    // an extension so set the runtime mode.

    m_pSnapIn->SetRuntimeMode(siRTExtension);

    // If we haven't yet created the Tasks collection then create it now.
    // Otherwise just clear it out.

    if (NULL == m_piTasks)
    {
        punkTasks = CTasks::Create(NULL);
        if (NULL == punkTasks)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkTasks->QueryInterface(IID_ITasks,
                                           reinterpret_cast<void **>(&m_piTasks)));
    }
    else
    {
        IfFailGo(m_piTasks->Clear());
    }

    // If there is a group name then convert to a BSTR to pass to the snap-in

    if (NULL != pwszTaskGroup)
    {
        bstrGroupName = ::SysAllocString(pwszTaskGroup);
        if (NULL == bstrGroupName)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Get the 1st data object from the selection

    IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    // Fire ExtensionSnapIn_AddTasks so the snap-in can add its tasks

    m_pSnapIn->GetExtensionSnapIn()->FireAddTasks(piMMCDataObject,
                                                  bstrGroupName, m_piTasks);

    // Give the enumerator its tasks collection

    pEnumTask->SetTasks(m_piTasks);

Error:
    FREESTRING(bstrGroupName);
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(punkTasks);
    RRETURN(hr);
}



HRESULT CView::EnumPrimaryTasks(CEnumTask *pEnumTask)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    ITasks         *piTasks = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (NULL == pResultView) // should always be valid, but double check
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Taskpads do not receive MMCN_SHOW so fire ResultViews_Activate here
    // to allow the snap-in to make any needed changes to ResultViews.Taskpad.
    // Note that the result view type could be siTaskpad or siListpad as listpads
    // are also allowed to display task buttons. We only fire the event for
    // siTaskpad as listpads will get it during MMCN_LISTPAD
    // (see CView::OnListpad()).

    if (siTaskpad == pResultView->GetActualType())
    {
        IfFailGo(ActivateResultView(pSelectedItem, pResultView));
    }

    // Give the enumerator its tasks collection

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks)));

    pEnumTask->SetTasks(piTasks);

Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piTasks);
    RRETURN(hr);
}




HRESULT CView::OnExtensionTaskNotify
(
    IMMCClipboard *piMMCClipboard,
    VARIANT       *arg,
    VARIANT       *param
)
{
    HRESULT          hr = S_OK;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    ITask           *piTask = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // If a task was clicked then arg is a VT_I4 containing the one-based
    // index of the Task object in m_piTasks. Fire ExtensionSnapIn_TaskClick.

    if (VT_I4 != arg->vt)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    IfFailGo(m_piTasks->get_Item(*arg, reinterpret_cast<Task **>(&piTask)));
    m_pSnapIn->GetExtensionSnapIn()->FireTaskClick(piMMCDataObject, piTask);

Error:
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CView::OnPrimaryTaskNotify
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT *arg    [in] Passed from taskpad calling MMCCtrl.TaskNotify.
//                       For MMC taskpad templates this will be the task or
//                       listpad button ID. For custom taskpads this will be
//                       a value defined by the taskpad developer.
//
//  VARIANT *param  [in] passed from taskpad calling MMCCtrl.TaskNotify
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called in a primary snap-in when a user clicks either a task
// or a listpad button in an MMC-defined taskpad as well is when a custom taskpad
// calls MMCCtrl.TaskNotify.
//
// There is no foolproof method of determining the source of the notification.
// One opportunity for confusion is the case where a task on a default taskpad
// has a URL action that navigates to a custom taskpad. When the user hits the
// task MMC tells the web browser control to navigate to the URL without
// informing the snap-in. If the custom taskpad calls MMCCtrl.TaskNotify then
// this method will be called because the same scope node is still selected.
// Unfortunately, the runtime still thinks that the default taskpad is the active
// result view because MMC hasn't told us otherwise. 
//
// The bottom line is that the runtime needs to distinguish arg parameter values
// between task/listpad button IDs and user defined values sent from a custom
// taskpad. The only way is to reserve a set of values and our documentation
// states that users should not call MMCCtrl.TaskNotify with an arg param between
// 0 and the number of tasks defined for a taskpad used by the same scope node.
// The runtime identifies a listpad button with an ID of zero and tasks with IDs
// corresponding to their Tasks collection index (1 to n).
//
// Users can work around this by using other numbers or non-integer data types.
//

HRESULT CView::OnPrimaryTaskNotify
(
    VARIANT       *arg,
    VARIANT       *param
)
{
    HRESULT                     hr = S_OK;
    CScopePaneItem             *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView                *pResultView = NULL;
    ITaskpad                   *piTaskpad = NULL;
    ITasks                     *piTasks = NULL;
    ITask                      *piTask = NULL;
    long                        cTasks = 0;             
    SnapInTaskpadTypeConstants  TaskpadType = Default;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get the taskpad and determine its type.

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Type(&TaskpadType));

    // If it is a custom taskpad then just fire ResultViews_Notify. If we
    // displayed the custom taskpad through normal procedures then that will be
    // the current result view type. If not, (given the scenario described in
    // the header notes above), and arg is not a VT_I4, then it must be from a
    // a custom taskpad.

    if ( (Custom == TaskpadType) || (VT_I4 != arg->vt) )
    {
        m_pSnapIn->GetResultViews()->FireTaskNotify(
                          static_cast<IResultView *>(pResultView), *arg, *param);
        goto Cleanup;
    }

    // Now we can't be sure of the taskpad type so we need to interpret the
    // arg parameter.

    // It is potentially a default taskpad task/listpad button click.
    // Check if the value is between zero and Taskpad.Tasks.Count

    IfFailGo(piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks)));
    IfFailGo(piTasks->get_Count(&cTasks));

    if (0 == arg->lVal)
    {
        // Assume it is a listpad button click and fire
        // ResultViews_ListpadButtonClick

        m_pSnapIn->GetResultViews()->FireListpadButtonClick(
                                        static_cast<IResultView *>(pResultView));
    }
    else if ( (arg->lVal >= 1L) && (arg->lVal <= cTasks) )
    {
        // Assume it is a task and fire ResultViews_TaskClick using the value
        // as the index of the Task clicked in ResultView.Taskpad.Tasks
        
        IfFailGo(piTasks->get_Item(*arg, reinterpret_cast<Task **>(&piTask)));
        m_pSnapIn->GetResultViews()->FireTaskClick(
                                static_cast<IResultView *>(pResultView), piTask);
    }
    else
    {
        // Assume it is from a custom taskpad and fire ResultViews_TaskNotify

        m_pSnapIn->GetResultViews()->FireTaskNotify(
                          static_cast<IResultView *>(pResultView), *arg, *param);
    }

Cleanup:
Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piTasks);
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}


HRESULT CView::OnPrint(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_Print

    m_pSnapIn->GetViews()->FirePrint(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnRefresh(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_Refresh
    
    m_pSnapIn->GetViews()->FireRefresh(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BSTR            bstrNewName = NULL;
    IMMCListItem   *piMMCListItem = NULL; // NotAddRef()ed
    CScopeItem     *pScopeItem = NULL;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it
    IfFalseGo(SUCCEEDED(hr), S_OK);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }

    bstrNewName = ::SysAllocString(pwszNewName);
    if (NULL == bstrNewName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        piMMCListItem = static_cast<IMMCListItem *>(pMMCDataObject->GetListItem());
        m_pSnapIn->GetResultViews()->FireItemRename(pResultView, piMMCListItem,
                                                    bstrNewName);
    }
    else if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        m_pSnapIn->GetScopeItems()->FireRename(
                                           static_cast<IScopeItem *>(pScopeItem),
                                           bstrNewName);
    }

Error:
    FREESTRING(bstrNewName);
    RRETURN(hr);
}


HRESULT CView::OnViewChange(IDataObject *piDataObject, long idxListItem)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    CMMCListItem   *pMMCListItem = NULL;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it (should never happen)
    IfFalseGo(SUCCEEDED(hr), S_OK);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }


    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        pMMCListItem = pMMCDataObject->GetListItem();
        m_pSnapIn->GetResultViews()->FireItemViewChange(pResultView,
                                       static_cast<IMMCListItem *>(pMMCListItem),
                                       pMMCListItem->GetHint());
    }

Error:
    RRETURN(hr);
}




HRESULT CView::OnQueryPaste
(
    IDataObject *piDataObjectTarget,
    IDataObject *piDataObjectSource
)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObject  = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarOKToPaste = VARIANT_FALSE;
    BOOL            fNotFromThisSnapIn = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create an MMCClipboard object holding the source items

    IfFailGo(CreateSelection(piDataObjectSource, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // The target should be one of our data objects representing a single scope
    // item. If not then ignore it.
    
    ::IdentifyDataObject(piDataObjectTarget, m_pSnapIn,
                         &pMMCDataObject, &fNotFromThisSnapIn);

    IfFalseGo(!fNotFromThisSnapIn, S_FALSE);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(),
              S_FALSE);

    // Fire Views_Select

    m_pSnapIn->GetViews()->FireQueryPaste(
                       static_cast<IView *>(this),
                       piMMCClipboard,
                       static_cast<IScopeItem *>(pMMCDataObject->GetScopeItem()),
                       &fvarOKToPaste);

    if (VARIANT_TRUE == fvarOKToPaste)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnPaste
(
    IDataObject  *piDataObjectTarget,
    IDataObject  *piDataObjectSource,
    IDataObject **ppiDataObjectRetToSource
)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObjectTarget  = NULL;
    CMMCDataObject *pMMCDataObjectRetToSource  = NULL;
    IUnknown       *punkDataObjectRetToSource = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarMove = VARIANT_FALSE;
    BOOL            fNotFromThisSnapIn = FALSE;

    SnapInSelectionTypeConstants SourceType = siEmpty;

    // Create an MMCClipboard object holding the source items

    IfFailGo(::CreateSelection(piDataObjectSource, &piMMCClipboard, m_pSnapIn,
                               &SourceType));

    // The target should be one of our data objects representing a single scope
    // item. If not then ignore it.

    ::IdentifyDataObject(piDataObjectTarget, m_pSnapIn,
                         &pMMCDataObjectTarget, &fNotFromThisSnapIn);

    IfFalseGo(!fNotFromThisSnapIn, SID_E_INTERNAL);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObjectTarget->GetType(),
              SID_E_INTERNAL);

    // If this is a move then MMC requested a returned data object.

    if (NULL != ppiDataObjectRetToSource)
    {
        fvarMove = VARIANT_TRUE;

        // If the source is not from this snap-in then create an MMCDataObject
        // in which the snap-in may return information on the items successfully
        // pasted. The format is determined by the source snap-in.

        if (IsForeign(SourceType))
        {
            punkDataObjectRetToSource = CMMCDataObject::Create(NULL);
            if (NULL == punkDataObjectRetToSource)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObjectRetToSource,
                                                           &pMMCDataObjectRetToSource));
            pMMCDataObjectRetToSource->SetSnapIn(m_pSnapIn);
            pMMCDataObjectRetToSource->SetType(CMMCDataObject::CutOrMove);
        }
    }

    // Fire Views_Paste

    m_pSnapIn->GetViews()->FirePaste(
                 static_cast<IView *>(this),
                 piMMCClipboard,
                 static_cast<IScopeItem *>(pMMCDataObjectTarget->GetScopeItem()),
                 static_cast<IMMCDataObject *>(pMMCDataObjectRetToSource),
                 fvarMove);

    if (VARIANT_TRUE == fvarMove)
    {
        // If the source is not from this snap-in then return the MMCDataObject
        // used by the snap-in to return its info on items successfully pasted.

        if (IsForeign(SourceType))
        {
            IfFailGo(pMMCDataObjectRetToSource->QueryInterface(IID_IDataObject,
                           reinterpret_cast<void **>(ppiDataObjectRetToSource)));
        }
        else
        {
            // The source is in the same snap-in. Return the source data object
            // as the CutOrMove data object. The snap-in should have set
            // ScopeItem.Pasted and MMCListItem.Pasted in the MMCClipboard's
            // collections.  These collections simply AddRef()ed the items
            // contained in the source data object's collections.
            // See CView::OnCutOrMove() below for how this is interpreted.

            piDataObjectSource->AddRef();
            *ppiDataObjectRetToSource = piDataObjectSource;
        }
    }


Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(punkDataObjectRetToSource);
    RRETURN(hr);
}




HRESULT CView::OnCutOrMove(IDataObject *piDataObjectFromTarget)
{
    HRESULT         hr = S_FALSE;
    IMMCClipboard  *piMMCClipboard = NULL;
    CMMCDataObject *pMMCDataObjectFromTarget  = NULL;
    IUnknown       *punkDataObjectFromTarget = NULL;
    BOOL            fNotFromThisSnapIn = FALSE;
    BOOL            fReleaseTargetDataObj = FALSE;

    SnapInSelectionTypeConstants TargetType = siEmpty;

    // If the source items come from this snap-in then create an MMCClipboard
    // object holding them

    ::IdentifyDataObject(piDataObjectFromTarget, m_pSnapIn,
                         &pMMCDataObjectFromTarget, &fNotFromThisSnapIn);

    if (fNotFromThisSnapIn)
    {
        // The source items do not come from this snap-in. Create an
        // MMCDataObject to wrap the data object from the target.

        punkDataObjectFromTarget = CMMCDataObject::Create(NULL);
        if (NULL == punkDataObjectFromTarget)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObjectFromTarget,
                                                     &pMMCDataObjectFromTarget));
        pMMCDataObjectFromTarget->SetSnapIn(m_pSnapIn);
        pMMCDataObjectFromTarget->SetType(CMMCDataObject::Foreign);
        pMMCDataObjectFromTarget->SetForeignData(piDataObjectFromTarget);
    }
    else
    {
        // The data object is from this snap-in. We can use its ScopeItems and
        // ListItems collections directly in an MMCClipboard.

        IfFailGo(::CreateSelection(piDataObjectFromTarget, &piMMCClipboard,
                                   m_pSnapIn, &TargetType));

        // See comment at end of function for why we set this flag here.
        
        if (IsSingle(TargetType))
        {
            fReleaseTargetDataObj = TRUE;
        }

        pMMCDataObjectFromTarget = NULL; // don't want to pass this to snap-in
                                         // because MMCClipboard has the info
    }

    // Fire Views_Cut

    m_pSnapIn->GetViews()->FireCut(
                       static_cast<IView *>(this),
                       piMMCClipboard,
                       static_cast<IMMCDataObject *>(pMMCDataObjectFromTarget));

Error:

    // There is a bug in MMC 1.1 and MMC 1.2 in nodemgr\scopndcb in
    // CNodeCallback::_Paste. It sends MMCN_PASTE, receives the data object
    // from the target IComponent, passes it to the source in MMCN_CUTORMOVE
    // and then it doesn't release it. If MMC is ever fixed this next line
    // of code must be removed. This is NTBUGS 408535 for MMC and
    // NTBUGS 408537 for the designer. Note that the bug only happens in the
    // single selection case. With multiple selection MMC correctly releases
    // the data object.

    if (fReleaseTargetDataObj)
    {
        piDataObjectFromTarget->Release();
    }
    
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(punkDataObjectFromTarget);
    RRETURN(hr);
}



void CView::OnDeselectAll()
{
    HRESULT hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);


    m_pSnapIn->GetResultViews()->FireDeselectAll(
                             static_cast<IResultView *>(pResultView),
                             static_cast<IMMCConsoleVerbs *>(m_pMMCConsoleVerbs),
                             static_cast<IMMCControlbar *>(m_pControlbar));

Error:
    // need empty statement here to avoid compiler error saying "missing ';'
    // before '}'

    ;
}

HRESULT CView::OnContextHelp(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CMMCDataObject *pMMCDataObject  = NULL;
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if (siSingleScopeItem == SelectionType)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
        IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

        m_pSnapIn->GetScopeItems()->FireHelp(pMMCDataObject->GetScopeItem());
    }
    else if (siSingleListItem == SelectionType)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
        IfFalseGo(CMMCDataObject::ListItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

        m_pSnapIn->GetResultViews()->FireHelp(pResultView,
                                              pMMCDataObject->GetListItem());
    }
    else
    {
        ASSERT(FALSE, "Bad selection type in MMCN_CONTEXTHELP");
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnDelete(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    m_pSnapIn->GetViews()->FireDelete(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnColumnsChanged
(
    IDataObject         *piDataObject,
    MMC_VISIBLE_COLUMNS *pVisibleColumns
)
{
    HRESULT         hr = S_OK;
    SAFEARRAY      *psaColumns = NULL;
    long HUGEP     *plCol = NULL;
    INT             i = 0;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarPersist = VARIANT_TRUE;

    VARIANT varColumns;
    ::VariantInit(&varColumns);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Create the SAFEARRAY of VT_I4 containing the column numbers

    psaColumns = ::SafeArrayCreateVector(VT_I4, 1,
                   static_cast<unsigned long>(pVisibleColumns->nVisibleColumns));
    if (NULL == psaColumns)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::SafeArrayAccessData(psaColumns,
                               reinterpret_cast<void HUGEP **>(&plCol));
    EXCEPTION_CHECK_GO(hr);

    // Copy in the column numbers. Adjust for one-based.

    for (i = 0; i < pVisibleColumns->nVisibleColumns; i++)
    {
        plCol[i] = pVisibleColumns->rgVisibleCols[i] + 1;
    }

    hr = ::SafeArrayUnaccessData(psaColumns);
    EXCEPTION_CHECK_GO(hr);

    plCol = NULL;

    varColumns.vt = VT_I4 | VT_ARRAY;
    varColumns.parray = psaColumns;

    m_pSnapIn->GetResultViews()->FireColumnsChanged(pResultView,
                                                    varColumns,
                                                    &fvarPersist);
    if (VARIANT_TRUE == fvarPersist)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

Error:
    if (NULL != plCol)
    {
        (void)::SafeArrayUnaccessData(psaColumns);
    }
    if (NULL != psaColumns)
    {
        (void)::SafeArrayDestroy(psaColumns);
    }
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::GetCurrentListViewSelection
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IMMCClipboard **ppiMMCClipboard [out] Selection returned here if non-NULL
//   CMMDataObject **ppMMCDataObject [out] DataObject returned here if non-NULL
//                                         Caller must call Release on DataObject
//
// Output:
//
// Notes:
//
// Iterates through the result pane using IResultData::GetNextItem and creates
// a multi-select data object containing the selection. If ppiMMCClipboard is
// non-NULL then creates an MMCCLipboard containing the selection as well. Both
// objects are returned to the caller only if their corresponding out-pointer
// params are non-NULL.
//

HRESULT CView::GetCurrentListViewSelection
(
    IMMCClipboard  **ppiMMCClipboard,
    CMMCDataObject **ppMMCDataObject
)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkDataObject = CMMCDataObject::Create(NULL);
    CMMCDataObject *pMMCDataObject = NULL;
    IUnknown       *punkScopeItems = CScopeItems::Create(NULL);
    CScopeItems    *pScopeItems = NULL;
    CScopeItem     *pScopeItem = NULL;
    IUnknown       *punkListItems = CMMCListItems::Create(NULL);
    CMMCListItems  *pMMCListItems = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    long            lIndex = 0;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;
    BOOL            fVirtual = FALSE;

    SnapInSelectionTypeConstants  SelectionType = siEmpty;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);
    fVirtual = pMMCListView->IsVirtual();

    ASSERT(fVirtual == m_fVirtualListView, "m_fVirtualListView does not agree with the current ListView.Virtual");

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    if (NULL != ppMMCDataObject)
    {
        *ppMMCDataObject = NULL;
    }

    if (NULL != ppiMMCClipboard)
    {
        *ppiMMCClipboard = NULL;
    }

    // Check that we created an MMCDataObject and the scope and list item
    // collections

    if ( (NULL == punkDataObject) || (NULL == punkScopeItems) ||
         (NULL == punkListItems) )
         
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                   &pMMCDataObject));
    pMMCDataObject->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeItems,
                                                   &pScopeItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkListItems,
                                                   &pMMCListItems));

    // Iterate through the items in the listview and build the scope item and
    // list item collections. When adding an item owned by another collection,
    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this item still belongs to its original owning collection (either
    // SnapIn.ScopeItems or ResultView.ListView.ListItems)
    
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    rdi.nState = LVIS_SELECTED; // Request only items that are selected
    hr = m_piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while (-1 != rdi.nIndex)
    {
        // As we requested only selected items this check isn't really necessary
        // but we double check anyway.

        if ( (rdi.nState & LVIS_SELECTED) != 0 )
        {
            if (rdi.bScopeItem)
            {
                pScopeItem = reinterpret_cast<CScopeItem *>(rdi.lParam);
                if (NULL == pScopeItem)
                {
                    // Static node has zero cookie. Technically this should
                    // never happen as the static node cannot appear in
                    // a list view owned by its own snap-in but we put this
                    // here just in case.
                    pScopeItem = m_pSnapIn->GetStaticNodeScopeItem();
                }
                lIndex = pScopeItem->GetIndex();
                varKey.bstrVal = pScopeItem->GetKey();
                if (NULL != varKey.bstrVal)
                {
                    varKey.vt = VT_BSTR;
                }
                else
                {
                    UNSPECIFIED_PARAM(varKey);
                }
                IfFailGo(pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                        static_cast<IScopeItem *>(pScopeItem)));
                pScopeItem->SetIndex(lIndex);
            }
            else
            {
                // If this is a virtual list then we need to create a virtual
                // list item and fire ResultViews_GetVirtualItemData.
                // rdi.nIndex contains the zero based index.
                
                if (fVirtual)
                {
                    IfFailGo(GetVirtualListItem(rdi.nIndex + 1L, pMMCListView,
                                                FireGetItemData, &pMMCListItem));
                }
                else
                {
                    pMMCListItem = reinterpret_cast<CMMCListItem *>(rdi.lParam);
                }

                lIndex = pMMCListItem->GetIndex();
                varKey.bstrVal = pMMCListItem->GetKey();
                if (NULL != varKey.bstrVal)
                {
                    varKey.vt = VT_BSTR;
                }
                else
                {
                    UNSPECIFIED_PARAM(varKey);
                }
                IfFailGo(pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                     static_cast<IMMCListItem *>(pMMCListItem)));
                pMMCListItem->SetIndex(lIndex);

                if (fVirtual)
                {
                    // We need to release the ref from creation because the
                    // collection now holds its own ref
                    pMMCListItem->Release();
                    pMMCListItem = NULL;
                }
            }
        }

        rdi.nState = LVIS_SELECTED;
        hr = m_piResultData->GetNextItem(&rdi);
        EXCEPTION_CHECK_GO(hr);

    }

    // Put the arrays of scopitems and listitems into the data object

    pMMCDataObject->SetScopeItems(pScopeItems);
    pMMCDataObject->SetListItems(pMMCListItems);

    // Set the dataobject type to multiselect because we populated its
    // collections rather than its individual scope or list item.

    pMMCDataObject->SetType(CMMCDataObject::MultiSelect);

    // If requested, get a clipboard object with the selection

    if (NULL != ppiMMCClipboard)
    {
        IfFailGo(::CreateSelection(static_cast<IDataObject *>(pMMCDataObject),
                                   ppiMMCClipboard, m_pSnapIn, &SelectionType));
    }

    // If requested, return the data object

    if (NULL != ppMMCDataObject)
    {
        pMMCDataObject->AddRef();
        *ppMMCDataObject = pMMCDataObject;
    }

Error:
    if ( fVirtual && (NULL != pMMCListItem) )
    {
        pMMCListItem->Release();
    }
    QUICK_RELEASE(punkDataObject);
    QUICK_RELEASE(punkScopeItems);
    QUICK_RELEASE(punkListItems);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}



HRESULT CView::CreateMultiSelectDataObject(IDataObject **ppiDataObject)
{
    HRESULT         hr = S_OK;
    IMMCClipboard  *piMMCClipboard = NULL;
    CMMCDataObject *pMMCDataObject = NULL;

    *ppiDataObject = NULL;

    // Get the current selection in both an MMCClipboard and an MMCDataObject

    IfFailGo(GetCurrentListViewSelection(&piMMCClipboard, &pMMCDataObject));

    // Give the snap-in a chance to set its own custom multi-select formats

    m_pSnapIn->GetViews()->FireGetMultiSelectData(static_cast<IView *>(this),
                                  piMMCClipboard,
                                  static_cast<IMMCDataObject *>(pMMCDataObject));

    *ppiDataObject = static_cast<IDataObject *>(pMMCDataObject);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::GetVirtualListItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long                     lIndex        [in]  index of virtual list item
//  CMMCListView            *pMMCListView  [in]  owning virtual listview
//  VirtualListItemOptions   Option        [in]  which event to fire
//  CMMCListItem           **ppMMCListItem [out] listitem returned here, caller
//                                               must Release
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called during IComponent::QueryDataObject() when the
// data object must represent list items in a virtual list view.
//
// Calls MMCListView.ListItems(lIndex) which will create the virtual list item
// and tie it to the listview (so it can access the underlying IResultData.
//
// Fires either ResultViews_GetVirtualItemDisplayInfo or
// ResultViews_GetVirtualItemData depending on option.
//
// A snap-in using a virtual list must implement GetVirtualItemDisplayInfo so
// that virtual list items will display correctly. Implementing
// GetVirtualItemData is optional.
//

HRESULT CView::GetVirtualListItem
(
    long                     lIndex,
    CMMCListView            *pMMCListView,
    VirtualListItemOptions   Option,
    CMMCListItem           **ppMMCListItem
)
{
    HRESULT        hr = S_OK;
    IMMCListItems *piMMCListItems = NULL; // Not AddRef()ed
    IMMCListItem  *piMMCListItem = NULL;
    CMMCListItem  *pMMCListItem = NULL;
    CResultView   *pResultView = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    piMMCListItems = pMMCListView->GetListItems();
    IfFalseGo(NULL != piMMCListItems, SID_E_INTERNAL);

    pResultView = pMMCListView->GetResultView();
    IfFalseGo(NULL != piMMCListItems, SID_E_INTERNAL);

    // Getting a list item at the given index in virtual list creates the
    // virtual list item. It does not become a member of the collection
    // but it does use a back point to the collection to get back up to the
    // View for IResultData access.

    varIndex.vt = VT_I4;
    varIndex.lVal = lIndex;
    IfFailGo(piMMCListItems->get_Item(varIndex, reinterpret_cast<MMCListItem **>(&piMMCListItem)));

    // We hold a ref on the newly minted virtual list item that will be
    // released below. The list item's data object also holds a ref on
    // it so it will stay alive until MMC releases the IDataObject

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                   &pMMCListItem));

    // Fire desired event

    if (FireGetItemData == Option)
    {
        m_pSnapIn->GetResultViews()->FireGetVirtualItemData(
                                      static_cast<IResultView *>(pResultView),
                                      static_cast<IMMCListItem *>(pMMCListItem));
    }
    else if (FireGetItemDisplayInfo == Option)
    {
        m_pSnapIn->GetResultViews()->FireGetVirtualItemDisplayInfo(
                                      static_cast<IResultView *>(pResultView),
                                      static_cast<IMMCListItem *>(pMMCListItem));
    }

    *ppMMCListItem = pMMCListItem;

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListItem);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::ListItemUpdate
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CMMCListItem *pMMCListItem [in]  list item that was updated
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called from CMMCListItem::Update for a virtual listitem so
// that we can check whether it is the same as the one we are caching. If they
// are the same then release our cached item and store this one. This allows the
// snap-in to do stuff like this in a virtual listview:
//
// Set ListItem = ResultView.ListItems(27)
// ListItem.Text = "Some new text"
// ListITem.Icon = 4
// ListItem.Update
//
// The first line creates a new MMCListItem and returns it. The next two lines
// set properties on it. The last line stores it so that when
// IComponent::GetDisplayInfo is called we will not fire
// ResultViews_GetVirtualItemDisplayInfo because we already have it.
//

void CView::ListItemUpdate(CMMCListItem *pMMCListItem)
{
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
    }
    pMMCListItem->AddRef();
    m_pCachedMMCListItem = pMMCListItem;
}




HRESULT CView::InternalCreatePropertyPages
(
    IPropertySheetCallback  *piPropertySheetCallback,
    LONG_PTR                 handle,
    IDataObject             *piDataObject,
    WIRE_PROPERTYPAGES     **ppPages
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrProjectName = NULL;
    CPropertySheet *pPropertySheet = NULL;
    IUnknown       *punkPropertySheet = CPropertySheet::Create(NULL);
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Check that we have a CPropertySheet and get is this pointer.

    if (NULL == punkPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertySheet,
        &pPropertySheet));

    // Give the property sheet its callback, handle, the selection, and the
    // project name which is the left hand portion of the prog ID.

    IfFailGo(GetProjectName(&bstrProjectName));

    // If this is a remote call (will happen during source debugging) then tell
    // the CPropertySheet so it can accumulate the property page info rather
    // than calling IPropertySheetCallback::AddPage.

    if (NULL != ppPages)
    {
        pPropertySheet->YouAreRemote();
    }

    IfFailGo(pPropertySheet->SetCallback(piPropertySheetCallback, handle,
                                         static_cast<LPOLESTR>(bstrProjectName),
                                         piMMCClipboard,
                                         static_cast<ISnapIn *>(m_pSnapIn),
                                         FALSE)); // not a config wizard

    // Let the snap-in add its property pages

    m_pSnapIn->GetViews()->FireCreatePropertyPages(
                               static_cast<IView *>(this),
                               piMMCClipboard,
                               static_cast<IMMCPropertySheet *>(pPropertySheet));

    // If we are remote then we need to ask CPropertySheet for its accumulated
    // property page definitions to return to the stub.

    if (NULL != ppPages)
    {
        *ppPages = pPropertySheet->TakeWirePages();
    }

    // Tell the property sheet to release its refs on all that stuff we
    // gave it above.

    (void)pPropertySheet->SetCallback(NULL, NULL, NULL, NULL, NULL, FALSE);


Error:
    FREESTRING(bstrProjectName);

    // Release our ref on the property sheet as the individual pages will addref
    // it and then release it when they are destroyed. If the snap-in did not
    // add any pages then our release here will destroy the property sheet.

    QUICK_RELEASE(punkPropertySheet);

    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::GetScopeItemDisplayString
(
    CScopeItem *pScopeItem,
    int         nCol,
    LPOLESTR   *ppwszString
)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    IMMCListSubItems  *piMMCListSubItems = NULL;
    IMMCListSubItem   *piMMCListSubItem = NULL;
    CMMCListSubItem   *pMMCListSubItem = NULL;
    IMMCColumnHeaders *piListViewColumnHeaders = NULL;
    IMMCColumnHeaders *piScopeItemColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }
    if (NULL != pResultView)
    {
        pMMCListView = pResultView->GetListView();
    }

    // If there is no listview or the selected item is not active (meaning it was
    // deselected) then this is a scope item in a namespace
    // extension being displayed in a result pane owned by the extendee. In that
    // case just use the the column number as an index into
    // ScopeItem.ListSubItems

    if ( (NULL == pMMCListView) || (!pSelectedItem->Active()) )
    {
        varIndex.vt = VT_I4;
        varIndex.lVal = (long)nCol + 1L; // adjust for 1-based collection
    }
    else
    {
        // This is a scope item displayed in a result pane belong to its own
        // snapin. Get the key of listview column header at the column number
        // requested by MMC

        IfFailGo(pMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piListViewColumnHeaders)));

        varIndex.vt = VT_I4;
        varIndex.lVal = (long)nCol + 1L; // adjust for 1-based collection

        // UNDONE: perf improvement here by getting the key string from
        // CColumnHeader::GetKey() rather than BSTR alloc

        IfFailGo(piListViewColumnHeaders->get_Item(varIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader)));
        IfFailGo(piMMCColumnHeader->get_Key(&varIndex.bstrVal));
        RELEASE(piMMCColumnHeader);
        varIndex.vt = VT_BSTR;

        // Get the column header with the same key in the scope item headers
        // and then get its index

        IfFailGo(pScopeItem->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piScopeItemColumnHeaders)));
        IfFailGo(piScopeItemColumnHeaders->get_Item(varIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader)));
        IfFailGo(::VariantClear(&varIndex));
        IfFailGo(piMMCColumnHeader->get_Index(&varIndex.lVal));
        varIndex.vt = VT_I4;
    }

    // Get the string in the scope item's ListSubItems at the index determined
    // above.

    IfFailGo(pScopeItem->get_ListSubItems(reinterpret_cast<MMCListSubItems **>(&piMMCListSubItems)));
    IfFailGo(piMMCListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListSubItem,
                                                   &pMMCListSubItem));
    *ppwszString = pMMCListSubItem->GetTextPtr();

Error:
    QUICK_RELEASE(piMMCListSubItems);
    QUICK_RELEASE(piMMCListSubItem);
    QUICK_RELEASE(piListViewColumnHeaders);
    QUICK_RELEASE(piScopeItemColumnHeaders);
    QUICK_RELEASE(piMMCColumnHeader);
    (void)::VariantClear(&varIndex);
    RRETURN(hr);
}


HRESULT CView::OnFilterButtonClick(long lColIndex, RECT *pRect)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL; // Not AddRef()ed

    // Crawl down the hierarchy to get the column headers collection

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

    pMMCColumnHeaders = pMMCListView->GetColumnHeaders();
    IfFalseGo(NULL != pMMCColumnHeaders, SID_E_INTERNAL);

    IfFalseGo(lColIndex < pMMCColumnHeaders->GetCount(), SID_E_INTERNAL);
    piMMCColumnHeader = pMMCColumnHeaders->GetItemByIndex(lColIndex);

    // Fire ResultViews_FilterButtonClick

    m_pSnapIn->GetResultViews()->FireFilterButtonClick(pResultView,
                                                       piMMCColumnHeader,
                                                       pRect->left,
                                                       pRect->top,
                                                       pRect->bottom - pRect->top,
                                                       pRect->right - pRect->left);
Error:
    RRETURN(hr);
}

HRESULT CView::OnFilterChange(MMC_FILTER_CHANGE_CODE ChangeCode, long lColIndex)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL; // Not AddRef()ed

    SnapInFilterChangeTypeConstants Type = siEnable;

    // If we are currently populating the listview then this event was generated
    // becasue we applied a filter so ignore it

    IfFalseGo(!m_fPopulatingListView, S_OK);

    // Crawl down the hierarchy to get the column headers collection
            
    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

    pMMCColumnHeaders = pMMCListView->GetColumnHeaders();
    IfFalseGo(NULL != pMMCColumnHeaders, SID_E_INTERNAL);

    // Set the change type enum based on the change code received from MMC.
    // For a value change get an IMMCColumnHeader* on the column that changed

    switch (ChangeCode)
    {
        case MFCC_DISABLE:
            Type = siDisable;
            break;

        case MFCC_ENABLE:
            Type = siEnable;
            break;

        case MFCC_VALUE_CHANGE:
            Type = siValueChange;
            IfFalseGo(lColIndex < pMMCColumnHeaders->GetCount(), SID_E_INTERNAL);
            piMMCColumnHeader = pMMCColumnHeaders->GetItemByIndex(lColIndex);
            break;
    }

    // Fire ResultViews_FilterChange

    m_pSnapIn->GetResultViews()->FireFilterChange(pResultView, piMMCColumnHeader,
                                                  Type);

Error:
    RRETURN(hr);
}


HRESULT CView::OnPropertiesVerb(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_SpecialPropertiesClick

    m_pSnapIn->GetViews()->FireSpecialPropertiesClick(this, SelectionType);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}

HRESULT CView::GetScopePaneItem
(
    CScopeItem      *pScopeItem,
    CScopePaneItem **ppScopePaneItem
)
{
    HRESULT         hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;

    // If ScopeItem is NULL then this is a request for the static node due
    // to an IComponent::GetResultViewType(cookie=0) call.
    
    if (NULL == pScopeItem)
    {
        *ppScopePaneItem = m_pScopePaneItems->GetStaticNodeItem();
        if (NULL == *ppScopePaneItem)
        {
            IfFailGo(m_pScopePaneItems->AddNode(m_pSnapIn->GetStaticNodeScopeItem(),
                                                ppScopePaneItem));
        }
    }
    else
    {
        hr = m_pScopePaneItems->GetItemByName(pScopeItem->GetNamePtr(),
                                              &piScopePaneItem);
        if (SUCCEEDED(hr))
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                           ppScopePaneItem));
        }
        else if (SID_E_ELEMENT_NOT_FOUND == hr)
        {
            IfFailGo(m_pScopePaneItems->AddNode(pScopeItem, ppScopePaneItem));
        }
        else
        {
            IfFailGo(hr);
        }
    }

Error:

    // Note that we release the ref on the ScopePaneItem as we are returning
    // the C++ pointer. The item is guaranteed to be in the collection until
    // the MMC notification processing completes so this is OK. Possible
    // notifications that would call this function are MMCN_RESTORE_VIEW
    // (CView::OnResotreView()) and IComponent::GetResultViewType()
    // (CView::GetResultViewType()).
    
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}


HRESULT CView::GetCompareObject
(
    RDITEMHDR     *pItemHdr,
    CScopeItem   **ppScopeItem,
    CMMCListItem **ppMMCListItem,
    IDispatch    **ppdispItem
)
{
    HRESULT hr = S_OK;

    *ppMMCListItem = NULL;
    *ppScopeItem = NULL;
    *ppdispItem = NULL;

    if ( (pItemHdr->dwFlags & RDCI_ScopeItem) != 0 )
    {
        *ppScopeItem = reinterpret_cast<CScopeItem *>(pItemHdr->cookie);
        IfFailGo((*ppScopeItem)->QueryInterface(IID_IDispatch,
                                       reinterpret_cast<void **>(ppdispItem)));
    }
    else
    {
        *ppMMCListItem = reinterpret_cast<CMMCListItem *>(pItemHdr->cookie);
        IfFailGo((*ppMMCListItem)->QueryInterface(IID_IDispatch,
                                       reinterpret_cast<void **>(ppdispItem)));
    }

Error:
    RRETURN(hr);
}
    

HRESULT CView::AddMenu(CMMCMenu *pMMCMenu, HMENU hMenu, CMMCMenus *pMMCMenus)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piMenuItems = NULL;
    CMMCMenus *pMMCMenuItems = NULL;
    IMMCMenus *piSubMenuItems = NULL;
    CMMCMenu  *pMMCMenuItem = NULL;
    long       cMenuItems = 0;
    long       i = 0;
    BOOL       fSkip = FALSE;
    BOOL       fHasChildren = FALSE;
    UINT       uiFlags = 0;
    HMENU      hMenuChild = NULL;
    UINT_PTR   uIDNewItem = 0;
    char      *pszCaption = NULL;
    long       lIndexCmdID = 0;

    // Get the children of the MMCMenu. These represent the items that
    // are being added to MMC's menu at the specified insertion point.

    IfFailGo(pMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMenuItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMenuItems, &pMMCMenuItems));

    cMenuItems = pMMCMenuItems->GetCount();

    // Iterate through the menu items and add each one to the popup menu and
    // to the CMMCMenus collection.

    for (i = 0; i < cMenuItems; i++)
    {
        // Add the menu item to our MMCMenus collection and get its command ID
        IfFailGo(CContextMenu::AddItemToCollection(pMMCMenus, pMMCMenuItems, i,
                                                   &pMMCMenuItem, &lIndexCmdID,
                                                   &fHasChildren, &fSkip));
        if (fSkip)
        {
            // Menu item is not visible, skip it.
            continue;
        }

        uiFlags = 0;

        uiFlags |= pMMCMenuItem->GetChecked() ? MF_CHECKED : MF_UNCHECKED;
        uiFlags |= pMMCMenuItem->GetEnabled() ? MF_ENABLED : MF_DISABLED;

        if (pMMCMenuItem->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCMenuItem->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCMenuItem->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (fHasChildren)
        {
            uiFlags |= MF_POPUP;
            hMenuChild = ::CreatePopupMenu();
            if (NULL == hMenuChild)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }
            uIDNewItem = reinterpret_cast<UINT_PTR>(hMenuChild);
        }
        else
        {
            uiFlags |= MF_STRING;
            uIDNewItem = (UINT_PTR)lIndexCmdID;
        }

        IfFailGo(::ANSIFromWideStr(pMMCMenuItem->GetCaption(), &pszCaption));

        // Add the item to the popup menu

        if (!::AppendMenu(hMenu, uiFlags, uIDNewItem, pszCaption))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        // If the item is a popup then call this function recursively to add its
        // items. Pass the command ID of this menu as the insertion point for
        // the submenu.

        if (fHasChildren)
        {
            IfFailGo(AddMenu(pMMCMenuItem, hMenuChild, pMMCMenus));
        }

        // Set this to NULL. When the top level hMenu is destroyed it will
        // destroy all sub-menus

        hMenuChild = NULL;

        CtlFree(pszCaption);
        pszCaption = NULL;
    }

Error:
    QUICK_RELEASE(piMenuItems);
    QUICK_RELEASE(piSubMenuItems);
    if (NULL != hMenuChild)
    {
        (void)::DestroyMenu(hMenuChild);
    }
    if (NULL != pszCaption)
    {
        CtlFree(pszCaption);
    }
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CView::SetStatusBarText(BSTR Text)
{
    HRESULT hr = S_OK;
    BOOL    fAllocatedEmptyString = FALSE;

    // If a snap-in passes an empty string VBA will pass it as NULL. MMC can
    // handle that but when running in a debugging session the generated proxy
    // will return an error. So, if the string is NULL then we allocate an
    // empty BSTR.

    if (NULL == Text)
    {
        Text = ::SysAllocString(L"");
        if (NULL == Text)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        fAllocatedEmptyString = TRUE;
    }

    hr = m_piConsole2->SetStatusText(static_cast<LPOLESTR>(Text));
    EXCEPTION_CHECK(hr);

Error:
    if (fAllocatedEmptyString)
    {
        FREESTRING(Text);
    }

    RRETURN(hr);
}


STDMETHODIMP CView::SelectScopeItem
(
    ScopeItem *ScopeItem,
    VARIANT    ViewType,
    VARIANT    DisplayString
)
{
    HRESULT                        hr = S_OK;
    CScopeItem                    *pScopeItem = NULL;
    CScopePaneItem                *pScopePaneItem = NULL;
    SnapInResultViewTypeConstants  siViewType = siUnknown;
    BSTR                           bstrDisplayString = NULL; // Don't free
    
    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    if (NULL == ScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the CScopeItem

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                        reinterpret_cast<IScopeItem *>(ScopeItem), &pScopeItem));

    // If ViewType and DisplayString were passed then convert them to the
    // correct types
    
    if (ISPRESENT(ViewType))
    {
        hr = ::VariantChangeType(&varCoerced, &ViewType, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        siViewType = (SnapInResultViewTypeConstants)varCoerced.iVal;

        hr = ::VariantClear(&varCoerced);
        EXCEPTION_CHECK_GO(hr);

    }

    if (ISPRESENT(DisplayString))
    {
        hr = ::VariantChangeType(&varCoerced, &DisplayString, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        bstrDisplayString = varCoerced.bstrVal;
    }

    // Get the corresponding ScopePaneItem and call
    // ScopePaneItem.DisplayNewResultView to do the work

    IfFailGo(GetScopePaneItem(pScopeItem, &pScopePaneItem));
    IfFailGo(pScopePaneItem->DisplayNewResultView(bstrDisplayString, siViewType));
        
Error:
    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);
    RRETURN(hr);
}

STDMETHODIMP CView::ExpandInTreeView(ScopeNode *ScopeNode)
{
    HRESULT     hr = S_OK;
    CScopeNode *pScopeNode = NULL;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->Expand(pScopeNode->GetHSCOPEITEM(), TRUE);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::CollapseInTreeView(ScopeNode *ScopeNode)
{
    HRESULT  hr = S_OK;
    CScopeNode *pScopeNode = NULL;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->Expand(pScopeNode->GetHSCOPEITEM(), FALSE);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::NewWindow
(
    ScopeNode                      *ScopeNode,
    SnapInNewWindowOptionConstants  Options,
    VARIANT                         Caption
)
{
    HRESULT     hr = S_OK;
    CScopeNode *pScopeNode = NULL;
    long        lOptions = MMC_NW_OPTION_NONE;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (Options & siNoScopePane) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOSCOPEPANE;
    }

    if ( (Options & siNoToolbars) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOTOOLBARS;
    }

    if ( (Options & siShortTitle) != 0 )
    {
        lOptions |= MMC_NW_OPTION_SHORTTITLE;
    }

    if ( (Options & siCustomTitle) != 0 )
    {
        lOptions |= MMC_NW_OPTION_CUSTOMTITLE;
    }

    if ( (Options & siNoPersist) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOPERSIST;
    }

    if ( ISPRESENT(Caption) && (VT_BSTR == Caption.vt) )
    {
        IfFailGo(m_pSnapIn->GetViews()->SetNextViewCaption(Caption.bstrVal));
    }

    hr = m_piConsole2->NewWindow(pScopeNode->GetHSCOPEITEM(), lOptions);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::PopupMenu(MMCMenu *Menu, long Left, long Top)
{
    HRESULT    hr = S_OK;
    HMENU      hMenu = NULL;
    IUnknown  *punkMMCMenus = NULL;
    CMMCMenus *pMMCMenus = NULL;
    CMMCMenu  *pMMCMenu = NULL;
    long       i = 0;
    HWND       hwndDummyOwner = NULL;
    HWND       hwndOwner = NULL;

    if (NULL == Menu)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Create a popup menu

    hMenu = ::CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Create an MMCMenus collection

    punkMMCMenus = CMMCMenus::Create(NULL);
    if (NULL == punkMMCMenus)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCMenus, &pMMCMenus));

    // Build the popup menu from the MMCMenu. Add each menu item to the popup
    // menu and to the MMCMenus collection. The collection index will be used
    // as the popup menu ID. When the user makes a selection we will find the
    // corresponding MMCMenu object by index and fire the event on it.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                reinterpret_cast<IMMCMenu *>(Menu), &pMMCMenu));

    IfFailGo(AddMenu(pMMCMenu, hMenu, pMMCMenus));

    
    // If we are not remoted then get the console's main frame window handle as
    // the owner of the popup menu

    if (!m_pSnapIn->WeAreRemote())
    {
        if (NULL == m_piConsole2)
        {
            hr = SID_E_NOT_CONNECTED_TO_MMC;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = m_piConsole2->GetMainWindow(&hwndOwner);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // We are remoted so we can't use an HWND from another process. Need to
        // create a dummy invisible window because TrackPopupMenu() requires a
        // valid HWND. We create a STATIC control so that we don't have to
        // register a window class.

        hwndDummyOwner = ::CreateWindow("STATIC", // window class
                                        NULL,     // no title
                                        WS_POPUP, // no styles
                                        0,        // upper left corner x
                                        0,        // upper left corner y
                                        0,        // no width
                                        0,        // no height
                                        NULL,     // no owner window
                                        NULL,     // no menu
                                        GetResourceHandle(), // HINSTANCE
                                        NULL);    // no lParam for WM_CREATE
        if (NULL == hwndDummyOwner)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        hwndOwner = hwndDummyOwner;
    }

    i = (long)::TrackPopupMenu(hMenu,            // menu to display
                               TPM_LEFTALIGN |   // align left side of menu with Top
                               TPM_TOPALIGN  |   // align top of menu with Top
                               TPM_NONOTIFY  |   // don't send any messages during selection
                               TPM_RETURNCMD |   // make the ret val the selected item
                               TPM_LEFTBUTTON,   // allow selection with left button only
                               Left,             // left side coordinate
                               Top,              // top coordinate
                               0,                // reserved,
                               hwndOwner,        // owner window
                               NULL);            // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error.

    if (0 == i)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    IfFalseGo((0 != i), S_OK);

    // if i is non-zero then it contains the index of the selected item in the
    // MMCMenus collection.

   IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                 pMMCMenus->GetItemByIndex(i - 1L), &pMMCMenu));

   // Fire the menu click event. CContextMenu has a utility function that
   // does this.
   
   CContextMenu::FireMenuClick(pMMCMenu, NULL);

Error:
    if (NULL != hMenu)
    {
        (void)::DestroyMenu(hMenu);
    }
    if (NULL != hwndDummyOwner)
    {
        (void)::DestroyWindow(hwndDummyOwner);
    }
    QUICK_RELEASE(punkMMCMenus);
    RRETURN(hr);
}


STDMETHODIMP CView::get_MMCMajorVersion(long *plVersion)
{
    HRESULT hr = S_OK;

    *plVersion = 0;

    // If we don't have m_piConsole2 yet then IComponent::Initialize hasn't
    // been called so we can't yet discern the MMC version.

    IfFalseGo(NULL != m_piConsole2, SID_E_MMC_VERSION_NOT_AVAILABLE);

    // We only support MMC 1.1 and 1.2 so always return 1

    *plVersion = 1L;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CView::get_MMCMinorVersion(long *plVersion)
{
    HRESULT hr = S_OK;

    // If we don't have m_piConsole2 yet then IComponent::Initialize hasn't
    // been called so we can't yet discern the MMC version.

    IfFalseGo(NULL != m_piConsole2, SID_E_MMC_VERSION_NOT_AVAILABLE);

    if (NULL == m_piColumnData)
    {
        // Must be MMC 1.1 as IColumnData is MMC 1.2 only
        *plVersion = 1L;
    }
    else
    {
        *plVersion = 2L;
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}

STDMETHODIMP CView::get_ColumnSettings
(
    BSTR             ColumnSetID,
    ColumnSettings **ppColumnSettings
)
{
    HRESULT              hr = S_OK;
    IUnknown            *punkColumnSettings = NULL;
    SColumnSetID        *pSColumnSetID = NULL;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;
    MMC_COLUMN_DATA     *pColData = NULL;
    IColumnSettings     *piColumnSettings = NULL;
    CColumnSettings     *pColumnSettings = NULL;
    IColumnSetting      *piColumnSetting = NULL;
    long                 i = 0;

    VARIANT varUnspecifiedParam;
    UNSPECIFIED_PARAM(varUnspecifiedParam);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    punkColumnSettings = CColumnSettings::Create(NULL);
    if (NULL == punkColumnSettings)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punkColumnSettings->QueryInterface(IID_IColumnSettings,
                                 reinterpret_cast<void **>(&piColumnSettings)));

    IfFailGo(::GetColumnSetID(ColumnSetID, &pSColumnSetID));

    // Get the current column configuration

    hr = m_piColumnData->GetColumnConfigData(pSColumnSetID, &pColSetData);
    EXCEPTION_CHECK_GO(hr);

    // The pointer will come back NULL if MMC has not yet persisted the column
    // config.

    if (NULL != pColSetData)
    {
        // Add an element to the collection for each persisted column. Adjust the
        // indexes and positions to be one-based. Start by adding the elements.

        for (i = 0; i < pColSetData->nNumCols; i++)
        {
            IfFailGo(piColumnSettings->Add(varUnspecifiedParam, // Index
                                           varUnspecifiedParam, // Key
                                           varUnspecifiedParam, // Width
                                           varUnspecifiedParam, // Hidden
                                           varUnspecifiedParam, // Position
                         reinterpret_cast<ColumnSetting **>(&piColumnSetting)));
            RELEASE(piColumnSetting);
        }

        // Now go through the columns and set their properties.

        varIndex.vt = VT_I4;
        pColData = pColSetData->pColData;

        for (i = 0; i < pColSetData->nNumCols; i++, pColData++)
        {
            varIndex.lVal = static_cast<long>(pColData->nColIndex) + 1L;
            IfFailGo(piColumnSettings->get_Item(varIndex,
                         reinterpret_cast<ColumnSetting **>(&piColumnSetting)));

            IfFailGo(piColumnSetting->put_Width(static_cast<long>(pColData->nWidth)));

            if ( (pColData->dwFlags & HDI_HIDDEN) != 0 )
            {
                IfFailGo(piColumnSetting->put_Hidden(VARIANT_TRUE));
            }
            else
            {
                IfFailGo(piColumnSetting->put_Hidden(VARIANT_FALSE));
            }

            // A columns position in the list view is based on where it appears in
            // the array returned from MMC

            IfFailGo(piColumnSetting->put_Position(i + 1L));

            RELEASE(piColumnSetting);
        }
    }

    // Set ColumnSettings.ColumnSetID

    IfFailGo(piColumnSettings->put_ColumnSetID(ColumnSetID));

    // Give ColumnSettings its back pointer to the owning View so it can get
    // the IColumnData to implement ColumnSettings.Perist

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piColumnSettings,
                                                   &pColumnSettings));
    pColumnSettings->SetView(this);

    *ppColumnSettings = reinterpret_cast<ColumnSettings *>(piColumnSettings);
    piColumnSettings->AddRef();

Error:
    QUICK_RELEASE(punkColumnSettings);
    QUICK_RELEASE(piColumnSettings);
    QUICK_RELEASE(piColumnSetting);

    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }

    if (NULL != pColSetData)
    {
        ::CoTaskMemFree(pColSetData);
    }
    RRETURN(hr);
}

STDMETHODIMP CView::get_SortSettings
(
    BSTR       ColumnSetID,
    SortKeys **ppSortKeys
)
{
    HRESULT            hr = S_OK;
    IUnknown          *punkSortKeys = NULL;
    SColumnSetID      *pSColumnSetID = NULL;
    MMC_SORT_SET_DATA *pSortSetData = NULL;
    MMC_SORT_DATA     *pSortData = NULL;
    ISortKeys         *piSortKeys = NULL;
    CSortKeys         *pSortKeys = NULL;
    ISortKey          *piSortKey = NULL;
    long               i = 0;

    VARIANT varUnspecifiedParam;
    UNSPECIFIED_PARAM(varUnspecifiedParam);

    VARIANT varSortColumn;
    ::VariantInit(&varSortColumn);

    VARIANT varSortOrder;
    ::VariantInit(&varSortOrder);

    VARIANT varSortIcon;
    ::VariantInit(&varSortIcon);

    if (NULL == m_piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    punkSortKeys = CSortKeys::Create(NULL);
    if (NULL == punkSortKeys)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punkSortKeys->QueryInterface(IID_ISortKeys,
                                          reinterpret_cast<void **>(&piSortKeys)));

    IfFailGo(::GetColumnSetID(ColumnSetID, &pSColumnSetID));

    // Get the current sort settings

    hr = m_piColumnData->GetColumnSortData(pSColumnSetID, &pSortSetData);
    EXCEPTION_CHECK_GO(hr);

    // The pointer will come back NULL if MMC has not yet persisted the sort
    // settings

    if (NULL != pSortSetData)
    {
        // Add an element to the collection for each persisted column. Adjust the
        // indexes and positions to be one-based. Start by adding the elements.

        varSortColumn.vt = VT_I4;
        varSortOrder.vt = VT_I4;
        varSortIcon.vt = VT_BOOL;

        for (i = 0, pSortData = pSortSetData->pSortData;
             i < pSortSetData->nNumItems;
             i++, pSortData++)
        {
            varSortColumn.lVal = static_cast<long>(pSortData->nColIndex + 1);

            if ( (pSortData->dwSortOptions & RSI_DESCENDING) != 0 )
            {
                varSortOrder.lVal = static_cast<long>(siDescending);
            }
            else
            {
                varSortOrder.lVal = static_cast<long>(siAscending);
            }

            if ( (pSortData->dwSortOptions & RSI_NOSORTICON) != 0 )
            {
                varSortIcon.boolVal = VARIANT_FALSE;
            }
            else
            {
                varSortIcon.boolVal = VARIANT_TRUE;
            }

            IfFailGo(piSortKeys->Add(varUnspecifiedParam, // Index
                                     varUnspecifiedParam, // Key
                                     varSortColumn,
                                     varSortOrder,
                                     varSortIcon,
                                     reinterpret_cast<SortKey **>(&piSortKey)));
            RELEASE(piSortKey);
        }
    }

    // Set SortKeys.ColumnSetID

    IfFailGo(piSortKeys->put_ColumnSetID(ColumnSetID));

    // Give SortKeys its back pointer to the owning View so it can get
    // the IColumnData to implement SortKeys.Perist

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSortKeys, &pSortKeys));
    pSortKeys->SetView(this);

    *ppSortKeys = reinterpret_cast<SortKeys *>(piSortKeys);
    piSortKeys->AddRef();

Error:
    QUICK_RELEASE(punkSortKeys);
    QUICK_RELEASE(piSortKeys);
    QUICK_RELEASE(piSortKey);

    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }

    if (NULL != pSortSetData)
    {
        ::CoTaskMemFree(pSortSetData);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IComponent Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::Initialize(IConsole *piConsole)
{
    DebugPrintf("IComponent::Initialize\r\n");
    
    HRESULT                 hr = S_OK;
    IContextMenuProvider   *piContextMenuProvider = NULL;
    IPropertySheetProvider *piPropertySheetProvider = NULL;

    // In theory, this method should never be called twice but as a precaution
    // we'll release any existing console interfaces.

    ReleaseConsoleInterfaces();

    // Acquire all the console interfaces needed for the life of the view

    IfFailGo(piConsole->QueryInterface(IID_IConsole2,
                                     reinterpret_cast<void **>(&m_piConsole2)));
    
    IfFailGo(m_piConsole2->QueryInterface(IID_IResultData,
                                   reinterpret_cast<void **>(&m_piResultData)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IHeaderCtrl2,
                                  reinterpret_cast<void **>(&m_piHeaderCtrl2)));

    IfFailGo(m_piConsole2->SetHeader(m_piHeaderCtrl2));

    // Try to get IColumnData. If MMC version < 1.2 then this will fail.
    (void)m_piConsole2->QueryInterface(IID_IColumnData,
                                    reinterpret_cast<void **>(&m_piColumnData));

    IfFailGo(m_piConsole2->QueryResultImageList(&m_piImageList));

    IfFailGo(m_piConsole2->QueryConsoleVerb(&m_piConsoleVerb));

    IfFailGo(piConsole->QueryInterface(IID_IContextMenuProvider,
                            reinterpret_cast<void **>(&piContextMenuProvider)));

    IfFailGo(m_pMMCContextMenuProvider->SetProvider(piContextMenuProvider, this));

    IfFailGo(piConsole->QueryInterface(IID_IPropertySheetProvider,
                          reinterpret_cast<void **>(&piPropertySheetProvider)));

    IfFailGo(m_pMMCPropertySheetProvider->SetProvider(piPropertySheetProvider,
                                                      this));

    // Fire Views_Load to tell snap-in that MMC has initialized the view

    m_pSnapIn->GetViews()->FireLoad(static_cast<IView *>(this));
    
Error:
    QUICK_RELEASE(piContextMenuProvider);
    QUICK_RELEASE(piPropertySheetProvider);
    RRETURN(hr);
}


STDMETHODIMP CView::Notify
(
    IDataObject     *piDataObject,
    MMC_NOTIFY_TYPE  event,
    long             Arg,
    long             Param
)
{
    DebugPrintf("IComponent::Notify(event=0x%08.8X Arg=%ld (0x%08.8X) Param=%ld (0x%08.8X)\r\n",  event, Arg, Arg, Param, Param);
    HRESULT hr = S_OK;

    switch (event)
    {
        case MMCN_ACTIVATE:
            DebugPrintf("IComponent::Notify(MMCN_ACTIVATE)\r\n");
            OnActivate((BOOL)Arg);
            break;
            
        case MMCN_ADD_IMAGES:
            DebugPrintf("IComponent::Notify(MMCN_ADD_IMAGES)\r\n");
            hr = OnAddImages(piDataObject,
                             reinterpret_cast<IImageList *>(Arg),
                             (HSCOPEITEM)Param);
            break;

        case MMCN_BTN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_BTN_CLICK)\r\n");
            hr = OnButtonClick(piDataObject,
                               static_cast<MMC_CONSOLE_VERB>(Param));
            break;

        case MMCN_COLUMN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_COLUMN_CLICK)\r\n");
            hr = OnColumnClick(Arg, Param);
            break;

        case MMCN_COLUMNS_CHANGED:
            DebugPrintf("IComponent::Notify(MMCN_COLUMNS_CHANGED)\r\n");
            hr = OnColumnsChanged(piDataObject,
                                  reinterpret_cast<MMC_VISIBLE_COLUMNS *>(Param));
            break;

        case MMCN_CUTORMOVE:
            DebugPrintf("IComponent::Notify(MMCN_CUTORMOVE)\r\n");
            hr = OnCutOrMove((IDataObject *)Arg);
            break;

        case MMCN_DBLCLICK:
            DebugPrintf("IComponent::Notify(MMCN_DBLCLICK)\r\n");
            hr = OnDoubleClick(piDataObject);
            break;

        case MMCN_DELETE:
            DebugPrintf("IComponent::Notify(MMCN_DELETE)\r\n");
            hr = OnDelete(piDataObject);
            break;

        case MMCN_DESELECT_ALL:
            DebugPrintf("IComponent::Notify(MMCN_DESELECT_ALL)\r\n");
            OnDeselectAll();
            break;

        case MMCN_FILTER_CHANGE:
            DebugPrintf("IComponent::Notify(MMCN_FILTER_CHANGE)\r\n");
            hr = OnFilterChange((MMC_FILTER_CHANGE_CODE)Arg, (long)Param);
            break;

        case MMCN_FILTERBTN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_FILTERBTN_CLICK)\r\n");
            hr = OnFilterButtonClick((long)Arg, (RECT *)Param);
            break;

        case MMCN_INITOCX:
            DebugPrintf("IComponent::Notify(MMCN_INITOCX)\r\n");
            hr = OnInitOCX(reinterpret_cast<IUnknown *>(Param));
            break;

        case MMCN_LISTPAD:
            DebugPrintf("IComponent::Notify(MMCN_LISTPAD)\r\n");
            hr = OnListpad(piDataObject, (BOOL)Arg);
            break;

        case MMCN_CONTEXTHELP:
            DebugPrintf("IComponent::Notify(MMCN_CONTEXTHELP)\r\n");
            OnContextHelp(piDataObject);
            break;

        case MMCN_MINIMIZED:
            DebugPrintf("IComponent::Notify(MMCN_MINIMIZED)\r\n");
            OnMinimized((BOOL)Arg);
            break;

        case MMCN_PASTE:
            DebugPrintf("IComponent::Notify(MMCN_PASTE)\r\n");
            hr = OnPaste(piDataObject, (IDataObject *)Arg, (IDataObject **)Param);
            break;

        case MMCN_PRINT:
            DebugPrintf("IComponent::Notify(MMCN_PRINT)\r\n");
            hr = OnPrint(piDataObject);
            break;

        case MMCN_QUERY_PASTE:
            DebugPrintf("IComponent::Notify(MMCN_QUERY_PASTE)\r\n");
            hr = OnQueryPaste(piDataObject, (IDataObject *)Arg);
            break;

        case MMCN_REFRESH:
            DebugPrintf("IComponent::Notify(MMCN_REFRESH)\r\n");
            hr = OnRefresh(piDataObject);
            break;

        case MMCN_RENAME:
            DebugPrintf("IComponent::Notify(MMCN_RENAME)\r\n");
            hr = OnRename(piDataObject, (OLECHAR *)Param);
            break;

        case MMCN_RESTORE_VIEW:
            DebugPrintf("IComponent::Notify(MMCN_RESTORE_VIEW)\r\n");
            hr = OnRestoreView(piDataObject,
                               (MMC_RESTORE_VIEW *)Arg,
                               (BOOL *)Param);
            break;

        case MMCN_SELECT:
            DebugPrintf("IComponent::Notify(MMCN_SELECT)\r\n");
            hr = OnSelect(piDataObject, (BOOL)LOWORD(Arg), (BOOL)HIWORD(Arg));
            break;

        case MMCN_SHOW:
            DebugPrintf("IComponent::Notify(MMCN_SHOW)\r\n");
            hr = OnShow((BOOL)Arg, (HSCOPEITEM)Param);
            break;

        case MMCN_SNAPINHELP:
            DebugPrintf("IComponent::Notify(MMCN_SNAPINHELP)\r\n");
            m_pSnapIn->FireHelp();
            break;

        case MMCN_VIEW_CHANGE:
            DebugPrintf("IComponent::Notify(MMCN_VIEW_CHANGE)\r\n");
            hr = OnViewChange(piDataObject, Arg);
            break;

    }

    RRETURN(hr);
}


STDMETHODIMP CView::Destroy(long cookie)
{
    HRESULT         hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    DebugPrintf("IComponent::Destroy\r\n");

    m_pSnapIn->GetViews()->FireTerminate(static_cast<IView *>(this));
    
    ReleaseConsoleInterfaces();

    // CSnapIn::CreateComponent caused an IObjectModel::SetHost() on this object
    // when it was created and this is the only opportunity remove our reference
    // on the host (which is CSnapIn)

    static_cast<IObjectModel *>(this)->SetHost(NULL);

    // Remove this view from SnapIn.Views

    varIndex.vt = VT_I4;
    varIndex.lVal = m_Index;

    IfFailGo(m_pSnapIn->GetViews()->Remove(varIndex));

    // Tell the ContextMenuProvider object to release its MMC interface and
    // to release its ref on us

    IfFailGo(m_pMMCContextMenuProvider->SetProvider(NULL, NULL));

    // Tell the PropertySheetProvider object to release its MMC interface and
    // to release its ref on us

    IfFailGo(m_pMMCPropertySheetProvider->SetProvider(NULL, NULL));

Error:    
    RRETURN(hr);
}



STDMETHODIMP CView::QueryDataObject
(
    long                cookie,
    DATA_OBJECT_TYPES   type,
    IDataObject       **ppiDataObject
)
{
    DebugPrintf("IComponent::QueryDataObject cookie=0x%08.8X type=0x%08.8X\r\n", cookie, type);

    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    IUnknown       *punkDataObject = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;
    BOOL            fReleaseListItem = FALSE;

    *ppiDataObject = NULL;

    if (IS_SPECIAL_COOKIE(cookie))
    {
        if ( (CCT_UNINITIALIZED == type) && (MMC_WINDOW_COOKIE == cookie) )
        {
            punkDataObject = CMMCDataObject::Create(NULL);
            if (NULL == punkDataObject)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }

            IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                           &pMMCDataObject));
            pMMCDataObject->SetSnapIn(m_pSnapIn);

            pMMCDataObject->SetType(CMMCDataObject::WindowTitle);
            IfFailGo(pMMCDataObject->SetCaption(m_bstrCaption));
        }
        else if (MMC_MULTI_SELECT_COOKIE == cookie)
        {
            IfFailGo(CreateMultiSelectDataObject(ppiDataObject));
        }
    }
    else if (CCT_RESULT == type)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
        pMMCListView = pResultView->GetListView();
        IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

        if (pMMCListView->IsVirtual())
        {
            // Create a virtual list item for use with the data object and fire
            // ResultViews_GetVirtualItemData

            IfFailGo(GetVirtualListItem(cookie + 1L, pMMCListView,
                                        FireGetItemData, &pMMCListItem));

            // We hold a ref on the newly minted virtual list item that will be
            // released below. The list item's data object also holds a ref on
            // it so it will stay alive until MMC releases the IDataObject
            fReleaseListItem = TRUE;
        }
        else
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(cookie);
        }
        pMMCDataObject = pMMCListItem->GetData();
        pMMCDataObject->SetContext(CCT_RESULT);
    }

    if (NULL != pMMCDataObject)
    {
        IfFailGo(pMMCDataObject->QueryInterface(IID_IDataObject,
                                      reinterpret_cast<void **>(ppiDataObject)));
    }

Error:
    if (fReleaseListItem)
    {
        pMMCListItem->Release();
    }
    QUICK_RELEASE(punkDataObject);
    RRETURN(hr);
}


STDMETHODIMP CView::GetResultViewType
(
    long      cookie,
    LPOLESTR *ppViewType,
    long     *pViewOptions
)
{
    DebugPrintf("IComponent::GetResultViewType cookie=0x%08.8X\r\n", cookie);

    HRESULT         hr = S_OK;
    CScopePaneItem *pScopePaneItem = NULL;
    CScopeItem     *pScopeItem = NULL;
    CMMCListView   *pMMCListView = NULL;

    SnapInResultViewTypeConstants Type = siUnknown;

    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;

    // Reset our virtual list view flag because we are transitioning to a new
    // result view.

    m_fVirtualListView = FALSE;


    IfFailGo(GetScopePaneItem(reinterpret_cast<CScopeItem *>(cookie),
                              &pScopePaneItem));
    
    // This is now the selected scope pane item so remember it
    m_pScopePaneItems->SetSelectedItem(pScopePaneItem);

    // Determine the result view by examining defaults and firing
    // events into the snap-in
    IfFailGo(pScopePaneItem->DetermineResultView());

    Type = pScopePaneItem->GetActualResultViewType();

    if (siOCXView == Type)
    {
        if (pScopePaneItem->GetResultView()->AlwaysCreateNewOCX())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_CREATENEW;
        }
    }
    else if ( (siListView == Type) || (siListpad == Type) )
    {
        pMMCListView = pScopePaneItem->GetResultView()->GetListView();

        if (pMMCListView->IsVirtual())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
            m_fVirtualListView = TRUE;
        }

        if (pMMCListView->MultiSelect())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
        }

        if (pMMCListView->UseFontLinking())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_USEFONTLINKING;
        }

        // If MMC >= 1.2 then check 1.2-only options

        if (NULL != m_piColumnData)
        {
            if (pMMCListView->GetView() == siFiltered)
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_FILTERED;
            }

            if (!pMMCListView->ShowChildScopeItems())
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
            }

            if (pMMCListView->LexicalSort())
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_LEXICAL_SORT;
            }
        }
    }

    switch (Type)
    {
        case siURLView:
        case siOCXView:
        case siTaskpad:
        case siListpad:
        case siCustomTaskpad:
        case siMessageView:
            IfFailGo(::CoTaskMemAllocString(
                                        pScopePaneItem->GetActualDisplayString(),
                                        ppViewType));
            break;

        default:
            break;
    }

    // If not doing a listview check if there are any listviews for this
    // scope pane item.

    if (!pScopePaneItem->HasListViews())
    {
        *pViewOptions |= MMC_VIEW_OPTIONS_NOLISTVIEWS;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::GetDisplayInfo
(
    RESULTDATAITEM *prdi
)
{
    DebugPrintf("IComponent::GetDisplayInfo %s %ls\r\n", prdi->bScopeItem ? "Scope item: " : "List item: ", prdi->bScopeItem ? (reinterpret_cast<CScopeItem *>(prdi->lParam))->GetDisplayNamePtr() : m_fVirtualListView ? L"<virtual list item>" : (reinterpret_cast<CMMCListItem *>(prdi->lParam))->GetTextPtr());

    HRESULT         hr = S_OK;
    CScopeItem     *pScopeItem = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    long            lViewMode = MMCLV_VIEWSTYLE_ICON;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;

    if (prdi->bScopeItem)
    {
        pScopeItem = reinterpret_cast<CScopeItem *>(prdi->lParam);
        if (NULL == pScopeItem)
        {
            // Static node has zero cookie. Technically this should
            // never happen as the static node cannot appear in
            // a list view owned by its own snap-in but we put this
            // here just in case.
            pScopeItem = m_pSnapIn->GetStaticNodeScopeItem();
        }

        if ( RDI_STR == (prdi->mask & RDI_STR) )
        {
            hr = m_piResultData->GetViewMode(&lViewMode);
            EXCEPTION_CHECK_GO(hr);

            if ( (0 == prdi->nCol) &&
                 (MMCLV_VIEWSTYLE_REPORT != lViewMode) &&
                 (MMCLV_VIEWSTYLE_FILTERED != lViewMode) )
            {
                // Not in detail modes, need the display name only
                prdi->str = pScopeItem->GetDisplayNamePtr();
            }
            else
            {
                // In report mode, need one of the columns
                IfFailGo(GetScopeItemDisplayString(pScopeItem, prdi->nCol,
                                                   &prdi->str));
            }
        }
        if ( RDI_IMAGE == (prdi->mask & RDI_IMAGE) )
        {
            IfFailGo(pScopeItem->GetImageIndex(&prdi->nImage));
        }
    }
    else 
    {
        // Display info is requested for a list item. There should definitely be
        // a currently selected scope pane item.

        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
        pMMCListView = pResultView->GetListView();
        IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

        // Get a CMMCListItem * pointing to the listitem in question
        
        if (!m_fVirtualListView)
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(prdi->lParam);
        }
        else
        {
            // A virtual listitem may either be cached or we need to create it
            // and ask the snap-in to initialze its display properties
            
            // If we have a cached list item but its index doesn't match
            // the requested index then release it.

            if (NULL != m_pCachedMMCListItem)
            {
                if (m_pCachedMMCListItem->GetIndex() != prdi->nIndex + 1L)
                {
                    m_pCachedMMCListItem->Release();
                    m_pCachedMMCListItem = NULL;
                }
            }

            // If we don't have a cached list item then create one and
            // fire ResultViews_GetVirtualItemDisplayInfo

            if (NULL == m_pCachedMMCListItem)
            {
                IfFailGo(GetVirtualListItem(prdi->nIndex + 1L, pMMCListView,
                                            FireGetItemDisplayInfo,
                                            &m_pCachedMMCListItem));
            }
            pMMCListItem = m_pCachedMMCListItem;
        }

        if ( RDI_STR == (prdi->mask & RDI_STR) )
        {
            hr = m_piResultData->GetViewMode(&lViewMode);
            EXCEPTION_CHECK_GO(hr);


            if ( (0 == prdi->nCol) && (MMCLV_VIEWSTYLE_REPORT != lViewMode) )
            {
                // Not in report mode, need the item text
                prdi->str = pMMCListItem->GetTextPtr();
            }
            else
            {
                // In report mode, need one of the columns
                IfFailGo(pMMCListItem->GetColumnTextPtr((long)prdi->nCol + 1L,
                                                        &prdi->str));
            }
        }

        if ( RDI_IMAGE == (prdi->mask & RDI_IMAGE) )
        {
            IfFailGo(GetImage(pMMCListItem, &prdi->nImage));
        }
    }

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::CompareObjects
(
    IDataObject *piDataObject1,
    IDataObject *piDataObject2
)
{
    DebugPrintf("IComponent::CompareObjects\r\n");
    RRETURN(m_pSnapIn->CompareObjects(piDataObject1, piDataObject2));
}



//=--------------------------------------------------------------------------=
//                      IExtendControlbar Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    CControlbar *pPrevControlbar = m_pSnapIn->GetCurrentControlbar();
    
    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->SetControlbar(piControlbar);

    m_pSnapIn->SetCurrentControlbar(pPrevControlbar);

    RRETURN(hr);
}


STDMETHODIMP CView::ControlbarNotify
(
    MMC_NOTIFY_TYPE event,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT      hr = S_OK;
    CControlbar *pPrevControlbar = m_pSnapIn->GetCurrentControlbar();

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    switch (event)
    {
        case MMCN_SELECT:
            hr = m_pControlbar->OnControlbarSelect(
                                         reinterpret_cast<IDataObject *>(param),
                                         (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
            break;

        case MMCN_BTN_CLICK:
            hr = m_pControlbar->OnButtonClick(
                                           reinterpret_cast<IDataObject *>(arg),
                                           static_cast<int>(param));
            break;

        case MMCN_MENU_BTNCLICK:
            hr = m_pControlbar->OnMenuButtonClick(
                                     reinterpret_cast<IDataObject *>(arg),
                                     reinterpret_cast<MENUBUTTONDATA *>(param));
            break;
    }

    m_pSnapIn->SetCurrentControlbar(pPrevControlbar);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IExtendControlbarRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CView::MenuButtonClick                            [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and the return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CView::PopupMenuClick()).
//

STDMETHODIMP CView::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT hr = S_OK;

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->MenuButtonClick(piDataObject, idCommand, ppPopupMenuDef);

    m_pSnapIn->SetCurrentControlbar(NULL);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CView::PopupMenuClick                             [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CView::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CView::MenuButtonClick() above for more info.
//

STDMETHODIMP CView::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT hr = S_OK;

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->PopupMenuClick(piDataObject, uiIDItem, punkParam);

    m_pSnapIn->SetCurrentControlbar(NULL);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      IExtendContextMenu Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed
)
{
    RRETURN(m_pContextMenu->AddMenuItems(piDataObject,
                                         piContextMenuCallback,
                                         plInsertionAllowed,
                                         m_pScopePaneItems->GetSelectedItem()));
}


STDMETHODIMP CView::Command
(
    long         lCommandID,
    IDataObject *piDataObject
)
{
    RRETURN(m_pContextMenu->Command(lCommandID, piDataObject,
                                    m_pScopePaneItems->GetSelectedItem()));
}


//=--------------------------------------------------------------------------=
//                    IExtendPropertySheet2 Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::CreatePropertyPages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject
)
{
    RRETURN(InternalCreatePropertyPages(piPropertySheetCallback, handle,
                                        piDataObject, NULL));
}



STDMETHODIMP CView::QueryPagesFor(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    VARIANT_BOOL    fvarHavePages = VARIANT_FALSE;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    m_pSnapIn->GetViews()->FireQueryPagesFor(static_cast<IView *>(this),
                                             piMMCClipboard,
                                             &fvarHavePages);

    if (VARIANT_TRUE == fvarHavePages)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::GetWatermarks
(
    IDataObject *piDataObject,
    HBITMAP     *phbmWatermark,
    HBITMAP     *phbmHeader,
    HPALETTE    *phPalette,
    BOOL        *bStretch
)
{
    *phbmWatermark = NULL;
    *phbmHeader = NULL;
    *phPalette = NULL;
    *bStretch = FALSE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                    IExtendPropertySheetRemote Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::CreatePropertyPageDefs
(
    IDataObject         *piDataObject,
    WIRE_PROPERTYPAGES **ppPages
)
{
    RRETURN(InternalCreatePropertyPages(NULL, NULL, piDataObject, ppPages));
}

//=--------------------------------------------------------------------------=
//                         IExtendTaskPad Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::TaskNotify
(
    IDataObject *piDataObject,
    VARIANT     *arg,
    VARIANT     *param
)
{
    HRESULT                       hr = S_OK;
    IMMCClipboard                *piMMCClipboard = NULL;
    SnapInSelectionTypeConstants  SelectionType = siEmpty;

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if (IsForeign(SelectionType))
    {
        IfFailGo(OnExtensionTaskNotify(piMMCClipboard, arg, param));
    }
    else
    {
        IfFailGo(OnPrimaryTaskNotify(arg, param));
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::EnumTasks
(
    IDataObject  *piDataObject,
    LPOLESTR      pwszTaskGroup,
    IEnumTASK   **ppEnumTASK
)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkEnumTask = CEnumTask::Create(NULL);
    CEnumTask      *pEnumTask = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    *ppEnumTASK = NULL;

    // Make sure we created the enumerator and get a C++ pointer for it

    if (NULL == punkEnumTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkEnumTask, &pEnumTask));

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    ASSERT(IsSingle(SelectionType), "IExtendTaskpad::EnumTasks received multiple selection. This should never happen");

    // If it is a foreign data object then this snap-in is running as a taskpad
    // extension. Taskpad extensions work differently than other extensions
    // because they are QIed for IComponentData and
    // IComponentData::CreateComponent is called. The component object is then
    // QIed for IExtendTaskpad.

    if (IsForeign(SelectionType))
    {
        IfFailGo(EnumExtensionTasks(piMMCClipboard, pwszTaskGroup, pEnumTask));
    }
    else
    {
        IfFailGo(EnumPrimaryTasks(pEnumTask));
    }

    pEnumTask->SetSnapIn(m_pSnapIn);

    IfFailGo(punkEnumTask->QueryInterface(IID_IEnumTASK,
                                        reinterpret_cast<void **>(ppEnumTASK)));

Error:
    QUICK_RELEASE(punkEnumTask);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::GetTitle
(
    LPOLESTR pwszGroup,
    LPOLESTR *ppwszTitle
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstrTitle = NULL;

    *ppwszTitle = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Title(&bstrTitle));
    IfFailGo(::CoTaskMemAllocString(bstrTitle, ppwszTitle));

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrTitle);
    RRETURN(hr);
}



STDMETHODIMP CView::GetDescriptiveText
(
    LPOLESTR  pwszGroup,
    LPOLESTR *ppwszDescriptiveText
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstrText = NULL;

    *ppwszDescriptiveText = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_DescriptiveText(&bstrText));
    IfFailGo(::CoTaskMemAllocString(bstrText, ppwszDescriptiveText));

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrText);
    RRETURN(hr);
}



STDMETHODIMP CView::GetBackground
(
    LPOLESTR                 pwszGroup,
    MMC_TASK_DISPLAY_OBJECT *pTDO
)
{
    HRESULT                          hr = S_OK;
    CScopePaneItem                  *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView                     *pResultView = NULL;
    ITaskpad                        *piTaskpad = NULL;
    SnapInTaskpadImageTypeConstants  Type = siNoImage;
    BSTR                             bstrURL = NULL;
    BSTR                             bstrFontFamily = NULL;
    BSTR                             bstrSymbolString = NULL;
    BOOL                             fNeedMouseImages = FALSE;

    ::ZeroMemory(pTDO, sizeof(*pTDO));
    pTDO->eDisplayType = MMC_TASK_DISPLAY_UNINITIALIZED;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_BackgroundType(&Type));

    switch (Type)
    {
        case siVanillaGIF:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;
            fNeedMouseImages = TRUE;
            break;
            
        case siChocolateGIF:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF;
            fNeedMouseImages = TRUE;
            break;

        case siBitmap:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
            fNeedMouseImages = TRUE;
            break;

        case siSymbol:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;

            IfFailGo(piTaskpad->get_FontFamily(&bstrFontFamily));
            if (ValidBstr(bstrFontFamily))
            {
                IfFailGo(::CoTaskMemAllocString(bstrFontFamily,
                                              &pTDO->uSymbol.szFontFamilyName));
            }

            IfFailGo(piTaskpad->get_EOTFile(&bstrURL));
            if (ValidBstr(bstrURL))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                                  &pTDO->uSymbol.szURLtoEOT));
                FREESTRING(bstrURL);
            }

            IfFailGo(piTaskpad->get_SymbolString(&bstrSymbolString));
            if (ValidBstr(bstrSymbolString))
            {
                IfFailGo(::CoTaskMemAllocString(bstrSymbolString,
                                                &pTDO->uSymbol.szSymbolString));
            }
            break;

        case siNoImage:
            break;

        default:
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
    }

    if (fNeedMouseImages)
    {
        IfFailGo(piTaskpad->get_MouseOverImage(&bstrURL));
        if (ValidBstr(bstrURL))
        {
            IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                              &pTDO->uBitmap.szMouseOverBitmap));
        }
        FREESTRING(bstrURL);

        IfFailGo(piTaskpad->get_MouseOffImage(&bstrURL));
        if (ValidBstr(bstrURL))
        {
            IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                              &pTDO->uBitmap.szMouseOffBitmap));
        }
    }

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrURL);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrSymbolString);
    RRETURN(hr);
}



STDMETHODIMP CView::GetListPadInfo
(
    LPOLESTR          pwszGroup,
    MMC_LISTPAD_INFO *pListPadInfo
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstr = NULL;
    VARIANT_BOOL    fvarListpadHasButton = VARIANT_FALSE;

    ::ZeroMemory(pListPadInfo, sizeof(*pListPadInfo));

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));

    // Get the listpad title

    IfFailGo(piTaskpad->get_ListpadTitle(&bstr));
    IfFailGo(::CoTaskMemAllocString(bstr, &pListPadInfo->szTitle));
    FREESTRING(bstr);

    // Check if the listpad has a button. If so then get the button text.

    IfFailGo(piTaskpad->get_ListpadHasButton(&fvarListpadHasButton));
    if (VARIANT_TRUE == fvarListpadHasButton)
    {
        IfFailGo(piTaskpad->get_ListpadButtonText(&bstr));
        IfFailGo(::CoTaskMemAllocString(bstr, &pListPadInfo->szButtonText));
    }
    else
    {
        pListPadInfo->szButtonText = NULL;
    }

    // Set the command ID to zero so it will not clash with any tasks. Tasks
    // will be added with command IDs matching their colleciton indexes which
    // begin at one.

    pListPadInfo->nCommandID = 0;

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                        IResultOwnerData Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::FindItem
(
    RESULTFINDINFO *pFindInfo,
    int            *pnFoundIndex
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    BSTR            bstrName = NULL;
    VARIANT_BOOL    fvarPartial = VARIANT_FALSE;
    VARIANT_BOOL    fvarWrap = VARIANT_FALSE;
    VARIANT_BOOL    fvarFound = VARIANT_FALSE;
    long            lIndex = 0;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    bstrName = ::SysAllocString(pFindInfo->psz);
    if (NULL == bstrName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (pFindInfo->dwOptions & RFI_PARTIAL) != 0 )
    {
        fvarPartial = VARIANT_TRUE;
    }

    if ( (pFindInfo->dwOptions & RFI_WRAP) != 0 )
    {
        fvarWrap = VARIANT_TRUE;
    }

    m_pSnapIn->GetResultViews()->FireFindItem(
                                       static_cast<IResultView *>(pResultView),
                                       bstrName,
                                       static_cast<long>(pFindInfo->nStart),
                                       fvarWrap,
                                       fvarPartial,
                                       &fvarFound,
                                       &lIndex);

    if ( (VARIANT_TRUE == fvarFound) && (0 != lIndex) )
    {
        // Item was found. Adjust the index from one-based to zero-based.
        hr = S_OK;
        *pnFoundIndex = static_cast<int>(lIndex - 1L);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}


STDMETHODIMP CView::CacheHint
(
    int nStartIndex,
    int nEndIndex
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);


    m_pSnapIn->GetResultViews()->FireCacheHint(
                                         static_cast<IResultView *>(pResultView),
                                         static_cast<long>(nStartIndex + 1),
                                         static_cast<long>(nEndIndex + 1));

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::SortItems
(
    int    nColumn,
    DWORD  dwSortOptions,
    LPARAM lUserParam
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    SnapInSortOrderConstants Order = siAscending;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if ( (dwSortOptions & RSI_DESCENDING) != 0 )
    {
        Order = siDescending;
    }

    m_pSnapIn->GetResultViews()->FireSortItems(
                                         static_cast<IResultView *>(pResultView),
                                         static_cast<long>(nColumn),
                                         Order);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                        IResultDataCompare Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CView::Compare
(
    LPARAM      lUserParam,
    MMC_COOKIE  cookieA,
    MMC_COOKIE  cookieB,
    int        *pnResult
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListItem   *pMMCListItem1 = reinterpret_cast<CMMCListItem *>(cookieA);
    CMMCListItem   *pMMCListItem2 = reinterpret_cast<CMMCListItem *>(cookieB);
    IDispatch      *pdispListItem1 = NULL;
    IDispatch      *pdispListItem2 = NULL;
    OLECHAR        *pwszText1 = NULL;
    OLECHAR        *pwszText2 = NULL;
    long            lColumn = static_cast<long>(*pnResult) + 1L;
    long            lResult = 0;

    VARIANT varResult;
    ::VariantInit(&varResult);

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pMMCListItem1->QueryInterface(IID_IDispatch,
                                  reinterpret_cast<void **>(&pdispListItem1)));

    IfFailGo(pMMCListItem2->QueryInterface(IID_IDispatch,
                                  reinterpret_cast<void **>(&pdispListItem2)));

    // Fire ResultViews_CompareItems
            
    m_pSnapIn->GetResultViews()->FireCompareItems(
                                      static_cast<IResultView *>(pResultView),
                                      pdispListItem1,
                                      pdispListItem2,
                                      lColumn,
                                      &varResult);

    if (::ConvertToLong(varResult, &lResult) == S_OK)
    {
        *pnResult = static_cast<int>(lResult);
    }
    else
    {
        // The snap-in did not handle the event. We need to do a
        // case-insensitive string comparison on the specified column.

        IfFailGo(pMMCListItem1->GetColumnTextPtr(lColumn, &pwszText1));

        IfFailGo(pMMCListItem2->GetColumnTextPtr(lColumn, &pwszText2));

        *pnResult = ::_wcsicmp(pwszText1, pwszText2);
    }

Error:
    QUICK_RELEASE(pdispListItem1);
    QUICK_RELEASE(pdispListItem2);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                       IResultDataCompareEx Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CView::Compare
(
    RDCOMPARE *prdc,
    int       *pnResult
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    long            lColumn = static_cast<long>(prdc->nColumn) + 1L;
    long            lResult = 0;

    CMMCListItem   *pMMCListItem1 = NULL;
    CMMCListItem   *pMMCListItem2 = NULL;

    CScopeItem     *pScopeItem1 = NULL;
    CScopeItem     *pScopeItem2 = NULL;

    IDispatch      *pdispItem1 = NULL;
    IDispatch      *pdispItem2 = NULL;

    OLECHAR        *pwszText1 = NULL;
    OLECHAR        *pwszText2 = NULL;

    VARIANT varResult;
    ::VariantInit(&varResult);

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get an IDispatch on each object being compared

    IfFailGo(GetCompareObject(prdc->prdch1, &pScopeItem1, &pMMCListItem1,
                              &pdispItem1));

    IfFailGo(GetCompareObject(prdc->prdch2, &pScopeItem2, &pMMCListItem2,
                              &pdispItem2));

    // Fire ResultViews_CompareItems

    m_pSnapIn->GetResultViews()->FireCompareItems(
                                      static_cast<IResultView *>(pResultView),
                                      pdispItem1,
                                      pdispItem2,
                                      lColumn,
                                      &varResult);

    // If the result can be converted to a long then the snap-in handled
    // the event.
    
    if (::ConvertToLong(varResult, &lResult) == S_OK)
    {
        *pnResult = static_cast<int>(lResult);
    }
    else
    {
        // The snap-in did not handle the event. We need to do a
        // case-insensitive string comparison on the specified column.

        if (NULL != pScopeItem1)
        {
            IfFailGo(GetScopeItemDisplayString(pScopeItem1,
                                               prdc->nColumn,
                                               &pwszText1));
        }
        else
        {
            IfFailGo(pMMCListItem1->GetColumnTextPtr(lColumn, &pwszText1));
        }

        if (NULL != pScopeItem2)
        {
            IfFailGo(GetScopeItemDisplayString(pScopeItem2,
                                               prdc->nColumn,
                                               &pwszText2));
        }
        else
        {
            IfFailGo(pMMCListItem2->GetColumnTextPtr(lColumn, &pwszText2));
        }

        *pnResult = ::_wcsicmp(pwszText1, pwszText2);
    }

Error:
    QUICK_RELEASE(pdispItem1);
    QUICK_RELEASE(pdispItem2);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                    IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CView::GetClassID(CLSID *pClsid)
{
    return E_NOTIMPL;
}


STDMETHODIMP CView::InitNew()
{
    return S_OK;
}

STDMETHODIMP CView::Load(IStream *piStream)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    IfFailGo(::PropertyBagFromStream(piStream, &p_PropertyBag));

    // Fire Views_ReadProperties

    m_pSnapIn->GetViews()->FireReadProperties(this, p_PropertyBag);

Error:
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}



STDMETHODIMP CView::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Create a property bag, fire the event, and save it to the stream.

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    EXCEPTION_CHECK_GO(hr);

    // Fire Views_WriteProperties

    m_pSnapIn->GetViews()->FireWriteProperties(this, p_PropertyBag);

    // Get the stream contents in a SafeArray of Byte

    IfFailGo(p_PropertyBag->get_Contents(&var));

    // Write the SafeArray contents to the stream

    IfFailGo(::WriteSafeArrayToStream(var.parray, piStream, WriteLength));

Error:
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::IsDirty                         [IPersistStream, IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      HRESULT
//
// Notes:
//
// The designer object model does not have any way for a snap-in to indicate
// that a view is dirty. This was an oversight discovered too late in the
// product cycle. There should have been a property View.Changed to control
// the return value from this function.
//
// To avoid a situation where a snap-in needs to save something we always return
// S_OK to indicate that the view is dirty and should be saved. The only
// problem this may cause is that when a console is opened in author mode and
// the user does not do anything that requires a save (e.g. selected a node
// in the scope pane) then they will be prompted to save unnecessarily.
//
STDMETHODIMP CView::IsDirty()
{
    return S_OK;
}


STDMETHODIMP CView::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    return E_NOTIMPL;
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IView == riid)
    {
        *ppvObjOut = static_cast<IView *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IComponent == riid)
    {
        *ppvObjOut = static_cast<IComponent *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendControlbar == riid)
    {
        *ppvObjOut = static_cast<IExtendControlbar *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendControlbarRemote == riid)
    {
        *ppvObjOut = static_cast<IExtendControlbarRemote *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendContextMenu == riid)
    {
        *ppvObjOut = static_cast<IExtendContextMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( (IID_IExtendPropertySheet  == riid) ||
              (IID_IExtendPropertySheet2 == riid) )
    {
        *ppvObjOut = static_cast<IExtendPropertySheet2 *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendPropertySheetRemote == riid)
    {
        *ppvObjOut = static_cast<IExtendPropertySheetRemote *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendTaskPad == riid)
    {
        *ppvObjOut = static_cast<IExtendTaskPad *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultOwnerData == riid)
    {
        *ppvObjOut = static_cast<IResultOwnerData *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultDataCompare == riid)
    {
        *ppvObjOut = static_cast<IResultDataCompare *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultDataCompareEx == riid)
    {
        *ppvObjOut = static_cast<IResultDataCompareEx *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPersistStream == riid)
    {
        *ppvObjOut = static_cast<IPersistStream *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPersistStreamInit == riid)
    {
        *ppvObjOut = static_cast<IPersistStreamInit *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CView::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piScopePaneItems));
    IfFailRet(SetObjectHost(static_cast<IContextMenu *>(m_pContextMenu)));
    IfFailRet(SetObjectHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdef.h ===
//=--------------------------------------------------------------------------=
// urlvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDef class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _URLVIEWDEF_DEFINED_
#define _URLVIEWDEF_DEFINED_


class CURLViewDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IURLViewDef
{
    private:
        CURLViewDef(IUnknown *punkOuter);
        ~CURLViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IURLViewDef

        BSTR_PROPERTY_RW(CURLViewDef,       Name,  DISPID_URLVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CURLViewDef,     Index, long, DISPID_URLVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CURLViewDef,       Key, DISPID_URLVIEWDEF_KEY);
        VARIANTREF_PROPERTY_RW(CURLViewDef, Tag, DISPID_URLVIEWDEF_TAG);
        SIMPLE_PROPERTY_RW(CURLViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_URLVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CURLViewDef,       ViewMenuText, DISPID_URLVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CURLViewDef,       ViewMenuStatusBarText, DISPID_URLVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(CURLViewDef,       URL, DISPID_URLVIEWDEF_URL);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[1];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(URLViewDef,           // name
                                &CLSID_URLViewDef,    // clsid
                                "URLViewDef",         // objname
                                "URLViewDef",         // lblname
                                &CURLViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,   // major version
                                TLIB_VERSION_MINOR,   // minor version
                                &IID_IURLViewDef,     // dispatch IID
                                NULL,                 // event IID
                                HELP_FILENAME,        // help file
                                TRUE);                // thread safe


#endif // _URLVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdefs.cpp ===
//=--------------------------------------------------------------------------=
// urlvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "urlvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CURLViewDefs::CURLViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>(
                                             punkOuter,
                                             OBJECT_TYPE_URLVIEWDEFS,
                                             static_cast<IURLViewDefs *>(this),
                                             static_cast<CURLViewDefs *>(this),
                                             CLSID_URLViewDef,
                                             OBJECT_TYPE_URLVIEWDEF,
                                             IID_IURLViewDef,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_URLViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CURLViewDefs::~CURLViewDefs()
{
}

IUnknown *CURLViewDefs::Create(IUnknown * punkOuter)
{
    CURLViewDefs *pURLViewDefs = New CURLViewDefs(punkOuter);
    if (NULL == pURLViewDefs)
    {
        return NULL;
    }
    else
    {
        return pURLViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDefs::Persist()
{
    HRESULT      hr = S_OK;
    IURLViewDef *piURLViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::Persist(piURLViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IURLViewDefs == riid)
    {
        *ppvObjOut = static_cast<IURLViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::GetMaster(IURLViewDefs **ppiMasterURLViewDefs)
{
    H_RRETURN(GetURLViewDefs(ppiMasterURLViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnap.h ===
//=--------------------------------------------------------------------------=
// xtdsnap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIn class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENDEDSNAPIN_DEFINED_
#define _EXTENDEDSNAPIN_DEFINED_


class CExtendedSnapIn : public CSnapInAutomationObject,
                        public CPersistence,
                        public IExtendedSnapIn
{
    private:
        CExtendedSnapIn(IUnknown *punkOuter);
        ~CExtendedSnapIn();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtendedSnapIn

        BSTR_PROPERTY_RW  (CExtendedSnapIn, Name,                               DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, Index,                long,         DISPID_EXTENDEDSNAPIN_INDEX);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, Key,                                DISPID_EXTENDEDSNAPIN_KEY);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, NodeTypeGUID,                       DISPID_EXTENDEDSNAPIN_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, NodeTypeName,                       DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, Dynamic,              VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_DYNAMIC);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsNameSpace,     VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsNewMenu,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsTaskMenu,      VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsPropertyPages, VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsToolbar,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsTaskpad,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtendedSnapIn,           // name
                                &CLSID_ExtendedSnapIn,    // clsid
                                "ExtendedSnapIn",         // objname
                                "ExtendedSnapIn",         // lblname
                                &CExtendedSnapIn::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IExtendedSnapIn,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _EXTENDEDSNAPIN_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtenson.h ===
//=--------------------------------------------------------------------------=
// xtenson.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class definition - implements Extension object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENSON_DEFINED_
#define _EXTENSON_DEFINED_

#include "snapin.h"

class CExtension : public CSnapInAutomationObject,
                   public IExtension
{
    private:
        CExtension(IUnknown *punkOuter);
        ~CExtension();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtension
        SIMPLE_PROPERTY_RW(CExtension, Index,               long,                           DISPID_EXTENSION_INDEX);
        BSTR_PROPERTY_RW(CExtension,   Key,                                                 DISPID_EXTENSION_KEY);
        BSTR_PROPERTY_RW(CExtension,   CLSID,                                               DISPID_EXTENSION_CLSID);
        BSTR_PROPERTY_RW(CExtension,   Name,                                                DISPID_EXTENSION_NAME);
        SIMPLE_PROPERTY_RW(CExtension, Type,                 SnapInExtensionTypeConstants,  DISPID_EXTENSION_EXTENDS_CONTEXT_MENU);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsContextMenu,   VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_CONTEXT_MENU);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsNameSpace,     VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_NAME_SPACE);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsToolbar,       VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsPropertySheet, VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_PROPERTY_SHEET);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsTaskpad,       VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_TASKPAD);
        SIMPLE_PROPERTY_RW(CExtension, Enabled,              VARIANT_BOOL,                  DISPID_EXTENSION_ENABLED);

        SIMPLE_PROPERTY_RO(CExtension, NameSpaceEnabled,     VARIANT_BOOL,                  DISPID_EXTENSION_NAMESPACE_ENABLED);
        STDMETHOD(put_NameSpaceEnabled)(VARIANT_BOOL fvarEnabled);
        
    // Public utility methods
    public:

        OLECHAR *GetCLSID() { return static_cast<OLECHAR *>(m_bstrCLSID); }
        BOOL Enabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL NameSpaceEnabled() { return VARIANTBOOL_TO_BOOL(m_NameSpaceEnabled); }
        BOOL ExtendsContextMenu() { return VARIANTBOOL_TO_BOOL(m_ExtendsContextMenu); }
        BOOL ExtendsToolbar() { return VARIANTBOOL_TO_BOOL(m_ExtendsToolbar); }
        BOOL ExtendsPropertySheet() { return VARIANTBOOL_TO_BOOL(m_ExtendsPropertySheet); }
        BOOL ExtendsTaskpad() { return VARIANTBOOL_TO_BOOL(m_ExtendsTaskpad); }
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetHSCOPEITEM(HSCOPEITEM hsi) { m_hsi = hsi; m_fHaveHsi = TRUE; }

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CSnapIn     *m_pSnapIn;  // Back ptr to snap-in
        BOOL         m_fHaveHsi; // TRUE=m_hsi has valid HSCOPEITEM
        HSCOPEITEM   m_hsi;      // HSCOPEITEM used when Extension belongs to
                                 // ScopeItem.DynamicExtensions so that
                                 // when VB enables it for namespace this object
                                 // can call IConsoleNameSpace2->AddExtension

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Extension,                  // name
                                &CLSID_Extension,           // clsid
                                "Extension",                // objname
                                "Extension",                // lblname
                                &CExtension::Create,        // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IExtension,            // dispatch IID
                                NULL,                       // no event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _EXTENSON_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnaps.cpp ===
//=--------------------------------------------------------------------------=
// xtdsnaps.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtdsnaps.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtendedSnapIns::CExtendedSnapIns(IUnknown *punkOuter) :
    CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>(
                                          punkOuter,
                                          OBJECT_TYPE_EXTENDEDSNAPINS,
                                          static_cast<IExtendedSnapIns *>(this),
                                          static_cast<CExtendedSnapIns *>(this),
                                          CLSID_ExtendedSnapIn,
                                          OBJECT_TYPE_EXTENDEDSNAPIN,
                                          IID_IExtendedSnapIn,
                                          static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtendedSnapIns,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtendedSnapIns::~CExtendedSnapIns()
{
}

IUnknown *CExtendedSnapIns::Create(IUnknown * punkOuter)
{
    CExtendedSnapIns *pExtendedSnapIns = New CExtendedSnapIns(punkOuter);
    if (NULL == pExtendedSnapIns)
    {
        return NULL;
    }
    else
    {
        return pExtendedSnapIns->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIns::Persist()
{
    HRESULT           hr = S_OK;
    IExtendedSnapIn  *piExtendedSnapIn = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>::Persist(piExtendedSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIns::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IExtendedSnapIns == riid)
    {
        *ppvObjOut = static_cast<IExtendedSnapIns *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtenson.cpp ===
//=--------------------------------------------------------------------------=
// xtenson.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CExtension::CExtension(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENSION,
                            static_cast<IExtension *>(this),
                            static_cast<CExtension *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence

{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtension::~CExtension()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrCLSID);
    FREESTRING(m_bstrName);
    InitMemberVariables();
}

void CExtension::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrCLSID = NULL;
    m_bstrName = NULL;
    m_Type = siStatic;
    m_ExtendsContextMenu = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_ExtendsPropertySheet = VARIANT_FALSE;
    m_ExtendsTaskpad = VARIANT_FALSE;
    m_Enabled = VARIANT_FALSE;
    m_NameSpaceEnabled = VARIANT_FALSE;
    m_pSnapIn = NULL;
    m_hsi = NULL;
    m_fHaveHsi = FALSE;
}

IUnknown *CExtension::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkExtension = NULL;

    CExtension *pExtension = New CExtension(punkOuter);

    IfFalseGo(NULL != pExtension, SID_E_OUTOFMEMORY);
    punkExtension = pExtension->PrivateUnknown();

Error:
    return punkExtension;
}


//=--------------------------------------------------------------------------=
//                         IExtension Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CExtension::put_NameSpaceEnabled(VARIANT_BOOL fvarEnabled)
{
    HRESULT      hr = S_OK;
    CLSID        clsid = CLSID_NULL;
    VARIANT_BOOL fvarCurrentValue = m_NameSpaceEnabled;

    m_NameSpaceEnabled = fvarEnabled;

    // If we have access to the snap-in, and we have an HSCOPITEM, and the
    // current value has gone from  disabled to enabled, then call
    // IConsoleNameSpace2::AddExtension()

    IfFalseGo(NULL != m_pSnapIn, S_OK);
    IfFalseGo(m_fHaveHsi, S_OK);
    IfFalseGo(VARIANT_FALSE == fvarCurrentValue, S_OK);
    IfFalseGo(VARIANT_TRUE == m_NameSpaceEnabled, S_OK);

    hr = ::CLSIDFromString(m_bstrCLSID, &clsid);
    EXCEPTION_CHECK_GO(hr);

    hr = m_pSnapIn->GetIConsoleNameSpace2()->AddExtension(m_hsi, &clsid);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtension::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtension == riid)
    {
        *ppvObjOut = static_cast<IExtension *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnap.cpp ===
//=--------------------------------------------------------------------------=
// xtdsnap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIn class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtdsnap.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtendedSnapIn::CExtendedSnapIn(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENDEDSNAPIN,
                            static_cast<IExtendedSnapIn *>(this),
                            static_cast<CExtendedSnapIn *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtendedSnapIn,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtendedSnapIn::~CExtendedSnapIn()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrNodeTypeName);
    InitMemberVariables();
}

void CExtendedSnapIn::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrNodeTypeName = NULL;
    m_Dynamic = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsNewMenu = VARIANT_FALSE;
    m_ExtendsTaskMenu = VARIANT_FALSE;
    m_ExtendsPropertyPages = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_ExtendsTaskpad = VARIANT_FALSE;
}

IUnknown *CExtendedSnapIn::Create(IUnknown * punkOuter)
{
    CExtendedSnapIn *pExtendedSnapIn = New CExtendedSnapIn(punkOuter);
    if (NULL == pExtendedSnapIn)
    {
        return NULL;
    }
    else
    {
        return pExtendedSnapIn->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIn::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrNodeTypeGUID, L"", OLESTR("CLSID")));

    IfFailRet(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("DisplayName")));

    IfFailRet(PersistSimpleType(&m_Dynamic, VARIANT_FALSE, OLESTR("Dynamic")));

    IfFailRet(PersistSimpleType(&m_ExtendsNameSpace, VARIANT_FALSE, OLESTR("ExtendsNameSpace")));

    IfFailRet(PersistSimpleType(&m_ExtendsNewMenu, VARIANT_FALSE, OLESTR("ExtendsNewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskMenu, VARIANT_FALSE, OLESTR("ExtendsTaskMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsPropertyPages, VARIANT_FALSE, OLESTR("ExtendsPropertyPages")));

    IfFailRet(PersistSimpleType(&m_ExtendsToolbar, VARIANT_FALSE, OLESTR("ExtendsToolbar")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskpad, VARIANT_FALSE, OLESTR("ExtendsTaskpad")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendedSnapIn == riid)
    {
        *ppvObjOut = static_cast<IExtendedSnapIn *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnaps.h ===
//=--------------------------------------------------------------------------=
// xtdsnaps.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENDEDSNAPINS_DEFINED_
#define _EXTENDEDSNAPINS_DEFINED_

#include "collect.h"

class CExtendedSnapIns : public CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>,
                         public CPersistence
{
    protected:
        CExtendedSnapIns(IUnknown *punkOuter);
        ~CExtendedSnapIns();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtendedSnapIns,           // name
                                &CLSID_ExtendedSnapIns,    // clsid
                                "ExtendedSnapIns",         // objname
                                "ExtendedSnapIns",         // lblname
                                &CExtendedSnapIns::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IExtendedSnapIns,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _EXTENDEDSNAPINS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\views.cpp ===
//=--------------------------------------------------------------------------=
// views.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "views.h"
#include "scopitem.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CViews::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiInitialize =
{
    DISPID_VIEWS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CViews::m_rgvtLoad[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiLoad =
{
    DISPID_VIEWS_EVENT_LOAD,
    sizeof(m_rgvtLoad) / sizeof(m_rgvtLoad[0]),
    m_rgvtLoad
};

VARTYPE CViews::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiTerminate =
{
    DISPID_VIEWS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};


VARTYPE CViews::m_rgvtActivate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiActivate =
{
    DISPID_VIEWS_EVENT_ACTIVATE,
    sizeof(m_rgvtActivate) / sizeof(m_rgvtActivate[0]),
    m_rgvtActivate
};

VARTYPE CViews::m_rgvtDeactivate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiDeactivate =
{
    DISPID_VIEWS_EVENT_DEACTIVATE,
    sizeof(m_rgvtDeactivate) / sizeof(m_rgvtDeactivate[0]),
    m_rgvtDeactivate
};


VARTYPE CViews::m_rgvtMinimize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiMinimize =
{
    DISPID_VIEWS_EVENT_MINIMIZE,
    sizeof(m_rgvtMinimize) / sizeof(m_rgvtMinimize[0]),
    m_rgvtMinimize
};

VARTYPE CViews::m_rgvtMaximize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiMaximize =
{
    DISPID_VIEWS_EVENT_MAXIMIZE,
    sizeof(m_rgvtMaximize) / sizeof(m_rgvtMaximize[0]),
    m_rgvtMaximize
};


VARTYPE CViews::m_rgvtSetControlbar[2] = { VT_UNKNOWN, VT_UNKNOWN };

EVENTINFO CViews::m_eiSetControlbar =
{
    DISPID_VIEWS_EVENT_SET_CONTROL_BAR,
    sizeof(m_rgvtSetControlbar) / sizeof(m_rgvtSetControlbar[0]),
    m_rgvtSetControlbar
};


VARTYPE CViews::m_rgvtUpdateControlbar[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiUpdateControlbar =
{
    DISPID_VIEWS_EVENT_UPDATE_CONTROLBAR,
    sizeof(m_rgvtUpdateControlbar) / sizeof(m_rgvtUpdateControlbar[0]),
    m_rgvtUpdateControlbar
};


VARTYPE CViews::m_rgvtSelect[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiSelect =
{
    DISPID_VIEWS_EVENT_SELECT,
    sizeof(m_rgvtSelect) / sizeof(m_rgvtSelect[0]),
    m_rgvtSelect
};


VARTYPE CViews::m_rgvtAddTopMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddTopMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_TOP_MENU_ITEMS,
    sizeof(m_rgvtAddTopMenuItems) / sizeof(m_rgvtAddTopMenuItems[0]),
    m_rgvtAddTopMenuItems
};


VARTYPE CViews::m_rgvtAddNewMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddNewMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_NEW_MENU_ITEMS,
    sizeof(m_rgvtAddNewMenuItems) / sizeof(m_rgvtAddNewMenuItems[0]),
    m_rgvtAddNewMenuItems
};


VARTYPE CViews::m_rgvtAddTaskMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddTaskMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_TASK_MENU_ITEMS,
    sizeof(m_rgvtAddTaskMenuItems) / sizeof(m_rgvtAddTaskMenuItems[0]),
    m_rgvtAddTaskMenuItems
};

VARTYPE CViews::m_rgvtAddViewMenuItems[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddViewMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_VIEW_MENU_ITEMS,
    sizeof(m_rgvtAddViewMenuItems) / sizeof(m_rgvtAddViewMenuItems[0]),
    m_rgvtAddViewMenuItems
};


VARTYPE CViews::m_rgvtGetMultiSelectData[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiGetMultiSelectData =
{
    DISPID_VIEWS_EVENT_GET_MULTISELECT_DATA,
    sizeof(m_rgvtGetMultiSelectData) / sizeof(m_rgvtGetMultiSelectData[0]),
    m_rgvtGetMultiSelectData
};



VARTYPE CViews::m_rgvtQueryPaste[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiQueryPaste =
{
    DISPID_VIEWS_EVENT_QUERY_PASTE,
    sizeof(m_rgvtQueryPaste) / sizeof(m_rgvtQueryPaste[0]),
    m_rgvtQueryPaste
};

VARTYPE CViews::m_rgvtPaste[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL
};

EVENTINFO CViews::m_eiPaste =
{
    DISPID_VIEWS_EVENT_PASTE,
    sizeof(m_rgvtPaste) / sizeof(m_rgvtPaste[0]),
    m_rgvtPaste
};


VARTYPE CViews::m_rgvtCut[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiCut =
{
    DISPID_VIEWS_EVENT_CUT,
    sizeof(m_rgvtCut) / sizeof(m_rgvtCut[0]),
    m_rgvtCut
};


VARTYPE CViews::m_rgvtDelete[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiDelete =
{
    DISPID_VIEWS_EVENT_DELETE,
    sizeof(m_rgvtDelete) / sizeof(m_rgvtDelete[0]),
    m_rgvtDelete
};


VARTYPE CViews::m_rgvtQueryPagesFor[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CViews::m_eiQueryPagesFor =
{
    DISPID_VIEWS_EVENT_QUERY_PAGES_FOR,
    sizeof(m_rgvtQueryPagesFor) / sizeof(m_rgvtQueryPagesFor[0]),
    m_rgvtQueryPagesFor
};


VARTYPE CViews::m_rgvtCreatePropertyPages[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiCreatePropertyPages =
{
    DISPID_VIEWS_EVENT_CREATE_PROPERTY_PAGES,
    sizeof(m_rgvtCreatePropertyPages) / sizeof(m_rgvtCreatePropertyPages[0]),
    m_rgvtCreatePropertyPages
};


VARTYPE CViews::m_rgvtRefresh[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiRefresh =
{
    DISPID_VIEWS_EVENT_REFRESH,
    sizeof(m_rgvtRefresh) / sizeof(m_rgvtRefresh[0]),
    m_rgvtRefresh
};



VARTYPE CViews::m_rgvtPrint[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiPrint =
{
    DISPID_VIEWS_EVENT_PRINT,
    sizeof(m_rgvtPrint) / sizeof(m_rgvtPrint[0]),
    m_rgvtPrint
};


VARTYPE CViews::m_rgvtSpecialPropertiesClick[2] =
{
    VT_UNKNOWN,
    VT_I4
};

EVENTINFO CViews::m_eiSpecialPropertiesClick =
{
    DISPID_VIEWS_EVENT_SPECIAL_PROPERTIES_CLICK,
    sizeof(m_rgvtSpecialPropertiesClick) / sizeof(m_rgvtSpecialPropertiesClick[0]),
    m_rgvtSpecialPropertiesClick
};


VARTYPE CViews::m_rgvtWriteProperties[2] =
{
    VT_UNKNOWN,
    VT_DISPATCH
};

EVENTINFO CViews::m_eiWriteProperties =
{
    DISPID_VIEWS_EVENT_WRITE_PROPERTIES,
    sizeof(m_rgvtWriteProperties) / sizeof(m_rgvtWriteProperties[0]),
    m_rgvtWriteProperties
};


VARTYPE CViews::m_rgvtReadProperties[2] =
{
    VT_UNKNOWN,
    VT_DISPATCH
};

EVENTINFO CViews::m_eiReadProperties =
{
    DISPID_VIEWS_EVENT_READ_PROPERTIES,
    sizeof(m_rgvtReadProperties) / sizeof(m_rgvtReadProperties[0]),
    m_rgvtReadProperties
};



   
#pragma warning(disable:4355)  // using 'this' in constructor

CViews::CViews(IUnknown *punkOuter) :
    CSnapInCollection<IView, View, IViews>(punkOuter,
                                           OBJECT_TYPE_VIEWS,
                                           static_cast<IViews *>(this),
                                           static_cast<CViews *>(this),
                                           CLSID_View,
                                           OBJECT_TYPE_VIEW,
                                           IID_IView,
                                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CViews::~CViews()
{
    RELEASE(m_piCurrentView);
    FREESTRING(m_bstrNextViewCaption);
    InitMemberVariables();
}


void CViews::InitMemberVariables()
{
    m_piCurrentView = NULL;
    m_bstrNextViewCaption = NULL;
}



IUnknown *CViews::Create(IUnknown * punkOuter)
{
    CViews *pViews = New CViews(punkOuter);
    if (NULL == pViews)
    {
        return NULL;
    }
    else
    {
        return pViews->PrivateUnknown();
    }
}


void CViews::SetCurrentView(IView *piView)
{
    RELEASE(m_piCurrentView);
    if (NULL != piView)
    {
        piView->AddRef();
    }
    m_piCurrentView = piView;
}

HRESULT CViews::SetNextViewCaption(BSTR bstrCaption)
{
    HRESULT hr = S_OK;

    FREESTRING(m_bstrNextViewCaption);
    if (NULL != bstrCaption)
    {
        m_bstrNextViewCaption = ::SysAllocString(bstrCaption);
        if (NULL == m_bstrNextViewCaption)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


void CViews::FireInitialize(IView *piView)
{
    DebugPrintf("Firing Views_Initialize\r\n");

    FireEvent(&m_eiInitialize, piView);
}

void CViews::FireLoad(IView *piView)
{
    DebugPrintf("Firing Views_Load\r\n");

    FireEvent(&m_eiLoad, piView);
}

void CViews::FireTerminate(IView *piView)
{
    DebugPrintf("Firing Views_Terminate\r\n");

    FireEvent(&m_eiTerminate, piView);
}


void CViews::FireActivate(IView *piView)
{
    DebugPrintf("Firing Views_Activate\r\n");

    FireEvent(&m_eiActivate, piView);
}

void CViews::FireDeactivate(IView *piView)
{
    DebugPrintf("Firing Views_Deactivate\r\n");

    FireEvent(&m_eiDeactivate, piView);
}

void CViews::FireMinimize(IView *piView)
{
    DebugPrintf("Firing Views_Minimize\r\n");

    FireEvent(&m_eiMinimize, piView);
}

void CViews::FireMaximize(IView *piView)
{
    DebugPrintf("Firing Views_Maximize\r\n");

    FireEvent(&m_eiMaximize, piView);
}

void CViews::FireSetControlbar(IView *piView, IMMCControlbar *piMMCControlbar)
{
    DebugPrintf("Firing Views_SetControlbar\r\n");

    FireEvent(&m_eiSetControlbar, piView, piMMCControlbar);
}


void CViews::FireSelect
(
    IView            *piView,
    IMMCClipboard    *piSelection,
    VARIANT_BOOL      fvarSelected,
    IMMCConsoleVerbs *piMMCConsoleVerbs
)
{
    DebugPrintf("Firing Views_Select(%s)\r\n", (VARIANT_TRUE == fvarSelected) ? "selected" : "deselected");

    FireEvent(&m_eiSelect, piView, piSelection, fvarSelected, piMMCConsoleVerbs);
}


void CViews::FireAddTopMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddTopMenuItems()\r\n");

    FireEvent(&m_eiAddTopMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddNewMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddNewMenuItems()\r\n");

    FireEvent(&m_eiAddNewMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddTaskMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddTaskMenuItems()\r\n");

    FireEvent(&m_eiAddTaskMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddViewMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed,
    VARIANT_BOOL  *pfvarAddPredefinedViews)
{
    DebugPrintf("Firing Views_AddViewMenuItems()\r\n");

    FireEvent(&m_eiAddViewMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed, pfvarAddPredefinedViews);
}


void CViews::FireUpdateControlbar
(
    IView          *piView,
    IMMCClipboard  *piMMClipboard,
    VARIANT_BOOL    fvarSelected,
    IMMCControlbar *piMMCControlbar
)
{
    DebugPrintf("Firing Views_UpdateControlbar(%s)\r\n", (VARIANT_TRUE == fvarSelected) ? "selected" : "deselected");

    FireEvent(&m_eiUpdateControlbar, piView, piMMClipboard,
              fvarSelected, piMMCControlbar);
}



void CViews::FireGetMultiSelectData
(
    IView          *piView,
    IMMCClipboard  *piSelection,
    IMMCDataObject *piMMCDataObject
)
{
    DebugPrintf("Firing Views_GetMultiSelectData\r\n");

    FireEvent(&m_eiGetMultiSelectData, piView, piSelection, piMMCDataObject);
}


void CViews::FireQueryPaste
(
    IView         *piView,
    IMMCClipboard *piSourceItems,
    IScopeItem    *piScopeItemDest,
    VARIANT_BOOL  *pfvarOKToPaste
)
{
    DebugPrintf("Firing Views_QueryPaste()\r\n");

    FireEvent(&m_eiQueryPaste, piView, piSourceItems,
              piScopeItemDest, pfvarOKToPaste);
}


void CViews::FirePaste
(
    IView          *piView,
    IMMCClipboard  *piSourceItems,
    IScopeItem     *piScopeItemDest,
    IMMCDataObject *piMMCDataObjectRetToSource,
    VARIANT_BOOL    fvarMove
)
{
    DebugPrintf("Firing Views_Paste()\r\n");

    FireEvent(&m_eiPaste, piView, piSourceItems,
              piScopeItemDest, piMMCDataObjectRetToSource, fvarMove);
}


void CViews::FireCut
(
    IView          *piView,
    IMMCClipboard  *piItemsPasted,
    IMMCDataObject *piMMCDataObjectFromTarget
)
{
    DebugPrintf("Firing Views_Cut\r\n");

    FireEvent(&m_eiCut, piView, piItemsPasted, piMMCDataObjectFromTarget);
}

void CViews::FireDelete
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Delete\r\n");

    FireEvent(&m_eiDelete, piView, piSelection);
}


void CViews::FireQueryPagesFor
(
    IView         *piView,
    IMMCClipboard *piSelection,
    VARIANT_BOOL  *pfvarHavePages
)
{
    DebugPrintf("Firing Views_QueryPagesFor\r\n");

    FireEvent(&m_eiQueryPagesFor, piView, piSelection, pfvarHavePages);
}


void CViews::FireCreatePropertyPages
(
    IView             *piView,
    IMMCClipboard     *piSelection,
    IMMCPropertySheet *piMMCPropertySheet
)
{
    DebugPrintf("Firing Views_CreatePropertyPages\r\n");

    FireEvent(&m_eiCreatePropertyPages, piView, piSelection, piMMCPropertySheet);
}


void CViews::FireRefresh
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Refresh\r\n");

    FireEvent(&m_eiRefresh, piView, piSelection);
}



void CViews::FirePrint
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Print\r\n");

    FireEvent(&m_eiPrint, piView, piSelection);
}



void CViews::FireSpecialPropertiesClick
(
     IView                        *piView,
     SnapInSelectionTypeConstants  ResultViewType
)
{
    DebugPrintf("Firing Views_SpecialPropertiesClick\r\n");

    FireEvent(&m_eiSpecialPropertiesClick, piView, ResultViewType);
}


void CViews::FireWriteProperties
(
    IView        *piView,
    _PropertyBag *p_PropertyBag
)
{
    DebugPrintf("Firing Views_WriteProperties\r\n");

    FireEvent(&m_eiWriteProperties, piView, p_PropertyBag);
}


void CViews::FireReadProperties
(
    IView        *piView,
    _PropertyBag *p_PropertyBag
)
{
    DebugPrintf("Firing Views_ReadProperties\r\n");

    FireEvent(&m_eiReadProperties, piView, p_PropertyBag);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViews::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IViews == riid)
    {
        *ppvObjOut = static_cast<IViews *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IView, View, IViews>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\views.h ===
//=--------------------------------------------------------------------------=
// views.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViews class definition - implements Views collection
//
//=--------------------------------------------------------------------------=

#ifndef _VIEWS_DEFINED_
#define _VIEWS_DEFINED_

#include "collect.h"

class CViews : public CSnapInCollection<IView, View, IViews>
{
    protected:
        CViews(IUnknown *punkOuter);
        ~CViews();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IViews
        COCLASS_PROPERTY_RO(CViews, CurrentView, View, IView, DISPID_VIEWS_CURRENT_VIEW);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:
        void SetCurrentView(IView *piView);

        HRESULT SetNextViewCaption(BSTR bstrCaption);
        BSTR GetNextViewCaptionPtr() { return m_bstrNextViewCaption; }

        void FireInitialize(IView *piView);
        void FireLoad(IView *piView);
        void FireTerminate(IView *piView);
        void FireActivate(IView *piView);
        void FireDeactivate(IView *piView);
        void FireMinimize(IView *piView);
        void FireMaximize(IView *piView);
        void FireSetControlbar(IView *piView, IMMCControlbar *piMMCControlbar);
        void FireUpdateControlbar(IView          *piView,
                                  IMMCClipboard  *piMMClipboard,
                                  VARIANT_BOOL    fvarSelected,
                                  IMMCControlbar *piMMCControlbar);
        void FireSelect(IView            *piView,
                        IMMCClipboard    *piSelection,
                        VARIANT_BOOL      fVarSelected,
                        IMMCConsoleVerbs *piMMCConsoleVerbs);
        void FireAddTopMenuItems(IView         *piView,
                                 IMMCClipboard *piSelection,
                                 IContextMenu  *piContextMenu,
                                 VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddNewMenuItems(IView         *piView,
                                 IMMCClipboard *piSelection,
                                 IContextMenu  *piContextMenu,
                                 VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddTaskMenuItems(IView         *piView,
                                  IMMCClipboard *piSelection,
                                  IContextMenu  *piContextMenu,
                                  VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddViewMenuItems(IView         *piView,
                                  IMMCClipboard *piSelection,
                                  IContextMenu  *piContextMenu,
                                  VARIANT_BOOL  *pfvarInsertionAllowed,
                                  VARIANT_BOOL  *pfvarAddPredefinedViews);
        void FireGetMultiSelectData(IView          *piView,
                                    IMMCClipboard  *piSelection,
                                    IMMCDataObject *piMMCDataObject);
        void FireQueryPaste(IView         *piView,
                            IMMCClipboard *piSourceItems,
                            IScopeItem    *piScopeItemDest,
                            VARIANT_BOOL  *pfvarOKToPaste);
        void FirePaste(IView          *piView,
                       IMMCClipboard  *piSourceItems,
                       IScopeItem     *piScopeItemDest,
                       IMMCDataObject *piMMCDataObjectRetToSource,
                       VARIANT_BOOL    fvarMove);
        void FireCut(IView          *piView,
                     IMMCClipboard  *piItemsPasted,
                     IMMCDataObject *piMMCDataObjectFromTarget);
        void FireDelete(IView *piView, IMMCClipboard *piSelection);
        void FireQueryPagesFor(IView         *piView,
                               IMMCClipboard *piSelection,
                               VARIANT_BOOL  *pfvarHavePages);

        void FireCreatePropertyPages(IView             *piView,
                                     IMMCClipboard     *piSelection,
                                     IMMCPropertySheet *piMMCPropertySheet);
        void FireRefresh(IView *piView, IMMCClipboard *piSelection);
        void FirePrint(IView *piView, IMMCClipboard *piSelection);
        void FireSpecialPropertiesClick(IView                        *piView,
                                        SnapInSelectionTypeConstants  ResultViewType);

        void FireWriteProperties(IView *piView, _PropertyBag *p_PropertyBag);
        void FireReadProperties(IView *piView, _PropertyBag *p_PropertyBag);

    private:

        void InitMemberVariables();

        // When the snap calls View.NewWindow and specifies siCaption, then
        // the caption is stored here. When the new view is created, it can
        // respond to CCF_WINDOW_TITLE requests from this string.

        BSTR m_bstrNextViewCaption;

        // Event Parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtLoad[1];
        static EVENTINFO m_eiLoad;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtActivate[1];
        static EVENTINFO m_eiActivate;

        static VARTYPE   m_rgvtDeactivate[1];
        static EVENTINFO m_eiDeactivate;

        static VARTYPE   m_rgvtMinimize[1];
        static EVENTINFO m_eiMinimize;

        static VARTYPE   m_rgvtMaximize[1];
        static EVENTINFO m_eiMaximize;

        static VARTYPE   m_rgvtSetControlbar[2];
        static EVENTINFO m_eiSetControlbar;

        static VARTYPE   m_rgvtUpdateControlbar[4];
        static EVENTINFO m_eiUpdateControlbar;

        static VARTYPE   m_rgvtSelect[4];
        static EVENTINFO m_eiSelect;

        static VARTYPE   m_rgvtAddTopMenuItems[4];
        static EVENTINFO m_eiAddTopMenuItems;

        static VARTYPE   m_rgvtAddNewMenuItems[4];
        static EVENTINFO m_eiAddNewMenuItems;

        static VARTYPE   m_rgvtAddTaskMenuItems[4];
        static EVENTINFO m_eiAddTaskMenuItems;

        static VARTYPE   m_rgvtAddViewMenuItems[5];
        static EVENTINFO m_eiAddViewMenuItems;

        static VARTYPE   m_rgvtGetMultiSelectData[3];
        static EVENTINFO m_eiGetMultiSelectData;

        static VARTYPE   m_rgvtQueryPaste[4];
        static EVENTINFO m_eiQueryPaste;

        static VARTYPE   m_rgvtPaste[5];
        static EVENTINFO m_eiPaste;

        static VARTYPE   m_rgvtCut[3];
        static EVENTINFO m_eiCut;

        static VARTYPE   m_rgvtDelete[2];
        static EVENTINFO m_eiDelete;

        static VARTYPE   m_rgvtQueryPagesFor[3];
        static EVENTINFO m_eiQueryPagesFor;

        static VARTYPE   m_rgvtCreatePropertyPages[3];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtRefresh[2];
        static EVENTINFO m_eiRefresh;

        static VARTYPE   m_rgvtPrint[2];
        static EVENTINFO m_eiPrint;

        static VARTYPE   m_rgvtSpecialPropertiesClick[2];
        static EVENTINFO m_eiSpecialPropertiesClick;

        static VARTYPE   m_rgvtWriteProperties[2];
        static EVENTINFO m_eiWriteProperties;

        static VARTYPE   m_rgvtReadProperties[2];
        static EVENTINFO m_eiReadProperties;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Views,                     // name
                                NULL,                      // clsid
                                "Views",                   // objname
                                "Views",                   // lblname
                                NULL,                      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IViews,               // dispatch IID
                                &DIID_DViewsEvents,        // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _VIEWS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\vblic\timebomb.h ===
//--------------------------------------------------------------------------
//   TimeBomb.H
//--------------------------------------------------------------------------

#ifndef _TIMEBOMB_H_

#include "IPServer.H"
#include "winbase.h"

#define SZEXPIRED1 "Sorry, this control has expired. Please obtain a newer version"
#define SZEXPIRED2 "Expired"

//prototypes
BOOL CheckExpired (void);
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2);

#define _TIMEBOMB_H_
#endif // _TIMEBOMB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\vblic\vblic.h ===
//=--------------------------------------------------------------------------=
// VBLIC.H
//=--------------------------------------------------------------------------=
// Header file for licensing support
//
#ifndef _VBLIC_H_
#define _VBLIC_H_

// VB (Standard and Professional) Licensing
#define MSCONTROLS MSCONTROLS
#define LICENSE_KEY_RESOURCE 2

BOOL VBValidateControlsLicense(char *pszLicenseKey);
BOOL CompareLicenseStringsW(LPWSTR pwszKey1, LPWSTR pwszKey2);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\vblic\timebomb.cpp ===
//--------------------------------------------------------------------------
//   TimeBomb.CPP
//--------------------------------------------------------------------------

//#include "time.h"
#include "timebomb.h"
#include "winbase.h"
#include "IPServer.H"

// prototypes
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2);

// Change this to the desired expiration date
// format {year, month, dayofweek, day, hour, minute, second, milliseconds}
const SYSTEMTIME beta_death = {1998, 3, 0, 1, 0, 0, 0, 0}; // 1 Mar 1998

//-------------------------------------------------------------------
// CheckExpired  - checks whether to the control has expired (beta)
//-------------------------------------------------------------------
BOOL CheckExpired (void)

{
#ifdef BETA_BOMB

  SYSTEMTIME now;  

  GetSystemTime(&now);

  if (After (now, beta_death))
      { // alert user of expiration
	MessageBox(NULL, SZEXPIRED1, SZEXPIRED2,
		   (MB_OK | MB_TASKMODAL));
	return FALSE;
      }

#endif  //BETA_BOMB

  return TRUE;
}

//-------------------------------------------------------------------
// After  - determines whether t1 is later than t2
//-------------------------------------------------------------------
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2)

{
  // compare Years
  if (t1.wYear > t2.wYear) return TRUE;
  if (t1.wYear < t2.wYear) return FALSE;
  // else Years are equal; compare Months
  if (t1.wMonth > t2.wMonth) return TRUE;
  if (t1.wMonth < t2.wMonth) return FALSE;
  // else Months are equal; compare Days
  if (t1.wDay > t2.wDay) return TRUE;
  if (t1.wDay < t2.wDay) return FALSE;
  // else Days are equal; compare Hours
  if (t1.wHour > t2.wHour) return TRUE;
  if (t1.wHour < t2.wHour) return FALSE;
  // else Hours are equal; compare Minutes
  if (t1.wMinute > t2.wMinute) return TRUE;
  if (t1.wMinute < t2.wMinute) return FALSE;
  // else Minutes are equal; compare Seconds
  if (t1.wSecond > t2.wSecond) return TRUE;
  if (t1.wSecond < t2.wSecond) return FALSE;
  // else Seconds are equal; compare Milliseconds
  if (t1.wMilliseconds > t2.wMilliseconds) return TRUE;
  // else Milliseconds are equal or less
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtensons.h ===
//=--------------------------------------------------------------------------=
// xtensons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensions class definition - implements Extensions collection
//
//=--------------------------------------------------------------------------=

#ifndef _XTENSONS_DEFINED_
#define _XTENSONS_DEFINED_

#include "collect.h"

class CExtensions : public CSnapInCollection<IExtension, Extension, IExtensions>
{
    protected:
        CExtensions(IUnknown *punkOuter);
        ~CExtensions();

    public:
        static IUnknown *Create(IUnknown * punk);

        enum ExtensionSubset { All, Dynamic };
        
        HRESULT Populate(BSTR bstrNodeTypeGUID, ExtensionSubset Subset);
        HRESULT SetSnapIn(CSnapIn *pSnapIn);
        HRESULT SetHSCOPEITEM(HSCOPEITEM hsi);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtensions
        STDMETHOD(EnableAll)(VARIANT_BOOL Enabled);
        STDMETHOD(EnableAllStatic)(VARIANT_BOOL Enabled);
        

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        enum ExtensionFeatures { NameSpace, ContextMenu, Toolbar,
                                 PropertySheet, Task };

        HRESULT AddExtensions(ExtensionFeatures   Feature,
                              char               *pszExtensionTypeKey,
                              size_t              cbExtensionTypeKey,
                              BSTR                bstrNodeTypeGUID,
                              ExtensionSubset     Subset,
                              HKEY                hkeyDynExt);

        HRESULT AddExtension(ExtensionFeatures   Feature,
                             char               *pszCLSID,
                             char               *pszName,
                             ExtensionSubset     Subset,
                             HKEY                hkeyDynExt);

        HRESULT UpdateExtensionFeatures(IExtension        *piExtension,
                                        ExtensionFeatures  Feature);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Extensions,              // name
                                &CLSID_Extensions,       // clsid
                                "Extensions",            // objname
                                "Extensions",            // lblname
                                &CExtensions::Create,    // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IExtensions,        // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _XTENSONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\vblic\vblic.cpp ===
#include <windows.h>
#include "vblic.h"

#ifdef BETA_BOMB
#include "timebomb.h"
#endif //BETA_BOMB

// NOTE: The following strings must match exactly the content of the registry as specified in
// vbprolic.reg.
#define LICENSES_KEY "Licenses"

void CalcValue(char * pszLicenseKey, char * pszKeyValue, LPTSTR pszTempBuff);
BOOL ValidateValue(HKEY hLicenseSubKey, char*  pszLicenseKey, char* pKeyValue);

#define MAX_KEY_LENGTH 200

//=-------------------------------------------------------------------------=
// CompareLicenseStringsW [Helper for comparing license keys]
//=-------------------------------------------------------------------------=
// Compares two null terminated wide strings and returns TRUE if the strings
// are equal.
//
BOOL CompareLicenseStringsW(LPWSTR pwszKey1, LPWSTR pwszKey2)
{
	int i = 0;
	
#ifdef BETA_BOMB
	// Check for expired control (BETA)
	if (!CheckExpired()) return FALSE;
#endif //BETA_BOMB

	// Check to see if the pointers are equal
	//
	if (pwszKey1 == pwszKey2)
		return TRUE;

	// Since pointer comparison failed, if either pointer is NULL, bail out
	//
	if (!pwszKey1 || !pwszKey2)
		return FALSE;
	
	// Compare each character.  Jump out when a character is not equal or the end of
	// either string is reached.
	//
	while (pwszKey1[i] && pwszKey2[i])
	{
		if (pwszKey1[i] != pwszKey2[i])
			break;
		i++;
	}

        return (pwszKey1[i] == pwszKey2[i]);
}

/////////////////////////////////////////////////////////////////////////////////
// VBValidateControlsLicense - This routine validates that the proper lincesing
// 	keys have been placed in the registery.  The list of potential keys are 
//	gathered from the resource file in the LICENSE_KEY_RESOURCE resource.
/////////////////////////////////////////////////////////////////////////////////

BOOL VBValidateControlsLicense(char *pszLicenseKey)
{
	HKEY hPrimaryLicenseKey, hLicenseSubKey;	
	LONG lSize = MAX_KEY_LENGTH;
	BOOL bFoundKey = FALSE;
	char szKeyValue[MAX_KEY_LENGTH];

#ifdef BETA_BOMB
	// Check for expired control (BETA)
	if (!CheckExpired()) return FALSE;
#endif //BETA_BOMB
	
	// Continue only if we were passed a non-NULL license string
	// We return FALSE, if the string is NULL
	//
	if (pszLicenseKey)
	{
		DWORD dwFoundKey = RegOpenKey(HKEY_CLASSES_ROOT, LICENSES_KEY, &hPrimaryLicenseKey);
		if (dwFoundKey == ERROR_SUCCESS)
		{
			// Now, loop through all the keys in the resource file trying to find
			// a match in the registry.
			if (!bFoundKey && *pszLicenseKey)
			{
				if (RegOpenKey(hPrimaryLicenseKey, pszLicenseKey, &hLicenseSubKey) == ERROR_SUCCESS)
				{
					if (ValidateValue(hLicenseSubKey, pszLicenseKey, szKeyValue))
						bFoundKey = TRUE;
					
					RegCloseKey(hLicenseSubKey);
				}
			}	// END if(...)

	 		RegCloseKey(hPrimaryLicenseKey);
		}	// END successfull RegOpenKey(HKEY_CLASSES_ROOT...)
	}
	

	return bFoundKey;
}

/////////////////////////////////////////////////////////////////////////////////
// ValidateValue - 	Calls CalcValue to get the corresponding value for a 
//					key and compares it to the value in the registry.
/////////////////////////////////////////////////////////////////////////////////
BOOL ValidateValue(HKEY hLicenseSubKey, char * pszLicenseKey, char * pszResultValue)
{
	BOOL bValidValue;
	TCHAR szTempBuff[MAX_KEY_LENGTH];
	
	// Reject a key that is too short.  (Short keys could lead to easier decoding.)
	long lSize = lstrlen(pszLicenseKey) + 1;
	if (lSize < 9)
		return FALSE;
	
	// Calculate the expected value from the key.	
	CalcValue(pszLicenseKey, pszResultValue, szTempBuff);
	
	// Now, get the value from the registry and compare.
	if (RegQueryValue(hLicenseSubKey, NULL, szTempBuff, &lSize) == ERROR_SUCCESS)
	{
		if (!lstrcmp(szTempBuff, pszResultValue))
			bValidValue = TRUE;
		else
			bValidValue = FALSE;
	}
	return bValidValue;
}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
// THIS SOURCE IS REPLICATED IN THE "DECODE.EXE" OR LICGEN SOURCE.  (THIS PROGRAM WILL
// GENERATE VALUES FROM KEYS.) ANY CHANGES TO EITHER SOURCE MUST BE REPLICATED
// IN THE OTHER.  DO NOT CHANGE THIS SOURCE OR YOU RISK BREAKING CONTROLS UNDER 
// VB4.
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CalcValue - This routine checks the value of the key with the key to
//	ensure it is a valid value.
// The plan:	First, XOR the string with itself in reverse.
//				Convert the result to ascii by adding each nibble to
//				'a' + (checksum of the key result mod 26).
/////////////////////////////////////////////////////////////////////////////////
void CalcValue(char * pszLicenseKey, char * pszResultKey, LPTSTR pszTempResult)
{
	BOOL bValid = FALSE;
	TCHAR *pKey, *pEndKey, *pEndResult, *pResult;
	unsigned int nCheckSum = 0;
	
	// Make a reverse copy of the key.
	
	// Find the end of the string
	for (pKey = pszLicenseKey; *pKey; pKey++);
	pKey--;
	
	for (pResult = pszTempResult; pKey >= pszLicenseKey; pKey--, pResult++)
		*pResult = *pKey;

	*pResult = '\0';

	// Find the end of the result string.
	for (pEndResult = pszTempResult; *pEndResult; pEndResult++);
	pEndResult--;
	
	// Find the end of the source string.
	for (pEndKey = (char *) pszLicenseKey; *pEndKey; pEndKey++);
	pEndKey--;
	
	// XOR each character with its corresponding character at the other
	// end of the string.
	for (pKey = (char *) pszLicenseKey, pResult = pszTempResult; pKey < pEndKey; pKey++, pResult++)
	{
		*pResult ^= *pKey;
		nCheckSum += *pResult;	// Calculate the checksum.
	}
	
	// Now find the middle (or about the middle).
	for (pKey = pszTempResult, pResult = pEndResult; pKey < pResult; pKey++, pResult--);
	pKey--;
	pEndResult = pKey;	// Save our new end.
	
	// Set our base character to mod 10 of the checksum of our XOR.
	TCHAR cBaseChar;
	cBaseChar = 'a' + (nCheckSum % 10);

	//Now convert to some ascii representation by adding each nibble to our base char.
	for (pKey = pszResultKey, pResult = pszTempResult; pResult <= pEndResult; pKey++, pResult++)
	{
		*pKey = cBaseChar + (*pResult & 0x0F);
		++pKey;
		*pKey = cBaseChar + (*pResult >> 4);
	}
	*pKey = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#ifdef DBG

class CDbg
{
public:
    CDbg(LPTSTR str);
    ~CDbg(void);

    void DebugOut(unsigned long fDebugMask, LPWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, LPWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

private:
    unsigned long   m_InfoLevel; // must be the first data member
    LPTSTR          m_InfoLevelString;

public:
    static long s_cCDbgObjCount;         // Number of CDbg instances.

};  // class CDbg


#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined
#define DEB_USER8           0x00800000      // User defined
#define DEB_USER9           0x01000000      // User defined
#define DEB_USER10          0x02000000      // User defined
#define DEB_USER11          0x04000000      // User defined
#define DEB_USER12          0x08000000      // User defined
#define DEB_USER13          0x10000000      // User defined
#define DEB_USER14          0x20000000      // User defined
#define DEB_USER15          0x40000000      // User defined

#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x7fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtensons.cpp ===
//=--------------------------------------------------------------------------=
// xtensons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensions class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtensons.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensions::CExtensions(IUnknown *punkOuter) :
    CSnapInCollection<IExtension, Extension, IExtensions>(
                                           punkOuter,
                                           OBJECT_TYPE_EXTENSIONS,
                                           static_cast<IExtensions *>(this),
                                           static_cast<CExtensions *>(this),
                                           CLSID_Extension,
                                           OBJECT_TYPE_EXTENSION,
                                           IID_IExtension,
                                           NULL)  // no persistence
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensions::~CExtensions()
{
}

IUnknown *CExtensions::Create(IUnknown * punkOuter)
{
    CExtensions *pExtensions = New CExtensions(punkOuter);
    if (NULL == pExtensions)
    {
        return NULL;
    }
    else
    {
        return pExtensions->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
// CExtensions::Populate
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR bstrNodeTypeGUID  [in] node type whose extensions should populate the
//                               collection
//   ExtensionSubset Subset [in] All or dynamic only
//
// Output:
//      HRESULT
//
// Notes:
//
// This function populates the collection with either static or dynamic
// extensions for the specified node type GUID. It may be called multiple times
// for the same collection.
//

HRESULT CExtensions::Populate(BSTR bstrNodeTypeGUID, ExtensionSubset Subset)
{
    HRESULT  hr = S_OK;
    char    *pszDynExtKeyPrefix = NULL;
    char    *pszDynExtKeyName = NULL;
    long     lRc = 0;
    HKEY     hKeyDynExt = NULL;

    // Open DynamicExtensions key for the node type.
    // Build the key name
    // \Software\Microsoft\MMC\NodeTypes\<NodeType GUID>\DynamicExtensions

    IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                            bstrNodeTypeGUID, &pszDynExtKeyPrefix));

    IfFailGo(::CreateKeyName(pszDynExtKeyPrefix, ::strlen(pszDynExtKeyPrefix),
                           MMCKEY_S_DYNAMIC_EXTENSIONS,
                           MMCKEY_S_DYNAMIC_EXTENSIONS_LEN,
                           &pszDynExtKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszDynExtKeyName, 0,
                         KEY_QUERY_VALUE, &hKeyDynExt);
    if (ERROR_SUCCESS != lRc)
    {
        if (ERROR_FILE_NOT_FOUND == lRc)
        {
            hKeyDynExt = NULL; // DynamicExtensions subkey is not present
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lRc);
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(AddExtensions(NameSpace, MMCKEY_S_NAMESPACE, MMCKEY_S_NAMESPACE_LEN,
                           bstrNodeTypeGUID, Subset, hKeyDynExt));

    IfFailGo(AddExtensions(ContextMenu, MMCKEY_S_CONTEXTMENU,
                           MMCKEY_S_CONTEXTMENU_LEN, bstrNodeTypeGUID, Subset,
                           hKeyDynExt));

    IfFailGo(AddExtensions(Toolbar, MMCKEY_S_TOOLBAR, MMCKEY_S_TOOLBAR_LEN,
                           bstrNodeTypeGUID, Subset, hKeyDynExt));

    IfFailGo(AddExtensions(PropertySheet, MMCKEY_S_PROPERTYSHEET,
                           MMCKEY_S_PROPERTYSHEET_LEN, bstrNodeTypeGUID, Subset,
                           hKeyDynExt));

    IfFailGo(AddExtensions(Task, MMCKEY_S_TASK, MMCKEY_S_TASK_LEN, bstrNodeTypeGUID,
                           Subset, hKeyDynExt));

Error:
    if (NULL != pszDynExtKeyPrefix)
    {
        ::CtlFree(pszDynExtKeyPrefix);
    }
    if (NULL != pszDynExtKeyName)
    {
        ::CtlFree(pszDynExtKeyName);
    }
    if (NULL != hKeyDynExt)
    {
        ::RegCloseKey(hKeyDynExt);
    }
    RRETURN(hr);
}


HRESULT CExtensions::AddExtensions
(
    ExtensionFeatures   Feature,
    char               *pszExtensionTypeKey,
    size_t              cbExtensionTypeKey,
    BSTR                bstrNodeTypeGUID,
    ExtensionSubset     Subset,
    HKEY                hkeyDynExt
)
{
    HRESULT     hr = S_OK;
    long        lRc = ERROR_SUCCESS;
    char       *pszGUIDPrefix = NULL;
    char       *pszExtensionsPrefix = NULL;
    char       *pszKeyName = NULL;
    HKEY        hkeyExtension = NULL;
    DWORD       dwIndex = 0;
    char        szValueName[64] = "";
    DWORD       cbValueName = sizeof(szValueName);
    char        szValueData[256] = "";
    DWORD       cbValueData = sizeof(szValueData);
    DWORD       dwType = REG_SZ;

    // Build the key name and open the key
    // Software\Microsoft\MMC\NodeTypes\<NodeType GUID>\Extensions\<Extension Type>

    IfFailGo(CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                            bstrNodeTypeGUID, &pszGUIDPrefix));

    IfFailGo(CreateKeyName(pszGUIDPrefix, ::strlen(pszGUIDPrefix),
                           MMCKEY_S_EXTENSIONS, MMCKEY_S_EXTENSIONS_LEN,
                           &pszExtensionsPrefix));

    IfFailGo(CreateKeyName(pszExtensionsPrefix, ::strlen(pszExtensionsPrefix),
                           pszExtensionTypeKey, cbExtensionTypeKey,
                           &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0,
                         KEY_QUERY_VALUE, &hkeyExtension);

    if (ERROR_SUCCESS != lRc)
    {
        // If extension type subkey is not there then nothing else to do
        IfFalseGo(ERROR_FILE_NOT_FOUND != lRc, S_OK);
        hr = HRESULT_FROM_WIN32(lRc);
        EXCEPTION_CHECK_GO(hr);
    }

    // Extension type key is there. Enum the values to get the various extensions.

    for (dwIndex = 0; ERROR_SUCCESS == lRc; dwIndex++)
    {
        cbValueName = sizeof(szValueName);
        cbValueData = sizeof(szValueData);

        lRc = ::RegEnumValue(hkeyExtension, dwIndex,
                            szValueName, &cbValueName,
                            NULL, // reserved
                            &dwType,
                            reinterpret_cast<LPBYTE>(szValueData), &cbValueData);
        if (ERROR_SUCCESS != lRc)
        {
            // Check whether there are no more values or a real error occurred
            if (ERROR_NO_MORE_ITEMS == lRc)
            {
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lRc);
                EXCEPTION_CHECK_GO(hr);
            }
        }

        // If it is not a string type or the name is zero length then ignore it
        if ( (REG_SZ != dwType) || (0 == cbValueName) )
        {
            continue;
        }

        if (0 == cbValueData)
        {
            szValueData[0] = '\0';
        }
        IfFailGo(AddExtension(Feature, szValueName, szValueData, Subset,
                              hkeyDynExt));
    }
    
Error:
    if (NULL != pszGUIDPrefix)
    {
        ::CtlFree(pszGUIDPrefix);
    }
    if (NULL != pszExtensionsPrefix)
    {
        ::CtlFree(pszExtensionsPrefix);
    }
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkeyExtension)
    {
        ::RegCloseKey(hkeyExtension);
    }
    RRETURN(hr);
}



HRESULT CExtensions::AddExtension
(
    ExtensionFeatures   Feature,
    char               *pszCLSID,
    char               *pszName,
    ExtensionSubset     Subset,
    HKEY                hkeyDynExt
)
{
    HRESULT     hr = S_OK;
    DWORD       cbDynValueData = 0;
    IExtension *piExtension = NULL;
    BSTR        bstrCLSID = NULL;
    BSTR        bstrName = NULL;
    long        lRc = 0;

    SnapInExtensionTypeConstants Type = siStatic;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    // Check if the extension is already in there.

    IfFailGo(::BSTRFromANSI(pszCLSID, &bstrCLSID));

    hr = GetItemByName(bstrCLSID, &piExtension);

    // If it's there then just need to add the extension type (see below).
    IfFalseGo(FAILED(hr), S_OK);

    // If there was a real error then return
    
    if (SID_E_ELEMENT_NOT_FOUND != hr)
    {
        goto Error;
    }
   
    // Item is not there. Might need to add it. First determine whether the
    // extension is static or dynamic. Check if the value name is also present
    // under the dynamic extensions key.

    if (NULL != hkeyDynExt)
    {
        // Try to read the data length for the value named the same as the
        // clsid under the DynamicExtensions key. Note that we don't check
        // the actual type because it is only the presence of the value that
        // matters.

        cbDynValueData = 0;
        lRc = ::RegQueryValueEx(hkeyDynExt, pszCLSID,
                                NULL, // reserved
                                NULL, // don't return type
                                NULL, // don't return the data
                                &cbDynValueData);
        if (ERROR_SUCCESS != lRc)
        {
            // If the value is not there then don't add the extension
            IfFalseGo(ERROR_FILE_NOT_FOUND != lRc, S_OK);

            // A real error occurred
            hr = HRESULT_FROM_WIN32(lRc);
            EXCEPTION_CHECK_GO(hr);
        }

        // It is a dynamic extension.
        Type = siDynamic;
    }

    // If we are being asked for dynamic extensions only and this one is static
    // then don't add it

    if (Dynamic == Subset)
    {
        IfFalseGo(siDynamic == Type, S_OK);
    }

    // Add the new extension

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrCLSID;
    IfFailGo(Add(varIndex, varKey, &piExtension));

    // Set its properties

    IfFailGo(piExtension->put_CLSID(bstrCLSID));

    if (*pszName != '\0')
    {
        IfFailGo(::BSTRFromANSI(pszName, &bstrName));
        IfFailGo(piExtension->put_Name(bstrName));
    }

    IfFailGo(piExtension->put_Type(Type));

Error:
    if ( SUCCEEDED(hr) && (NULL != piExtension) )
    {
        // Add the extension type.
        IfFailGo(UpdateExtensionFeatures(piExtension, Feature));
    }
    FREESTRING(bstrCLSID);
    FREESTRING(bstrName);
    QUICK_RELEASE(piExtension);
    RRETURN(hr);
}



HRESULT CExtensions::UpdateExtensionFeatures
(
    IExtension        *piExtension,
    ExtensionFeatures  Feature
)
{
    HRESULT hr = S_OK;

    switch (Feature)
    {
        case NameSpace:
            IfFailGo(piExtension->put_ExtendsNameSpace(VARIANT_TRUE));
            break;

        case ContextMenu:
            IfFailGo(piExtension->put_ExtendsContextMenu(VARIANT_TRUE));
            break;

        case Toolbar:
            IfFailGo(piExtension->put_ExtendsToolbar(VARIANT_TRUE));
            break;

        case PropertySheet:
            IfFailGo(piExtension->put_ExtendsPropertySheet(VARIANT_TRUE));
            break;

        case Task:
            IfFailGo(piExtension->put_ExtendsTaskpad(VARIANT_TRUE));
            break;
    }

Error:
    RRETURN(hr);
}


HRESULT CExtensions::SetSnapIn(CSnapIn *pSnapIn)
{
    HRESULT     hr = S_OK;
    long        i = 0;
    long        cObjects = GetCount();
    CExtension *pExtension = NULL;

    while (i < cObjects)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pExtension));
        pExtension->SetSnapIn(pSnapIn);
        i++;
    }

Error:
    RRETURN(hr);
}


HRESULT CExtensions::SetHSCOPEITEM(HSCOPEITEM hsi)
{
    HRESULT     hr = S_OK;
    long        i = 0;
    long        cObjects = GetCount();
    CExtension *pExtension = NULL;

    while (i < cObjects)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pExtension));
        pExtension->SetHSCOPEITEM(hsi);
        i++;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IExtensions Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CExtensions::EnableAll(VARIANT_BOOL Enabled)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cObjects = GetCount();

    while (i < cObjects)
    {
        IfFailGo(GetItemByIndex(i)->put_Enabled(Enabled));
        i++;
    }
    
Error:
    RRETURN(hr);
}




STDMETHODIMP CExtensions::EnableAllStatic(VARIANT_BOOL Enabled)
{
    HRESULT                       hr = S_OK;
    IExtension                   *piExtension = NULL; // Not AddRef()ed
    long                          i = 0;
    long                          cObjects = GetCount();
    SnapInExtensionTypeConstants  Type = siStatic;

    while (i < cObjects)
    {
        piExtension = GetItemByIndex(i);
        IfFailGo(piExtension->get_Type(&Type));
        if (siStatic == Type)
        {
            IfFailGo(piExtension->put_Enabled(Enabled));
        }
        i++;
    }

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensions::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtensions == riid)
    {
        *ppvObjOut = static_cast<IExtensions *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IExtension, Extension, IExtensions>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\amcmsgid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcmsgid.h
//
//--------------------------------------------------------------------------

#ifndef _AMCMSGID_H
#define _AMCMSGID_H


//***************************IMPORTANT*****************************************
// The following enum group defines custom window messages used by MMC.
// MMC_MSG_SHOW_SNAPIN_HELP_TOPIC should be the first message and it's value
// can't be changed because it is referenced by mmc.lib, which is statically
// linked by snap-ins. Changing this message number would break existing snap-in
// DLLs.
//
// Because the message ID was mistakenly changed from the original (ver 1.1) value
// of 2166 to 2165, the message MMC_MSG_SHOW_SNAP_IN_HELP_TOPIC_ALT is being added
// so that MMC will respond properly to both message codes. This eliminates the
// need to synchronize this check-in with snap-in re-linking.
//******************************************************************************

enum MMC_MSG
{
    // Base message starting
    MMC_MSG_START    = 2165,    // DO NOT CHANGE!!

    // Message sent by nodemgr to conui
    //
    // wParam - <unused>
    // lParam - LPOLESTR help topic
    MMC_MSG_SHOW_SNAPIN_HELP_TOPIC_ALT = MMC_MSG_START, // This must be the first message!
    MMC_MSG_SHOW_SNAPIN_HELP_TOPIC,

    MMC_MSG_PROP_SHEET_NOTIFY,


    // Messages sent by CIC
    //
    // wParam - VARIANTARG
    // lParam - VARIANTARG
    MMC_MSG_CONNECT_TO_CIC,


    // Message sent by TPLV (TaskPadListView or ListPad)
    //
    // wParam - HWND of TPLV
    // lParam - HWND* to receive ListView window if connecting, NULL if deconnecting
    MMC_MSG_CONNECT_TO_TPLV,

    // Message sent from CFavTreeObserver to parent window
    //
    // wparam - ptr to Memento if favorite selected, NULL if folder selected
    // lparam - <unused>
    MMC_MSG_FAVORITE_SELECTION,

    // Message sent from CIconControl to parent window
    //
    // wparam - out param, ptr to HICON.
    // lparam - unused
    MMC_MSG_GET_ICON_INFO,

    // must be last!!
    MMC_MSG_MAX,
    MMC_MSG_FIRST = MMC_MSG_START,
    MMC_MSG_LAST  = MMC_MSG_MAX - 1
};

#endif // _AMCMSGID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\baseapi.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      baseapi.h
 *
 *  Contents:  Definition for MMCBASE_API
 *
 *  History:   13-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

// The following ifdef block is the standard way of creating macros which make exporting
// from a DLL simpler. All files within this DLL are compiled with the MMCBASE_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see
// MMCBASE_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef MMCBASE_EXPORTS
	#define MMCBASE_API __declspec(dllexport)
#else
	#define MMCBASE_API __declspec(dllimport)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\axwin2.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      AxHostWindow2.h
 *
 *  Contents:  Header file for CAxWindowT2. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/
#pragma once
#ifndef __AXWIN2_H__
#define __AXWIN2_H__

template <typename TBase = CWindow>
class CAxWindowT2 : public CAxWindowT<TBase>
{
public:
    CAxWindowT2(HWND hwnd = 0) : CAxWindowT<TBase>(hwnd) {}

    HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(lpszName, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(dwResID, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        DECLARE_SC(sc, TEXT("CreateControlEx"));

        TCHAR szModule[_MAX_PATH];
        if(0 == GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH))
        {
            ASSERT(FALSE);
            return ((sc = E_FAIL).ToHr());
        }
        
        CComBSTR bstrURL(OLESTR("res://"));
        bstrURL.Append(szModule);
        bstrURL.Append(OLESTR("/"));
        TCHAR szResID[11];
        sc = StringCchPrintf(szResID, countof(szResID), _T("%0d"), dwResID);
        if(sc)
            return ((sc = E_FAIL).ToHr());
        bstrURL.Append(szResID);
        
        return CreateControlEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
    }
    
    HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            CComPtr<IUnknown> spunkControl;
            hr = spAxWindow->CreateControlEx(lpszName, m_hWnd, pStream, &spunkControl, iidSink, punkSink);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkControl ) (*ppUnkControl = spunkControl)->AddRef();
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
            return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
        }

        return S_OK;
    }
    
    HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            hr = spAxWindow->AttachControl(pControl, m_hWnd);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
            return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);
        }

        return S_OK;
    }
};

typedef CAxWindowT2<CWindow> CAxWindow2;

#endif  // __AXWIN2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\base64.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      base64.h
 *
 *  Contents:  Implements encoding / decoding table for base64 format
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 * class base64_table
 *
 * PURPOSE: Class maintains Base64 conversion templates. It exposes static methods 
 *          to both encode and decode Base64 data
 *
 * USAGE:   call static methods to encode/decode one piece of data (24 bites or less)
 *
 *+-------------------------------------------------------------------------*/
class base64_table
{
protected:
    static BYTE _six2pr64[64];
    static BYTE _pr2six[256]; 
public:
    base64_table();
    int decode4(BYTE * src, int nChars, BYTE * dest);
    BYTE map2six(BYTE bt);
    // static functions used for zero terminated LPOLESTR format data only
    static void encode(const BYTE * &src, DWORD &cbInput, LPOLESTR &dest);
    static bool decode(LPCOLESTR &src, BYTE * &dest);
};


/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::map2six
 *
 * PURPOSE: maps symbols to 6bit value if smb is valid, 0xff else
 *
 *+-------------------------------------------------------------------------*/
inline BYTE base64_table::map2six(BYTE bt)
{
    return (bt > 255 ? 0xff : _pr2six[bt]);
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::decode4
 *
 * PURPOSE: glues 3 bytes from stored 6bit values
 *
 * NOTE: gluing is done in place - data pointed by src is destroyed
 *
 *+-------------------------------------------------------------------------*/
inline int base64_table::decode4(BYTE * src, int nChars, BYTE * dest)
{
    // glue to form 3 full bytes
    src[0] <<= 2; src[0] |= (src[1] >> 4);
    src[1] <<= 4; src[1] |= (src[2] >> 2);
    src[2] <<= 6; src[2] |= (src[3] );

    // now store as many bytes as have complete set of bites;
    // int nFull = nChars*6/8; // it actually boils to 0 or nChars - 1, whichever is bigger
    for (int i=0; i< nChars-1; i++)
        *dest++ = src[i];

    return nChars ? nChars - 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\amcpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcpriv.h
//
//--------------------------------------------------------------------------

#ifndef __AMC_PRIV_H__
#define __AMC_PRIV_H__
#pragma once


#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


#include "ndmgr.h"

//
//  TVOWNED_MAGICWORD
//

const COMPONENTID TVOWNED_MAGICWORD = (long)(0x03951589);

#define MMCNODE_NO_CHANGE          0
#define MMCNODE_NAME_CHANGE        1
#define MMCNODE_TARGET_CHANGE      2


//////////////////////////////////////////////////////////////////////////////
//
// SViewUpdateInfo and related defines.
//

typedef CList<HMTNODE, HMTNODE> CHMTNODEList;

struct SViewUpdateInfo
{
    SViewUpdateInfo() : newNode(0), insertAfter(0), flag(0) {}

    CHMTNODEList    path;
    HMTNODE         newNode;
    HMTNODE         insertAfter;
    DWORD           flag;
};


// The following are values of params sent to the views OnUpdate(lHint, pHint)
// lHint will be one of the VIEW_UPDATE_xxx's defined below.
// pHint will be a ptr to SViewUpdateInfo struct.

// VIEW_UPDATE_ADD is sent when a new node needs to be added.
// SViewUpdateInfo.flag         - unused
// SViewUpdateInfo.newNode      - the new node to be added
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_ADD             786


// VIEW_UPDATE_SELFORDELETE is sent when a node needs to ABOUT to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to node that is being deleted.
//
#define VIEW_UPDATE_SELFORDELETE    787

// VIEW_UPDATE_DELETE is sent when a node needs to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_DELETE          788
#define VUI_DELETE_THIS             1
#define VUI_DELETE_SETAS_EXPANDABLE 2


// VIEW_UPDATE_DELETE_EMPTY_VIEW is sent after the VIEW_UPDATE_DELETE is sent.
// No parameters.
#define VIEW_UPDATE_DELETE_EMPTY_VIEW   789


// VIEW_UPDATE_MODIFY is sent when a node needs to be modified.
// SViewUpdateInfo.flag         - REFRESH_NODE => Only node needs to be refreshed
//                                REFRESH_RESULTVIEW => Both node and result view need refresh. 
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_MODIFY          790
#define VUI_REFRESH_NODE            1


#define VIEW_RESELECT               791

// VIEW_UPDATE_TASKPAD_NAVIGATION is sent to refresh the navigation controls of
// all console taskpad views.
// SViewUpdateInfo.flag         - unused
// SviewUpdateInfo.newNode      - node that needs refreshing (always a taskpad group node)
// SViewUpdateInfo.path         - unused
#define VIEW_UPDATE_TASKPAD_NAVIGATION 792

class CSafeGlobalUnlock
{
public:
    CSafeGlobalUnlock(HGLOBAL h) : m_h(h)
    {
    }
    ~CSafeGlobalUnlock()
    {
        ::GlobalUnlock(m_h);
    }

private:
    HGLOBAL m_h;
};



enum EVerb
{
    evNone,
    evOpen,      
    evCut,       
    evCopy,      
    evPaste,     
    evDelete,    
    evPrint,     
    evRename,    
    evRefresh,   
    evProperties,

    // must be last
    evMax
};


#define INVALID_COOKIE  ((long)-10)


#endif // __AMC_PRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\axhostwindow2.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      AxHostWindow2.h
 *
 *  Contents:  Header file for CAxHostWindow2T. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef __AXHOSTWINDOW2_H_
#define __AXHOSTWINDOW2_H_


template <typename TFrameWindow> class CSimpleFrameSite;
//------------------------------------------------------------------------------------------------------------------
//
//
//------------------------------------------------------------------------------------------------------------------

template<typename TFrameWindow>
class ATL_NO_VTABLE CAxHostWindow2T :       public CAxHostWindow/*, 
                                            public IPersistPropertyBagImpl<CAxHostWindow2T>, 
                                            public IPersistStreamInitImpl<CAxHostWindow2T>*/
{
public:
    CAxHostWindow2T()
    {
        m_bUserMode = false;
        m_bMessageReflect = false;
        m_ContainerPages.cElems = 0;
        m_ContainerPages.pElems = 0;
    }
    
    ~CAxHostWindow2T()
    {
        if(m_ContainerPages.cElems >=1)
            CoTaskMemFree(m_ContainerPages.pElems);
    }

    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    
    typedef CAxHostWindow2T<TFrameWindow> thisClass;
    typedef CSimpleFrameSite<TFrameWindow> simpleFrameClass;
    BEGIN_COM_MAP(thisClass)
       //COM_INTERFACE_ENTRY(IPersistPropertyBag)
       //COM_INTERFACE_ENTRY(IPersistStreamInit)
       COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(IID_ISimpleFrameSite,simpleFrameClass, m_spUnkSimpleFrameSite.p)
       COM_INTERFACE_ENTRY_NOINTERFACE(IOleContainer) //yes!!
       COM_INTERFACE_ENTRY_CHAIN(CAxHostWindow)
    END_COM_MAP()
    
public:


BEGIN_PROP_MAP(thisClass)
    PROP_ENTRY("AllowWindowlessActivation"  ,   0x60020000, CLSID_NULL)
    PROP_ENTRY("BackColor"                  ,   DISPID_AMBIENT_BACKCOLOR, CLSID_NULL)
    PROP_ENTRY("ForeColor"                  ,   DISPID_AMBIENT_FORECOLOR, CLSID_NULL)
    PROP_ENTRY("LocaleID"                   ,   DISPID_AMBIENT_LOCALEID, CLSID_NULL)
    PROP_ENTRY("UserMode"                   ,   DISPID_AMBIENT_USERMODE, CLSID_NULL)
    
    PROP_ENTRY("DisplayAsDefault"           ,   DISPID_AMBIENT_DISPLAYASDEFAULT, CLSID_NULL)
    PROP_ENTRY("Font"                       ,   DISPID_AMBIENT_FONT, CLSID_NULL)
    PROP_ENTRY("MessageReflect"             ,   DISPID_AMBIENT_MESSAGEREFLECT, CLSID_NULL)
    PROP_ENTRY("ShowGrabHandles"            ,   DISPID_AMBIENT_SHOWGRABHANDLES, CLSID_NULL)
    PROP_ENTRY("ShowHatching"               ,   DISPID_AMBIENT_SHOWHATCHING, CLSID_NULL)

    PROP_ENTRY("DocHostFlags"               ,   0x60020012, CLSID_NULL)
    PROP_ENTRY("DocHostDoubleClickFlags"    ,   0x60020014, CLSID_NULL)
    PROP_ENTRY("AllowContextMenu"           ,   0x60020016, CLSID_NULL)
    PROP_ENTRY("AllowShowUI"                ,   0x60020018, CLSID_NULL)
    PROP_ENTRY("OptionKeyPath"              ,   0x6002001a, CLSID_NULL)
END_PROP_MAP()
public:

    STDMETHOD(CreateControlEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink)
    {
        HRESULT hr = S_FALSE;

        ReleaseAll();

        if (m_hWnd != NULL)
        {
            RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
            ReleaseWindow();
        }

        if (::IsWindow(hWnd))
        {
            USES_CONVERSION;
            SubclassWindow(hWnd);
            if (m_clrBackground == NULL)
            {
                if (IsParentDialog())
                    m_clrBackground = GetSysColor(COLOR_BTNFACE);
                else
                    m_clrBackground = GetSysColor(COLOR_WINDOW);
            }

            bool bWasHTML;
            hr = CreateNormalizedObjectEx(lpszTricsData, IID_IUnknown, (void**)ppUnk, bWasHTML);
            bool bInited = hr == S_FALSE;

            if (SUCCEEDED(hr))
                hr = ActivateAx(*ppUnk, bInited, pStream);

            
            //Try to hook up any sink the user might have given us.
            m_iidSink = iidAdvise;
            if(SUCCEEDED(hr) && *ppUnk && punkSink)
                AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);

            if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
            {
                if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
                    m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
                else
                {
                    DWORD dwStyle = GetStyle();
                    SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
                    SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
                }

                CComPtr<IUnknown> spUnk(*ppUnk);
                // Is it just plain HTML?
                USES_CONVERSION;
                if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
                    (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
                    (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
                    (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
                    (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
                    (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
                    (lpszTricsData[6] == OLECHAR(':')))
                {
                    // Just HTML, eh?
                    CComPtr<IPersistStreamInit> spPSI;
                    hr = spUnk->QueryInterface(IID_IPersistStreamInit, (void**)&spPSI);
                    spPSI->InitNew();
                    bInited = TRUE;
                    CComPtr<IHTMLDocument2> spHTMLDoc2;
                    hr = spUnk->QueryInterface(IID_IHTMLDocument2, (void**)&spHTMLDoc2);
                    if (SUCCEEDED(hr))
                    {
                        CComPtr<IHTMLElement> spHTMLBody;
                        hr = spHTMLDoc2->get_body(&spHTMLBody);
                        if (SUCCEEDED(hr))
                            hr = spHTMLBody->put_innerHTML(CComBSTR(lpszTricsData + 7));
                    }
                }
                else
                {
                    CComPtr<IWebBrowser2> spBrowser;
                    spUnk->QueryInterface(IID_IWebBrowser2, (void**)&spBrowser);
                    if (spBrowser)
                    {
                        CComVariant ve;
                        CComVariant vurl(lpszTricsData);
    #pragma warning(disable: 4310) // cast truncates constant value
                        spBrowser->put_Visible(VARIANT_TRUE);
    #pragma warning(default: 4310) // cast truncates constant value
                        spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
                    }
                }

            }
            if (FAILED(hr) || m_spUnknown == NULL)
            {
                // We don't have a control or something failed so release
                ReleaseAll();

                if (m_hWnd != NULL)
                {
                    RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                    if (FAILED(hr))
                        ReleaseWindow();
                }
            }
        }
        return hr;
    }
    //We support licensing
    virtual HRESULT CreateLicensedControl(REFCLSID clsid,REFIID riid, void** ppvObj,bool& bIsItLicensed)
    {
        CComPtr<IClassFactory2> spCF2;
        bIsItLicensed = false;
        HRESULT hr = CoGetClassObject(clsid,CLSCTX_SERVER,0,IID_IClassFactory2,(void**)&spCF2);
        if(FAILED(hr)) return hr;
                
        bIsItLicensed = true;
        LICINFO licInfo;
        licInfo.cbLicInfo = sizeof(LICINFO);
        hr = spCF2->GetLicInfo(&licInfo);

        if(FAILED(hr)) 
        {
            ::MessageBox(NULL,_T("License Key for this component not found. You do not have the appropriate license to use this component in the design environment"),_T("Licensing Error"),MB_OK);
            return hr;
        }
        BSTR strKey = 0;
        if(licInfo.fRuntimeKeyAvail) 
        {
            hr = spCF2->RequestLicKey(0,&strKey);
        }
        
        if(SUCCEEDED(hr) || licInfo.fLicVerified)
        {
            hr = spCF2->CreateInstanceLic(NULL,NULL,riid,strKey,ppvObj);
            if(strKey) { ::SysFreeString(strKey); }
            return hr;
        }

        ::MessageBox(NULL,_T("License Key for this component not found. You do not have the appropriate license to use this component in the design environment"),_T("Licensing Error"),MB_OK);
        return hr;
    }

    virtual HRESULT CreateNormalizedObjectEx(LPCOLESTR lpszTricsData, REFIID riid, void** ppvObj, bool& bWasHTML)
    {
        ATLASSERT(ppvObj);

        CLSID clsid;
        HRESULT hr = E_FAIL;
        bWasHTML = false;
        *ppvObj = NULL;

        if (lpszTricsData == NULL || lpszTricsData[0] == 0){ return S_OK; }

        // Is it HTML ?
        USES_CONVERSION;
        if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
            (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
            (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
            (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
            (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
            (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
            (lpszTricsData[6] == OLECHAR(':')))
        {
            // It's HTML, so let's create mshtml
            hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_SERVER, riid, ppvObj);
            bWasHTML = true;
        }
        if (FAILED(hr))
        {
            // Can't be clsid, or progid if length is grater than 255
            if (ocslen(lpszTricsData) < 255)
            {
                if (lpszTricsData[0] == '{') // Is it a CLSID?
                    hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
                else
                    hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
                
                if (SUCCEEDED(hr))  // Aha, it was one of those two
                {
                    //check if its a licensed control
                    //TODO: The usermode and binary persistence needs to act here
                    bool bLicensed = false;
                    hr = CreateLicensedControl(clsid,riid,ppvObj,bLicensed);
                    if(SUCCEEDED(hr) || ( bLicensed && FAILED(hr) ) )
                        return hr;

                    //create the control in a normal way - it does not support licensing
                    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER, riid, ppvObj);
                }
            }
            if (FAILED(hr))
            {
                // Last guess - it must be either a URL so let's create shdocvw
                hr = CoCreateInstance(CLSID_WebBrowser, NULL, CLSCTX_SERVER, riid, ppvObj);
                bWasHTML = true;
            }
        }

        return hr;
    }
public:
    virtual void OnFinalMessage(HWND hWnd)
    {
        FinalRelease();
        GetControllingUnknown()->Release();
    }

public: //modified methods
    STDMETHOD(GetContainer)(IOleContainer** ppContainer)
    {
        if(!ppContainer) return E_POINTER;
        if(m_spOleContainer)
            return (*ppContainer = m_spOleContainer)->AddRef(), S_OK;
        *ppContainer = 0;
        return E_NOINTERFACE;
    }
    STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
    {
        if(!ppDisp) return E_POINTER;
        if(m_spExtendedDispatch)
            return (*ppDisp = m_spExtendedDispatch)->AddRef(), S_OK;
        *ppDisp = 0;
        return E_NOTIMPL;
    }

    STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
    {
        if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL || !m_spInPlaceFrame || !m_spInPlaceUIWindow || !m_pContainerFrame)
        {
            return E_POINTER;
        }
                
        m_spInPlaceFrame.CopyTo(ppFrame);
        m_spInPlaceUIWindow.CopyTo(ppDoc);
        GetClientRect(lprcPosRect);
        GetClientRect(lprcClipRect);
        
        pFrameInfo = m_pContainerFrame->GetInPlaceFrameInfo();
        return S_OK;
    }
    STDMETHOD(ShowPropertyFrame)()
    {
        HRESULT hr = E_FAIL;
        if(m_ContainerPages.cElems <= 0) return hr;
        
        CComPtr<ISpecifyPropertyPages> spSpecifyPages;
        hr = QueryControl(IID_ISpecifyPropertyPages,(void**)&spSpecifyPages);
        if(FAILED(hr)) return hr;
        
        CAUUID pages;
        hr = spSpecifyPages->GetPages(&pages);
        if(FAILED(hr)) return hr;

        CComQIPtr<IOleObject> spObj(spSpecifyPages);
        CComPtr<IUnknown> spUnk = spSpecifyPages;
        if(!spObj || !spUnk)  return E_NOINTERFACE; 
    
        
        UINT nOldElems = pages.cElems;
        pages.cElems += m_ContainerPages.cElems;        
        pages.pElems = (GUID *)::CoTaskMemRealloc(pages.pElems, pages.cElems * sizeof(CLSID));
        
        for(UINT n = 0; n < m_ContainerPages.cElems; n++)
        {
            pages.pElems[nOldElems + n] = m_ContainerPages.pElems[n];   
        }
        LPOLESTR szTitle = NULL;

        spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

        RECT rcPos;
        ::GetClientRect(m_hWnd,&rcPos);
        
        m_pContainerFrame->SetDirty(true);
                    
        hr = OleCreatePropertyFrame(m_pContainerFrame->m_hWnd, rcPos.top, rcPos.left, szTitle,
            1, &spUnk.p, pages.cElems, pages.pElems, LOCALE_USER_DEFAULT, 0, 0);

        CoTaskMemFree(szTitle);
        CoTaskMemFree(pages.pElems);
        
        return hr;
    }
    
    void ReleaseAll()
    {
        if (m_bReleaseAll)
            return;
        m_bReleaseAll = TRUE;

        if (m_spViewObject != NULL)
            m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

        if(m_dwAdviseSink != 0xCDCDCDCD)
        {
            AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
            m_dwAdviseSink = 0xCDCDCDCD;
        }

        if (m_spOleObject)
        {
            m_spOleObject->Unadvise(m_dwOleObject);
            m_spOleObject->Close(OLECLOSE_NOSAVE);
            m_spOleObject->SetClientSite(NULL);
        }

        if (m_spUnknown != NULL)
        {
            CComPtr<IObjectWithSite> spSite;
            m_spUnknown->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
            if (spSite != NULL)
                spSite->SetSite(NULL);
        }

        m_spViewObject.Release();
        m_dwViewObjectType = 0;

        m_spInPlaceObjectWindowless.Release();
        m_spOleObject.Release();
        m_spUnknown.Release();

        m_bInPlaceActive = FALSE;
        m_bWindowless = FALSE;
        m_bInPlaceActive = FALSE;
        m_bUIActive = FALSE;
        m_bCapture = FALSE;
        m_bReleaseAll = FALSE;
    }

    STDMETHOD(AttachControl)(IUnknown* pUnkControl, HWND hWnd)
    {
        HRESULT hr = S_FALSE;

        ReleaseAll();

        if (m_hWnd != NULL)
        {
            RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
            ReleaseWindow();
        }

        if (::IsWindow(hWnd))
        {
            SubclassWindow(hWnd);

            hr = ActivateAx(pUnkControl, TRUE, NULL);

            if (FAILED(hr))
            {
                ReleaseAll();

                if (m_hWnd != NULL)
                {
                    RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                    ReleaseWindow();
                }
            }
        }
        return hr;
    }

    void FinalRelease()
    {
        CAxHostWindow::FinalRelease();
    }

public:
    unsigned                                                                m_bRequiresSave:1;
    CComPtr<IUnknown>                                                       m_spUnkSimpleFrameSite;
    CComPtr<IOleContainer>                                                  m_spOleContainer;   
    CComPtr<IDispatch>                                                      m_spExtendedDispatch;
    CAUUID                                                                  m_ContainerPages;
    TFrameWindow                                                            *m_pContainerFrame;
};

//--------------------------------------------------------------------------------------------------------------------
//*Very Very* Simple SimpleFrameSite impl
//SimpleFrameSite tear-off atop the Site - very basic message routing 
//one Known control that implements it for our test cases is(sad we cant use VB's intrinsic ones) - MS tabbed Dialog(Sheridan's)
//(not to be confused with MS tabstrip control)
//------------------------------------------------------------------------------------------------------------------
template <typename TFrameWindow>
class ATL_NO_VTABLE CSimpleFrameSite:   public ISimpleFrameSite,
                                        public CComTearOffObjectBase<CAxHostWindow2T<TFrameWindow> >
{
public:
    CSimpleFrameSite(){}
    ~CSimpleFrameSite(){}

    typedef CSimpleFrameSite<TFrameWindow> thisClass;
    
    BEGIN_COM_MAP(thisClass)
        COM_INTERFACE_ENTRY(ISimpleFrameSite)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    //ISimpleFrameSite
    STDMETHODIMP PreMessageFilter(/* [in] */ HWND hWnd,/* [in] */ UINT msg,/* [in] */ WPARAM wp,
                                /* [in] */ LPARAM lp,/* [out] */ LRESULT *plResult,
                                /* [out] */ DWORD *pdwCookie)
    {
        if(!plResult || !pdwCookie) { return E_POINTER; }
        HWND hWndChild = GetAxWindow(hWnd);
            
        if(hWndChild && ((msg == WM_PAINT)||(msg == WM_KEYDOWN)) )
        {
            ATLTRACE("\nPreMessageFilter called !!\n");
            *plResult = 0;
            ::SendMessage(hWndChild,msg,wp,lp);
        }
        
        return S_OK;
    }

    
    STDMETHODIMP PostMessageFilter(/* [in] */ HWND hWnd,/* [in] */ UINT msg,/* [in] */ WPARAM wp,
                                /* [in] */  LPARAM lp,/* [out] */ LRESULT *plResult,/* [in] */ DWORD dwCookie)
    {
        if(!plResult) { return E_POINTER; }
                
        HWND hWndChild = GetAxWindow(hWnd);
        if(hWndChild && ((msg == WM_PAINT)||(msg == WM_KEYDOWN))  )
        {
            ATLTRACE("\nPostMessageFilter called !!\n");
            *plResult = 0;
        }
        
        return S_OK;
    }

protected:
    HWND GetAxWindow(HWND& hWnd)
    {
        HWND hWndChild = GetWindow(hWnd,GW_CHILD);
            
        TCHAR pszClassName[100];
        TCHAR szFind[] = _T("AtlAxWinEx");
        if(hWndChild)
        {
            for(;;)
            {
                if(0 == GetClassName(hWndChild,pszClassName,100))
                {
                    ASSERT(FALSE);
                    return 0;
                }
                int nCmp = CompareString(LOCALE_USER_DEFAULT, 0, 
                    pszClassName, countof(pszClassName),
                    szFind, countof(szFind));

                ASSERT(ERROR_INVALID_FLAGS != nCmp && ERROR_INVALID_PARAMETER != nCmp);

                if(nCmp == CSTR_EQUAL)
                {
                    return ::GetWindow(hWndChild,GW_CHILD);
                }
                else
                {
                    return hWndChild;
                }
            }
        }
        return 0;
    }

};

#endif
//--------------------------------------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\autoptr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       autoptr.h
//
//--------------------------------------------------------------------------

#ifndef AUTOPTR_H_INCLUDED
#define AUTOPTR_H_INCLUDED

#ifndef ASSERT
#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif // _INC_CRTDBG
#define ASSERT(x) _ASSERT(x)
#endif // ASSERT

#include "cpputil.h"

/*+-------------------------------------------------------------------------*
 * CAutoResourceManagementBase
 *
 * This is a base class that implements common functionality for the class
 * of smart resource handlers which release resource when it's destroyed.  All
 * classes based on this class will behave identically, except the manner
 * in which they release their resources.
 *
 * DeleterClass is typically the class that derives from CAutoResourceManagementBase,
 * and must implement
 *
 *      static void _Delete(ResourceType h);
 *
 * See CAutoPtr below for an example.
 *--------------------------------------------------------------------------*/

template<typename ResourceType, typename DeleterClass>
class CAutoResourceManagementBase
{
    typedef CAutoResourceManagementBase<ResourceType, DeleterClass> ThisClass;
    typedef ThisClass Releaser;

    DECLARE_NOT_COPIABLE   (ThisClass)
    DECLARE_NOT_ASSIGNABLE (ThisClass)

// protected ctor so only derived classes can intantiate
protected:
    explicit CAutoResourceManagementBase(ResourceType h = 0) throw() : m_hResource(h) {}

public:
    ~CAutoResourceManagementBase() throw()
    {
        Delete();
    }

    void Attach(ResourceType p) throw()
    {
        ASSERT(m_hResource == NULL);
        m_hResource = p;
    }

    ResourceType Detach() throw()
    {
        ResourceType const p = m_hResource;
        m_hResource = NULL;
        return p;
    }

    /*
     * Returns the address of the pointer contained in this class.
     * This is useful when using the COM/OLE interfaces to create
     * allocate the object that this class manages.
     */
    ResourceType* operator&() throw()
    {
        /*
         * This object must be empty now, or the data pointed to will be leaked.
         */
        ASSERT (m_hResource == NULL);
        return &m_hResource;
    }

    operator ResourceType() const throw()
    {
        return m_hResource;
    }

    bool operator==(int p) const throw()
    {
        ASSERT(p == NULL);
        return m_hResource == NULL;
    }

    bool operator!=(int p) const throw()
    {
        ASSERT(p == NULL);
        return m_hResource != NULL;
    }

    bool operator!() const throw()
    {
        return m_hResource == NULL;
    }

    void Delete() throw()
    {
        if (m_hResource != NULL)
        {
            DeleterClass::_Delete (m_hResource);
            m_hResource = NULL;
        }
    }

private:
    ResourceType m_hResource;
}; // class CAutoResourceManagementBase


/*+-------------------------------------------------------------------------*
 * CAutoPtrBase
 *
 * This is a base class that implements common functionality for the class
 * of smart pointers which delete its pointee when it's destroyed.  All
 * classes based on this class will behave identically, except the manner
 * in which they destroy their pointees.
 *
 * DeleterClass is typically the class that derives from CAutoPtrBase, and
 * must implement
 *
 *      static void _Delete(T* p);
 *
 * This template reuses CAutoResourceManagementBase to manage the pointer
 *
 * See CAutoPtr below for an example.
 *--------------------------------------------------------------------------*/

template<typename T, typename DeleterClass>
class CAutoPtrBase : public CAutoResourceManagementBase<T*, DeleterClass>
{
    typedef CAutoPtrBase<T, DeleterClass>                 ThisClass;
    typedef CAutoResourceManagementBase<T*, DeleterClass> BaseClass;
    typedef BaseClass Releaser;

    DECLARE_NOT_COPIABLE   (ThisClass)
    DECLARE_NOT_ASSIGNABLE (ThisClass)

// protected ctor so only derived classes can intantiate
protected:
    explicit CAutoPtrBase(T* p = 0) throw() : BaseClass(p) {}

public:

    T& operator*() const throw()
    {
        T* ptr = *this; // use operator defined by the BaseClass for conversion
        ASSERT(ptr != NULL);
        return *ptr;
    }

    T* operator->() const throw()
    {
        T* ptr = *this; // use operator defined by the BaseClass for conversion
        ASSERT(ptr != NULL);
        return ptr;
    }

}; // class CAutoPtrBase


/*+-------------------------------------------------------------------------*
 * CAutoPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * operator new.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoPtr : public CAutoPtrBase<T, CAutoPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        delete p;
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoArrayPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * operator new[].
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoArrayPtr : public CAutoPtrBase<T, CAutoArrayPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoArrayPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoArrayPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        delete[] p;
    }
};


/*+-------------------------------------------------------------------------*
 * CCoTaskMemPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * CoTaskMemAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CCoTaskMemPtr : public CAutoPtrBase<T, CCoTaskMemPtr<T> >
{
    typedef CAutoPtrBase<T, CCoTaskMemPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CCoTaskMemPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            CoTaskMemFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoGlobalPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with GlobalAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoGlobalPtr : public CAutoPtrBase<T, CAutoGlobalPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoGlobalPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoGlobalPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            GlobalFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoLocalPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with LocalAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoLocalPtr : public CAutoPtrBase<T, CAutoLocalPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoLocalPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoLocalPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            LocalFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CHeapAllocMemPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated from the process
 * default heap with HeapAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CHeapAllocMemPtr : public CAutoPtrBase<T, CHeapAllocMemPtr<T> >
{
    typedef CAutoPtrBase<T, CHeapAllocMemPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CHeapAllocMemPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            HeapFree(::GetProcessHeap(), 0, p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoWin32Handle
 *
 * CAutoPtrBase-based class that closes HANDLE on destruction
 *--------------------------------------------------------------------------*/
class CAutoWin32Handle : public CAutoResourceManagementBase<HANDLE, CAutoWin32Handle>
{
    typedef CAutoResourceManagementBase<HANDLE, CAutoWin32Handle> BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoWin32Handle(HANDLE p = NULL) throw() : BaseClass(p) {}

    bool IsValid()
    {
        return IsValid(*this); // use base class operator to convet to HANDLE
    }
private:
    static bool IsValid (HANDLE p)
    {
        return (p != NULL && p != INVALID_HANDLE_VALUE);
    }
    // only CAutoResourceManagementBase should call this
    static void _Delete (HANDLE p)
    {
        if (IsValid(p))
            CloseHandle(p);
    }
};

/*+-------------------------------------------------------------------------*
 * CAutoAssignOnExit
 *
 * instances of this template class assign the value in destructor.
 *
 * USAGE: Say you have variable "int g_status" which must be set to S_OK before
 *        you leave the function. To do so declare following in the function:
 *
 *        CAutoAssignOnExit<int,S_OK>  any_object_name(g_status);
 *--------------------------------------------------------------------------*/
template<typename T, T value>
class CAutoAssignOnExit
{
    T& m_rVariable; // variable, which needs to be modified in destructor
public:
    // constructor
    CAutoAssignOnExit( T& rVariable ) : m_rVariable(rVariable) {}
    // destructor
    ~CAutoAssignOnExit()
    {
        // assign designated final value
        m_rVariable = value;
    }
};

#endif // AUTOPTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\bitmap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       bitmap.h
//
//--------------------------------------------------------------------------

// bitmap.h : definition file
//


#ifndef __BITMAP__H__
#define __BITMAP__H__

    HBITMAP CopyBitmap(HBITMAP hbm);

#endif //__BITMAP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\columninfo.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       columninfo.h
//
//  Contents:   Classes related to column persistence.
//
//
//  Note:       The classes in this file (CColumnInfo, CColumnInfoList)
//              were in nodemgr/colwidth.h. They are moved here so that
//              if columns change conui can ask nodemgr to persist data
//              or conui can set headers by asking nodemgr for data.
//
//  History:    04-Apr-00 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLUMNINFO_H_
#define COLUMNINFO_H_
#pragma once

using namespace std;

//+-------------------------------------------------------------------
//
//  Class:      CColumnInfo
//
//  Purpose:    The minimum information about a column that will be
//              persisted. (Width, order, format which can be hidden status)
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnInfo : public CSerialObject, public CXMLObject
{
public:
    CColumnInfo () : m_nCol(-1), m_nWidth(-1), m_nFormat(0)
    {}

    CColumnInfo (INT nCol, INT nWidth, INT nFormat)
                : m_nCol(nCol), m_nWidth(nWidth), m_nFormat(nFormat)
    {}

    CColumnInfo(const CColumnInfo& colInfo)
    {
        m_nFormat = colInfo.m_nFormat;
        m_nWidth = colInfo.m_nWidth;
        m_nCol = colInfo.m_nCol;
    }

    CColumnInfo& operator=(const CColumnInfo& colInfo)
    {
        if (this != &colInfo)
        {
            m_nCol = colInfo.m_nCol;
            m_nFormat = colInfo.m_nFormat;
            m_nWidth = colInfo.m_nWidth;
        }

        return (*this);
    }

    bool operator ==(const CColumnInfo &colinfo) const
    {
        return ( (m_nCol      == colinfo.m_nCol)  &&
                 (m_nFormat == colinfo.m_nFormat) &&
                 (m_nWidth  == colinfo.m_nWidth) );
    }

    // Temp members so that CNode can access & modify data. Should be removed soon.
public:
    INT GetColIndex  ()   const    {return m_nCol;}
    INT GetColWidth  ()   const    {return m_nWidth;}
    bool IsColHidden ()   const    {return (m_nFormat & HDI_HIDDEN);}

    void SetColIndex (INT nCol)    {m_nCol = nCol;}
    void SetColWidth (INT nWidth)  {m_nWidth = nWidth;}
    void SetColHidden(bool bHidden = true)
    {
        if (bHidden)
            m_nFormat |= HDI_HIDDEN;
        else
            m_nFormat &= ~HDI_HIDDEN;
    }

protected:
    INT           m_nCol;       // The index supplied when snapin inserted the column.
                                // This is not the index viewed by the user.
    INT           m_nWidth;
    INT           m_nFormat;

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_INFO);
    virtual void Persist(CPersistor &persistor);
};

//+-------------------------------------------------------------------
//
//  Class:      ColPosCompare
//
//  Purpose:    Compare the column position in CColumnInfo and the given position.
//              This is used to reorder/search the columns.
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
struct ColPosCompare : public std::binary_function<const CColumnInfo, INT, bool>
{
    bool operator() (const CColumnInfo colinfo, INT nCol) const
    {
        return (nCol == colinfo.GetColIndex());
    }
};


//+-------------------------------------------------------------------
//
//  Class:      CColumnInfoList
//
//  Purpose:    linked list with CColumnInfo's.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
typedef list<CColumnInfo> CIL_base;
class CColumnInfoList : public XMLListCollectionImp<CIL_base>, public CSerialObject
{
public:
    friend class  CColumnSetData;

public:
    CColumnInfoList ()
    {
    }

    ~CColumnInfoList()
    {
    }

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_INFO_LIST);
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};

#endif // COLUMNINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\comobjects.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       comobjects.h
//
//  Contents:   Base code for com objects exported by Object Model.
//
//  Classes:    CMMCStrongReferences, CMMCIDispatchImpl
//
//  History:    16-May-2000 AudriusZ     Created
//
//--------------------------------------------------------------------


#pragma once
#ifndef COMOBJECTS_H_INCLUDED
#define COMOBJECTS_H_INCLUDED

/*+-------------------------------------------------------------------------*
 * class CComObjectObserver
 *
 * PURPOSE: The general interface for a class that observes com object events
 *
 * USAGE:   Used by CMMCIDispatchImpl, so all ObjectModel objects inherit from it
 *
 *+-------------------------------------------------------------------------*/
class CComObjectObserver : public CObserverBase
{
public:
    // request to break external references
    virtual SC ScOnDisconnectObjects()  {DEFAULT_OBSERVER_METHOD;}
};

/*+-------------------------------------------------------------------------*
 * function GetComObjectEventSource
 *
 * PURPOSE: returns singleton for emmiting Com Object Events
 *          Since ObjectModel com objects are implemented in EXE and DLL's
 *          There is a need to have 'global' object per process to
 *          be able to bradcast events to every object.
 *
 * USAGE:   Used by
 *          1) CMMCIDispatchImpl    to register objects
 *          2) CAMCMultiDocTemplate to bradcast 'cut off extenal references'
 *+-------------------------------------------------------------------------*/
MMCBASE_API CEventSource<CComObjectObserver>& GetComObjectEventSource();

/***************************************************************************\
 *
 * CLASS:  CMMCStrongReferences
 *
 * PURPOSE: Implements static interface to count strong references put on MMC
 *          Also implements the method to detect when the last stron reference was
 *          released in order to start MMC exit procedure.
 *
 *          Class is implemented as singleton object in mmcbase.dll
 *
 * USAGE:   use CMMCStrongReferences::AddRef() and CMMCStrongReferences::Release()
 *              to put/remove strong references on MMC.EXE
 *          use CMMCStrongReferences::LastRefReleased() to inspect if the
 *              last ref was released
 *
\***************************************************************************/
class MMCBASE_API CMMCStrongReferences
{
public:
    // public (static) interface
    static DWORD AddRef();
    static DWORD Release();
    static bool  LastRefReleased();

private:
    // implementation helpers

    CMMCStrongReferences();

    static CMMCStrongReferences& GetSingletonObject();
    DWORD InternalAddRef();
    DWORD InternalRelease();
    bool  InternalLastRefReleased();

    // data members
    DWORD  m_dwStrongRefs;      // strong reference count
    bool   m_bLastRefReleased;  // have strong reference count ever go from one to zero
};


/***************************************************************************\
 *
 * CLASS:  CMMCIDispatchImpl<typename _ComInterface, const GUID * _pguidClass = &GUID_NULL, const GUID* _pLibID = &LIBID_MMC20>
 *                  _ComInterface - Object Model interface implemented by the class
 *                  _pguidClass [optional] - pointer to CLSID for cocreatable objects
 *                  _pLibID     [optional] - pointer to LIBID with _ComInterface's type info
 *
 * PURPOSE: Base for every com object defined by the MMC Object Model
 *          implements common functionality, like:
 *              - IDispatch
 *              - ISupportErrorInfo
 *              - IExternalConnection
 *
 * USAGE:   Derive your object from CMMCIDispatchImpl<interface>
 *          Define: BEGIN_MMC_COM_MAP(_Class) ... END_MMC_COM_MAP() in the class
 *          Define COM_INTERFACE_ENTRY for each additional interface
 *          ( DO NOT need to add IDispatch, ISupportErrorInfo, IExternalConnection
 *          or implemented ObjecModel interface - these are added by the base class )
 *
\***************************************************************************/
template<
	typename _ComInterface,
	const GUID * _pguidClass = &GUID_NULL,
	const GUID * _pLibID = &LIBID_MMC20>
class CMMCIDispatchImpl :
    public IDispatchImpl<_ComInterface, &__uuidof(_ComInterface), _pLibID>,
    // we can use the IMMCSupportErrorInfoImpl object because exactly one dispinterface is exposed from this object.
    public IMMCSupportErrorInfoImpl<&__uuidof(_ComInterface), _pguidClass>,
    public IExternalConnection,
    public CComObjectRoot,
    public CComObjectObserver
{
public:
    // typedef interface and this class [used by macros defined in the derived class]
    typedef _ComInterface MMCInterface;
    typedef CMMCIDispatchImpl<_ComInterface, _pguidClass, _pLibID> CMMCIDispatchImplClass;

// interfaces implemented by this base class
BEGIN_COM_MAP(CMMCIDispatchImplClass)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IExternalConnection)
END_COM_MAP()

    CMMCIDispatchImpl()
    {
        // add itself as an observer for com object events
        GetComObjectEventSource().AddObserver(*static_cast<CComObjectObserver*>(this));

#ifdef _MMC_NODE_MANAGER_ONLY_
    // Every object implemented by node manager should also register for typeinfo clenup
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder());
#endif // _MMC_NODE_MANAGER_ONLY_
    }

#ifdef _MMC_NODE_MANAGER_ONLY_
    // Every object implemented by node manager should also register for typeinfo clenup

    // the porpose of this static function is to ensure _tih is a static variable,
    // since static wrapper will hold on its address - it must be always valid
    static CComTypeInfoHolder& GetInfoHolder() { return _tih; }

#endif // _MMC_NODE_MANAGER_ONLY_

    // implementation for IExternalConnection methods

    STDMETHOD_(DWORD, AddConnection)(DWORD extconn, DWORD dwreserved)
    {
        DWORD dwRefs = AddRef();    // addref itself

        // put a strong reference on MMC - this will prevent mmc from exiting
        if (extconn & EXTCONN_STRONG)
            dwRefs = CMMCStrongReferences::AddRef();

        return dwRefs;
    }
    STDMETHOD_(DWORD, ReleaseConnection)(DWORD extconn, DWORD dwreserved, BOOL fLastReleaseCloses)
    {
        DWORD dwStrongRefs = 0;
        DWORD dwRefs = 0;

        // release a strong reference on MMC
        if (extconn & EXTCONN_STRONG)
        {
            dwStrongRefs = CMMCStrongReferences::Release();
        }

        //release a ref on itself
        dwRefs = Release();

        // return a proper ref count
        return (extconn & EXTCONN_STRONG) ? dwStrongRefs : dwRefs;
    }

    /***************************************************************************\
     *
     * METHOD:  ScOnDisconnectObjects
     *
     * PURPOSE: invoked when observed event (request to disconnect) occures
     *          Disconnects from external connections
     *
     * PARAMETERS:
     *
     * RETURNS:
     *    SC    - result code
     *
    \***************************************************************************/
    virtual ::SC ScOnDisconnectObjects()
    {
        DECLARE_SC(sc, TEXT("CMMCIDispatchImpl<_ComInterface>::ScOnDisconnectObjects"));

        // QI for IUnknown
        IUnknownPtr spUnknown = this;

        // sanity check
        sc = ScCheckPointers( spUnknown, E_UNEXPECTED );
        if (sc)
            return sc;

        // cutt own references
        sc = CoDisconnectObject( spUnknown, 0/*dwReserved*/ );
        if (sc)
            return sc;

        return sc;
    }

#ifdef DBG
    // this block is to catch mistakes when the Derived class does not use
    // BEGIN_MMC_COM_MAP() or END_MMC_COM_MAP() in its body
    virtual void _BEGIN_MMC_COM_MAP() = 0;
    virtual void _END_MMC_COM_MAP() = 0;
#endif
};

/***************************************************************************\
 *
 * MACRO:  BEGIN_MMC_COM_MAP
 *
 * PURPOSE: To be used in place of BEGIN_MMC_COM_MAP for com objects used in MMC Object Model
 *
\***************************************************************************/

#ifndef DBG

// standard version
#define BEGIN_MMC_COM_MAP(_Class)                       \
        BEGIN_COM_MAP(_Class)                           \
        COM_INTERFACE_ENTRY(MMCInterface)

#else // DBG

// same as above, but shuts off the trap placed in CMMCIDispatchImpl in debug mode
#define BEGIN_MMC_COM_MAP(_Class)                       \
        virtual void _BEGIN_MMC_COM_MAP() {}            \
        BEGIN_COM_MAP(_Class)                           \
        COM_INTERFACE_ENTRY(MMCInterface)
#endif // DBG

/***************************************************************************\
 *
 * MACRO:  END_MMC_COM_MAP
 *
 * PURPOSE: To be used in place of END_COM_MAP for com objects used in MMC Object Model
 *
\***************************************************************************/

#ifndef DBG

// standard version
#define END_MMC_COM_MAP()                               \
        COM_INTERFACE_ENTRY_CHAIN(CMMCIDispatchImplClass)   \
        END_COM_MAP()

#else // DBG

// same as above, but shuts off the trap placed in CMMCIDispatchImpl in debug mode
#define END_MMC_COM_MAP()                               \
        COM_INTERFACE_ENTRY_CHAIN(CMMCIDispatchImplClass)   \
        END_COM_MAP()                                   \
        virtual void _END_MMC_COM_MAP() {}

#endif // DBG

/*+-------------------------------------------------------------------------*
 * class CConsoleEventDispatcher
 *
 *
 * PURPOSE: Interface for emitting com events from node manager side
 *          implemented by CMMCApplication
 *
 *+-------------------------------------------------------------------------*/
class CConsoleEventDispatcher
{
public:
    virtual SC ScOnContextMenuExecuted( PMENUITEM pMenuItem ) = 0;
};

/***************************************************************************\
 *
 * METHOD:  CConsoleEventDispatcherProvider
 *
 * PURPOSE: this class is to wrap and maintain a pointer to CConsoleEventDispatcher
 *          interface. Pointer is set by conui side and used from node manager side.
 *          Pointer is discarded when when cleanup event is observed.
 *
\***************************************************************************/
class CConsoleEventDispatcherProvider
{
public:

    // public class members (static) to get/set interface pointer
    static SC MMCBASE_API ScSetConsoleEventDispatcher( CConsoleEventDispatcher *pDispatcher )
    {
        s_pDispatcher = pDispatcher;
        return SC(S_OK);
    }
    static SC MMCBASE_API ScGetConsoleEventDispatcher( CConsoleEventDispatcher *&pDispatcher )
    {
        pDispatcher = s_pDispatcher;
        return SC(S_OK);
    }

private:
    // pointer to interface
    static MMCBASE_API CConsoleEventDispatcher *s_pDispatcher;
};

#endif // COMOBJECTS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\comerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      comerror.h
//
//  Contents:  Support for Rich COM errors
//
//  History:   14-Oct-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef COMERROR_H
#define COMERROR_H
#pragma once

#include "tiedobj.h"



//############################################################################
//############################################################################
//
//  COM Rich Error support
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * MMCReportError
 *
 * PURPOSE: Calls AtlReportError and sets the last error condition based
 *          on an SC.
 *
 * PARAMETERS:
 *    SC &   sc :
 *    const  IID :
 *    const  CLSID :
 *
 * RETURNS:
 *    inline HRESULT
 *
 *+-------------------------------------------------------------------------*/
inline
HRESULT MMCReportError(SC &sc, const IID &iid, const CLSID & clsid)
{
    // only report the error if there was one.
    if(sc)
    {
        USES_CONVERSION;

        const  int length = 256;
        TCHAR sz[length];

        sc.GetErrorMessage(length, sz);

        // set everything we know about the error - the description, the help file,
        // the help ID, and the CLSID and IID of the source.
        return AtlReportError(clsid, sz, sc.GetHelpID(), sc.GetHelpFile(), iid, sc.ToHr());
    }
    else
        return S_OK;
}

// see "WHY NAMESPACES ?" comment at the top of mmcerror.h file
namespace comerror {
/*+-------------------------------------------------------------------------*
 * class _SC
 *
 *
 * PURPOSE: a local version of the SC class that automatically sets the error
 *          information when deleted.
 *
 * NOTE: Because of a compiler bug, this class cannot directly be internal
 *       to IMMCSupportErrorInfoImpl<>
 *
 *+-------------------------------------------------------------------------*/
template<const IID *piid, const CLSID *pclsid>
class SC : public mmcerror::SC
{
    typedef mmcerror::SC BaseClass;
public:
    SC (HRESULT hr = S_OK) : BaseClass(hr)
    {
    }

    ~SC()
    {
        MMCReportError(*this, *piid, *pclsid);
    }

    // copy constructor
    SC(const BaseClass &rhs) : BaseClass(rhs)
    {
    }

    // assignment
    SC&  operator= (HRESULT hr)             { BaseClass::operator =(hr);  return *this; }
    SC&  operator= (const BaseClass &rhs)   { BaseClass::operator =(rhs); return *this; }
    SC&  operator= (const SC &rhs)          { BaseClass::operator =(rhs); return *this; }
};

} // namespace comerror

/*+-------------------------------------------------------------------------*
 * class IMMCSupportErrorInfoImpl
 *
 *
 * PURPOSE: Inherits from ISupportErrorInfoImpl. local definition of the
 *          status code class SC, which makes it easy to return error information
 *          via the COM rich error handling system, without any extra effort
 *          on the part of the programmer.
 *
 *+-------------------------------------------------------------------------*/
template<const IID *piid, const CLSID *pclsid>
class IMMCSupportErrorInfoImpl : public ISupportErrorInfoImpl<piid>
{
    // this makes sure that AtlReportError is called in the destructor
    public:
        typedef comerror::SC<piid, pclsid> SC;
};

#define NYI_COM_METHOD()  {SC sc = E_NOTIMPL; return sc.ToHr();}

#ifdef AFX_MANAGE_STATE
	#define MMC_COM_MANAGE_STATE() AFX_MANAGE_STATE (AfxGetAppModuleState())
#else
	#define MMC_COM_MANAGE_STATE() /**/
#endif

/************************************************************************
 * The following macros make it easy to implement a lightweight
 * COM object that "connects" to a non-COM tied object and delegates
 * all its methods to the non-COM object. The tied object pointer
 * is checked as well.
 ************************************************************************/
#define MMC_METHOD_PROLOG()                                         \
	MMC_COM_MANAGE_STATE();											\
																	\
    SC  sc;                                                         \
                                                                    \
    CMyTiedObject *pTiedObj = NULL;                                 \
                                                                    \
    sc = ScGetTiedObject(pTiedObj);                                 \
    if(sc)                                                          \
        return (sc.ToHr())

#define MMC_METHOD_CALL(_fn)                                        \
    sc = pTiedObj->Sc##_fn

#define MMC_METHOD_EPILOG()                                         \
    return sc.ToHr()

#define MMC_METHOD0(_fn)                                            \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)();                                         \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD0_PARAM(_fn, param)                               \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(param);                                    \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1(_fn, T1)                                        \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1);                                       \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1_PARAM(_fn, T1, param)                           \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, param);                                \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2(_fn, T1, T2)                                    \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2);                                   \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2_PARAM(_fn, T1, T2, param)                       \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, param);                            \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3(_fn, T1, T2, T3)                                \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3);                               \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3_PARAM(_fn, T1, T2, T3, param)                   \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, param);                        \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD4(_fn, T1, T2, T3, T4)                            \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4)                          \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4);                           \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD4_PARAM(_fn, T1, T2, T3, T4, param)               \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4)                          \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, param);                    \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD5(_fn, T1, T2, T3, T4, T5)                        \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)                   \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, p5);                       \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD5_PARAM(_fn, T1, T2, T3, T4, T5, param)           \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)                   \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, p5, param);                \
    MMC_METHOD_EPILOG();                                            \
}

/************************************************************************
 * A version of the above macros that adds a prefix to the Sc methods.
 * This is useful for disambiguating method names if the same object serves
 * as the tied object for more than one COM object with identical methods.
 ************************************************************************/
#define MMC_METHOD0_EX(_prefix, _fn)                                \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)();                                \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1_EX(_prefix, _fn, T1)                            \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1);                              \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2_EX(_prefix, _fn, T1, T2)                        \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1, p2);                          \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3_EX(_prefix, _fn, T1, T2, T3)                    \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1, p2, p3, param);               \
    MMC_METHOD_EPILOG();                                            \
}

#endif  // COMERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\classreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       classreg.h
//
//  History: 02-02-2000 Vivekj Added
//--------------------------------------------------------------------------

#pragma once
#ifndef _CLASSREG_H_
#define _CLASSREG_H_

#include "tstring.h"
#include "modulepath.h"


/*+-------------------------------------------------------------------------*
 * AddReplacementTrace
 *
 * Trace helper function.
 *--------------------------------------------------------------------------*/

#ifdef DBG

inline void AddReplacementTrace (std::wstring& str, LPCWSTR pszKey, LPCWSTR pszData)
{
	if (!str.empty())
		str	+= L"\n";

	str	+= pszKey;
	str	+= L" -> ";
	str	+= pszData;
}

#else
#define AddReplacementTrace(str, pszKey, pszData)
#endif	// DBG


/*+-------------------------------------------------------------------------*
 * InlineT2W
 *
 * Helper function to aid in converting tstrings during initialization
 * of constant members.
 *--------------------------------------------------------------------------*/

inline std::wstring InlineT2W (const tstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return A2CW(str.c_str());
#endif
}


/*+-------------------------------------------------------------------------*
 * CObjectRegParams
 *
 * Parameters register all objects.
 *--------------------------------------------------------------------------*/

class CObjectRegParams
{
public:
	CObjectRegParams (
		const CLSID&	clsid,                          // CLSID of object
		LPCTSTR			pszModuleName,                  // name of implementing DLL
		LPCTSTR			pszClassName,                   // class name of object
		LPCTSTR			pszProgID,                      // ProgID of object
		LPCTSTR			pszVersionIndependentProgID,    // version-independent ProgID of object
		LPCTSTR			pszServerType = _T("InprocServer32")) // server type
		:
		m_clsid                       (clsid),
		m_strModuleName               (InlineT2W (pszModuleName) ),
		m_strModulePath               (InlineT2W ((LPCTSTR)CModulePath::MakeAbsoluteModulePath(pszModuleName))),
		m_strClassName                (InlineT2W (pszClassName)),
		m_strProgID                   (InlineT2W (pszProgID)),
		m_strVersionIndependentProgID (InlineT2W (pszVersionIndependentProgID)),
		m_strServerType				  (InlineT2W (pszServerType))
	{
	}

    const CLSID     	m_clsid;						// CLSID of object
	const std::wstring	m_strModuleName;				// name of implementing DLL
	const std::wstring	m_strModulePath;				// absolute module path
	const std::wstring	m_strClassName;					// class name of object
	const std::wstring	m_strProgID;					// ProgID of object
	const std::wstring	m_strVersionIndependentProgID;	// version-independent ProgID of object
	const std::wstring	m_strServerType;				// server type local/in-proc, etc.
};


/*+-------------------------------------------------------------------------*
 * CControlRegParams
 *
 * Parameters required to register all controls, in addition to
 * CObjectRegParams.
 *--------------------------------------------------------------------------*/

class CControlRegParams
{
public:
	CControlRegParams (
		const GUID&		libid,					// LIBID of control's typelib
		LPCTSTR			pszToolboxBitmapID,     // index of control's bitmap
		LPCTSTR			pszVersion)             // control's version
		:
		m_libid              (libid),
		m_strToolboxBitmapID (InlineT2W (pszToolboxBitmapID)),
		m_strVersion         (InlineT2W (pszVersion))
	{
	}

    const GUID			m_libid;				// LIBID of control's typelib
    const std::wstring	m_strToolboxBitmapID;	// index of control's bitmap
    const std::wstring	m_strVersion;			// control's version
};


/*+-------------------------------------------------------------------------*
 * MMCUpdateRegistry
 *
 * Registers a COM object or control.  This function typically isn't used
 * directly, but indirectly via DECLARE_MMC_OBJECT_REGISTRATION or
 * DECLARE_MMC_CONTROL_REGISTRATION.
 *--------------------------------------------------------------------------*/

MMCBASE_API HRESULT WINAPI MMCUpdateRegistry (
    BOOL                        bRegister,      // I:register or unregister?
    const CObjectRegParams*     pObjParams,     // I:object registration parameters
    const CControlRegParams*    pCtlParams);    // I:control registration parameters (optional)


/*+-------------------------------------------------------------------------*
 * DECLARE_MMC_OBJECT_REGISTRATION
 *
 * Declares a registration function for a COM object.
 *--------------------------------------------------------------------------*/

#define DECLARE_MMC_OBJECT_REGISTRATION(                            \
	szModule,														\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID)                                     \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                \
{                                                                   \
    CObjectRegParams op (											\
		clsid,														\
		szModule,													\
		szClassName,												\
		szProgID,													\
		szVersionIndependentProgID);								\
                                                                    \
    return (MMCUpdateRegistry (bRegister, &op, NULL));              \
}


/*+-------------------------------------------------------------------------*
 * DECLARE_MMC_CONTROL_REGISTRATION
 *
 * Declares a registration function for a COM control.
 *--------------------------------------------------------------------------*/

#define DECLARE_MMC_CONTROL_REGISTRATION(                           \
	szModule,														\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID,                                     \
    libid,                                                          \
    szBitmapID,                                                     \
    szVersion)                                                      \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                \
{                                                                   \
    CObjectRegParams op (											\
		clsid,														\
		szModule,													\
		szClassName,												\
		szProgID,													\
		szVersionIndependentProgID);								\
                                                                    \
    CControlRegParams cp (											\
		libid,														\
		szBitmapID,													\
		szVersion);													\
                                                                    \
    return (MMCUpdateRegistry (bRegister, &op, &cp));               \
}

#endif // _CLASSREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\cmenuinfo.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Interface/implementation file for CContextMenuInfo
 *
 *  History:   12-Sep-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CMENUINFO_H
#define CMENUINFO_H
#pragma once

class CConsoleView;
class CConsoleTree;

//
// This structure is used to pass UI information to/from the mmc.exe and
// the node manager.  It has information about the state of the UI "bits"
// and returns the selected menu item.  Note: if the node manager processes
// the menu command, the m_lSelected will be returned with a value of 0
//


enum
{
    CMINFO_USE_TEMP_VERB         = 0x00000001, // Need for r-click of non-selected scope node and by TaskPads.
    CMINFO_SHOW_VIEW_ITEMS       = 0x00000002,
    CMINFO_SHOW_SAVE_LIST        = 0x00000004,
    CMINFO_DO_SCOPEPANE_MENU     = 0x00000008, // Set when menu invoked from scope pane
    CMINFO_SCOPEITEM_IN_RES_PANE = 0x00000010, // set when the item is a scope item in the result pane
    CMINFO_SHOW_SCOPEITEM_OPEN   = 0x00000020, // Show Open verb for scope item regardless of enable state
    CMINFO_FAVORITES_MENU        = 0x00000040, // Show items for favorites menu
    CMINFO_SHOW_VIEWOWNER_ITEMS  = 0x00000080, // Show items for scope item that owns result view
    CMINFO_SHOW_SCOPETREE_ITEM   = 0x00000100, // Show item for showing/hiding scope tree
};


class CContextMenuInfo
{
public:
    POINT                   m_displayPoint;

    // flag to indicate the snap-in manager is allowed to be displayed
    bool                    m_bScopeAllowed;        // Display scope pane menu item
    bool                    m_bBackground;          // Background on control or item
    bool                    m_bMultiSelect;         // TRUE if multi select in the result pane.
	bool					m_bAllowDefaultItem;	// permit a default item on the menu (true for context menus, false for menu bar popups)
    MMC_CONTEXT_MENU_TYPES  m_eContextMenuType;     // Context menu type
    DATA_OBJECT_TYPES       m_eDataObjectType;      // Data object type
    HWND                    m_hWnd;                 // View HWND
    CConsoleView*           m_pConsoleView;         // console view interface (not a COM interface)
    CConsoleTree*           m_pConsoleTree;         // console tree interface (not a COM interface)
    IMMCListViewPtr         m_spListView;           // Pointer to listview interface (NULL if custom result view)
    LPARAM                  m_resultItemParam;      // Our wrapped lparam for the result item
    HNODE                   m_hSelectedScopeNode;
    HTREEITEM               m_htiRClicked;
    int                     m_iListItemIndex;       // The index of the list item in the result pane

    DWORD                   m_dwFlags;              // One of the CMINFO_xxx flags
	RECT					m_rectExclude;			// portion of screen to avoid obscuring

public:
    CContextMenuInfo ()
    {
        Initialize();
    }

    void Initialize ()
    {
        m_displayPoint.x          = 0;
        m_displayPoint.y          = 0;
        m_bScopeAllowed           = false;
        m_bBackground             = false;
        m_bMultiSelect            = false;
        m_bAllowDefaultItem       = true;
        m_eContextMenuType        = MMC_CONTEXT_MENU_DEFAULT;
        m_eDataObjectType         = CCT_UNINITIALIZED;
        m_hWnd                    = NULL;
        m_pConsoleView            = NULL;
        m_pConsoleTree            = NULL;
        m_spListView              = NULL;
        m_resultItemParam         = 0;
        m_hSelectedScopeNode      = 0;
        m_htiRClicked             = 0;
        m_iListItemIndex          = 0;
        m_dwFlags                 = 0;

		SetRectEmpty (&m_rectExclude);
    }
};

#endif /* CMENUINFO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\bookmark.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      bookmark.h
 *
 *  Contents:  Interface file for CBookmark
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef BOOKMARK_H
#define BOOKMARK_H
#pragma once

#include <windows.h>
#include <vector>
#include <objbase.h>
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "stddbg.h"
#include "stgio.h"
#include "xmlbase.h"

typedef std::vector<BYTE>               ByteVector;
#define BOOKMARK_CUSTOMSTREAMSIGNATURE  "MMCCustomStream"

//***************************************************************************
// class CDynamicPathEntry
// 
//
// PURPOSE: Encapsulates a single entry in the dynamic path of a bookmark.
//
// NOTES:  In MMC2.0 which shipped with WindowsXP, the m_type member could be
//         just one of NDTYP_STRING or NDTYP_CUSTOM. In MMC2.0 that shipped with
//         .net server, this was changed to allow a third possibility - a bitwise OR
//         of NDTYP_STRING and NDTYP_CUSTOM. This is because snap-ins that previously
//         did not implement a CCF_ format and later changed to implement the format
//         would find that their old bookmarks no longer worked.
//
//         The pattern matching strategy has therefore changed to match whatever 
//         data is present in the bookmark.
//
//****************************************************************************
class CDynamicPathEntry : public CXMLObject
{
protected:
    enum PathEntryType
    {
        NDTYP_STRING = 0x01,
        NDTYP_CUSTOM = 0x02
    };

public:
    // comparison
    bool    operator ==(const CDynamicPathEntry &rhs) const;
    bool    operator < (const CDynamicPathEntry &rhs) const;

    SC      ScInitialize(bool bIs10Path, /*[IN,OUT]*/ByteVector::iterator &iter);

    virtual void Persist(CPersistor &persistor);
    DEFINE_XML_TYPE(XML_TAG_DYNAMIC_PATH_ENTRY);
protected:
    BYTE         m_type;         // A combination of one or more flags from the enum PathEntryType - See above note.
    ByteVector   m_byteVector;   // the actual data if it is a custom ID
    std::wstring m_strEntry;     // the actual data if it is a string.
};

/*+-------------------------------------------------------------------------*
 * class CBookmark
 * 
 *
 * PURPOSE: Maintains a persistent representation of a scope node.
 *
 *+-------------------------------------------------------------------------*/
class CBookmark : public CXMLObject
{
    friend class CScopeTree;
    typedef std::list<CDynamicPathEntry> CDynamicPath;

public:
    enum { ID_Unknown = -1 };

    CBookmark(MTNODEID idStatic = ID_Unknown) : m_idStatic (idStatic) , m_bIsFastBookmark(true) {}
    CBookmark(bool bIsFastBookmark)           : m_idStatic (0),         m_bIsFastBookmark(bIsFastBookmark) {}

    virtual ~CBookmark ()           {}
    bool    IsValid  ()      const  { return (m_idStatic != ID_Unknown); }
    bool    IsStatic ()      const  { ASSERT (IsValid());  return (m_dynamicPath.empty()); }
    bool    IsDynamic ()     const  { return (!IsStatic());}
    void    Reset()                 {m_idStatic = ID_Unknown; m_dynamicPath.clear();}

    IStream & Load(IStream &stm);

    // Casts
    operator HBOOKMARK()    const;
    static CBookmark * GetBookmark(HBOOKMARK hbm);

    // XML
    DEFINE_XML_TYPE(XML_TAG_BOOKMARK);
    virtual void Persist(CPersistor &persistor);

public:
    bool operator ==(const CBookmark& other) const;
    bool operator !=(const CBookmark& other) const;
    bool operator < (const CBookmark& other) const;

    void SetFastBookmark(bool b) {m_bIsFastBookmark = b;}

protected:
    MTNODEID        m_idStatic;
    CDynamicPath    m_dynamicPath;

protected:
     bool   m_bIsFastBookmark;
     bool   IsFastBookmark() {return m_bIsFastBookmark;}
};


inline IStream& operator>> (IStream& stm, CBookmark& bm)
{
    return bm.Load(stm);
}

#include "bookmark.inl"

#endif // BOOKMARK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\bookmark.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      bookmark.inl
 *
 *  Contents:  Implementation file for CBookmark
 *
 *  History:   25-Oct-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "uastrfnc.h"	// from $(SHELL_INC_PATH), for unaligned string functions


/*+-------------------------------------------------------------------------*
 * UnalignedValueAt
 *
 * Returns the value at a potentially unaligned address.
 *--------------------------------------------------------------------------*/

template<typename T>
T UnalignedValueAt (UNALIGNED T* pT)
{
	return (*pT);
}


//############################################################################
//############################################################################
//
//  Implementation of class CDynamicPathEntry
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntry::ScInitialize
 *
 * PURPOSE: Initializes the entry from a byte array read in from a console file.
 *
 * PARAMETERS:
 *    bool  bIs10Path : true if the path entry format is that of MMC1.0.
 *    I     iter:    The byte array.
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CDynamicPathEntry::ScInitialize(bool bIs10Path, /*[IN,OUT]*/ByteVector::iterator &iter)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntry::ScInitialize"));

    if(bIs10Path) // an MMC1.0 path entry. Just the display name
    {
        m_type = NDTYP_STRING;
        m_strEntry =  reinterpret_cast<LPCWSTR>(iter);
        iter += (m_strEntry.length() + 1) *sizeof(WCHAR); // bump up the iterator.
    }
    else // a 1.1 or 1.2 path. The first byte contains the type.
    {
        m_type = *iter++; // either NDTYP_STRING or NDTYP_CUSTOM
        switch(m_type)
        {
        default:
            sc = E_UNEXPECTED;
            break;

		case NDTYP_STRING:
		{
			LPCWSTR pszEntry = reinterpret_cast<LPCWSTR>(iter);
            sc = ScCheckPointers(pszEntry);
            if(sc)
                return sc;
                
#ifdef ALIGNMENT_MACHINE
			/*
			 * Bug 128010: if our target machine requires data alignment and
			 * the source is unaligned, make an aligned copy that we can
			 * pass to std::wstring::operator=, which calls wcs* functions
			 * expect aligned data
			 */
			if (!IS_ALIGNED (pszEntry))
			{
				LPWSTR pszNew = (LPWSTR) alloca ((ualstrlenW(pszEntry) + 1) * sizeof(WCHAR));
                sc = ScCheckPointers(pszNew);
                if(sc)
                    return sc;

				ualstrcpyW (pszNew, pszEntry);
				pszEntry = pszNew;
			}
#endif
            m_strEntry = pszEntry;
            // bump the input pointer to the next element
            iter += (m_strEntry.length() + 1) * sizeof (WCHAR);
            break;
		}

        case NDTYP_CUSTOM:
            const SNodeID*  pNodeID = reinterpret_cast<const SNodeID*>(iter); // same binary layout as a SNodeID.
            if(!pNodeID)
                return (sc = E_UNEXPECTED);

			/*
			 * Bug 177492: pNodeID->cBytes may be unaligned, so make an aligned copy of it
			 */
			const DWORD cBytes = UnalignedValueAt (&pNodeID->cBytes);

            m_byteVector.insert(m_byteVector.end(), pNodeID->id, pNodeID->id + cBytes);
            /*if(pNodeID->cBytes==0)
                m_dwFlags = MMC_NODEID_SLOW_RETRIEVAL; */ // shouldn't need this; should not be able to save such a bookmark.

            iter += sizeof (pNodeID->cBytes) + cBytes; // bump up the pointer.
            break;
        }

    }

    return sc;
}

inline bool
CDynamicPathEntry::operator ==(const CDynamicPathEntry &rhs) const
{
    // check the types
    if(!(m_type & rhs.m_type & (NDTYP_CUSTOM | NDTYP_STRING))) // bitwise OR - at least one type must be in common
        return false;

    // if both types implement NDTYP_CUSTOM, use that preferentially. Else, compare based on display names.
    if(m_type & rhs.m_type & NDTYP_CUSTOM)
        return (m_byteVector == rhs.m_byteVector);
    else // (m_type & rhs.m_type & NDTYP_STRING)
        return (m_strEntry   == rhs.m_strEntry);
}

inline bool
CDynamicPathEntry::operator < (const CDynamicPathEntry &rhs) const
{
    // If both have NDTYP_CUSTOM in common, compare byte vector
    // else if both have NDTYP_STRING in common, compare strings.
    // Otherwise (have nothing in common), use m_type to impose the ordering 
    
    if (rhs.m_type & m_type & NDTYP_CUSTOM)
        return  std::lexicographical_compare(m_byteVector.begin(),
                                             m_byteVector.end(),
                                             rhs.m_byteVector.begin(),
                                             rhs.m_byteVector.end());

    else if (rhs.m_type & m_type & NDTYP_STRING)
        return m_strEntry < rhs.m_strEntry;

    else
        return (m_type < rhs.m_type);
}

/*--------------------------------------------------------------------------*
 * InsertScalar
 *
 * Inserts a scalar value of type T into an output stream as a series of
 * the output stream's value_type.
 *--------------------------------------------------------------------------*/

template<typename Container, typename T>
void InsertScalar (Container& c, const T& t)
{
    Container::const_iterator itFrom = reinterpret_cast<Container::const_iterator>(&t);
    std::copy (itFrom, itFrom + sizeof (t), std::back_inserter(c));
}


//############################################################################
//############################################################################
//
//  Implementation of class CBookmark
//
//############################################################################
//############################################################################

inline bool
CBookmark::operator ==(const CBookmark& other) const
{
    return ((m_idStatic     == other.m_idStatic) &&
            (m_dynamicPath == other.m_dynamicPath));
}

inline bool
CBookmark::operator!=(const CBookmark& other) const
{
    return (!(*this == other));
}

inline bool
CBookmark::operator<(const CBookmark& other) const
{
    if (m_idStatic < other.m_idStatic)
        return true;

    if (m_idStatic == other.m_idStatic)
    {
        return std::lexicographical_compare( m_dynamicPath.begin(),
                                             m_dynamicPath.end(),
                                             other.m_dynamicPath.begin(),
                                             other.m_dynamicPath.end() );
    }

    return false;
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmark::HBOOKMARK
 *
 * PURPOSE: Casts a bookmark into an HBOOKMARK
 *
 * RETURNS:
 *    operator
 *
 *+-------------------------------------------------------------------------*/
inline
CBookmark:: operator HBOOKMARK()    const
{
    return reinterpret_cast<HBOOKMARK>(this);
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmark::GetBookmark
 *
 * PURPOSE:  Converts an HBOOKMARK to a CBookmark.
 *
 * PARAMETERS:
 *    HBOOKMARK  hbm :
 *
 * RETURNS:
 *    CBookmark *
 *
 *+-------------------------------------------------------------------------*/
inline CBookmark *
CBookmark::GetBookmark(HBOOKMARK hbm)
{
    return reinterpret_cast<CBookmark *>(hbm);
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmark::Load
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream& stm :
 *
 * RETURNS:
 *    inline IStream&
 *
 *+-------------------------------------------------------------------------*/
inline IStream&
CBookmark::Load(IStream& stm)
{
    // loading from a stream. Convert from one of the legacy formats.

    // 1. Read the static node ID
    stm >> m_idStatic;
    m_dynamicPath.clear();

    // 2. Read the dynamic path
    ByteVector  vDynamicPath;
    ByteVector::iterator iter;
    stm >> vDynamicPath;

    // 2a. If the dynamic path is empty, we're done.
    if(vDynamicPath.empty())
        return (stm);

    // 3. Strip out the unnecessary details like the signature, etc.

    // 3a. Check for a signature
    iter = vDynamicPath.begin();
    bool bIs10Path = true;
    if(memcmp (iter,  BOOKMARK_CUSTOMSTREAMSIGNATURE,
               sizeof(BOOKMARK_CUSTOMSTREAMSIGNATURE)) == 0)
    {
        // throw away the signature and the following version bytes
        iter += (sizeof(BOOKMARK_CUSTOMSTREAMSIGNATURE) + sizeof(DWORD));
        bIs10Path = false; //is a post-MMC1.0 path.
    }

    // create new entries for each piece.
    while(iter != vDynamicPath.end())
    {
        CDynamicPathEntry entry;
        entry.ScInitialize(bIs10Path, iter); //NOTE: iter is an in/out parameter.
        m_dynamicPath.push_back(entry);
    }

    return (stm);
}
/*+-------------------------------------------------------------------------*
 *
 * CBookmark::Persist
 *
 * PURPOSE: Persists the bookmark
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CBookmark::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CBookmark::Persist"));

    // check and persist only valid node ids
    if (persistor.IsStoring() && (m_idStatic == ID_Unknown))
        sc.Throw(E_UNEXPECTED);

    persistor.PersistAttribute(XML_ATTR_BOOKMARK_STATIC, m_idStatic);

    bool bPersistList = persistor.IsLoading() ? (persistor.HasElement(XML_ATTR_BOOKMARK_DYNAMIC_PATH, NULL)) :
                                                (m_dynamicPath.size() > 0);

    if (bPersistList)
        persistor.PersistList(XML_ATTR_BOOKMARK_DYNAMIC_PATH, NULL, m_dynamicPath);
}

/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntry::Persist
 *
 * PURPOSE: Persists the dynamic path entry of the bookmark
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CDynamicPathEntry::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntry::Persist"));

    if ( (m_type & NDTYP_STRING) || persistor.IsLoading())
        persistor.PersistAttribute(XML_ATTR_BOOKMARK_DYN_STRING, m_strEntry, attr_optional);

    if ( (m_type & NDTYP_CUSTOM) || persistor.IsLoading())
    {
        CXMLAutoBinary binData;
        if (persistor.IsStoring())
        {
            if (m_byteVector.size())
            {
                sc = binData.ScAlloc(m_byteVector.size());
                if (sc)
                    sc.Throw();

                CXMLBinaryLock sLock(binData); // unlocks on destructor

                LPBYTE pData = NULL;
                sc = sLock.ScLock(&pData);
                if (sc)
                    sc.Throw();

                std::copy(m_byteVector.begin(), m_byteVector.end(), pData);
            }
        }
        persistor.PersistAttribute(XML_ATTR_BOOKMARK_DYN_CUSTOM, binData, attr_optional);
        if (persistor.IsLoading())
        {
            m_byteVector.clear();
            if (binData.GetSize()) // if there is nothing to read it won't be allocated
            {
                CXMLBinaryLock sLock(binData); // unlocks on destructor

                LPBYTE pData = NULL;
                sc = sLock.ScLock(&pData);
                if (sc)
                    sc.Throw();

                m_byteVector.assign( pData, pData + binData.GetSize() );
            }
        }
    }
    
    if (persistor.IsLoading()) // determine the format(s) available
    {
        m_type = 0;

        if(m_strEntry.size() > 0)
            m_type |= NDTYP_STRING;

        if(m_byteVector.size())
            m_type |= NDTYP_CUSTOM;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\comdbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comdbg.h
//
//--------------------------------------------------------------------------

#ifndef COMDBG_H
#define COMDBG_H

#include <objidl.h>
#include <comdef.h>
#include <atlbase.h>
#include <atlcom.h>
#include "dbg.h"

#ifdef DBG
//#define COMDBG
#endif

#ifdef COMDBG
inline void DumpStorage(IStorage* pStorage)
{
    ASSERT(pStorage != NULL);
    if (pStorage == NULL)
        return;

    STATSTG s;
    HRESULT hr = pStorage->Stat(&s, STATFLAG_DEFAULT);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return;
    TRACE(L"%s->\n", s.pwcsName);
    CoTaskMemFree(s.pwcsName);

    IEnumSTATSTGPtr spElements;
    hr = pStorage->EnumElements(0, NULL, 0, &spElements);
    ASSERT(hr == S_OK || hr == STG_E_ACCESSDENIED);

    if (hr == STG_E_ACCESSDENIED)
        TRACE(L"    (not enumerating contents of write-only storage)\n", s.pwcsName);
    if (hr != S_OK)
        return;

    do
    {
        ULONG numberReturned;
        hr = spElements->Next(1, &s, &numberReturned);
        if (hr != S_OK || numberReturned != 1)
            return;
        if (s.type == STGTY_STORAGE)
            TRACE(L"    [%s]\n", s.pwcsName);
        else 
            TRACE(L"    %s (%u bytes)\n", s.pwcsName, s.cbSize.LowPart);
        CoTaskMemFree(s.pwcsName);
    } while (true);
}

class ProxyReporter
{
public:
    ProxyReporter()
        : m_LastName(L"Unnamed"), m_LastInterface(L"Unknown"), m_LastThis(UINT_PTR(this))
    {
        TRACE(L"<PR>(%s(%s:%X)) is crowning.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    virtual ~ProxyReporter()
    {
        TRACE(L"<PR>(%s(%s:%X)) is dead.\n", GetLastInterface(), GetLastName(), m_LastThis);
    }

protected:
    void Born() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is alive.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void Dying() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is dying.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void CallHome(const wchar_t* from) const
    {
        TRACE(L"<PR>(%s(%s:%X)#%u) calling home from: %s\n", GetLastInterface(), GetLastName(), GetLastThis(), GetRefCount(), from);
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        return m_LastName;
    }

    virtual const wchar_t* GetInterfaceName() const
    {
        return m_LastInterface;
    }

    virtual unsigned GetRefCount() const
    {
        return 0;
    }

private:
    mutable const wchar_t* m_LastName;
    mutable const wchar_t* m_LastInterface;
    mutable UINT_PTR m_LastThis;

    const const wchar_t* GetLastName() const
    {
        return m_LastName = GetInstanceName();
    }

    const const wchar_t* GetLastInterface() const
    {
        return m_LastInterface = GetInterfaceName();
    }

    unsigned GetLastThis() const
    {
        return m_LastThis = UINT_PTR(GetThis());
    }

}; // class ProxyReporter

template<typename Base> 
    class ATLProxyReporter : public Base
{
public:
    ATLProxyReporter()
        : m_InstanceName(L"Unnamed")
    {
        Born();
    }

    virtual ~ATLProxyReporter()
    {
        Dying();
    }

    void InitATLProxyReporter(const wchar_t* instanceName)
    {
        ASSERT(instanceName != NULL);
        m_InstanceName = instanceName;
        CallHome(L"InitATLProxyReporter");
    }

protected:
    ULONG InternalAddRef()
    {
        const ULONG r = Base::InternalAddRef();
        CallHome(L"InternalAddRef(after)");
        return r;
    }

    ULONG InternalRelease()
    {
        CallHome(L"InternalRelease(before)");
        return Base::InternalRelease();
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        ASSERT(m_InstanceName != NULL);
        return m_InstanceName;
    }

    virtual unsigned GetRefCount() const
    {
        return unsigned(m_dwRef);
    }

private:
    const wchar_t* m_InstanceName;

}; // class ATLProxyReporter

class __declspec(uuid("B425E0EC-A086-11d0-8F59-00A0C91ED3C8")) DebugStream : 
    public IStream, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStream()
    {
    }

    virtual ~DebugStream()
    {
    }

    void InitDebugStream(IStream* pStream)
    {
        ASSERT(m_spStream == NULL);
        ASSERT(pStream != NULL);
        m_spStream = pStream;
    }

    BEGIN_COM_MAP(DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStream), DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStream), IStream)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStream)

// IStream
public:
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Read(pv, cb, pcbRead);
        CallHome(SUCCEEDED(hr) ? L"Read" : L"Read(failed!)");
        return hr;
    }
    
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Write(pv, cb, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"Write" : L"Write(failed!)");
        return hr;
    }

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
        CallHome(SUCCEEDED(hr) ? L"Seek" : L"Seek(failed!)");
        return hr;
    }
        
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->SetSize(libNewSize);
        CallHome(SUCCEEDED(hr) ? L"SetSize" : L"SetSize(failed!)");
        return hr;
    }
        
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
        
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Commit(grfCommitFlags);
        CallHome(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
        
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Revert();
        CallHome(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
        
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->LockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"LockRegion" : L"LockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->UnlockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"UnlockRegion" : L"UnlockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Stat(pstatstg, grfStatFlag);
        CallHome(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }
        
    STDMETHOD(Clone)(IStream** ppstm)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Clone(ppstm);
        CallHome(SUCCEEDED(hr) ? L"Clone" : L"Clone(failed!)");
        return hr;
    }

protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStream";
    }

private:
    IStreamPtr m_spStream;
}; // class DebugStream


class __declspec(uuid("B6E77CAC-A0AC-11d0-8F59-00A0C91ED3C8")) DebugStorage : 
    public IStorage, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStorage()
    {
    }

    virtual ~DebugStorage()
    {
        ASSERT(m_spStorage != NULL);
        CallHome(L"~DebugStorage, elements:");
        DumpStorage(m_spStorage);
    }

    void InitDebugStorage(IStorage* pStorage)
    {
        ASSERT(m_spStorage == NULL);
        ASSERT(pStorage != NULL);
        m_spStorage = pStorage;
    }

    BEGIN_COM_MAP(DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStorage), DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStorage), IStorage)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStorage)

// IStorage
public:
    STDMETHOD(CreateStream)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStream(pwcsName, grfMode, reserved1, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStream" : L"CreateStream(failed!)");
        return hr;
    }
        
    STDMETHOD(OpenStream)(const OLECHAR *pwcsName, void *reserved1, DWORD grfMode, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStream(pwcsName, reserved1, grfMode, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStream" : L"OpenStream(failed!)");
        return hr;
    }
    
    STDMETHOD(CreateStorage)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStorage(pwcsName, grfMode, reserved1, reserved2, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStorage" : L"CreateStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(OpenStorage)(const OLECHAR *pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStorage, elements:" : L"OpenStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(CopyTo)(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
    
    STDMETHOD(MoveElementTo)(const OLECHAR *pwcsName, IStorage *pstgDest, const OLECHAR *pwcsNewName, DWORD grfFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->MoveElementTo(pwcsName, pstgDest, pwcsNewName, grfFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"MoveElementTo" : L"MoveElementTo(failed!)");
        return hr;
    }
    
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Commit(grfCommitFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
    
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Revert();
        CallHomeAndDump(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
    
    STDMETHOD(EnumElements)(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG** ppenum)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->EnumElements(reserved1, reserved2, reserved3, ppenum);
        CallHomeAndDump(SUCCEEDED(hr) ? L"EnumElements" : L"EnumElements(failed!)");
        return hr;
    }
    
    STDMETHOD(DestroyElement)(const OLECHAR* pwcsName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->DestroyElement(pwcsName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"DestroyElement" : L"DestroyElement(failed!)");
        return hr;
    }
    
    STDMETHOD(RenameElement)(const OLECHAR *pwcsOldName, const OLECHAR *pwcsNewName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->RenameElement(pwcsOldName, pwcsNewName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"RenameElement" : L"RenameElement(failed!)");
        return hr;
    }
    
    STDMETHOD(SetElementTimes)(const OLECHAR *pwcsName, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetElementTimes(pwcsName, pctime, patime, pmtime);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetElementTimes" : L"SetElementTimes(failed!)");
        return hr;
    }
    
    STDMETHOD(SetClass)(REFCLSID clsid)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetClass(clsid);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetClass" : L"SetClass(failed!)");
        return hr;
    }
    
    STDMETHOD(SetStateBits)(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetStateBits(grfStateBits, grfMask);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetStateBits" : L"SetStateBits(failed!)");
        return hr;
    }
    
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Stat(pstatstg, grfStatFlag);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }

// ProxyReporter
protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStorage";
    }

private:
    IStoragePtr m_spStorage;

    void CallHomeAndDump(const wchar_t* from) const
    {
        CallHome(from);
        DumpStorage(m_spStorage);
    }

}; // class DebugStorage

#endif // COMDBG


/*+-------------------------------------------------------------------------*
 * CreateDebugStream
 *
 * Wrapper on IStorage::CreateStream
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamPtr spStream;
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, &spStream);
    ASSERT(SUCCEEDED(hr) && spStream != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStream** ppStream)
{
    return (CreateDebugStream (pStorage, name, grfMode, name, ppStream));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStream
 *
 * Wrapper on IStorage::OpenStream
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamPtr spStream;
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, &spStream);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStream** ppStream)
{
    return (OpenDebugStream (pStorage, name, grfMode, name, ppStream));
}


/*+-------------------------------------------------------------------------*
 * CreateDebugStorage
 *
 * Wrapper on IStorage::CreateStorage
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, &spStorage);
    ASSERT(SUCCEEDED(hr) && spStorage != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (CreateDebugStorage (pStorage, name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * CreateDebugDocfile
 *
 * Wrapper on StgCreateDocfile
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugDocfile(const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(ppStorage != NULL);
    #ifndef COMDBG
    HRESULT hr = StgCreateDocfile(name, grfMode, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = StgCreateDocfile(name, grfMode, NULL, &spStorage);
    ASSERT(SUCCEEDED(hr) && spStorage != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter((instanceName) ? instanceName : L"<temporary>");
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugDocfile(const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (CreateDebugDocfile (name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStorage
 *
 * Wrapper on IStorage::OpenStorage
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, &spStorage);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (OpenDebugStorage (pStorage, name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStorage
 *
 * Wrapper on StgOpenStorage
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStorage(const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = StgOpenStorage(name, NULL, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = StgOpenStorage(name, NULL, grfMode, NULL, NULL, &spStorage);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStorage(const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (OpenDebugStorage (name, grfMode, name, ppStorage));
}

#endif // COMDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\comptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comptrs.h
//
//--------------------------------------------------------------------------

#ifndef COMPTRS_H
#define COMPTRS_H

#ifndef COMPTR_H
#include <comptr.h>
#endif

#endif // COMPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\condoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       condoc.h
//
//  This file defines interface to access document from node manager side
//--------------------------------------------------------------------------

#pragma once

#if !defined(CONDOC_H_INCLUDED)
#define CONDOC_H_INCLUDED


/***************************************************************************\
 *
 * CLASS:  CConsoleDocument
 *
 * PURPOSE: Defines interface to access document from node manager side
 *
\***************************************************************************/
class CConsoleDocument
{
public:
    virtual SC ScOnSnapinAdded       (PSNAPIN pSnapIn)   = 0;
    virtual SC ScOnSnapinRemoved     (PSNAPIN pSnapIn)   = 0;
    virtual SC ScSetHelpCollectionInvalid()              = 0;
};

#endif // !defined(CONDOC_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\constatbar.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      constatbar.h
 *
 *  Contents:  Interface file for CConsoleStatusBar
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONSTATBAR_H
#define CONSTATBAR_H
#pragma once


class CConsoleStatusBar
{
public:
    virtual SC ScSetStatusText (LPCTSTR pszText) = 0;
};


#endif /* CONSTATBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\comptr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comptr.h
//
//--------------------------------------------------------------------------

#ifndef COMPTR_H
#define COMPTR_H

#pragma warning(disable:4800)
#include <comdef.h>
#define CIP_RETYPEDEF(I) typedef I##Ptr I##CIP;
#define CIP_TYPEDEF(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I); CIP_RETYPEDEF(I);
#define DEFINE_CIP(x)\
	CIP_TYPEDEF(x)

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

CIP_RETYPEDEF(IUnknown);
CIP_RETYPEDEF(IDataObject);
CIP_RETYPEDEF(IStorage);
CIP_RETYPEDEF(IStream);
CIP_RETYPEDEF(IPersistStorage);
CIP_RETYPEDEF(IPersistStream);
CIP_RETYPEDEF(IPersistStreamInit);
CIP_RETYPEDEF(IDispatch);

#endif // COMPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\conframe.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      conframe.h
 *
 *  Contents:  Interface file for CConsoleFrame.
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONFRAME_H
#define CONFRAME_H
#pragma once


struct CreateNewViewStruct;
class CConsoleStatusBar;
class CConsoleView;

class CConsoleFrame
{
public:
    virtual SC ScGetActiveStatusBar   (CConsoleStatusBar*& pStatusBar) = 0;
    virtual SC ScGetActiveConsoleView (CConsoleView*& pConsoleView)    = 0;
    virtual SC ScCreateNewView        (CreateNewViewStruct* pcnvs, 
                                       bool bEmitScriptEvents = true)  = 0;
    virtual SC ScUpdateAllScopes      (LONG lHint, LPARAM lParam)      = 0;
    virtual SC ScGetMenuAccelerators  (LPTSTR pBuffer, int cchBuffer)  = 0;

    virtual SC ScShowMMCMenus         (bool bShow)                     = 0;
};


#endif /* CONFRAME_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\countof.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      countof.h  
 *
 *  Contents:           
 *
 *  History:   12-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __COUNTOF_H__
#define __COUNTOF_H__
#pragma once

/*-------------------------------------------------------------------*/
/* Define a safe function that will return the count of elements     */
/* in an array.  It is safe because it won't compile if the argument */
/* is not an array, whereas the classic macro to do this:            */
/*                                                                   */
/*     #define countof(a)  (sizeof(a) / sizeof(a[0]))                */
/*                                                                   */
/* will compile if given a pointer, but will almost certainly not    */
/* give the expected result.                                         */
/*                                                                   */
/* Unfortunately, the compiler won't compile this yet.               */
/*-------------------------------------------------------------------*/
#if _MSC_VER > 1400
#error See if the compiler can handle the countof<T> template now.
#endif

#ifdef COMPILER_WONT_COMPILE_THIS
    template <typename T, size_t N>
    inline size_t countof(T (&a)[N]) 
        { return N; }
#else
    #define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif


#endif  // __COUNTOF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\contree.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      contree.h
 *
 *  Contents:  Interface file for CConsoleTree
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONTREE_H
#define CONTREE_H
#pragma once


class CConsoleTree
{
public:
    virtual SC ScSetTempSelection    (HTREEITEM htiSelected) = 0;
    virtual SC ScRemoveTempSelection ()                      = 0;
    virtual SC ScReselect            ()                      = 0;
};


#endif /* CONTREE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\conview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      conview.h
 *
 *  Contents:  Interface file for CConsoleView
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONVIEW_H
#define CONVIEW_H
#pragma once


// declarations
class CMemento;
class CContextMenuInfo;
class CConsoleStatusBar;

class CConsoleView
{
public:
    enum WebCommand
    {
        eWeb_Back = 1,
        eWeb_Forward,
        eWeb_Home,
        eWeb_Refresh,
        eWeb_Stop,
    };

    //
    // NOTE: ePane_Tasks is being added to have a pane identifier for
    // the task view pane. Currently no task view information is stored
    // in the pane info array, so the use of ePane_Tasks as an index is
    // of limited value.
    //
    enum ViewPane
    {
        ePane_None = -1,
        ePane_ScopeTree,
        ePane_Results,
        ePane_Tasks,

        // must be last
        ePane_Count,
        ePane_First = ePane_ScopeTree,
        ePane_Last  = ePane_Tasks,
    };

    static bool IsValidPane (ViewPane ePane)
        { return ((ePane >= ePane_First) && (ePane <= ePane_Last)); }

public:
    virtual SC ScCut                        (HTREEITEM htiCut)    = 0;
    virtual SC ScPaste                      ()                    = 0;
    virtual SC ScToggleStatusBar            ()                    = 0;
    virtual SC ScToggleDescriptionBar       ()                    = 0;
    virtual SC ScToggleScopePane            ()                    = 0;
    virtual SC ScToggleTaskpadTabs          ()                    = 0;
    virtual SC ScContextHelp                ()                    = 0;
    virtual SC ScHelpTopics                 ()                    = 0;
    virtual SC ScShowSnapinHelpTopic        (LPCTSTR pszTopic)    = 0;
    virtual SC ScSaveList                   ()                    = 0;
    virtual SC ScGetFocusedItem             (HNODE& hNode, LPARAM& lCookie, bool& fScope) = 0;
    virtual SC ScSetFocusToPane             (ViewPane ePane)      = 0;
    virtual SC ScSelectNode                 (MTNODEID id, bool bSelectExactNode = false) = 0;
    virtual SC ScExpandNode                 (MTNODEID id, bool fExpand, bool fExpandVisually) = 0;
    virtual SC ScShowWebContextMenu         ()                    = 0;
    virtual SC ScSetDescriptionBarText      (LPCTSTR pszDescriptionText) = 0;
    virtual SC ScViewMemento                (CMemento* pMemento)  = 0;
    virtual SC ScChangeViewMode             (int nNewMode)        = 0;
    virtual SC ScJiggleListViewFocus        ()                    = 0;
    virtual SC ScRenameListPadItem          ()                    = 0;
    virtual SC ScOrganizeFavorites          ()                    = 0; // bring up the "Organize Favorites" dialog.
    virtual SC ScLineUpIcons                ()                    = 0; // line up the icons in the list
    virtual SC ScAutoArrangeIcons           ()                    = 0; // auto arrange the icons in the list
    virtual SC ScOnRefresh                  (HNODE hNode, bool bScope, LPARAM lResultItemParam) = 0; // refresh the result pane.
    virtual SC ScOnRename                   (CContextMenuInfo *pContextInfo) = 0; // allows the user to rename the specified item
    virtual SC ScRenameScopeNode            (HMTNODE hMTNode)     = 0; // put the specified scope node into rename mode.

    virtual SC ScGetStatusBar               (CConsoleStatusBar **ppStatusBar) = 0;

    virtual ViewPane GetFocusedPane         ()                    = 0;
    virtual int      GetListSize            ()                    = 0;
    virtual HNODE    GetSelectedNode        ()                    = 0;
    virtual HWND     CreateFavoriteObserver (HWND hwndParent, int nID) = 0;
};



#endif /* CONVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\cpputil.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      cpputil.h
 *
 *  Contents:  Miscellaneous C++ utilities
 *
 *  History:   29-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*
 * add these to a class declaration if you don't want it to be copied
 * and/or assigned
 */
#define DECLARE_NOT_COPIABLE(  ClassName)    private: ClassName           (const ClassName&);    // not implemented
#define DECLARE_NOT_ASSIGNABLE(ClassName)    private: ClassName& operator=(const ClassName&);    // not implemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\events.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       events.h
//
//  History:    09-24-1999 VivekJ created
//--------------------------------------------------------------------------

/************************************************************************
 * This file contains classes that provide support for the Observer pattern,
 * or publish-subscribe.
 *
 * Event sources send notifications to event observers. The parameterized type
 * is the event observer class, or (C++) interface.
 *
 * To use this mechanism, derive your event source class from CEventSource
 * parameterized by the observer class(es) or interface(es). Add a specific observer object
 * to the list of observers by calling the AddObserver function. The observer object class
 * should derive from CObserverBase.
 *
 * When the source wishes to call a particular notification method in the
 * observer class, use ScFireEvent template method.
 * specify observer's method as a 1st parameter. for instance: CMyObserver::MyEvent
 * [optionaly] specify parameters to event as 2nd and following parameters to ScFireEvent
 *
 * All event observer notification methods MUST return SC's.
 *
 * You can not have other method with the same name as event on observer - it won't compile.
 *
 * When sources/observers are deleted, the connection between them is broken automatically.
 * There is no support as yet to manually break a connection, although such a method can
 * be easily added to either the source or observer (make sure both sides of the connection
 * are broken.
 *
 * See the test code at the end of the file as an example.
 ************************************************************************/

// a #define to make it easy to implement only some observer methods.
#define DEFAULT_OBSERVER_METHOD SC sc; return sc;

#include "cpputil.h"
/*+-------------------------------------------------------------------------*
 * class CObserverBase
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CObserverBase;

/*+-------------------------------------------------------------------------*
 * class CEventSourceBase
 *
 *
 * PURPOSE: provides general Event Source interface
 *
 *+-------------------------------------------------------------------------*/
class CEventSourceBase
{
public:
    virtual ~CEventSourceBase() {}
    virtual void UnadviseSource(CObserverBase &observer) =0;

};

/*+-------------------------------------------------------------------------*
 * class _CEventSource
 *
 *
 * PURPOSE: implements connection between event source and observer
 *
 * NOTE:    This class IS NOT intended for external use - use CEventSource instead
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
class _CEventSource : public CEventSourceBase
{
private:
    typedef CObserver *                 POBSERVER;
    typedef _CEventSource<CObserver>    ThisClass;

    // no std::set, or std::map please
    // those cannot be shared by several DLL's
    // see KB article Q172/3/96

    // since some items may be gone and some new added during the operation,
    // std::list is the best choice, since it does not reallocate on insert
    // but that is not enough - see CListIntegrityProtector class below
    struct ObserverData
    {
        POBSERVER pObject;  // pointer to the object
        bool      bDeleted; // true means entry remove pending, pObject not valid
    };

    typedef std::list< ObserverData > CObserverList;

    CObserverList m_observerList;

    // count of active locks.
    // when value is 0, it is safe to remove deleted items from the list.
    int m_nStackDepth;

    // removes deleted items from the list
    void CleanupDeleted();

protected:
    typedef typename CObserverList::iterator   iterator;

    /***************************************************************************\
     *
     * CLASS:  CListIntegrityProtector
     *
     * PURPOSE: locks the list in the owning class from item deletion.
     *          thus assures the list is safe to iterate, the client just
     *          needs to skip deleted entries.
     *          Destructor will release the lock, an in case this is the last
     *          lock - will perforn the cleanup.
     *
     *          this technique is needed, since objects get deleted and created
     *          during the events, so the observer list is changed, which
     *          invalidated the iterators. Using the std::list and postponing
     *          cleanup allowed to deal with 'live' list safelly.
     *
     * USAGE:   Create the object of this class in scope where you need to
     *          make sure the items does not get deleted from the list.
     *
    \***************************************************************************/
    friend class CListIntegrityProtector;
    class CListIntegrityProtector
    {
        DECLARE_NOT_COPIABLE(CListIntegrityProtector)
        DECLARE_NOT_ASSIGNABLE(CListIntegrityProtector)

        ThisClass *m_pOwner;
    public:
        // constructor (increments iterator count)
        CListIntegrityProtector(ThisClass *pOwner) : m_pOwner(pOwner)
        {
            ASSERT(pOwner);
            if (pOwner)
                ++(pOwner->m_nStackDepth);
        }

        // destructor (decrements iterator count - cleans up if not iterators left)
        ~CListIntegrityProtector()
        {
            ASSERT(m_pOwner);
            if ( m_pOwner && ( 0 == --(m_pOwner->m_nStackDepth) ) )
                m_pOwner->CleanupDeleted();
        }
    };

protected:
    CObserverList & GetObserverList() { return m_observerList;}

public:
    _CEventSource() : m_nStackDepth(0) {};
    virtual ~_CEventSource();    // disconnects all listeners

    void _AddObserver(CObserver &observer);
    virtual void  UnadviseSource(CObserverBase &observer); // to disconnect a particular observer. (only disconnects this side)
};

/***************************************************************************\
 *
 * CLASSES:  _CEventSource1 - _CEventSource5
 *
 * PURPOSE: these classes do not add anything to _CEventSource
 *          defining them is just required for using them as base classes
 *          of CEventSource_ [ same class cannot appear twice in base class list]
 *
 * NOTE:    These classes ARE NOT intended for external use
 *
\***************************************************************************/
template<class CObserver> class _CEventSource1 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource2 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource3 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource4 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource5 : public _CEventSource<CObserver> {};


/*+-------------------------------------------------------------------------*
 * CVoid
 *
 * This is a do-nothing class that is used for the _CEventSourceX
 * specializations below.  _CEventSourceX used specializations of "void"
 * and the default types for the Es2-Es5 template parameters of CEventSource
 * used to be "void".  Newer (i.e. Win64) compilers, however, will issue
 * C2182 ("illegal use of type 'void'") and won't allow void to be the
 * default type.
 *--------------------------------------------------------------------------*/
class CVoid {};

/***************************************************************************\
 *
 * SPECIALIZATIONS: _CEventSource1 - _CEventSource5 for void parameters
 *
 * PURPOSE: This allows to have single template for different count of observers.
 *          The specialization defines empty and harmless base clases
 *          for default template parameters
 *
 * NOTE:    These classes ARE NOT intended for external use
 *
\***************************************************************************/
template<> class _CEventSource2<CVoid> {}; // specializes _CEventSource2<CVoid> as empty class
template<> class _CEventSource3<CVoid> {}; // specializes _CEventSource3<CVoid> as empty class
template<> class _CEventSource4<CVoid> {}; // specializes _CEventSource4<CVoid> as empty class
template<> class _CEventSource5<CVoid> {}; // specializes _CEventSource5<CVoid> as empty class

/***************************************************************************\
 *
 * CLASS:   CEventSource
 *
 * PURPOSE: This class implements Event emitting capability to be used by
 *          event-emitter classes derived from it.
 *          Implements ScFireEvent methods and AddObserver method
 *
 * USAGE:   use spacialization of this class as base class for your event-emitter class
 *          See the list of possible usage paterns below:
 *          class CMyClassWithEvents : public CEventSource<CMyObserver> ...
 *          class CMyClassWithEvents : public CEventSource<CMyObserver1, CMyObserver2> ...
 *          ...
 *          class CMyClassWithEvents : public CEventSource<CMyObserver1, CMyObserver2, CMyObserver3, CMyObserver4, CMyObserver5> ...
 *
 * NOTE:    Do not derive from this class more than once - add template parameters instead
 *
\***************************************************************************/
template<class Es1, class Es2 = CVoid, class Es3 = CVoid, class Es4 = CVoid, class Es5 = CVoid>
class CEventSource : public _CEventSource1<Es1>,
                     public _CEventSource2<Es2>, // NOTE: this will be empty class if Es2 == CVoid
                     public _CEventSource3<Es3>, // NOTE: this will be empty class if Es3 == CVoid
                     public _CEventSource4<Es4>, // NOTE: this will be empty class if Es4 == CVoid
                     public _CEventSource5<Es5>  // NOTE: this will be empty class if Es5 == CVoid
{
public:

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer>
     *
     * PURPOSE: implements ScFireEvent for parameter-less events
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass>
    SC ScFireEvent(SC (observerclass::*_EventName)())
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - no parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)();
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1>
     *
     * PURPOSE: implements ScFireEvent for events with one parameter
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1), _P1 p1)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - one parameter"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2>
     *
     * PURPOSE: implements ScFireEvent for events with two parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2), _P1 p1, _P2 p2)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - two parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3>
     *
     * PURPOSE: implements ScFireEvent for events with three parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3), _P1 p1, _P2 p2, _P3 p3)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3, P4>
     *
     * PURPOSE: implements ScFireEvent for events with four parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *    _P4 p4                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3, class _P4>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3, _P4 p4), _P1 p1, _P2 p2, _P3 p3, _P4 p4)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3, p4);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3, P4, P5>
     *
     * PURPOSE: implements ScFireEvent for events with four parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *    _P4 p4                       - parameter to be passed
     *    _P5 p5                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3, class _P4, class _P5>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3, _P4 p4, _P5 p5), _P1 p1, _P2 p2, _P3 p3, _P4 p4, _P5 p5)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3, p4, p5);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::AddObserver<Observer>
     *
     * PURPOSE: adds observer to the list
     *
     * PARAMETERS:
     *    Observer &observer - observer to add to the list
     *
     * RETURNS:
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass>
    void AddObserver(observerclass &observer)
    {
        typedef _CEventSource<observerclass> BC;
        // NOTE: if you are getting the error here, probably you are passing a type
        // derived from actual Observer class to AddObserver(). Please cast it to appr. type
        BC::_AddObserver(observer);
    }
};


/*+-------------------------------------------------------------------------*
 * class CObserverBase
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CObserverBase
{
    typedef CEventSourceBase *      PEVENTSOURCE;

    // no std::set, or std::map please
    // those cannot be shared by several DLL's
    // see KB article Q172/3/96 (Q172396)
    typedef std::list<PEVENTSOURCE> CSourceList;    // list of all event sources that this object is connected to.
    typedef CSourceList::iterator   iterator;

    CSourceList m_sourceList;
    CSourceList & GetSourceList() { return m_sourceList;}

public:
    CObserverBase() {};
    virtual ~CObserverBase();

    void    UnadviseObserver(CEventSourceBase &source); // to disconnect a particular source (this side only)
    void    _AddSource(CEventSourceBase &source);

    void    UnadviseAll();       // disconnects all connections - both sides
};

//############################################################################
//############################################################################
//
//  Implementation of class CObserverBase
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CObserverBase::UnadviseObserver
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CEventSourceBase & source :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CObserverBase::UnadviseObserver(CEventSourceBase &source)
{
    DECLARE_SC(sc, TEXT("CObserverBase::UnadviseObserver"));

    iterator it = std::find( GetSourceList().begin(), GetSourceList().end(), &source );

    // check if found
    if ( it == GetSourceList().end() )
    {
        sc = E_UNEXPECTED;
        return;
    }

    GetSourceList().erase(it);
}


inline void
CObserverBase::_AddSource(CEventSourceBase &source)
{
    GetSourceList().push_back(&source);
}

/*+-------------------------------------------------------------------------*
 *
 * CObserverBase::~CObserverBase
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
inline CObserverBase::~CObserverBase()
{
    // disconnect all sources connected to this observer.
    iterator iter;
    for(iter = GetSourceList().begin(); iter != GetSourceList().end(); iter++)
    {
        (*iter)->UnadviseSource(*this);
    }
}

//############################################################################
//############################################################################
//
//  Implementation of class CEventSource
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * _CEventSource::_AddObserver
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CObserver & observer :
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void
_CEventSource<CObserver>::_AddObserver(CObserver &observer)
{
    ObserverData observerData = { &observer, false /*bDeleted*/ };

    GetObserverList().push_back( observerData );
    observer._AddSource(*this);
}


/*+-------------------------------------------------------------------------*
 *
 * _CEventSource::~_CEventSource
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
_CEventSource<CObserver>::~_CEventSource()
{
    //disconnect all observers connected to this source

    {
        CListIntegrityProtector(this); // protect the list while iterating

        iterator iter;
        for(iter = GetObserverList().begin(); iter != GetObserverList().end(); ++iter)
        {
            if (!iter->bDeleted && iter->pObject)
                iter->pObject->UnadviseObserver(*this);
        }
    }

    ASSERT( m_nStackDepth == 0 );

    GetObserverList().clear();
}

/*+-------------------------------------------------------------------------*
 *
 * _CEventSource<CObserver>::CleanupDeleted()
 *
 * PURPOSE: removes entries marked as deleted
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void _CEventSource<CObserver>::CleanupDeleted()
{
    ASSERT ( m_nStackDepth == 0 );

    for(iterator iter = GetObserverList().begin(); iter != GetObserverList().end();)
    {
        if (iter->bDeleted)
            iter = GetObserverList().erase( iter );
        else
            ++iter; // valid - skip
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CEventSource::UnadviseSource
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CObserver & observer :
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void
_CEventSource<CObserver>::UnadviseSource(CObserverBase &observer)
{
    // we cannot dynamic cast the observer pointer to a CObserver pointer,
    // becuase UnadviseSource is called from ~CObserverBase(), by which time
    // the CObserver sub-object has already been deleted. Instead, we search for
    // the CObserverBase pointer in the Observer List.
    iterator iter, iterNext;
    bool    bFound = false;

    CListIntegrityProtector(this); // protect the list while iterating

    for(iter = GetObserverList().begin(); iter != GetObserverList().end(); iter++)
    {
        if(!iter->bDeleted && static_cast<CObserverBase *>(iter->pObject) == &observer)
        {
            // do not alter the list directly, let the cleanup do the work
            // just mark the entry as invalid
            iter->bDeleted = true;
            iter->pObject = NULL;
            bFound = true;
            break;
        }
    }

    ASSERT(bFound);
}


//############################################################################
//############################################################################
//
//  stoopid test code
//
//############################################################################
//############################################################################
#ifdef TEST_EVENTS

class CTestObserver : public CObserverBase
{
public:
    SC  ScMyEvent(int a)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestObserver2 : public CObserverBase
{
public:
    SC  ScMyEvent(int a)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }

    SC  ScMyEvent2(int a,int d)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestObserver3 : public CObserverBase
{
public:
    SC  ScMyOtherEvent()
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestEventSource : public CEventSource<CTestObserver,CTestObserver2, CTestObserver3>
{
public:
    void FireEvent()
    {
        DECLARE_SC(sc, TEXT("FireEvent"));

        sc = ScFireEvent(CTestObserver::ScMyEvent, 42 /*arg1*/);
        sc = ScFireEvent(CTestObserver2::ScMyEvent2, 42 /*arg1*/, 24 /*arg1*/);
        sc = ScFireEvent(CTestObserver3::ScMyOtherEvent);
    }
};


static void DoEventTest()
{
    CTestEventSource source;
    CTestObserver    observer_1;
    CTestObserver2   observer_2;
    CTestObserver3   observer_3;


    source.AddObserver(observer_2);
    source.AddObserver(observer_3);
    source.AddObserver(observer_1);
    source.FireEvent();     // should fire to observer1 only.

    {
        // new scope
        CTestObserver   observer2;
        source.AddObserver(observer2);
        source.FireEvent();     // should fire to observer1 and observer2.
        // observer2 is deleted here.
    }

    source.FireEvent();     // should fire to observer1 only.

}

class CTestObject
{
public:
    CTestObject()
    {
        DoEventTest();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\eventlock.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       eventlock.h
//
//  This file contains code needed to fire script event in a safer way
//  Locks made on stack will postpone firing the event on particular interface
//  as long as the last lock is released.
//--------------------------------------------------------------------------

#pragma once

#if !defined(EVENTLOCK_H_INCLUDED)
#define EVENTLOCK_H_INCLUDED

#include <queue>
#include "baseapi.h"


/***************************************************************************\
 *
 * CLASS:  CEventBuffer
 *
 * PURPOSE: objects this class maintains the interface locks by exposing 
 *          methods Lock(), Unlock() and IsLocked(); It also implements queue
 *          of script events accessible thru ScEmitOrPostpone(); Events in the queue
 *          will be automatically emited when the last lock is removed by
 *          calling Unlock() method.
 *
 * USAGE:   Object of this class are constucted as global or static variables
 *          per each monitored interface. 
 *          Currently it is used (as static variable) by GetEventBuffer template 
 *          function and is accessed by CEventLock object put on the stack by
 *          LockComEventInterface macro
 *
\***************************************************************************/
class MMCBASE_API CEventBuffer
{
    // structure containing postponed script event
    // since it is a dipinterface call, data consists of pointer to
    // IDispatch interface , disp_id and the array of parameters
    struct DispCallStr
    {
        IDispatchPtr                spDispatch; 
        DISPID                      dispid;
        std::vector<CComVariant>    vars;
    };

	// the following member is not used from anywhere else but from mmcbase.dll - based methods
	// thus it is safe to have it here ( but we need to silence the warning )
#pragma warning(disable:4251)
    // queue of postponed events
    std::queue<DispCallStr> m_postponed;
#pragma warning(default:4251)
    // lock count
    int                     m_locks;

public:
    // constructor. No locks initially
    CEventBuffer();
    ~CEventBuffer();

    // locking methods
    void Lock()     { m_locks++; }
    void Unlock()   { ASSERT(m_locks > 0); if (--m_locks == 0) ScFlushPostponed(); }
    bool IsLocked() { return m_locks != 0; }

    // event emitting / postponing
    SC ScEmitOrPostpone(IDispatch *pDispatch, DISPID dispid, CComVariant *pVar, int count);
private:
    // helper emiting postponed events
    SC ScFlushPostponed();
};

/***************************************************************************\
 *
 * FUNCTION:  GetEventBuffer
 *
 * PURPOSE: This function provides access to static object created in it's body
 *          Having it as template allows us to define as many static objects as
 *          interfaces we have.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventBuffer&  - reference to the static object created inside
 *
\***************************************************************************/
MMCBASE_API CEventBuffer& GetEventBuffer();

/***************************************************************************\
 *
 * CLASS:  CEventLock
 *
 * PURPOSE: Template class to allow simple Lock()/Unlock() functionality
 *          by placing instances of this class on the stack.
 *          Constructor will put a lock on the event interface, destructor
 *          will release it.
 *
 * USAGE:   You can place the lock on stack by constructing object directly 
 *          or by using LockComEventInterface macro (which does the same)
 *
\***************************************************************************/
template <typename _dispinterface>
class MMCBASE_API CEventLock
{
public:

    CEventLock()    {  GetEventBuffer().Lock();    }
    ~CEventLock()   {  GetEventBuffer().Unlock();  }
};

/***************************************************************************\
 *
 * MACRO:  LockComEventInterface
 *
 * PURPOSE: Constructs the object on stack which holds a lock on event interface
 *
\***************************************************************************/
#define LockComEventInterface(_dispinterface) \
    CEventLock<_dispinterface> _LocalEventInterfaceLock;


#endif // !defined(EVENTLOCK_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\enumerator.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      enumerator.h
//
//  Contents:  Supports enumeration for collections of com objects
//
//  History:   14-Oct-99 VivekJ    Created (as comerror.h)
//             08-Mar-2000 AudriusZ separated some code into enumerator.h file
//
//--------------------------------------------------------------------------

#ifndef ENUMERATOR_H_INCLUDED
#define ENUMERATOR_H_INCLUDED
#pragma once

/***************************************************************************\
 *
 * CLASS:  CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>
 *
 * PURPOSE: Implements enumeration for collection class
 *          EnumImplementor class is responsible for implementing these methods:
 *          SC  ScEnumNext(_Position &pos, PDISPATCH & pDispatch); 
 *          SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, _Position &pos);
 *          SC  ScEnumReset(_Position &pos);
 *
\***************************************************************************/
/****** usage tips *******************************************************
 *   Generally you will provide just 2 params to template - this means
 *   the tied object of your base class needs to implement following methods:
 *           ScEnumNext, ScEnumSkip, ScEnumReset;
 *
 *   If you pass same class as the first and the third template parameter, your base class is
 *   required to implement mentioned methods (not the tied object).
 *   It's usefull when you want to have collection and enueration in one class.
 *
 *   You also may specify any other class implementing the methods as the 3rd parameter, 
 *   but then the BaseClass needs to implement method 'ScGetEnumImplementor' returning 
 *   the instance of that class
 *
 *   NOTE1: since it's template class, the BaseClass is not required to define/implement
 *          ScGetTiedObject, when it implements enum methods itself.
 *   NOTE2: But it always IS REQUIRED to define CMyTiedObject type to compile.
 *          (this template class needs it to be anything different than the BaseClass)
 *          It is suggested to typedef it as void : "typedef void CMyTiedObject;"
 *   NOTE3: Make sure CMyTiedObject type is public or protected
 ************************************************************************/
template <class BaseClass, class _Position, class EnumImplementor = BaseClass::CMyTiedObject>
class CMMCNewEnumImpl : public BaseClass
{
    // Methods to get proper implementor for Enum methods
    // simple one when implemented by the base class
    SC ScGetEnumImplementor(BaseClass * &pObj)                { pObj = this; return SC(S_OK); }
    // when implemented by the tied object (default) - also simple
    SC ScGetEnumImplementor(typename BaseClass::CMyTiedObject * &pObj) { return ScGetTiedObject(pObj); }
public:
    STDMETHOD(get__NewEnum)(IUnknown** ppUnk);
};




/*+-------------------------------------------------------------------------*
 * class CMMCEnumerator
 *
 *
 * PURPOSE: General purpose enumerator class. Keyed to a position object,
 *          which is templated.
 *
 *          The following three methods need to be implemented by the tied object:
 *
 *          SC  ScEnumNext(_Position &pos, PDISPATCH & pDispatch); // should return the next element.
 *          SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,
                            * _Position &pos);
 *          SC  ScEnumReset(_Position &pos);
 *
 *          Cloning the enumerator is taken care of automatically.
 *
 * NOTE:    The Position object must have a copy constructor and assignment
 *          operator.
 *+-------------------------------------------------------------------------*/

typedef IEnumVARIANT ** PPENUMVARIANT;
typedef VARIANT *       PVARIANT;

template<class TiedObj, class _Position>
class CMMCEnumerator : 
    public IEnumVARIANT,
    public IMMCSupportErrorInfoImpl<&IID_IEnumVARIANT,     &GUID_NULL>,    // rich error handling
    public CComObjectRoot,
    public CTiedComObject<TiedObj>
{
    typedef CMMCEnumerator<TiedObj, _Position> ThisClass;

    typedef TiedObj CMyTiedObject;

    friend  TiedObj;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // Returns the next celt items starting from the current position
    // in the array rgvar
    STDMETHODIMP Next(unsigned long celt, PVARIANT rgvar, unsigned long * pceltFetched);

    // Skips over the next celt elements in the enumeration sequence.
    STDMETHODIMP Skip(unsigned long celt);

    // Resets the enumeration sequence to the beginning
    STDMETHODIMP Reset();

    // Creates a copy of the current state of enumeration
    STDMETHODIMP Clone(PPENUMVARIANT ppenum);

public:
    // the position object that keeps track of the present location.
    _Position m_position;
};


/*+-------------------------------------------------------------------------*
 * class CMMCArrayEnumBase
 *
 * PURPOSE: General purpose array enumeration base class.
 *          Particularly useful when array of items to be enumerated is initially
 *          available, or when com object creation is not a big penalty and there 
 *          is no need to postpone item creation to when they are requested.
 *
 * USAGE:   typedef your enumerator as CMMCNewEnumImpl parameterized by this class
 *          - or even better - create the instance of CMMCArrayEnum class.
 *          Use Init method passing an array of pointers to items [first, last)
 *+-------------------------------------------------------------------------*/
template <class _CollectionInterface, class _ItemInterface>
class CMMCArrayEnumBase :
    public CMMCIDispatchImpl<_CollectionInterface>,
    public CTiedObject                     // enumerators are tied to it
{
protected:
    typedef void CMyTiedObject; // not tied

public:
    BEGIN_MMC_COM_MAP(CMMCArrayEnumBase)
    END_MMC_COM_MAP()

public:

    // Returns count of items in the collection
    STDMETHODIMP get_Count( PLONG pCount );

    // Returns specified item from collection
    STDMETHODIMP Item( long Index, _ItemInterface ** ppItem );

    // Resets position to the first item in the collection
    ::SC ScEnumReset (unsigned &pos);

    // Returns item from the collection, advances position
    ::SC ScEnumNext  (unsigned &pos, PDISPATCH & pDispatch);

    // Skips the amount of items in enumeration
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, unsigned &pos);

    // Initializes the array with given iterators
    template<typename InIt> 
    void Init(InIt first, InIt last)
    { 
        m_array.clear();
        m_array.reserve(last - first);
        while(first != last)
            m_array.push_back(*first), ++first;
    }

private:

    // data members
    std::vector< CComPtr<_ItemInterface> > m_array;
};

/*+-------------------------------------------------------------------------*
 * class CMMCArrayEnumBase
 *
 * PURPOSE: General purpose array enumeration class.
 *          Particularly useful when array of items to be enumerated is initially
 *          available, or when com object creation is not a big penalty and there 
 *          is no need to postpone item creation to when they are requested.
 *
 * USAGE:   create the instance of CMMCArrayEnum class whenever you need an 
 *          enumerator for the array of objects you have.
 *          Parameterized by collection type and element type;
 *          For instance CMMCArrayEnum< Nodes, Node >
 *          Use Init method passing an array of pointers to items [first, last)
 *
 * EXAMPLE: << skipping error checking for clarity >>
 *          void GetNodes(std::vector<PNODE>& InNodes, PPNODES ppOutNodes)
 *          {
 *              typedef CComObject< CMMCArrayEnum<Nodes, Node> > EnumNodes;
 *              EnumNodes *pNodes = NULL;
 *              EnumNodes::CreateInstance(&pNodes);             // create
 *              pNodes->Init(InNodes.begin(), InNodes.end());   // initialize with array
 *              pNodes->AddRef();                               // addref for caller
 *              *ppOutNodes = pNodes;                           // return
 *          }
 *
 *+-------------------------------------------------------------------------*/
template <class _CollT, class _ItemT>
class CMMCArrayEnum : 
public CMMCNewEnumImpl<CMMCArrayEnumBase<_CollT, _ItemT>, unsigned, CMMCArrayEnumBase<_CollT, _ItemT> >
{
};


// include inline definitions
#include "enumerator.inl"

#endif  // ENUMERATOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\guidhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guidhelp.h
//
//--------------------------------------------------------------------------

#pragma once

// GUID support functions

class CStr;
class CString;

struct IContextMenuCallback;
struct IComponent;

HRESULT ExtractData(   IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       BYTE*        pbData,
                       DWORD        cbData );


/*+-------------------------------------------------------------------------*
 * ExtractString
 *
 * Gets string data representing the given clipboard format from the data
 * object.  StringType must be a type that can accept assignment from
 * LPCTSTR (WTL::CString, CStr, tstring, etc.)
 *--------------------------------------------------------------------------*/

template<class StringType>
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       StringType&  str);

HRESULT GuidToCStr( CStr* pstr, const GUID& guid );
HRESULT GuidToCString(CString* pstr, const GUID& guid );

HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );

HRESULT ExtractObjectTypeCStr( IDataObject* piDataObject, CStr* pstr );
HRESULT ExtractObjectTypeCString( IDataObject* piDataObject, CString* pstr );

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CStr& strDisplayName);
HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CString& strDisplayName);

HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst);

HRESULT AddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    LPOLESTR pszText,
    LPOLESTR pszStatusBarText,
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst);

HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );


/*------------------------------------------------*/
/* declare various relational operators for GUIDs */
/*------------------------------------------------*/

#include <functional>

// template helper CLSID comparison function
#if _MSC_VER <= 1300
// NOTE: extra parameter is added to have different decorated function name for each operator
// or else in debug version (expanded) functions will be linked as one function
// NOTE: VC7 supports template template parameters, which T really should be, but they don't
// work here.  The compiler shouldn't even allow this code, but somehow it magically works.
template <class comparator>
inline bool CompareCLSID (const CLSID& x, const CLSID& y, const comparator * unused = NULL)
#else
template <template <class T> class comparator>
inline bool CompareCLSID (const CLSID& x, const CLSID& y)
#endif
{
    return  x.Data1 != y.Data1 ? comparator<unsigned long> ()(x.Data1 , y.Data1) :
            x.Data2 != y.Data2 ? comparator<unsigned short>()(x.Data2 , y.Data2) :
            x.Data3 != y.Data3 ? comparator<unsigned short>()(x.Data3 , y.Data3) :
            comparator<int>()(memcmp(x.Data4 , y.Data4, sizeof(x.Data4)) , 0);
}

inline bool operator < (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::less>( x , y );
}

inline bool operator > (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::greater>( x , y );
}

inline bool operator <= (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::less_equal>( x , y );
}

inline bool operator >= (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::greater_equal>( x , y );
}

/*--------------------------------------------------------------*/
/* operator== and operator!= for GUIDs are defined in objbase.h */
/*--------------------------------------------------------------*/


#include "guidhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\findview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       findview.h
//
//--------------------------------------------------------------------------

/*+-------------------------------------------------------------------------*
 *
 * FindMMCView
 *
 * PURPOSE: Locates the amcview window that is an ancestor of the specified window.
 *
 * PARAMETERS: 
 *    HWND  hwnd : [in] The window whose ancestor amcview needs to be located
 *
 * RETURNS: 
 *    inline HWND : The ancestor AmcView window, or NULL if not found
 *
 *+-------------------------------------------------------------------------*/
inline HWND FindMMCView(HWND hwnd)
{
    // Get the childframe handle.
    do
    {
        TCHAR buffer[MAX_PATH];
        if (::GetClassName (hwnd, buffer, MAX_PATH))
        {
            if (!_tcscmp (buffer, g_szChildFrameClassName))
                break;
        }
    } while (hwnd = ::GetParent (hwnd));

    // Get the AMCView handle from Childframe handle.
    if (hwnd)
        hwnd = ::GetDlgItem(hwnd, 0xE900 /*AFX_IDW_PANE_FIRST*/);

    return hwnd;
}



/*+-------------------------------------------------------------------------*
 *
 * FindMMCView
 *
 * PURPOSE: Same as above, but allows a takes a CComControlBase reference as the input parameters
 *
 * PARAMETERS: 
 *    CComControlBase& rCtrl :
 *
 * RETURNS: 
 *    HWND WINAPI
 *
 *+-------------------------------------------------------------------------*/
HWND inline FindMMCView(CComControlBase& rCtrl)
{
    HWND hwnd = NULL;

    // Try to get client window from client site or in-place site interfaces
    if (rCtrl.m_spInPlaceSite)
    {
        rCtrl.m_spInPlaceSite->GetWindow(&hwnd);
    }
    else if (rCtrl.m_spClientSite)
    {
        CComPtr<IOleWindow> spWindow;
        if ( SUCCEEDED(rCtrl.m_spClientSite->QueryInterface(IID_IOleWindow, (void **)&spWindow)) )
        {
            spWindow->GetWindow(&hwnd);
        }
    }
   
    return FindMMCView(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\cstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cstr.h
//
//--------------------------------------------------------------------------

#ifndef __STR_H__
#define __STR_H__

#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 

class CStr
{
public:

// Constructors
    CStr();
    CStr(const CStr& stringSrc);
    CStr(TCHAR ch, int nRepeat = 1);
    CStr(LPCSTR lpsz);
    CStr(LPCWSTR lpsz);
    CStr(LPCTSTR lpch, int nLength);
    CStr(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CStr& operator=(const CStr& stringSrc);
    const CStr& operator=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator=(char ch);
#endif
    const CStr& operator=(LPCSTR lpsz);
    const CStr& operator=(LPCWSTR lpsz);
    const CStr& operator=(const unsigned char* psz);

    // string concatenation
    const CStr& operator+=(const CStr& string);
    const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator+=(char ch);
#endif
    const CStr& operator+=(LPCTSTR lpsz);

    friend CStr STRAPI operator+(const CStr& string1,
            const CStr& string2);
    friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
    friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
    friend CStr STRAPI operator+(const CStr& string, char ch);
    friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
    friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
    friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CStr Mid(int nFirst, int nCount) const;
    CStr Mid(int nFirst) const;
    CStr Left(int nCount) const;
    CStr Right(int nCount) const;

    CStr SpanIncluding(LPCTSTR lpszCharSet) const;
    CStr SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void FormatV(LPCTSTR lpszFormat, va_list argList);
    void Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
    // formatting for localization (uses FormatMessage API)
    void __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
    void __cdecl FormatMessage(UINT nFormatID, ...);
#endif

    // Windows support
    BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                        // 255 chars max
    BSTR AllocSysString();
    BSTR SetSysString(BSTR* pbstr);

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

// Implementation
public:
    ~CStr();
    int GetAllocLength() const;

protected:
    // lengths/sizes in characters
    //  (note: an extra character is always allocated)
    LPTSTR m_pchData;           // actual string (zero terminated)
    int m_nDataLength;          // does not include terminating 0
    int m_nAllocLength;         // does not include terminating 0

    // implementation helpers
    void Init();
    void AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    static void SafeDelete(LPTSTR lpch);
    static int SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL STRAPI operator==(const CStr& s1, const CStr& s2);
BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyString;
extern TCHAR strChNil;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStr::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? NULL : _tcslen(lpsz); }
inline CStr::CStr(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
    { return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
    { return (TCHAR)ch + string; }
#endif

inline int CStr::GetLength() const
    { return m_nDataLength; }
inline int CStr::GetAllocLength() const
    { return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
    { return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
    { return (LPCTSTR)m_pchData; }

// String support (windows specific)
inline int CStr::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
    { ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
    { ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
    { _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(int nIndex) const
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline TCHAR CStr::operator[](int nIndex) const
    {
        // same as GetAt

        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline void CStr::SetAt(int nIndex, TCHAR ch)
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);
        ASSERT(ch != 0);

        m_pchData[nIndex] = ch;
    }
inline BOOL STRAPI operator==(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) == 0; }
inline BOOL STRAPI operator!=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) != 0; }
inline BOOL STRAPI operator<(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) < 0; }
inline BOOL STRAPI operator<=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) <= 0; }

// General Exception for memory
class MemoryException
{
public:
    MemoryException(){}
    void DisplayMessage()
    {
    ::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
    }
};

// General Exception for memory
class ResourceException
{
public:
    ResourceException()
    {
    ::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
    }
};

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\enumerator.inl ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      enumerator.inl
//
//  Contents:  Supports enumeration for collections of com objects
//
//  History:   08-Mar-2000 AudriusZ    Created
//
//--------------------------------------------------------------------------

#ifndef ENUMERATOR_INL_INCLUDED
#define ENUMERATOR_INL_INCLUDED
#pragma once

/*+-------------------------------------------------------------------------*
 *
 * CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>::get__NewEnum
 *
 * PURPOSE: Returns new enumerator for collection
 *          in the array rgvar
 *
 * PARAMETERS: 
 *    IUnknown** ppUnk : [out] - new enumerator
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
template <class BaseClass, class _Position, class EnumImplementor>
STDMETHODIMP CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>::get__NewEnum(IUnknown** ppUnk)
{
	MMC_COM_MANAGE_STATE();

    SC  sc;
    EnumImplementor *pEnumImpl = NULL;     //get enum implementor

    // validate the parameter
    sc = ScCheckPointers (ppUnk);
    if (sc)
        return (sc.ToHr());

    *ppUnk = NULL;

    sc = ScGetEnumImplementor(pEnumImpl);
    if(sc)
        return (sc.ToHr());

    // typedef the enumerator
    typedef CComObject<CMMCEnumerator<EnumImplementor, _Position> > CEnumerator;

    // create an instance of the enumerator
    CEnumerator *pEnum = NULL;
    sc = CEnumerator::CreateInstance(&pEnum);
    if (sc)
        return (sc.ToHr());

    if(!pEnum)
        return ((sc = E_UNEXPECTED).ToHr());

    // create a connection between the enumerator and the tied object.
    sc = ScCreateConnection(*pEnum, *pEnumImpl); 
    if(sc)
        return (sc.ToHr());

    // initialize the position using the Reset function
    sc = pEnumImpl->ScEnumReset(pEnum->m_position); 
    if(sc)
        return (sc.ToHr());

    // get the IUnknown from which IEnumVARIANT can be queried
    sc = pEnum->QueryInterface (IID_IUnknown, (void**) ppUnk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}       

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Next
 *
 * PURPOSE: Returns the next celt items starting from the current position
 *          in the array rgvar
 *
 * PARAMETERS: 
 *    unsigned  long :
 *    PVARIANT  rgvar :
 *    unsigned  long :  The number of elements actually fetched
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Next(unsigned long celt, PVARIANT rgvar, 
                                                     unsigned long * pceltFetched)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Next"));

    CMyTiedObject *pTiedObj = NULL;
    PVARIANT       pVar = rgvar;
    unsigned long  celtFetched = 0;
    _Position      posTemp = m_position;
    int            i       = 0;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                 
        goto Error;

    // initialize the variables.
    if(pceltFetched != NULL)
        *pceltFetched = 0;

    // initialize the array
    for(i = 0; i<celt; i++)
        VariantInit(&rgvar[i]);

    for(celtFetched = 0; celtFetched < celt; celtFetched++, pVar++)
    {
        // at this point, we have a valid position.
        IDispatchPtr spDispatch;

        // Get the next element from the tied object.      
        // The returned IDispatch* _must_ have been AddRef'd for us!
        sc = pTiedObj->ScEnumNext(m_position, *(&spDispatch));
        if(sc)
            goto Error;

        if(sc == SC(S_FALSE) )
            goto Cleanup; // return just the elements so far.

        if(spDispatch == NULL)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        // set the dispatch member of the input array to the interface returned
        V_VT       (pVar) = VT_DISPATCH;
        V_DISPATCH (pVar) = spDispatch.Detach();
    }

Cleanup:
    // return the count fetched, if the caller wants it
    if (pceltFetched != NULL)
        *pceltFetched = celtFetched;

    return sc.ToHr();

Error:
    // clear the array.
    for (i=0; i<celt; i++)
        VariantClear(&rgvar[i]);

    //restore the position and set the count to zero.
    m_position = posTemp;
    celtFetched = 0;
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Skip
 *
 * PURPOSE: Skips over the next celt elements in the enumeration sequence.
 *
 * PARAMETERS: 
 *    unsigned  long :
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Skip(unsigned long celt)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Skip"));
    
    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    /*
     * It's too easy for implementers of ScEnumSkip to forget to
     * return S_FALSE if the count fetched is less than the count
     * requested.  We'll take care of that here.
     */
    unsigned long celtSkipped = celt + 1;

    /*
     * It's also easy for implementers of ScEnumNext to forget 
     * that if the enumeration fails, the position needs to 
     * remain unaffected.
     */
    _Position posT = m_position;

    // call the tied object with the position.
    sc = pTiedObj->ScEnumSkip(celt, celtSkipped, posT);
    if (sc)
        return (sc.ToHr());

    /*
     * success, so update the enumeration position
     */
    m_position = posT;

    /*
     * if this assert fails, the implementation of ScEnumSkip either
     * didn't initialize or didn't update celtSkipped
     */
    ASSERT (celtSkipped <= celt);

    if (celtSkipped < celt)
        sc = S_FALSE;
    if (celtSkipped > celt)
        celtSkipped = celt;     // sanity

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Reset
 *
 * PURPOSE: Resets the enumeration sequence to the beginning
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Reset()
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Reset"));
    
    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    // call the tied object with the position.
    sc = pTiedObj->ScEnumReset(m_position);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Clone
 *
 * PURPOSE: Creates a copy of the current state of enumeration
 *
 * PARAMETERS: 
 *    PPENUMVARIANT  ppenum :
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Clone(PPENUMVARIANT ppenum)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Clone"));

    if(!ppenum)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    typedef CComObject<ThisClass> CNewComObject;
    CNewComObject *pNewComObj = NULL;

    // create an instance of the new enumerator.
    sc = CNewComObject::CreateInstance(&pNewComObj);
    if (sc)
        return (sc.ToHr());

    if(!pNewComObj)
        return ((sc = E_UNEXPECTED).ToHr());

    // at this point the new object has been created.
    // Set the position directly from the present state.
    pNewComObj->m_position = m_position;

    // connect the COM object to the tied object
    sc = ScCreateConnection(*pNewComObj, *pTiedObj);
    if(sc)
        return sc.ToHr();

    // addref the new object for the client.
    *ppenum = pNewComObj;
    (*ppenum)->AddRef();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::get_Count
*
* PURPOSE: Returns count of items in the collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
STDMETHODIMP CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::get_Count( PLONG pCount )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::get_Count"));

    // parameter check
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc.ToHr();

    // return the count
    *pCount = m_array.size();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::Item
*
* PURPOSE: Returns specified item from collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
STDMETHODIMP CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::Item( long Index, _ItemInterface ** ppItem )
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::Item"));

    // parameter check
    sc = ScCheckPointers(ppItem);
    if (sc)
        return sc.ToHr();

    // initialization
    *ppItem = NULL;

    // remember - we are 1 based!
    if (Index < 1 || Index > m_array.size())
        return (sc = E_INVALIDARG).ToHr();

    *ppItem = m_array[Index - 1];

    // recheck the pointer
    sc = ScCheckPointers(*ppItem, E_NOINTERFACE);
    if (sc)
        return sc.ToHr();

   (*ppItem)->AddRef();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumReset
*
* PURPOSE: Resets position to the first item in the collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumReset (unsigned &pos) 
{ 
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumReset"));

    pos = 0; 
    return sc; 
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumNext
*
* PURPOSE: Returns item from the collection, advances position
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumNext(unsigned &pos, PDISPATCH & pDispatch)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumNext"));

    // initialize;
    pDispatch = NULL;
    // check the ranges
    if (pos >= m_array.size())
        return sc = S_FALSE;

    // get element
    pDispatch = m_array[pos];

    // recheck the pointer
    sc = ScCheckPointers(pDispatch, E_NOINTERFACE);
    if (sc)
        return sc;

    pDispatch->AddRef();
    ++pos;

    return sc;
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumSkip
*
* PURPOSE: Skips the amount of items in enumeration
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, unsigned &pos)
{
	MMC_COM_MANAGE_STATE();
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumSkip"));

    // no skipped at start
    celtSkipped = 0;

    // check if it's a void task
    if (!celt)
        return sc;

    // are we behind the last item?
    if (pos >= m_array.size())
        return sc = S_FALSE;

    // how far can we go?
    celtSkipped = m_array.size() - pos;
    
    // but go no more than requested
    if (celtSkipped > celt)
        celtSkipped = celt;

    // advance
    pos += celtSkipped;

    // check if we could do as much as requested
    if (celtSkipped < celt)
        return sc = S_FALSE;

    return sc;
}


#endif  // ENUMERATOR_INL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\imageid.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      imageid.h
 *
 *  Contents:  IDs for stock scope/result item images
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef IMAGEID_H
#define IMAGEID_H
#pragma once


/*
 * these IDs correspond to the images in nodemgr\res\nodes[16|32].bmp
 */
enum StockImageIndex
{
    eStockImage_Folder     = 0,
    eStockImage_File       = 1,
    eStockImage_OCX        = 2,
    eStockImage_HTML       = 3,
    eStockImage_Monitor    = 4,
    eStockImage_Shortcut   = 5,
    eStockImage_OpenFolder = 6,
    eStockImage_Taskpad    = 7,
    eStockImage_Favorite   = 8,

    // must be last
    eStockImage_Count,
    eStockImage_Max = eStockImage_Count - 1
};


#endif /* IMAGEID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\memento.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       memento.h
//
//--------------------------------------------------------------------------

#pragma once
#ifndef _MEMENTO_H_
#define _MEMENTO_H_

// forward declarations
class CMemento;
                                     

/*+-------------------------------------------------------------------------*
 * class CMemento
 *
 * PURPOSE: Encapsulates the settings needed to restore a node/view combination.
 *
 *+-------------------------------------------------------------------------*/
class CMemento : public CSerialObject, public CXMLObject
{
public:
    CBookmark       &GetBookmark()         {return m_bmTargetNode;}
    CViewSettings   &GetViewSettings()     {return m_viewSettings;}

    bool            operator==(const CMemento& memento);
    bool            operator!=(const CMemento& memento);

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);  

    virtual void    Persist(CPersistor& persistor);
    DEFINE_XML_TYPE(XML_TAG_MEMENTO);
private:
    CViewSettings   m_viewSettings;
	CBookmark       m_bmTargetNode;
};

#endif // _MEMENTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\macros.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       macros.h
//
//  Contents:   Useful macros
//
//  Macros:     ARRAYLEN
//
//              BREAK_ON_FAIL(hresult)
//              BREAK_ON_FAIL(hresult)
//
//              DECLARE_IUNKNOWN_METHODS
//              DECLARE_STANDARD_IUNKNOWN
//              IMPLEMENT_STANDARD_IUNKNOWN
//
//              SAFE_RELEASE
//
//              DECLARE_SAFE_INTERFACE_PTR_MEMBERS
//
//  History:    6/3/1996   RaviR   Created
//              7/23/1996  JonN    Added exception handling macros
//
//____________________________________________________________________________

#ifndef _MACROS_H_
#define _MACROS_H_


//____________________________________________________________________________
//
//  Macro:      ARRAYLEN
//
//  Purpose:    To determine the length of an array.
//____________________________________________________________________________
//

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


//____________________________________________________________________________
//
//  Macros:     BREAK_ON_FAIL(hresult), BREAK_ON_ERROR(lastError)
//
//  Purpose:    To break out of a loop on error.
//____________________________________________________________________________
//

#define BREAK_ON_FAIL(hr)   if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr)  if (lr != ERROR_SUCCESS) { break; } else 1;

#define RETURN_ON_FAIL(hr)  if (FAILED(hr)) { return(hr); } else 1;

#define THROW_ON_FAIL(hr)   if (FAILED(hr)) { _com_issue_error(hr); } else 1;


//____________________________________________________________________________
//
//  Macros:     DwordAlign(n)
//____________________________________________________________________________
//

#define DwordAlign(n)  (((n) + 3) & ~3)


//____________________________________________________________________________
//
//  Macros:     IF_NULL_RETURN_INVALIDARG
//____________________________________________________________________________
//

#define IF_NULL_RETURN_INVALIDARG(x) \
    { \
        ASSERT((x) != NULL); \
        if ((x) == NULL) \
            return E_INVALIDARG; \
    }

#define IF_NULL_RETURN_INVALIDARG2(x, y) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y)

#define IF_NULL_RETURN_INVALIDARG3(x, y, z) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y) \
    IF_NULL_RETURN_INVALIDARG(z)

#define RELEASE_DATAOBJECT(pDataObj) \
    {\
        if ( (pDataObj) && (!IS_SPECIAL_DATAOBJECT(pDataObj))) \
            pDataObj->Release();\
    }

#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\guidhelp.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      guidhelp.inl
 *
 *  Contents:
 *
 *  History:   13-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "xmlbase.h"	// for CXMLBinary


/*+-------------------------------------------------------------------------*
 * ExtractString
 *
 * Gets string data representing the given clipboard format from the data
 * object.  StringType must be a type that can accept assignment from
 * LPCTSTR (WTL::CString, CStr, tstring, etc.)
 *
 * Many (many!) implementations of IDataObject::GetDataHere incorrectly call
 * CreateStreamOnHGlobal using the HGLOBAL we get them (calling it is
 * incorrect because GetDataHere is specifically forbidden from reallocating
 * the medium that is given to it, which the IStream implementation returned
 * from CreateStreamOnHGlobal will do if it needs more room).
 *
 * We would be more robust if we used TYMED_STREAM in preference to
 * TYMED_HGLOBAL, if the snap-in supported it.
 *--------------------------------------------------------------------------*/

template<class StringType>
HRESULT ExtractString (
	IDataObject*	piDataObject,
	CLIPFORMAT		cfClipFormat,
	StringType&		str)
{
	DECLARE_SC (sc, _T("ExtractString"));

	sc = ScCheckPointers (piDataObject);
	if (sc)
		return (sc.ToHr());

	/*
	 * clear out the output
	 */
	str	= _T("");

    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
	CXMLBinary	xmlBin;

	/*
	 * 1024 isn't a random number.  It must be (at least) this large to
	 * maintain compatibility with buggy snap-ins.
	 */
	const int	cchGrow   = 1024;
	int			cchBuffer = 0;

	/*
	 * to enter the loop the first time
	 */
	sc = STG_E_MEDIUMFULL;

	while (sc == STG_E_MEDIUMFULL)
	{
		/*
		 * increase the buffer size
		 */
		cchBuffer += cchGrow;
		const int cbBuffer = cchBuffer * sizeof(WCHAR);

		/*
		 * Allocate a buffer for the string.  In the reallocation case,
		 * it is safe to store the return value from GlobalReAlloc in
		 * stgmedium.hGlobal because the original handle is also held
		 * in autoGlobal
		 */
		if (cchBuffer == cchGrow)
			sc = xmlBin.ScAlloc   (cbBuffer, true /* fZeroInit */);
		else
			sc = xmlBin.ScRealloc (cbBuffer, true /* fZeroInit */);

		if (sc)
			return (sc.ToHr());

		/*
		 * get the HGLOBAL out of the CXMLBinary
		 */
		stgmedium.hGlobal = xmlBin.GetHandle();
		sc = ScCheckPointers (stgmedium.hGlobal, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		/*
		 * get the string from the data object
		 */
        sc = piDataObject->GetDataHere (&formatetc, &stgmedium);
		// don't check for error here, it'll be checked at the top of the loop
	}

	/*
	 * this will handle all non-STG_E_MEDIUMFULL errors from
	 * IDataObject::GetDataHere
	 */
	if (sc)
    {
        // don't trace these errors
        SC scTemp = sc;
        sc.Clear();
        return scTemp.ToHr();
    }

	/*
	 * lock down the returned data in preparation for copying
	 */
	CXMLBinaryLock lock (xmlBin);

	LPWSTR pchBuffer = NULL;
	sc = lock.ScLock (&pchBuffer);
	if (sc)
		return (sc.ToHr());

	/*
	 * Copy the string.  The termination isn't unjustified paranoia.
	 * Many implementations of IDataObject::GetDataHere don't terminate
	 * their strings.
	 */
	USES_CONVERSION;
	pchBuffer[cchBuffer-1] = 0;
	str = W2CT (pchBuffer);

	return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcdata.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MMCData.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2/27/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef __MMCDATA__H__
#define __MMCDATA__H__

#include "ndmgr.h"
#include "mmcptrs.h"

class CToolBarCtrlEx;
class CMultiSelection;
class CConsoleFrame;
class CConsoleView;
class CConsoleStatusBar;
class CMenuButtonsMgr;
class CAMCViewToolbarsMgr;
class CNode;
class CXMLObject;
class CStdVerbButtons;
class CConsoleDocument;

//////////////////////////////////////////////////////////////////////////////
//
// SConsoleData structure.
//


enum ProgramMode
{
    eMode_Author,
    eMode_User,
    eMode_User_MDI,
    eMode_User_SDI,

    eMode_Count,
    eMode_First = eMode_Author,
    eMode_Last  = eMode_User_SDI,
    eMode_Error = -1
};


enum ConsoleFlags
{
    eFlag_ShowStatusBar                  = 0x00000001,
    eFlag_HelpDocInvalid                 = 0x00000002,
    eFlag_LogicalReadOnly                = 0x00000004,
    eFlag_PreventViewCustomization       = 0x00000008,
                             // DO NOT USE 0x00000010 - an obsolete flag that was used in MMC1.2 to disallow context menus on taskpads.

    eFlag_Default                        = eFlag_ShowStatusBar,
    eFlag_All                            = 0x0000000f,
};

// The current MMC version: 2.0
#define MMC_VERSION_MAJOR 2
#define MMC_VERSION_MINOR 0

#define MakeConsoleFileVer(major_ver,minor_ver) \
        MakeConsoleFileVer_(major_ver, minor_ver, 0)

#define MakeConsoleFileVer_(major_ver,minor_ver,minor_subver) \
        ((DWORD)(((DWORD)(BYTE)(major_ver)<<16)|((WORD)(BYTE)(minor_ver)<<8)|(BYTE)(minor_subver)))


#define GetConsoleFileMajorVersion(eFileVer)    ((BYTE)((eFileVer)>>16))
#define GetConsoleFileMinorVersion(eFileVer)    ((BYTE)(((WORD)(eFileVer)) >> 8))
#define GetConsoleFileMinorSubversion(eFileVer) ((BYTE)(eFileVer))


enum ConsoleFileVersion
{
    FileVer_0100 = MakeConsoleFileVer (1, 0),       // MMC v1.0
    FileVer_0110 = MakeConsoleFileVer (1, 1),       // MMC v1.1
    FileVer_0120 = MakeConsoleFileVer (1, 2),       // MMC v1.2
    FileVer_0200 = MakeConsoleFileVer (2, 0),       // MMC v2.0

    FileVer_Current = FileVer_0200,
    FileVer_Invalid = -1,
};


inline bool IsValidProgramMode (ProgramMode eMode)
{
    return ((eMode >= eMode_First) && (eMode <= eMode_Last));
}

inline bool IsValidFileVersion (ConsoleFileVersion eFileVer)
{
    return ((eFileVer == FileVer_0100) ||
            (eFileVer == FileVer_0110) ||
            (eFileVer == FileVer_0120) ||
            (eFileVer == FileVer_0200));
}

inline bool IsCurrentFileVersion (ConsoleFileVersion eFileVer)
{
    return (eFileVer == FileVer_Current);
}


#define NAVLIST_LEVELS  2

struct SConsoleData
{
    SConsoleData()
        :
        m_hwndMainFrame (NULL),
        m_pConsoleFrame (NULL),
        m_eAppMode      (eMode_Author),
        m_eConsoleMode  (eMode_Author),
        m_dwFlags       (eFlag_Default),
        m_eFileVer      (FileVer_Invalid),
        m_pXMLPersistColumnData(NULL),
        m_pConsoleDocument(NULL)
    {
    }

    ProgramMode GetMode() const
    {
        return (m_eAppMode);
    }

    ProgramMode GetConsoleMode() const
    {
        return (m_eConsoleMode);
    }

    ConsoleFileVersion GetFileVersion() const
    {
        return (m_eFileVer);
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return (m_pConsoleFrame);
    }

    void SetScopeTree (IScopeTree* pScopeTree)
    {
        // hook this console data to the scope tree
        m_spScopeTree = pScopeTree;

        // hook the scope tree to this console data
        m_spScopeTree->SetConsoleData (reinterpret_cast<LPARAM>(this));
    }

    IScopeTreePtr       m_spScopeTree;

    HWND                m_hwndMainFrame;
    CConsoleFrame*      m_pConsoleFrame;
    ProgramMode         m_eAppMode;
    ProgramMode         m_eConsoleMode;
    ConsoleFileVersion  m_eFileVer;
    DWORD               m_dwFlags;

    // Console's column data
    IPersistStreamPtr   m_spPersistStreamColumnData;
    CXMLObject*         m_pXMLPersistColumnData;

    // access to document from node manager side
    CConsoleDocument*   m_pConsoleDocument;
}; // struct SConsoleData


//////////////////////////////////////////////////////////////////////////////
//
// SViewData structure.
//

const DWORD STD_MENUS       = 0x00000001;
const DWORD STD_BUTTONS     = 0x00000002;
const DWORD SNAPIN_MENUS    = 0x00000004;
const DWORD SNAPIN_BUTTONS  = 0x00000008;
const DWORD STATUS_BAR      = 0x80000000;

// The status bar isn't really a "toolbar" per se, but it's visibility
// status is stored with the rest of these bits so we don't have to change
// the view data stream format to accomodate it.
const DWORD ALL_TOOLBARS    = 0x0000000f;

inline DWORD ToolbarsOf (DWORD dwToolbars)
    { return (dwToolbars & ALL_TOOLBARS); }

inline DWORD StatusBarOf (DWORD dwToolbars)
    { return (dwToolbars & STATUS_BAR); }


struct SViewData
{
    friend class CAMCView;

private:
    enum eFlag
    {
        eFlag_ScopePaneVisible    = 0x00000001, // Scope pane visible
        eFlag_DescBarVisible      = 0x00000008,
        eFlag_VirtualList         = 0x00000010,
        eFlag_TaskpadTabsAllowed  = 0x00000040,

        // default for new views
        eFlag_Default             = eFlag_ScopePaneVisible   |
                                    eFlag_TaskpadTabsAllowed
    };

public:
    SViewData() :
        m_dwFlags                   (eFlag_Default),
        m_pStatusBar                (NULL),
        m_pConsoleView              (NULL),
        m_pConsoleData              (NULL),
        m_nViewID                   (0),
        m_hwndView                  (NULL),
        m_hwndChildFrame            (NULL),
        m_hwndListCtrl              (NULL),
        m_lWindowOptions            (0),
        m_pMultiSelection           (NULL),
        m_dwToolbarsDisplayed       (ALL_TOOLBARS | STATUS_BAR),    // enable all
        m_bSnapinChangingView       (FALSE),
        m_pMenuButtonsMgr           (NULL),
        m_pAMCViewToolbarsMgr       (NULL),
        m_pStdVerbButtons           (NULL)
    {
    }

private:
    DWORD   m_dwFlags;          // manipulate with accessors

    void SetFlag (eFlag flag, bool fSet)
    {
        if (fSet)
            m_dwFlags |= flag;
        else
            m_dwFlags &= ~flag;
    }

    bool TestFlag (eFlag flag) const
    {
        return ((m_dwFlags & flag) ? true : false);
    }

public:
    void SetScopePaneVisible    (bool b = true)   { SetFlag (eFlag_ScopePaneVisible,    b); }
    void SetDescBarVisible      (bool b = true)   { SetFlag (eFlag_DescBarVisible,      b); }
    void SetVirtualList         (bool b = true)   { SetFlag (eFlag_VirtualList,         b); }
    void SetTaskpadTabsAllowed  (bool b = true)   { SetFlag (eFlag_TaskpadTabsAllowed,  b); }

public:
    bool IsScopePaneVisible     () const          { return (TestFlag (eFlag_ScopePaneVisible));    }
    bool IsDescBarVisible       () const          { return (TestFlag (eFlag_DescBarVisible));      }
    bool IsVirtualList          () const          { return (TestFlag (eFlag_VirtualList) & HasList()); }
    bool HasList                () const          { return m_rvt.HasList();             }
    bool HasOCX                 () const          { return m_rvt.HasOCX();              }
    bool HasWebBrowser          () const          { return m_rvt.HasWebBrowser();       }
    bool HasListPad             () const          { return (HasWebBrowser() && (NULL != m_hwndListCtrl)); }
    bool AreTaskpadTabsAllowed  () const          { return (TestFlag (eFlag_TaskpadTabsAllowed));  }

    DWORD GetListOptions()         const          { return m_rvt.GetListOptions();}
    DWORD GetHTMLOptions()         const          { return m_rvt.GetHTMLOptions();}
    DWORD GetOCXOptions()          const          { return m_rvt.GetOCXOptions();}
    DWORD GetMiscOptions()         const          { return m_rvt.GetMiscOptions();}

    LPCOLESTR   GetURL()           const          { return m_rvt.GetURL();}
    LPCOLESTR   GetOCX()           const          { return m_rvt.GetOCX();}

    void SetResultViewType(CResultViewType &rvt)  { m_rvt = rvt;}

    CConsoleStatusBar* GetStatusBar()   const     { return (m_pStatusBar); }
    CConsoleView*      GetConsoleView() const     { return (m_pConsoleView); }

    void SetStatusBar (CConsoleStatusBar* pStatusBar)
        { m_pStatusBar = pStatusBar; }

    void SetConsoleView (CConsoleView* pConsoleView)
        { m_pConsoleView = pConsoleView; }

    CMenuButtonsMgr* GetMenuButtonsMgr() const    { return (m_pMenuButtonsMgr); }
    void SetMenuButtonsMgr (CMenuButtonsMgr* pMenuButtonsMgr) { m_pMenuButtonsMgr = pMenuButtonsMgr; }

    CAMCViewToolbarsMgr* GetAMCViewToolbarsMgr() const    { return (m_pAMCViewToolbarsMgr); }
    void SetAMCViewToolbarsMgr (CAMCViewToolbarsMgr* pAMCViewToolbarsMgr) { m_pAMCViewToolbarsMgr = pAMCViewToolbarsMgr; }

    CStdVerbButtons* GetStdVerbButtons() const    { return (m_pStdVerbButtons); }
    void SetStdVerbButtons (CStdVerbButtons* pStdVerbButtons) { m_pStdVerbButtons = pStdVerbButtons; }

private:
    CConsoleStatusBar*      m_pStatusBar;
    CConsoleView*           m_pConsoleView;
    CMenuButtonsMgr*        m_pMenuButtonsMgr;
    CAMCViewToolbarsMgr*    m_pAMCViewToolbarsMgr;
    CStdVerbButtons*        m_pStdVerbButtons;

public:
    SConsoleData*           m_pConsoleData;
    int                     m_nViewID;

    HWND                    m_hwndView;
    HWND                    m_hwndChildFrame;
    HWND                    m_hwndListCtrl;

    long                    m_lWindowOptions;

    IFramePrivatePtr        m_spNodeManager;
    IResultDataPrivatePtr   m_spResultData;
    IImageListPrivatePtr    m_spRsltImageList;
    IConsoleVerbPtr         m_spVerbSet;
    INodeCallbackPtr        m_spNodeCallback;
    IControlbarsCachePtr    m_spControlbarsCache;
    ITaskCallbackPtr        m_spTaskCallback;
    CMultiSelection*        m_pMultiSelection;

    DWORD                   m_dwToolbarsDisplayed;

    // Is snapin changing the view now.
    BOOL                    m_bSnapinChangingView;

    bool IsStandardMenusAllowed()
    {
        return (m_dwToolbarsDisplayed & STD_MENUS);
    }

    bool IsSnapinMenusAllowed()
    {
        return (m_dwToolbarsDisplayed & SNAPIN_MENUS);
    }

protected:
    CResultViewType         m_rvt;
};


#include <pshpack8.h>   // for Win64

struct CreateNewViewStruct
{
    MTNODEID    idRootNode;         // in:  ID of the root node of the view
    long        lWindowOptions;     // in:  window creation options, MMC_NW_OPTION_*
    bool        fVisible;           // in:  is the window visible?
    SViewData*  pViewData;          // out: view data for the new view
    HNODE       hRootNode;          // out: root node of the new view
};

#include <poppack.h>


#endif // __MMCDATA__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcplex_.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCPLEX_H__
#define __MMCPLEX_H__


struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__MMCPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmcerror.cpp
//
//  Contents:  Class definitions for mmc error support code.
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#pragma once

#ifndef _MMCERROR_H
#define _MMCERROR_H

#include "baseapi.h"	// for MMCBASE_API
#include "stddbg.h"		// for ASSERT, COMPILETIME_ASSERT


/*+-------------------------------------------------------------------------*
 * WHY NAMESPACES ?
 * We had problems trying to use "modified" SC when implementing
 * com classes supporting ISupportErrorInfo.
 * we had:
 * [global version] - class CS
 * [local version ] - a template class _SC, derived from SC and typedef'ed to SC.
 * That was not only confusing to us - IDE debugger was also confused and crashing.
 *
 * The solution for that was to separate real types used for implementing.
 * Thus to have typedef'ed definitions both in global and local scope.
 * Plus (to avoid dealing with _SC and __SC and have better IDE support)
 * we have used namespaces mmcerror and comerror, so we endup with this:
 * - mmcerror::SC defining main functionality
 * - comerror::SC (derived from mmcerror::SC) defining modified functionality
 * - global SC - typedef of mmcerror::SC
 * - local  SC - typedef of comerror::SC
 *+-------------------------------------------------------------------------*/
namespace mmcerror {
/*+-------------------------------------------------------------------------*
 * class SC
 *
 * PURPOSE: The definition of a status code. Contains two members, a facility
 *          and an error code. This is a class rather
 *          than a typedef to avoid accidental casts to and from HRESULTS.
 *
 *          SC's hold information about an error: The source of the error,
 *          and the error code itself. These are stored in
 *          different bit fields within the SC.
 *
 * NOTE:    Do not add any virtual functions or member variables to this class.
 *          This could potentially wreak havoc on MMC performance.
 *
 *+-------------------------------------------------------------------------*/
class MMCBASE_API SC
{
public:
    typedef long value_type;

private:
    enum facility_type
    {
        FACILITY_WIN     = 1,     // Defined by the system
        FACILITY_MMC     = 2,     // these map directly to an UINT.
        FACILITY_HRESULT = 3,     // these map directly to an HRESULT
    };


public:
    /*
     * Constructor.  Default copy construction and assignment are sufficient.
     * If they are ever insufficient, that is a clear indication that this
     * class has become heavier than is acceptable for its pervasive pass-by-
     * value usage.
     */
    SC (HRESULT hr = S_OK);

    // equality operators
    bool operator==(const SC &rhs)      const;
    bool operator==(HRESULT hr)  		const;
    bool operator!=(const SC &rhs)      const;
    bool operator!=(HRESULT hr)  		const;

    SC&                 operator= (HRESULT hr)        {MakeSc(FACILITY_HRESULT, hr);	return (*this);}
    SC&                 FromWin32(value_type value)   {MakeSc(FACILITY_WIN,     value);	return (*this);}
    SC&                 FromMMC(value_type value)     {MakeSc(FACILITY_MMC,     value);	return (*this);}
    void                Clear()                       {MakeSc(FACILITY_HRESULT, S_OK); }
    HRESULT             ToHr()          const;
    value_type          GetCode()       const         {return m_value;}

    // get the error message in a preallocated buffer
    void                GetErrorMessage(UINT maxLength, /*[OUT]*/ LPTSTR szMessage) const;
    static void         SetHinst(HINSTANCE hInst);
    static void         SetHWnd(HWND hWnd);

    static DWORD        GetMainThreadID()             {return s_dwMainThreadID;}
    static void         SetMainThreadID(DWORD dwThreadID);

    operator            bool()          const;
    operator            !   ()          const;
    bool                IsError()       const         {return operator bool();}
    static HINSTANCE    GetHinst()                    {ASSERT(s_hInst); return s_hInst;}
    static HWND         GetHWnd()                     {return s_hWnd;}
    DWORD               GetHelpID();
    static LPCTSTR      GetHelpFile();
    void                Throw() throw(SC);
    void                Throw(HRESULT hr) throw();
    void                FatalError()    const;        // ends the application.
    SC&                 FromLastError();
    // does the same trace like in ~SC(); does not change contents.
    void                Trace_() const;
    void                TraceAndClear()               { Trace_();  Clear(); }

private:
    void                MakeSc(facility_type facility, value_type value){m_facility = facility, m_value = value;}

    // accessor functions
    facility_type       GetFacility()   const          {return m_facility;}

private:
    operator HRESULT()                  const; // this is to prevent automatic conversions to HRESULTs by way of bool's.

private:
    facility_type       m_facility;
    value_type          m_value; // the error code.
    static HINSTANCE    s_hInst; // the module that contains all error messages.
    static HWND         s_hWnd;  // the parent HWnd for the error boxes.
    static DWORD        s_dwMainThreadID; // The main thread ID of MMC.

    // debug specific behavior
#ifdef DBG   // Debug SC's hold a pointer to the name of the function they are declared in.
public:
    void          SetFunctionName(LPCTSTR szFunctionName);
    LPCTSTR       GetFunctionName() const;
    void          SetSnapinName  (LPCTSTR szSnapinName) { m_szSnapinName = szSnapinName;}
    LPCTSTR       GetSnapinName() const { return m_szSnapinName;}
    void          CheckCallingThreadID();

    ~SC();
    // SC shouldn't pass the function name around - it's something personal.
    // These will prevent doing so:
    SC& operator = (const SC& other);
    SC(const SC& other);
private:
    LPCTSTR              m_szFunctionName;
    LPCTSTR              m_szSnapinName;

    static UINT          s_CallDepth;
#endif // DBG
};

} // namespace mmcerror

// see "WHY NAMESPACES ?" comment at the top of file
typedef mmcerror::SC SC;

//############################################################################
//############################################################################
//
// the module that contains all the localized strings
//
//############################################################################
//############################################################################
MMCBASE_API HINSTANCE GetStringModule();

//############################################################################
//############################################################################
//
// Functions to format and display an error
//
//############################################################################
//############################################################################
//
// Functions to get an error string from a given SC
//
void    MMCBASE_API FormatErrorIds(   UINT   idsOperation, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage);
void    MMCBASE_API FormatErrorString(LPCTSTR szOperation, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage, BOOL fShort = FALSE);
void    MMCBASE_API FormatErrorShort(SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage);

//
//  Error Boxes - These will eventually allow to user to suppress more error messages
//
int     MMCBASE_API MMCErrorBox(UINT idsOperation,          UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(UINT idsOperation,   SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(LPCTSTR szOperation, SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(                     SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(LPCTSTR szMessage,          UINT fuStyle = MB_ICONSTOP | MB_OK);

//
//  Message Boxes - These cannot be suppressed
//
// This #define eventually will change so that MessageBox's are different and cannot be suppressed
#define MMCMessageBox MMCErrorBox



//############################################################################
//############################################################################
//
//  Debug macros
//
//############################################################################
//############################################################################
#ifdef DBG

MMCBASE_API void TraceError(LPCTSTR sz, const SC& sc);
MMCBASE_API void TraceErrorMsg(LPCTSTR szFormat, ...);

MMCBASE_API void TraceSnapinError(LPCTSTR szError, const SC& sc);

#define DECLARE_SC(_sc, _func)  SC  _sc; sc.SetFunctionName(_func);

// This define is used only within the SC class
#define INCREMENT_CALL_DEPTH() ++s_CallDepth

#define DECREMENT_CALL_DEPTH() --s_CallDepth

///////////////////////////////////////////////////////////////////////
// MMC public interfaces (for snapins) should use this macro as this //
// does some initial error checks and more can be added later.       //
///////////////////////////////////////////////////////////////////////
#define DECLARE_SC_FOR_PUBLIC_INTERFACE(_sc, _func)  SC  _sc;\
                                                     sc.SetFunctionName(_func);\
                                                     sc.SetSnapinName(GetSnapinName());\
                                                     sc.CheckCallingThreadID();

#define IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()           tstring _szSnapinNameForDebug;\
                                                     LPCTSTR GetSnapinName()\
                                                     {\
                                                         return _szSnapinNameForDebug.data();\
                                                     };\
                                                     void SetSnapinName(LPCTSTR sz)\
                                                     {\
                                                         _szSnapinNameForDebug = sz;\
                                                     };
#else

#define TraceError          ;/##/

#define TraceSnapinError    ;/##/

#define DECLARE_SC(_sc, _func)  SC  _sc;

// This define is used only within the SC class
#define INCREMENT_CALL_DEPTH()

#define DECREMENT_CALL_DEPTH()

#define DECLARE_SC_FOR_PUBLIC_INTERFACE(_sc, _func)  SC  _sc;

#define IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

#endif

//############################################################################
//############################################################################
//
//  Parameter validation
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * ScCheckPointers
 *
 * PURPOSE: Checks to make sure that all specified parameters are non-NULL
 *
 * PARAMETERS:
 *    const void * pv1 :
 *
 * RETURNS:
 *    inline SC: S_OK if no error, E_INVALIDARG if any of the pointers are NULL
 *
 *
 * NOTE: Do not replace with a single function and optional parameters; that
 *       is inefficient.
 *+-------------------------------------------------------------------------*/
inline SC  ScCheckPointers(const void * pv1, HRESULT err = E_INVALIDARG)
{
    return (NULL == pv1) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void *pv2, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, const void * pv5, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) || (NULL == pv5) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, const void * pv5, const void* pv6, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) || (NULL == pv5) || (NULL == pv6)) ? err : S_OK;
}

// see "WHY NAMESPACES ?" comment at the top of file
namespace mmcerror {

/*+-------------------------------------------------------------------------*
 * SC::SC
 *
 * Constructor for SC.
 *
 * Default copy construction and assignment are sufficient.  If they are
 * ever insufficient, that is a clear indication that this class has become
 * heavier than is acceptable for its pervasive pass-by-value usage.
 *--------------------------------------------------------------------------*/

inline SC::SC (HRESULT hr /* =S_OK */)
#ifdef DBG
: m_szFunctionName(NULL), m_szSnapinName(NULL)
#endif // DBG
{
    /*
     * This assert will fail if SC's ever derive from a non-trivial base
     * class (i.e. one that has members or virtual functions), or defines
     * virtual functions of its own.  Don't do that!  SC's must remain
     * extremely lightweight.
     */
    COMPILETIME_ASSERT (offsetof (SC, m_facility) == 0);
    INCREMENT_CALL_DEPTH();

    MakeSc (FACILITY_HRESULT, hr);
}


/*+-------------------------------------------------------------------------*
 * SC::operator==
 *
 *
 * PURPOSE: Determines whether two SC's are equivalent.
 *
 *+-------------------------------------------------------------------------*/
inline bool
SC::operator==(const SC &rhs)   const
{
    return ( (m_facility == rhs.m_facility) &&
             (m_value    == rhs.m_value) );
}

inline bool
SC::operator==(HRESULT hr) const
{
    return ( (m_facility == FACILITY_HRESULT) &&
             (m_value    == hr) );
}

inline bool
SC::operator!=(const SC &rhs)   const
{
    return !operator==( rhs );
}

inline bool
SC::operator!=(HRESULT hr) const
{
    return !operator==( hr );
}


// this version compares an hr to an SC.
inline
operator == (HRESULT hr, const SC & sc)
{
    return (sc == hr);
}

#ifdef DBG

/*+-------------------------------------------------------------------------*
 *
 * SC::GetFunctionName
 *
 * PURPOSE: Sets the debug function name to the supplied string.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    LPCTSTR  The function name.
 *
 *+-------------------------------------------------------------------------*/
inline LPCTSTR SC::GetFunctionName() const
{
    return m_szFunctionName;
}


/*+-------------------------------------------------------------------------*
 *
 * SC::CheckCallingThreadID
 *
 * PURPOSE: Check if the method was called on main thread.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline void SC::CheckCallingThreadID()
{
    ASSERT(-1 != GetMainThreadID());

    if (GetMainThreadID() == ::GetCurrentThreadId())
        return;

    TraceSnapinError(_T(", method called from wrong thread"), (*this));
    return;
}



/*+-------------------------------------------------------------------------*
 *
 * SC::~SC
 *
 * PURPOSE: Destructor - Debug mode only. Does a trace if an error occurred.
 *
 *+-------------------------------------------------------------------------*/
inline SC::~SC()
{
    DECREMENT_CALL_DEPTH();

    Trace_();
}

#endif // DBG

/*+-------------------------------------------------------------------------*
 *
 * SC::Trace_()
 *
 * PURPOSE: Does a trace if an error occurred. Does nothing in release mode
 *          It is very convenient when we want to register, but ignore the error -
 *          Simply doing sc.Trace_(); sc.Clear(); does all we need.
 *
 *+-------------------------------------------------------------------------*/
inline void SC::Trace_() const
{

#ifdef DBG

    if (IsError())
    {
        // Distinguish between snapin error & MMC error using the
        // snapin name variable.
        if (m_szSnapinName != NULL)
        {
            TraceSnapinError(_T(""), *this);
        }
        else if (m_szFunctionName != NULL)
        {
            TraceError(m_szFunctionName, *this);
        }
    }

#endif // DBG

}

/*+-------------------------------------------------------------------------*
 *
 * SC::operator bool
 *
 * PURPOSE: Returns a value indicating whether the SC holds an error code
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *    bool : true if error, else false
 *
 *+-------------------------------------------------------------------------*/
inline SC::operator bool() const
{
   if(GetCode()==0)
       return false;   // quick exit if no error

   return (GetFacility()==FACILITY_HRESULT) ? FAILED(GetCode()) : true;
}

inline SC::operator !() const
{
    return (!operator bool());
}


} // namespace mmcerror

/*+-------------------------------------------------------------------------*
 *
 * ScFromWin32
 *
 * PURPOSE: Creates an SC with the facility set to Win32.
 *
 * PARAMETERS:
 *    SC::value_type  code :
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC  ScFromWin32(SC::value_type code)
{
    SC sc;
    sc.FromWin32(code);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScFromMMC
 *
 * PURPOSE: Creates an SC with the facility set to MMC.
 *
 * PARAMETERS:
 *    SC::value_type  code :
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline SC  ScFromMMC(SC::value_type code)
{
    SC sc;
    sc.FromMMC(code);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * HrFromSc
 *
 * PURPOSE: Converts a status code (SC) to an HRESULT. Use sparingly, as this
 *          loses information in the conversion.
 *
 * PARAMETERS:
 *    SC &sc: The SC to convert
 *
 * RETURNS:
 *    inline HRESULT: The converted value.
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline HRESULT HrFromSc(const SC &sc)
{
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * SCODEFromSc
 *
 * PURPOSE: Converts a status code (SC) to an SCODE. Use sparingly, as this
 *          loses information in the conversion.
 *          On 32bit machine SCODE is same as HRESULT.
 *
 * PARAMETERS:
 *    SC &sc: The SC to convert
 *
 * RETURNS:
 *    inline SCODE: The converted value.
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline SCODE SCODEFromSc(const SC &sc)
{
    return (SCODE)sc.ToHr();
}

//***************************************************************************
//
// BufferCbValidate, BufferCchValidate, BufferCchValidateW, BufferCchValidateA
//
// PURPOSE: Validates that a buffer has the specified number of bytes by
//          simulating a hack attack on it. This is done by setting all the
//          bytes in the buffer to some value. In retail builds, this does
//          nothing.
//
// NOTE:    This functions destroys the contents of the buffer, DO NOT
//          use it on [in] data.
//
// RETURNS: 
//    void
//
//****************************************************************************
#ifdef DBG
inline void BufferCbValidate(void *dest, size_t count)
{
    memset(dest, 0xcc, count);
}

inline void BufferCchValidateW(WCHAR *sz, size_t cch)
{
    memset(sz, 0xcc, cch*sizeof(WCHAR));
}

inline void BufferCchValidateA(char *sz, size_t cch)
{
    memset(sz, 0xcc, cch*sizeof(char));
}

// The TCHAR version
#ifdef UNICODE
#define BufferCchValidate BufferCchValidateW
#else // UNICODE
#define BufferCchValidate BufferCchValidateA
#endif //UNICODE

#else  // DBG
#define BufferCbValidate               ;/##/
#define BufferCchValidateW             ;/##/
#define BufferCchValidateA             ;/##/
#define BufferCchValidate              ;/##/
#endif // DBG


#endif //_MMCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcdebug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmctrace.h
//
//  Contents:  Declaration of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef MMCDEBUG_H
#define MMCDEBUG_H
#pragma once

#include "baseapi.h"	// for MMCBASE_API

//--------------------------------------------------------------------------
#ifdef DBG
//--------------------------------------------------------------------------

/*
 * Define a macro to break into the debugger.
 *
 * On Intel, do an inline break.  That'll keep us from breaking
 * inside NTDLL and switching from source mode to disassembly mode.
 */
#ifdef _M_IX86
#define MMCDebugBreak()     _asm { int 3 }
#else
#define MMCDebugBreak()     DebugBreak()
#endif

// forward class declarations
class MMCBASE_API CTraceTag;

typedef CTraceTag * PTRACETAG;
typedef std::vector<PTRACETAG> CTraceTags;

MMCBASE_API CTraceTags * GetTraceTags();     // singleton.

class CStr;
CStr & GetFilename();

extern LPCTSTR const szTraceIniFile;

enum
{
    TRACE_COM2              = 0x0001,
    TRACE_OUTPUTDEBUGSTRING = 0x0002,
    TRACE_FILE              = 0x0004,
    TRACE_DEBUG_BREAK       = 0x0008,
    TRACE_DUMP_STACK        = 0x0010,

    TRACE_ALL               = ( TRACE_COM2 | TRACE_OUTPUTDEBUGSTRING | TRACE_FILE | TRACE_DEBUG_BREAK | TRACE_DUMP_STACK )
};

/*+-------------------------------------------------------------------------*
 * class CTraceTag
 *
 * PURPOSE: Encapsulates a particular trace type.
 *
 * USAGE: Instantiate it with
 *
 *  #ifdef DBG
 *  CTraceTag tagTest( TEXT("TestCategory"), TEXT("TestName"))
 *  #endif
 *
 * Make sure to use STRING LITERALS for the category and name; the tag
 * stores the pointer to the string only.
 *
 * You can also specify which outputs to enable by default. Or, from the
 * traces dialog, each output can be individually enabled/disabled.
 *
 * Add code to use the trace just like a printf statement as follows:
 *
 * example: Trace(tagTest, "Error: %d", hr);
 *
 * The complete Trace statement must be on a single line. If not, use continuation
 * characters (\).
 *+-------------------------------------------------------------------------*/
class MMCBASE_API CTraceTag
{
public:
    CTraceTag(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags = 0);
    ~CTraceTag();
    const LPCTSTR GetCategory()  const   {return m_szCategory;}
    const LPCTSTR GetName()      const   {return m_szName;}

    void    SetTempState()          {m_dwFlagsTemp = m_dwFlags;}
    void    Commit();

    void    SetFlag(DWORD dwMask)   {m_dwFlagsTemp |= dwMask;}
    void    ClearFlag(DWORD dwMask) {m_dwFlagsTemp &= ~dwMask;}

    void    RestoreDefaults()     {m_dwFlags = m_dwDefaultFlags; m_dwFlagsTemp = m_dwDefaultFlags;}

    DWORD   GetFlag(DWORD dwMask) const {return m_dwFlagsTemp & dwMask;}

    void    TraceFn( LPCTSTR szFormat, va_list ) const;

    BOOL    FIsDefault()  const   {return (m_dwFlags == m_dwDefaultFlags);}
    BOOL    FAny()        const   {return (m_dwFlags != 0);}
    BOOL    FCom2()       const   {return (m_dwFlags & TRACE_COM2);}
    BOOL    FDebug()      const   {return (m_dwFlags & TRACE_OUTPUTDEBUGSTRING);}
    BOOL    FFile()       const   {return (m_dwFlags & TRACE_FILE);}
    BOOL    FBreak()      const   {return (m_dwFlags & TRACE_DEBUG_BREAK);}
    BOOL    FDumpStack()  const   {return (m_dwFlags & TRACE_DUMP_STACK);}

    // temp flag functions
    BOOL    FAnyTemp()    const   {return (m_dwFlagsTemp != 0);}

    DWORD   GetAll()              {return m_dwFlags;}

    static CStr& GetFilename();
    static unsigned int& GetStackLevels();


protected:
    // these are designed to be overloaded by a derived class to instrument certain
    // pieces of code as appropriate.
    virtual void    OnEnable()      {}
    virtual void    OnDisable()     {}

private:
    void    OutputString(const CStr &str) const; // sends the specified string to all appropriate outputs.
    void    DumpStack()                   const; // sends the stack trace to all appropriate outputs.

private:
    LPCTSTR         m_szCategory;
    LPCTSTR         m_szName;
    DWORD           m_dwDefaultFlags;
    DWORD           m_dwFlags;
    DWORD           m_dwFlagsTemp;    // thrown away if Cancel is hit in the dialog.
    static HANDLE   s_hfileCom2;
    static HANDLE   s_hfile;
};

MMCBASE_API void Trace(const CTraceTag &, LPCTSTR szFormat, ... );
MMCBASE_API void TraceDirtyFlag    (LPCTSTR szComponent, bool bDirty );   // trace for the dirty flag for persistent objects.
MMCBASE_API void TraceSnapinPersistenceError(LPCTSTR szError);
MMCBASE_API void TraceBaseLegacy   (LPCTSTR szFormat, ... );
MMCBASE_API void TraceConuiLegacy  (LPCTSTR szFormat, ... );
MMCBASE_API void TraceNodeMgrLegacy(LPCTSTR szFormat, ... );

MMCBASE_API void DoDebugTraceDialog();

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TraceBaseLegacy(_T("Release called on NULL interface ptr\n"));
    }
}

#define BEGIN_TRACETAG(_class)                   \
    class _class : public CTraceTag              \
    {                                            \
    public:                                      \
        _class(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags = 0)    \
        : CTraceTag(szCategory, szName, dwDefaultFlags) {}

#define END_TRACETAG(_class, _Category, _Name)   \
    } _tag##_class(_Category, _Name);




//--------------------------------------------------------------------------
#else // DBG
//--------------------------------------------------------------------------

// these macros evaluate to blanks.

#define CTraceTag()
#define MMCDebugBreak()

//          Expand to ";", <tab>, one "/" followed by another "/"
//          (which is //).
//          NOTE: This means the Trace statements have to be on ONE line.
//          If you need multiple line Trace statements, enclose them in
//          a #ifdef DBG block.
#define Trace               ;/##/
#define TraceDirtyFlag      ;/##/
#define TraceCore           ;/##/
#define TraceConuiLegacy    ;/##/
#define TraceNodeMgrLegacy  ;/##/


template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
}

//--------------------------------------------------------------------------
#endif // DBG
//--------------------------------------------------------------------------

#endif  // MMCDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcptrs.h
//
//--------------------------------------------------------------------------

#ifndef MMCPTRS_H
#define MMCPTRS_H
#pragma once

#pragma warning(disable:4800)
#include <comdef.h>     // for _COM_SMARTPTR_TYPEDEF

#define DEFINE_COM_SMARTPTR(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I)


// version 1.0
DEFINE_COM_SMARTPTR(IComponent);                    // IComponentPtr
DEFINE_COM_SMARTPTR(IComponentData);                // IComponentDataPtr
DEFINE_COM_SMARTPTR(IConsole);                      // IConsolePtr
DEFINE_COM_SMARTPTR(IConsole2);                     // IConsole2Ptr
DEFINE_COM_SMARTPTR(IConsoleNameSpace);             // IConsoleNameSpacePtr
DEFINE_COM_SMARTPTR(IConsoleNameSpace2);            // IConsoleNameSpace2Ptr
DEFINE_COM_SMARTPTR(IConsoleVerb);                  // IConsoleVerbPtr
DEFINE_COM_SMARTPTR(IContextMenuCallback);          // IContextMenuCallbackPtr
DEFINE_COM_SMARTPTR(IContextMenuProvider);          // IContextMenuProviderPtr
DEFINE_COM_SMARTPTR(IControlbar);                   // IControlbarPtr
DEFINE_COM_SMARTPTR(IControlbarsCache);             // IControlbarsCachePtr
DEFINE_COM_SMARTPTR(IDocConfig);                    // IDocConfigPtr
DEFINE_COM_SMARTPTR(IExtendContextMenu);            // IExtendContextMenuPtr
DEFINE_COM_SMARTPTR(IExtendControlbar);             // IExtendControlbarPtr
DEFINE_COM_SMARTPTR(IExtendPropertySheet);          // IExtendPropertySheetPtr
DEFINE_COM_SMARTPTR(IExtendPropertySheet2);         // IExtendPropertySheet2Ptr
DEFINE_COM_SMARTPTR(IFramePrivate);                 // IFramePrivatePtr
DEFINE_COM_SMARTPTR(IHeaderCtrl);                   // IHeaderCtrlPtr
DEFINE_COM_SMARTPTR(IHeaderCtrlPrivate);            // IHeaderCtrlPrivatePtr
DEFINE_COM_SMARTPTR(IImageList);                    // IImageListPtr
DEFINE_COM_SMARTPTR(IImageListPrivate);             // IImageListPrivatePtr
DEFINE_COM_SMARTPTR(IMMCListView);                  // IMMCListViewPtr
DEFINE_COM_SMARTPTR(IMenuButton);                   // IMenuButtonPtr
DEFINE_COM_SMARTPTR(INodeCallback);                 // INodeCallbackPtr
DEFINE_COM_SMARTPTR(IPropertySheetCallback);        // IPropertySheetCallbackPtr
DEFINE_COM_SMARTPTR(IPropertySheetProvider);        // IPropertySheetProviderPtr
DEFINE_COM_SMARTPTR(IPropertySheetProviderPrivate); // IPropertySheetProviderPrivatePtr
DEFINE_COM_SMARTPTR(IResultDataCompare);            // IResultDataComparePtr
DEFINE_COM_SMARTPTR(IResultDataPrivate);            // IResultDataPrivatePtr
DEFINE_COM_SMARTPTR(IResultOwnerData);              // IResultOwnerDataPtr
DEFINE_COM_SMARTPTR(IScopeDataPrivate);             // IScopeDataPrivatePtr
DEFINE_COM_SMARTPTR(IScopeTree);                    // IScopeTreePtr
DEFINE_COM_SMARTPTR(IScopeTreeIter);                // IScopeTreeIterPtr
DEFINE_COM_SMARTPTR(ISnapinAbout);                  // ISnapinAboutPtr
DEFINE_COM_SMARTPTR(ISnapinHelp);                   // ISnapinHelpPtr
DEFINE_COM_SMARTPTR(ISnapinHelp2);                  // ISnapinHelp2Ptr
DEFINE_COM_SMARTPTR(IToolbar);                      // IToolbarPtr

// version 1.1
DEFINE_COM_SMARTPTR(IDisplayHelp);                  // IDisplayHelpPtr
DEFINE_COM_SMARTPTR(IEnumTASK);                     // IEnumTASKPtr
DEFINE_COM_SMARTPTR(IExtendTaskPad);                // IExtendTaskPadPtr
DEFINE_COM_SMARTPTR(IRequiredExtensions);           // IRequiredExtensionsPtr
DEFINE_COM_SMARTPTR(IStringTablePrivate);           // IStringTablePrivatePtr
DEFINE_COM_SMARTPTR(ITaskPadHost);                  // ITaskPadHostPtr

// version 1.2
DEFINE_COM_SMARTPTR(IColumnData);                   // IColumnDataPtr
DEFINE_COM_SMARTPTR(IDumpSnapins);                  // IDumpSnapinsPtr
DEFINE_COM_SMARTPTR(IMessageView);                  // IMessageViewPtr
DEFINE_COM_SMARTPTR(IResultDataCompareEx);          // IResultDataCompareExPtr
DEFINE_COM_SMARTPTR(ITaskCallback);                 // ITaskCallbackPtr

// version 2.0
DEFINE_COM_SMARTPTR(IComponent2);                   // IComponent2Ptr
DEFINE_COM_SMARTPTR(IComponentData2);               // IComponentData2Ptr
DEFINE_COM_SMARTPTR(IConsolePower);                 // IConsolePowerPtr
DEFINE_COM_SMARTPTR(IConsolePowerSink);             // IConsolePowerSinkPtr
DEFINE_COM_SMARTPTR(IContextMenuCallback2);         // IContextMenuCallback2Ptr
DEFINE_COM_SMARTPTR(IExtendView);                   // IExtendViewPtr
DEFINE_COM_SMARTPTR(IViewExtensionCallback);        // IViewExtensionCallbackPtr
DEFINE_COM_SMARTPTR(ISnapinProperties);             // ISnapinPropertiesPtr
DEFINE_COM_SMARTPTR(ISnapinPropertiesCallback);     // ISnapinPropertiesCallbackPtr
DEFINE_COM_SMARTPTR(IConsole3);                     // IConsole3
DEFINE_COM_SMARTPTR(INodeProperties);               // INodePropertiesPtr
DEFINE_COM_SMARTPTR(IResultData2);                  // IResultData2Ptr
DEFINE_COM_SMARTPTR(IMMCClipboardDataObject);       // IMMCClipboardDataObjectPtr



#endif // MMCPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MMCUtil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:  ListView_GetItemData
//
//  History:    12/4/1996   RaviR   Created
//____________________________________________________________________________
//

#ifndef _MMCUTIL_H_
#define _MMCUTIL_H_

#define MMC_CLSCTX_INPROC (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)


inline LPARAM ListView_GetItemData(HWND hwnd, int iItem)
{
    LV_ITEM lvi; 
    ZeroMemory(&lvi, sizeof(lvi));

    if (iItem >= 0)
    {
        lvi.iItem  = iItem;
        lvi.mask = LVIF_PARAM;

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
        VERIFY(::SendMessage(hwnd, LVM_GETITEM, 0, (LPARAM)&lvi) == TRUE);
#include "popwarn.h"
    }

    return lvi.lParam;
}

#endif // _MMCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mnemonic.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mnemonic.h
 *
 *  Contents:  Mnemonic helpers
 *
 *  History:   31-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef MNEMONIC_H
#define MNEMONIC_H
#pragma once


/*+-------------------------------------------------------------------------*
 * GetMnemonicChar 
 *
 * Returns the mnemonic character for the input string, 0 if none.
 *--------------------------------------------------------------------------*/

template<class T>
T GetMnemonicChar (const T* pszText, const T** pchMnemonic = NULL)
{
    const T* pchT             = pszText;
    const T  chMnemonicMarker = '&';
    T        chMnemonic       = 0;

    // find the mnemonic character
    for (bool fContinue = true; fContinue; )
    {
        // find the next mnemonic marker
        while ((*pchT != 0) && (*pchT != chMnemonicMarker))
            pchT++;

        // no mnemonic marker?
        if (*pchT != chMnemonicMarker)
            break;

        switch (*++pchT)
        {
            // double mnemonic marker, keep going
            case chMnemonicMarker:
                pchT++;
                break;

            // end of string, no mnemonic
            case 0:
                fContinue = false;
                break;

            // found a mnemonic
            default:
                if (pchMnemonic != NULL)
                    *pchMnemonic = pchT;

                chMnemonic = *pchT;
                fContinue  = false;
                break;
        }
    }

    return (chMnemonic);
}


#endif /* MNEMONIC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\modulepath.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       modulepath.h
//
//--------------------------------------------------------------------------

#pragma once

#if !defined(__MODULEPATH_H_INCLUDED__)
#define __MODULEPATH_H_INCLUDED__

#include "cstr.h"

/***************************************************************************\
 *
 * Class:  CModulePath
 *
 * PURPOSE: groups static methods needed to set correct module paths in the registry
 *          Having a class here (not functions) allows to link only one instance
 *			of the methods per module.
 * NOTE:    it uses global _Module, which is different for each DLL.
 *
\***************************************************************************/
class CModulePath
{
public:
	/***************************************************************************\
	 *
	 * METHOD:  MakeAbsoluteModulePath
	 *
	 * PURPOSE: makes absolute path by prepending the directory of current module.
	 *			If file is in system directory and platform supports that,
	 *			method replaces path with "%SystemRoot%\system32" or similar.
	 *
	 * PARAMETERS:
	 *    const CStr& str - module name.
	 *
	 * RETURNS:
	 *    CStr    - result path (empty if cannot be calculated)
	 *
	\***************************************************************************/
	static CStr MakeAbsoluteModulePath(const CStr& str)
	{
		// if the string contains path - do not change it
		CStr strModulePath;
		if ( ( str.Find(_T('\\')) != -1 ) || ( str.Find(_T('/')) != -1 ) )
		{
			strModulePath = str;
		}
		else
		{
            /*
             * get a buffer for the module filename; if it failed,
             * return empty string
             */
            LPTSTR pszModulePath = strModulePath.GetBuffer(_MAX_PATH);
            if (pszModulePath == NULL)
				return _T("");

			// else append the module directory
			DWORD dwPathLen = ::GetModuleFileName(_Module.GetModuleInstance(),
												  pszModulePath,
												  _MAX_PATH );
			strModulePath.ReleaseBuffer();

			// if encountered problems with a path - return empty string
			if ( dwPathLen == 0 )
				return _T("");

			int iLastSlashPos = strModulePath.ReverseFind(_T('\\'));
			// if we cannot separate the filename - cannot append it to the file
			if (iLastSlashPos == -1)
				return _T("");

			//not subtract the file name
			strModulePath = strModulePath.Left(iLastSlashPos + 1) + str;
		}

		// now see it it matches system directory ...

		// get system dir
		CStr strSystemPath;
        LPTSTR pszSystemPath = strSystemPath.GetBuffer(_MAX_PATH);
        if (pszSystemPath == NULL)
            return strModulePath;

		DWORD dwPathLen = ::GetSystemDirectory( pszSystemPath, _MAX_PATH);
		strSystemPath.ReleaseBuffer();

		// if encountered problems with system path - return what we have
		if ( dwPathLen == 0 )
			return strModulePath;

		// now compare the path and substitute with the environment variable
		// [ if path is not in the system dir - use the value we already have ]
		if ( PlatformSupports_REG_EXPAND_SZ_Values() &&
			(_tcsnicmp( strSystemPath, strModulePath, strSystemPath.GetLength() ) == 0) )
		{
			CStr strSystemVariable = (IsNTPlatform() ? _T("%SystemRoot%\\System32") :
													   _T("%WinDir%\\System"));

			// path is in the system dir - replace it with environment var
			strModulePath = strSystemVariable + strModulePath.Mid(strSystemPath.GetLength());
		}

		return strModulePath;
	}

	/***************************************************************************\
	 *
	 * METHOD:  IsNTPlatform
	 *
	 * PURPOSE: checks current platform
	 *
	 * RETURNS:
	 *    bool    - true if application is running on NT platform
	 *
	\***************************************************************************/
	static bool IsNTPlatform()
	{
		// Find out OS version.
		OSVERSIONINFO versInfo;
		versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		BOOL bStat = ::GetVersionEx(&versInfo);
		ASSERT(bStat);
		return (versInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
	}

	/***************************************************************************\
	 *
	 * METHOD:  PlatformSupports_REG_EXPAND_SZ_Values
	 *
	 * PURPOSE: checks current platform capabilities
	 *
	 * RETURNS:
	 *    bool   - true if platform supports REG_EXPAND_SZ values in registry
	 *
	\***************************************************************************/
	static bool PlatformSupports_REG_EXPAND_SZ_Values()
	{
		// Find out OS version.
		OSVERSIONINFO versInfo;
		versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		BOOL bStat = ::GetVersionEx(&versInfo);
		ASSERT(bStat);

		// NT supports it...
		if (versInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
			return true;

		// for 9x to support REG_EXPAND_SZ it should be Win98 at least
		// But even on winME OLE does not support REG_EXPAND_SZ (despite the OS does)
		// so we put the absolute path anyway
		return false;
	}
};

#endif // !defined(__MODULEPATH_H_INCLUDED__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmctempl.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCTEMPL_H__
#define __MMCTEMPL_H__

#ifndef __MMCPLEX_H__
    #include <mmcplex_.h>
#endif

#ifdef ASSERT_VALID
#undef ASSERT_VALID
#endif

#define ASSERT_VALID(pOb)  


#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)


#ifndef _INC_NEW
    #include <new.h>
#endif


#ifndef __AFX_H__
struct __POSITION {};
typedef __POSITION *POSITION;
#endif

#define BEFORE_START_POSITION ((POSITION)-1L)


inline              
BOOL IsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite = TRUE )
{
    return TRUE;
}


template<class TYPE>
inline void ConstructElements(TYPE* pElements, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pElements, nCount * sizeof(TYPE)));

    // first do bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));

    // then call the constructor(s)
    for (; nCount--; pElements++)
        ::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void DestructElements(TYPE* pElements, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pElements, nCount * sizeof(TYPE)));

    // call the destructor(s)
    for (; nCount--; pElements++)
        pElements->~TYPE();
}

template<class TYPE>
inline void CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pDest, nCount * sizeof(TYPE)));
    ASSERT(nCount == 0 ||
        IsValidAddress(pSrc, nCount * sizeof(TYPE)));

    // default is element-copy using assignment
    while (nCount--)
        *pDest++ = *pSrc++;
}


template<class TYPE, class ARG_TYPE>
BOOL CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    ASSERT(IsValidAddress(pElement1, sizeof(TYPE), FALSE));
    ASSERT(IsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT HashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(DWORD_PTR)key) >> 4;
}



/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray
{
public:
// Construction
    CArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CArray& src);
    void Copy(const CArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
    ASSERT_VALID(this);

    if (m_pData != NULL)
    {
        DestructElements<TYPE>(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DestructElements<TYPE>(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        ConstructElements<TYPE>(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = m_nSize / 8;
            nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        if(NULL == pNewData)
        {
            ASSERT(FALSE);
            return;
        }
        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);
        ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
    ASSERT_VALID(this);
    ASSERT(this != &src);   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
    ASSERT_VALID(this);
    ASSERT(this != &src);   // cannot append to itself

    SetSize(src.m_nSize);
    CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            if(NULL == pNewData)
            {
                ASSERT(FALSE);
                return;
            }
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // destroy intial data before copying over it
        DestructElements<TYPE>(&m_pData[nOldSize], nCount);
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        ConstructElements<TYPE>(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DestructElements<TYPE>(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}



/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:
// Construction
    CList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    POSITION AddHead(ARG_TYPE newElement);
    POSITION AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CList* pNewList);
    void AddTail(CList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    TYPE& GetNext(POSITION& rPosition); // return *Position++
    TYPE GetNext(POSITION& rPosition) const; // return *Position++
    TYPE& GetPrev(POSITION& rPosition); // return *Position--
    TYPE GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position);
    TYPE GetAt(POSITION position) const;
    void SetAt(POSITION pos, ARG_TYPE newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
    POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    POSITION FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
    { CNode* pNode = (CNode*) pos;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
    ASSERT_VALID(this);

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DestructElements<TYPE>(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    ASSERT(m_pNodeFree != NULL);  // we must have something

    CList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow

    ConstructElements<TYPE>(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DestructElements<TYPE>(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
    ASSERT_VALID(this);

    ASSERT(pNewList != NULL);
    ASSERT_VALID(pNewList);

    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
    ASSERT_VALID(this);
    ASSERT(pNewList != NULL);
    ASSERT_VALID(pNewList);

    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
    ASSERT_VALID(this);
    ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
    ASSERT(IsValidAddress(m_pNodeHead, sizeof(CNode)));

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
    ASSERT_VALID(this);
    ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
    ASSERT(IsValidAddress(m_pNodeTail, sizeof(CNode)));

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeHead);
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeTail);
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
    ASSERT_VALID(this);

    CNode* pOldNode = (CNode*) position;
    ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
    ASSERT_VALID(this);

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (CompareElements<TYPE>(&pNode->data, &searchValue))
            return (POSITION)pNode;
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CMap(int nBlockSize = 10);

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    POSITION GetStartPosition() const;
    void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    ASSERT_VALID(this);
    ASSERT(m_nCount == 0);
    ASSERT(nHashSize > 0);

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        if(m_pHashTable)
        {
            memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
        }
        else
        {
            ASSERT(FALSE);
            m_nHashTableSize = 0;
            return;
        }
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    ASSERT_VALID(this);

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DestructElements<VALUE>(&pAssoc->value, 1);
                DestructElements<KEY>(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
        // chain them into free list
        CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    ASSERT(m_pFreeList != NULL);  // we must have something

    CMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow
    ConstructElements<KEY>(&pAssoc->key, 1);
    ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DestructElements<VALUE>(&pAssoc->value, 1);
    DestructElements<KEY>(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (CompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    ASSERT_VALID(this);

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    ASSERT_VALID(this);

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    ASSERT_VALID(this);

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (CompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    ASSERT_VALID(this);
    ASSERT(m_pHashTable != NULL);  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    ASSERT(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        ASSERT(pAssocRet != NULL);  // must find something
    }

    // find next association
    ASSERT(IsValidAddress(pAssocRet, sizeof(CAssoc)));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (POSITION) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
    // Accessing elements
    TYPE GetAt(int nIndex) const
        { return (TYPE)BASE_CLASS::GetAt(nIndex); }
    TYPE& ElementAt(int nIndex)
        { return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
    void SetAt(int nIndex, TYPE ptr)
        { BASE_CLASS::SetAt(nIndex, ptr); }

    // Potentially growing the array
    void SetAtGrow(int nIndex, TYPE newElement)
       { BASE_CLASS::SetAtGrow(nIndex, newElement); }
    int Add(TYPE newElement)
       { return BASE_CLASS::Add(newElement); }
    int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
       { return BASE_CLASS::Append(src); }
    void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
        { BASE_CLASS::Copy(src); }

    // Operations that move elements around
    void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
        { BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
    void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
       { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

    // overloaded operator helpers
    TYPE operator[](int nIndex) const
        { return (TYPE)BASE_CLASS::operator[](nIndex); }
    TYPE& operator[](int nIndex)
        { return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
    CTypedPtrList(int nBlockSize = 10)
        : BASE_CLASS(nBlockSize) { }

    // peek at head or tail
    TYPE& GetHead()
        { return (TYPE&)BASE_CLASS::GetHead(); }
    TYPE GetHead() const
        { return (TYPE)BASE_CLASS::GetHead(); }
    TYPE& GetTail()
        { return (TYPE&)BASE_CLASS::GetTail(); }
    TYPE GetTail() const
        { return (TYPE)BASE_CLASS::GetTail(); }

    // get head or tail (and remove it) - don't call on empty list!
    TYPE RemoveHead()
        { return (TYPE)BASE_CLASS::RemoveHead(); }
    TYPE RemoveTail()
        { return (TYPE)BASE_CLASS::RemoveTail(); }

    // add before head or after tail
    POSITION AddHead(TYPE newElement)
        { return BASE_CLASS::AddHead(newElement); }
    POSITION AddTail(TYPE newElement)
        { return BASE_CLASS::AddTail(newElement); }

    // add another list of elements before head or after tail
    void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
        { BASE_CLASS::AddHead(pNewList); }
    void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
        { BASE_CLASS::AddTail(pNewList); }

    // iteration
    TYPE& GetNext(POSITION& rPosition)
        { return (TYPE&)BASE_CLASS::GetNext(rPosition); }
    TYPE GetNext(POSITION& rPosition) const
        { return (TYPE)BASE_CLASS::GetNext(rPosition); }
    TYPE& GetPrev(POSITION& rPosition)
        { return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
    TYPE GetPrev(POSITION& rPosition) const
        { return (TYPE)BASE_CLASS::GetPrev(rPosition); }

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position)
        { return (TYPE&)BASE_CLASS::GetAt(position); }
    TYPE GetAt(POSITION position) const
        { return (TYPE)BASE_CLASS::GetAt(position); }
    void SetAt(POSITION pos, TYPE newElement)
        { BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
    CTypedPtrMap(int nBlockSize = 10)
        : BASE_CLASS(nBlockSize) { }

    // Lookup
    BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
        { return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

    // Lookup and add if not there
    VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
        { return (VALUE&)BASE_CLASS::operator[](key); }

    // add a new key (key, value) pair
    void SetAt(KEY key, VALUE newValue)
        { BASE_CLASS::SetAt(key, newValue); }

    // removing existing (key, ?) pair
    BOOL RemoveKey(KEY key)
        { return BASE_CLASS::RemoveKey(key); }

    // iteration
    void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
        { BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
            (BASE_CLASS::BASE_VALUE&)rValue); }
};


#endif //__MCTEMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\mmcx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcx.h
//
//--------------------------------------------------------------------------

#ifndef MMCX_H
#define MMCX_H
#include <bool.h>

// This avoids "warning C4290: C++ Exception Specification ignored"
// JonN 12/16/96
#pragma warning(4:4290)

class MMCX
	{
	public: enum Code
		{
		InvalidInstanceData,
		InvalidParameter,
		InvalidPointer,
		InvalidVersion,
		UnableToCreateStorage,
		UnableToCreateStream,
		UnableToDestroyElement,
		UnableToSave,
		UnableToLoad,
		UnableToLoadSomePortionOfTheTree,
		UnableToOpenStorage,
		UnableToOpenStream,
		UnableToWriteToStream,
		Unknown,
		};

	public: MMCX() throw()
		: m_Code(Unknown)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		}

	public: MMCX(Code c, const TCHAR* file, int line) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(file), m_Line(line)
			#endif
		{
		}

	public: MMCX(Code c) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		}

	public: MMCX(const MMCX& e) throw()
		: m_Code(e.m_Code)
			#ifdef _DEBUG
			, m_File(e.m_File), m_Line(e.m_Line)
			#endif
		{
		}

	public: ~MMCX() throw()
		{
		}

	public: MMCX& operator=(const MMCX& e) throw()
		{
		m_Code = e.m_Code;
		#ifdef _DEBUG
		m_File = e.m_File;
		m_Line = e.m_Line;
		#endif
		return *this;
		}

	public: bool operator==(Code c) const throw()
		{
		return m_Code == c;
		}

	public: bool operator==(const MMCX& m) const throw()
		{
		return operator==(m.m_Code);
		}

	public: bool operator!=(Code c) const throw()
		{
		return m_Code != c;
		}

	public: bool operator!=(const MMCX& m) const throw()
		{
		return operator!=(m.m_Code);
		}

	public: Code GetCode() const throw()
		// Returns the error code.
		{
		return m_Code;
		}

	public: const _TCHAR* GetDescription() const throw()
		{
		// This may be less efficeint than a lookup table, but is
		// only used in debug builds, and is much more maintainable (the
		// table doesn't have to be kept in exact sync with the code
		// enumerations).
		switch (m_Code)
			{
			case InvalidInstanceData:
				return _T("Invalid instance data");
			case InvalidParameter:
				return _T("Invalid parameters passed to a function");
			case InvalidPointer:
				return _T("Pointer found in invalid state");
			case InvalidVersion:
				return _T("This version of MMC is not compatible with the ")
														_T("file opened");
			case UnableToCreateStorage:
				return _T("Unable to create storage");
			case UnableToCreateStream:
				return _T("Unable to create stream in storage");
			case UnableToDestroyElement:
				return _T("Unable to destroy an element in a docfile");
			case UnableToSave:
				return _T("Unable to save");
			case UnableToLoad:
				return _T("Unable to load from storage");
			case UnableToLoadSomePortionOfTheTree:
				return _T("Unable to load some of the tree");
			case UnableToOpenStorage:
				return _T("Unable to open a storage");
			case UnableToOpenStream:
				return _T("Unable to open a stream");
			case UnableToWriteToStream:
				return _T("Unable to write to stream");
			case Unknown:
				return _T("Unknown");
			}
		return _T("Unknown");
		}

	private: Code m_Code;
	#ifdef _DEBUG
	private: const TCHAR* m_File;
	private: int m_Line;
	#endif

	}; // class MMCException

template<typename MoreInfoT> class MMCXPlus : public MMCX
	{
	public: MMCXPlus() throw()
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c, const TCHAR* file, int line) throw()
		: MMCX(c, file, line), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c) throw()
		: MMCX(c), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MMCXPlus& e) throw()
		: MMCX(e), m_MoreInfo(e.m_MoreInfo)
		{
		}

	public: ~MMCXPlus() throw()
		{
		}

	public: MMCXPlus& operator=(const MMCXPlus& e) throw()
		{
		MMCX::operator=(e);
		m_MoreInfo = e.m_MoreInfo;
		return *this;
		}

	public: const MoreInfoT& GetMoreInfo() const throw()
		{
		return m_MoreInfo;
		}

	private: MoreInfoT m_MoreInfo;
	}; // class MMCXPlus

typedef MMCXPlus<HRESULT> COMX;

#ifdef _DEBUG
#define XCODE(x) MMCX::Code::x, _T(__FILE__), __LINE__
#else
#define XCODE(x) MMCX::Code::x
#endif

// Assert 'n throw macros
#define ANT(test, exception) \
	if (!static_cast<bool>(test)) { ASSERT(static_cast<bool>(test)); throw exception; }

#define AssertThenThrow(test, exception) ANT(test, exception)

#define ANTIfNot(exception, acceptableException) \
	if (exception != acceptableException) \
		{ ASSERT(exception != acceptableException); throw exception; }

#define AssertThenThrowIfNot(exception, acceptableException) \
	ANTIfNot(exception, acceptableException)

#define MMCEX(x) MMCX(XCODE(x))
#define COMEX(hr, x) COMX(hr, XCODE(x))
#endif // MMCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\ndmgrp.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ndmgrp.h
 *
 *  Contents:  Private header to go along with ndmgr.h
 *
 *  History:   03-Mar-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef NDMGRP_H
#define NDMGRP_H
#pragma once

#include "ndmgr.h"

struct DataWindowData
{
    MMC_COOKIE          cookie;
    LONG_PTR            lpMasterNode;
    IDataObjectPtr      spDataObject;
    IComponentDataPtr   spComponentData;
    IComponentPtr       spComponent;
    HWND                hDlg;
};

inline DataWindowData* GetDataWindowData (HWND hwndData)
{
    LONG_PTR nData = GetWindowLongPtr (hwndData, WINDOW_DATA_PTR_SLOT);
    return (reinterpret_cast<DataWindowData *>(nData));
}


#endif /* NDMGRP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\ndmgrpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ndmgrpriv.h (originally ndmgr.idl)
//
//--------------------------------------------------------------------------

#include "mmcobj.h"
#include <string>
#include <vector>
#include <iterator>

#ifndef __ndmgrpriv_h__
#define __ndmgrpriv_h__

#define MMC_INTERFACE(Interface, x)    \
    extern "C" const IID IID_##Interface;   \
    struct DECLSPEC_UUID(#x) __declspec(novtable) Interface

// forward class declarations
class CContextMenuInfo;
class CResultViewType;
class tstring;
class CColumnInfoList;
class CConsoleView;
class CXMLObject;

// interfaces
interface INodeType;
interface INodeTypesCache;
interface IEnumNodeTypes;
interface IFramePrivate;
interface IScopeDataPrivate;
interface IResultDataPrivate;
interface IImageListPrivate;
interface IPropertySheetNotify;
interface INodeCallback;
interface IScopeTreeIter;
interface IScopeTree;
interface IPropertySheetProviderPrivate;
interface IDumpSnapins;
interface IMMCListView;
interface ITaskPadHost;
interface IStringTablePrivate;
interface ITaskCallback;
interface IComCacheCleanup;
interface IHeaderCtrlPrivate;
interface IMMCClipboardDataObject;
interface IMMCClipboardSnapinObject;

typedef IFramePrivate*          LPFRAMEPRIVATE;
typedef IScopeDataPrivate*      LPSCOPEDATAPRIVATE;
typedef IResultDataPrivate*     LPRESULTDATAPRIVATE;
typedef IImageListPrivate*      LPIMAGELISTPRIVATE;
typedef IPropertySheetNotify*   LPPROPERTYSHEETNOTIFY;
typedef INodeCallback*          LPNODECALLBACK;
typedef IScopeTreeIter*         LPSCOPETREEITER;
typedef IScopeTree*             LPSCOPETREE;
typedef INodeType*              LPNODETYPE;
typedef INodeTypesCache*        LPNODETYPESCACHE;
typedef IEnumNodeTypes*         LPENUMNODETYPES;
typedef IDumpSnapins*           LPDUMPSNAPINS;
typedef IMMCListView*           LPMMCLISTVIEW;
typedef ITaskCallback*          LPTASKCALLBACK;
typedef IComCacheCleanup*       LPCOMCACHECLEANUP;
typedef IMMCClipboardDataObject*    LPCLIPBOARDDATAOBJECT;
typedef IMMCClipboardSnapinObject*  LPCLIPBOARDSNAPINOBJECT;

typedef LONG_PTR                HBOOKMARK;
typedef LONG_PTR                HVIEWSETTINGS;
typedef LONG_PTR                HPERSISTOR;

typedef IPropertySheetProviderPrivate*  LPPROPERTYSHEETPROVIDERPRIVATE;

typedef struct _TREEITEM * HTREEITEM;

// Implements the list save feature (t-dmarm)
#define IMPLEMENT_LIST_SAVE

// Use to see if the MT Node is valid before referencing the saved pointer in
// a property sheet.
STDAPI MMCIsMTNodeValid(void* pMTNode, BOOL bReset);

// Window class used to store data for property sheets
#define MAINFRAME_CLASS_NAME   L"MMCMainFrame"

// Window class used to store data for property sheets
#define DATAWINDOW_CLASS_NAME  L"MMCDataWindow"
#define WINDOW_DATA_SIZE       (sizeof (DataWindowData *))

// Slots for data stored in the data windows
#define WINDOW_DATA_PTR_SLOT   0

// Max length of item text in list/tree controls
// (including the terminating zero)
#define MAX_ITEM_TEXT_LEN      1024

// MID(Menu Identifications) for context menus
enum MID_LIST
{
    MID_VIEW = 1,
    MID_VIEW_LARGE,
    MID_VIEW_SMALL,
    MID_VIEW_LIST,
    MID_VIEW_DETAIL,
    MID_VIEW_FILTERED,
    MID_VIEW_HTML,
    MID_ARRANGE_ICONS,
    MID_LINE_UP_ICONS,
    MID_PROPERTIES,
    MID_CREATE_NEW,
    MID_TASK,
    MID_EXPLORE,
    MID_NEW_TASKPAD_FROM_HERE,
    MID_OPEN,
    MID_CUT,
    MID_COPY,
    MID_PASTE,
    MID_DELETE,
    MID_PRINT,
    MID_REFRESH,
    MID_RENAME,
    MID_CONTEXTHELP,
    MID_ARRANGE_AUTO,
    MID_STD_MENUS,
    MID_STD_BUTTONS,
    MID_SNAPIN_MENUS,
    MID_SNAPIN_BUTTONS,
    MID_LISTSAVE,
    MID_COLUMNS,
    MID_CUSTOMIZE,
    MID_ORGANIZE_FAVORITES,
    MID_EDIT_TASKPAD,
    MID_DELETE_TASKPAD,

    MID_LAST,   // this must be last

};

class CResultItem;

typedef struct _CCLVSortParams
{
    BOOL                    bAscending;         // sort direction
    int                     nCol;               // Which column to sort on.
    LPRESULTDATACOMPARE     lpResultCompare;    // Snap-in component interface
    LPRESULTDATACOMPAREEX   lpResultCompareEx;  //          "
    LPARAM                  lpUserParam;        // parameter user passes in
    BOOL                    bSetSortIcon;       // Sort icon /*[not]*/ needed

    /*
     * Bug 414256:  We need to save the sort data only if
     * it is user initiated sort. Is this user initiated?
     */
    BOOL                    bUserInitiatedSort;
} CCLVSortParams;

//
// This structure is used by MMCPropertyChangeNotify to pass
// information from a property sheet to the console.  It has routing
// information to notify the correct snap-in of a property changed notify.
//

const DWORD MMC_E_INVALID_FILE = 0x80FF0002;
const DWORD MMC_E_SNAPIN_LOAD_FAIL = 0x80FF0003;

typedef struct _PROPERTYNOTIFYINFO
{
    LPCOMPONENTDATA pComponentData; // Valid if (fScopePane == TRUE)
    LPCOMPONENT     pComponent;     // Valid if (fScopePane == FALSE)
    BOOL            fScopePane;     // True if it is for a scope pane item.
    HWND            hwnd;           // HWND to console handling the message
} PROPERTYNOTIFYINFO;


// Context menu types
typedef enum  _MMC_CONTEXT_MENU_TYPES
{
    MMC_CONTEXT_MENU_DEFAULT   = 0,      // Normal context menu
    MMC_CONTEXT_MENU_ACTION    = 1,      // Action menu button
    MMC_CONTEXT_MENU_VIEW      = 2,      // View menu button
    MMC_CONTEXT_MENU_FAVORITES = 3,      // Favorites menu button
    MMC_CONTEXT_MENU_LAST      = 4,

}   MMC_CONTEXT_MENU_TYPES;

DECLARE_HANDLE (HMTNODE);
DECLARE_HANDLE (HNODE);     // A scope pane handle(lParam) within a view

typedef unsigned long MTNODEID;

const MTNODEID ROOTNODEID      = 1;


typedef PROPERTYNOTIFYINFO*     LPPROPERTYNOTIFYINFO;

// Special cookies (Note: Can't use -1)
const LONG_PTR LVDATA_BACKGROUND  =  -2;
const LONG_PTR LVDATA_CUSTOMOCX   =  -3;
const LONG_PTR LVDATA_CUSTOMWEB   =  -4;
const LONG_PTR LVDATA_MULTISELECT =  -5;
const LONG_PTR LVDATA_ERROR       = -10;
const LONG_PTR SPECIAL_LVDATA_MIN = -10;
const LONG_PTR SPECIAL_LVDATA_MAX =  -2;
#define IS_SPECIAL_LVDATA(d) (((d) >= SPECIAL_LVDATA_MIN) && ((d) <= SPECIAL_LVDATA_MAX))


typedef struct _SELECTIONINFO
{
    BOOL                m_bScope;
    BOOL                m_bBackground;
    IUnknown*           m_pView;    // valid for scope seln (CDN_SELECT)
    MMC_COOKIE          m_lCookie;   // valid for result item (CCN_SELECT)
    MMC_CONSOLE_VERB    m_eCmdID;
    BOOL                m_bDueToFocusChange;
    BOOL                m_bResultPaneIsOCX;
    BOOL                m_bResultPaneIsWeb;
} SELECTIONINFO;


typedef struct _HELPDOCINFO
{
    LPCOLESTR     m_pszFileName;    // File name (same as .msc file)
    FILETIME      m_ftimeCreate;    // .msc file creation time
    FILETIME      m_ftimeModify;    // .msc file modification time
} HELPDOCINFO;

// MMC_ILISTPAD_INFO struct: internal form has additional field for clsid
typedef struct _MMC_ILISTPAD_INFO
{
    MMC_LISTPAD_INFO info;
    LPOLESTR szClsid;
} MMC_ILISTPAD_INFO;

// *****************************************
// CLASS: CTaskPadData
// this class represents data set representing one TaskPad
// used to request taskpad information from CNode
// *****************************************
class CTaskPadData
{
public:
    std::wstring strName;
    CLSID        clsidTaskPad;
};
typedef std::vector<CTaskPadData>                CTaskPadCollection;
typedef std::insert_iterator<CTaskPadCollection> CTaskPadInsertIterator;

// *****************************************
// CLASS:CViewExtensionData
// this class represents data set representing one ViewExtension
// used to request extension information from CNode
// *****************************************
class CViewExtensionData
{
public:
    std::wstring strURL;
    std::wstring strName;
    std::wstring strTooltip;
    GUID         viewID;  // unique identifier for the view
    bool         bReplacesDefaultView;
};
typedef std::vector<CViewExtensionData>          CViewExtCollection;
typedef std::insert_iterator<CViewExtCollection> CViewExtInsertIterator;


// The following internal flag corresponding to public view style MMC_ENSUREFOCUSVISIBLE.
// The flag is placed in the upper half of a long so it won't conflict with the LVS_*
// flags that are passed in the same long to our list control's SetViewStyle method.

#define MMC_LVS_ENSUREFOCUSVISIBLE 0x00010000


/*
NOTIFICATIONS
=============

Notify(dataobject, event, arg, param);
    For all the MMC_NOTIFY_TYPE events,
    dataobject = dataobject for cookie, can be NULL when dataobject is not required
    event = one of the CD_NOTIFY_TYPEs
    arg and param depend on type, see below.


NCLBK_ACTIVATE
    arg = TRUE if gaining focus

NCLBK_BTN_CLICK
    ....

NCLBK_CLICK

NCLBK_CONTEXTMENU
    param = CContextMenuInfo*

NCLBK_DBLCLICK

NCLBK_DELETE
    arg = TRUE if scope item FALSE if result item.
    param = If scope item is being deleted param is unused.
            If result item is being deleted param is the result items cookie.
    return = unused.

NCLBK_EXPAND
    arg = TRUE => expand, FALSE => contract

NCLBK_EXPANDED
    arg = TRUE => expanded, FALSE => contracted

NCLBK_FOLDER
    arg = <>0 if expanding, 0 if contracting
    param = HSCOPEITEM of expanding/contracting item

NCLBK_MINIMIZED
    arg = TRUE if minimized

NCLBK_MULTI_SELECT
    arg = TRUE if due to focus change.
    param unused


NCLBK_PROPERTIES
    pLParam = (CResultItem*)arg;
    param unused

NCLBK_PROPERTY_CHANGE
    lpDataObject = NULL
    lParam = user object

NCLBK_NEW_NODE_UPDATE
    arg = 1 => folder needs to be refreshed
    arg = 2 => result view needs to be refreshed
    arg = 3 => both needs to be refreshed

NCLBK_RENAME
    This gets called the first time to query for rename and a
    second time to do the rename.  For the query S_OK or S_FALSE for the
    return type.  After the rename, we will send the new name with a LPOLESTR.
    MMC_COOKIE lResultItemCookie = (MMC_COOKIE)arg;
    pszNewName = (LPOLESTR)param; // the new name
    return = S_OK to allow rename and S_FALSE to disallow rename.

NCLBK_SELECT
    arg = TRUE if the item is selected, FALSE otherwise.
    param = ptr to SELECTIONINFO.

NCLBK_SHOW
    arg = <>0 if selecting, 0 if deselecting
    param = HSCOPEITEM of selected/deselected item

NCLBK_COLUMN_CLICK
    param = nCol, the column that was clicked.

NCLBK_FINDITEM
    This message is sent when a result item list with owner data wants to find
    an item who's name matches a string

    arg = ptr to RESULTFINDINFO
    param = ptr to returned item index

NCLBK_CACHEHINT
    This message is sent when the result item list with owner data is about to
    ask for display info for a range of items.

    arg = index of start item
    param = index of end item

NCLBK_GETHELPDOC
    This message is sent to get the path of the combined help topics document.
    The node manager may update the help doc info.
    arg = pointer to HELPDOCINFO struct
    param = pointer to returned path string (LPOLESTR*)

NCLBK_LISTPAD
    This message is sent to tell the snapin that the TaskPad ListView is ready
    to receive items (if attaching).
    arg = TRUE if attaching, FALSE if detaching


NCLBK_WEBCONTEXTMENU
    send when the user right clicks on a web page.
    arg   = unused
    param = unused

NCLBK_UPDATEHELPDOC
    send when console doc is saved to update help file name and file times
    arg = ptr to current help doc info (HELPDOCINFO*)
    param = ptr to new help doc info  (HELPDOCINFO*)

NCLBK_DELETEHELPDOC
    send when console doc is closed to delete the temp help collection file
    associated with the document
    arg - ptr to help doc info (HELPDOCINFO*)
    param - unused
*/

typedef enum _NCLBK_NOTIFY_TYPE
{
    NCLBK_NONE              = 0x9000,
    NCLBK_ACTIVATE          = 0x9001,
    NCLBK_CACHEHINT         = 0x9002,
    NCLBK_CLICK             = 0x9003,
    NCLBK_CONTEXTMENU       = 0x9004,
    NCLBK_COPY              = 0x9005,
    NCLBK_CUT               = 0x9006,
    NCLBK_DBLCLICK          = 0x9007,
    NCLBK_DELETE            = 0x9008,
    NCLBK_EXPAND            = 0x9009,
    NCLBK_EXPANDED          = 0x900A,
    NCLBK_FINDITEM          = 0x900B,
    NCLBK_FOLDER            = 0x900C,
    NCLBK_MINIMIZED         = 0x900D,
    NCLBK_MULTI_SELECT      = 0x900E,
    NCLBK_NEW_NODE_UPDATE   = 0x900F,
    NCLBK_PRINT             = 0x9011,
    NCLBK_PROPERTIES        = 0x9012,
    NCLBK_PROPERTY_CHANGE   = 0x9013,
    NCLBK_REFRESH           = 0x9015,
    NCLBK_RENAME            = 0x9016,
    NCLBK_SELECT            = 0x9017,
    NCLBK_SHOW              = 0x9018,
    NCLBK_COLUMN_CLICKED    = 0x9019,
    NCLBK_SNAPINHELP        = 0x901D,
    NCLBK_CONTEXTHELP       = 0x901E,
    NCLBK_INITOCX           = 0x9020,
    NCLBK_FILTER_CHANGE     = 0x9021,
    NCLBK_FILTERBTN_CLICK   = 0x9022,
    NCLBK_TASKNOTIFY        = 0x9024,
    NCLBK_GETPRIMARYTASK    = 0x9025,
    NCLBK_GETHELPDOC        = 0x9027,
    NCLBK_LISTPAD           = 0x9029,
    NCLBK_GETEXPANDEDVISUALLY   = 0x902B,
    NCLBK_SETEXPANDEDVISUALLY   = 0x902C,
    NCLBK_NEW_TASKPAD_FROM_HERE = 0x902D,
    NCLBK_WEBCONTEXTMENU    = 0x902E,
    NCLBK_UPDATEHELPDOC     = 0x902F,
    NCLBK_EDIT_TASKPAD      = 0x9030,
    NCLBK_DELETE_TASKPAD    = 0x9031,
    NCLBK_DELETEHELPDOC     = 0x9032
} NCLBK_NOTIFY_TYPE;



///////////////////////////////////////////////////////////////////////////////
// Common Console clipboard formats
//

// Clipboard format for the multi selected static nodes.
// If there are N static nodes are selected in the result pane, the MTNodes
// for these N nodes will be passed in a GloballAlloced memory. The first DWORD
// contains the number of MTNodes, this will be followed by N ptrs to the MTNodes.
//
#define CCF_MULTI_SELECT_STATIC_DATA    ( L"CCF_MULTI_SELECT_STATIC_DATA" )

#define CCF_NEWNODE ( L"CCF_NEWNODE" )

//const CLSID CLSID_NDMGR_SNAPIN = {0x2640211a, 0x06d0, 0x11d1, {0xa7, 0xc9, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x65}};
extern const CLSID CLSID_NDMGR_SNAPIN;

//const GUID GUID_MMC_NEWNODETYPE = {0xfd17e9cc, 0x06ce, 0x11d1, {0xa7, 0xc9, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x65}};
extern const GUID GUID_MMC_NEWNODETYPE;


///////////////////////////////////////////////////////////////////////////
///



    // helpstring("Notify that the properties of an object changed"),
    MMC_INTERFACE(IPropertySheetNotify, d700dd8e-2646-11d0-a2a7-00c04fd909dd) : IUnknown
    {
        STDMETHOD(Notify)(/*[in]*/ LPPROPERTYNOTIFYINFO pNotify, /*[in]*/ LPARAM lParam)  = 0;
    };



    // helpstring("IFramePrivate Interface"),
    MMC_INTERFACE(IFramePrivate, d71d1f2a-1ba2-11d0-a29b-00c04fd909dd): IConsole3
    {
        /*[helpstring("Sets IFrame Result pane")]*/
        STDMETHOD(SetResultView)(/*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("Is the ListView set as result view")]*/
        STDMETHOD(IsResultViewSet)(BOOL* pbIsLVSet) = 0;

        /*[helpstring("Sets Task Pads list view")]*/
        STDMETHOD(SetTaskPadList)(/*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("IComponent's component ID")]*/
        STDMETHOD(GetComponentID)(/*[out]*/ COMPONENTID* lpComponentID)  = 0;

        /*[helpstring("IComponent's component ID")]*/
        STDMETHOD(SetComponentID)(/*[in]*/ COMPONENTID id)  = 0;

        /*[helpstring("Node for the view.")]*/
        STDMETHOD(SetNode)(/*[in]*/ HMTNODE hMTNode, /*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Cache the IComponent interface for the snapin.")]*/
        STDMETHOD(SetComponent)(/*[in]*/ LPCOMPONENT lpComponent)  = 0;

        /*[helpstring("Console name space.")]*/
        STDMETHOD(QueryScopeTree)(/*[out]*/ IScopeTree** ppScopeTree)  = 0;

        /*[helpstring("Set the console name space.")]*/
        STDMETHOD(SetScopeTree)(/*[in]*/ IScopeTree* pScopeTree)  = 0;

        /*[helpstring("Creates image list for the scope pane.")]*/
        STDMETHOD(CreateScopeImageList)(/*[in]*/ REFCLSID refClsidSnapIn)  = 0;

        /*[helpstring("bExtension is TRUE if this IFrame is used by an extension.")]*/
        STDMETHOD(SetUsedByExtension)(/*[in]*/ BOOL bExtension)  = 0;

        /*[helpstring("Init view data.")]*/
        STDMETHOD(InitViewData)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Clean up view data.")]*/
        STDMETHOD(CleanupViewData)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Reset the sort parameters after a selection change.")]*/
        STDMETHOD(ResetSortParameters)()  = 0;
   };




   // helpstring("IScopeDataPrivate Interface"),
    MMC_INTERFACE(IScopeDataPrivate, 60BD2FE0-F7C5-11cf-8AFD-00AA003CA9F6) : IConsoleNameSpace2
    {
    };




    // helpstring("IImageListPrivate Interface"),
    MMC_INTERFACE(IImageListPrivate, 7538C620-0083-11d0-8B00-00AA003CA9F6) : IImageList
    {
        /*[helpstring("Private tree control method used to map images on callbacks")]*/
        STDMETHOD(MapRsltImage)(COMPONENTID id, /*[in]*/ int nSnapinIndex, /*[out]*/ int* pnConsoleIndex)  = 0;

        /*[helpstring("Private tree control method used to map images on callbacks")]*/
        STDMETHOD(UnmapRsltImage)(COMPONENTID id, /*[in]*/ int nConsoleIndex, /*[out]*/ int* pnSnapinIndex)  = 0;
    };



    // helpstring("IResultDataPrivate Interface"),
    MMC_INTERFACE(IResultDataPrivate, 1EBA2300-0854-11d0-8B03-00AA003CA9F6) : IResultData2
    {
        /*[helpstring("Get the list view style.")]*/
        STDMETHOD(GetListStyle)(/*[out]*/ long * pStyle)  = 0;

        /*[helpstring("Set the list view style.")]*/
        STDMETHOD(SetListStyle)(/*[in]*/ long Style)  = 0;

        /*[helpstring("Set loading mode of list")]*/
        STDMETHOD(SetLoadMode)(/*[in]*/ BOOL bState)  = 0;

        /*[helpstring("Arrange the icons in the result pane")]*/
        STDMETHOD(Arrange)(long style)  = 0;

        /*[helpstring("Sort from the Listview header control")]*/
        STDMETHOD(InternalSort)(INT nCol, DWORD dwSortOptions, LPARAM lUserParam, BOOL bColumnClicked)  = 0;

        /*[helpstring("Private tree control method used to reset the result view")]*/
        STDMETHOD(ResetResultData)()  = 0;

        /*[helpstring("Private listview method to retrieve sort column")]*/
        STDMETHOD(GetSortColumn)(INT* pnCol) = 0;

        /*[helpstring("Private listview method to retrieve sort column")]*/
        STDMETHOD(GetSortDirection)(BOOL* pbAscending) = 0;
    };


    // helpstring("IHeaderCtrlPrivate Interface that adds to IHeaderCtrl methods"),
    MMC_INTERFACE(IHeaderCtrlPrivate, 0B384311-701B-4e8a-AEC2-DA6321E27AD2) : IHeaderCtrl2
    {
        /*[helpstring("Get the number of columns in list view.")]*/
        STDMETHOD(GetColumnCount)(/*[in]*/INT* pnCol) = 0;

        /*[helpstring("Get the current column settings from list view header.")]*/
        STDMETHOD(GetColumnInfoList)(/*[out]*/ CColumnInfoList *pColumnsList) = 0;

        /*[helpstring("Modify the columns in list view with given data.")]*/
        STDMETHOD(ModifyColumns)(/*[in]*/ const CColumnInfoList& columnsList) = 0;

        /*[helpstring("Get the column settings that snapin supplied originally")]*/
        STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList) = 0;
    };


    // helpstring("Minimum master tree control methods required by node manager."),
    MMC_INTERFACE(IScopeTree, d8dbf067-5fb2-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Initialize scope tree with the document.")]*/
        STDMETHOD(Initialize)(/*[in]*/ HWND hFrameWindow, /*[in]*/ IStringTablePrivate* pStringTable)  = 0;

        /*[helpstring("Query for an iterator to the master tree items.")]*/
        STDMETHOD(QueryIterator)(/*[out]*/IScopeTreeIter** lpIter)  = 0;

        /*[helpstring("Query for an node callback interface to access HNODE items.")]*/
        STDMETHOD(QueryNodeCallback)(/*[out]*/ INodeCallback** ppNodeCallback)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(CreateNode)(/*[in]*/ HMTNODE hMTNode, /*[in]*/ LONG_PTR lViewData,
                           /*[in]*/ BOOL fRootNode, /*[out]*/ HNODE* phNode)  = 0;

        /*[helpstring("Do cleanup needed prior to deleting/shutting down view.")]*/
        STDMETHOD(CloseView)(/*[in]*/ int nView)  = 0;

        /*[helpstring("Delete all view data for the specified view id.")]*/
        STDMETHOD(DeleteView)(/*[in]*/ int nView)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(DestroyNode)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Finds the node that matches the ID")]*/
        STDMETHOD(Find)(/*[in]*/ MTNODEID mID, /*[out]*/ HMTNODE* phMTNode)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(GetImageList)(/*[out]*/ PLONG_PTR plImageList)  = 0;

        /*[helpstring("Run snap-in manager")]*/
        STDMETHOD(RunSnapIn)(/*[in]*/ HWND hwndParent)  = 0;

        /*[helpstring("Returns the version for the file rooted at the given storage.")]*/
        STDMETHOD(GetFileVersion)(/*[in]*/ IStorage* pstgRoot, /*[out]*/ int* pnVersion)  = 0;

        /*[helpstring("Returns the MTNODEID for the node represented by a bookmark")]*/
        STDMETHOD(GetNodeIDFromBookmark)(/*[in]*/ HBOOKMARK hbm, /*[out]*/ MTNODEID* pID, /*[out]*/ bool& bExactMatchFound)  = 0;

        /*[helpstring("Loads a bookmark from a stream and returns the MTNODEID for the node.")]*/
        STDMETHOD(GetNodeIDFromStream)(/*[in]*/ IStream *pStm, /*[out]*/ MTNODEID* pID)  = 0;

        /*[helpstring("Loads a bookmark from a stream and returns the MTNODEID for the node.")]*/
        STDMETHOD(GetNodeFromBookmark)(/*[in]*/ HBOOKMARK hbm, /*[in]*/CConsoleView *pConsoleView, /*[out]*/ PPNODE ppNode, /*[out]*/ bool& bExactMatchFound)  = 0;

        /*[helpstring("Returns the ID path for the given ID")]*/
        STDMETHOD(GetIDPath)(/*[in]*/ MTNODEID id, /*[out]*/ MTNODEID** ppIDs, /*[out]*/ long* pLength)  = 0;

        /*[helpstring("Check to see if synchronous node expansion is required")]*/
        STDMETHOD(IsSynchronousExpansionRequired)()  = 0;

        /*[helpstring("Sets whether synchronous node expansion is required")]*/
        STDMETHOD(RequireSynchronousExpansion)(/*[in]*/ BOOL fRequireSyncExpand)  = 0;

        /*[helpstring("Sets the SConsoleData to use for this scope tree")]*/
        STDMETHOD(SetConsoleData)(/*[in]*/ LPARAM lConsoleData)  = 0;

        /*[helpstring("Persists the tree to/from an XML document")]*/
        STDMETHOD(Persist)(/*[in]*/ HPERSISTOR hPersistor)  = 0;

        /*[helpstring("Get path between two nodes as a string")]*/
        STDMETHOD(GetPathString)(/*[in]*/ HMTNODE hmtnRoot, /*[in]*/ HMTNODE hmtnLeaf, /*[out]*/ LPOLESTR* pPath)  = 0;

        /*[helpstring("Get the SnapIns object")]*/
        STDMETHOD(QuerySnapIns)(/*[out]*/ SnapIns **ppSnapIns)  = 0;

        /*[helpstring("Get the ScopeNamespace object")]*/
        STDMETHOD(QueryScopeNamespace)(/*[out]*/ ScopeNamespace **ppScopeNamespace)  = 0;

        /*[helpstring("Create an empty Properties object")]*/
        STDMETHOD(CreateProperties)(/*[out]*/ Properties **ppProperties)  = 0;

        /*[helpstring("Get scope node id for Node object")]*/
        STDMETHOD(GetNodeID)(/*[in]*/ PNODE pNode, /*[out]*/ MTNODEID *pID)  = 0;

        /*[helpstring("Get HMTNODE for Node object")]*/
        STDMETHOD(GetHMTNode)(/*[in]*/ PNODE pNode, /*[out]*/ HMTNODE *phMTNode)  = 0;

        /*[helpstring("Get Node object ptr for scope node")]*/
        STDMETHOD(GetMMCNode)(/*[in]*/ HMTNODE hMTNode, /*[out]*/ PPNODE ppNode)  = 0;

        /*[helpstring("Get NODE object for Root Node")]*/
        STDMETHOD(QueryRootNode)(/*[out]*/ PPNODE ppNode)  = 0;

        /*[helpstring("Check if snapin is used by MMC")]*/
        STDMETHOD(IsSnapinInUse)(/*[in]*/ REFCLSID refClsidSnapIn, /*[out]*/ PBOOL pbInUse)  = 0;

    };



    // helpstring("Master tree item iterator."),
    MMC_INTERFACE(IScopeTreeIter, d779f8d1-6057-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Sets the current master tree node.")]*/
        STDMETHOD(SetCurrent)(/*[in]*/ HMTNODE hStartMTNode)  = 0;

        /*[helpstring("Moves the iterator forward to the next master node 
        sibling and returns a pointer to the new "current". NULL if none")]*/
        STDMETHOD(Next)(/*[out]*/ HMTNODE* phScopeItem)  = 0;

        /*[helpstring("Moves the iterator backward to the prev master node 
        sibling and returns a pointer to the new "current". NULL if none")]*/
        STDMETHOD(Prev)(/*[out]*/ HMTNODE* phScopeItem)  = 0;

        /*[helpstring("Returns the child master node.")]*/
        STDMETHOD(Child)(/*[out]*/ HMTNODE* phsiChild)  = 0;

        /*[helpstring("Returns the last child master node.")]*/
        STDMETHOD(LastChild)(/*[out]*/ HMTNODE* phsiLastChild)  = 0;

    };



    // helpstring("Node callback methods."),
    MMC_INTERFACE(INodeCallback, b241fced-5fb3-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Initialize with the scope tree.")]*/
        STDMETHOD(Initialize)(/*[in]*/ IScopeTree* pIScopeTree)  = 0;

        /*[helpstring("Returns the images for this node.")]*/
        STDMETHOD(GetImages)(/*[in]*/ HNODE hNode, /*[out]*/ int* iImage, int* iSelectedImage)  = 0;

        /*[helpstring("Returns the display name for node.")]*/
        STDMETHOD(GetDisplayName)(/*[in]*/ HNODE hNode, /*[out]*/ tstring& strName)  = 0;

        /*[helpstring("Returns the custom window title for this node")]*/
        STDMETHOD(GetWindowTitle)(/*[in]*/ HNODE hNode, /*[out]*/ tstring& strTitle)  = 0;

        /*[helpstring("Handles callback for result items")]*/
        STDMETHOD(GetDispInfo)(/*[in]*/ HNODE hNode, /*[in,out]*/ LVITEMW* plvi)  = 0;

        /*[helpstring("Returns the UI state of master node.")]*/
        STDMETHOD(GetState)(/*[in]*/ HNODE hNode, /*[out]*/ UINT* pnState)  = 0;

        /*[helpstring("Returns the result pane for the node.")]*/
        STDMETHOD(GetResultPane)(/*[in]*/ HNODE hNode, /*[in, out]*/ CResultViewType& rvt,
                                /*[out]*/ GUID *pGuidTaskpadID)  = 0;

        /*[helpstring("Asks the snapin to restore its result pane with given data")]*/
        STDMETHOD(RestoreResultView)(/*[in]*/HNODE hNode, /*[in]*/const CResultViewType& rvt) = 0;

        /*[helpstring("Returns the result pane OCX control for the node.")]*/
        STDMETHOD(GetControl)(/*[in]*/ HNODE hNode, /*[in]*/ CLSID clsid, /*[out]*/IUnknown **ppUnkControl)  = 0;

        /*[helpstring("Sets the result pane OCX control for the node.")]*/
        STDMETHOD(SetControl)(/*[in]*/ HNODE hNode, /*[in]*/ CLSID clsid, /*[in]*/IUnknown* pUnknown)  = 0;

        /*[helpstring("Returns the result pane OCX control for the node.")]*/
        STDMETHOD(GetControl)(/*[in]*/ HNODE hNode, /*[in]*/LPUNKNOWN pUnkOCX, /*[out]*/IUnknown **ppUnkControl)  = 0;

        /*[helpstring("Sets the result pane OCX control for the node.")]*/
        STDMETHOD(SetControl)(/*[in]*/ HNODE hNode, /*[in]*/LPUNKNOWN pUnkOCX, /*[in]*/IUnknown* pUnknown)  = 0;

        /*[helpstring("Sends the MMCN_INITOCX notification to the appropriate snapin")]*/
        STDMETHOD(InitOCX)(/*[in]*/ HNODE hNode, /*[in]*/ IUnknown* pUnknown)  = 0;

        /*[helpstring("Set the Result Item ID")]*/
        //RENAME// STDMETHOD(SetItemID)(/*[in]*/ HNODE hNode, /*[in]*/ HRESULTITEM riID)  = 0;
        STDMETHOD(SetResultItem)(/*[in]*/ HNODE hNode, /*[in]*/ HRESULTITEM hri)  = 0;

        /*[helpstring("Get the Result Item ID")]*/
        //RENAME// STDMETHOD(GetItemID)(/*[in]*/ HNODE hNode, /*[out]*/ HRESULTITEM* priID)  = 0;
        STDMETHOD(GetResultItem)(/*[in]*/ HNODE hNode, /*[out]*/ HRESULTITEM* phri)  = 0;

        /*[helpstring("Returns the nodes unique ID")]*/
        //RENAME// STDMETHOD(GetID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;
        STDMETHOD(GetMTNodeID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;

        /*[helpstring("Determine if node is the target of another")]*/
        STDMETHOD(IsTargetNodeOf)(/*[in]*/ HNODE hNode, /*[in]*/ HNODE hTestNode)  = 0;

        /*[helpstring("Returns the nodes static parents MTNODEID and the subsequent path")]*/
        STDMETHOD(GetPath)(/*[in]*/ HNODE hNode, /*[in]*/ HNODE hRootNode, /*[out]*/ BYTE* pbm_)  = 0;

        /*[helpstring("Returns the static parent nodes unique ID")]*/
        STDMETHOD(GetStaticParentID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;

        /*[helpstring("Notify")]*/
        STDMETHOD(Notify)(/*[in]*/ HNODE hNode, /*[in]*/ NCLBK_NOTIFY_TYPE event,
                       /*[in]*/ LPARAM arg, /*[in]*/ LPARAM param)  = 0;

        /*[helpstring("Returns the parent master node.")]*/
        STDMETHOD(GetMTNode)(/*[in]*/ HNODE hNode, /*[out]*/ HMTNODE* phMTNode)  = 0;

        /*[helpstring("The HMTNODE path to the node is returned in pphMTNode")]*/
        STDMETHOD(GetMTNodePath)(/*[in]*/ HNODE hNode, /*[out]*/ HMTNODE** pphMTNode,
                              /*[out]*/ long* plLength)  = 0;

        /*[helpstring("Get node's owner ID")]*/
        STDMETHOD(GetNodeOwnerID)(/*[in]*/ HNODE hNode, /*[out]*/ COMPONENTID* pID)  = 0;

        /*[helpstring("Get node's cookie")]*/
        STDMETHOD(GetNodeCookie)(/*[in]*/ HNODE hNode, /*[out]*/ MMC_COOKIE* lpCookie)  = 0;

        /*[helpstring("Returns S_OK if the node can possibly be expanded, and S_FALSE otherwise.")]*/
        STDMETHOD(IsExpandable)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Return the dataobject for the selected item")]*/
        // cookie valid if bScope & bMultiSel are both FALSE.
        // cookie is the index\lParam for virtual\regular LV
        STDMETHOD(GetDragDropDataObject)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ BOOL bMultiSel,
                                  /*[in]*/ LONG_PTR lvData, /*[out]*/ LPDATAOBJECT* ppDataObject,
                                  /*[out]*/ bool& bCopyAllowed, /*[out]*/ bool& bMoveAllowed)  = 0;

        /*[helpstring("Returns the task enumerator.")]*/
        STDMETHOD(GetTaskEnumerator)(/*[in]*/ HNODE hNode, /*[in]*/ LPCOLESTR pszTaskGroup,
                                  /*[out]*/ IEnumTASK** ppEnumTask)  = 0;

        /*[helpstring("UpdateWindowLayout.")]*/
        STDMETHOD(UpdateWindowLayout)(/*[in]*/ LONG_PTR lViewData, /*[in]*/ long lToolbarsDisplayed)  = 0;

        /*[helpstring("AddCustomFolderImage")]*/
        STDMETHOD(AddCustomFolderImage)(/*[in]*/ HNODE hNode,
                                      /*[in]*/ IImageListPrivate* pImageList)  = 0;

        /*[helpstring("preloads the node if necessary")]*/
        STDMETHOD(PreLoad)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Get the TaskPad ListView information")]*/
        STDMETHOD(GetListPadInfo)(/*[in]*/ HNODE hNode,
                                /*[in]*/ IExtendTaskPad* pExtendTaskPad,
                                /*[in,string]*/ LPCOLESTR szTaskGroup,
                                /*[out]*/ MMC_ILISTPAD_INFO* pIListPadInfo)  = 0;

        /*[helpstring("Sets Task Pads list view")]*/
        STDMETHOD(SetTaskPadList)(/*[in]*/ HNODE hNode, /*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("Sets up a specific taskpad, given the GUID identifier.")]*/
        STDMETHOD(SetTaskpad)(/*[in]*/ HNODE hNodeSelected, /*[in]*/ GUID *pGuidTaskpad)  = 0;

        /*[helpstring("Invokes the Customize View dialog")]*/
        STDMETHOD(OnCustomizeView)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Set the view settings for a particular node.")]*/
        STDMETHOD(SetViewSettings)(/*[in]*/ int nViewID, /*[in]*/ HBOOKMARK hbm, /*[in]*/ HVIEWSETTINGS hvs)  = 0;

        /*[helpstring("Execute given verb for given scope item")]*/
        STDMETHOD(ExecuteScopeItemVerb)(/*[in]*/ MMC_CONSOLE_VERB verb, /*[in]*/ HNODE hNode, /*[in]*/LPOLESTR lpszNewName)  = 0;

        /*[helpstring("Execute given verb for selected result item(s)")]*/
        STDMETHOD(ExecuteResultItemVerb)(/*[in]*/ MMC_CONSOLE_VERB verb, /*[in]*/ HNODE hNode, /*[in]*/LPARAM lvData, /*[in]*/LPOLESTR lpszNewName)  = 0;

        /*[helpstring("Get the disp interface for given scope node object")]*/
        STDMETHOD(QueryCompDataDispatch)(/*[in]*/ PNODE pNode, /*[out]*/ PPDISPATCH ScopeNodeObject)  = 0;

        /*[helpstring("Get the disp interface for selected resultpane objects")]*/
        STDMETHOD(QueryComponentDispatch)(/*[in]*/ HNODE hNode, /*[in]*/LPARAM lvData, /*[out]*/ PPDISPATCH SelectedObject)  = 0;

        /*[helpstring("Creates a context menu for the specified node.")]*/
        STDMETHOD(CreateContextMenu)( PNODE pNode, HNODE hNode, PPCONTEXTMENU ppContextMenu)  = 0;

        /*[helpstring("Creates a context menu for the current selection node.")]*/
        STDMETHOD(CreateSelectionContextMenu)( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu)  = 0;

        /*[helpstring("show/hide column")]*/
        STDMETHOD(ShowColumn)(HNODE hNodeSelected, int iColIndex, bool bShow) = 0;

        /*[helpstring("to get the sort column")]*/
        STDMETHOD(GetSortColumn)(HNODE hNodeSelected, int *piSortCol) = 0;

        /*[helpstring("to set the sort column")]*/
        STDMETHOD(SetSortColumn)(HNODE hNodeSelected, int iSortCol, bool bAscending) = 0;

        /*[helpstring("Returns the data for the specified clipboard format of the specified list item")*/
        STDMETHOD(GetProperty)(/*[in]*/ HNODE hNodeScope, /*[in]*/ BOOL bForScopeItem, /*[in]*/ LPARAM resultItemParam, /*[in]*/ BSTR bstrPropertyName,
                                                     /*[out]*/ PBSTR  pbstrPropertyValue) =0;

        /*[helpstring("Returns the nodetype GUID identifier of the specified list item")*/
        STDMETHOD(GetNodetypeForListItem)(/*[in]*/ HNODE hNodeScope, /*[in]*/ BOOL bForScopeItem, /*[in]*/ LPARAM resultItemParam, /*[in]*/ PBSTR pbstrNodetype) =0;

        /* returns view extension by inserting them to provided iterator */
        STDMETHOD(GetNodeViewExtensions)(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it) = 0;

        /* Inform nodemgr that the column data for given node has changed & to save the data */
        STDMETHOD(SaveColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/const CColumnInfoList& columnsList) = 0;

        /* Ask nodemgr for column-data (no sort data) to setup the headers. */
        STDMETHOD(GetPersistedColumnInfoList) (/*[in]*/HNODE hNode, /*[out]*/CColumnInfoList *pColumnsList) = 0;

        /* Inform nodemgr that the column data for given node is invalid. */
        STDMETHOD(DeletePersistedColumnData) (/*[in]*/HNODE hNode) = 0;

        /* Does about object exists for the snapin whose node is provided. */
        STDMETHOD(DoesAboutExist) (/*[in]*/HNODE hNode, /*[out]*/ bool *pbAboutExists) = 0;

        /* Show about box for given context. */
        STDMETHOD(ShowAboutInformation) (/*[in]*/HNODE hNode) = 0;

        /*Executes a shell command with the specified parameters in the specified directory with the correct window size*/
        STDMETHOD(ExecuteShellCommand)(/*[in]*/ HNODE hNode, /*[in]*/ BSTR Command, /*[in]*/ BSTR Directory, /*[in]*/ BSTR Parameters, /*[in]*/ BSTR WindowState) = 0;

        /*Given the context update the paste button.*/
        STDMETHOD(UpdatePasteButton)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie) = 0;

        /*Findout if current selection context can allow given dataobject to be pasted.*/
        STDMETHOD(QueryPaste)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[in]*/ IDataObject *pDataObject, /*[out]*/bool& bPasteAllowed, /*[out]*/ bool& bCopyOperatationIsDefault) = 0;

        /*Findout if current selection context can allow given dataobject to be pasted.*/
        STDMETHOD(QueryPasteFromClipboard)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[out]*/bool& bPasteAllowed) = 0;

        /*Given the current drop target (or paste target) context paste the given data object or the one from clipboard*/
        STDMETHOD(Drop) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie, /*[in]*/IDataObject *pDataObjectToPaste, /*[in]*/BOOL bIsDragOperationMove) = 0;

        /*Given the current drop target (or paste target) context paste the given data object or the one from clipboard*/
        STDMETHOD(Paste) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie) = 0;

        /*Get the IPersistStream of the CViewSettingsPersistor object for loading the settings.*/
        STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/IPersistStream** ppStream) = 0;

        /*Get the IXMLObject of the CViewSettingsPersistor object for storing/loading the settings.*/
        STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/CXMLObject** ppXMLObject) = 0;

        /*Inform nodemgr that the document is closing, do any cleanups.*/
        STDMETHOD(DocumentClosing) () = 0;

        // Given the node get the snapin name
        STDMETHOD(GetSnapinName)(/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName,  /*[out]*/ bool& bValidName) = 0;

        // Given the node see if it is dummy snapin
        STDMETHOD(IsDummySnapin)(/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin) = 0;

        // See if the snapin supports MMC1.0 version of help (MMCN_SNAPINHELP)
        STDMETHOD(DoesStandardSnapinHelpExist)(/*[in]*/HNODE hNode, /*[out]*/bool& bStandardHelpExists) = 0;
    };




    // helpstring("IControlbarsCache Interface"),
    MMC_INTERFACE(IControlbarsCache, 2e9fcd38-b9a0-11d0-a79d-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Detaches all the controlbars.")]*/
        STDMETHOD(DetachControlbars)()  = 0;

    };


typedef enum _EXTESION_TYPE
{
    EXTESION_NAMESPACE       = 0x1,
    EXTESION_CONTEXTMENU     = 0x2,
    EXTESION_TOOLBAR         = 0x3,
    EXTESION_PROPERTYSHEET   = 0x4,

} EXTESION_TYPE;




// helpstring("INodeType Interface"),
MMC_INTERFACE(INodeType, B08A8368-967F-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(GetNodeTypeID)(/*[out]*/ GUID* pGUID)  = 0;

    STDMETHOD(AddExtension)(/*[in]*/ GUID guidSnapIn,
                         /*[in]*/ EXTESION_TYPE extnType)  = 0;

    STDMETHOD(RemoveExtension)(/*[in]*/ GUID guidSnapIn,
                            /*[in]*/ EXTESION_TYPE extnType)  = 0;

    STDMETHOD(EnumExtensions)(/*[in]*/ EXTESION_TYPE extnType,
                           /*[out]*/ IEnumGUID** ppEnumGUID)  = 0;
};




// helpstring("INodeTypesCache Interface"),
MMC_INTERFACE(INodeTypesCache, DE40436E-9671-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(CreateNodeType)(/*[in]*/ GUID guidNodeType,
                           /*[out]*/ INodeType** ppNodeType)  = 0;

    STDMETHOD(DeleteNodeType)(/*[in]*/ GUID guidNodeType)  = 0;

    STDMETHOD(EnumNodeTypes)(/*[out]*/ IEnumNodeTypes** ppEnumNodeTypes)  = 0;
};




MMC_INTERFACE(IEnumNodeTypes, ABBD61E6-9686-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(Next)(/*[in]*/ ULONG celt,
                 /*[out, size_is(celt), length_is(*pceltFetched)]*/ INodeType*** rgelt,
                 /*[out]*/ ULONG *pceltFetched)  = 0;

    STDMETHOD(Skip)(/*[in]*/ ULONG celt)  = 0;

    STDMETHOD(Reset)()  = 0;

    STDMETHOD(Clone)(/*[out]*/ IEnumNodeTypes **ppenum)  = 0;
};


class CBasicSnapinInfo
{
public:
	CBasicSnapinInfo() : m_clsid(GUID_NULL), m_nImageIndex(-1) {}

public:
	CLSID			m_clsid;
	std::wstring	m_strName;
	int				m_nImageIndex;
};

class CAvailableSnapinInfo
{
public:
	CAvailableSnapinInfo (bool f32Bit) : m_cTotalSnapins(0), m_himl(NULL), m_f32Bit(f32Bit) {}

   ~CAvailableSnapinInfo()
	{
		if (m_himl != NULL)
			ImageList_Destroy (m_himl);
	}

public:
	std::vector<CBasicSnapinInfo>	m_vAvailableSnapins;	// snap-ins that are available in the requested memory model
	UINT							m_cTotalSnapins;		// total number of snap-ins referenced in the console file
	HIMAGELIST						m_himl;					// images for snap-ins in m_vAvailableSnapins
	const bool						m_f32Bit;				// check 32-bit (vs. 64-bit) snap-ins?
};

// helpstring("IDumpSnapins Interface"),
MMC_INTERFACE(IDumpSnapins, A16496D0-1D2F-11d3-AEB8-00C04F8ECD78) : IUnknown
{
	STDMETHOD(Dump)(/*[in]*/ LPCTSTR pszDumpFilePath)  = 0;

	STDMETHOD(CheckSnapinAvailability)(/*[in/out]*/ CAvailableSnapinInfo& asi) = 0;
};


MMC_INTERFACE(IPropertySheetProviderPrivate, FEF554F8-A55A-11D0-A7D7-00C04FD909DD) : IPropertySheetProvider
{
    STDMETHOD(ShowEx)(/*[in]*/ HWND hwnd, /*[in]*/ int page, /*[in]*/ BOOL bModalPage)  = 0;

    STDMETHOD(CreatePropertySheetEx)(
        /*[in]*/ LPCWSTR title,
        /*[in]*/ boolean type,
        /*[in]*/ MMC_COOKIE cookie,
        /*[in]*/ LPDATAOBJECT pIDataObject,
        /*[in]*/ LONG_PTR lpMasterTreeNode,
        /*[in]*/ DWORD dwOptions)  = 0;

    /*[helpstring("Collects the pages from the extension snap-in(s)")]*/
    STDMETHOD(AddMultiSelectionExtensionPages)(LONG_PTR lMultiSelection)  = 0;

    /*[helpstring("Determine if the property sheet exist")]*/
    STDMETHOD(FindPropertySheetEx)(/*[in]*/ MMC_COOKIE cookie, /*[in]*/ LPCOMPONENT lpComponent,
                              /*[in]*/ LPCOMPONENTDATA lpComponentData, /*[in]*/ LPDATAOBJECT lpDataObject)  = 0;

    /*[helpstring("Set data required for property sheet tooltips")]*/
    STDMETHOD(SetPropertySheetData)(/*[in]*/ INT nPropSheetType, /*[in]*/ HMTNODE hMTNode)  = 0;
};


const long CCLV_HEADERPAD = 25;



// helpstring("MMC Default listview interface"),
MMC_INTERFACE(IMMCListView, 1B3C1392-D68B-11CF-8C2B-00AA003CA9F6) : IUnknown
{
    STDMETHOD(GetListStyle)( void )  = 0;

    STDMETHOD(SetListStyle)(
        /*[in]*/    long        nNewValue )  = 0;

    STDMETHOD(GetViewMode)( void )  = 0;

    STDMETHOD(SetViewMode)(
        /*[in]*/    long        nViewMode )  = 0;

    STDMETHOD(InsertItem)(
        /*[in]*/    LPOLESTR    str,
        /*[in]*/    long        iconNdx,
        /*[in]*/    LPARAM      lParam,
        /*[in]*/    long        state,
        /*[in]*/    long        ownerID,
        /*[in]*/    long        itemIndex,
        /*[out]*/   CResultItem*& pri) = 0;

    /* parameter changed to HRESULTITEM, not to use the CResultItem*
       pointer until we know it is not a virtual list  */
    STDMETHOD(DeleteItem)(
        /*[in]*/    HRESULTITEM  itemID,
        /*[in]*/    long        nCol)  = 0;

    STDMETHOD(FindItemByLParam)(
        /*[in]*/    long        owner,
        /*[in]*/    LPARAM      lParam,
        /*[out]*/   CResultItem*& pri)  = 0;

    STDMETHOD(InsertColumn)(
        /*[in]*/    int         nCol,
        /*[in]*/    LPCOLESTR   str,
        /*[in]*/    long        nFormat,
        /*[in]*/    long        width)  = 0;

    STDMETHOD(DeleteColumn)(
        /*[in]*/    int         nCol)  = 0;

    STDMETHOD(DeleteAllItems)(
        /*[in]*/    long        ownerID)  = 0;

    STDMETHOD(SetColumn)(
        /*[in]*/    long        nCol,
        /*[in]*/    LPCOLESTR   str,
        /*[in]*/    long        nFormat,
        /*[in]*/    long        width)  = 0;

    STDMETHOD(GetColumn)(
        /*[in]*/    long        nCol,
        /*[out]*/   LPOLESTR*   str,
        /*[out]*/   long*       nFormat,
        /*[out]*/   int*        width)  = 0;

    STDMETHOD(GetColumnCount)(
        /*[out]*/   int*        nColCnt)  = 0;

    STDMETHOD(SetItem)(
        /*[in]*/    int         nIndex,
        /*[in]*/    CResultItem*  pri,
        /*[in]*/    long        nCol,
        /*[in]*/    LPOLESTR    str,
        /*[in]*/    long        nImage,
        /*[in]*/    LPARAM      lParam,
        /*[in]*/    long        nState,
        /*[in]*/    long        ownerID)  = 0;

    STDMETHOD(GetItem)(
        /*[in]*/    int         nIndex,
        /*[in]*/    CResultItem*& pri,
        /*[in]*/    long        nCol,
        /*[out]*/   LPOLESTR*   str,
        /*[out]*/   int*        nImage,
        /*[in]*/    LPARAM*     lParam,
        /*[out]*/   unsigned int* nState,
        /*[out]*/   BOOL*       pbScopeItem)  = 0;

    STDMETHOD(GetNextItem)(
        /*[in]*/    COMPONENTID ownerID,
        /*[in]*/    long        nIndex,
        /*[in]*/    UINT        nState,
        /*[out]*/   CResultItem*& ppListItem,
        /*[out]*/   long&       nIndexNextItem)  = 0;

    STDMETHOD(GetLParam)(
        /*[in]*/    long        nItem,
        /*[out]*/   CResultItem*& pri)  = 0;

    STDMETHOD(ModifyItemState)(
        /*[in]*/    long        nItem,
        /*[in]*/    CResultItem*  pri,
        /*[in]*/    UINT        add,
        /*[in]*/    UINT        remove)  = 0;

    STDMETHOD(SetIcon)(
        /*[in]*/    long        nID,
        /*[in]*/    HICON       hIcon,
        /*[in]*/    long        nLoc)  = 0;

    STDMETHOD(SetImageStrip)(
        /*[in]*/    long        nID,
        /*[in]*/    HBITMAP     hbmSmall,
        /*[in]*/    HBITMAP     hbmLarge,
        /*[in]*/    long        nStartLoc,
        /*[in]*/    long        cMask) = 0;

    STDMETHOD(MapImage)(
        /*[in]*/    long        nID,
        /*[in]*/    long        nLoc,
        /*[out]*/   int*        pResult)  = 0;

    STDMETHOD(Reset)()  = 0;

    STDMETHOD(Arrange)(/*[in]*/ long style)  = 0;

    STDMETHOD(UpdateItem)(/*[in]*/HRESULTITEM itemID)  = 0;

    STDMETHOD(Sort)(
        /*[in]*/    LPARAM      lUserParam,
        /*[in]*/    long*       pParams)  = 0;


    STDMETHOD(SetItemCount)(
        /*[in]*/    int         nItemCount,
        /*[in]*/    DWORD       dwOptions)  = 0;

    STDMETHOD(SetVirtualMode)(
        /*[in]*/    BOOL        bVirtual)  = 0;

    STDMETHOD(Repaint)(
        /*[in]*/    BOOL        bErase)  = 0;

    STDMETHOD(SetChangeTimeOut)(
        /*[in]*/    ULONG        lTimeout)  = 0;

    STDMETHOD(SetColumnFilter)(
        /*[in]*/    int             nCol,
        /*[in]*/    DWORD           dwType,
        /*[in]*/    MMC_FILTERDATA* pFilterData)  = 0;

    STDMETHOD(GetColumnFilter)(
        /*[in]*/     int             nCol,
        /*[in,out]*/ DWORD*          dwType,
        /*[in,out]*/ MMC_FILTERDATA* pFilterData)  = 0;

    STDMETHOD(SetColumnSortIcon)(
        /*[in]*/     int             nNewCol,
        /*[in]*/     int             nOldCol,
        /*[in]*/     BOOL            bAscending,
        /*[in]*/     BOOL            bSetSortIcon)  = 0;

    STDMETHOD(SetLoadMode)(
        /*[in]*/    BOOL        bState)  = 0;

    /*[helpstring("Get the current list view header settings.")]*/
    STDMETHOD(GetColumnInfoList) (/*[out]*/CColumnInfoList *pColumnsList) = 0;

    /*[helpstring("Modify the list-view headers with given data.")]*/
    STDMETHOD(ModifyColumns) (/*[in]*/const CColumnInfoList& columnsList) = 0;

    /* Put the specified list item into rename mode */
    STDMETHOD(RenameItem) ( /*[in]*/HRESULTITEM itemID)  =0;

    /*[helpstring("Get the column settings that snapin supplied originally")]*/
    STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList) = 0;
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.1 changes
////

// MMC_ITASK, internal form of MMC_TASK has additional field for classid.
struct MMC_ITASK
{
    MMC_TASK task;
    LPOLESTR szClsid;
};



    // helpstring("Console <=> CIC communication conduit"),
    MMC_INTERFACE(ITaskPadHost, 4f7606d0-5568-11d1-9fea-00600832db4a) : IUnknown
    {
        /*[helpstring("CIC calls this when snapin's script wants to notify the snapin of something")]*/
        STDMETHOD(TaskNotify)(/*[in,string]*/ BSTR szClsid, /*[in]*/ VARIANT * pvArg, /*[in]*/ VARIANT * pvParam)  = 0;

        /*[helpstring("CIC calls this when the script asks for tasks")]*/
        STDMETHOD(GetTaskEnumerator)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ IEnumTASK** ppEnumTASK)  = 0;

        /*[helpstring("Returns the primary snapins IExtendTaskPad")]*/
        STDMETHOD(GetPrimaryTask)(/*[out]*/ IExtendTaskPad** ppExtendTaskPad)  = 0;

        /*[helpstring("Returns the primary snapin's taskpad title")]*/
        STDMETHOD(GetTitle)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ BSTR * szTitle)  = 0;

        /*[helpstring("Descriptive Text for the default task pad.")]*/
        STDMETHOD(GetDescriptiveText)(/*[in,string]*/ BSTR pszGroup, /*[out]*/ BSTR * pszDescriptiveText)  = 0;

        /*[helpstring("Returns the primary snapin's taskpad background image.")]*/
        STDMETHOD(GetBackground)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ MMC_TASK_DISPLAY_OBJECT * pTDO)  = 0;

//      /*[helpstring("Returns the primary snapin's taskpad branding info.")]*/
//      STDMETHOD(GetBranding)(/*[in,string]*/ BSTR szGroup, /*[out]*/ MMC_TASK_DISPLAY_OBJECT * pTDO)  = 0;

        /*[helpstring("Returns the primary snapin's listpad info")]*/
        STDMETHOD(GetListPadInfo)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ MMC_ILISTPAD_INFO * pIListPadInfo)  = 0;
    };



    // helpstring("Interface for accessing strings in a console file"),
    MMC_INTERFACE(IStringTablePrivate, 461A6010-0F9E-11d2-A6A1-0000F875A9CE) : IUnknown
    {
        /*[helpstring("Add a string to the snap-in's string table")]*/
        STDMETHOD(AddString)(
            /*[in]*/  LPCOLESTR      pszAdd,    // string to add to the string table
            /*[out]*/ MMC_STRING_ID* pStringID, // ID of added string
            /*[in]*/  const CLSID *  pCLSID     // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Retrieves a string from the snap-in's string table")]*/
        STDMETHOD(GetString)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string
            /*[in]*/  ULONG         cchBuffer,  // number of characters in lpBuffer
            /*[out, size_is(cchBuffer)]*/
                  LPOLESTR      lpBuffer,   // string corresponding to wStringID
            /*[out]*/ ULONG*        pcchOut,    // number of characters written to lpBuffer
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Retrieves the length of a string in the snap-in's string table")]*/
        STDMETHOD(GetStringLength)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string
            /*[out]*/ ULONG*        pcchString, // number of characters in string, not including terminator
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Delete a string from the snap-in's string table")]*/
        STDMETHOD(DeleteString)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string to delete
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Delete all strings from the snap-in's string table")]*/
        STDMETHOD(DeleteAllStrings)(
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Find a string in the snap-in's string table")]*/
        STDMETHOD(FindString)(
            /*[in]*/  LPCOLESTR      pszFind,   // string to find in the string table
            /*[out]*/ MMC_STRING_ID* pStringID, // ID of string, if found
            /*[in]*/  const CLSID *  pCLSID     // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Returns an enumerator into a snap-in's string table")]*/
        STDMETHOD(Enumerate)(
            /*[out]*/ IEnumString** ppEnum,     // string enumerator
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;
    };



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.2 changes
////

// ITaskCallback

// helpstring("Task callback. Handles the drawing and selection notifications of tasks"),
MMC_INTERFACE(ITaskCallback, 4b2293ba-e7ba-11d2-883c-00c04f72c717) : IUnknown
{
    /*[helpstring("Determines whether to display "Edit" and "Delete" items for this taskpad.")]*/
    STDMETHOD(IsEditable)()  = 0;

    /*[helpstring("Modifies the underlying taskpad.")]*/
    STDMETHOD(OnModifyTaskpad)()  = 0;

    /*[helpstring("Deletes the underlying taskpad.")]*/
    STDMETHOD(OnDeleteTaskpad)()  = 0;

    /*[helpstring("Gets the GUID identifier of the underlying taskpad.")]*/
    STDMETHOD(GetTaskpadID)(/*[out]*/ GUID *pGuid)  = 0;
};

// helpstring("Interface for releasing Node Manager's cached com objects"),
MMC_INTERFACE(IComCacheCleanup, 35FEB982-55E9-483b-BD15-149F3F9E6C63) : IUnknown
{
    /* gives a chance to release cached OLE objects prior to calling OleUninitialize */
    STDMETHOD(ReleaseCachedOleObjects)()  = 0;
};

#endif // __ndmgrpriv_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\popwarn.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       popwarn.h
 *
 *  Contents:   This file pops the current compiler's warning state from
 *              the stack, if the compiler supports it.
 * 
 *              pushwarn.h is the complement to this file.
 *
 *  History:    17-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if (_MSC_VER >= 1200)
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\pickicon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      pickicon.h
 *
 *  Contents:  Interface file for PickIconDlg (copied from shell)
 *
 *  History:   13-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

MMCBASE_API INT_PTR PASCAL
MMC_PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\objmodelptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objmodelptrs.h
//
//--------------------------------------------------------------------------

#pragma once

#ifndef OBJMODELPTRS_H
#define OBJMODELPTRS_H

DEFINE_COM_SMARTPTR(_Application);      // _ApplicationPtr
DEFINE_COM_SMARTPTR(Document);          // DocumentPtr
DEFINE_COM_SMARTPTR(Column);            // Column
DEFINE_COM_SMARTPTR(Columns);           // Columns
DEFINE_COM_SMARTPTR(ContextMenu);       // ContextMenuPtr
DEFINE_COM_SMARTPTR(Frame);             // FramePtr
DEFINE_COM_SMARTPTR(MenuItem);          // MenuItemPtr
DEFINE_COM_SMARTPTR(Node);              // NodePtr
DEFINE_COM_SMARTPTR(Nodes);             // NodesPtr
DEFINE_COM_SMARTPTR(Properties);        // PropertiesPtr
DEFINE_COM_SMARTPTR(Property);          // PropertyPtr
DEFINE_COM_SMARTPTR(ScopeNamespace);    // ScopeNamespacePtr
DEFINE_COM_SMARTPTR(SnapIn);            // SnapInPtr
DEFINE_COM_SMARTPTR(SnapIns);           // SnapInsPtr
DEFINE_COM_SMARTPTR(View);              // ViewPtr
DEFINE_COM_SMARTPTR(Views);             // ViewsPtr
DEFINE_COM_SMARTPTR(Extension);         // ExtensionPtr
DEFINE_COM_SMARTPTR(Extensions);        // ExtensionsPtr


#endif // OBJMODELPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\observer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       observer.h
//
//--------------------------------------------------------------------------

#ifndef _OBSERVER_H_
#define _OBSERVER_H_

#include <vector>

// Event source interface template
// Defines event source class for specific observer class 
template <class Observer>
    class EventSource
    {
    public:
        STDMETHOD(Advise)(Observer* pObserver, LONG_PTR* pCookie) = 0;
        STDMETHOD(Unadvise)(LONG_PTR Cookie) = 0;
    };

// Event source implementation template
// Defines implementation of event source for a specific observer class
// maintains a vector of the active observers of this event source       
template <class Observer>
class ATL_NO_VTABLE EventSourceImpl : EventSource<Observer>
{
    typedef std::list<Observer*> ObserverList;
    typedef typename std::list<Observer*>::iterator ObserverIter;
     
    public:
        STDMETHOD(Advise)(Observer* pObserver, LONG_PTR* plCookie);
        STDMETHOD(Unadvise)(LONG_PTR lCookie);
            
    protected:
        ~EventSourceImpl() 
        {
            // verify there are no obervers when going away
            ASSERT(m_Observers.empty()); 
        }

        ObserverList  m_Observers;
};

template <class Observer>
    STDMETHODIMP EventSourceImpl<Observer>::Advise(Observer* pObserver, LONG_PTR* plCookie)
    {
        ASSERT(pObserver != NULL);
        ASSERT(plCookie != NULL);

        ObserverIter iter = m_Observers.insert(m_Observers.end(), pObserver);

	    // can't cast iterator to LONG_PTR so check size before cheating
	    ASSERT(sizeof(ObserverIter) == sizeof(LONG_PTR));
		*(ObserverIter*)plCookie = iter;

        return S_OK;
    }

template <class Observer>
    STDMETHODIMP EventSourceImpl<Observer>::Unadvise(LONG_PTR lCookie)
    {
		// Can't cast LONG_PTR to iterator, so have to cheat 
		// see Advise method for size check
	    ObserverIter iter;
		*(LONG_PTR*)&iter = lCookie;

        m_Observers.erase(iter);
        return S_OK;
    }

// Observer enumerator helper
// Provides for-loop header for iterating over observers of a specified observer class  
#define FOR_EACH_OBSERVER(ObserverClass, ObserverIter) \
for ( \
    std::list<ObserverClass*>::iterator ObserverIter = EventSourceImpl<ObserverClass>::m_Observers.begin(); \
    ObserverIter != EventSourceImpl<ObserverClass>::m_Observers.end(); \
    ++ObserverIter \
    )
     
#endif // _OBSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\npd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       npd.h
//
//--------------------------------------------------------------------------

#ifndef NPD_H
#define NPD_H

#ifndef COMDBG_H
#include <comdbg.h>
#endif

// {118B559C-6D8C-11d0-B503-00C04FD9080A}
extern const GUID IID_PersistData;

#if _MSC_VER < 1100
class PersistData : public IUnknown, public CComObjectRoot
#else
class __declspec(uuid("118B559C-6D8C-11d0-B503-00C04FD9080A")) PersistData : 
                                      public IUnknown, public CComObjectRoot
#endif
{
public:
    BEGIN_COM_MAP(PersistData)
        COM_INTERFACE_ENTRY(PersistData)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(PersistData)

    HRESULT Initialize(IStorage* pRoot, BOOL bSameAsLoad)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = bSameAsLoad;

        if (bSameAsLoad)
            return Open();
        return Create();
    }

    HRESULT Create(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Create();
    }

    HRESULT Open(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Open();
    }

    IStorage* GetRoot()
    {
        return m_spRoot;
    }

    BOOL SameAsLoad()
    {
        return m_bSameAsLoad;
    }

    void SetSameAsLoad(BOOL bSame = TRUE)
    {
        m_bSameAsLoad = bSame;
    }

    void ClearSameAsLoad()
    {
        m_bSameAsLoad = FALSE;
    }
                                     
    IStream* GetTreeStream()
    {
        return m_spTreeStream;
    }

    IStorage* GetNodeStorage()
    {
        return m_spNodeStorage;
    }

protected:
    explicit PersistData()
        : m_bSameAsLoad(TRUE)
    {
    }

    virtual ~PersistData()
    {
    }

private:
    IStoragePtr m_spRoot;
    BOOL m_bSameAsLoad;
    IStreamPtr m_spTreeStream;
    IStoragePtr m_spNodeStorage;

    explicit PersistData(const PersistData&);
        // No copy.

    PersistData& operator=(const PersistData&);
        // No copy.

    HRESULT Create()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Create the stream for the tree
        HRESULT hr = CreateDebugStream(m_spRoot, L"tree",
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree",
                                                            &m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

        // Create the storage for the nodes
        hr = CreateDebugStorage(m_spRoot, L"nodes",
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes",
                                                            &m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }

    HRESULT Open()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Open the stream for the trees persistent data.
        HRESULT hr = OpenDebugStream(m_spRoot, L"tree",
                STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree", &m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

        // Open the storage for the nodes
        hr = OpenDebugStorage(m_spRoot, L"nodes",
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes", 
                                                            &m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }
}; // class PersistData

DEFINE_COM_SMARTPTR(PersistData);   // PersistDataPtr

#endif // NPD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\pushwarn.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       pushwarn.h
 *
 *  Contents:   This file pushes the current compiler's warning state on
 *              the stack, if the compiler supports it.
 * 
 *              popwarn.h is the complement to this file.
 *
 *  History:    17-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if (_MSC_VER >= 1200)
#pragma warning (push)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\picon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      picon.h
 *
 *  Contents:  Interface file for CPersistableIcon
 *
 *  History:   19-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef PICON_H
#define PICON_H
#pragma once

#include <objidl.h>     // for IStorage
#include "tstring.h"
#include "smarticon.h"
#include "cpputil.h"

class CPersistableIconData
{
public:
    CPersistableIconData() :
        m_nIndex (-1)
    {}

    CPersistableIconData(LPCTSTR pszIconFile, int nIndex) :
        m_strIconFile (pszIconFile), m_nIndex (nIndex)
    {}

    // default copy construction and assignment are fine
//  CPersistableIconData (const CPersistableIconData& other)
//  CPersistableIconData& operator= (const CPersistableIconData& other)

    void Clear ()
    {
        m_strIconFile.erase();
        m_nIndex = -1;

        ASSERT (m_strIconFile.empty());
    }

    bool operator== (const CPersistableIconData& other) const
        { return ((m_nIndex == other.m_nIndex) && (m_strIconFile == other.m_strIconFile)); }

    bool operator!= (const CPersistableIconData& other) const
        { return (!operator== (other)); }


public:
    tstring m_strIconFile;
    int     m_nIndex;

};

class CXMLPersistableIcon;

class CPersistableIcon
{
	DECLARE_NOT_COPIABLE   (CPersistableIcon);
	DECLARE_NOT_ASSIGNABLE (CPersistableIcon);

    // these guys need to assign new icons to the object
    friend class CXMLPersistableIcon;
    friend HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon);

public:
	CPersistableIcon () {}
   ~CPersistableIcon ();

    operator bool () const
        { return (!m_Data.m_strIconFile.empty()); }

    bool operator== (const CPersistableIconData& data) const
        { return (m_Data == data); }

    bool operator!= (const CPersistableIconData& data) const
        { return (m_Data != data); }

    CPersistableIcon& operator= (const CPersistableIconData& data);

	HRESULT GetIcon (int nIconSize, CSmartIcon& icon) const;

    void GetData (CPersistableIconData& data) const
        { data = m_Data; }

    HRESULT Load (LPCWSTR pszFilename);
    HRESULT Load (IStorage* pstg);

private:
    void Cleanup();
    bool ExtractIcons();


private:
    CPersistableIconData    m_Data;
	CSmartIcon				m_icon16;
	CSmartIcon				m_icon32;

    static const LPCWSTR s_pszDefaultStorage;
    static const LPCWSTR s_pszIconFileStream;
    static const LPCWSTR s_pszIconBitsStream;

};


IStream& operator>> (IStream& stm,       CPersistableIconData& data);

extern const LPCWSTR g_pszCustomDataStorage;


#endif /* PICON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\rsltitem.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      rsltitem.h
 *
 *  Contents:  Interface file for CResultItem
 *
 *  History:   13-Dec-1999 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef RSLTITEM_H_INCLUDED
#define RSLTITEM_H_INCLUDED


/*+-------------------------------------------------------------------------*
 * CResultItem
 *
 * This is the class behind the HRESULTITEM.  A pointer to this class is
 * stored as the item data for each item in a non-virtual list.
 *--------------------------------------------------------------------------*/

class CResultItem
{
public:
    CResultItem (COMPONENTID id, LPARAM lSnapinData, int nImage);

    bool        IsScopeItem   () const;
    COMPONENTID GetOwnerID    () const;
    LPARAM      GetSnapinData () const;
    int         GetImageIndex () const;
    HNODE       GetScopeNode  () const;

    void SetSnapinData (LPARAM lSnapinData);
    void SetImageIndex (int nImage);

    static HRESULTITEM  ToHandle (const CResultItem* pri);
    static CResultItem* FromHandle (HRESULTITEM hri);

private:
    const COMPONENTID   m_id;
    int                 m_nImage;

    union
    {
        HNODE           m_hNode;        // if IsScopeItem() == true
        LPARAM          m_lSnapinData;  // if IsScopeItem() == false
    };

#ifdef DBG
    enum { Signature = 0x746c7372 /* "rslt" */ };
    const DWORD         m_dwSignature;
#endif
};


/*+-------------------------------------------------------------------------*
 * CResultItem::CResultItem
 *
 * Constructs a CResultItem.
 *--------------------------------------------------------------------------*/

inline CResultItem::CResultItem (
    COMPONENTID id,
    LPARAM      lSnapinData,
    int         nImage) :
#ifdef DBG
        m_dwSignature (Signature),
#endif
        m_id          (id),
        m_lSnapinData (lSnapinData),
        m_nImage      (nImage)
{}


/*+-------------------------------------------------------------------------*
 * CResultItem::IsScopeItem
 *
 * Returns true if this CResultItem represents a scope item, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CResultItem::IsScopeItem () const
{
    return (m_id == TVOWNED_MAGICWORD);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetOwnerID
 *
 * Returns the COMPONENTID for the componenet that owns this CResultItem.
 *--------------------------------------------------------------------------*/

inline COMPONENTID CResultItem::GetOwnerID () const
{
    return (m_id);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetSnapinData
 *
 * Returns the snap-in's LPARAM for this CResultItem.
 *--------------------------------------------------------------------------*/

inline LPARAM CResultItem::GetSnapinData () const
{
    return (m_lSnapinData);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetScopeNode
 *
 * Returns the HNODE for a CResultItem that represents a scope node.  If the
 * CResultItem does not represent a scope node, NULL is returned.
 *--------------------------------------------------------------------------*/

inline HNODE CResultItem::GetScopeNode () const
{
    return (IsScopeItem() ? m_hNode : NULL);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetImageIndex
 *
 * Returns the image index for a CResultItem.
 *--------------------------------------------------------------------------*/

inline int CResultItem::GetImageIndex () const
{
    return (m_nImage);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::SetSnapinData
 *
 * Sets the snap-in's LPARAM for the CResultItem.
 *--------------------------------------------------------------------------*/

inline void CResultItem::SetSnapinData (LPARAM lSnapinData)
{
    m_lSnapinData = lSnapinData;
}


/*+-------------------------------------------------------------------------*
 * CResultItem::SetImageIndex
 *
 * Sets the image index for a CResultItem.
 *--------------------------------------------------------------------------*/

inline void CResultItem::SetImageIndex (int nImage)
{
    m_nImage = nImage;
}


/*+-------------------------------------------------------------------------*
 * CResultItem::ToHandle
 *
 * Converts a CResultItem to a HRESULTITEM.
 *--------------------------------------------------------------------------*/

inline HRESULTITEM CResultItem::ToHandle (const CResultItem* pri)
{
    return (reinterpret_cast<HRESULTITEM>(const_cast<CResultItem*>(pri)));
}


/*+-------------------------------------------------------------------------*
 * CResultItem::FromHandle
 *
 * Converts a HRESULTITEM to a CResultItem*.  This function cannot use
 * dynamic_cast because there are no virtual functions and therefore no
 * place to store RTTI.
 *--------------------------------------------------------------------------*/

inline CResultItem* CResultItem::FromHandle (HRESULTITEM hri)
{
    if ((hri == NULL) || IS_SPECIAL_LVDATA (hri))
        return (NULL);

    CResultItem* pri = reinterpret_cast<CResultItem*>(hri);

    ASSERT (pri->m_dwSignature == Signature);
    return (pri);
}


#endif /* RSLTITEM_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\smarticon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      smarticon.h
 *
 *  Contents:  Interface file for CSmartIcon
 *
 *  History:   25-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include <windows.h>	// for HICON  when building uicore.lib, which has no PCH
#include "stddbg.h"		// for ASSERT when building uicore.lib, which has no PCH


/*+-------------------------------------------------------------------------*
 * class CSmartIcon
 *
 *
 * PURPOSE: A smart wrapper for icons. Destroys the icon when all references
 *          to the icon are released.
 *
 *
 * USAGE:   1) Create the icon and assign to a smart icon:
 *              smarticon.Attach(::CreateIcon(...));
 *
 *          NOTE: The Attach method will destroy the icon if the underlying
 *          CSmartIconData object cannot be created because of insufficient memory.
 *
 *          2) Smart icons can be treated as icons:
 *              DrawIcon(..., smarticon, ...)
 *
 *          3) Smart icons can be assigned to one another just like handles:
 *              smarticon1 = smarticon2;
 *
 *+-------------------------------------------------------------------------*/
class CSmartIcon
{
public:
    CSmartIcon () : m_pData(NULL) {}
   ~CSmartIcon ();
	CSmartIcon (const CSmartIcon& other);
	CSmartIcon& operator= (const CSmartIcon& rhs);

    void  Attach  (HICON hIcon);
    HICON Detach  ();				// let go without decrementing ref count
    void  Release ();				// let go, decrementing ref count

    operator HICON() const
    {
        return m_pData
            ? m_pData->operator HICON()
            : NULL;
    }

    /*
     * for comparison to NULL (only)
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);
        return (operator HICON() == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);
        return (operator HICON() != NULL);
    }

private:
    class CSmartIconData
    {
        HICON	m_hIcon;
        DWORD	m_dwRefs;

        CSmartIconData(HICON hIcon) : m_hIcon(hIcon), m_dwRefs(1) {}

       ~CSmartIconData()
		{
			if (m_hIcon != NULL)
				::DestroyIcon (m_hIcon);
		}

	public:
		static CSmartIconData* CreateInstance(HICON hIcon)	{ return new CSmartIconData(hIcon);	}
        operator HICON() const								{ return m_hIcon; }

		HICON Detach();
        void AddRef()           {++m_dwRefs;}
        void Release()
        {
            if((--m_dwRefs)==0)
				delete this;
        }
    };

private:
    CSmartIconData* m_pData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\serial.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      serial.h
 *
 *  Contents:  Object serialization class definitions
 *
 *  History:   11-Feb-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef SERIAL_H
#define SERIAL_H
                                                         
/*+-------------------------------------------------------------------------*
 * class CSerialObject
 * 
 *
 * PURPOSE: Base class for objects that can be serialized.
 *
 *+-------------------------------------------------------------------------*/
class CSerialObject
{
public:
    HRESULT Read (IStream &stm);

protected: // implemented by the derived class
    // virtual CStr GetName()      =0;
    virtual UINT    GetVersion()   =0;

    // return values for ReadSerialObject: S_OK: succeeded, S_FALSE: unknown version
    // E_UNEXPECTED: catastrophic error.
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/) = 0;  
};

/*+-------------------------------------------------------------------------*
 * class CSerialObjectRW
 * 
 *
 * PURPOSE: Provided to separate from CSerialObject the "Write" functionality 
 *          which is much less frequently used
 *
 *+-------------------------------------------------------------------------*/
class CSerialObjectRW : public CSerialObject
{
public:
    HRESULT Write(IStream &stm);

protected: // implemented by the derived class

    virtual HRESULT WriteSerialObject(IStream &stm) = 0;
};

//############################################################################
//############################################################################
//
//  template functions - std::list class
//
//############################################################################
//############################################################################
template<class T, class Al> 
HRESULT Read(IStream& stm, std::list<T, Al>& l)
{   
    HRESULT hr = S_OK;

    try
    {
        int cSize;
        stm >> cSize;

        for(int i=0 ; i<cSize; i++)
        {
            T t;
            hr = t.Read(stm);   // read the underlying object
            BREAK_ON_FAIL (hr);

            l.push_back(t);     // add it to the list
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}

template<class T, class Al> 
HRESULT Write(IStream& stm, std::list<T, Al>& l)
{   
    HRESULT hr = S_OK;

    try
    {
        int cSize = l.size();

        // write out the length
        stm << cSize;

        // write out the members
        for(std::list<T, Al>::iterator it = l.begin(); it != l.end(); ++it)
        {
            hr = it->Write (stm);
            BREAK_ON_FAIL (hr);
        }
        
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}



#endif // SERIAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\resultview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ResultViewInfo.h
//
//  History:    Jan-18-2000 VivekJ Added
//--------------------------------------------------------------------------
#ifndef _RESULTVIEW_H
#define _RESULTVIEW_H

/*+-------------------------------------------------------------------------*
 * class CResultViewType
 *
 *
 * PURPOSE: Provides a wrapper for the RESULT_VIEW_TYPE_INFO structure, and
 *          is used for communication between conui and nodemgr.
 *
 *+-------------------------------------------------------------------------*/
class CResultViewType : public CXMLObject
{
    typedef std::wstring wstring; // only wide strings are needed here.

protected:
    virtual void Persist(CPersistor &persistor);

    DEFINE_XML_TYPE(XML_TAG_RESULTVIEWTYPE);

public:
    CResultViewType();
    CResultViewType &   operator =(RESULT_VIEW_TYPE_INFO &rvti); // conversion from a RESULT_VIEW_TYPE_INFO structure

    bool operator != (const CResultViewType& rvt) const;

    // the default copy constructor and assignment operators are sufficient

    MMC_VIEW_TYPE   GetType()        const  {return m_viewType;}
    DWORD           GetListOptions() const  {return m_dwListOptions;}
    DWORD           GetHTMLOptions() const  {return m_dwHTMLOptions;}
    DWORD           GetOCXOptions()  const  {return m_dwOCXOptions;}
    DWORD           GetMiscOptions() const  {return m_dwMiscOptions;}

    BOOL            HasList()        const  {return (m_viewType==MMC_VIEW_TYPE_LIST);}
    BOOL            HasWebBrowser()  const  {return (m_viewType==MMC_VIEW_TYPE_HTML);}
    BOOL            HasOCX()         const  {return (m_viewType==MMC_VIEW_TYPE_OCX);}

    LPCOLESTR       GetURL()         const  {return m_strURL.data();}
    LPCOLESTR       GetOCX()         const  {return m_strOCX.data();}

    LPUNKNOWN       GetOCXUnknown()  const  {return m_spUnkControl;} // returns the IUnknown of the OCX.

    bool            IsPersistableViewDescriptionValid() const {return m_bPersistableViewDescriptionValid;}
    bool            IsMMC12LegacyData()                 const {return !IsPersistableViewDescriptionValid();}

    SC              ScInitialize(LPOLESTR & pszView, long lMiscOptions); // the legacy case.
    SC              ScGetOldTypeViewOptions(long* plViewOptions) const;
    SC              ScReset();

// functions specific to nodemgr. Do NOT add any member variables in this section.
#ifdef _NODEMGR_DLL_
    SC              ScInitialize(RESULT_VIEW_TYPE_INFO &rvti);

    SC              ScGetResultViewTypeInfo(RESULT_VIEW_TYPE_INFO& rvti) const;
#endif _NODEMGR_DLL_


private:
    bool            m_bPersistableViewDescriptionValid;
    bool            m_bInitialized;

    MMC_VIEW_TYPE   m_viewType;

    wstring         m_strURL;
    wstring         m_strOCX;           // for snapins that implement IComponent only.
    wstring         m_strPersistableViewDescription;

    DWORD           m_dwMiscOptions;
    DWORD           m_dwListOptions;
    DWORD           m_dwHTMLOptions;
    DWORD           m_dwOCXOptions;

    CComPtr<IUnknown>   m_spUnkControl;     // a smart pointer for the control created by the snapin.

};

inline CResultViewType::CResultViewType()
:
  m_viewType(MMC_VIEW_TYPE_LIST), // the default view type
  m_dwMiscOptions(0),
  m_dwListOptions(0),
  m_dwHTMLOptions(0),
  m_dwOCXOptions(0),
  m_bPersistableViewDescriptionValid(false),
  m_bInitialized(false)
{
}

//+-------------------------------------------------------------------
//
//  Member:      CResultViewType::ScReset
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CResultViewType::ScReset ()
{
    DECLARE_SC(sc, _T("CResultViewType::ScReset"));

    m_viewType         = MMC_VIEW_TYPE_LIST; // the default view type
    m_dwMiscOptions    = 0;
    m_dwListOptions    = 0;
    m_dwHTMLOptions    = 0;
    m_dwOCXOptions     = 0;

    m_bPersistableViewDescriptionValid = false;
    m_bInitialized     = false;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::operator!=
 *
 * PURPOSE: Operator != (Used by CViewSettings which is used by CMemento).
 *
 * NOTE:    For MMC2 compare only persistable view desc for MMC1.2 compare all
 *          parameters.
 *
 *+-------------------------------------------------------------------------*/
inline
bool CResultViewType::operator != (const CResultViewType& rvt) const
{
    if (m_bInitialized != rvt.m_bInitialized)
        return true;

    if (m_bPersistableViewDescriptionValid)
    {
        if (m_strPersistableViewDescription != rvt.m_strPersistableViewDescription)
            return true;

        return false;
    }

    // Legacy case MMC1.2, should compare other parameters.
    switch(m_viewType)
    {
    default:
        ASSERT(FALSE && _T("Unknown view type"));
        break;

    case MMC_VIEW_TYPE_LIST:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwListOptions != rvt.m_dwListOptions) )
        {
            return true;
        }
        break;

    case MMC_VIEW_TYPE_HTML:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwHTMLOptions != rvt.m_dwHTMLOptions) ||
             (m_strURL != rvt.m_strURL) )
        {
            return true;
        }

        break;

    case MMC_VIEW_TYPE_OCX:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwOCXOptions  != rvt.m_dwOCXOptions) ||
             (m_strOCX != rvt.m_strOCX) )
        {
            return true;
        }
        break;
    }

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScInitialize
 *
 * PURPOSE: Initializes the class from parameters returned by IComponent::
 *          GetResultViewType
 *
 * PARAMETERS:
 *    LPOLESTR  ppViewType :
 *    long      lViewOptions :
 *
 * RETURNS:
 *    SC
 *
 * NOTE:     This is for MMC1.2 compatible GetResultViewType.
 *
 *+-------------------------------------------------------------------------*/
inline
SC CResultViewType::ScInitialize(LPOLESTR & pszView, long lViewOptions)
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));

    m_bInitialized = true;

    m_bPersistableViewDescriptionValid = false; // the legacy case - we don't have a persistable view description.

    // MMC_VIEW_OPTIONS_NOLISTVIEWS is a special case - it goes to the dwMiscOptions
    if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)
        m_dwMiscOptions |= RVTI_MISC_OPTIONS_NOLISTVIEWS;

    // check whether the type of view is a web page or OCX.
    if ( (NULL == pszView) || (_T('\0') == pszView[0]) )
    {
        // the result pane is a standard list
        m_viewType = MMC_VIEW_TYPE_LIST;

        m_dwListOptions = 0;

        // convert the view options from the old bits to the new ones
        if(lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST)                   m_dwListOptions |= RVTI_LIST_OPTIONS_OWNERDATALIST;
        if(lViewOptions & MMC_VIEW_OPTIONS_MULTISELECT)                     m_dwListOptions |= RVTI_LIST_OPTIONS_MULTISELECT;
        if(lViewOptions & MMC_VIEW_OPTIONS_FILTERED)                        m_dwListOptions |= RVTI_LIST_OPTIONS_FILTERED;
        if(lViewOptions & MMC_VIEW_OPTIONS_USEFONTLINKING)                  m_dwListOptions |= RVTI_LIST_OPTIONS_USEFONTLINKING;
        if(lViewOptions & MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST)   m_dwListOptions |= RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
        if(lViewOptions & MMC_VIEW_OPTIONS_LEXICAL_SORT)                    m_dwListOptions |= RVTI_LIST_OPTIONS_LEXICAL_SORT;

    }
    else
    {
        // the result pane is a web page or an OCX.

        if (L'{' == pszView[0]) // the hacky way of ensuring that the result view is an OCX
        {
            m_viewType = MMC_VIEW_TYPE_OCX;
            m_strOCX   = pszView;

            // If the snapin says "create new" then do not "cache the ocx"
            if(!(lViewOptions & MMC_VIEW_OPTIONS_CREATENEW))   m_dwOCXOptions |= RVTI_OCX_OPTIONS_CACHE_OCX;

            if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)    m_dwOCXOptions |= RVTI_OCX_OPTIONS_NOLISTVIEW;
        }
        else
        {
            m_viewType = MMC_VIEW_TYPE_HTML;
            m_strURL   = pszView;

            if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)    m_dwHTMLOptions |= RVTI_HTML_OPTIONS_NOLISTVIEW;
        }
    }

    // make sure we free the allocated memory.
    if(pszView != NULL)
    {
        ::CoTaskMemFree(pszView);
        pszView = NULL; // NOTE: pszView is a reference, so this changes the in parameter.
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CResultViewType::Persist
//
//  Synopsis:   persist to / from XML document.
//
//  Arguments:  [persistor]  - target or source.
//
//--------------------------------------------------------------------
inline
void CResultViewType::Persist(CPersistor& persistor)
{
    if ( (! m_bInitialized) &&
         (persistor.IsStoring()) )
    {
        SC sc;
        (sc = E_UNEXPECTED).Throw();
    }
    else
        m_bInitialized = true;

    if (persistor.IsLoading())
        m_bPersistableViewDescriptionValid = persistor.HasElement(XML_TAG_RESULTVIEW_DESCRIPTION, NULL);

    if (m_bPersistableViewDescriptionValid)
    {
        CPersistor persistorDesc(persistor, XML_TAG_RESULTVIEW_DESCRIPTION);
        persistorDesc.PersistContents(m_strPersistableViewDescription);
        return;
    }

    // Legacy code for MMC1.2
    {
        int &viewType = (int&) m_viewType;

        // define the table to map enumeration values to strings
        static const EnumLiteral mappedViewTypes[] =
        {
            { MMC_VIEW_TYPE_LIST,   XML_ENUM_MMC_VIEW_TYPE_LIST },
            { MMC_VIEW_TYPE_HTML,   XML_ENUM_MMC_VIEW_TYPE_HTML },
            { MMC_VIEW_TYPE_OCX,    XML_ENUM_MMC_VIEW_TYPE_OCX },
        };

        const size_t countof_types = sizeof(mappedViewTypes)/sizeof(mappedViewTypes[0]);
        // create wrapper to persist flag values as strings
        CXMLEnumeration viewTypePersistor(viewType, mappedViewTypes, countof_types );
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_TYPE, viewTypePersistor);

        switch(m_viewType)
        {
        case MMC_VIEW_TYPE_LIST:
            {
                // define the table to map enumeration flags to strings
                static const EnumLiteral mappedLVOptions[] =
                {
                    { RVTI_LIST_OPTIONS_OWNERDATALIST,      XML_BITFLAG_LIST_OPTIONS_OWNERDATALIST },
                    { RVTI_LIST_OPTIONS_MULTISELECT,        XML_BITFLAG_LIST_OPTIONS_MULTISELECT },
                    { RVTI_LIST_OPTIONS_FILTERED,           XML_BITFLAG_LIST_OPTIONS_FILTERED },
                    { RVTI_LIST_OPTIONS_USEFONTLINKING,     XML_BITFLAG_LIST_OPTIONS_USEFONTLINKING },
                    { RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST,  XML_BITFLAG_LIST_OPTIONS_NO_SCOPE_ITEMS },
                    { RVTI_LIST_OPTIONS_LEXICAL_SORT,       XML_BITFLAG_LIST_OPTIONS_LEXICAL_SORT },
                };

                const size_t countof_options = sizeof(mappedLVOptions)/sizeof(mappedLVOptions[0]);

                // create wrapper to persist flag values as strings
                CXMLBitFlags optPersistor(m_dwListOptions, mappedLVOptions, countof_options);
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, optPersistor);
            }
            break;

        case MMC_VIEW_TYPE_HTML:
            {
                // NOT USED - persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, m_dwHTMLOptions);
                m_dwHTMLOptions = 0;
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_URL_STRING, m_strURL);
            }
            break;

        case MMC_VIEW_TYPE_OCX:
            {
                // define the table to map enumeration flags to strings
                static const EnumLiteral mappedOCXOptions[] =
                {
                    { RVTI_OCX_OPTIONS_CACHE_OCX,      XML_BITFLAG_OCX_OPTIONS_CACHE_OCX },
                };

                const size_t countof_options = sizeof(mappedOCXOptions)/sizeof(mappedOCXOptions[0]);

                // create wrapper to persist flag values as strings
                CXMLBitFlags optPersistor(m_dwOCXOptions, mappedOCXOptions, countof_options);
                // persist the wrapper
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, optPersistor);
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OCX_STRING, m_strOCX);
            }
            break;

        default:
            ASSERT(FALSE && _T("Unknown MMC_VIEW_TYPE"));
            break;
        }

        // define the table to map enumeration flags to strings
        static const EnumLiteral mappedMiscOptions[] =
        {
            { RVTI_MISC_OPTIONS_NOLISTVIEWS,  _T("Misc_NoListViews") },
        };

        const size_t countof_miscoptions = sizeof(mappedMiscOptions)/sizeof(mappedMiscOptions[0]);

        // create wrapper to persist flag values as strings
        CXMLBitFlags miscPersistor(m_dwMiscOptions, mappedMiscOptions, countof_miscoptions);
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_MISC_OPTIONS, miscPersistor);
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScGetOldTypeViewOptions
 *
 * PURPOSE: This method is for compatibility with MMC1.2. It makes MMC1.2 compatible
 *          view option for MMCN_RESTORE_VIEW.
 *
 * PARAMETERS:
 *    [out] long*      plViewOptions :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CResultViewType::ScGetOldTypeViewOptions(long* plViewOptions) const
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));
    sc = ScCheckPointers(plViewOptions);
    if (sc)
        return sc;

    *plViewOptions = 0;

    if(! m_bInitialized)
        return (sc = E_UNEXPECTED); // should be initialized.

    if (m_bPersistableViewDescriptionValid)
        return (sc = E_UNEXPECTED); // Not MMC1.2 type data.

    if (HasWebBrowser())
    {
        if (m_dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS)
            *plViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        return sc;
    }

    if (HasList())
    {
        if(m_dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST)  *plViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_MULTISELECT)    *plViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_FILTERED)       *plViewOptions |= MMC_VIEW_OPTIONS_FILTERED;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_USEFONTLINKING) *plViewOptions |= MMC_VIEW_OPTIONS_USEFONTLINKING;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST) *plViewOptions |= MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_LEXICAL_SORT)   *plViewOptions |= MMC_VIEW_OPTIONS_LEXICAL_SORT;

        return sc;
    }
    else if(HasOCX())
    {
        // NOTE: The CREATENEW flag has the opposite sense of the CACHE_OCX flag.
        if(!(m_dwOCXOptions  & RVTI_OCX_OPTIONS_CACHE_OCX))    *plViewOptions |= MMC_VIEW_OPTIONS_CREATENEW;
        if (m_dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS)    *plViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        return sc;
    }

    return (sc = E_UNEXPECTED);
}


#ifdef _NODEMGR_DLL_
/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScInitialize
 *
 * PURPOSE: Initializes the class from a RESULT_VIEW_TYPE_INFO structure.
 *
 * PARAMETERS:
 *    RESULT_VIEW_TYPE_INFO & rvti :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CResultViewType::ScInitialize(RESULT_VIEW_TYPE_INFO &rvti)
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));

    if(m_bInitialized)
        return (sc = E_UNEXPECTED); // should not try to initialize twice

    m_bInitialized = true;

    // make sure we have a persistable view description.
    if(!rvti.pstrPersistableViewDescription)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(TEXT("Parameter 'pstrPersistableViewDescription' in structure 'RESULT_VIEW_TYPE_INFO' is NULL"), sc);
        return sc;
    }

    // copy the description
    m_strPersistableViewDescription     = rvti.pstrPersistableViewDescription;
    ::CoTaskMemFree(rvti.pstrPersistableViewDescription);
    rvti.pstrPersistableViewDescription = NULL; // just to make sure we don't try to use it
    m_bPersistableViewDescriptionValid  = true;

    // validate the view type
    m_viewType = rvti.eViewType;
    if( (m_viewType != MMC_VIEW_TYPE_LIST) &&
        (m_viewType != MMC_VIEW_TYPE_OCX)  &&
        (m_viewType != MMC_VIEW_TYPE_HTML) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(TEXT("Parameter 'eViewType' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
        return sc;
    }

	m_dwMiscOptions = rvti.dwMiscOptions;

    // validate the various view options
    switch(m_viewType)
    {
    default:
        ASSERT(0 && "Should not come here");
        return (sc = E_INVALIDARG);
        break;

    case MMC_VIEW_TYPE_LIST:
        if(rvti.dwListOptions & ~( RVTI_LIST_OPTIONS_NONE                          |
                                   RVTI_LIST_OPTIONS_OWNERDATALIST                 | RVTI_LIST_OPTIONS_MULTISELECT    |
                                   RVTI_LIST_OPTIONS_FILTERED                      | RVTI_LIST_OPTIONS_USEFONTLINKING |
                                   RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST | RVTI_LIST_OPTIONS_LEXICAL_SORT   |
								   RVTI_LIST_OPTIONS_ALLOWPASTE )
                                   )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwListOptions' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
            return sc;
        }

        m_dwListOptions = rvti.dwListOptions;

        break;

    case MMC_VIEW_TYPE_HTML:
        // if the view type is HTML, make sure that no flags are set. If snapins wrongly set this flag, it could break our well
        // intentioned effort to add future expansion
        if(rvti.dwHTMLOptions & ~( RVTI_HTML_OPTIONS_NONE |
                                   RVTI_HTML_OPTIONS_NOLISTVIEW) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwHTMLOptions' in structure 'RESULT_VIEW_TYPE_INFO' must be zero"), sc);
            return sc;
        }

        // make sure we have a valid URL
        if(NULL == rvti.pstrURL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'pstrURL' in structure 'RESULT_VIEW_TYPE_INFO' cannot be NULL"), sc);
            return sc;
        }

        m_dwHTMLOptions = 0;

        // copy the URL
        m_strURL     = rvti.pstrURL;
        ::CoTaskMemFree(rvti.pstrURL);
        rvti.pstrURL = NULL; // just to make sure we don't try to use it

        break;

    case MMC_VIEW_TYPE_OCX:
        if(rvti.dwOCXOptions & ~( RVTI_OCX_OPTIONS_NONE |
                                  RVTI_OCX_OPTIONS_NOLISTVIEW |
                                  RVTI_OCX_OPTIONS_CACHE_OCX) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwOCXOptions' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
            return sc;
        }

        // if an OCX was specified, must have a valid OCX control IUnknown
        if(rvti.pUnkControl == NULL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("No OCX specified in parameter 'pUnkControl' of structure 'RESULT_VIEW_TYPE_INFO'"), sc);
            return sc;
        }

        m_dwOCXOptions = rvti.dwOCXOptions;
        m_spUnkControl = rvti.pUnkControl; // does an addref, but rvti.ppUnkControl already had an addref set by the snapin. So need to release it once.
		rvti.pUnkControl->Release();
        break;
    }


    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CResultViewType::ScGetResultViewTypeInfo
//
//  Synopsis:    Fill the RESULT_VIEW_TYPE_INFO struct and return.
//
//  Arguments:   [rvti] - Fill the struct and return.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC
CResultViewType::ScGetResultViewTypeInfo (RESULT_VIEW_TYPE_INFO& rvti) const
{
    DECLARE_SC(sc, _T("CResultViewType::ScGetResultViewTypeInfo"));

    if(! m_bInitialized)
        return (sc = E_UNEXPECTED);

    ZeroMemory(&rvti, sizeof(rvti));
    rvti.pstrPersistableViewDescription = NULL;

    // must have a persistable description
    if (!IsPersistableViewDescriptionValid())
        return (sc = E_UNEXPECTED);

    int cchDest = (1 + wcslen(m_strPersistableViewDescription.data()));

    rvti.pstrPersistableViewDescription = (LPOLESTR) CoTaskMemAlloc( cchDest * sizeof(OLECHAR));
    sc = ScCheckPointers(rvti.pstrPersistableViewDescription, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // copy over the description string.
    sc = StringCchCopyW(rvti.pstrPersistableViewDescription, cchDest, m_strPersistableViewDescription.data());
    if(sc)
        return sc;

    return (sc);
}
#endif _NODEMGR_DLL_

#endif //_RESULTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\refcount.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      refcount.h
 *
 *  Contents:  Interface file for reference counting templates
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef REFCOUNT_H
#define REFCOUNT_H
#pragma once

#include "stddbg.h"


template<class T> class CRefCountedObject;
template<class T> class CRefCountedPtr;


/*+-------------------------------------------------------------------------*
 * CRefCountedObject
 *
 * Template reference-counted object class, intended to be used in
 * conjuction with CRefCountedPtr<T>.
 *
 * Typically, you'd use this like so:
 *
 *      class CClassWithoutRefCounting;
 *      typedef CRefCountedObject<CClassWithoutRefCounting> CClassWithRefCounting;
 *
 *      CClassWithRefCounting::SmartPtr m_spClass;
 *      m_spClass.CreateInstance ();
 *--------------------------------------------------------------------------*/

template<class BaseClass>
class CRefCountedObject : public BaseClass
{
public:
    typedef CRefCountedObject<BaseClass>    ThisClass;
    typedef CRefCountedPtr<ThisClass>       SmartPtr;

    CRefCountedObject () : m_cRefs (0) {}

private:
    /*
     * CRefCountedObject's should only be created on the heap,
     * so we'll protect the dtor so it can only be deleted from
     * Release, not by automatic object unwinding
     */
    ~CRefCountedObject () {}

public:
    static ThisClass* CreateInstance ()
    {
        return (new ThisClass);
    }

    LONG AddRef()
    {
        return (InterlockedIncrement (&m_cRefs));
    }

    LONG Release()
    {
        /*
         * if this assert fails, we have mismatched AddRef/Release's
         */
        ASSERT (m_cRefs > 0);

        LONG rc = InterlockedDecrement (&m_cRefs);

        if (rc == 0)
            delete this;

        return (rc);
    }

    LONG m_cRefs;

private:
    /*
     * CRefCountedObject's are not meant to be copied or assigned
     */
    CRefCountedObject (const CRefCountedObject& other);             // no impl
    CRefCountedObject& operator= (const CRefCountedObject& other);  // no impl
};


/*+-------------------------------------------------------------------------*
 * CRefCountedPtr
 *
 * Template reference-counted smart pointer class, intended to be used in
 * conjuction with CRefCountedObject<T>.
 *
 * T must implement CreateInstance, AddRef and Release.  It can do this
 * intrisically, or use the implementation in CRefCountedObject like this:
 *
 *      class CClassWithoutRefCounting;
 *      typedef CRefCountedObject<CClassWithoutRefCounting> CClassWithRefCounting;
 *--------------------------------------------------------------------------*/

template<class T>
class CRefCountedPtr
{
public:
    CRefCountedPtr (T* pRealObject = NULL) :
        m_pRealObject (pRealObject)
    {
        SafeAddRef();
    }

    CRefCountedPtr (const CRefCountedPtr<T>& other) :
        m_pRealObject (other.m_pRealObject)
    {
        SafeAddRef();
    }

    ~CRefCountedPtr ()
    {
        SafeRelease();
    }

    T* operator->() const
    {
        return (m_pRealObject);
    }

    operator T*() const
    {
        return (m_pRealObject);
    }

    T& operator*() const
    {
        return (*m_pRealObject);
    }

    T** operator&()
    {
        ASSERT (m_pRealObject == NULL);
        return (&m_pRealObject);
    }

    CRefCountedPtr<T>& operator= (const CRefCountedPtr<T>& other)
    {
        return (operator= (other.m_pRealObject));
    }

    CRefCountedPtr<T>& operator= (T* pOtherObject)
    {
        if (pOtherObject != m_pRealObject)
        {
            T* pOldObject = m_pRealObject;
            m_pRealObject = pOtherObject;
            SafeAddRef();

            if (pOldObject != NULL)
                pOldObject->Release();
        }

        return (*this);
    }

    bool CreateInstance()
    {
        SafeRelease();
        m_pRealObject = T::CreateInstance();
        if (m_pRealObject == NULL)
            return (false);

        m_pRealObject->AddRef();
        return (true);
    }

    LONG AddRef()
    {
        return (SafeAddRef());
    }

    LONG Release()
    {
        LONG cRefs = SafeRelease();
        m_pRealObject = NULL;
        return (cRefs);
    }

    void Attach(T* pNewObject)
    {
        if (pNewObject != m_pRealObject)
        {
            SafeRelease();
            m_pRealObject = pNewObject;
        }
    }

    T* Detach()
    {
        T* pOldObject = m_pRealObject;
        m_pRealObject = NULL;
        return (pOldObject);
    }

    bool operator!() const
    {
        return (m_pRealObject == NULL);
    }

    bool operator==(const CRefCountedPtr<T>& other)
    {
        return (m_pRealObject == other.m_pRealObject);
    }

    bool operator!=(const CRefCountedPtr<T>& other)
    {
        return (m_pRealObject != other.m_pRealObject);
    }

    /*
     * for comparison to NULL
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);
        return (m_pRealObject == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);
        return (m_pRealObject != NULL);
    }


protected:
    LONG SafeAddRef ()
    {
        return ((m_pRealObject) ? m_pRealObject->AddRef() : 0);
    }

    LONG SafeRelease ()
    {
        return ((m_pRealObject) ? m_pRealObject->Release() : -1);
    }


protected:
    T*  m_pRealObject;

};


#endif /* REFCOUNT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\sitebase.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      SiteBase.h
 *
 *  Contents:  Header file for CAxWindowImplT. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/
#pragma once
#ifndef __SITEBASE_H_
#define __SITEBASE_H_

//------------------------------------------------------------------------------------------------------------------
//
//
//
#include "AxWin2.H"

template <typename TDerived, typename TWindow = CAxWindow2>
class CAxWindowImplT : public CWindowImplBaseT< TWindow >     
{
public:
    typedef CAxWindowImplT<TWindow> thisClass;
    
public:
    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_CREATE,OnCreate)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNCDestroy)
    END_MSG_MAP()

    //
    DECLARE_WND_SUPERCLASS(_T("AtlAxWinEx"),CAxWindow::GetWndClassName()) 
    

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        if (GetWndClassInfo().m_lpszOrigName == NULL)
            GetWndClassInfo().m_lpszOrigName = GetWndClassName();
        ATOM atom = GetWndClassInfo().Register(&m_pfnSuperWindowProc);

        dwStyle = GetWndStyle(dwStyle);
        dwExStyle = GetWndExStyle(dwExStyle);

        return CWindowImplBaseT<TWindow>::Create(hWndParent, rcPos, szWindowName,dwStyle, dwExStyle, nID,atom, lpCreateParam);

    }   
    
    HRESULT AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl = 0, REFIID iidSink = IID_NULL, IUnknown* punkSink = 0)
    {
        return AtlAxCreateControlEx(lpszName, hWnd, pStream,ppUnkContainer,ppUnkControl,iidSink,punkSink);
    }

public:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        ::OleInitialize(NULL);

        CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
        int nLen = ::GetWindowTextLength(m_hWnd);
        LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
        ::GetWindowText(m_hWnd, lpstrName, nLen + 1);
        ::SetWindowText(m_hWnd, _T(""));
        IAxWinHostWindow* pAxWindow = NULL;
        int nCreateSize = 0;
        if (lpCreate && lpCreate->lpCreateParams)
            nCreateSize = *((WORD*)lpCreate->lpCreateParams);
        HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
        CComPtr<IStream> spStream;
        if (h && nCreateSize)
        {
            BYTE* pBytes = (BYTE*) GlobalLock(h);
            BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
            //Align to DWORD
            //pSource += (((~((DWORD)pSource)) + 1) & 3);
            memcpy(pBytes, pSource, nCreateSize);
            GlobalUnlock(h);
            CreateStreamOnHGlobal(h, TRUE, &spStream);
        }
        USES_CONVERSION;
        CComPtr<IUnknown> spUnk;
        TDerived* pT = static_cast<TDerived*>(this);
        HRESULT hRet = pT->AxCreateControl2(T2COLE(lpstrName), m_hWnd, spStream, &spUnk);
        if(FAILED(hRet))
            return -1;  // abort window creation
        hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        if(FAILED(hRet))
            return -1;  // abort window creation
        ::SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
        // check for control parent style if control has a window
        HWND hWndChild = ::GetWindow(m_hWnd, GW_CHILD);
        if(hWndChild != NULL)
        {
            if(::GetWindowLong(hWndChild, GWL_EXSTYLE) & WS_EX_CONTROLPARENT)
            {
                DWORD dwExStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
                dwExStyle |= WS_EX_CONTROLPARENT;
                ::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle);
            }
        }
        
        bHandled = TRUE;
        return 0L;
    }
    LRESULT OnNCDestroy(UINT , WPARAM , LPARAM , BOOL& bHandled)
    {
        IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(m_hWnd, GWLP_USERDATA);
        if(pAxWindow != NULL)
            pAxWindow->Release();
        OleUninitialize();
        m_hWnd = 0;
        bHandled = TRUE;
        return 0L;
    }

};

//-----------------------------------------------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\safetemp.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SafeTemp.h
//
//  Contents:   A template for safe pointers.
//
//  Classes:    XSafeInterfacePtr<ISome>
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


//____________________________________________________________________________
//
//  Template:   XSafeInterfacePtr
//
//  Purpose:    Safe pointer to any interface that supports AddRef/Release
//
//  Notes:      This works for classes that define AddRef/Release, or for
//              OLE interfaces. It is not necessary that the class
//              be a derivative of IUnknown, so long as it supports
//              AddRef and Release methods which have the same semantics as
//              those in IUnknown.
//
//              The constructor takes a parameter which specifies whether
//              the captured pointer should be AddRef'd, defaulting to TRUE.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


template<class ISome>
class XSafeInterfacePtr
{
public:

    inline XSafeInterfacePtr(ISome * pinter=NULL, BOOL fInc=TRUE)
        : _p ( pinter )
    {
        if (fInc && (_p != NULL))
        {
            _p->AddRef();
        }
    }

    inline ~XSafeInterfacePtr()
    {
        if (_p != NULL)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline BOOL IsNull(void)
    {
        return (_p == NULL);
    }

    inline void Copy(ISome **pxtmp)
    {
        *pxtmp = _p;
        if (_p != NULL)
            _p->AddRef();
    }

    inline void Transfer(ISome **pxtmp)
    {
        *pxtmp = _p;
        _p = NULL;
    }

    inline void Set(ISome* p, BOOL fInc = TRUE)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
        if (fInc && _p)
        {
            _p->AddRef();
        }
    }

    inline void SafeRelease(void)
    {
        if (_p)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline void SimpleRelease(void)
    {
        ASSERT(_p != NULL);
        _p->Release();
        _p = NULL;
    }

    inline void Attach(ISome* p)
    {
        ASSERT(_p == NULL);
        _p = p;
    }

    inline void Detach(void)
    {
        _p = NULL;
    }

    inline ISome * operator-> () { return _p; }

    inline ISome& operator * () { return *_p; }

    inline operator ISome *() { return _p; }

    inline ISome ** operator &()
    {
        ASSERT( _p == NULL );
        return &_p;
    }

    inline ISome *Self(void) { return _p; }

private:

    ISome * _p;

    inline  void operator= (const XSafeInterfacePtr &) {;}

    inline  XSafeInterfacePtr(const XSafeInterfacePtr &){;}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________

#include "admindbg.h"
#include <tchar.h>      // for _T
#include <string>


//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #ifdef DBG
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#define DEB_RESOURCE    DEB_USER10      // Constructor/Destructor
#define DEB_METHOD      DEB_USER11
#define DEB_FUNCTION    DEB_USER12

#undef  ASSERT
#undef  VERIFY


#ifdef DBG

    #define Dbg                         DBG_COMP.DebugOut

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    
    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_DESTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this);

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n"));

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

    /*
     * COMPILETIME_ASSERT(f)
     *
     * Generates a build break at compile time if the constant expression
     * is not true.  Unlike the "#if" compile-time directive, the expression
     * in COMPILETIME_ASSERT() is allowed to use "sizeof".
     *
     * Compiler magic!  If the expression "f" is FALSE, then you get 
     * 
     *      error C2196: case value '0' already used
     */
    #define COMPILETIME_ASSERT(f) switch (0) case 0: case f: break;


#else

    inline void __DummyDbg(ULONG, LPCWSTR, ...) { }
    inline void __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __DummyTrace(LPCWSTR, ...) { }
    inline void __DummyTrace(LPCSTR, ...) { }

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   (e)

    #define ASSERT(e)
    #define VERIFY(e)   (e)
    #define COMPILETIME_ASSERT(f)

#endif // DBG


#ifdef DBG

    /*
     * this is a roundabout way of getting this accomplished (real impl is
     * in stddbg.cpp), but it gets around a compiler bug that won't allow
     * us to ignore C4786.
     */
    struct CDebugLeakDetectorBase
    {
        virtual ~CDebugLeakDetectorBase() = 0 {};

        virtual void DumpLeaks() = 0;
        virtual int AddRef(const std::string& strClass) = 0;
        virtual int Release(const std::string& strClass) = 0;
    };

    extern CDebugLeakDetectorBase& GetLeakDetector();

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    GetLeakDetector().AddRef(#cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    GetLeakDetector().Release(#cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    

#endif 





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#ifdef DBG

class CTraceTag;
class tstring;

struct DBG_PersistTraceData
{
    DBG_PersistTraceData();
  
    void TraceErr(LPCTSTR strInterface, LPCTSTR msg);
    typedef void (*PTraceErrorFn)(LPCTSTR szError);

    void SetTraceInfo(PTraceErrorFn pFN, bool bComponent, const tstring& owner);

    PTraceErrorFn pTraceFN;
    bool       bIComponent;
    bool       bIComponentData;
    // cannot use tstring - it cannot be defined here
    // since this file is included at the top of tstring.h
#ifdef UNICODE
    std::wstring    strSnapin;
#else
    std::string     strSnapin;
#endif
};

#endif // DBG

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\toolbars.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      toolbars.h
 *
 *  Contents:  Defines the (non-COM) interface classes that are used for
 *             communication between conui and nodemgr
 *
 *  History:   30-Aug-99 AnandhaG     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TOOLBARS_H
#define TOOLBARS_H
#pragma once

//+-------------------------------------------------------------------
//
//  class:     CMenuButtonNotify
//
//  Purpose:   Menubutton click notification hanlder interface.
//             When the user clicks a menubutton, MMC calls the
//             method ScNotifyMenuBtnClick of this interface.
//             This is implemented by whoever adds a menubutton.
//             (ie: snapins & MMC menus).
//
//  History:   30-Aug-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButtonNotify
{
public:
    virtual SC ScNotifyMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    MENUBUTTONDATA& menuButtonData) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CMenuButtonsMgr
//
//  Purpose:   An interface to manipulate MenuButton UI.
//
//  History:   30-Aug-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButtonsMgr
{
public:
    virtual SC ScAddMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                               INT idCommand, LPCOLESTR lpButtonText,
                               LPCOLESTR lpStatusText) = 0;
    virtual SC ScModifyMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                  INT idCommand, LPCOLESTR lpButtonText,
                                  LPCOLESTR lpStatusText) = 0;
    virtual SC ScModifyMenuButtonState(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand, MMC_BUTTON_STATE nState,
                                       BOOL bState) = 0;
    virtual SC ScAttachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk) = 0;
    virtual SC ScDetachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk) = 0;

    virtual SC ScDisableMenuButtons() = 0;

    // The following members will be part of CMenuButtonsMgrImpl
    // after "Customize View" dialog is moved to Conui
    virtual SC ScToggleMenuButton(BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CToolbarNotify
//
//  Purpose:   Toolbutton click notification hanlder interface.
//             When the user clicks a toolbutton, MMC calls the
//             method ScNotifyToolBarClick of this interface.
//             This is implemented by whoever adds a toolbar.
//             (ie: snapins & MMC stdbar).
//
//  History:   12-Oct-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CToolbarNotify
{
public:
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    UINT nID) = 0;
    virtual SC ScAMCViewToolbarsBeingDestroyed() = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CStdVerbButtons
//
//  Purpose:   An interface used by nodemgr to manipulate std-verb buttons.
//
//  History:   26-Oct-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CStdVerbButtons
{
public:
    virtual SC ScUpdateStdbarVerbs(IConsoleVerb* pCV) = 0;
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, IConsoleVerb* pCV = NULL) = 0;
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag) = 0;
    virtual SC ScShow(BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CMMCToolbarIntf
//
//  Purpose:   An interface to manipulate Toolbar UI.
//
//  History:   05-Dec-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMMCToolbarIntf
{
public:
    virtual SC ScAddButtons(CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons) = 0;
    virtual SC ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages, HBITMAP hbmp, COLORREF crMask) = 0;
    virtual SC ScInsertButton(CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton) = 0;
    virtual SC ScDeleteButton(CToolbarNotify* pNotifyCallbk, int nIndex) = 0;
    virtual SC ScGetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL* pbState) = 0;
    virtual SC ScSetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL bState) = 0;
    virtual SC ScAttach(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScDetach(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScDelete(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScShow(CToolbarNotify* pNotifyCallbk, BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CAMCViewToolbarsMgr
//
//  Purpose:   An interface to create/disable Toolbar. (Rename this
//             to CToolbarsMgr once old one is removed).
//
//  History:   05-Dec-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CAMCViewToolbarsMgr
{
public:
    virtual SC ScCreateToolBar(CMMCToolbarIntf** ppToolbarIntf) = 0;
    virtual SC ScDisableToolbars() = 0;
};

#endif /* TOOLBARS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\stgio.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stgio.h
 *
 *  Contents:  Interface file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STGIO_H
#define STGIO_H
#pragma once

#include <objidl.h>     // for IStream
#include <string>       // for std::string, std::wstring
#include <list>         // for std::list
#include <vector>       // for std::vector
#include <deque>        // for std::deque
#include <map>          // for std::map, std::multimap
#include <set>          // for std::set, std::multiset


#define DeclareStreamOperators(type)                    \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm,       type  t);      
                                                        
#define DeclareStreamOperatorsByRef(type)               \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm, const type& t);


/*
 * Writing these small types by value allows convenient usage with 
 * literals and constants like:
 *
 *      str << (char) 'a';
 *
 * instead of the bulkier and less convenient:
 *
 *      char ch = 'a';
 *      str << ch;
 */
DeclareStreamOperators (bool);
DeclareStreamOperators (         char);
DeclareStreamOperators (unsigned char);
DeclareStreamOperators (         short);
DeclareStreamOperators (unsigned short);
DeclareStreamOperators (         int);
DeclareStreamOperators (unsigned int);
DeclareStreamOperators (         long);
DeclareStreamOperators (unsigned long);
DeclareStreamOperators (         __int64);
DeclareStreamOperators (unsigned __int64);
DeclareStreamOperators (float);
DeclareStreamOperators (double);
DeclareStreamOperators (long double);


/*
 * These are relatively large and unlikely to be used with literals,
 * so write by const reference
 */
DeclareStreamOperatorsByRef (CLSID);
DeclareStreamOperatorsByRef (std::string);
DeclareStreamOperatorsByRef (std::wstring);

template<class T1, class T2>
IStream& operator>> (IStream& stm,       std::pair<T1, T2>& p);
template<class T1, class T2>
IStream& operator<< (IStream& stm, const std::pair<T1, T2>& p);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::list<T, Al>& l);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::list<T, Al>& l);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::deque<T, Al>& d);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::deque<T, Al>& d);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::vector<T, Al>& v);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::vector<T, Al>& v);

template<class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::set<T, Pr, Al>& s);
template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::set<T, Pr, Al>& s);

template<class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::multiset<T, Pr, Al>& s);
template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<T, Pr, Al>& s);

template<class K, class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::map<K, T, Pr, Al>& m);
template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::map<K, T, Pr, Al>& m);

template<class K, class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::multimap<K, T, Pr, Al>& m);
template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<K, T, Pr, Al>& m);


#include "stgio.inl"

#endif /* STGIO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\stgutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       StgUtil.h
//
//  Contents:   Classes to simplify dealing with storage objects.
//
//  Classes:    CDocFile,
//              CIStorage
//              CIStream
//
//  History:    6/3/1996   RaviR   Created
//
//
//  Sample:     Code sample using the above three classes & their safe ptrs.
//
//              Objective: Create a doc file this will be the root storage.
//                         Create a sub storage under this root storage.
//
//              Code:
//                  HRESULT
//                  CerateADocFileWithSubStorage(
//                      WCHAR      wszDocFileName[],
//                      WCHAR      wszSubStgName[],
//                      LPSTORAGE *ppstg)
//                  {
//                      try
//                      {
//                          CDocFile docFile;
//                          docFile.Create(wszDocFileName);
//
//                          CIStorage stgRoot;
//                          docFile.Transfer(&stgRoot);
//
//                          CIStorage stgSub;
//                          stgRoot.CreateStorage(&stgSub, wszSubStgName);
//
//                          stgRoot.Transfer(ppstg);
//                      }
//                      CATCH_FILE_ERROR(hr,cfe)
//							delete cfe;
//                          return hr;
//                      END_CATCH_FILE_ERROR;
//
//                      return S_OK;
//                  }
//
//____________________________________________________________________________
//


#ifndef __STGUTIL__H__
#define __STGUTIL__H__

#include "macros.h"

//
// CDocFile, CIStorage and CIStream throw errors of type CFileException.
// Note, however, that m_cause is always CFileException::generic and
// m_lOsError is an HRESULT rather than a Windows error code.
//

#define THROW_FILE_ERROR2(hr,psz) AfxThrowFileException( CFileException::generic, hr, psz );
#define THROW_FILE_ERROR(hr) THROW_FILE_ERROR2( hr, NULL )

#define CATCH_FILE_ERROR(hr)							\
	catch(CFileException* cfe)							\
	{													\
		if (cfe.m_cause != CFileException::generic)		\
			throw;										\
		HRESULT hr = cfe.m_IOsError;

#define END_CATCH_FILE_ERROR }
		
//____________________________________________________________________________
//
//  Class:      CDocFile
//
//  Synopsis:   CDocFile can be used to create, open & close a docfile.
//              It has one data member, a pointer to the root IStorage
//              interface of the document. Safe interface pointer member
//              functions are created for this data member. (Please see
//              macros.h for description of Safe interface pointer member
//              functions)
//
//  Members:    Create:
//                  Creates/opens a docfile with the given name. The default
//                  mode is to create a docfile with read-write and share
//                  exclusive flags. Throws CFileException on error.
//
//              CreateTemporary:
//                  Creates a temporary docfile, which will be deleted on
//                  release. Throws CFileException on error.
//
//              Open:
//                  Opens an existing docfile. The default mode is read-write
//                  and share exclusive. Throws CFileException on error.
//
//              Safe Interface Pointer Member functions:
//                  Used to access the IStorage interface ptr. (see macros.h)
//
//
//  History:    5/31/1996   RaviR   Created
//
//____________________________________________________________________________
//


class CDocFile
{
public:

    void Create(LPWSTR pwszName,
            DWORD grfMode = STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE);

    void CreateTemporary(void) { this->Create(NULL, STGM_DELETEONRELEASE); }

    void Open(LPWSTR pwszName,
            DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CDocFile, IStorage, m_pstg)

private:
    LPSTORAGE       m_pstg;

}; // class CDocFile



inline
void
CDocFile::Create(
    LPWSTR pswzName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgCreateDocfile(pswzName, grfMode, 0, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pswzName) );
    }
}


inline
void
CDocFile::Open(
    LPWSTR pwszName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgOpenStorage(pwszName, NULL, grfMode, NULL, NULL, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pwszName) );
    }
}


//____________________________________________________________________________
//
//  Class:      CIStorage
//
//  Synopsis:   Represents an IStorage instance - top level or embedded.
//
//  History:    5/29/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStorage.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw CFileException.
//
//              3) Most of the methods have default values for arguments.
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStorage interface ptr.
//
//
//              CIStorage
//                  |
//                  |
//              IStorage
//
//____________________________________________________________________________
//

class CIStorage
{
public:

    void CreateStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                      DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->CreateStream(pszName, grfMode, NULL, NULL, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                       DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStream(pszName, NULL, grfMode, 0, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void CreateStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                          DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);

        HRESULT hr = m_pstg->CreateStorage(pszName, grfMode, NULL, NULL, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(pszName, NULL, grfMode, NULL, 0, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPSTORAGE pstgPriority,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(NULL, pstgPriority, grfMode, NULL, 0, ppstg);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void CopyTo(LPSTORAGE pstgDest)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);

        HRESULT hr = m_pstg->CopyTo(0, NULL, NULL, pstgDest);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void MoveElementTo(LPCOLESTR pszName, LPSTORAGE pstgDest,
                          LPCOLESTR pszNewName, DWORD grfFlags = STGMOVE_MOVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);
        ASSERT(m_pstg != pstgDest);

        HRESULT hr = m_pstg->MoveElementTo(pszName, pstgDest, pszNewName, grfFlags);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Commit(grfCommitFlags);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Revert(void)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Revert();

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void EnumElements(IEnumSTATSTG ** ppenum)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppenum != NULL);

        HRESULT hr = m_pstg->EnumElements(0, NULL, 0, ppenum);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void DestroyElement(LPCOLESTR pszName)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->DestroyElement(pszName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void RenameElement(LPCOLESTR pszOldName, LPCOLESTR pszNewName)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pszOldName != NULL);
        ASSERT(pszNewName != NULL);

        HRESULT hr = m_pstg->RenameElement(pszOldName, pszNewName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetElementTimes(LPCOLESTR pszName, LPFILETIME pctime,
                        LPFILETIME patime = NULL, LPFILETIME pmtime = NULL)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetElementTimes(pszName, pctime, patime, pmtime);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetClass(REFCLSID clsid)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetClass(clsid);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetStateBits(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetStateBits(grfStateBits, grfMask);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Stat(pstatstg, grfStatFlag);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStorage, IStorage, m_pstg)

private:
    IStorage * m_pstg;

}; // class CIStorage




//____________________________________________________________________________
//
//  Class:      CIStream
//
//  Synopsis:   Represents an IStream instance
//
//  History:    5/31/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStream.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw the error(hresult).
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStream interface ptr.
//
//
//              CIStream
//                 |
//                 |
//              IStream
//
//____________________________________________________________________________
//

class CIStream
{
public:

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT);
    void Clone(IStream ** ppstm);
    void Read(PVOID pv, ULONG cb);
    void Write(const VOID * pv, ULONG cb);
    void CopyTo(IStream * pstm, ULARGE_INTEGER cb);
    void GetCurrentSeekPosition(ULARGE_INTEGER * plibCurPosition);
    void Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin = STREAM_SEEK_CUR,
                                ULARGE_INTEGER * plibNewPosition = NULL);
    void SetSize(ULARGE_INTEGER libNewSize);
    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStream, IStream, m_pstm);

private:
    LPSTREAM    m_pstm;

}; // class CIStream


inline
void
CIStream::Clone(
    IStream ** ppstm)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Clone(ppstm);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Commit(
    DWORD grfCommitFlags)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Commit(grfCommitFlags);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Seek(dlibMove, dwOrigin, plibNewPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::GetCurrentSeekPosition
//
//  Synopsis:   Returns the current seek position.
//
//  Arguments:  [plibCurPosition] -- IN
//
//  Returns:    void
//____________________________________________________________________________
//

inline
void
CIStream::GetCurrentSeekPosition(
    ULARGE_INTEGER * plibCurPosition)
{
    ASSERT(m_pstm != NULL);
    ASSERT(plibCurPosition != NULL);

    LARGE_INTEGER li = {0};

    HRESULT hr = m_pstm->Seek(li, STREAM_SEEK_CUR, plibCurPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::SetSize(
    ULARGE_INTEGER libNewSize)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->SetSize(libNewSize);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



inline
void
CIStream::Stat(
    STATSTG   * pstatstg,
    DWORD       grfStatFlag)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstatstg != NULL);

    HRESULT hr = m_pstm->Stat(pstatstg, grfStatFlag);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



#endif // __STGUTIL__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef STRINGS_H_INCLUDED
#define STRINGS_H_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef INIT_MMC_BASE_STRINGS
#define MMC_BASE_STRING_EX(var,t_lit) EXTERN_C LPCTSTR const var = t_lit;
#else
#define MMC_BASE_STRING_EX(var,t_lit) EXTERN_C LPCTSTR const var;
#endif

#define MMC_BASE_STRING(var,lit) MMC_BASE_STRING_EX(var, _T(lit));

MMC_BASE_STRING (  g_szMmcndmgrDll,                 "mmcndmgr.dll" );
MMC_BASE_STRING (  g_szCicDll,                      "cic.dll" );
MMC_BASE_STRING (  g_szCLSID ,                      "CLSID" );
MMC_BASE_STRING (  g_szContextMenu ,                "ContextMenu" );
MMC_BASE_STRING (  g_szImage ,                      "Image" );
MMC_BASE_STRING (  g_szImageOpen ,                  "ImageOpen" );
MMC_BASE_STRING (  g_szImageClosed ,                "ImageClosed" );
MMC_BASE_STRING (  g_szName ,                       "Name" );
MMC_BASE_STRING (  g_szNameString ,                 "NameString" );
MMC_BASE_STRING (  g_szNameStringIndirect ,         "NameStringIndirect" );
MMC_BASE_STRING (  g_szObject ,                     "Object" );
MMC_BASE_STRING (  g_szObjects ,                    "Objects" );
MMC_BASE_STRING (  g_szObjectType ,                 "ObjectType" );
MMC_BASE_STRING (  g_szObjectTypes ,                "ObjectTypes" );
MMC_BASE_STRING (  g_szObjectTypeGUID ,             "ObjectTypeGUID" );
MMC_BASE_STRING (  g_szObjectContext ,              "ObjectContext" );
MMC_BASE_STRING (  g_szPackage ,                    "Package" );
MMC_BASE_STRING (  g_szResultPane ,                 "ResultPane" );
MMC_BASE_STRING (  g_szStatus ,                     "Status" );
MMC_BASE_STRING (  g_szStatusString ,               "StatusString" );
MMC_BASE_STRING (  g_szTree ,                       "Tree" );
MMC_BASE_STRING (  g_szNameSpace ,                  "NameSpace" );
MMC_BASE_STRING (  g_szNodeType ,                   "NodeType" );
MMC_BASE_STRING (  g_szNodeTypes ,                  "NodeTypes" );
MMC_BASE_STRING (  g_szPropertySheet ,              "PropertySheet" );
MMC_BASE_STRING (  g_szStandAlone ,                 "StandAlone" );
MMC_BASE_STRING (  g_szToolbar ,                    "Toolbar" );
MMC_BASE_STRING (  g_szExtensions ,                 "Extensions" );
MMC_BASE_STRING (  g_szTask ,                       "Task" );
MMC_BASE_STRING (  g_szAbout ,                      "About" );
MMC_BASE_STRING (  g_szView ,                       "View" );     // registry key for view extension snapins
MMC_BASE_STRING (  g_szDynamicExtensions ,          "Dynamic Extensions" );
MMC_BASE_STRING (  g_szRestrictAuthorMode ,         "RestrictAuthorMode" );
MMC_BASE_STRING (  g_szRestrictToPermittedList ,    "RestrictToPermittedSnapins" );
MMC_BASE_STRING (  g_szRestrictRun ,                "Restrict_Run" );
MMC_BASE_STRING (  g_szRestrictScriptsFromEnteringAuthorMode ,  "RestrictScriptsEnteringAuthorMode" );
MMC_BASE_STRING (  g_szMaxColumnDataPersisted ,     "MaxColDataPersisted" );
MMC_BASE_STRING (  g_szMaxViewItemsPersisted ,      "MaxViewItemsPersisted" );
MMC_BASE_STRING (  g_szDEFAULT_CONSOLE_EXTENSION ,  ".msc" );

// window class name for the MDI child frame
MMC_BASE_STRING (  g_szChildFrameClassName ,        "MMCChildFrm" );
MMC_BASE_STRING (  g_szAMCViewWndClassName ,        "MMCViewWindow" );
MMC_BASE_STRING (  g_szOCXViewWndClassName ,        "MMCOCXViewWindow" );

MMC_BASE_STRING (  CURRENT_VER_KEY ,                "Software\\Microsoft\\Windows NT\\CurrentVersion" );
MMC_BASE_STRING (  NODE_TYPES_KEY ,                 "Software\\Microsoft\\MMC\\NodeTypes" );
MMC_BASE_STRING (  SNAPINS_KEY ,                    "Software\\Microsoft\\MMC\\SnapIns" );
MMC_BASE_STRING (  SETTINGS_KEY ,                   "Software\\Microsoft\\MMC\\Settings" );
MMC_BASE_STRING (  POLICY_KEY ,                     "Software\\Policies\\Microsoft\\MMC" );

// user data subfolder
MMC_BASE_STRING (  g_szUserDataSubFolder,           "Microsoft\\MMC" );

// XML tags and attribute names used

/*-----------------------------------------------------------------------------------*\
|   Following strings used as element tags in XML document
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_TAG_BOOKMARK ,                "BookMark" );
MMC_BASE_STRING ( XML_TAG_BINARY ,                  "Binary" );
MMC_BASE_STRING ( XML_TAG_BINARY_STORAGE ,          "BinaryStorage" );
MMC_BASE_STRING ( XML_TAG_BITMAP ,                  "Bitmap" );
MMC_BASE_STRING ( XML_TAG_COLUMN_INFO ,             "Column" );
MMC_BASE_STRING ( XML_TAG_COLUMN_INFO_LIST ,        "ColumnSettings" );
MMC_BASE_STRING ( XML_TAG_COLUMN_PERIST_INFO ,      "ColumnSettingsCache" );
MMC_BASE_STRING ( XML_TAG_COLUMN_PERIST_ENTRY ,     "SnapinColumnSettings" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SET ,              "ColumnSet" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SET_DATA ,         "ListViewColumns" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SORT_INFO ,        "SortSettings" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_ICON ,            "Image" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_FILE_UID ,        "ConsoleFileID" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_TASKPAD ,         "ConsoleTaskpad" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_TASKPADS ,        "ConsoleTaskpads" );
MMC_BASE_STRING ( XML_TAG_CUSTOM_DATA ,             "VisualAttributes" );
MMC_BASE_STRING ( XML_TAG_DYNAMIC_PATH_ENTRY ,      "Segment" );
MMC_BASE_STRING ( XML_TAG_EOT_SYMBOL_INFO ,         "Symbol" );
MMC_BASE_STRING ( XML_TAG_LARGE_TASK_ICON ,         "LargeIcon" );
MMC_BASE_STRING ( XML_TAG_SMALL_TASK_ICON ,         "SmallIcon" );
MMC_BASE_STRING ( XML_TAG_FAVORITES_ENTRY ,         "Favorite" );
MMC_BASE_STRING ( XML_TAG_FAVORITES_LIST ,          "Favorites" );
MMC_BASE_STRING ( XML_TAG_FRAME_STATE ,             "FrameState" );
MMC_BASE_STRING ( XML_TAG_HASH_VALUE ,              "HashValue" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT ,              "Component" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_LIST ,         "Components" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_DATA ,         "ComponentData" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_DATA_LIST ,    "ComponentDatas" );
MMC_BASE_STRING ( XML_TAG_ICON ,                    "Icon" );
MMC_BASE_STRING ( XML_TAG_IDENTIFIER_POOL ,         "IdentifierPool" );
MMC_BASE_STRING ( XML_TAG_ISTORAGE ,                "Storage" );
MMC_BASE_STRING ( XML_TAG_ISTREAM ,                 "Stream" );
MMC_BASE_STRING ( XML_TAG_MEMENTO ,                 "ViewMemento" );
MMC_BASE_STRING ( XML_TAG_MMC_CONSOLE_FILE ,        "MMC_ConsoleFile" );
MMC_BASE_STRING ( XML_TAG_MMC_STRING_TABLE ,        "StringTables" );
MMC_BASE_STRING ( XML_TAG_MT_NODE ,                 "Node" );
MMC_BASE_STRING ( XML_TAG_NODE_BITMAPS ,            "Bitmaps" );
MMC_BASE_STRING ( XML_TAG_ORIGINAL_CONSOLE_CRC ,    "SourceChecksum" );
MMC_BASE_STRING ( XML_TAG_POINT ,                   "Point" );
MMC_BASE_STRING ( XML_TAG_RECTANGLE ,               "Rectangle" );
MMC_BASE_STRING ( XML_TAG_RESULTVIEW_DESCRIPTION,   "Description" );
MMC_BASE_STRING ( XML_TAG_SCOPE_TREE ,              "ScopeTree" );
MMC_BASE_STRING ( XML_TAG_SCOPE_TREE_NODES ,        "Nodes" );
MMC_BASE_STRING ( XML_TAG_SNAPIN ,                  "Snapin" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_CACHE ,            "SnapinCache" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_EXTENSION ,        "Extension" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_EXTENSIONS ,       "Extensions" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_PROPERTIES ,       "SnapinProperties" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_PROPERTY ,         "SnapinProperty" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE ,            "Strings" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE_MAP ,        "StringTable" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE_STRING ,     "String" );
MMC_BASE_STRING ( XML_TAG_TASK ,                    "Task" );
MMC_BASE_STRING ( XML_TAG_TASK_CMD_LINE ,           "CommandLine" );
MMC_BASE_STRING ( XML_TAG_TASK_LIST ,               "Tasks" );
MMC_BASE_STRING ( XML_TAG_VALUE_BIN_DATA ,          "BinaryData" );
MMC_BASE_STRING ( XML_TAG_VALUE_BOOL ,              "Boolean" );
MMC_BASE_STRING ( XML_TAG_VALUE_BYTE ,              "Byte" );
MMC_BASE_STRING ( XML_TAG_VALUE_CSTR ,              "String" );
MMC_BASE_STRING ( XML_TAG_VALUE_DWORD ,             "DoubleWord" );
MMC_BASE_STRING ( XML_TAG_VALUE_GUID ,              "GUID" );
MMC_BASE_STRING ( XML_TAG_VALUE_INT ,               "Integer" );
MMC_BASE_STRING ( XML_TAG_VALUE_LONG ,              "Long" );
MMC_BASE_STRING ( XML_TAG_VALUE_SHORT ,             "Short" );
MMC_BASE_STRING ( XML_TAG_VALUE_UINT ,              "UnsignedInteger" );
MMC_BASE_STRING ( XML_TAG_VALUE_ULONG ,             "UsignedLong" );
MMC_BASE_STRING ( XML_TAG_VALUE_UNKNOWN ,           "Unknown" );
MMC_BASE_STRING ( XML_TAG_VALUE_WSTRING ,           "WideString" );
MMC_BASE_STRING ( XML_TAG_VARIANT ,                 "VARIANT" );
MMC_BASE_STRING ( XML_TAG_VIEW ,                    "View" );
MMC_BASE_STRING ( XML_TAG_VIEW_LIST ,               "Views" );
MMC_BASE_STRING ( XML_TAG_VIEW_PERSIST_INFO ,       "ViewSettingsCache" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS ,           "ViewSettings" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS_2 ,         "ViewOptions" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS_ID ,        "TargetView" );
MMC_BASE_STRING ( XML_TAG_WINDOW_PLACEMENT ,        "WindowPlacement" );
MMC_BASE_STRING ( XML_TAG_RESULTVIEWTYPE ,          "ResultView" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as element names in XML ( put as value of attribute 'NAME')
|   This helps in cases we need differentiate between elements of the same type
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_NAME_CLSID_SNAPIN ,           "Snapin" );
MMC_BASE_STRING ( XML_NAME_ICON_LARGE ,             "Large" );
MMC_BASE_STRING ( XML_NAME_ICON_SMALL ,             "Small" );
MMC_BASE_STRING ( XML_NAME_MAX_POSITION ,           "MaxPosition" );
MMC_BASE_STRING ( XML_NAME_MIN_POSITION ,           "MinPosition" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_LARGE ,      "Large" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_SMALL ,      "Small" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_SMALL_OPEN , "SmallOpen" );
MMC_BASE_STRING ( XML_NAME_NORMAL_POSITION ,        "NormalPosition" );
MMC_BASE_STRING ( XML_NAME_ROOT_NODE ,              "RootNode" );
MMC_BASE_STRING ( XML_NAME_SELECTED_NODE ,          "SelectedNode" );
MMC_BASE_STRING ( XML_NAME_TARGET_NODE ,            "TargetNode" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as attribute names in XML document
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_ATTR_CONSOLE_VERSION ,        "ConsoleVersion" );
MMC_BASE_STRING ( XML_ATTR_APPLICATION_MODE ,       "ProgramMode" );
MMC_BASE_STRING ( XML_ATTR_BINARY_REF_INDEX ,       "BinaryRefIndex" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYN_CUSTOM ,    "Custom" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYN_STRING ,    "String" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYNAMIC_PATH ,  "DynamicPath" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_STATIC ,        "NodeID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_COLUMN ,     "Index" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_FORMAT ,     "Format" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_WIDTH ,      "Width" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_SNAPIN ,     "Snapin" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_RANK ,        "Age" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID ,          "ID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_VIEW ,     "ViewID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_FLAGS ,    "Flags" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_PATH ,     "ID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SORT_INFO_COLMN , "ColumnIndex" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SORT_INFO_OPTNS , "SortOptions" );
MMC_BASE_STRING ( XML_ATTR_CONSOLE_ICON_LARGE ,     "CONSOLE_FILE_ICON_LARGE" );
MMC_BASE_STRING ( XML_ATTR_CONSOLE_ICON_SMALL ,     "CONSOLE_FILE_ICON_SMALL" );
MMC_BASE_STRING ( XML_ATTR_CUSTOM_TITLE ,           "ApplicationTitle" );
MMC_BASE_STRING ( XML_ATTR_EOT_SYMBOL_DW_SYMBOL ,   "ID" );
MMC_BASE_STRING ( XML_ATTR_FAVORITE_TYPE ,          "TYPE" );
MMC_BASE_STRING ( XML_ATTR_FRAME_STATE_FLAGS ,      "Flags" );
MMC_BASE_STRING ( XML_ATTR_ICOMPONENT_VIEW_ID ,     "ViewID" );
MMC_BASE_STRING ( XML_ATTR_ICON_FILE ,              "File" );
MMC_BASE_STRING ( XML_ATTR_ICON_INDEX ,             "Index" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_ABSOLUTE_MAX ,   "AbsoluteMax" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_ABSOLUTE_MIN ,   "AbsoluteMin" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_NEXT_AVAILABLE , "NextAvailable" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_ID ,             "ID" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_IMAGE ,          "ImageIdx" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_NAME ,           "Name" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_PRELOAD ,        "Preload" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_SNAPIN_CLSID ,   "CLSID" );
MMC_BASE_STRING ( XML_ATTR_NAME ,                   "Name" );
MMC_BASE_STRING ( XML_ATTR_NODE_BITMAPS_MASK ,      "MaskColor" );
MMC_BASE_STRING ( XML_ATTR_POINT_X ,                "X" );
MMC_BASE_STRING ( XML_ATTR_POINT_Y ,                "Y" );
MMC_BASE_STRING ( XML_ATTR_RECT_BOTTOM ,            "Bottom" );
MMC_BASE_STRING ( XML_ATTR_RECT_LEFT ,              "Left" );
MMC_BASE_STRING ( XML_ATTR_RECT_RIGHT ,             "Right" );
MMC_BASE_STRING ( XML_ATTR_RECT_TOP ,               "Top" );
MMC_BASE_STRING ( XML_ATTR_SHOW_COMMAND ,           "ShowCommand" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_CLSID ,           "CLSID" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_EXTN_ENABLED ,    "AllExtensionsEnabled" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_EXTN_TYPES ,      "ExtensionTypes" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_PROP_FLAGS ,      "Flags" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_PROP_NAME ,       "Name" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_ID ,    "ID" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_VALUE,  "Value" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_REFS ,  "Refs" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_DIR ,      "Directory" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_PARAMS ,   "Params" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_WIN_ST ,   "WindowState" );
MMC_BASE_STRING ( XML_ATTR_TASK_COMMAND ,           "Command" );
MMC_BASE_STRING ( XML_ATTR_TASK_DESCRIPTION ,       "Description" );
MMC_BASE_STRING ( XML_ATTR_TASK_FLAGS ,             "Flags" );
MMC_BASE_STRING ( XML_ATTR_TASK_NAME ,              "Name" );
MMC_BASE_STRING ( XML_ATTR_TASK_TYPE ,              "Type" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_DESCRIPTION ,    "Description" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_ID ,             "ID" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NAME ,           "Name" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NODE_SPECIFIC ,  "IsNodeSpecific" );
MMC_BASE_STRING ( XML_ATTR_REPLACES_DEFAULT_VIEW ,  "ReplacesDefaultView" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NODE_TYPE ,      "NodeType" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_ORIENTATION ,    "Orientation" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_TOOLTIP ,        "Tooltip" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_LIST_SIZE,       "ListSize");
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_LARGE ,        "Large" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_MEDIUM ,       "Medium" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_NONE ,         "None" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_SMALL ,        "Small" );
MMC_BASE_STRING ( XML_ATTR_VARIANT_TYPE ,           "Type" );
MMC_BASE_STRING ( XML_ATTR_VARIANT_VALUE ,          "Value" );
MMC_BASE_STRING ( XML_ATTR_VIEW_ID ,                "ID" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SCOPE_WIDTH ,       "ScopePaneWidth" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DB_VISIBLE , "DescriptionBarVisible" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DEF_COL_W0 , "DefaultColumn0Width" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DEF_COL_W1 , "DefaultColumn1Width" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_FLAG ,       "Flags" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_LIST_STYLE , "ListStyle" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_VIEW_MODE ,  "ViewMode" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_ID_VIEW ,  "ViewID" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_MASK ,     "Contents" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_OPTIONS ,  "Options" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_RANK ,     "Age" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_TYPE ,     "Type" );
MMC_BASE_STRING ( XML_ATTR_WIN_PLACEMENT_FLAGS ,    "Flags" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_OPTIONS ,      "Options" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_MISC_OPTIONS , "MiscOptions" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_OCX_STRING ,   "OCX" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_URL_STRING ,   "URL" );
MMC_BASE_STRING ( XML_ATTR_SOURCE_INDEX,                 "SourceIndex");           // used to compress user state files
MMC_BASE_STRING ( XML_ATTR_NODETYPE_GUID,            "NodeTypeGUID");



/*-----------------------------------------------------------------------------------*\
|   Following strings used as enumerations
\*-----------------------------------------------------------------------------------*/


MMC_BASE_STRING ( XML_ENUM_FSTATE_SHOWSTATUSBAR,                "ShowStatusBar" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_HELPDOCINVALID,               "HelpDocInvalid" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_LOGICALREADONLY,              "LogicalReadOnly" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_PREVENTVIEWCUSTOMIZATION,     "PreventViewCustomization" );

MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_AUTHOR,                 "Author" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER,                   "User" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER_MDI,               "UserMDI" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER_SDI,               "UserSDI" );

MMC_BASE_STRING ( XML_ENUM_LV_STYLE_ICON,                       "Icon" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_SMALLICON,                  "SmallIcon" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_LIST,                       "List" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_REPORT,                     "Report" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_FILTERED,                   "Filtered");

MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_SCOPE,                     "Scope" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_RESULT,                    "Result" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_COMMANDLINE,               "CommandLine" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_TARGET,                    "Target" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_FAVORITE,                  "Favorite" ) ;

MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_RESTORED,               "Restored" ) ;
MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_MINIMIZED,              "Minimized" ) ;
MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_MAXIMIZED,              "Maximized" ) ;

MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_HIDE,                       "SW_HIDE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNORMAL,                 "SW_SHOWNORMAL" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMINIMIZED,              "SW_SHOWMINIMIZED" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMAXIMIZED,              "SW_SHOWMAXIMIZED" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNOACTIVATE,             "SW_SHOWNOACTIVATE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOW,                       "SW_SHOW" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_MINIMIZE,                   "SW_MINIMIZE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMINNOACTIVE,            "SW_SHOWMINNOACTIVE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNA,                     "SW_SHOWNA" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_RESTORE,                    "SW_RESTORE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWDEFAULT,                "SW_SHOWDEFAULT" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_FORCEMINIMIZE,              "SW_FORCEMINIMIZE" );

MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_SETMINPOSITION,            "WPF_SETMINPOSITION" );
MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_RESTORETOMAXIMIZED,        "WPF_RESTORETOMAXIMIZED" );
MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT,      "WPF_ASYNCWINDOWPLACEMENT" );

MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_LIST,                  "List" );
MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_HTML,                  "HTML" );
MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_OCX,                   "OCX" );

MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_LEFT,                "Left" );
MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_RIGHT,               "Right" );
MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_CENTER,              "Center" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as bitflags
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SINGLESEL,           "LVS_SINGLESEL" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SHOWSELALWAYS,       "LVS_SHOWSELALWAYS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SORTASCENDING,       "LVS_SORTASCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SORTDESCENDING,      "LVS_SORTDESCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SHAREIMAGELISTS,     "LVS_SHAREIMAGELISTS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOLABELWRAP,         "LVS_NOLABELWRAP" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_AUTOARRANGE,         "LVS_AUTOARRANGE" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_EDITLABELS,          "LVS_EDITLABELS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_OWNERDATA,           "LVS_OWNERDATA" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOSCROLL,            "LVS_NOSCROLL" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_ALIGNLEFT,           "LVS_ALIGNLEFT" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_OWNERDRAWFIXED,      "LVS_OWNERDRAWFIXED" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOCOLUMNHEADER,      "LVS_NOCOLUMNHEADER" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOSORTHEADER,        "LVS_NOSORTHEADER" );

MMC_BASE_STRING ( XML_BITFLAG_VIEW_SCOPE_PANE_VISIBLE,      "ScopePaneVisible" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STD_MENUS,            "NoStdMenus" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STD_BUTTONS,          "NoStdButtons" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_SNAPIN_MENUS,         "NoSnapinMenus" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_SNAPIN_BUTTONS,       "NoSnapinButtons" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_DISABLE_SCOPEPANE,       "DisableScopePane" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_DISABLE_STD_TOOLBARS,    "DisableStdToolbars" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_CUSTOM_TITLE,            "CustomTitle" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STATUS_BAR,           "NoStatusBar" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_CREATED_IN_USER_MODE,    "CreatedInUserMode" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_TASKPAD_TABS,         "NoTaskpadTabs" );

MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_VIEWMODE,        "Flag_ViewMode" );
MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_RVTYPE,          "Flag_ResultView" );
MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_TASKPADID,       "Flag_TaskPadID" );

MMC_BASE_STRING ( XML_BITFLAG_TASK_DISABLED,                "eFlag_Disabled" );

MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_HORIZONTAL,       "Horizontal" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_VERTICAL,         "Vertical" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_NO_RESULTS,       "NoResults" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_DESCRIPTIONS_AS_TEXT, "DescriptionsAsText" );

MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_OWNERDATALIST,   "ListView_OwnerDrawList" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_MULTISELECT,     "ListView_MultiSelect" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_FILTERED,        "ListView_Filtered" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_USEFONTLINKING,  "ListView_UseFontLinking" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_NO_SCOPE_ITEMS,  "ListView_NoScopeItems" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_LEXICAL_SORT,    "ListView_LexicalSort" );

MMC_BASE_STRING ( XML_BITFLAG_OCX_OPTIONS_CACHE_OCX,        "OCX_CacheControl" );

MMC_BASE_STRING ( XML_BITFLAG_MISC_OPTIONS_NOLISTVIEWS,     "Misc_NoListViews" );

MMC_BASE_STRING ( XML_BITFLAG_COL_SORT_DESCENDING,          "RSI_DESCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_COL_SORT_NOSORTICON,          "RSI_NOSORTICON" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as fixed attribute values ( such as enumerations)
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_VAL_FAVORITE_GROUP ,  "Group" );
MMC_BASE_STRING ( XML_VAL_FAVORITE_SINGLE , "Single" );
MMC_BASE_STRING ( XML_VAL_BOOL_TRUE ,       "true" );
MMC_BASE_STRING ( XML_VAL_BOOL_FALSE,       "false" );

/*-----------------------------------------------------------------------------------*\
|   END - XML
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( CHARSET_RAW_UNICODE ,        "ISO-10646-UCS-2" );
MMC_BASE_STRING ( CHARSET_COMPRESSED_UNICODE , "UTF-8" );

#define MMC_PROTOCOL_SCHEMA_NAME "--mmc"
#define MMC_PAGEBREAK_RELATIVE_URL "pagebreak."

MMC_BASE_STRING_EX ( PAGEBREAK_URL, _T(MMC_PROTOCOL_SCHEMA_NAME) _T(":") _T(MMC_PAGEBREAK_RELATIVE_URL) );

// define macros to declare a wide literal (need two levels - won't work with defines else)
#define __W(x)      L ## x
#define _W(x)      __W(x)

#endif // STRINGS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\stgio.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1998.
 *
 *  File:      stgio.inl
 *
 *  Contents:  Inlines file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STGIO_INL
#define STGIO_INL
#pragma once

#include <functional>   
#include <algorithm>


/*+-------------------------------------------------------------------------*
 * stream_insert
 *
 * Functor to insert an object in an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
struct stream_insert : 
    public std::binary_function<IStream*, T, IStream&>
{
    IStream& operator() (IStream* pstm, const T& t) const
        { return (*pstm << t); }
};


/*+-------------------------------------------------------------------------*
 * stream_extract
 *
 * Functor to extract an object from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
struct stream_extract :
    public std::binary_function<IStream*, T, IStream&>
{
    IStream& operator() (IStream* pstm, T& t) const
        { return (*pstm >> t); }
};


/*+-------------------------------------------------------------------------*
 * insert_each
 *
 * Inserts each item in a collection in an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void insert_each (IStream* pstm, const Collection& c)
{
    std::for_each (c.begin(), c.end(), 
                   std::bind1st (stream_insert<Collection::value_type>(), pstm));
}


/*+-------------------------------------------------------------------------*
 * insert_collection
 *
 * Inserts an entire collection into an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void insert_collection (IStream* pstm, const Collection& c)
{
    /*
     * write the size
     */
    *pstm << (DWORD) c.size();

    /*
     * write the elements
     */
    insert_each (pstm, c);
}


/*+-------------------------------------------------------------------------*
 * extract_collection
 *
 * Extracts an entire collection (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void extract_collection (IStream* pstm, Collection& c)
{
    /*
     * clear out the current container
     */
    c.clear();
    ASSERT (c.empty());

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        Collection::value_type t;
        *pstm >> t;

        /*
         * put it in the container
         */
        c.push_back (t);
    }
}


/*+-------------------------------------------------------------------------*
 * extract_vector 
 *
 * Extracts an entire vector (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
void extract_vector (IStream* pstm, std::vector<T>& v)
{
    /*
     * clear out the current container
     */
    v.clear();

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * pre-allocate the appropriate number of items (specialization for vector)
     */
    v.reserve (cItems);
    ASSERT (v.empty());
    ASSERT (v.capacity() >= cItems);

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        T t;
        *pstm >> t;

        /*
         * put it in the container
         */
        v.push_back (t);
    }
}

// specialized scalar vector prototypes (stgio.cpp)
#define DeclareScalarVectorStreamFunctions(scalar_type)                        \
    void extract_vector    (IStream* pstm,       std::vector<scalar_type>& v); \
    void insert_collection (IStream* pstm, const std::vector<scalar_type>& v);
                                                    
DeclareScalarVectorStreamFunctions (bool);
DeclareScalarVectorStreamFunctions (         char);
DeclareScalarVectorStreamFunctions (unsigned char);
DeclareScalarVectorStreamFunctions (         short);
DeclareScalarVectorStreamFunctions (unsigned short);
DeclareScalarVectorStreamFunctions (         int);
DeclareScalarVectorStreamFunctions (unsigned int);
DeclareScalarVectorStreamFunctions (         long);
DeclareScalarVectorStreamFunctions (unsigned long);
DeclareScalarVectorStreamFunctions (         __int64);
DeclareScalarVectorStreamFunctions (unsigned __int64);
DeclareScalarVectorStreamFunctions (float);
DeclareScalarVectorStreamFunctions (double);
DeclareScalarVectorStreamFunctions (long double);


/*+-------------------------------------------------------------------------*
 * extract_set_or_map
 *
 * Extracts an entire set or map (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void extract_set_or_map (IStream* pstm, Collection& c)
{
    /*
     * clear out the current container
     */
    c.clear();
    ASSERT (c.empty());

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        Collection::value_type t;
        *pstm >> t;

        /*
         * put it in the container
         */
        c.insert (t);
    }
}



/*+-------------------------------------------------------------------------*
 * operator<<, operator>>
 *
 * Stream insertion and extraction operators for various types
 *--------------------------------------------------------------------------*/

// std::pair<>
template<class T1, class T2> 
IStream& operator>> (IStream& stm, std::pair<T1, T2>& p)
{
    return (stm >> p.first >> p.second);
}

template<class T1, class T2> 
IStream& operator<< (IStream& stm, const std::pair<T1, T2>& p)
{
    return (stm << p.first << p.second);
}


// std::list<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::list<T, Al>& l)
{
    extract_collection (&stm, l);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::list<T, Al>& l)
{
    insert_collection (&stm, l);
    return (stm);
}


// std::deque<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::deque<T, Al>& l)
{
    extract_collection (&stm, l);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::deque<T, Al>& l)
{
    insert_collection (&stm, l);
    return (stm);
}


// std::vector<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::vector<T, Al>& v)
{
    extract_vector (&stm, v);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::vector<T, Al>& v)
{
    insert_collection (&stm, v);
    return (stm);
}


// std::set<>
template<class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::set<T, Pr, Al>& s)
{
    extract_set_or_map (&stm, s);
    return (stm);
}

template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::set<T, Pr, Al>& s)
{
    insert_collection (&stm, s);
    return (stm);
}


// std::multiset<>
template<class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::multiset<T, Pr, Al>& s)
{
    extract_set_or_map (&stm, s);
    return (stm);
}

template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multiset<T, Pr, Al>& s)
{
    insert_collection (&stm, s);
    return (stm);
}


// std::map<>
template<class K, class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::map<K, T, Pr, Al>& m)
{
    extract_set_or_map (&stm, m);
    return (stm);
}

template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::map<K, T, Pr, Al>& m)
{
    insert_collection (&stm, m);
    return (stm);
}


// std::multimap<>
template<class K, class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::multimap<K, T, Pr, Al>& m)
{
    extract_set_or_map (&stm, m);
    return (stm);
}

template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<K, T, Pr, Al>& m)
{
    insert_collection (&stm, m);
    return (stm);
}


#endif /* STGIO_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\tiedobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tiedobj.h
//
//  History:    08/28/1999 VivekJ Created
//--------------------------------------------------------------------------

#ifndef TIEDOBJ_H
#define TIEDOBJ_H
#pragma once

#include "conuistr.h" // for MMC_E_OBJECT_IS_GONE

/************************************************************************
 * This file provides base and template class support to encapsulate the
 * relationship between an object and a COM tearoff object that holds a pointer
 * to that object.
 *    The object is referred to as the Tied object, since the COM object is
 * "tied" to it, and cannot do anything useful apart from it.
 *    The COM object disables itself when the tied object is deleted. This
 * allows for automatic detection of dead states. An object can also "orphan"
 * all COM objects tied to it by calling the UnadviseAll method.
 *
 * An example of a tied object relationship is that of CAMCDoc and CMMCDocument.
 * CMMCDocument is derived from CTiedComObject<CAMCDoc>, and CAMCDoc derives
 * from CTiedObject. CAMCDoc thus keeps a list of all COM object that are tied
 * to it, and notifies them when it is destroyed. Similarly, the COM objects notify
 * the tied object when they are destroyed, so that they are removed from the list.
 *
 * NOTE: the tied object does NOT addref the COM objects, it just keeps a list of them.
 * If it was to addref them, there would be all sorts of circular lifetime problems.
 * By ensuring that the tied object and the COM objects notify each other of their
 * own destruction, lifetime management is correctly handled.
 *
 * Use CTiedComObjectCreator::ScCreateAndConnect to create an instance of the 
 * COM object and tie it to the tied object.
 *
 ************************************************************************/

class CTiedObject;
class CTiedComObjectRoot;


/*+-------------------------------------------------------------------------*
 * class CTiedComObjectRoot
 * 
 *
 * PURPOSE: Base class for CTiedComObject
 *
 *+-------------------------------------------------------------------------*/
class CTiedComObjectRoot
{
public:
    virtual void Unadvise()  = 0; // so that the tied object can inform that it is being deleted.
};


/*+-------------------------------------------------------------------------*
 * class CTiedObject
 * 
 *
 * PURPOSE: The base class that any object which has COM objects tied to 
 *          it should derive from. Provides methods to add a new COM object
 *          to its list of tied objects, to remove a COM object from its
 *          list, and to 
 *
 *+-------------------------------------------------------------------------*/
class CTiedObject
{
    typedef CTiedComObjectRoot * PTIEDCOMOBJECTROOT;
    typedef std::list<PTIEDCOMOBJECTROOT> CTiedComObjects;

    CTiedComObjects m_TiedComObjects;

public:
    SC      ScAddToList(CTiedComObjectRoot *p);
    void    RemoveFromList(CTiedComObjectRoot *p);

    virtual ~CTiedObject();

protected:
    void    UnadviseAll();
};

/*+-------------------------------------------------------------------------*
 *
 * CTiedObject::ScAddToList
 *
 * PURPOSE: Adds the COM object to the list of objects. Usually called soon
 *          after constructing the COM object.
 *
 * PARAMETERS: 
 *    CTiedComObjectRoot * p :
 *
 * RETURNS: 
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline
SC  CTiedObject::ScAddToList(CTiedComObjectRoot *p)
{
    DECLARE_SC (sc, _T("CTiedObject::ScAddToList"));

    if(!p)
        return (sc = E_INVALIDARG);

    m_TiedComObjects.push_back(p);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTiedObject::RemoveFromList
 *
 * PURPOSE: Removes the specfied COM object from the list of COM objects.
 *          Usually called from the destructor of the COM object.
 *
 * PARAMETERS: 
 *    CTiedComObjectRoot * p : The COM object.
 *
 * RETURNS: 
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline
void CTiedObject::RemoveFromList(CTiedComObjectRoot *p)
{
    CTiedComObjects::iterator iter;
    
    iter = std::find (m_TiedComObjects.begin(), m_TiedComObjects.end(), p);
    ASSERT(iter != m_TiedComObjects.end());

    if(iter != m_TiedComObjects.end())
        m_TiedComObjects.erase(iter);

}

inline
void CTiedObject::UnadviseAll()
{
    CTiedComObjects::iterator iter;
    for(iter = m_TiedComObjects.begin(); iter != m_TiedComObjects.end(); iter++)
    {
        (*iter)->Unadvise();
    }
}

inline
CTiedObject::~CTiedObject()
{
    UnadviseAll();
}

/*+-------------------------------------------------------------------------*
 * template class CTiedComObject
 * 
 *
 * PURPOSE:  The base class for COM objects that are tied to non-COM objects
 *           for instance, CMMCDocument is tied to CAMCDoc - it delegates
 *           all its methods to the tied object.
 *
 *+-------------------------------------------------------------------------*/
template <class TiedObjectClass>
class CTiedComObject : public CTiedComObjectRoot
{
    friend class TiedObjectClass;

public:
            CTiedComObject() : m_pT(NULL) {}
    virtual ~CTiedComObject();
    void    SetTiedObject(TiedObjectClass *pT);

protected:
    // called by the COM methods to make sure that the tied object exists.
    SC      ScGetTiedObject(TiedObjectClass*&pT);
    bool    IsTied()     { return m_pT != NULL; }
    void    Unadvise();

private:
    TiedObjectClass *m_pT;
};


/*+-------------------------------------------------------------------------*
 *
 * ~CTiedComObject
 *
 * PURPOSE:  Destructor. Tells the tied object to remove this one from
 *           its list of tied COM objects.
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObjectClass>
CTiedComObject<TiedObjectClass>::~CTiedComObject()
{
    if(m_pT != NULL)
    {
        m_pT->RemoveFromList(this);
    }
}

template<class TiedObjectClass>
void
CTiedComObject<TiedObjectClass>::SetTiedObject(TiedObjectClass *pT)
{
    ASSERT(pT != NULL);
    m_pT = pT;
}

template<class TiedObjectClass>
inline void
CTiedComObject<TiedObjectClass>::Unadvise()
{
    m_pT = NULL;
}


/*+-------------------------------------------------------------------------*
 *
 * CTiedComObject::ScGetTiedObject
 *
 * PURPOSE: Checks that a valid tied object pointer exists, and returns it.
 *
 * PARAMETERS: 
 *    TiedObjectClass** ppT : [OUT]: The object pointer
 *
 * RETURNS: 
 *      SC:     MMC_E_OBJECT_IS_GONE if no valid pointer exists.
 *+-------------------------------------------------------------------------*/
template<class TiedObjectClass>
inline SC 
CTiedComObject<TiedObjectClass>::ScGetTiedObject(TiedObjectClass*&pT)
{
    DECLARE_SC (sc, _T("CTiedComObject::ScGetTiedObject"));

    pT =  m_pT;
    if(NULL == m_pT)
        return (sc = ScFromMMC(MMC_E_OBJECT_IS_GONE));

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * ScCreateConnection
 *
 * PURPOSE: Creates a two-way connection between a COM object and its tied
 *          object.
 *
 * PARAMETERS: 
 *    TiedComObjClass  comObj :
 *    TiedObjClass     obj :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
template<class TiedComObjClass, class TiedObjClass>
SC ScCreateConnection(TiedComObjClass &comObj, TiedObjClass &obj)
{
    DECLARE_SC (sc, _T("ScCreateConnection"));
    
    sc = obj.ScAddToList(&comObj);
    if(sc)
        return (sc);
    
    comObj.SetTiedObject(&obj);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CTiedComObjectCreator
 * 
 *
 * PURPOSE: has a single static function, ScCreateAndConnect, which creates
 *          an instance of the COM object (if the smart pointer supplied is
 *          NULL) and connects it to the Tied object supplied.
 *
 *+-------------------------------------------------------------------------*/
template <class TiedComObjectClass>
class CTiedComObjectCreator
{
public:
    template<class TiedObjClass, class SmartPointerClass>
    static SC ScCreateAndConnect(TiedObjClass &obj, SmartPointerClass &smartPointer)
    {
        DECLARE_SC(sc, TEXT("CTiedComObjectCreator::ScCreateAndConnect") );

        // if the object has not yet been created, create it.
        if(smartPointer == NULL)
        {
            CComObject<TiedComObjectClass> *pTiedComObject = NULL;
            
            sc = CComObject<TiedComObjectClass>::CreateInstance(&pTiedComObject);
            if (sc)
                return (sc);

            if(!pTiedComObject)
                return (sc = E_UNEXPECTED);

            sc = ScCreateConnection(*pTiedComObject, obj); // create a link between the tied obj and tied com obj.
            if(sc)
                return sc;

            smartPointer = pTiedComObject; // This AddRef's it once. need to addref it for the client as well.
        }

        return sc;
    }

};

#endif  // TIEDOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\stlstuff.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stlstuff.h
 *
 *  Contents:  Interface file for STL helpers
 *
 *  History:   26-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STLSTUFF_H
#define STLSTUFF_H
#pragma once



/*+-------------------------------------------------------------------------*
 * const member function adapters
 *
 * These member function adapters are used to adapt const member functions
 * in the same way that 
 * 
 *      std::mem_fun
 *      std::mem_fun1
 *      std::mem_fun_ref
 *      std::mem_fun_ref1
 * 
 * adapt non-const member functions.
 *--------------------------------------------------------------------------*/

        // TEMPLATE CLASS const_mem_fun_t
template<class _R, class _Ty>
    class const_mem_fun_t : public std::unary_function<_Ty *, _R> {
public:
    explicit const_mem_fun_t(_R (_Ty::*_Pm)() const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty *_P)
        {return ((_P->*_Ptr)()); }
private:
    _R (_Ty::*_Ptr)() const;
    };
        // TEMPLATE FUNCTION const_mem_fun
template<class _R, class _Ty> inline
    const_mem_fun_t<_R, _Ty> const_mem_fun(_R (_Ty::*_Pm)() const)
    {return (const_mem_fun_t<_R, _Ty>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun1_t
template<class _R, class _Ty, class _A>
    class const_mem_fun1_t : public std::binary_function<_Ty *, _A, _R> {
public:
    explicit const_mem_fun1_t(_R (_Ty::*_Pm)(_A) const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty *_P, _A _Arg)
        {return ((_P->*_Ptr)(_Arg)); }
private:
    _R (_Ty::*_Ptr)(_A) const;
    };
        // TEMPLATE FUNCTION const_mem_fun1
template<class _R, class _Ty, class _A> inline
    const_mem_fun1_t<_R, _Ty, _A> const_mem_fun1(_R (_Ty::*_Pm)(_A) const)
    {return (const_mem_fun1_t<_R, _Ty, _A>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun_ref_t
template<class _R, class _Ty>
    class const_mem_fun_ref_t : public std::unary_function<_Ty *, _R> {
public:
    explicit const_mem_fun_ref_t(_R (_Ty::*_Pm)() const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty& _X)
        {return ((_X.*_Ptr)()); }
private:
    _R (_Ty::*_Ptr)() const;
    };
        // TEMPLATE FUNCTION const_mem_fun_ref
template<class _R, class _Ty> inline
    const_mem_fun_ref_t<_R, _Ty> const_mem_fun_ref(_R (_Ty::*_Pm)() const)
    {return (const_mem_fun_ref_t<_R, _Ty>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun1_ref_t
template<class _R, class _Ty, class _A>
    class const_mem_fun1_ref_t : public std::binary_function<_Ty *, _A, _R> {
public:
    explicit const_mem_fun1_ref_t(_R (_Ty::*_Pm)(_A) const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty& _X, _A _Arg)
        {return ((_X.*_Ptr)(_Arg)); }
private:
    _R (_Ty::*_Ptr)(_A) const;
    };
        // TEMPLATE FUNCTION const_mem_fun1_ref
template<class _R, class _Ty, class _A> inline
    const_mem_fun1_ref_t<_R, _Ty, _A> const_mem_fun1_ref(_R (_Ty::*_Pm)(_A) const)
    {return (const_mem_fun1_ref_t<_R, _Ty, _A>(_Pm)); }



#endif /* STLSTUFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\treeobsv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       treeobsv.h
//
//--------------------------------------------------------------------------

#ifndef _TREEOBSV_H_
#define _TREEOBSV_H_

#include "observer.h"

typedef LONG_PTR TREEITEMID;

// Tree item attributes
const DWORD TIA_NAME   = 0x00000001;
const DWORD TIA_IMAGE  = 0x00000002;

// observer styles
const DWORD TOBSRV_HIDEROOT     = 0x00000001;    // Don't display root item
const DWORD TOBSRV_FOLDERSONLY  = 0x00000002;    // Show only folder items

const TREEITEMID TREEID_ROOT = static_cast<TREEITEMID>(-1);
const TREEITEMID TREEID_LAST = static_cast<TREEITEMID>(-2);

class CTreeObserver
{
public:
    STDMETHOD (SetStyle) (DWORD dwStyle) = 0;
    STDMETHOD_(void, ItemAdded)   (TREEITEMID tid) = 0;
    STDMETHOD_(void, ItemRemoved) (TREEITEMID tidParent, TREEITEMID tidRemoved) = 0;
    STDMETHOD_(void, ItemChanged) (TREEITEMID tid, DWORD dwAttrib) = 0;
};


class CTreeSource 
{
public:
    STDMETHOD_(TREEITEMID, GetRootItem)        () = 0;
    STDMETHOD_(TREEITEMID, GetParentItem)      (TREEITEMID tid) = 0;
    STDMETHOD_(TREEITEMID, GetChildItem)       (TREEITEMID tid) = 0;
    STDMETHOD_(TREEITEMID, GetNextSiblingItem) (TREEITEMID tid) = 0;

    STDMETHOD_(LPARAM,     GetItemParam)    (TREEITEMID tid) = 0;
    STDMETHOD_(void,       GetItemName)     (TREEITEMID tid, LPTSTR pszName, int cchMaxName) = 0;
    STDMETHOD_(int,        GetItemImage)    (TREEITEMID tid) = 0;
    STDMETHOD_(int,        GetItemOpenImage)(TREEITEMID tid) = 0;
    STDMETHOD_(BOOL,       IsFolderItem)    (TREEITEMID tid) = 0;
};


#endif // _TREEOBSV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\treesink.h ===
/*+-------------------------------------------------------------------------*
 * class CTreeCtrlEventSink
 * 
 *
 * PURPOSE: The notification handler class for tree notifications.
 *
 *+-------------------------------------------------------------------------*/
class CTreeCtrlEventSink : public CEventSinkBase
{
    virtual SC  ScOnSelectNode()    {return S_OK;}
    virtual SC  ScOnDeleteNode()    {return S_OK;}
    virtual SC  ScOnInsertNode()    {return S_OK;}
    virtual SC  ScOnModifyNode()    {return S_OK;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------
#pragma once

class tstring;

class CStr;

ULONG   _ttoul(LPTSTR psz);
WORD    I_SplitModuleAndResourceID(LPCTSTR szBuf);
BOOL    I_GetStrFromModule(LPCTSTR pszModule, ULONG ulMsgNo, CStr &strBuf);
HICON   I_GetHicon(LPCTSTR pszModule, ULONG ulId);
LPSTR   CoTaskDupString(LPCSTR lpszIn);
LPWSTR  CoTaskDupString(LPCWSTR lpszIn);
LPTSTR  NewDupString(LPCTSTR lpszIn);
LPTSTR  StripTrailingWhitespace (LPTSTR pszStart);
HRESULT GUIDToCStr(CStr& str, const GUID& guid);
HRESULT GUIDFromCStr(const CStr& str, GUID* pguid);
bool    IsWhistler ();
HRESULT WriteCompatibleImageList (HIMAGELIST himl, IStream* pstm);
HRESULT ReadCompatibleImageList (IStream* pstm, HIMAGELIST& himl);

bool InflateFont (LOGFONT* plf, int nPointsToGrowBy);

inline bool DeflateFont (LOGFONT* plf, int nPointsToShrinkBy)
    { return (InflateFont (plf, -nPointsToShrinkBy)); }

bool GetTBBtnTextAndStatus(HINSTANCE hInst, int nID, std::wstring& szButton, std::wstring& szToolTip);

#ifdef DBG
void DrawOnDesktop (HBITMAP hbm, int x, int y);
void DrawOnDesktop (HICON hIcon, int x, int y);
void DrawOnDesktop (HIMAGELIST himl, int x, int y, int iImage = -1);
#endif

/*---------------------------------------------------------*\
| copied from winuser.h since we currently compile
| with _WIN32_WINNT == 0x0400
\*---------------------------------------------------------*/
#if (_WIN32_WINNT < 0x0500)

#if !defined(WS_EX_LAYOUTRTL)
	#define WS_EX_LAYOUTRTL                    0x00400000L
#endif

#if !defined(LAYOUT_BITMAPORIENTATIONPRESERVED)
	#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008
#endif

#if !defined(LAYOUT_RTL)
	#define LAYOUT_RTL                         0x00000001 // Right to left
#endif

// implement locally Gdi32 functions for layout
DWORD PrivateSetLayout( HDC hdc, DWORD dwLayout );

inline DWORD SetLayout( HDC hdc, DWORD dwLayout )
{
	return PrivateSetLayout( hdc, dwLayout );
}

// implement locally Gdi32 functions for layout
DWORD PrivateGetLayout( HDC hdc );

inline DWORD GetLayout( HDC hdc )
{
	return PrivateGetLayout( hdc );
}

// To deactivate UI theming before calling snapins & restore original context
// use below apis. (See util.cpp for more details).
BOOL WINAPI MmcDownlevelActivateActCtx(HANDLE hActCtx, ULONG_PTR* pulCookie); 
VOID WINAPI MmcDownlevelDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\variant.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      variant.h
 *
 *  Contents:  Interface file for various VARIANT helper functions
 *
 *  History:   19-Nov-1999 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef VARIANT_H_INCLUDED
#define VARIANT_H_INCLUDED


/*+-------------------------------------------------------------------------*
 * ConvertByRefVariantToByValue 
 *
 * VBScript will has two syntaxes for calling dispinterfaces:
 * 
 * 1.   obj.Method (arg)
 * 2.   obj.Method arg
 * 
 * The first syntax will pass arg by value, which out dispinterfaces will
 * be able to handle.  If Method takes a BSTR argument, the VARIANT that
 * arrives at Method will be of type VT_BSTR.
 * 
 * The second syntax will pass arg by reference.  In this case Method will
 * receive a VARIANT of type (VT_VARIANT | VT_BYREF).  The VARIANT that is
 * referenced will be of type VT_BSTR.
 * 
 * This function will dereference the VARIANT and return the direct pointer 
 * in pVar.  Calling this function on a VARIANT that is not VT_BYREF is
 * harmless.
 *--------------------------------------------------------------------------*/

inline VARIANT* ConvertByRefVariantToByValue (VARIANT* pVar)
{
    while ((pVar != NULL) && (V_VT(pVar) == (VT_VARIANT | VT_BYREF)))
    {
        pVar = V_VARIANTREF(pVar);
    }

    return (pVar);
}


/*+-------------------------------------------------------------------------*
 * IsOptionalParamMissing 
 *
 * Returns true if an optional argument to an Automation method is left
 * blank.  This is indicated by a type of VT_ERROR with a value of
 * DISP_E_PARAMNOTFOUND.
 * 
 * This should be moved to a header.
 *--------------------------------------------------------------------------*/

inline bool IsOptionalParamMissing (const VARIANT& var)
{
    return ((V_VT(&var) == VT_ERROR) && (V_ERROR(&var) == DISP_E_PARAMNOTFOUND));
}


#endif /* VARIANT_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\tstring.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.inl
 *
 *  Contents:  Inline implementation file for tstring
 *
 *  History:   04-Oct-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TSTRING_INL
#define TSTRING_INL
#pragma once


/*+-------------------------------------------------------------------------*
 * tstring::tstring
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring::tstring (const allocator_type& al) :
    BaseClass (al)
{}

inline tstring::tstring (const tstring& other) :
    BaseClass (other)
{}

inline tstring::tstring (const BaseClass& other) :
    BaseClass (other)
{}

inline tstring::tstring (const tstring& other, size_type pos, size_type n) :
    BaseClass (other, pos, n)
{}

inline tstring::tstring (const BaseClass& other, size_type pos, size_type n) :
    BaseClass (other, pos, n)
{}

inline tstring::tstring (const TCHAR* psz) :
    BaseClass (psz)
{}

inline tstring::tstring (const TCHAR* psz, size_type n) :
    BaseClass (psz, n)
{}

inline tstring::tstring (size_type n, TCHAR ch) :
    BaseClass (n, ch)
{}

inline tstring::tstring (const_iterator first, const_iterator last) :
    BaseClass (first, last)
{}


/*+-------------------------------------------------------------------------*
 * tstring::operator= 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::operator= (const tstring& other)
{
    if (this != &other)
        erase();    // see KB Q172398

    BaseClass::operator= (other);
    return (*this);
}

inline tstring& tstring::operator= (const BaseClass& other)
{
    if (data() != other.data())
        erase();    // see KB Q172398

    BaseClass::operator= (other);
    return (*this);
}

inline tstring& tstring::operator= (TCHAR ch)
{
    erase();    // see KB Q172398
    BaseClass::operator= (ch);
    return (*this);
}

inline tstring& tstring::operator= (const TCHAR* psz)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::operator= (psz);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::operator+= 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::operator+= (const tstring& strToAppend)
{
    BaseClass::operator+= (strToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (const BaseClass& strToAppend)
{
    BaseClass::operator+= (strToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (TCHAR chToAppend)
{
    BaseClass::operator+= (chToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (const TCHAR* pszToAppend)
{
    BaseClass::operator+= (pszToAppend);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::append 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::append (const tstring& str)
{
    BaseClass::append (str);
    return (*this);
}

inline tstring& tstring::append (const BaseClass& str)
{
    BaseClass::append (str);
    return (*this);
}

inline tstring& tstring::append (const tstring& str, size_type pos, size_type n)
{
    BaseClass::append (str, pos, n);
    return (*this);
}

inline tstring& tstring::append (const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::append (str, pos, n);
    return (*this);
}

inline tstring& tstring::append (const TCHAR* psz)
{
    BaseClass::append (psz);
    return (*this);
}

inline tstring& tstring::append (const TCHAR* psz, size_type n)
{
    BaseClass::append (psz, n);
    return (*this);
}

inline tstring& tstring::append (size_type n, TCHAR ch)
{
    BaseClass::append (n, ch);
    return (*this);
}

inline tstring& tstring::append (const_iterator first, const_iterator last)
{
    BaseClass::append (first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::assign 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::assign (const tstring& str)
{
    if (this != &str)
        erase();    // see KB Q172398

    BaseClass::assign (str);
    return (*this);
}

inline tstring& tstring::assign (const BaseClass& str)
{
    if (data() != str.data())
        erase();    // see KB Q172398

    BaseClass::assign (str);
    return (*this);
}

inline tstring& tstring::assign (const tstring& str, size_type pos, size_type n)
{
    if (this != &str)
        erase();    // see KB Q172398

    BaseClass::assign (str, pos, n);
    return (*this);
}

inline tstring& tstring::assign (const BaseClass& str, size_type pos, size_type n)
{
    if (data() != str.data())
        erase();    // see KB Q172398

    BaseClass::assign (str, pos, n);
    return (*this);
}

inline tstring& tstring::assign (const TCHAR* psz)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::assign (psz);
    return (*this);
}

inline tstring& tstring::assign (const TCHAR* psz, size_type n)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::assign (psz, n);
    return (*this);
}

inline tstring& tstring::assign (size_type n, TCHAR ch)
{
    erase();    // see KB Q172398
    BaseClass::assign (n, ch);
    return (*this);
}

inline tstring& tstring::assign (const_iterator first, const_iterator last)
{
    if (!IsPartOfString (*this, first))
        erase();    // see KB Q172398

    BaseClass::assign (first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::insert 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::insert (size_type p0, const tstring& str)
{
    BaseClass::insert (p0, str);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const BaseClass& str)
{
    BaseClass::insert (p0, str);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const tstring& str, size_type pos, size_type n)
{
    BaseClass::insert (p0, str, pos, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::insert (p0, str, pos, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const TCHAR* psz, size_type n)
{
    BaseClass::insert (p0, psz, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const TCHAR* psz)
{
    BaseClass::insert (p0, psz);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, size_type n, TCHAR ch)
{
    BaseClass::insert (p0, n, ch);
    return (*this);
}

inline void tstring::insert (iterator it, size_type n, TCHAR ch)
{
    BaseClass::insert (it, n, ch);
}

inline void tstring::insert (iterator it, const_iterator first, const_iterator last)
{
    BaseClass::insert (it, first, last);
}


/*+-------------------------------------------------------------------------*
 * tstring::erase 
 *
 * Simple wrapper that forwards the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::erase (size_type p0, size_type n)
{
    BaseClass::erase (p0, n);
    return (*this);
}

inline tstring::iterator tstring::erase (iterator it)
{
    return (BaseClass::erase (it));
}

inline tstring::iterator tstring::erase (iterator first, iterator last)
{
    return (BaseClass::erase (first, last));
}


/*+-------------------------------------------------------------------------*
 * tstring::replace 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::replace (size_type p0, size_type n0, const tstring& str)
{
    BaseClass::replace (p0, n0, str);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const BaseClass& str)
{
    BaseClass::replace (p0, n0, str);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const tstring& str, size_type pos, size_type n)
{
    BaseClass::replace (p0, n0, str, pos, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::replace (p0, n0, str, pos, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const TCHAR* psz, size_type n)
{
    BaseClass::replace (p0, n0, psz, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const TCHAR* psz)
{
    BaseClass::replace (p0, n0, psz);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, size_type n, TCHAR ch)
{
    BaseClass::replace (p0, n0, n, ch);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const tstring& str)
{
    BaseClass::replace (first0, last0, str);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const BaseClass& str)
{
    BaseClass::replace (first0, last0, str);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const TCHAR* psz, size_type n)
{
    BaseClass::replace (first0, last0, psz, n);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const TCHAR* psz)
{
    BaseClass::replace (first0, last0, psz);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, size_type n, TCHAR ch)
{
    BaseClass::replace (first0, last0, n, ch);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const_iterator first, const_iterator last)
{
    BaseClass::replace (first0, last0, first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::substr 
 *
 * Simple wrapper that forwards the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring tstring::substr (size_type pos, size_type n) const
{
    return (tstring (BaseClass::substr (pos, n)));
}


#endif /* TSTRING_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\viewset.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      viewset.h
 *
 *  Contents:  Declares a class that holds the settings needed to re-create a view.
 *
 *  History:   21-April-99 vivekj     Created
 *             03-Feb-2000 AnandhaG   Added CResultViewType member
 *
 *--------------------------------------------------------------------------*/
#ifndef _VIEWSET_H_
#define _VIEWSET_H_

//+-------------------------------------------------------------------
//
//  Class:      CViewSettings
//
//  Purpose:    The view information for a node (bookmark).
//              Stores result-view-type, taskpad-id and view mode.
//
//  History:    01-27-1999   AnandhaG   Created
//              02-08-2000   AnandhaG   Modified to include new result-view-type
//
//--------------------------------------------------------------------
class CViewSettings : public CSerialObject, public CXMLObject
{
private:
    typedef std::wstring wstring;

///////////////////////////////////////////////////////////////////////////////////////////
// View Types (These are meant for decoding MMC1.2 consoles, do not use them for MMC2.0. //
///////////////////////////////////////////////////////////////////////////////////////////
typedef enum  _VIEW_TYPE
{
    VIEW_TYPE_OCX        = MMCLV_VIEWSTYLE_ICON - 3,  // -3 custom ocx view
    VIEW_TYPE_WEB        = MMCLV_VIEWSTYLE_ICON - 2,  // -2 custom web view
    VIEW_TYPE_DEFAULT    = MMCLV_VIEWSTYLE_ICON - 1,  // -1

    VIEW_TYPE_LARGE_ICON = MMCLV_VIEWSTYLE_ICON,
    VIEW_TYPE_REPORT     = MMCLV_VIEWSTYLE_REPORT,
    VIEW_TYPE_SMALL_ICON = MMCLV_VIEWSTYLE_SMALLICON,
    VIEW_TYPE_LIST       = MMCLV_VIEWSTYLE_LIST,
    VIEW_TYPE_FILTERED   = MMCLV_VIEWSTYLE_FILTERED,

} VIEW_TYPE;

///////////////////////////////////////////////////////////////////////////////////////////
// CViewSetting Mask tells which members are valid.                                      //
///////////////////////////////////////////////////////////////////////////////////////////
static const DWORD VIEWSET_MASK_NONE        = 0x0000;
static const DWORD VIEWSET_MASK_VIEWMODE    = 0x0001;         // The ViewMode member is valid.
static const DWORD VIEWSET_MASK_RVTYPE      = 0x0002;         // The CResultViewType is valid.
static const DWORD VIEWSET_MASK_TASKPADID   = 0x0004;         // The taskpad id is valid.


protected:
    virtual UINT GetVersion() { return 4;}
    virtual HRESULT ReadSerialObject(IStream &stm, UINT nVersion);

public:
    virtual void Persist(CPersistor &persistor);

    DEFINE_XML_TYPE(XML_TAG_VIEW_SETTINGS);

public:
    CViewSettings();

    bool operator == (const CViewSettings& viewSettings);
    bool operator != (const CViewSettings& viewSettings)
    {
        return (!operator==(viewSettings));
    }

    SC              ScGetViewMode(ULONG& ulViewMode);
    SC              ScSetViewMode(const ULONG ulViewMode);

    SC              ScGetTaskpadID(GUID& guidTaskpad);
    SC              ScSetTaskpadID(const GUID& guidTaskpad);

    SC              ScGetResultViewType(CResultViewType& rvt);
    SC              ScSetResultViewType(const CResultViewType& rvt);

    bool            IsViewModeValid()    const;
    bool            IsTaskpadIDValid()   const  { return (m_dwMask & VIEWSET_MASK_TASKPADID);}
    bool            IsResultViewTypeValid()const  { return (m_dwMask & VIEWSET_MASK_RVTYPE);}

    void            SetResultViewTypeValid(bool bSet = true)  { SetMask(VIEWSET_MASK_RVTYPE, bSet);}
    void            SetTaskpadIDValid(bool bSet = true)  { SetMask(VIEWSET_MASK_TASKPADID, bSet);}
    void            SetViewModeValid(bool bSet = true)  { SetMask(VIEWSET_MASK_VIEWMODE, bSet);}

    bool            operator<(const CViewSettings& viewSettings){ return (m_dwRank < viewSettings.m_dwRank);}

    SC              ScInitialize(bool  bViewTypeValid,
								 const VIEW_TYPE& viewType,
                                 const long lViewOptions,
                                 const wstring& wstrViewName);

private:
    void            SetMask(DWORD dwMask, bool bSet = true)
                    {
                        if (bSet)
                            m_dwMask |= dwMask;
                        else
                            m_dwMask &=(~dwMask);
                    }

private:
    CResultViewType m_RVType;
    ULONG           m_ulViewMode;

    GUID            m_guidTaskpad;  // the guid of the taskpad, if any.

    DWORD           m_dwMask;       // VIEWSET_MASK

    // Book keeping members.
public:
    DWORD         GetUsageRank()     const  { return m_dwRank;}
    void          SetUsageRank(DWORD dw)    { m_dwRank = dw;}

    BOOL          IsObjInvalid()     const  { return m_bInvalid;}
    void          SetObjInvalid(BOOL b = TRUE) { m_bInvalid = b;}

private:
    // Needed for book keeping.
    DWORD           m_dwRank;       // Usage rank.
    BOOL            m_bInvalid;     // For garbage collection.
};

#endif _VIEWSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\tstring.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Interface file for tstring
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TSTRING_H
#define TSTRING_H
#pragma once

#include <string>       // for std::wstring, std::string
#include <objidl.h>     // for IStream
#include <commctrl.h>
#include "mmc.h"
#include "ndmgr.h"      // for MMC_STRING_ID
#include "ndmgrpriv.h"
#include "stddbg.h"     // for ASSERT
#include "mmcptrs.h"    // for IStringTablePrivatePtr


/*+-------------------------------------------------------------------------*
 * tstring
 *
 * A tstring is a native-format (ANSI/Unicode) Standard C++ string that:
 * 
 *      1. always persists itself in Unicode format, and
 *      2. supports LoadString, like MFC CStrings
 * 
 * For ANSI, we provide IStream insertion and extraction operators that 
 * will automatically convert to Unicode on stream insertion and from
 * Unicode on stream extraction.
 * 
 * All base class member functions that return a base class instance (and
 * overloads), like substr:
 * 
 *      std::string std::string::substr (size_type pos, size_type n) const;
 * 
 * must have forwarder functions here, so tstring supports such constructs
 * as:
 * 
 *      tstring strStuff;
 *      *pStream << strStuff.substr(4, 6);
 * 
 * If we didn't have forwarder functions in tstring, then an instance of 
 * the base class type would be inserted in the stream instead of a tstring.
 * For Unicode, that wouldn't be a problem; but for ANSI, we'd end up 
 * inserting a std::string into the stream in non-Unicode format.  That
 * would defeat the purpose of having this class.
 *--------------------------------------------------------------------------*/

#ifdef UNICODE
    typedef std::wstring    tstring_BaseClass;
#else
    typedef std::string     tstring_BaseClass;
#endif

class tstring : public tstring_BaseClass
{
    typedef tstring_BaseClass   BaseClass;
    
public:
    explicit tstring (const allocator_type& al = allocator_type());

    tstring (const tstring&   other);
    tstring (const BaseClass& other);
    tstring (const tstring&   other, size_type pos, size_type n);
    tstring (const BaseClass& other, size_type pos, size_type n);
    tstring (const TCHAR* psz);
    tstring (const TCHAR* psz, size_type n);
    tstring (size_type n, TCHAR ch);
    tstring (const_iterator first, const_iterator last);
    
    tstring& operator= (const tstring&   other);
    tstring& operator= (const BaseClass& other);
    tstring& operator= (TCHAR ch);
    tstring& operator= (const TCHAR* psz);

    tstring& operator+= (const tstring&   strToAppend);
    tstring& operator+= (const BaseClass& strToAppend);
    tstring& operator+= (TCHAR chToAppend);
    tstring& operator+= (const TCHAR* pszToAppend);

    tstring& append (const tstring&   str);
    tstring& append (const BaseClass& str);
    tstring& append (const tstring&   str, size_type pos, size_type n);
    tstring& append (const BaseClass& str, size_type pos, size_type n);
    tstring& append (const TCHAR* psz);
    tstring& append (const TCHAR* psz, size_type n);
    tstring& append (size_type n, TCHAR ch);
    tstring& append (const_iterator first, const_iterator last);
    
    tstring& assign (const tstring&   str);
    tstring& assign (const BaseClass& str);
    tstring& assign (const tstring&   str, size_type pos, size_type n);
    tstring& assign (const BaseClass& str, size_type pos, size_type n);
    tstring& assign (const TCHAR* psz);
    tstring& assign (const TCHAR* psz, size_type n);
    tstring& assign (size_type n, TCHAR ch);
    tstring& assign (const_iterator first, const_iterator last);

    tstring& insert (size_type p0, const tstring&   str);
    tstring& insert (size_type p0, const BaseClass& str);
    tstring& insert (size_type p0, const tstring&   str, size_type pos, size_type n);
    tstring& insert (size_type p0, const BaseClass& str, size_type pos, size_type n);
    tstring& insert (size_type p0, const TCHAR* psz, size_type n);
    tstring& insert (size_type p0, const TCHAR* psz);
    tstring& insert (size_type p0, size_type n, TCHAR ch);
    iterator insert (iterator it, TCHAR ch);
    void     insert (iterator it, size_type n, TCHAR ch);
    void     insert (iterator it, const_iterator first, const_iterator last);

    tstring& erase (size_type p0 = 0, size_type n = npos);
    iterator erase (iterator it);
    iterator erase (iterator first, iterator last);

    tstring& replace (size_type p0, size_type n0, const tstring&   str);
    tstring& replace (size_type p0, size_type n0, const BaseClass& str);
    tstring& replace (size_type p0, size_type n0, const tstring&   str, size_type pos, size_type n);
    tstring& replace (size_type p0, size_type n0, const BaseClass& str, size_type pos, size_type n);
    tstring& replace (size_type p0, size_type n0, const TCHAR* psz, size_type n);
    tstring& replace (size_type p0, size_type n0, const TCHAR* psz);
    tstring& replace (size_type p0, size_type n0, size_type n, TCHAR ch);
    tstring& replace (iterator first0, iterator last0, const tstring&   str);
    tstring& replace (iterator first0, iterator last0, const BaseClass& str);
    tstring& replace (iterator first0, iterator last0, const TCHAR* psz, size_type n);
    tstring& replace (iterator first0, iterator last0, const TCHAR* psz);
    tstring& replace (iterator first0, iterator last0, size_type n, TCHAR ch);
    tstring& replace (iterator first0, iterator last0, const_iterator first, const_iterator last);

    tstring substr (size_type pos = 0, size_type n = npos) const;
    
    bool LoadString (HINSTANCE hInst, UINT nID);
};

#ifndef UNICODE
IStream& operator>> (IStream& stm,       tstring& task);
IStream& operator<< (IStream& stm, const tstring& task);
#endif  // UNICODE



/*+-------------------------------------------------------------------------*
 * CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/
class CPersistor;

class CStringTableStringBase
{
public:
    enum
    {
        eNoValue = -1,
    };

    CStringTableStringBase (IStringTablePrivate* pstp);
    CStringTableStringBase (const CStringTableStringBase& other);
    CStringTableStringBase (IStringTablePrivate* pstp, const tstring& str);
    CStringTableStringBase& operator= (const CStringTableStringBase& other);
    CStringTableStringBase& operator= (const tstring& str);
    CStringTableStringBase& operator= (LPCTSTR psz);

    virtual ~CStringTableStringBase ();

    MMC_STRING_ID CommitToStringTable () const;
    void RemoveFromStringTable () const;

    /* Call Detach if your string is deleted before the string table is.
     * Failing to do so will *remove* your string from the string table.*/     
    void Detach()
    {
        m_id = eNoValue;
    }

    bool operator== (const CStringTableStringBase& other) const
    {
        ASSERT ((m_str == other.m_str) == (m_id == other.m_id));
        return (m_id == other.m_id);
    }

    bool operator!= (const CStringTableStringBase& other) const
    {
        return (!(*this == other));
    }

    bool operator== (const tstring& str) const
    {
        return (m_str == str);
    }

    bool operator!= (const tstring& str) const 
    {
        return (m_str != str);
    }

    bool operator== (LPCTSTR psz) const
    {
        return (m_str == psz);
    }

    bool operator!= (LPCTSTR psz) const 
    {
        return (m_str != psz);
    }

    LPCTSTR data() const
        { return (m_str.data()); }

    tstring str() const
        { return (m_str); }

    MMC_STRING_ID id() const
        { return (m_id); }

private:
    void Assign (const CStringTableStringBase& other);

    mutable IStringTablePrivatePtr  m_spStringTable;
    mutable MMC_STRING_ID           m_id;
    tstring                         m_str;

    friend IStream& operator>> (IStream& stm,       CStringTableStringBase& task);
    friend IStream& operator<< (IStream& stm, const CStringTableStringBase& task);
    friend class CPersistor;
};


template<class _E, class _Tr, class _Al>
bool IsPartOfString (const std::basic_string<_E, _Tr, _Al>& str, const _E* psz)
{
    return ((psz >= str.begin()) && (psz <= str.end()));
}


#include "tstring.inl"


#endif /* TSTRING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\xmlbase.h ===
#ifndef XMLBASE_H
#define XMLBASE_H
#pragma once

#include <atlbase.h>
#include <list>
#include <map>
#include "mmcerror.h"
#include "macros.h"
#include "tstring.h"
#include "strings.h"
#include "cstr.h"


/*+-------------------------------------------------------------------------*
    This file contains code required to persist data using XML format.
    The classes defined here fall into following categories:

    Main persistence process engine
        CPersistor
         | this class is the working horse for XML persistence
         | every class supporting persistence gets the reference to
         | CPersistor to it's Persist method, where it implements
         | persisting ot their own code. Class' own code is persisted
         | by calling Persist* methods on persistor and passing internal
         | variables to them. The tree of CPersist objects is created during
         | persist operation (load or save) and lives only during this operation.

    MSXML interface wrappers:
        CXMLElement             (wraps IXMLDOMNode interface)
        CXMLElementCollection   (wraps IXMLDOMNodeList interface)
        CXMLDocument            (wraps IXMLDOMDocument interface)
         | these wrappers add very little to the interfaces wrapped
         | - the throw SC type of exception instead of returning the error code
         | - maintain internal smart pointer to wrapped interfaces
         | - return error from methods if the interface has not be set

    base classes for classes supporting XML persistence
        CXMLObject              - generic persistence support
        XMLListCollectionBase   - persistence support for std::list
        XMLListCollectionImp    - persistence support for std::list
        XMLMapCollectionBase    - persistence support for std::map
        XMLMapCollection        - persistence support for std::map
        XMLMapCollectionImp     - persistence support for std::map
         | for object to support persistence it needs to derive from any of listed
         | classes (at least from CXMLObject). Other classes add some more functionality
         | to the derived class.

    Generic value persistece support
        CXMLValue   - support for set of generic types (like int, string, etc)
        CXMLBoolean - support for BOOL and bool types
         | CXMLValue mostly used by implicit cast of the object given to
         | CPersistor::PersistAttribute or CPersistor::PersistContents

    Wrappers, adding persistence to regular types
        XMLPoint                - persistence for POINT type
        XMLRect                 - persistence for RECT type
        XMLListCollectionWrap   - persistence for std::list type
        XMLMapCollectionWrap    - persistence for std::map type
        CXML_IStorage           - persistence thru IStorage
        CXML_IStream            - persistence thru IStream
        CXMLPersistableIcon     - persistence for console icon
        CXMLVariant             - persistence for CComVariant
        CXMLEnumeration         - persistence for enumerations by literals
        CXMLBitFlags            - persistence for bit-flags by literals
         | these classes usually take the reference to object they persist as
         | a parameter to the constructor and usually are constructed
         | on stack solely to persist the object and die afterwards

  SEE THE SAMPLE BELOW
  ----------------------------------------------------------------------------
  SAMPLE:
         say we have classes A, B what need to be persisted (access specifiers ommited)

            class A { int i; };
            class B { int j; A  a; };

         and we would want to persist them in format (assume A::i = 1, B::j = 2) :
            <BT INDEX = "2"><AT>1</AT></BT>

         we need to change the classes to support persistence:

            class A : public CXMLObject      // to inherit persistence capability
            { int i;

              DEFINE_XML_TYPE("AT")          // to define the tag name

              virtual void
              Persist(CPersistor &persistor) // to implement persistence for own staff
              {
                persistor.PersistContents(i);  // persist i as  AT element contents
              }
            };
            class B  : public CXMLObject     // to inherit persistence capability
            { int j; A  a;

              DEFINE_XML_TYPE("BT")          // to define the tag name

              virtual void
              Persist(CPersistor &persistor) // to implement persistence for own staff
              {
                persistor.PersistAttribute(_T("INDEX"), j); // persist j
                persistor.Persist(a);                       // persist a
              }
            };

         to have it in the string we may use:

            B b; std::wstring xml_text;
            b.ScSaveToString(&xml_text);

  ---------------------------------------------------------------------------- */

// forward declarations

class CPersistor;
class CXMLObject;
class CXMLElement;
class CXMLDocument;
class CXMLValueExtension;

enum XMLAttributeType
{
    attr_required,
    attr_optional
};

// special modes for certain persistors. These can be used to pass in information about
// how to persist. Not as scalable as a class hierarchy, but useful nonetheless.
enum PersistorMode
{
    persistorModeNone                    =  0x0000,

    persistorModeValueSplitEnabled       =  0x0001,   // used for StringTableStrings, indicates that all strings should be persisted by value

    persistorModeDefault = persistorModeValueSplitEnabled // the default setting
};

/*+-------------------------------------------------------------------------*
 * CONCEPT OF BINARY STORAGE
 *
 * To make xml documents more readable, a part of it (containing base64 - encoded
 * binary data) is stored at separate element located at the end of document.
 * the following sample illustrates this
 *
 *   NOT_USING_BINARY_STROAGE                   USING_BINARY_STROAGE
 *
 *  <ROOT>                                      <ROOT>
 *      <ELEMENT1>                                  <ELEMENT1 BINARY_REF_INDEX="0" />
 *          very_long_bin_data                      <ELEMENT2 BINARY_REF_INDEX="1" />
 *      </ELEMENT1>                                 .....
 *      <ELEMENT2>                                  <BINARY_STORAGE>
 *          other_long_bin_data                         <BINARY>
 *      </ELEMENT2>                                         very_long_bin_data
 *  </ROOT>                                             </BINARY>
 *                                                      <BINARY>
 *                                                          very_long_bin_data
 *                                                      </BINARY>
 *                                                  </BINARY_STORAGE>
 *                                              </ROOT>
 *
 * The decision to be saved at binary storage is made by the CXMLObject.
 * It informs the persistor by returning "true" from UsesBinaryStorage() method;
 *
 * In addition ( to make it locatable ) <BINARY> elements may have 'Name' attribute.
 * CXMLObject may supply it by returning non-NULL pointer to 'Name' attribute value
 * from virtual method GetBinaryEntryName().
 *
 * Storage is created / commited by methods provided in CXMLDocument
 *
 * NOTE: all mentioned methods, as well as GetXMLType() MUST return 'static' values.
 * To make XML document consistent, values need to be fixed [hardcoded].
 *+-------------------------------------------------------------------------*/

/*+-------------------------------------------------------------------------*
 * class CXMLObject
 *
 *
 * PURPOSE: The basic XML persistent object. has a name and a Persist function.
 *          When the object is persisted, an element with the name of the
 *          object is created. The Persist function is then called with
 *          a persistor created on the element.
 *
 *+-------------------------------------------------------------------------*/
class CXMLObject
{
    // this is overridden
public:

    virtual LPCTSTR GetXMLType() = 0;
    virtual void    Persist(CPersistor &persistor) = 0;

    // following methods are implemented by binary elements only.
    // leave it to this base class for most CXMLObject-derived classes.
    // see comment "CONCEPT OF BINARY STORAGE" above

    virtual bool    UsesBinaryStorage() { return false; }

    // this is optional. Overwrite only if you REALLY NEED the name
    virtual LPCTSTR GetBinaryEntryName() { return NULL; }

public: // implemented by CXMLObject. Do not override

    SC ScSaveToString(std::wstring *pString, bool bPutHeader = false); // set bPutHeader = true to write out the "?xml" tag
    SC ScSaveToDocument( CXMLDocument& xmlDocument );
    SC ScLoadFromString(LPCWSTR lpcwstrSource, PersistorMode mode = persistorModeNone);
    SC ScLoadFromDocument( CXMLDocument& xmlDocument );
};

/*+-------------------------------------------------------------------------*
 * MACRO  DEFINE_XML_TYPE
 *
 *
 * PURPOSE:  puts must-to-define methods to XCMLObject derived class implementation
 *           Since xml tag is rather class attribute than object, static method
 *           is provided to retrieve the type when object is not available
 *           Virtual method is provided for tag to be available from gen. purpose
 *           functions using the pointer to the base class.
 *
 * USAGE:    add DEFINE_XML_TYPE(pointer_to_string)
 *
 * NOTE:     'public' access qualifier will be applied for lines following the macro
 *+-------------------------------------------------------------------------*/

#define DEFINE_XML_TYPE(name) \
    public: \
    virtual LPCTSTR GetXMLType()  { return name; } \
    static  LPCTSTR _GetXMLType() { return name; }

/*+-------------------------------------------------------------------------*
 * class  CXMLElementCollection
 *
 *
 * PURPOSE:  Wrapper around IXMLDOMNodeList.
 *
 * NOTE: Throws exceptions!
 *+-------------------------------------------------------------------------*/
class CXMLElementCollection
{
    CComQIPtr<IXMLDOMNodeList, &IID_IXMLDOMNodeList> m_sp;

public:
    CXMLElementCollection(const CXMLElementCollection &other) { m_sp = other.m_sp; }
    CXMLElementCollection(IXMLDOMNodeList *ptr = NULL)  { m_sp = ptr; }

    bool IsNull()  { return m_sp == NULL; }

    void  get_count(long *plCount);
    void  item(LONG lIndex, CXMLElement *pElem);
};

/*+-------------------------------------------------------------------------*
 * class CXMLElement
 *
 *
 * PURPOSE: Wrapper around IXMLDOMNode
 *+-------------------------------------------------------------------------*/
class CXMLElement
{
    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> m_sp;

public:
    CXMLElement(LPUNKNOWN pElem = NULL)  { m_sp = pElem; }
    CXMLElement(const CXMLElement& elem) { m_sp = elem.m_sp;  }

    bool IsNull()                        { return m_sp == NULL; }

    // returns indentation to ad to child element or closing tag
    // to have nice-looking document. indentation depends on element depth
    bool GetTextIndent(CComBSTR& bstrIndent, bool bForAChild);

    void get_tagName(CStr &strTagName);
    void get_parent(CXMLElement * pParent);
    void setAttribute(const CStr &strPropertyName, const CComBSTR &bstrPropertyValue);
    bool getAttribute(const CStr &strPropertyName,       CComBSTR &bstrPropertyValue);
    void removeAttribute(const CStr &strPropertyName);
    void get_children(CXMLElementCollection *pChildren);
    void get_type(DOMNodeType *pType);
    void get_text(CComBSTR &bstrContent);
    void addChild(CXMLElement& rChildElem);
    void removeChild(CXMLElement& rChildElem);
    void replaceChild(CXMLElement& rNewChildElem, CXMLElement& rOldChildElem);
    void getNextSibling(CXMLElement * pNext);
    void getChildrenByName(LPCTSTR strTagName, CXMLElementCollection *pChildren);
    void put_text(BSTR bstrValue);
};

/*+-------------------------------------------------------------------------*
 * class CXMLDocument
 *
 *
 * PURPOSE: Wrapper class for IXMLDOMDocument
 *
 *+-------------------------------------------------------------------------*/
class CXMLDocument
{
    CComQIPtr<IXMLDOMDocument, &IID_IXMLDOMDocument> m_sp;

public:
    CXMLDocument& operator = (IXMLDOMDocument *pDoc) { m_sp = pDoc; return *this; }

    bool IsNull()                        { return m_sp == NULL; }

    operator CXMLElement()               { return CXMLElement(m_sp); }

    void get_root(CXMLElement *pElem);
    void createElement(DOMNodeType type, BSTR bstrTag, CXMLElement *pElem);

    // members to maintain the binary storage
    // see comment "CONCEPT OF BINARY STORAGE" above

    // used on storing (at top level, prior to persisting)
    // - creates an element for storing binary stuff
    void CreateBinaryStorage();
    // used on loading (at top level, prior to persisting)
    // - locates an element to be used for loading binary stuff
    void LocateBinaryStorage();
    // used on storing (at top level, after persisting the main staff)
    // - attaches the binary strage as the last child element of elemParent
    void CommitBinaryStorage();
    // returns element representing binary storage. Used from CPersistor
    CXMLElement GetBinaryStorage() { return m_XMLElemBinaryStorage; }

    SC ScCoCreate(bool bPutHeader);

    SC ScLoad(LPCWSTR strSource);
    SC ScLoad(IStream *pStream, bool bSilentOnErrors = false );
    SC ScSaveToFile(LPCTSTR lpcstrFileName);
    SC ScSave(CComBSTR &bstrResult);

private:
    // element representing binary storage
    CXMLElement m_XMLElemBinaryStorage;
};


/*+-------------------------------------------------------------------------*
 * class CXMLBinary
 *
 *
 * PURPOSE: GetGlobalSize() is alway rounded to allocation units,
 *          so to know the actual size of the memory blob, we need to
 *          carry the size information with HGLOBAL.
 *          This struct is solely to bind these guys
 *+-------------------------------------------------------------------------*/
class CXMLBinary
{
public:
    CXMLBinary();
    CXMLBinary(HGLOBAL handle, size_t size);
    ~CXMLBinary()   { Detach(); }

    void    Attach(HGLOBAL handle, size_t size);
    HGLOBAL Detach();
    size_t  GetSize() const;
    HGLOBAL GetHandle() const;
    SC      ScAlloc(size_t size, bool fZeroInit = false);
    SC      ScRealloc(size_t new_size, bool fZeroInit = false);
    SC      ScFree();

    SC      ScLockData(const void **ppData) const;
    SC      ScLockData(void **ppData) { return ScLockData(const_cast<const void **>(ppData)); }
    SC      ScUnlockData() const;

protected:
    // implementation helpers

private: // not implemented

    CXMLBinary(const CXMLBinary&);  // not implemented; not allowed;
    operator = (CXMLBinary&);       // not implemented; not allowed;

private:
    HGLOBAL             m_Handle;
    size_t              m_Size;
    mutable unsigned    m_Locks;
};


/*+-------------------------------------------------------------------------*
 * class CXMLAutoBinary
 *
 *
 * PURPOSE: same as CXMLAutoBinary, but frees the memory on destruction
 *+-------------------------------------------------------------------------*/
class CXMLAutoBinary : public CXMLBinary
{
public:
    CXMLAutoBinary() : CXMLBinary() {}
    CXMLAutoBinary(HGLOBAL handle, size_t size) : CXMLBinary(handle, size) {}
    ~CXMLAutoBinary()   { ScFree(); }
};

/*+-------------------------------------------------------------------------*
 * class CXMLBinaryLock
 *
 *
 * PURPOSE: provides data locking functionality which is automatically removed
 *          in destructor
 *+-------------------------------------------------------------------------*/
class CXMLBinaryLock
{
public:

    CXMLBinaryLock(CXMLBinary& binary);
    ~CXMLBinaryLock();

    template<typename T>
    SC ScLock(T **ppData)
    {
        return ScLockWorker(reinterpret_cast<void**>(ppData));
    }

    SC ScUnlock();

private: // not implemented

    CXMLBinaryLock(const CXMLBinaryLock&);  // not implemented; not allowed;
    operator = (CXMLBinaryLock&);           // not implemented; not allowed;

private:

    SC ScLockWorker(void **ppData);

    bool        m_bLocked;
    CXMLBinary& m_rBinary;
};

/*+-------------------------------------------------------------------------*
 * class CXMLValue
 *
 *
 * PURPOSE: Holds any type of value, in the spirit of a variant, except
 *          that a pointer to the original object is kept. This allows
 *          reading as well as writing to occur on the original object.
 *
 *+-------------------------------------------------------------------------*/
class CXMLValue
{
    friend class CXMLBoolean;
    enum XMLType
    {
        XT_I4,  //LONG
        XT_UI4, //ULONG
        XT_UI1, //BYTE
        XT_I2,  //SHORT
        XT_DW,  //DWORD
        XT_BOOL,//BOOL
        XT_CPP_BOOL,//bool
        XT_UINT,//UINT
        XT_INT, //INT
        XT_STR, //CStr
        XT_WSTR, // std::wstr
        XT_TSTR, // tstring
        XT_GUID, // GUID
        XT_BINARY, //HGLOBAL - unparsable data
        XT_EXTENSION
    };

    const XMLType m_type;
    union
    {
        LONG        *  pL;
        ULONG       *  pUl;
        BYTE        *  pByte;
        SHORT       *  pS;
        DWORD       *  pDw;
        UINT        *  pUint;
        INT         *  pInt;
        CStr        *  pStr;
        std::wstring * pWStr;
        tstring     * pTStr;
        GUID        * pGuid;
        CXMLBinary  * pXmlBinary;
        bool        *   pbool;
        BOOL        *   pBOOL;
        CXMLValueExtension     * pExtension;
    } m_val;

    // private constructor. used by friend class CXMLBoolean
    CXMLValue(XMLType type)         : m_type(type) { }
public:
    CXMLValue(const CXMLValue   &v) : m_type(v.m_type), m_val(v.m_val) { }
    CXMLValue(LONG &l)              : m_type(XT_I4)     { m_val.pL=&l; }
    CXMLValue(ULONG &ul)            : m_type(XT_UI4)    { m_val.pUl=&ul; }
    CXMLValue(BYTE &b)              : m_type(XT_UI1)    { m_val.pByte=&b; }
    CXMLValue(SHORT &s)             : m_type(XT_I2)     { m_val.pS=&s; }
    CXMLValue(UINT &u)              : m_type(XT_UINT)   { m_val.pUint=&u; }
    CXMLValue(INT &i)               : m_type(XT_INT)    { m_val.pInt=&i; }
    CXMLValue(CStr &str)            : m_type(XT_STR)    { m_val.pStr=&str; }
    CXMLValue(std::wstring &str)    : m_type(XT_WSTR)   { m_val.pWStr=&str; }
    CXMLValue(GUID &guid)           : m_type(XT_GUID)   { m_val.pGuid = &guid; }
    CXMLValue(CXMLBinary &binary)   : m_type(XT_BINARY) { m_val.pXmlBinary = &binary; }
    CXMLValue(tstring &tstr)        : m_type(XT_TSTR)   { m_val.pTStr = &tstr; }
    CXMLValue(CXMLValueExtension& ext) : m_type(XT_EXTENSION) { m_val.pExtension = &ext; }
    SC ScReadFromBSTR(const BSTR bstr);     // read input into the underlying variable.
    SC ScWriteToBSTR (BSTR * pbstr ) const; // writes the value into provided string
    LPCTSTR GetTypeName() const;
    // The following method is called when value is persisted as stand-alone element.
    // Depending on the result returned the contents may go to Binary Storage
    // see comment "CONCEPT OF BINARY STORAGE" above
    bool UsesBinaryStorage() const { return m_type == XT_BINARY; }
};

/*+-------------------------------------------------------------------------*
 * CXMLBoolean
 *
 *
 * PURPOSE: special case: booleans. Need to be printed as true/false, NOT as integer.
 *
 *+-------------------------------------------------------------------------*/
class CXMLBoolean : public CXMLValue
{
public:
    CXMLBoolean(BOOL &b) : CXMLValue(XT_BOOL)       { m_val.pBOOL = &b;}
    CXMLBoolean(bool &b) : CXMLValue(XT_CPP_BOOL)   { m_val.pbool = &b;}
};

/*+-------------------------------------------------------------------------*
 * CXMLValueExtension
 *
 *
 * PURPOSE: interface to extend CXMLValue by more sophisticated types
 *
 *+-------------------------------------------------------------------------*/
class CXMLValueExtension
{
public:
    virtual SC ScReadFromBSTR(const BSTR bstr) = 0;     // read input into the underlying variable.
    virtual SC ScWriteToBSTR (BSTR * pbstr ) const = 0; // writes the value into provided string
    virtual LPCTSTR GetTypeName() const = 0;
};

/*+-------------------------------------------------------------------------*
 * class EnumLiteral
 *
 *
 * PURPOSE: to define enum-to-literal mapping arrays (used by CXMLEnumeration)
 *
 *+-------------------------------------------------------------------------*/

struct EnumLiteral
{
    UINT    m_enum;
    LPCTSTR m_literal;
};


/*+-------------------------------------------------------------------------*
 * class CXMLEnumeration
 *
 *
 * PURPOSE: to persist enumeration as string literal
 *          using array of enum-to-literal mappings
 *
 *+-------------------------------------------------------------------------*/

class CXMLEnumeration : public CXMLValueExtension
{
    // just an enum sized type to hold reference
    // while many enum types will be used, internally they
    // will be cast to this type
    enum enum_t { JUST_ENUM_SIZE_VALUE };
public:

    // template constructor to allow different enums to be persisted
    template<typename _ENUM>
    CXMLEnumeration(_ENUM& en, const EnumLiteral * const etols, size_t count)
                : m_pMaps(etols) ,  m_count(count), m_rVal((enum_t&)(en))
    {
        // folowing lines won't compile in case you are trying to pass
        // type other than enum or int
        COMPILETIME_ASSERT( sizeof(en) == sizeof(enum_t) );
        UINT testit = en;
    }

    // CXMLValueExtension metods required to implement
    SC ScReadFromBSTR(const BSTR bstr);     // read input into the underlying variable.
    SC ScWriteToBSTR (BSTR * pbstr ) const; // writes the value into provided string
    LPCTSTR GetTypeName() const { return _T("Enumerations"); }

    // to enable passing itself as CMLValue
    operator CXMLValue ()
    {
        return CXMLValue (*this);
    }

private:
    enum_t                          &m_rVal;
    const   EnumLiteral * const     m_pMaps;
    const   size_t                  m_count;
};

/*+-------------------------------------------------------------------------*
 * class CXMLBitFlags
 *
 *
 * PURPOSE: to persist bit flags as string literals
 *          using array of enum-to-literal mappings
 *
 *+-------------------------------------------------------------------------*/

class CXMLBitFlags
{
public:

    // template constructor to allow different enums to be persisted
    template<typename _integer>
    CXMLBitFlags(_integer& flags, const EnumLiteral * const etols, size_t count)
                : m_pMaps(etols) ,  m_count(count), m_rVal((UINT&)flags)
    {
        // folowing lines won't compile in case you are trying to pass
        // type other than enum or int
        COMPILETIME_ASSERT( sizeof(flags) == sizeof(UINT) );
        UINT testit = flags;
    }

    void PersistMultipleAttributes(LPCTSTR name, CPersistor &persistor);

private:
    UINT                           &m_rVal;
    const   EnumLiteral * const     m_pMaps;
    const   size_t                  m_count;
};

/*+-------------------------------------------------------------------------*
 * class XMLPoint
 *
 *
 * PURPOSE: Holds the name and value of a point object
 *
 *+-------------------------------------------------------------------------*/
class XMLPoint : public CXMLObject
{
    CStr            m_strObjectName;
    POINT    &      m_point;
public:
    XMLPoint(const CStr& strObjectName, POINT &point);

    DEFINE_XML_TYPE(XML_TAG_POINT);
    virtual void    Persist(CPersistor &persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLRect
 *
 *
 * PURPOSE: Holds the name and value of a rectangle object
 *
 *+-------------------------------------------------------------------------*/
class XMLRect : public CXMLObject
{
    CStr            m_strObjectName;
    RECT    &       m_rect;
public:
    XMLRect(const CStr strObjectName, RECT &rect);

    DEFINE_XML_TYPE(XML_TAG_RECTANGLE);
    virtual void    Persist(CPersistor &persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionBase
 *
 *
 * PURPOSE: Defines the base list collection class for persisting stl:list's
 *          It's intended to be used as a base for deriving list persitence classes
 *          Persist method implements "load" by iterating thru xml elements
 *          and calling OnNewElement for each, and can be reused by derived classes.
 *
 * USAGE:   Probably the better idea is to use XMLListColLectionImp
 *          as a base to your collection instead of this class (it is richer). Use this class
 *          only if your class has special items which does not allow you to use that class.
 *
 *+-------------------------------------------------------------------------*/
class XMLListCollectionBase: public CXMLObject
{
public:
    // function called when new element is to be created and loaded
    virtual void OnNewElement(CPersistor& persistor) = 0;
    virtual void Persist(CPersistor& persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionImp
 *
 * PURPOSE: A base class for stl::list derived collections implementing persitence of
 *          the list items as linear sequence of xml items.
 *          The items kept in the list must be either CXMLObject-derived or be
 *          of the simple type (one accepted by CXMLVBalue constructors)
 *
 * USAGE:   Derive your class from XMLListCollectionImp parametrized by the list,
 *          instead of deriving from stl::list directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element.
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    if provided implementation does not fit for you - f.i. your elements need
 *          a parameter to the constructor, or special initialization,
 *          use XMLListCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class LT>
class XMLListCollectionImp: public XMLListCollectionBase , public LT
{
    typedef typename LT::iterator iter_t;
public:
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = begin(); it != end(); ++it)
                persistor.Persist(*it);
        }
        else
        {
            clear();
            // let the base class do the job
            // it will call OnNewElement for every element found
            XMLListCollectionBase::Persist(persistor);
        }
    }
    // method called to create and load new element
    virtual void OnNewElement(CPersistor& persistor)
    {
        iter_t it = insert(end());
        persistor.Persist(*it);
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionWrap
 *
 * PURPOSE: A wrapper around stl::list to support persisting
 *          To be used to persist stl::list objects "from outside" - i.e. without
 *          deriving the list class from persistence-enabled classes.
 *
 * USAGE:   If you have list m_l to persist, create the object XMLListCollectionWrap wrap(m_l,"tag")
 *          on the stack and persist that object (f.i. Persistor.Persist(wrap)
 *
 * NOTE:    if provided implementation does not fit for you - see if you can use
 *          XMLListCollectionImp or XMLListCollectionBase as a base for your list.
 *+-------------------------------------------------------------------------*/
template<class LT>
class XMLListCollectionWrap: public XMLListCollectionBase
{
    typedef typename LT::iterator iter_t;
    LT & m_l;
    CStr    m_strListType;
public:
    XMLListCollectionWrap(LT &l, const CStr &strListType)
        : m_l(l), m_strListType(strListType) {}
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = m_l.begin(); it != m_l.end(); ++it)
                persistor.Persist(*it);
        }
        else
        {
            m_l.clear();
            // let the base class do the job
            // it will call OnNewElement for every element found
            XMLListCollectionBase::Persist(persistor);
        }
    }
    // method called to create and load new element
    virtual void OnNewElement(CPersistor& persistor)
    {
        iter_t it = m_l.insert(m_l.end());
        persistor.Persist(*it);
    }
    virtual LPCTSTR GetXMLType() {return m_strListType;}
private:
    // to prevent ivalid actions on object
    XMLListCollectionWrap(const XMLListCollectionWrap& other);
    XMLListCollectionWrap& operator = ( const XMLListCollectionWrap& other ) { return *this; }
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollectionBase
 *
 *
 * PURPOSE: Defines the base map collection class for persisting stl:map's
 *          It's intended to be used as a base for deriving map persitence classes.
 *          Persist method implements "load" by iterating thru xml elements
 *          and calling OnNewElement for each pair, and can be reused by derived classes.
 *
 * USAGE:   Probably the better idea is to use XMLMapCollection or XMLMapColLectionImp
 *          as a base to your collection instead of this class (they are richer). Use this class
 *          only if your class has special items which does not allow you to use those classes.
 *
 *+-------------------------------------------------------------------------*/
class XMLMapCollectionBase: public CXMLObject
{
public:
    // function called when new element is to be created and loaded
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal) = 0;
    // base implementation [loading only!] enumerates elements calling OnNewElement for each
    virtual void Persist(CPersistor& persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollection
 *
 * PURPOSE: Use this class only when you cannot use XMLMapCollectionImp due to
 *          special requirements on construction of the elements kept in the map
 *          (see also purpose of XMLMapCollectionImp)
 *
 * USAGE:   Derive your class from XMLMapCollection parametrized by the map,
 *          instead of deriving from stl::map directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element. Define OnNewElement
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    Your class should implement: OnNewElement to be functional.
 *
 * NOTE:    if provided implementation does not fit for you -
 *          use XMLMapCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollection: public XMLMapCollectionBase, public MT
{
    typedef typename MT::iterator iter_t;
public:
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = begin(); it != end(); ++it)
            {
                MT::key_type *pKey = const_cast<MT::key_type*>(&it->first);
                persistor.Persist(*pKey);
                persistor.Persist(it->second);
            }
        }
        else
        {
            clear();
            XMLMapCollectionBase::Persist(persistor);
        }
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollectionImp
 *
 * PURPOSE: A base class for stl::map derived collections implementing persitence of
 *          the map items as linear sequence of xml items.
 *          The items kept in the map must be either CXMLObject-derived or be
 *          of the simple type (one accepted by CXMLVBalue constructors)
 *
 * USAGE:   Derive your class from XMLMapCollectionImp parametrized by the map,
 *          instead of deriving from stl::map directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element.
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    if provided implementation does not fit for you - f.i. your elements need
 *          a parameter to the constructor, or special initialization,
 *          use XMLMapCollection or XMLMapCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollectionImp: public XMLMapCollection<MT>
{
public:
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        MT::key_type key;
        persistKey.Persist(key);

        MT::referent_type val;
        persistVal.Persist(val);

        insert(MT::value_type(key,val));
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionWrap
 *
 * PURPOSE: A wrapper around stl::map to support persisting
 *          To be used to persist stl::map objects "from outside" - i.e. without
 *          deriving the map class from persistence-enabled classes.
 *
 * USAGE:   If you have map m_m to persist, create the object XMLMapCollectionWrap wrap(m_m,"tag")
 *          on the stack and persist that object (f.i. Persistor.Persist(wrap)
 *
 * NOTE:    if provided implementation does not fit for you - see if you can use
 *          XMLMapCollection or XMLMapCollectionImp or XMLMapCollectionBase as a base for your map
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollectionWrap: public XMLMapCollectionBase
{
    typedef typename MT::iterator iter_t;
    MT & m_m;
    CStr    m_strMapType;
public:
    XMLMapCollectionWrap(MT &m, const CStr &strMapType) : m_m(m), m_strMapType(strMapType) {}
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        MT::key_type key;
        persistKey.Persist(key);

        MT::referent_type val;
        persistVal.Persist(val);

        m_m.insert(MT::value_type(key,val));
    }
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = m_m.begin(); it != m_m.end(); ++it)
            {
                MT::key_type *pKey = const_cast<MT::key_type*>(&it->first);
                persistor.Persist(*pKey);
                persistor.Persist(it->second);
            }
        }
        else
        {
            m_m.clear();
            XMLMapCollectionBase::Persist(persistor);
        }
    }
    virtual LPCTSTR GetXMLType() {return m_strMapType;}
private:
    // to prevent ivalid actions on object
    XMLMapCollectionWrap(const XMLMapCollectionWrap& other);
    XMLMapCollectionWrap& operator = ( const XMLMapCollectionWrap& other ) { return *this; }
};

/*+-------------------------------------------------------------------------*
 * class CPersistor
 *
 *
 * PURPOSE: Defines the Persistor class used for XML serialization
 *             Persistors are aware if the file is being loaded or saved. Thus,
 *             methods like Persist work for both directions, and
 *             uses references to the data being persisted.
 *
 * USAGE:   1) a persistor can be created "underneath" another persistor, using
 *          the appropriate constructor.
 *          2) To make an object persistable, derive it from CXMLObject, and
 *             implement the abstract methods. The syntax persistor.Persits(object)
 *             will then automatically work correctly.
 *          3) To persist an element use Pesist method. It will create new / locate
 *             CPersist object for an element (under this persistor's element)
 *          4) Collection classes when persisting their members specify "bLockedOnChild"
 *             constructors parameter as "true". This technique changes persistor's
 *             behavior. Insted of loacting the element (#3), constructor of new
 *             persistor will only check if element pointed by parent is of required type.
 *
 * NOTES:   1) StringTableStrings can be saved with either the ID inline or the
 *             actual string value inline. The latter is useful when loading/saving
 *             XML to/from a string instead of a file. This is controlled by the
 *	           EnableValueSplit method.
 *             Binary storage usage is also controlled by it
 *+-------------------------------------------------------------------------*/
class CPersistor
{
    // NOTE: if member variable is to be inherited by child persistors,
    // don't forget to add it to CPersistor::BecomeAChildOf method
    CXMLDocument    m_XMLDocument;
    CXMLElement     m_XMLElemCurrent;
    bool            m_bIsLoading;
    bool            m_bLockedOnChild;
    DWORD           m_dwModeFlags;     // any special modes

private:
    void  SetMode(PersistorMode mode, bool bEnable) {m_dwModeFlags = (m_dwModeFlags & ~mode) | (bEnable ? mode : 0);}
    bool  IsModeSet(PersistorMode mode)  {return (m_dwModeFlags & mode);}
public:
    void  SetMode(PersistorMode mode)               {m_dwModeFlags = mode;}


public:
    // construct a persistor from a parent persistor.
    // this creates a new XML element with the given name,
    // and everything persisted to the new persistor
    // is persisted under this element.
    CPersistor(CPersistor &persistorParent, const CStr &strElementType, LPCTSTR szElementName = NULL);
    // construct a new persistor for given document and root element
    // everything persisted to the new persistor
    // is persisted under this element.
    CPersistor(CXMLDocument &document, CXMLElement& rElemRoot);
    // used to create child persistor on particular element
    // bLockedOnChild is used to create a "fake parent" persistor, which
    // will always return the child without trying to locate it (pElemCurrent)
    CPersistor(CPersistor &other, CXMLElement& rElemCurrent, bool bLockedOnChild = false);

    CXMLDocument &  GetDocument()                  {return (m_XMLDocument);}
    CXMLElement  &  GetCurrentElement()                 {return (m_XMLElemCurrent);}
    bool            HasElement(const CStr &strElementType, LPCTSTR szstrElementName);
    void            EnableValueSplit       (bool bEnable)      { SetMode(persistorModeValueSplitEnabled,       bEnable); }

    // the various modes
    bool            FEnableValueSplit()                {return IsModeSet(persistorModeValueSplitEnabled);}

    // Load/Store mode related functions.
    bool            IsLoading()        {return m_bIsLoading;}
    bool            IsStoring()        {return !m_bIsLoading;}
    void            SetLoading(bool b) {m_bIsLoading = b;}

    // special methods to set/get the Name attribute of a persistor
    void            SetName(const CStr & strName);
    CStr            GetName();

    // Canned persistence methods:

    // .. to persist CXMLObject-derived object under own sub-element
    // <this><object_tag>object_body</object_tag></this>
    void Persist(CXMLObject &object, LPCTSTR lpstrName = NULL);

    // .. to persist value of the simple type under own sub-element
    // <this><value_type value="value"/></this>
    void Persist(CXMLValue xval, LPCTSTR name = NULL);

    // .. to persist value as named attribute of this element
    // <this name="value"/>
    void PersistAttribute(LPCTSTR name,CXMLValue xval,const XMLAttributeType type = attr_required);

    // .. to persist value as contents of this element
    // <this>value</this>
    // NOTE:  xml element cannot have both value-as-contents and sub-elements
    void PersistContents(CXMLValue xval);

    // .. to persist flags as separate attributes
    void PersistAttribute( LPCTSTR name, CXMLBitFlags& flags );

    /***************************************************************************\
     *
     * METHOD:  CPersistor::PersistList
     *
     * PURPOSE: it is designated for persisting std::list type of collections
     *          as a subelement of the persistor.
     *          NOTE: list elements need to be either CXMLObject-derived or be
     *                of the simple type (one accepted by CXMLVBalue constructors)
     *          NOTE2: list elements must have default constuctor available
     *
     * PARAMETERS:
     *    const CStr &strListType   - [in] tag of new subelement
     *    LPCTSTR name              - [in] name attr. of new subelement (NULL == none)
     *    std::list<T,Al>& val      - [in] list to be persisted
     *
     * RETURNS:
     *    void
     *
    \***************************************************************************/
    template<class T, class Al>
    void PersistList(const CStr &strListType, LPCTSTR name,std::list<T,Al>& val)
    {
        typedef std::list<T,Al> LT;
        XMLListCollectionWrap<LT> lcol(val,strListType);
        Persist(lcol, name);
    }

    /***************************************************************************\
     *
     * METHOD:  PersistMap
     *
     * PURPOSE: it is designated for persisting std::map type of collections
     *          as a subelement of the persistor.
     *          NOTE: map elements (both key and val) need to be either CXMLObject-derived
     *                or be of the simple type (one accepted by CXMLVBalue constructors)
     *          NOTE2: map elements must have default constuctor available
     *
     * PARAMETERS:
     *    const CStr &strListType   - [in] tag of new subelement
     *    LPCTSTR name              - [in] name attr. of new subelement (NULL == none)
     *    std::map<K,T,Pr,Al>& val  - [in] map to be persisted
     *
     * RETURNS:
     *    void
     *
    \***************************************************************************/
    template<class K, class T, class Pr, class Al>
    void PersistMap(const CStr &strMapType, LPCTSTR name, std::map<K, T, Pr, Al>& val)
    {
        typedef std::map<K, T, Pr, Al> MT;
        XMLMapCollectionWrap<MT> mcol(val,strMapType);
        Persist(mcol, name);
    }

    void PersistString(LPCTSTR lpstrName, CStringTableStringBase &str);

private: // private implementation helpers
    // common constructor, not to be used from outside.
    // provided as common place for member initialization
    // all the constructors should call it prior to doing anything specific.
    void CommonConstruct();
    // element creation / locating
    CXMLElement AddElement(const CStr &strElementType, LPCTSTR szElementName);
    CXMLElement GetElement(const CStr &strElementType, LPCTSTR szstrElementName, int iIndex = -1);
    void AddTextElement(BSTR bstrData);
    void GetTextElement(CComBSTR &bstrData);
    CXMLElement CheckCurrentElement(const CStr &strElementType, LPCTSTR szstrElementName);
    void BecomeAChildOf(CPersistor &persistorParent, CXMLElement elem);
};


/*+-------------------------------------------------------------------------*
 * class CXML_IStorage
 *
 * PURPOSE: This class provides memory-based implementation of IStorage plus
 *          it supports persisting the data on the storage to/from XML.
 *          Mostly used to create IStorage for snapin data to be saved
 *          to console file as XML binary blob
 *
 * USAGE:   You will create the object whenever you need a memory-based IStorage
 *          implementation. To access IStorage interface use GetIStorage() method.
 *          It will create a storage if does not have one under control already.
 *          You will use returned pointer for Read and Write operations.
 *          Whenever required you will pass the object to CPersistor::Persist method
 *          to have it persisted using XML persistence model.
 *
 * NOTE:    You are encoureged to use GetIStorage() for accessing the undelying IStorage.
 *          Do not cache returned pointer, since the storage may change when persisted
 *          from XML, and this invalidates the pointer. However if you AddRef,
 *          the pointer will be valid as long as the last reference is released.
 *          That means it may outlive CXML_IStorage object itself - nothing wrong with that.
 *          You only must be aware that once persistence (loading) from XML is completed,
 *          CXML_IStorage will switch to the new storage and it will not be in sync with
 *          the pointer you have. Always use GetIStorage() to get the current pointer.
 *
 *+-------------------------------------------------------------------------*/
class CXML_IStorage : public CXMLObject
{
public: // interface methods not throwing any exceptions
    
    SC ScInitializeFrom( IStorage *pSource );
    SC ScInitialize(bool& bCreatedNewOne);
    SC ScGetIStorage( IStorage **ppStorage );
    SC ScRequestSave(IPersistStorage * pPersistStorage);

    // instruct to persist to binary storage
    virtual bool UsesBinaryStorage() { return true; }

    DEFINE_XML_TYPE(XML_TAG_ISTORAGE);

public: // interface methods throwing SC's

    virtual void Persist(CPersistor &persistor);

private:
    IStoragePtr     m_Storage;
    ILockBytesPtr   m_LockBytes;
// following methods\data is for trace support in CHK builds
#ifdef DBG
public:
    DBG_PersistTraceData m_dbg_Data;
#endif // #ifdef DBG
}; // class CXML_IStorage


/*+-------------------------------------------------------------------------*
 * class CXML_IStream
 *
 * PURPOSE: This class provides memory-based implementation of IStream plus
 *          it supports persisting the data on the stream to/from XML.
 *          Mostly used to create IStream for snapin data to be saved
 *          to console file as XML binary blob
 *
 * USAGE:   You will create the object whenever you need a memory-based IStream
 *          implementation. To access IStream interface use GetIStream() method.
 *          It will create a stream if does not have one under control already.
 *          You will use returned pointer for Read and Write operations.
 *          Whenever required you will pass the object to CPersistor::Persist method
 *          to have it persisted using XML persistence model.
 *
 * NOTE:    You are encoureged to use GetIStream() for accessing the undelying IStream.
 *          Do not cache returned pointer, since the stream may change when persisted
 *          from XML, and this invalidates the pointer. However if you AddRef,
 *          the pointer will be valid as long as the last reference is released.
 *          That means it may outlive CXML_IStream object itself - nothing wrong with that.
 *          You only must be aware that once persistence (loading) from XML is completed,
 *          CXML_IStream will switch to the new stream and it will not be in sync with
 *          the pointer you have. Always use GetIStream() to get the current pointer.
 *
 * NOTE:    Every call to GetIStream() moves stream cursor to the begining of the stream
 *
 *+-------------------------------------------------------------------------*/
class CXML_IStream : public CXMLObject
{
public: // interface methods not throwing any exceptions
    
    SC ScInitializeFrom( IStream *pSource );
    SC ScInitialize(bool& bCreatedNewOne);
    SC ScSeekBeginning();
    SC ScGetIStream( IStream **ppStream );
    SC ScRequestSave(IPersistStorage * pPersistStream);
    inline SC ScRequestSave(IPersistStream * pPersistStream)
    {
        return ScRequestSaveX(pPersistStream);
    }
    inline SC ScRequestSave(IPersistStreamInit * pPersistStreamInit)
    {
        return ScRequestSaveX(pPersistStreamInit);
    }

    // instruct to persist to binary storage
    virtual bool UsesBinaryStorage() { return true; }

    DEFINE_XML_TYPE(XML_TAG_ISTREAM);

public:
    virtual void Persist(CPersistor &persistor);

private:
    template<class TIPS>
    SC ScRequestSaveX(TIPS * pPersistStream)
    {
        DECLARE_SC(sc, TEXT("CXML_IStream::ScRequestSaveX"));

        // initialize
        bool bCreatedNewOne = false; // unused here
        sc = ScInitialize(bCreatedNewOne);
        if (sc)
            return sc;

        // recheck pointers
        sc = ScCheckPointers( m_Stream, E_UNEXPECTED );
        if (sc)
            return sc;
        
        ULARGE_INTEGER null_size = { 0, 0 };
        sc = m_Stream->SetSize( null_size );
        if(sc)
            return sc;
        
        sc = ScSeekBeginning();
        if(sc)
            return sc;

        sc = pPersistStream->Save( m_Stream, TRUE );
        if(sc)
            return sc;

        // commit the changes - this ensures everything is in HGLOBAL
        sc = m_Stream->Commit( STGC_DEFAULT );
        if(sc)
            return sc;

#ifdef DBG
        if (S_FALSE != pPersistStream->IsDirty())
            DBG_TraceNotResettingDirty(typeid(TIPS).name());
#endif // #ifdef DBG

        return sc;
    }
private:
    IStreamPtr  m_Stream;
#ifdef DBG // tracing support
public:
    DBG_PersistTraceData m_dbg_Data;
    void DBG_TraceNotResettingDirty(LPCSTR strIntfName);
#endif // #ifdef DBG
}; // class CXML_IStream

/*+-------------------------------------------------------------------------*
 * class CXMLPersistableIcon
 *
 * PURPOSE: Persists wraps for persisting CPersistableIcon
 *
 * USAGE:   Create object whenever you need to persist to CPersistableIcon
 *
 *+-------------------------------------------------------------------------*/

class CPersistableIcon;

class CXMLPersistableIcon : public CXMLObject
{
    CPersistableIcon& m_Icon;
public:
    CXMLPersistableIcon(CPersistableIcon& Icon) : m_Icon(Icon) {}
    DEFINE_XML_TYPE(XML_TAG_ICON);
    virtual void    Persist(CPersistor &persistor);
};


/*+-------------------------------------------------------------------------*
 * CXMLVariant
 *
 * This class implements a CComVariant that can persist itself to/from an
 * XML persistor.
 *--------------------------------------------------------------------------*/

class CXMLVariant :
    public CComVariant,
    public CXMLObject
{
public:
    // construction and assignment forwarders
    CXMLVariant() {}
    CXMLVariant(const VARIANT& varSrc)                  : CComVariant(varSrc)       {}
    CXMLVariant(const CComVariant& varSrc)              : CComVariant(varSrc)       {}
    CXMLVariant(const CXMLVariant& varSrc)              : CComVariant(varSrc)       {}
    CXMLVariant(BSTR bstrSrc)                           : CComVariant(bstrSrc)      {}
    CXMLVariant(LPCOLESTR lpszSrc)                      : CComVariant(lpszSrc)      {}
#ifndef OLE2ANSI
    CXMLVariant(LPCSTR lpszSrc)                         : CComVariant(lpszSrc)      {}
#endif
    CXMLVariant(bool bSrc)                              : CComVariant(bSrc)         {}
    CXMLVariant(int nSrc)                               : CComVariant(nSrc)         {}
    CXMLVariant(BYTE nSrc)                              : CComVariant(nSrc)         {}
    CXMLVariant(short nSrc)                             : CComVariant(nSrc)         {}
    CXMLVariant(float fltSrc)                           : CComVariant(fltSrc)       {}
    CXMLVariant(double dblSrc)                          : CComVariant(dblSrc)       {}
    CXMLVariant(CY cySrc)                               : CComVariant(cySrc)        {}
    CXMLVariant(long nSrc, VARTYPE vtSrc = VT_I4)       : CComVariant(nSrc, vtSrc)  {}

    CXMLVariant& operator=(const CXMLVariant& varSrc)   { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(const CComVariant& varSrc)   { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(const VARIANT& varSrc)       { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(BSTR bstrSrc)                { CComVariant::operator=(bstrSrc);  return (*this); }
    CXMLVariant& operator=(LPCOLESTR lpszSrc)           { CComVariant::operator=(lpszSrc);  return (*this); }
#ifndef OLE2ANSI
    CXMLVariant& operator=(LPCSTR lpszSrc)              { CComVariant::operator=(lpszSrc);  return (*this); }
#endif
    CXMLVariant& operator=(bool bSrc)                   { CComVariant::operator=(bSrc);     return (*this); }
    CXMLVariant& operator=(int nSrc)                    { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(BYTE nSrc)                   { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(short nSrc)                  { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(long nSrc)                   { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(float fltSrc)                { CComVariant::operator=(fltSrc);   return (*this); }
    CXMLVariant& operator=(double dblSrc)               { CComVariant::operator=(dblSrc);   return (*this); }
    CXMLVariant& operator=(CY cySrc)                    { CComVariant::operator=(cySrc);    return (*this); }

public:
    DEFINE_XML_TYPE(XML_TAG_VARIANT);
    virtual void Persist(CPersistor &persistor);

    bool IsPersistable() const
        { return (IsPersistable(this)); }

    static bool IsPersistable(const VARIANT* pvar)
    {
        if (pvar == NULL)
            return (false);

        /*
         * we can only store variants that are "simple" (i.e. not by-ref,
         * array, etc.)
         */
        return ((V_VT(pvar) & ~VT_TYPEMASK) == 0);
    }
};

/***************************************************************************\
 *
 * CLASS:  CConsoleFilePersistor
 *
 * PURPOSE: File persistence black box. all console file - user data logic
 *          is hiden under this class
 *
 * USAGE:   Use instance of this class to load and save console file,
 *          NOTE - saving should be done with the same instance the console
 *          was loaded.
 *          Good idea for your class maintaning console (such as AMCDocument)
 *          to either derive of contain instance of this class
 *
\***************************************************************************/
class CConsoleFilePersistor
{
public: // public interface

    CConsoleFilePersistor() : m_bCRCValid(false) {}

    SC ScSaveConsole(LPCTSTR lpstrConsolePath, bool bForAuthorMode, const CXMLDocument& xmlDocument);
    SC ScLoadConsole(LPCTSTR lpstrConsolePath, bool& bXmlBased, CXMLDocument& xmlDocument,
                     IStorage **ppStorage);

    static SC ScGetUserDataFolder(tstring& strUserDataFolder);

private: // implementation helpers

    static SC ScGetUserDataPath(LPCTSTR lpstrOriginalPath, tstring& strUserDataPath);
    static SC ScGetUserData(const tstring& strUserDataConsolePath,
                            const tstring& strFileCRC,
                            bool& bValid, CXMLDocument& xmlDocument);

    static SC ScOpenDocAsStructuredStorage(LPCTSTR lpszPathName, IStorage **ppStorage);
    static SC ScLoadXMLDocumentFromFile(CXMLDocument& xmlDocument, LPCTSTR strFileName, bool bSilentOnErrors = false);

private: // compress/uncompress the file
    static void GetBinaryCollection(CXMLDocument& xmlDocument, CXMLElementCollection&  colBinary);
    static SC ScCompressUserStateFile(LPCTSTR szConsoleFilePath, CXMLDocument & xmlDocument);
    static SC ScUncompressUserStateFile(CXMLDocument &xmlDocumentOriginal, CXMLDocument& xmlDocument);

private: // internal data

    tstring m_strFileCRC;
    bool    m_bCRCValid;
};

#endif // XMLBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\xmlimage.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlimage.h
 *
 *  Contents:  Interface file for CXMLImageList
 *
 *  History:   10-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


#include "xmlbase.h"			// for CXMLObject
#include "atlbase.h"			// for CComModule
#include "atlapp.h"				// required by atlctrls.h
extern CComModule _Module;		// required by atlwin.h
#include "atlwin.h"				// required by atlctrls.h
#include "atlctrls.h"			// for WTL::CImageList
#include "strings.h"			// for XML_TAG_VALUE_BIN_DATA

/*+-------------------------------------------------------------------------*
 * class CXMLImageList
 *
 * This class adds XML persistence to WTL::CImageLists.
 *--------------------------------------------------------------------------*/

class CXMLImageList :
	public CXMLObject,
	public WTL::CImageList
{
public:
    // CXMLObject methods
    virtual void Persist(CPersistor &persistor);
    virtual bool UsesBinaryStorage()				{ return (true); }
    DEFINE_XML_TYPE(XML_TAG_VALUE_BIN_DATA);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\inc\xmlicon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlicon.h
 *
 *  Contents:  Interface file for CXMLIcon
 *
 *  History:   26-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "xmlbase.h"	// for CXMLObject
#include "smarticon.h"	// for CSmartIcon


/*+-------------------------------------------------------------------------*
 * class CXMLIcon
 *
 * This class adds XML persistence to CSmartIcons.  CSmartIcon cannot
 * implement XML persistence on its own because it is used in the shell
 * extension.  The shell extension must be extremely lightweight, but
 * XML persistence requires mmcbase.dll.  Depending on mmcbase.dll would
 * make the shell extension too heavy, so we have this functionality split.
 *--------------------------------------------------------------------------*/

class CXMLIcon :
	public CXMLObject,
	public CSmartIcon
{
public:
	CXMLIcon (LPCTSTR pszBinaryEntryName = NULL) :
		m_strBinaryEntryName ((pszBinaryEntryName != NULL) ? pszBinaryEntryName : _T(""))
	{}

	// default copy construction, copy assignment, and destruction are fine

	CXMLIcon& operator= (const CSmartIcon& other)
	{
		CSmartIcon::operator= (other);
		return (*this);
	}

    // CXMLObject methods
public:
    virtual void Persist(CPersistor &persistor);
    virtual bool UsesBinaryStorage()				{ return (true); }
    virtual LPCTSTR GetBinaryEntryName();
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_ICON);

private:
	const tstring	m_strBinaryEntryName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\api.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       API.c
//
//  Contents:
//
//  APIs:       MMCPropertyChangeNotify
//
//  History:    10/15/1996   RaviR   Created
//____________________________________________________________________________
//

#include <wtypes.h>
#include "objbase.h"
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "commctrl.h" // for LV_ITEMW needed by ndmgrpriv.h
#include "mmc.h"
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "mmcptrs.h"
#include "ndmgrp.h"
#include "amcmsgid.h"


HRESULT MMCPropertyChangeNotify(LONG_PTR lNotifyHandle, LPARAM lParam)
{
    // Note - the property sheet is in a different thread than the console.
    // So init COM.
    HRESULT hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        LPPROPERTYSHEETNOTIFY ppsn;

        hr = CoCreateInstance (CLSID_NodeManager, NULL, CLSCTX_INPROC,
                               IID_IPropertySheetNotify,
                               reinterpret_cast<void **>(&ppsn));

        if (SUCCEEDED(hr))
        {
            LPPROPERTYNOTIFYINFO ppni = reinterpret_cast<LPPROPERTYNOTIFYINFO>(lNotifyHandle);

            ppsn->Notify (ppni, lParam);
            ppsn->Release();
        }

        // Uninit COM
        CoUninitialize();
    }

    return (hr);
}


HRESULT MMCPropertyHelp (LPOLESTR pszHelpTopic)
{
    // find the MMC main window for this process
    HWND        hwndFrame    = NULL;
    const DWORD dwCurrentPid = GetCurrentProcessId();

    while (1)
    {
        // find an MMC frame window
        hwndFrame = FindWindowEx (NULL, hwndFrame, MAINFRAME_CLASS_NAME, NULL);

        if (hwndFrame == NULL)
            break;

        // found a frame, is it on this process?
        DWORD   dwWindowPid;
        GetWindowThreadProcessId (hwndFrame, &dwWindowPid);

        if (dwCurrentPid == dwWindowPid)
            break;
    }

    if (hwndFrame == NULL)
        return (E_UNEXPECTED);

    return ((HRESULT) SendMessage (hwndFrame, MMC_MSG_SHOW_SNAPIN_HELP_TOPIC,
                                   NULL, reinterpret_cast<LPARAM>(pszHelpTopic)));
}


HRESULT MMCFreeNotifyHandle(LONG_PTR lNotifyHandle)
{

    if (lNotifyHandle == NULL)
        return E_INVALIDARG;

    LPPROPERTYNOTIFYINFO ppni =
            reinterpret_cast<LPPROPERTYNOTIFYINFO>(lNotifyHandle);

    BOOL bResult;

    if ((bResult = IsBadReadPtr(ppni, sizeof(PROPERTYNOTIFYINFO))) == FALSE)
        ::GlobalFree(ppni);

    return ((bResult == FALSE) ? S_OK : E_FAIL);
}


HRESULT MMCIsMTNodeValid(void* pMTNode, BOOL bReset)
{
    HRESULT hr = S_FALSE;
    HWND hWnd = NULL;
    DWORD dwPid = 0;
    DWORD dwTid = 0;

    if (pMTNode == NULL)
        return hr;

    while (1)
    {
        hWnd = ::FindWindowEx(NULL, hWnd, DATAWINDOW_CLASS_NAME, NULL);

        // No windows found
        if (hWnd == NULL)
            break;

        // Check if the window belongs to the current process
        dwTid = ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        // Get the extra bytes and compare the data objects
        if (GetClassLong(hWnd, GCL_CBWNDEXTRA) != WINDOW_DATA_SIZE)
            break;

        DataWindowData* pData = GetDataWindowData (hWnd);

        if (pData == NULL)
            break;

        if (pData->lpMasterNode == reinterpret_cast<LONG_PTR>(pMTNode))
        {
            // clear the data out if the user requests it
            if (bReset)
                pData->lpMasterNode = NULL;

            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\mmciid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmciid.c
//
//--------------------------------------------------------------------------

#include <mmc_i.c>      // from <root>\admin\published\mmc
#include <mmcobj_i.c>   // from <root>\admin\published\mmc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\clsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       clsid.c
//
//--------------------------------------------------------------------------

#include "ndmgr.h"

// This is an alternate name for the CLSID CLSID_NodeInit. There is a cpp_quote statement
// in mmc.idl to declare the extern.  This is what is published to the snap-ins

CLSID const CLSID_NodeManager =
    {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


// {80F94176-FCCC-11d2-B991-00C04F8ECD78}
const CLSID CLSID_MessageView =
{ 0x80f94176, 0xfccc, 0x11d2, { 0xb9, 0x91, 0x0, 0xc0, 0x4f, 0x8e, 0xcd, 0x78 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\ndmgriid.c ===
#include "ndmgr_i.c"
#include "hcolwrap_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\apimfc.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       apimfc.cpp
//
//  Contents:   
//
//  APIs:       MFC specific API in core
//
//____________________________________________________________________________
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
#include <afxwin.h>         // MFC core and standard components

#include "..\inc\mmc.h"



LPFNPSPCALLBACK _MMCHookPropertyPage;
HHOOK           _MMCmsgHook;

LRESULT CALLBACK _MMCHookCBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_MMCmsgHook != 0);

    if (nCode < 0)
        return CallNextHookEx(_MMCmsgHook, nCode, wParam, lParam);

    if (nCode == HCBT_CREATEWND)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        CallNextHookEx(_MMCmsgHook, nCode, wParam, lParam);
        UnhookWindowsHookEx(_MMCmsgHook);
    }
    
    return 0; // Allow the window to be created
}


UINT CALLBACK _MMCHookPropSheetPageProc(HWND hwnd,UINT uMsg,LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookPropertyPage(hwnd, uMsg, ppsp);
    
    switch (uMsg)
    {
        case PSPCB_CREATE:
            _MMCmsgHook = SetWindowsHookEx (WH_CBT, _MMCHookCBTProc, 
                                            GetModuleHandle(NULL), 
                                            GetCurrentThreadId());
            break;
    } 

    return i;
}


HRESULT STDAPICALLTYPE MMCPropPageCallback(void* vpsp)
{
    if (vpsp == NULL)
        return E_POINTER;

    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

    if ((void*)psp->pfnCallback == (void*)_MMCHookPropSheetPageProc)
        return E_UNEXPECTED;

    _MMCHookPropertyPage = psp->pfnCallback;
    psp->pfnCallback = _MMCHookPropSheetPageProc;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\lib\ndmgrpriv.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      ndmgrpriv.cpp
 *
 *  Contents:  Implementation file for the GUIDs defined in ndmgrpriv.h
 *             Started out from the old ndmgr_i.c file.
 *
 *  History:   5-Dec-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"{
#endif


#include <rpc.h>
#include <rpcndr.h>

//############################################################################
//############################################################################
//
//  Macro definitions
//
//############################################################################
//############################################################################


#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


//############################################################################
//############################################################################
//
//  GUID definitions
//
//############################################################################
//############################################################################

MIDL_DEFINE_GUID(IID, IID_IPropertySheetNotify,0xd700dd8e,0x2646,0x11d0,0xa2,0xa7,0x00,0xc0,0x4f,0xd9,0x09,0xdd);


MIDL_DEFINE_GUID(IID, IID_IFramePrivate,0xd71d1f2a,0x1ba2,0x11d0,0xa2,0x9b,0x00,0xc0,0x4f,0xd9,0x09,0xdd);


MIDL_DEFINE_GUID(IID, IID_IScopeDataPrivate,0x60BD2FE0,0xF7C5,0x11cf,0x8A,0xFD,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IImageListPrivate,0x7538C620,0x0083,0x11d0,0x8B,0x00,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IResultDataPrivate,0x1EBA2300,0x0854,0x11d0,0x8B,0x03,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IHeaderCtrlPrivate,0x0B384311,0x701B,0x4e8a,0xAE,0xC2,0xDA,0x63,0x21,0xE2,0x7A,0xD2);


MIDL_DEFINE_GUID(IID, IID_IScopeTree,0xd8dbf067,0x5fb2,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_IScopeTreeIter,0xd779f8d1,0x6057,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeCallback,0xb241fced,0x5fb3,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_IControlbarsCache,0x2e9fcd38,0xb9a0,0x11d0,0xa7,0x9d,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeType,0xB08A8368,0x967F,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeTypesCache,0xDE40436E,0x9671,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_IEnumNodeTypes,0xABBD61E6,0x9686,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_IDumpSnapins,0xA16496D0,0x1D2F,0x11d3,0xAE,0xB8,0x00,0xC0,0x4F,0x8E,0xCD,0x78);


MIDL_DEFINE_GUID(IID, IID_IPropertySheetProviderPrivate,0xFEF554F8,0xA55A,0x11D0,0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD);


MIDL_DEFINE_GUID(IID, IID_IMMCListView,0x1B3C1392,0xD68B,0x11CF,0x8C,0x2B,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_ITaskPadHost,0x4f7606d0,0x5568,0x11d1,0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a);


MIDL_DEFINE_GUID(IID, IID_IStringTablePrivate,0x461A6010,0x0F9E,0x11d2,0xA6,0xA1,0x00,0x00,0xF8,0x75,0xA9,0xCE);


MIDL_DEFINE_GUID(IID, IID_ITaskCallback,0x4b2293ba,0xe7ba,0x11d2,0x88,0x3c,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_ITaskView,0x9ff7a05c,0xe7b9,0x11d2,0x88,0x3c,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_ITitleView,0xdca68d28,0xeeb3,0x11d2,0x88,0x3e,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_IFolderTabView,0xf4d3c5a8,0x0314,0x11d3,0x88,0x59,0x00,0xc0,0x4f,0x72,0xc7,0x17);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\dllvars.h ===
//------------------------------------------------------------------------------
//
//  File: dllvars.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Global variables and functions for the parser DLL
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is used only by the framework.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef DLLVARS_H
#define DLLVARS_H


void IncrementClassCount();
void DecrementClassCount();

#ifdef __DLLENTRY_CPP
#define __DLLENTRY_EXTERN 
#else
#define __DLLENTRY_EXTERN extern
#endif

__DLLENTRY_EXTERN HMODULE g_hDll;
__DLLENTRY_EXTERN PUID g_puid;


#endif // DLLVARS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\clasfact.h ===
//------------------------------------------------------------------------------
//
//  File: classfact.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Declaration of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef CLASFACT_H
#define CLASFACT_H


class CLocImpClassFactory : public IClassFactory, public CLObject
{
public:
	CLocImpClassFactory();
	~CLocImpClassFactory();

#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext &) const;
#endif

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

private:
	UINT m_uiRefCount;
};

#endif // CLASFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\dllentry.cpp ===
//------------------------------------------------------------------------------
//
//  File: dllentry.cpp
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Defines the initialization routines for the DLL.
//
//  This file needs minor changes, as marked by TODO comments. However, the
//  functions herein are only called by the system, Espresso, or the framework,
//  and you should not need to look at them extensively.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "clasfact.h"
#include "impparse.h"

#define __DLLENTRY_CPP
#include "dllvars.h"

LONG g_lActiveClasses = 0;

static AFX_EXTENSION_MODULE parseDLL = { NULL, NULL };


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Main entry point for Win32 DLL. Returns 1, asserts, or throws an exception.
//------------------------------------------------------------------------------
extern "C" int APIENTRY
DllMain(
		HINSTANCE hInstance,	// Instance handle of this DLL.
		DWORD dwReason,			// Attaching or detaching.
		LPVOID lpReserved)		// Unused.
{
	UNREFERENCED_PARAMETER(lpReserved);

	if (DLL_PROCESS_ATTACH == dwReason)
	{
		LTTRACE("DLLNAME.DLL Initializing!\n");	// TODO: Change name.

		// Extension DLL one-time initialization.

		AfxInitExtensionModule(parseDLL, hInstance);

		// Insert this DLL into the resource chain.

		new CDynLinkLibrary(parseDLL);
		g_hDll = hInstance;
		g_puid.m_pid = CLocImpParser::m_pid;
		g_puid.m_pidParent = pidNone;

	}
	else if (DLL_PROCESS_DETACH == dwReason)
	{
		LTTRACE("DLLNAME.DLL Terminating!\n");	// TODO: Change name

		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...

		LTASSERT(DllCanUnloadNow() == S_OK);

		// Extension DLL shutdown.

		AfxTermExtensionModule(parseDLL);
	}

	// Return OK.

	return 1;
} // end of ::DllMain()


// TODO: Use GUIDGEN.EXE to replace this class ID with a unique one.
// GUIDGEN is supplied with MSDEV (VC++ 4.0) as part of the OLE support stuff.
// Run it and you'll get a little dialog box. Pick radio button 3, "static
// const struct GUID = {...}". Click on the "New GUID" button, then the "Copy"
// button, which puts the result in the clipboard. From there, you can just
// paste it into here. Just remember to change the type to CLSID!
static const CLSID ciImpParserCLSID =
{0x033EA178L, 0xC126, 0x11CE, {0x89, 0x49, 0x00, 0xAA, 0x00, 0xA3, 0xF5, 0x51}};

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to get the unique class ID of the parser interface.
//------------------------------------------------------------------------------
STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)	// Place to return parser interface class ID.
{
	ciParserCLSID = ciImpParserCLSID;

	return;
} // end of ::DllGetParserCLSID()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to register this parser. Calls base implementation in ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllRegisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	hr = RegisterParser(g_hDll);

	return ResultFromScode(hr);
} // end of ::DllRegisterParser()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to unregister this parser. Calls the base implementation in
//  ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllUnregisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	hr = UnregisterParser(CLocImpParser::m_pid, pidNone);

	return ResultFromScode(hr);
} // end of ::DllUnregisterParser()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to return the class factory interface.
//
//  Return values: some sort of result code
//				   ppClassFactory points to a CLocImpClassFactory object
//					on success
//------------------------------------------------------------------------------
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,	// Class ID for desired parser interfaces.
		REFIID iid,					// Desired parser interface.
		LPVOID *ppClassFactory)		// Return pointer to object with interface.
									//  Note that it's a hidden double pointer!
{
	LTASSERT(ppClassFactory != NULL);

	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciImpParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CLocImpClassFactory *pClassFactory;

			pClassFactory = new CLocImpClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMemExcep)
		{
			sc = E_OUTOFMEMORY;
			pMemExcep->Delete();
		}
	}

	return ResultFromScode(sc);
} // end of ::DllGetClassObject()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to query if the DLL can unload.
//------------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
	SCODE sc;

	sc = (0 == g_lActiveClasses) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
} // end of ::DllCanUnloadNow()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Global function used in the parser to increment the active class count.
//------------------------------------------------------------------------------
void
IncrementClassCount()
{
	InterlockedIncrement(&g_lActiveClasses);

	return;
} // end of ::IncrementClassCount()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Global function used in the parser to decrement the active class count.
//------------------------------------------------------------------------------
void
DecrementClassCount()
{
	LTASSERT(g_lActiveClasses != 0);

	InterlockedDecrement(&g_lActiveClasses);

	return;
} // end of ::DecrementClassCount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\clasfact.cpp ===
//------------------------------------------------------------------------------
//
//  File: classfact.cpp
//  Copyright (C) 1995-1997 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  Implementation of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//  Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"
#include "impparse.h"

#include "clasfact.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor for class factory implementation.
//------------------------------------------------------------------------------
CLocImpClassFactory::CLocImpClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();

	return;
} // end of CLocImpClassFactory::CLocImpClassFactory()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Destructor for class factory implementation.
//------------------------------------------------------------------------------
CLocImpClassFactory::~CLocImpClassFactory()
{
	LTASSERT(0 == m_uiRefCount);
	DEBUGONLY(AssertValid());

	DecrementClassCount();

	return;
} // end of CLocImpClassFactory::~CLocImpClassFactory()


#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert if object is not valid. Unfortunately, there really isn't anything
//  we can check.
//------------------------------------------------------------------------------
void
CLocImpClassFactory::AssertValid()
		const
{
	CLObject::AssertValid();

	return;
} // end of CLocImpClassFactory::AssertValid()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump all internal data to supplied dump context, for debugging purposes.
//------------------------------------------------------------------------------
void
CLocImpClassFactory::Dump(
		CDumpContext &dc)		// Context to dump to.
		const
{
	CLObject::Dump(dc);

	dc << "NET Parser CLocImpClassFactory:\n\r";
	dc << "\tm_uiRefCount: " << m_uiRefCount << "\n\r";

	return;
} // end of CLocImpClassFactory::Dump()

#endif // _DEBUG


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Increment reference count for object, return new value.
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::AddRef()
{
	return ++m_uiRefCount;
} // end of CLocImpClassFactory::AddRef()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrement reference count for object. If goes to 0, delete object. Return
//  new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::Release()
{
	LTASSERT(m_uiRefCount != 0);

	m_uiRefCount--;

	if (0 == m_uiRefCount)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
} // end of CLocImpClassFactory::Release()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query whether this object supports a given interface. If it does,
//  increment the reference count for this object.
//
//  Return values: some sort of result code
//				   *ppvObj will point to this object if it does support the
//					desired interface or be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::QueryInterface(
		REFIID iid,			// Type of interface desired.
		LPVOID *ppvObj)		// Return pointer to object with such interface.
							//  Note it's a hidden double pointer!
{
	LTASSERT(ppvObj != NULL);

	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;

	if (IID_IUnknown == iid)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (IID_IClassFactory == iid)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}

	if (S_OK == sc)
	{
		AddRef();
	}

	return ResultFromScode(sc);
} // end of CLocImpClassFactory::QueryInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create an instance of the requested class. All interfaces are implemented
//  by the CLocImpParser object.
//
//  Return values: some sort of result code
//				   ppvObj will point to a CLocImpParser object if it does
//					support the desired interface or be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,		// ???
		REFIID iid,				// Interface desired on parser object.
		LPVOID *ppvObj)			// Return pointer to object with interface.
								//  Note that it's a hidden double pointer!
{
	LTASSERT(ppvObj != NULL);

	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;

	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CLocImpParser *pParser;

			pParser = new CLocImpParser;

			sc = pParser->QueryInterface(iid, ppvObj);

			pParser->Release();
		}
		catch (CMemoryException *pMem)
		{
			sc = E_OUTOFMEMORY;
			pMem->Delete();
		}
		catch (...)
		{
		}
	}

	return ResultFromScode(sc);
} // end of CLocImpClassFactory::CreateInstance()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Not implemented. Always fails.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::LockServer(
		BOOL)		// Unused.
{
	return E_NOTIMPL;
} // end of CLocImpClassFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\impparse.cpp ===
//------------------------------------------------------------------------------
//
//  File: impparse.cpp
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Implementation of CLocImpParser, which provides the ILocParser interface
//  for the parser.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"
#include "impfile.h"
#include "impparse.h"


//
// Init statics
// TODO: get a ParserId in PARSERID.H for this new parser.
//

const ParserId CLocImpParser::m_pid = pidExchangeMNC;	// note: 100 is a bogus number

// Reference count the registering of options since these are global
// to the parser.
INT g_nOptionRegisterCount = 0;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor for CLocImpParser.
//------------------------------------------------------------------------------
CLocImpParser::CLocImpParser()
 : CPULocParser(g_hDll)
{
	LTTRACEPOINT("CLocImpParser constructor");
	m_fOptionInit = FALSE;
	IncrementClassCount();

	// TODO to add support for Binary objects, run this code
	// EnableInterface(IID_ILocBinary, TRUE);

} 


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor for CLocImpParser.
//------------------------------------------------------------------------------
CLocImpParser::~CLocImpParser()
{
	LTTRACEPOINT("CLocImpParser destructor");

	LTASSERTONLY(AssertValid());

	DecrementClassCount();

	// Remove any options
	UnRegisterOptions();
} // end of CLocImpParser::~CLocImpParser()


HRESULT 
CLocImpParser::OnInit(
	IUnknown *)
{
	LTASSERT(!m_fOptionInit);

	RegisterOptions();
	return ERROR_SUCCESS;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create the file instance for the given file type
//
//------------------------------------------------------------------------------
HRESULT 
CLocImpParser::OnCreateFileInstance(
	ILocFile * &pLocFile, 
	FileType ft)
{
	
	SCODE sc = E_INVALIDARG;
	
	pLocFile = NULL;

	switch (ft)
	{
	// TODO: This switch cases on the ft* constants supplied by you in
	// impfile.h. For each filetype, allocate an object of the correct
	// class to handle it and return a pointer to the object in pLocFile.
	// Most parsers user one class (CLocImpFile) which adjusts its behavior
	// according to the type.

	case ftUnknown:
	case ftMNCFileType:
	// Have to leave ftUnknown in because that is the type used until the
	// file has been parsed once successfully and the actual type is known.
		try
		{
			pLocFile = new CLocImpFile(NULL);
			sc = S_OK;
		}
		catch(CMemoryException *e)
		{
			sc = E_OUTOFMEMORY;
			e->Delete();
		}
		break;

	default:
	// Do nothing, sc falls through as E_INVALIDARG and the correct
	// result is returned.
		break;
	}
	
	return ResultFromScode(sc);
}	

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply the basic information about this parser.
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetParserInfo(
	ParserInfo &pi) 
	const
{
	pi.aParserIds.SetSize(1);
	pi.aParserIds[0].m_pid = m_pid;
	pi.aParserIds[0].m_pidParent = pidNone;
	pi.elExtensions.AddTail("msc");

	// TODO: Add the extentions for this parser's files to the
	// elExtensions list in pi, with lines of the form:
	//	pi.elExtensions.AddTail("TMP");

	// TODO: Update the IDS_IMP_PARSER_DESC resource string with
	// the description for this parser.	(For consistency with other
	// parsers, it should be 'FOO', not 'FOO parser', 'FOO format',
	// 'FOO files', etc.)
	LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
	LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_IMP_PARSER_DESC_HELP));

	return;
	
}	

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply descriptions for each file type supported
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetFileDescriptions(
	CEnumCallback &cb) 
	const
{
	EnumInfo eiFileInfo;
	CLString strDesc;

	eiFileInfo.szAbbreviation = NULL;

	// TODO: For each file type supported (the ft* constants you supplied in
	// impfile.h), return a string (loaded from a resource) describing it:
	//
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
	eiFileInfo.szDescription = (const TCHAR *)strDesc;
	eiFileInfo.ulValue = ftMNCFileType;
	cb.ProcessEnum(eiFileInfo);
	
}	



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply the version of this parser
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetParserVersion(
	DWORD &dwMajor,	
	DWORD &dwMinor, 
	BOOL &fDebug) 
	const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
	
}	


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Do any parser specific validation on the string
//
//------------------------------------------------------------------------------
CVC::ValidationCode 
CLocImpParser::OnValidateString(
	const CLocTypeId &ltiType,
	const CLocTranslation &lTrans, 
	CReporter *pReporter,
	const CContext &context)
{

	UNREFERENCED_PARAMETER(ltiType);
	UNREFERENCED_PARAMETER(lTrans);
	UNREFERENCED_PARAMETER(pReporter);
	UNREFERENCED_PARAMETER(context);

	// Edit time validation.
	// TODO if validation is done on strings this function and the Generate
	// functions should go through a common routine.

	return CVC::NoError;
		
}	

#define INCOMAPTIBLE_VERSION_TEXT _T("IncompatibleVersion")

BEGIN_LOC_UI_OPTIONS_BOOL(optCompatibleVersion)
    LOC_UI_OPTIONS_BOOL_ENTRY(INCOMAPTIBLE_VERSION_TEXT, TRUE, CLocUIOption::etCheckBox,
				IDS_INCOMPAT_PARSER, IDS_INCOMPAT_PARSER_HELP, NULL, 
				CLocUIOption::stOverride),

	END_LOC_UI_OPTIONS_BOOL();

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Register any options for the parser
//
//------------------------------------------------------------------------------
void
CLocImpParser::RegisterOptions()
{

	LTASSERT(g_nOptionRegisterCount >= 0);

	if (g_nOptionRegisterCount++ > 0)
	{
		// Already registered
        m_fOptionInit = true;
		return;
	}

	SmartRef<CLocUIOptionSet> spOptSet;
	CLocUIOptionImpHelper OptHelp(g_hDll);
	
	spOptSet = new CLocUIOptionSetDef;
	spOptSet->SetGroupName(g_puid.GetName());
	
	OptHelp.SetBools(optCompatibleVersion, COUNTOF(optCompatibleVersion));

	OptHelp.GetOptions(spOptSet.GetInterface(), IDS_PARSER_OPTIONS, IDS_PARSER_OPTIONS_HELP);

	m_fOptionInit = RegisterParserOptions(spOptSet.GetInterface());

	if (m_fOptionInit)
	{
		spOptSet.Extract();
	}
}

void
CLocImpParser::UnRegisterOptions()
{
	if (m_fOptionInit)
	{
		if (--g_nOptionRegisterCount == 0)
		{
			UnRegisterParserOptions(g_puid);		
		}
	}
}	

/***************************************************************************\
 *
 * METHOD:  IsConfiguredToUseBracesForStringTables
 *
 * PURPOSE: Reads option specifying how string table identifers should appear
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool - true == use braces
 *
\***************************************************************************/
bool IsConfiguredToUseBracesForStringTables()
{
    BOOL bIncompatibleVersion = GetParserOptionBool(g_puid, INCOMAPTIBLE_VERSION_TEXT);

    // true if compatible
    return !bIncompatibleVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\impfile.h ===
//------------------------------------------------------------------------------
//
//  File: impfile.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//  Declaration of CLocImpFile, which provides the ILocFile interface for
//  the parser
//
//  MAJOR IMPLEMENTATION FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef IMPFILE_H
#define IMPFILE_H


const FileType ftMNCFileType = ftUnknown + 1;

class CLocImpFile : public ILocFile, public CLObject
{
public:
	CLocImpFile(ILocParser *);

protected:
	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(const CFileSpec REFERENCE,
			CReporter REFERENCE);
	STDMETHOD_(FileType, GetFileType)() const;
	STDMETHOD_(void, GetFileTypeDescription)(CLString REFERENCE) const;
	STDMETHOD_(BOOL, GetAssociatedFiles)(CStringList REFERENCE) const;

	STDMETHOD_(BOOL, EnumerateFile)(CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE);
	STDMETHOD_(BOOL, GenerateFile)(const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE);

	//
	//  CLObect implementation
	//
#ifdef LTASSERT_ACTIVE
	void AssertValid() const;
#endif

private:
	IStream *	m_pstmTargetString;
	IStorage *	m_pstgTargetStringTable;
	IStorage *	m_pstgTargetParent;
	DWORD		m_dwCountOfStringTables;
	IStream *	m_pstmSourceString;
	IStorage *	m_pstgSourceStringTable;
	IStorage *	m_pstgSourceParent;
	DWORD m_dwCountOfStrings;
	CLSID m_clsidSnapIn;
	DWORD m_dwID,m_dwRefCount;

    bool                    m_bXMLBased;
    CComQIPtr<IXMLDOMNode>  m_spStringTablesNode;
    CComQIPtr<IXMLDOMNode>  m_spTargetStringTablesNode;

private:
	BOOL GenerateStrings(CLocItemHandler & ihItemHandler,CLocItemSet &isItemSet);
	BOOL OpenStream(BOOL fGenerating);
	BOOL AddItemToSet(CLocItemSet & isItemSet,const DBID &dbidNodeId,DWORD dwID,LPCSTR szTemp);
	BOOL ProcessStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId,BOOL fGenerating);
	BOOL ProcessXMLStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId,BOOL fGenerating);
	BOOL EnumerateStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId, BOOL fGenerating );
	BOOL CreateChildNode(CLocItemHandler & ihItemHandler,const DBID &dbidFileId, DBID & pNewParentId,const char *szNodeRes,const char *szNodeString);
	BOOL CreateParentNode(CLocItemHandler & ihItemHandler,const DBID &dbidFileId, DBID & pNewParentId,const char *szNodeRes,const char *szNodeString);
	//
	//  Private methods to prevent callers access.
	//
	~CLocImpFile();
	CLocImpFile();
	const CLocImpFile &operator=(const CLocImpFile &);

	//
	//  Private data for C.O.M. implementation
	//
	ILocParser *m_pParentClass;
	ULONG m_ulRefCount;

	//
	//  Framework data.
	//
	enum ImpFileError
	{
		ImpNoError,
		ImpSourceError,
		ImpTargetError,
		ImpEitherError,
		ImpNeitherError		// For errors which aren't really in files.
		// TODO: Add more error types here if you need them.
	};

	CPascalString m_pstrFileName;		// Filename of source file.
	DBID m_idFile;
	CPascalString m_pstrTargetFile;		// Filename of target file, set
										//  only when generating.
	CLFile *m_pOpenSourceFile;			// File object for source file.
	CLFile *m_pOpenTargetFile;			// File object for target file, set
										//  only when generating.

	CReporter *m_pReporter;		// Reporter object used to display messages.
								//  THIS POINTER IS VALID ONLY DURING CALLS TO
								//  OpenFile(), EnumerateFile(), GenerateFile(),
								//  and anything called from them. If it is
								//  not valid, it is guaranteed to be NULL.
	FileType m_FileType;		// Type (ft* constant above) for this file.

	CodePage m_cpSource;		// ANSI code page for source file.
	CodePage m_cpTarget;		// ANSI code page for target file, set
								//  only when generating.

	//
	//  Parser-specific data.
	//

	//
	//  Private implementation functions.
	//

	BOOL Verify();
	//
	// Handy utility functions. TODO: Except for ReportException(), they should
	// be removed if not used. Note ReportMessage() is used by other utility
	// functions.
	//

	void ReportException(CException *pException,	// DO NOT EVER REMOVE!
			ImpFileError WhichFile = ImpSourceError) const;
	void ReportMessage(MessageSeverity sev, UINT nMsgId,	// REMOVE CAREFULLY!
			ImpFileError WhichFile = ImpSourceError) const;
};

#endif // IMPFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\impfile.cpp ===
//------------------------------------------------------------------------------
//
//  File: impfile.cpp
//  Copyright (C) 1995-1997 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  Implementation of CLocImpFile, which provides the ILocFile interface for
//  the parser.
//
//  MAJOR IMPLEMENTATION FILE.
//
//  Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"

#include "impfile.h"
#include "impparse.h"
#include "xml_supp.h"

# define MAX_BUFFER		8192


// TODO: Format constants go here.


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Constructor for CLocImpFile.
//------------------------------------------------------------------------------
CLocImpFile::CLocImpFile(
		ILocParser *pParentClass)	// Pointer to parent class, normally NULL.
{
	//
	// C.O.M. initialization
	//

	m_pParentClass = pParentClass;
	m_ulRefCount = 0;

	//
	//  IMP file initialization
	//

	m_pOpenSourceFile = NULL;
	

	m_pReporter = NULL;
	
	m_FileType = ftMNCFileType;

	AddRef();
	IncrementClassCount();
	
	m_dwCountOfStringTables = 0;
	m_pstmSourceString = NULL;
	m_pstgSourceStringTable = NULL;
	m_pstgSourceParent = NULL;
	m_pstmTargetString = NULL;
	m_pstgTargetStringTable = NULL;
	m_pstgTargetParent = NULL;

    m_bXMLBased = false;

	// Format initialization.

	// TODO: initialize implementation member variables here.

	return;
} // end of CLocImpFile::CLocImpFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Destructor for CLocImpFile.
//------------------------------------------------------------------------------
CLocImpFile::~CLocImpFile()
{
	DEBUGONLY(AssertValid());

	if (m_pOpenSourceFile != NULL)
	{
		m_pOpenSourceFile->Close();
		delete m_pOpenSourceFile;
	}

	DecrementClassCount();

	// Format deinitialization.

	//  TODO: perform any implementation cleanup here.

	return;
} // end of CLocImpFile::~CLocImpFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Increment the object reference count. Return the new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpFile::AddRef()
{
	if (m_pParentClass != NULL)
	{
		m_pParentClass->AddRef();
	}

	return ++m_ulRefCount;
} // end of CLocImpFile::AddRef()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrement the object reference count. If it goes to 0, delete the object.
//  Return the new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpFile::Release()
{
	LTASSERT(m_ulRefCount != 0);

	if (m_pParentClass != NULL)
	{
		m_pParentClass->Release();
	}

	m_ulRefCount--;
	if (0 == m_ulRefCount)
	{
		delete this;
		return 0;
	}

	return m_ulRefCount;
} // end of CLocImpFile::Release()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query whether this object supports a given interface.
//
//  Return values: some kind of result code
//                 ppvObj will point to this object if it supports the desired
//                  interface, be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpFile::QueryInterface(
		REFIID iid,		// Desired interface.
		LPVOID *ppvObj) // Return pointer to object with interface.
						//  Note that it's a hidden double pointer.
{
	LTASSERT(ppvObj != NULL);

	if (m_pParentClass != NULL)
	{
		return m_pParentClass->QueryInterface(iid, ppvObj);
	}
	else
	{
		SCODE scRetVal = E_NOINTERFACE;

		*ppvObj = NULL;

		if (IID_IUnknown == iid)
		{
			*ppvObj = (IUnknown *)this;
			scRetVal = S_OK;
		}
		else if (IID_ILocFile == iid)
		{
			*ppvObj = (ILocFile *)this;
			scRetVal = S_OK;
		}

		if (S_OK == scRetVal)
		{
			AddRef();
		}
		return ResultFromScode(scRetVal);
	}
} // end of CLocImpFile::QueryInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Check object for validity. Asserts if not! (debug only)
//------------------------------------------------------------------------------
void
CLocImpFile::AssertValidInterface()
		const
{
	AssertValid();

	return;
} // end of CLocImpFile::AssertValidInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Open the file and make sure it is the correct type. Return TRUE if it is,
//  FALSE if not or on error.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::OpenFile(
		const CFileSpec &fsFileSpec,	// Name of file to open.
		CReporter &Reporter)			// Reporter object for messages.
{
	DEBUGONLY(fsFileSpec.AssertValid());
	DEBUGONLY(Reporter.AssertValid());

	const CPascalString &pstrFileName = fsFileSpec.GetFileName();
	BOOL fRetVal = FALSE;

	LTTRACEPOINT("OpenFile()");
	// Set reporter pointer for the duration of this function.
	m_pReporter = &Reporter;

	try
	{
		CFileException excFile;

		m_pstrFileName = pstrFileName;      // Initialize source filename.
		m_idFile = fsFileSpec.GetFileId();
		
		if (m_pOpenSourceFile != NULL)
		{
			// If source file pointer seems to be open already, close it.

			m_pOpenSourceFile->Close();
			delete m_pOpenSourceFile;
			m_pOpenSourceFile = NULL;
		}

		// Open the source file. Doesn't throw an exception if the open
		// fails, but does return FALSE and put the info in an exception
		// structure if you supply one.

		m_pOpenSourceFile = new CLFile;
		fRetVal = m_pOpenSourceFile->Open(m_pstrFileName,
				CFile::modeRead | CFile::shareDenyNone, &excFile);
		if (!fRetVal)
		{
			ReportException(&excFile);
			m_pOpenSourceFile->Abort();
			delete m_pOpenSourceFile;
			m_pOpenSourceFile = NULL;
			// fRetCode is already FALSE.
		}
		else
		{
			// Verify() assumes it is in a try/catch frame.

			fRetVal = Verify();
		}
	}
	catch(CException *e)
	{
		ReportException(e);
		delete m_pOpenSourceFile;
		m_pOpenSourceFile = NULL;
		fRetVal = FALSE;
		// m_pReporter will be NULLed by normal cleanup code below.
		e->Delete();
	}
	catch(...)
	{
		// Reset the reporter pointer, no idea if it will still be valid by
		// the time the destructor gets called. The only other thing that
		// needs to be cleaned up is the source file, which will be handled in
		// the destructor.

		m_pReporter = NULL;
		throw;
	}

	m_pReporter = NULL;

	return fRetVal;
} // end of CLocImpFile::OpenFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the file type (a ft* constant from impfile.h). If you only have one
//  file type, you can just return it directly.
//------------------------------------------------------------------------------
FileType
CLocImpFile::GetFileType()
		const
{
	return m_FileType;
} // end of CLocImpFile::GetFileType()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the file description in strDesc, according to the file type. If you
//  have only one file type, you can just return a string directly.
//------------------------------------------------------------------------------
void
CLocImpFile::GetFileTypeDescription(
		CLString &strDesc)	// Place to return file description string.
		const
{
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_IMP_FILE_DESC));
	return;
} // end of CLocImpFile::GetFileTypeDescription()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the names of any associated files as a list of strings in lstFiles.
//  Returns TRUE if there are any, FALSE if not.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::GetAssociatedFiles(
		CStringList &lstFiles)          // Return associated file names here.
		const
{
	DEBUGONLY(lstFiles.AssertValid());
	LTASSERT(lstFiles.GetCount() == 0);

	// TODO: If your files have associated files, put them in lstFiles here.
	UNREFERENCED_PARAMETER(lstFiles);

	return FALSE;
} // end of CLocImpFile::GetAssociatedFiles()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Enumerate all the localizable items in this file. Returns TRUE on success,
//  FALSE on error.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::EnumerateFile(
		CLocItemHandler &ihItemHandler, // Localizable-item handler and
										//  reporter object all in one!
		const CLocLangId &lid,          // Source language ID object.
		const DBID &dbidFileId)         // Database ID of file, used as parent
										//  for all top-level items in the
										//  file.
{
	DEBUGONLY(ihItemHandler.AssertValid());
	DEBUGONLY(lid.AssertValid());
	DEBUGONLY(dbidFileId.AssertValid());

	LTTRACEPOINT("EnumerateFile()");

	// Set reporter pointer for the duration of this function.
	m_pReporter = &ihItemHandler;

	if (NULL == m_pOpenSourceFile)
	{
		// Source file isn't open, whoops.

		LTASSERT(0 && "Source file isn't open in CLocImpFile::EnumerateFile()");
		return FALSE;
	}

	// Retrieve and store the ANSI code page value. Note that some types
	// of files use OEM code pages instead, or even use both. To get the
	// OEM code page, do GetCodePage(cpDos) instead.
	m_cpSource = lid.GetCodePage(cpAnsi);

	BOOL bRet = TRUE;

	try
	{
		bRet = EnumerateStrings(ihItemHandler,dbidFileId,FALSE);
	}
	catch(CException *e)
	{
		ReportException(e);
		bRet = FALSE;
		// m_pReporter will be NULLed by normal cleanup code below.
		e->Delete();
	}
	catch (...)
	{
		// Reset the reporter pointer, no idea if it will still be valid by
		// the time the destructor gets called. Reset the process pointer,
		// since it definitely won't be valid! The only other thing that
		// needs to be cleaned up is the source file, which will be handled in
		// the destructor.

		m_pReporter = NULL;
		throw;
	}

	m_pReporter = NULL;                 // Reset reporter pointer.

	return bRet;
} // end of CLocImpFile::EnumerateFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create a new target file be replacing resources in the source file with the 
//  localized items from Espresso.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::GenerateFile(
		const CPascalString &pstrTargetFile,// Name of target file.
		CLocItemHandler &ihItemHandler,     // Localizable-item handler and
											//  reporter object all in one!
		const CLocLangId &lidSource,        // Source language ID object.
		const CLocLangId &lidTarget,        // Target language ID object.
		const DBID &dbidParent)             // Database ID of file, used as
											//  parent for all top-level items
											//  in the file.
{
	DEBUGONLY(pstrTargetFile.AssertValid());
	DEBUGONLY(ihItemHandler.AssertValid());
	DEBUGONLY(lidSource.AssertValid());
	DEBUGONLY(lidTarget.AssertValid());
	DEBUGONLY(dbidParent.AssertValid());

	BOOL fRetVal = FALSE;

	// Set reporter pointer for the duration of this function.
	m_pReporter = &ihItemHandler;

	if (NULL == m_pOpenSourceFile)
	{
		// Source file isn't open, whoops.

		LTASSERT(0 && "Source file isn't open in CLocImpFile::GenerateFile()");
		return FALSE;
	}

	// Retrieve and store the ANSI code page values for the source and target
	// files. Note that some types of files use OEM code pages instead, or
	// even use both. To get the OEM code page, do GetCodePage(cpDos) instead.
	m_cpSource = lidSource.GetCodePage(cpAnsi);
	m_cpTarget = lidTarget.GetCodePage(cpAnsi);

	try
	{
		m_pstrTargetFile = pstrTargetFile;	// Initialize target filename.

		CFileStatus fsFileStatus;

		CLFile::CopyFile(m_pstrFileName,m_pstrTargetFile,FALSE);
		
		CLFile::GetStatus(m_pstrTargetFile, fsFileStatus);
		if(fsFileStatus.m_attribute & CFile::readOnly)
		{
			fsFileStatus.m_attribute &= ~CFile::readOnly; 
			CLFile::SetStatus(m_pstrTargetFile, fsFileStatus);
		}

		fRetVal = EnumerateStrings(ihItemHandler,dbidParent,TRUE);
		
	}
	catch(CException *e)
	{
		ReportException(e, ImpEitherError);
		fRetVal = FALSE;
		// m_pReporter will be NULLed by normal cleanup code.
		e->Delete();
	}
	catch(...)
	{
		// Generic exception handling is needed here because otherwise
		// target file will not be cleaned up. Also, no idea if reporter
		// pointer will still be valid by the time the destructor is
		// called. The process pointer definitely won't be valid, so reset
		// it too. The source file will be cleaned up by the destructor.

		m_pReporter = NULL;
		throw;
	}

	// Cleanup.

	if (!fRetVal)
	{
		try
		{
			// Nuke the target file if the generate failed.

			CLFile::Remove(pstrTargetFile);
		}
		catch(CException *e)
		{
			ReportException(e, ImpTargetError);
			// fRetVal is already FALSE
			// m_pReporter will be NULLed by normal cleanup code.
			e->Delete();
		}
		catch(...)
		{
			// Generic exception handling is needed here because otherwise
			// target file will not be cleaned up. Also, no idea if reporter
			// pointer will still be valid by the time the destructor is
			// called. The process pointer is already NULL. The source file
			// will be cleaned up by the destructor.

			m_pReporter = NULL;
			throw;
		}
	}

	// Normal cleanup code.

	m_pReporter = NULL;				// Reset reporter pointer.
	
	return fRetVal;
} // end of CLocImpFile::GenerateFile()


//------------------------------------------------------------------------------
//
//  TODO:
//  Verify that a file is a ???, as best we can. When we're reasonably sure,
//  set the reporter confidence level to high -- until then, messages will be
//  discarded, not displayed. This is also the place where m_FileType is set.
//
//  Returns TRUE if so, FALSE if not or on error, or throws an exception.
//
//  Normally there is need to catch exceptions in this function, they will
//  be caught and handled by a higher level. To avoid memory leaks, consider
//  using automatic variables or CByteArrays (as described and demonstrated in
//  the utility function FindSignature() below) instead of dynamic allocation.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::Verify()
{
	DEBUGONLY(AssertValid());
	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	// ...

	// Set confidence level to high and return that we recognize this file.

	m_pReporter->SetConfidenceLevel(CReporter::High);
	return TRUE;
} // end of CLocImpFile::Verify()


//------------------------------------------------------------------------------
//
//  Reports the exception described by *pException. Since the message can be
//  retrieved directly from the exception, there is no need (as far as reporting
//  goes) to catch or handle different kinds of exceptions separately. Normally,
//  there is no reason for your code to call this function, since under normal
//  circumstances you don't have to catch exceptions.
//
//  THIS FUNCTION IS USED BY THE FRAMEWORK! DO NOT REMOVE IT!
//------------------------------------------------------------------------------
void
CLocImpFile::ReportException(
		CException *pException, // Exception to be reported.
		ImpFileError WhichFile) // Defaults to ImpSourceError (most common).
		const
{
	const UINT MAX_MESSAGE = 256;

	CLString strContext;
	CLString strMessage;
	char *pszMessage;

	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	pszMessage = strMessage.GetBuffer(MAX_MESSAGE);
	LTASSERT(pszMessage != NULL);
	pException->GetErrorMessage(pszMessage, MAX_MESSAGE);
	strMessage.ReleaseBuffer();

	switch (WhichFile)
	{
	case ImpNeitherError:   // By convention, report errors not really in any
							//  file against the source file.
	case ImpSourceError:
		m_pstrFileName.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpTargetError:
		m_pstrTargetFile.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpEitherError:
		{
			CLString strSource, strTarget;

			m_pstrFileName.ConvertToCLString(strSource, CP_ACP);
			m_pstrTargetFile.ConvertToCLString(strTarget, CP_ACP);

			strContext.Format(g_hDll, IDS_IMP_OR, (const char *) strSource,
					(const char *) strTarget);
		}
		break;

	default:
		LTASSERT(0 && "WhichFile is bad during CLocImpFile::ReportException");
		break;
	}

	CContext ctx(strContext, m_idFile, otFile, vProjWindow);

	m_pReporter->IssueMessage(esError, ctx, strMessage);

	return;
} // end of CLocImpFile::ReportException()


//------------------------------------------------------------------------------
//
//  Reports a message to the user. Note that the message will be discarded
//  unless the reporter's confidence level had been set high (see Verify()).
//------------------------------------------------------------------------------
void
CLocImpFile::ReportMessage(
		MessageSeverity sev,    // Severity of message.
								//  (esError, esWarning, esNote)
		UINT nMsgId,                    // ID of string resource to load for message.
		ImpFileError WhichFile) // Defaults to ImpSourceError (most common).
		const
{
	CLString strContext;

	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	switch (WhichFile)
	{
	case ImpNeitherError:   // By convention, report errors not really in any
							//  file against the source file.
	case ImpSourceError:
		m_pstrFileName.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpTargetError:
		m_pstrTargetFile.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpEitherError:
		{
			CLString strSource, strTarget;

			m_pstrFileName.ConvertToCLString(strSource, CP_ACP);
			m_pstrTargetFile.ConvertToCLString(strTarget, CP_ACP);

			strContext.Format(g_hDll, IDS_IMP_OR, (const char *) strSource,
					(const char *) strTarget);
		}
		break;

	default:
		LTASSERT(0 && "WhichFile is bad during CLocImpFile::ReportMessage");
		break;
	}

	CContext ctx(strContext, m_idFile, otFile, vProjWindow);

	m_pReporter->IssueMessage(sev, ctx, g_hDll, nMsgId);

	return;
} // end of CLocImpFile::ReportMessage()


#ifdef LTASSERT_ACTIVE

//------------------------------------------------------------------------------
//
//  Asserts if the object is not valid. Any functions you add should probably
//  call this function (in DEBUGONLY()) first thing -- see Verify() and Enum().
//------------------------------------------------------------------------------
void
CLocImpFile::AssertValid()
		const
{
	// Check base class.

	CLObject::AssertValid();

	// Check C.O.M. data. m_pParentClass should always be NULL.
	// Correct range for m_ulRefCount is unknown, but make sure it hasn't
	// wrapped around by checking for less than 100 (if we ever exceed
	// 100 references from below, there's probably something wrong too!).

	LTASSERT(NULL == m_pParentClass);
	LTASSERT(m_ulRefCount < 100);

	// Check filename strings.

	m_pstrFileName.AssertValid();
	m_pstrTargetFile.AssertValid();

	// If the file object pointers are non-NULL, check the objects.

	if (m_pOpenSourceFile != NULL)
	{
		m_pOpenSourceFile->AssertValid();
	}
	// If the reporter pointer is non-NULL, check the object.

	if (m_pReporter != NULL)
	{
		m_pReporter->AssertValid();
	}

	// If the process object pointer is non-NULL, check the object.

	// Make sure m_FileType is one of the valid types.

	switch (m_FileType)
	{
	case ftMNCFileType:
	case ftUnknown:
	// TODO: add cases for all ft* constants in impfile.h here.
	//      case ftFoo1FileType:
	//      case ftFoo2FileType:
		// These are all OK. Do nothing.
		break;

	default:
		// This is bad!
		LTASSERT(0 && "m_FileType is bad during CLocImpFile::AssertValid()");
	}

	// Can't check code page values, they could be just about anything
	// and still valid.

	// TODO: check any checkable implementation member variables here.

	return;
} // end of CLocImpFile::AssertValid()


#endif // _DEBUG


//Creating a parent node
//ihItemHandler	-> Required to send item 
//dbidFileId	-> Id of the parent of node
//pNewParentId  -> New Id will be assigned can be used if this node has
//				   child
//szNodeRes		-> Res ID of the node 
//szNodeString	-> String of the node
//				<- Returns success or failure 

BOOL CLocImpFile::CreateParentNode(CLocItemHandler & ihItemHandler,
								   const DBID & dbidFileId, 
								   DBID & pNewParentId, 
								   const char * szNodeRes, 
								   const char * szNodeString) 
{
	BOOL fRetVal = TRUE;
	CLocItemSet isItemSet;
	
	CLocUniqueId uid;
	CPascalString pstrText,pstrId;
	try
	{
		CLocItem *pLocItem = new CLocItem();
	
		pstrId.SetString(szNodeRes,strlen(szNodeRes),m_cpSource);
		
		uid.GetResId().SetId(pstrId);
		
		pstrText.SetString(szNodeString,strlen(szNodeString),m_cpSource);
	
		uid.GetTypeId().SetId(pstrText);

		uid.SetParentId(dbidFileId);

		//set up pLocItem

		pLocItem->SetUniqueId(uid);

		pLocItem->SetFDisplayable(TRUE);
		pLocItem->SetFExpandable(TRUE);
		pLocItem->SetFNoResTable(TRUE);
		pLocItem->SetIconType(CIT::Expandable);
			
		//Add the node to Item set
		isItemSet.Add(pLocItem);		
		
		//Send node to espresso

		fRetVal  = ihItemHandler.HandleItemSet(isItemSet);
	
		// If OK, retrieve DBID.

		if (fRetVal)
		{
			pNewParentId.Clear();
			pNewParentId = pLocItem->GetMyDatabaseId();
		}
		isItemSet.ClearItemSet();
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;

}

//Creating a child node
//ihItemHandler	-> Required to send item 
//dbidFileId	-> Id of the parent of node
//pNewParentId  -> New Id to be use for items belonging to this child
//szNodeRes		-> Res ID of the node 
//szNodeString	-> String of the node
//				<- Returns success or failure 


BOOL CLocImpFile::CreateChildNode(CLocItemHandler & ihItemHandler,
								   const DBID & dbidFileId, 
								   DBID & pNewParentId, 
								   const char * szNodeRes, 
								   const char * szNodeString) 
{
	BOOL fRetVal = TRUE;
	CLocItemSet isItemSet;
	
	CLocUniqueId uid;
	CPascalString pstrText,pstrId;
	try
	{
		CLocItem *pLocItem = new CLocItem();
	
		pstrId.SetString(szNodeRes,strlen(szNodeRes),m_cpSource);

		pstrText.SetString(szNodeString,strlen(szNodeString),m_cpSource);
		
		uid.GetResId().SetId(pstrId);
					
		uid.GetTypeId().SetId(pstrText);
		
		uid.SetParentId(dbidFileId);

		//set up pLocItem

		pLocItem->SetUniqueId(uid);

		pLocItem->SetFDisplayable(TRUE);
		pLocItem->SetFExpandable(FALSE);
		pLocItem->SetFNoResTable(TRUE);
		pLocItem->SetIconType(CIT::String);
			
		//Add the node to Item set
		isItemSet.Add(pLocItem);		
		
		//Send node to espresso

		fRetVal  = ihItemHandler.HandleItemSet(isItemSet);
	
		// If OK, retrieve DBID.

		if (fRetVal)
		{
			pNewParentId.Clear();
			pNewParentId = pLocItem->GetMyDatabaseId();
		}
		isItemSet.ClearItemSet();
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;

}


BOOL CLocImpFile::EnumerateStrings(CLocItemHandler & ihItemHandler, 
								   const DBID & dbidFileId, 
								   BOOL fGenerating)
{
BOOL fRetVal = TRUE;

	try
	{
		fRetVal = OpenStream(FALSE);
		if(!fRetVal)
			goto exit_clean;

		if(fGenerating)
			fRetVal = OpenStream(TRUE);
		if(!fRetVal)
			goto exit_clean;

        if (m_bXMLBased)
		    fRetVal = ProcessXMLStrings(ihItemHandler,dbidFileId,fGenerating);
        else
		    fRetVal = ProcessStrings(ihItemHandler,dbidFileId,fGenerating);
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	
exit_clean:
	if(m_pstmSourceString)
		m_pstmSourceString->Release();
	if(m_pstgSourceStringTable)
		m_pstgSourceStringTable->Release();
	if(m_pstgSourceParent)
		m_pstgSourceParent->Release();
	if(fGenerating)
	{
		if(m_pstmTargetString)
			m_pstmTargetString->Release();
		if(m_pstgTargetStringTable)
			m_pstgTargetStringTable->Release();
		if(m_pstgTargetParent)
			m_pstgTargetParent->Release();
	}
	return fRetVal;
}

BOOL CLocImpFile::ProcessStrings(CLocItemHandler & ihItemHandler, 
								 const DBID & dbidFileId, 
								 BOOL fGenerating)
{
	DBID dbidParentId,dbidNodeId;
	BOOL fRetVal = TRUE;
    BOOL bUseBraces = ::IsConfiguredToUseBracesForStringTables();

	fRetVal = CreateParentNode(ihItemHandler,dbidFileId,dbidParentId,"String Table","String Table");
	for(DWORD i=0; i < m_dwCountOfStringTables;i++)
	{
		ULONG dwBytesRead;
		OLECHAR FAR* psz;
		char szTemp[MAX_BUFFER];
		CLocItemSet lsItemSet;
		int nLength = 0;

		dbidNodeId.Clear();
		m_pstmSourceString->Read(&m_clsidSnapIn,sizeof(CLSID),&dwBytesRead);
		StringFromCLSID(m_clsidSnapIn,&psz);
		wcstombs(szTemp,psz,MAX_BUFFER);
		nLength = strlen(szTemp);
		LTASSERT((szTemp[0] == '{') && (szTemp[nLength - 1] == '}'));

        // strip braces if configured so
        CString strGUID(szTemp);
        if ( !bUseBraces && strGUID[0] == _T('{') &&  strGUID[strGUID.GetLength() - 1] == _T('}'))
            strGUID = strGUID.Mid(1, strGUID.GetLength() - 2);

		fRetVal = CreateChildNode(ihItemHandler,dbidParentId,dbidNodeId,strGUID,strGUID);
		m_pstmSourceString->Read(&m_dwCountOfStrings,sizeof(DWORD),&dwBytesRead);
		if(fGenerating)
		{
			HRESULT hr;
			DWORD dwBytesWritten;
			hr = m_pstmTargetString->Write(&m_clsidSnapIn,sizeof(CLSID),&dwBytesWritten);
			hr = m_pstmTargetString->Write(&m_dwCountOfStrings,sizeof(DWORD),&dwBytesWritten);
		}
		for(DWORD j = 0;j < m_dwCountOfStrings;j++)
		{
			DWORD dwCharCount;
	
			m_pstmSourceString->Read(&m_dwID,sizeof(DWORD),&dwBytesRead);
			m_pstmSourceString->Read(&m_dwRefCount,sizeof(DWORD),&dwBytesRead);
			m_pstmSourceString->Read(&dwCharCount,sizeof(DWORD),&dwBytesRead);
			WCHAR *pString;
			pString = new WCHAR[dwCharCount + 1];
			m_pstmSourceString->Read(pString,dwCharCount * 2,&dwBytesRead);
			pString[dwCharCount] = L'\0';
			int nSize = WideCharToMultiByte(m_cpSource,0,pString,dwCharCount,szTemp,dwCharCount*2,NULL,NULL);
			szTemp[nSize] = '\0';
			AddItemToSet(lsItemSet,dbidNodeId,m_dwID,szTemp);
			delete []pString;
			if(!fGenerating)
				fRetVal = ihItemHandler.HandleItemSet(lsItemSet);
			else	
				fRetVal = GenerateStrings(ihItemHandler,lsItemSet);	
			lsItemSet.ClearItemSet();
		}
	}

	return fRetVal;
}

BOOL CLocImpFile::ProcessXMLStrings(CLocItemHandler & ihItemHandler, 
								 const DBID & dbidFileId, 
								 BOOL fGenerating)
{
	DBID dbidParentId,dbidNodeId;
	BOOL bOK = TRUE;
    BOOL bUseBraces = ::IsConfiguredToUseBracesForStringTables();

    // check if we have a table
    if (m_spStringTablesNode == NULL)
        return FALSE;

    // create node
	bOK = CreateParentNode(ihItemHandler, dbidFileId, dbidParentId, "String Table", "String Table");
    if (!bOK)
        return bOK;

    // read the strings from XML document
    CStringTableMap mapStringTables;
    HRESULT hr = ReadXMLStringTables(m_spStringTablesNode, mapStringTables);
    if (FAILED(hr))
        return FALSE;

    // iterate thru read data
    CStringTableMap::iterator it;
    for (it = mapStringTables.begin(); it != mapStringTables.end(); ++it)
    {
        std::wstring wstrGUID = it->first;
        const CStringMap& rStrings = it->second;

        dbidNodeId.Clear();

        // convert 2 ansi
        CString strGUID;
        wcstombs(strGUID.GetBuffer(wstrGUID.length()), wstrGUID.c_str(), wstrGUID.length());
        strGUID.ReleaseBuffer();

        // strip braces if configured so
        if ( !bUseBraces && strGUID[0] == _T('{') &&  strGUID[strGUID.GetLength() - 1] == _T('}'))
            strGUID = strGUID.Mid(1, strGUID.GetLength() - 2);

        bOK = CreateChildNode(ihItemHandler, dbidParentId, dbidNodeId, strGUID, strGUID);
        if (!bOK)
            return bOK;

        // handle the strings in map
        CStringMap::iterator its;
        for (its = rStrings.begin(); its != rStrings.end(); ++its)
        {
            DWORD dwID = its->first;
            std::wstring text = its->second;

            DWORD dwCharCount = text.length();
            CString strText;
            char *pBuffer = strText.GetBuffer(dwCharCount*2);
            if (pBuffer == NULL)
                return FALSE;
			int nSize = WideCharToMultiByte(m_cpSource, 0, text.c_str(), dwCharCount,
                                            pBuffer, dwCharCount*2, NULL, NULL);
			pBuffer[nSize] = '\0';
            strText.ReleaseBuffer();

            // use/update the string
            CLocItemSet lsItemSet;
			AddItemToSet(lsItemSet, dbidNodeId, dwID, strText);

			bOK = ihItemHandler.HandleItemSet(lsItemSet);
            if (!bOK)
                return bOK;

            if(fGenerating)
            {
				CLocItem *pLocItem = lsItemSet.GetAt(0);
                if (!pLocItem)
                    return FALSE;

                std::wstring strNewVal = pLocItem->GetLocString().GetString();
                hr = UpdateXMLString(m_spTargetStringTablesNode, wstrGUID, dwID, strNewVal);
                CString strMsg = strGUID;
                if (FAILED(hr))
                    return FALSE;
            }
			lsItemSet.ClearItemSet();

            if (!bOK)
                return bOK;
        }
    }

    // save XML document to the file
    if (fGenerating)
    {
        hr = SaveXMLContents(m_pstrTargetFile, m_spTargetStringTablesNode);
        if (FAILED(hr))
            return FALSE;
    }

	return TRUE;
}

BOOL CLocImpFile::AddItemToSet(CLocItemSet & isItemSet, 
							   const DBID &dbidNodeId,
							   DWORD dwID, 
							   LPCSTR szText)
{
	BOOL fRetVal = TRUE;
	CPascalString pstrText;
	CLocUniqueId uid;
	ULONG lItemType = 1;
	
	try
	{
		CLocItem * pNewItem = new CLocItem;
		pstrText.SetString(szText,strlen(szText),m_cpSource);
		uid.GetResId().SetId(dwID);
		uid.GetTypeId().SetId(lItemType);
		uid.SetParentId(dbidNodeId);

		pNewItem->SetUniqueId(uid);
				
		CLocString lsString;
	
		pNewItem->SetIconType(CIT::String);
		lsString.SetString(pstrText);
		
		pNewItem->SetFDevLock(FALSE);
		pNewItem->SetFUsrLock(FALSE);
		pNewItem->SetFExpandable(FALSE);
		pNewItem->SetFDisplayable(FALSE);
		pNewItem->SetFNoResTable(FALSE);
		lsString.SetCodePageType(cpAnsi);
		lsString.SetStringType(CST::Text);
		pNewItem->SetLocString(lsString);
		isItemSet.Add(pNewItem);
		fRetVal = TRUE;
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();	
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;
}

BOOL CLocImpFile::OpenStream(BOOL fGenerating)
{
BOOL fRetVal = TRUE;
HRESULT hr;
	


	if(!fGenerating)
	{
		hr = StgOpenStorage(m_pstrFileName,NULL,STGM_TRANSACTED | STGM_READ | STGM_SHARE_DENY_WRITE,NULL,0,&m_pstgSourceParent);
		if(!FAILED(hr))
		{
			CPascalString pstrStorage,pstrStream;
			pstrStorage.SetString("String Table",strlen("String Table"),cpAnsi);
			pstrStream.SetString("Strings",strlen("Strings"),cpAnsi);

			hr = m_pstgSourceParent->OpenStorage(pstrStorage,NULL,STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&m_pstgSourceStringTable);
			if(!FAILED(hr))
			{
				HRESULT hr = m_pstgSourceStringTable->OpenStream(pstrStream,0,STGM_READ | STGM_SHARE_EXCLUSIVE,0,&m_pstmSourceString);
				if(!FAILED(hr))
				{
					DWORD dwBytesRead;
					m_pstmSourceString->Read(&m_dwCountOfStringTables,sizeof(DWORD),&dwBytesRead);
				}
				else
					fRetVal = FALSE;
			}
			else
			{
				fRetVal = FALSE;
			}
		}
		else
		{
            // try to open this as XML document
            m_spStringTablesNode.Release(); // release the old one (if such exist)
            hr = OpenXMLStringTable(m_pstrFileName, &m_spStringTablesNode);
            if (SUCCEEDED(hr))
                m_bXMLBased = true;

            if (FAILED(hr))
            {
			    CLString strMessage, strFilePath;

			    m_pstrFileName.ConvertToCLString(strFilePath, CP_ACP);
			    strMessage.Format(g_hDll, IDS_MSC_ERR_OPENSTORAGE, strFilePath);
			    LTASSERT(m_pReporter != NULL);
			    m_pReporter->IssueMessage(esError, CLString(g_hDll, IDS_MNC_GENERIC_LOCATION),strMessage);

			    fRetVal = FALSE;
            }
		}
	}
	else if (!m_bXMLBased)
	{	
		hr = StgOpenStorage(m_pstrTargetFile,NULL,STGM_READWRITE | STGM_SHARE_EXCLUSIVE,NULL,0,&m_pstgTargetParent);
		if(!FAILED(hr))
		{
			CPascalString pstrStorage,pstrStream;
			pstrStorage.SetString("String Table",strlen("String Table"),cpAnsi);
			pstrStream.SetString("Strings",strlen("Strings"),cpAnsi);

			hr = m_pstgTargetParent->OpenStorage(pstrStorage,NULL,STGM_READWRITE | STGM_SHARE_EXCLUSIVE ,NULL,0,&m_pstgTargetStringTable);
			if(!FAILED(hr))
			{
				HRESULT hr = m_pstgTargetStringTable->CreateStream(pstrStream, STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,0,0,&m_pstmTargetString);
				if(!FAILED(hr))
				{
					DWORD dwBytesRead;
					hr = m_pstmTargetString->Write(&m_dwCountOfStringTables,sizeof(DWORD),&dwBytesRead);
				}
				else
					fRetVal = FALSE;
			}
			else
				fRetVal = FALSE;
		}
		else
  			fRetVal = FALSE;
	}
    else
    {
        // try to open this as XML document
        m_spTargetStringTablesNode.Release(); // release the old one (if such exist)
        hr = OpenXMLStringTable(m_pstrTargetFile, &m_spTargetStringTablesNode);
        if (FAILED(hr))
    		fRetVal = FALSE;
    }
	return fRetVal;	
}

BOOL CLocImpFile::GenerateStrings(CLocItemHandler & ihItemHandler, 
								  CLocItemSet & isItemSet)
{
BOOL fRetVal = TRUE;
INT iNoOfElements = 0;
DWORD dwBytesWritten,dwCharCount;
WCHAR *pLocText;
HRESULT hr;

	try
	{
		if(ihItemHandler.HandleItemSet(isItemSet))
		{
			while(iNoOfElements < isItemSet.GetSize())
			{
				CLocItem *pLocItem;
				CPascalString pstrText;

				pLocItem = isItemSet.GetAt(iNoOfElements);

				hr = m_pstmTargetString->Write(&m_dwID,sizeof(DWORD),&dwBytesWritten);
				hr = m_pstmTargetString->Write(&m_dwRefCount,sizeof(DWORD),&dwBytesWritten);
				
				pstrText = pLocItem->GetLocString().GetString();
				dwCharCount = pstrText.GetStringLength();
				hr = m_pstmTargetString->Write(&dwCharCount,sizeof(DWORD),&dwBytesWritten);
				pLocText = pstrText.GetStringPointer();
				hr = m_pstmTargetString->Write(pLocText,dwCharCount * 2,&dwBytesWritten);
				pstrText.ReleaseStringPointer();
				iNoOfElements++;
			}
		}
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}

	return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\impparse.h ===
//------------------------------------------------------------------------------
//
//  File: impparse.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Declare CLocImpParser, which provides the ILocParser interface for
//  the parser.
//
//	THIS FILE SHOULD NEED ONLY MINOR CHANGES.
//
//	Owner:
//
//------------------------------------------------------------------------------

#pragma once

class CLocImpParser: public CPULocParser
{
public:
	CLocImpParser();
	~CLocImpParser();

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType);
	virtual void OnGetParserInfo(ParserInfo &) const;
	virtual void OnGetFileDescriptions(CEnumCallback &) const;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor, BOOL &fDebug) const;

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context);


	static const ParserId m_pid;

private:
	void RegisterOptions();
	void UnRegisterOptions();

	BOOL m_fOptionInit;

};

bool IsConfiguredToUseBracesForStringTables();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parser.rc
//
#define IDS_IMP_PARSER_DESC             12700
#define IDS_IMP_OR                      12701
#define IDS_IMP_MSG_SEND                12704
#define IDS_IMP_MSG_TOOLONG             12705
#define IDS_IMP_MSG_READERR             12706
#define IDS_IMP_PARSER_DESC_HELP        12709
#define IDS_IMP_FILE_DESC               12710
#define IDS_MNC_NO_MEMORY               12711
#define IDS_MNC_GENERIC_LOCATION        12712
#define IDS_MSC_ERR_OPENSTORAGE         12713
#define IDS_PARSER_OPTIONS              12714
#define IDS_PARSER_OPTIONS_HELP         12715
#define IDS_INCOMPAT_PARSER             12716
#define IDS_INCOMPAT_PARSER_HELP        12717

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\stdafx.h ===
//------------------------------------------------------------------------------
//
//  File: stdafx.h
//	Copyright (C) 1995=1996 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//	Include file for standard system include files, or project-specific
//	include files that are used frequently, but are changed infrequently
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.
#include <atlbase.h>
#include <map>
#include <string>

// to avoid: clstring.inl(233) : error C4552: '!=' : operator has no effect
#pragma warning (disable: 4552)

#include <parser.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\stdafx.cpp ===
//------------------------------------------------------------------------------
//
//  File: stdafx.cpp
//	Copyright (C) 1995=1996 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//	Source file that includes just the standard includes. 
//	stdafx.obj will contain the pre-compiled type information.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


// Add libs for the project.

#ifdef _DEBUG
#pragma comment(lib, "..\\..\\lib\\Debug\\esputil.lib") 
#pragma comment(lib, "..\\..\\lib\\Debug\\pbase.lib") 
#else
#pragma comment(lib, "..\\..\\lib\\Retail\\esputil.lib") 
#pragma comment(lib, "..\\..\\lib\\Retail\\pbase.lib") 
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Localization Parser DLL"
#define VER_INTERNALNAME_STR            "mmcparse.dll"
#define VER_ORIGINALFILENAME_STR        "mmcparse.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\procobj.inl ===
//------------------------------------------------------------------------------
//
//  File: procobj.inl
//	Copyright (C) 1994-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Inline implementations of CProcessObj and derived classes.
//
//  YOU SHOULD NOT NEED TO CHANGE THIS FILE. However, the CProcessObj family
//  is used extensively in a typical parser implementation. See procobj.h for
//  more information.
//
//	Owner:
//
//------------------------------------------------------------------------------


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return a localizable-item handler.
//------------------------------------------------------------------------------
inline CLocItemHandler &
CProcessObj::GetHandler()
{
	ASSERT_VALID(&m_handler);

	return m_handler;
} // end of CProcessObj::GetHandler()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get language ID object for source language.
//------------------------------------------------------------------------------
inline const CLocLangId &
CProcessObj::GetSrcLangID()
{
	return m_langIdSrc;
} // end of CProcessObj::GetSrcLangID()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get language ID object for target language (generating only).
//------------------------------------------------------------------------------
inline const CLocLangId &
CProcessObjGen::GetTgtLangID()
{
	return m_langIdTgt;
} // end of CProcessObjGen::GetTgtLangID()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\xml_supp.cpp ===
//------------------------------------------------------------------------------
//
//  File: xml_supp.cpp
//  Copyright (C) 1995-2000 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  implements helper functions for parsing XML document
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "xml_supp.h"

// include "strings.h" to get tag names and attribute names for XML elements in MSC file
#define INIT_MMC_BASE_STRINGS
#include "strings.h"
// note if you want to untie the project from MMC, copy the definitions for 
// the following strings from strings.h here:
/*
XML_TAG_MMC_CONSOLE_FILE;
XML_TAG_MMC_STRING_TABLE;
XML_TAG_STRING_TABLE_MAP;
XML_TAG_STRING_TABLE;
XML_TAG_VALUE_GUID;
XML_TAG_STRING_TABLE_STRING;
XML_ATTR_STRING_TABLE_STR_ID;
*/

LPCSTR strXMLStringTablePath[] = {  XML_TAG_MMC_CONSOLE_FILE, 
                                        XML_TAG_MMC_STRING_TABLE, 
                                            XML_TAG_STRING_TABLE_MAP };


/***************************************************************************\
 *
 * METHOD:  LocateNextElementNode
 *
 * PURPOSE: locates sibling node of type ELEMENT
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode   [in] - node which sibling to locate
 *    IXMLDOMNode **ppNode [out] - sibling node
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
static HRESULT LocateNextElementNode(IXMLDOMNode *pNode, IXMLDOMNode **ppNode)
{
    // parameter check
    if (ppNode == NULL)
        return E_INVALIDARG;

    // init out parameter
    *ppNode = NULL;

    // check [in] parameter
    if (pNode == NULL)
        return E_INVALIDARG;

    // loop thru siblings
    CComPtr<IXMLDOMNode> spCurrNode = pNode;
    CComPtr<IXMLDOMNode> spResultNode;
    while (1)
    {
        // get sibling node
        HRESULT hr = spCurrNode->get_nextSibling(&spResultNode);
        if (FAILED(hr))
            return hr;

        // check the pointer
        if (spResultNode == NULL)
            return E_FAIL; // not found

        // done if it's ELEMENT node

        DOMNodeType elType = NODE_INVALID;
        spResultNode->get_nodeType(&elType);
        
        if (elType == NODE_ELEMENT)
        {
            *ppNode = spResultNode.Detach(); 
            return S_OK;
        }

        // get to the next one
        spCurrNode = spResultNode;
    }

    return E_UNEXPECTED;
}

/***************************************************************************\
 *
 * METHOD:  OpenXMLStringTable
 *
 * PURPOSE: Opens XML document and locates string table node in it
 *
 * PARAMETERS:
 *    LPCWSTR lpstrFileName             - [in] file to load document from
 *    IXMLDOMNode **ppStringTableNode   - [out] pointer to node containing string table
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT OpenXMLStringTable(LPCWSTR lpstrFileName, IXMLDOMNode **ppStringTableNode)
{
    // do parameter check
    if (lpstrFileName == NULL || ppStringTableNode == NULL)
        return E_INVALIDARG;

    // init return value
    *ppStringTableNode = NULL;

    // cocreate xml document
    CComQIPtr<IXMLDOMDocument> spDocument;
    HRESULT hr = spDocument.CoCreateInstance(CLSID_DOMDocument);
    if (FAILED(hr))
        return hr;

    // prevent re-formating
    spDocument->put_preserveWhiteSpace(VARIANT_TRUE);

    // load the file
    VARIANT_BOOL bOK = VARIANT_FALSE;
    hr = spDocument->load(CComVariant(lpstrFileName), &bOK);
    if (hr != S_OK || bOK != VARIANT_TRUE)
        return FAILED(hr) ? hr : E_FAIL;

    // the path represents element tags in similar to the file system manner
    // so 'c' from <a><b><c/></b></a> can be selected by "a/b/c"
    // construct the path
    std::string strPath;
    for (int i = 0; i< sizeof(strXMLStringTablePath)/sizeof(strXMLStringTablePath[0]); i++)
        strPath.append(i > 0 ? 1 : 0, '/' ).append(strXMLStringTablePath[i]);

    // locate required node
    hr = spDocument->selectSingleNode(CComBSTR(strPath.c_str()), ppStringTableNode);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  SaveXMLContents
 *
 * PURPOSE: Saves XML document to file
 *
 * PARAMETERS:
 *    LPCWSTR lpstrFileName         [in] - file to save to
 *    IXMLDOMNode *pStringTableNode [in] - pointer to <any> document's element
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT SaveXMLContents(LPCWSTR lpstrFileName, IXMLDOMNode *pStringTableNode)
{
    // do parameter check
    if (lpstrFileName == NULL || pStringTableNode == NULL)
        return E_INVALIDARG;

    // get the document
    CComQIPtr<IXMLDOMDocument> spDocument;
    HRESULT hr = pStringTableNode->get_ownerDocument(&spDocument);
    if (FAILED(hr))
        return hr;

    // save the file
    hr = spDocument->save(CComVariant(lpstrFileName));
    if (FAILED(hr))
        return hr;

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  GetXMLElementContents
 *
 * PURPOSE: retuns XML text elements' contents as BSTR
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode    [in] - node which contents is requested
 *    CComBSTR& bstrResult  [out] - resulting string
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT GetXMLElementContents(IXMLDOMNode *pNode, CComBSTR& bstrResult)
{
    // init result
    bstrResult.Empty();

    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    // locate required node
    CComQIPtr<IXMLDOMNode> spTextNode;
    HRESULT hr = pNode->selectSingleNode(CComBSTR(L"text()"), &spTextNode);
    if (FAILED(hr))
        return hr;

    // recheck the pointer
    if (spTextNode == NULL)
        return E_POINTER;

    // done
    return spTextNode->get_text(&bstrResult);
}

/***************************************************************************\
 *
 * METHOD:  ReadXMLStringTables
 *
 * PURPOSE: Reads string tables to std::map - based structure
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode            [in] - string table node
 *    CStringTableMap& mapResult    [out] - map containing string tables
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT ReadXMLStringTables(IXMLDOMNode *pNode, CStringTableMap& mapResult)
{
    mapResult.clear();

    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    // get the node list 
    CComQIPtr<IXMLDOMNodeList> spGUIDNodes;
    HRESULT hr = pNode->selectNodes(CComBSTR(XML_TAG_VALUE_GUID), &spGUIDNodes);
    if (FAILED(hr))
        return hr;

    // recheck the pointer
    if (spGUIDNodes == NULL)
        return E_POINTER;

    // get the item count
    long length = 0;
    hr = spGUIDNodes->get_length(&length);
    if (FAILED(hr))
        return hr;

    // read the items
    for (int n = 0; n < length; n++)
    {
        // get one node
        CComQIPtr<IXMLDOMNode> spGUIDNode;
        hr = spGUIDNodes->get_item(n, &spGUIDNode);
        if (FAILED(hr))
            return hr;
    
        // read the text
        CComBSTR bstrLastGUID;
        hr = GetXMLElementContents(spGUIDNode, bstrLastGUID);
        if (FAILED(hr))
            return hr;

        // Add the entry to the map;
        CStringMap& rMapStrings = mapResult[static_cast<LPOLESTR>(bstrLastGUID)];

        //get the strings node following the guid
        CComPtr<IXMLDOMNode> spStringsNode;
        hr = LocateNextElementNode(spGUIDNode, &spStringsNode);
        if (FAILED(hr))
            return hr;

        // recheck
        if (spStringsNode == NULL)
            return E_POINTER;

        // select strings for this guid
        CComQIPtr<IXMLDOMNodeList> spStringNodeList;
        HRESULT hr = spStringsNode->selectNodes(CComBSTR(XML_TAG_STRING_TABLE_STRING), &spStringNodeList);
        if (FAILED(hr))
            return hr;

        // recheck the pointer
        if (spStringNodeList == NULL)
            return E_POINTER;

        // count the strings
        long nStrCount = 0;
        hr = spStringNodeList->get_length(&nStrCount);
        if (FAILED(hr))
            return hr;

        // add all the strings to map
        CComQIPtr<IXMLDOMNode> spStringNode;
		for(int iStr = 0; iStr < nStrCount; iStr++)
		{
            // get n-th string
            spStringNode.Release();
            hr = spStringNodeList->get_item(iStr, &spStringNode);
            if (FAILED(hr))
                return hr;

            CComQIPtr<IXMLDOMElement> spElement = spStringNode;
            if (spElement == NULL)
                return E_UNEXPECTED;

            // get string id
            CComVariant val;
            hr = spElement->getAttribute(CComBSTR(XML_ATTR_STRING_TABLE_STR_ID), &val);
            if (FAILED(hr))
                continue;
            
            DWORD dwID = val.bstrVal ? wcstoul(val.bstrVal, NULL, 10) : 0;

            // get string text
            CComBSTR bstrText;
            hr = GetXMLElementContents(spStringNode, bstrText);
            if (FAILED(hr))
                return hr;

            // add to the map
            rMapStrings[dwID] = bstrText;
		}
    }

	return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  UpdateXMLString
 *
 * PURPOSE: Updates string in string table
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode            [in] - string tables
 *    const std::wstring& strGUID   [in] - GUID of string table
 *    DWORD ID                      [in] - id of string
 *    const std::wstring& strNewVal [in] - new value for string
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT UpdateXMLString(IXMLDOMNode *pNode, const std::wstring& strGUID, DWORD ID, const std::wstring& strNewVal)
{
    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    USES_CONVERSION;
    // locate the GUID node
    std::wstring strTagGUID(T2CW(XML_TAG_VALUE_GUID)); 
    std::wstring strGUIDPattern( strTagGUID + L"[text() = \"" + strGUID + L"\"]" ); 

    CComQIPtr<IXMLDOMNode> spGUIDNode;
    HRESULT hr = pNode->selectSingleNode(CComBSTR(strGUIDPattern.c_str()), &spGUIDNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spGUIDNode == NULL)
        return E_POINTER;

    //get the strings node following the guid
    CComPtr<IXMLDOMNode> spStringsNode;
    hr = LocateNextElementNode(spGUIDNode, &spStringsNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spStringsNode == NULL)
        return E_POINTER;

    // locate the string node by ID (actually its text node)
    CString strPattern;
    strPattern.Format("%s[@%s = %d]/text()", XML_TAG_STRING_TABLE_STRING, 
                                            XML_ATTR_STRING_TABLE_STR_ID, ID);

    CComQIPtr<IXMLDOMNode> spTextNode;
    hr = spStringsNode->selectSingleNode(CComBSTR(strPattern), &spTextNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spTextNode == NULL)
        return E_POINTER;

    // set the contents
    hr = spTextNode->put_text(CComBSTR(strNewVal.c_str()));
    if (FAILED(hr))
        return hr;
        
    return S_OK; // done
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\xml_supp.h ===
//------------------------------------------------------------------------------
//
//  File: xml_supp.h
//  Copyright (C) 1995-2000 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  defines helper functions for parsing XML document
//
//------------------------------------------------------------------------------


typedef std::map<int, std::wstring> CStringMap;
typedef std::map<std::wstring, CStringMap> CStringTableMap;

HRESULT OpenXMLStringTable(LPCWSTR lpstrFileName, IXMLDOMNode **ppStringTableNode);
HRESULT SaveXMLContents(LPCWSTR lpstrFileName, IXMLDOMNode *pStringTableNode);
HRESULT GetXMLElementContents(IXMLDOMNode *pNode, CComBSTR& bstrResult);
HRESULT ReadXMLStringTables(IXMLDOMNode *pNode, CStringTableMap& mapResult);
HRESULT UpdateXMLString(IXMLDOMNode *pNode, const std::wstring& strGUID, DWORD ID, 
                        const std::wstring& strNewVal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil.h ===
//-----------------------------------------------------------------------------
//  
//  File: esputil.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Common classes for Espresso
//  
//  
//-----------------------------------------------------------------------------

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\helpids.h ===
//-----------------------------------------------------------------------------
//  
//  File: helpids.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//  DON'T USE MATH -  the Help compiler isnt very good...
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\loctypes.h ===
//-----------------------------------------------------------------------------
//  
//  File: loctypes.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
//-----------------------------------------------------------------------------
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is just a redirector to the 'real' MITUTIL.H.
//  
//-----------------------------------------------------------------------------

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: locutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parseman.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseman.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parser.h ===
//-----------------------------------------------------------------------------
//  
//  File: parser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  
//-----------------------------------------------------------------------------

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\pbase.h ===
//-----------------------------------------------------------------------------
//  
//  File: pbase.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Parser base classes.  Parsers should really be using parsers.h
//  
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: parsutil.h|inc
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\precenum.h ===
#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\puser.h ===
//-----------------------------------------------------------------------------
//  
//  File: puser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
//-----------------------------------------------------------------------------
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\parserid.h ===
//-----------------------------------------------------------------------------
//
// File: parserid.h
// Copyright (c) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// See 'parserid.txt' in the Parsers directory for a description of these
// constants.
//
//-----------------------------------------------------------------------------
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;
const ParserId pidWMI = 97;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: binary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\clfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
//-----------------------------------------------------------------------------
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\context.h ===
//-----------------------------------------------------------------------------
//  
//  File: context.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\binary.inl ===
//-----------------------------------------------------------------------------
//  
//  File: binary.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Required inline functions for generating binary info template classes.
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\clfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\context.inl ===
//-----------------------------------------------------------------------------
//  
//  File: context.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\dbid.h ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference		// icon for reference glossary
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\dbid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\filespec.h ===
//-----------------------------------------------------------------------------
//  
//  File: filespec.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\itemhand.h ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
//-----------------------------------------------------------------------------
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globalid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\itemhand.inl ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\location.h ===
//-----------------------------------------------------------------------------
//  
//  File: location.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

private:
	NOTHROW void AssignFrom(const CLocation &);
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\locitem.h ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class LTAPIENTRY CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\lunknown.h ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\location.inl ===
//-----------------------------------------------------------------------------
//  
//  File: location.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\locitem.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\puid.h ===
//-----------------------------------------------------------------------------
//  
//  File: puid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\lunknown.inl ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\puid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: puid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resid.h ===
//-----------------------------------------------------------------------------
//  
//  File: resid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4663 )
#pragma warning(disable : 4665 )

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#pragma warning(disable : 4664 )
#include <afxtempl.h>

#include <mitutil.h>
#include <locutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#define IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\typeid.h ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\softinfo.h ===
//******************************************************************************
//
// SoftInfo.h: Software Utility classes
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and
	// mess people up.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\uniqid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
//-----------------------------------------------------------------------------
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\typeid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\uniqid.h ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  What we use to uniquely identify a localizable item.
//  
//-----------------------------------------------------------------------------
 

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: _globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: _goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_importo.h ===
//-----------------------------------------------------------------------------
//  
//  File: importo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class for Import Data Options
//
//  Owner: KenWal
//
//  Code Review Status: Not Reviewed
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_wtrmark.h ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\cancel.h ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_wtrmark.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\dbhelp.h ===
//******************************************************************************
//
//  DbHelp.h:  LocStudio LocUtil
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\dcsgrid.h ===
//------------------------------------------------------------------------------
//
// File: DcsGrid.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//------------------------------------------------------------------------------
 
#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_var.h ===
//-----------------------------------------------------------------------------
//  
//  File: var.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\enumplatform.h ===
//******************************************************************************
//
// EnumPlatform.h: Common enum Platform definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\extlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: extlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of an extension list.  Used by the parsers to tell the caller
//  what the parser is will to handle.
//  
//-----------------------------------------------------------------------------
 
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espstate.h ===
//-----------------------------------------------------------------------------
//  
//  File: espstate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\enumstringtype.h ===
//******************************************************************************
//
// EnumStringType.h: Common enum String Type definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fielddef.h ===
//******************************************************************************
//  
//  FieldDef.h:	Common Column Definitions
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************
 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fieldval.h ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\flddeflist.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddeflist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fileexcldlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileExclDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\filedlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
 
#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fieldval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\flddefhelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddefhelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\gotohelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: gotohelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locobj.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	COSPlatform();
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locpct.h ===
//-----------------------------------------------------------------------------
//  
//  File: LOCPCT.H
//  
//  Declarations for CLocPercentFrame and CLocPercentHelper
//
//  Author:  kenwal
//
//  Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\logfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
//  
//-----------------------------------------------------------------------------
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\logfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\operator.h ===
//-----------------------------------------------------------------------------
//  
//  File: operator.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\lstime.h ===
//-----------------------------------------------------------------------------
//  
//  File: lstime.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\passtrmerge.h ===
//-----------------------------------------------------------------------------
//
// File: PasStrMerge.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// Declaration of a class which handles the merge of two Pascal strings.
//
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\product.h ===
//-----------------------------------------------------------------------------
//  
//  File: product.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\report.h ===
//-----------------------------------------------------------------------------
//  
//  File: report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 


enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\showwarnings.h ===
//-----------------------------------------------------------------------------
//  
//  File: ShowWarnings.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\progress.inl ===
//-----------------------------------------------------------------------------
//  
//  File: progress.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h|locutil
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\schema.inl ===
//-----------------------------------------------------------------------------
//  
//  File: schema.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\schema.h ===
//-----------------------------------------------------------------------------
//  
//  File: schema.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\stringhelp.h ===
//******************************************************************************
//
// StringHelp.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------
//
// File: _cancel.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\warndlg.h ===
//******************************************************************************
//  
//  File: WarnDlg.H
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: _extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Classes to support the new Espresso Extensions interfaces.
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_optvalstore.h ===
//-----------------------------------------------------------------------------
//  
//  File: _optvalstore.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_pumpidle.h ===
//-----------------------------------------------------------------------------
//  
//  File: pumpidle.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: _progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_report.h ===
//-----------------------------------------------------------------------------
//  
//  File: _report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _report.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_username.h ===
//-----------------------------------------------------------------------------
//  
//  File: username.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitui.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitui.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mittl.h ===
//******************************************************************************
//
// MitTL.h: MIT Template Library
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitctrl.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitctrl.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitdiff.h ===
//------------------------------------------------------------------------------
//  
//  mitdiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\premidlenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\profile.h ===
//-----------------------------------------------------------------------------
//  
//  File: profile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  LocStudio  profile marks
//
//-----------------------------------------------------------------------------

#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\precenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\blobfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\clstring.h ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\blobfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\counter.h ===
//-----------------------------------------------------------------------------
//  
//  File: counter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\cowblob.h ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Copy-On-Write (COW) blob class.  Hold binary information, but only copies
//  the data when it's written to.
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 
#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\clstring.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
	LTVERIFY(strFormat.LoadString(hResourceModule, nFormatID) != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\cowblob.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for CLocCOWBlob.  This file should only be used by
//  cowblob.h
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\diff.h ===
//-----------------------------------------------------------------------------
//  
//  File: diff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the following classes needed for string differencing:
//	CDifference, CDelta, CDeltaVisitor, CDiffAlgorithm, CDiffAlgortihmFactory,
//	CDiffEngine  
//-----------------------------------------------------------------------------
 
#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\diff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: diff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\dllvars.h ===
//-----------------------------------------------------------------------------
//  
//  File: dllvars.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\edithelp.h ===
//******************************************************************************
//  
//  EditHelp.h
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\gnudiffalg.h ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CGNUDiffAlgorithm, CGNUDiffAlgFact
//-----------------------------------------------------------------------------
 
#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\flushmem.h ===
//-----------------------------------------------------------------------------
//  
//  File: flushmem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\espnls.h ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Language support functions for Espresso.
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\espnls.inl ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the language id object.  This file should ONLY be
//  included by espnls.h
//  
//-----------------------------------------------------------------------------
 

inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\imagehelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: imagehelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This file is a re-director for IMAGEHLP.DLL.  Rather than linking directly
//  with the DLL (which may not exist on Win 95 systems), this class will
//  dynamically load IMAGEHLP.DLL and then provide certain functions from it.
//  The functions currently available are those that I found immediately
//  useful, so this is not a complete list of IMAGEHLP functionality.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\gnudiffalg.inl ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline implementation of CDumbDiffAlgorithm, CDumbDiffAlgFact
//-----------------------------------------------------------------------------
 
inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\listdelta.h ===
//-----------------------------------------------------------------------------
//  
//  File: listdelta.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CListDelta
//-----------------------------------------------------------------------------
 
#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\loadlib.h ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class to manage LoadLibray/FreeLibary style DLL usage.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locid.h ===
//-----------------------------------------------------------------------------
//  
//  File: locid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\loadlib.inl ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\ltimalloc.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltimalloc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\macros.h ===
//-----------------------------------------------------------------------------
//  
//  File: macros.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\ltdebug.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltdebug.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
//-----------------------------------------------------------------------------
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locvar.h ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CLocVariant, our variant class.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locvar.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
//-----------------------------------------------------------------------------
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\mitenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optionval.h ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optvalset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optionval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optvalset.h ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\passtr.h ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
//-----------------------------------------------------------------------------
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\redvisit.h ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CRichEditDeltaVisitor
//-----------------------------------------------------------------------------
 
#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\refcount.h ===
//-----------------------------------------------------------------------------
//  
//  File: refcount.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULON