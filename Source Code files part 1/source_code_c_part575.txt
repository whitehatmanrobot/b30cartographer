ata struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(DPSP_SPCALLBACKS);
    if(!bLoopBack){
		sd.dwReserved1 = pspNode->dwReserved1;
		sd.dwReserved2 = pspNode->dwReserved2;
	}	
 	sd.lpszName = pspNode->lpszName;
	sd.lpGuid = &(pspNode->guid);
	sd.lpISP = (IDirectPlaySP *) pInt;
	
	sd.lpAddress = lpAddress;
	sd.dwAddressSize = dwAddressSize;

	hr = spinit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("could not start up service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// reset size of callback structure in case SP changed it
	this->pcbSPCallbacks->dwSize = sizeof(DPSP_SPCALLBACKS);

	hr = VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("invalid callbacks from service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// check that SP version makes sense
	if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) < DPSP_DX3VERSION)
	{
    	DPF_ERR("incompatible version returned from service provider!");
		// the init did succeed, try to call shutdown
	    if (sd.lpCB->Shutdown)  
	    {
			// dx3 and earlier sp's had a VOID arg list for shutdown
	    	hr = CALLSPVOID( sd.lpCB->Shutdown );
	    }
		else 
		{
			// shutdown not required...
		}
	    
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		hr = DPERR_UNAVAILABLE;
        goto CLEANUP_AND_EXIT;
	}
	else if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) == DPSP_DX3VERSION) 
	{
		DPF(0,"loading DX3 service provider");
		this->dwFlags |= DPLAYI_DPLAY_DX3SP;
		gbDX3SP = TRUE; // set a .dll var indicating it's not safe to allow any more directplay objects
						// to be created
	}

	// a-josbor: remember the version number in case we need it later
	this->dwSPVersion = sd.dwSPVersion;
	
	// set the blob size
	this->dwSPHeaderSize = sd.dwSPHeaderSize;
	DPF(1,"setting sp's message data size to %d\n",this->dwSPHeaderSize);

	// store a pointer to our IDirectPlaySP
	this->pISP = (IDirectPlaySP *)pInt;

	hr = GetMaxMessageSize(this);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto CLEANUP_AND_EXIT;
    }


    // success
    return DP_OK;

CLEANUP_AND_EXIT:
    if (this->hSPModule)
    {
        if (!FreeLibrary(this->hSPModule))
        {
            ASSERT(FALSE);
			dwError = GetLastError();
			DPF_ERR("could not free sp module");
			DPF(0, "dwError = %d", dwError);
        }
		this->hSPModule = NULL;
    }
	
	if (pInt)
	{
		// release the idirectplaysp interface we alloc'ed above...	
		this->dwRefCnt++;	 // since sp is not really loaded, make sure we don't nuke this object
		ASSERT(this->dwRefCnt >= 3);
		DP_Release((LPDIRECTPLAY)pInt);
		this->dwRefCnt--;
	}
	
	// make sure we reset this flag if we failed.  we never would have gotten here if it had
	// been true b4 the call, so if it changed, it was on the failed load
	gbDX3SP = FALSE;
	
    return hr;
} // LoadSP


// called by our MS Golf app hack
// builds a tcp/ip broadcast address
HRESULT  GetTCPBroadcastAddress(IDirectPlay * piplay,LPDPADDRESS * ppAddress,LPDWORD pdwAddressSize)
{
	HRESULT hr;
	char * pszBroadcast="";
	DWORD dwBroadcastSize = sizeof(char);

	ASSERT(ppAddress);
	ASSERT(NULL == *ppAddress);
	ASSERT(pdwAddressSize);
	ASSERT(0 == *pdwAddressSize);
	
	// call once to get the size - note - it's ok to cast ipiplay here,
	// since create address only checks for valid this ptr...
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	ASSERT(DPERR_BUFFERTOOSMALL == hr);
	
	// alloc the size needed
	*ppAddress = DPMEM_ALLOC(*pdwAddressSize);
	if (!*ppAddress) return DPERR_OUTOFMEMORY;

	// call it again - this time we should get the real show!	
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	if (FAILED(hr))	ASSERT(FALSE);
	
	return hr;
	
} // GetTCPBroadcastAddress

// called by InternalCreate
HRESULT AllocMemoryPools(LPDPLAYI_DPLAY this)
{
	InitTablePool(this);
	this->lpPlayerMsgPool=NULL;
	this->lpSendParmsPool=NULL;
	this->lpMsgNodePool=NULL;
	if(InitContextTable(this)!=DP_OK){
		return DPERR_NOMEMORY;
	}
	this->lpPlayerMsgPool=FPM_Init(sizeof(GROUPHEADER),NULL,NULL,NULL);
	if(!this->lpPlayerMsgPool){
		return DPERR_NOMEMORY;
	}
	this->lpSendParmsPool=FPM_Init(sizeof(SENDPARMS),SendInitAlloc,SendInit,SendFini);
	if(!this->lpSendParmsPool){
		return DPERR_NOMEMORY;
	}
	this->lpMsgNodePool=FPM_Init(sizeof(MESSAGENODE),NULL,NULL,NULL);
	if(!this->lpMsgNodePool){
		return DPERR_NOMEMORY;
	}
	return DP_OK;
}

VOID FreeMemoryPools(LPDPLAYI_DPLAY this)
{
	if(this->lpPlayerMsgPool){
		this->lpPlayerMsgPool->Fini(this->lpPlayerMsgPool,FALSE);
	}
	if(this->lpSendParmsPool){
		this->lpSendParmsPool->Fini(this->lpSendParmsPool,FALSE);
	}
	if(this->lpMsgNodePool){
		this->lpMsgNodePool->Fini(this->lpMsgNodePool,FALSE);
	}
	FiniTablePool(this);
	FiniContextTable(this);
}

HRESULT InitReply(LPDPLAYI_DPLAY this)
{
	if(!(this->hReply = CreateEventA(NULL,FALSE,FALSE,NULL))){	// Auto-Reset, unsignalled event.
		return DPERR_OUTOFMEMORY;
	}
	
	InitializeCriticalSection(&this->ReplyCS);
	this->dwReplyCommand = 0;
	this->pReplyBuffer   = NULL;
	this->pvReplySPHeader= NULL;
	return DP_OK;	
}

VOID FiniReply(LPDPLAYI_DPLAY this)
{
	if(this->hReply){
		CloseHandle(this->hReply);
		this->hReply=0;
		DeleteCriticalSection(&this->ReplyCS);
	}
}

VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand)
{
	EnterCriticalSection(&this->ReplyCS);
	ASSERT(this->dwReplyCommand==0);
	this->dwReplyCommand=dwReplyCommand;
	ResetEvent(this->hReply);
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

VOID UnSetupForReply(LPDPLAYI_DPLAY this)
{
	EnterCriticalSection(&this->ReplyCS);
	this->dwReplyCommand=0;
	if(this->pReplyBuffer){
		FreeReplyBuffer(this->pReplyBuffer);
	}
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, DWORD *pcbReply, LPVOID *ppvSPHeader, DWORD dwTimeout)
{
	HRESULT hr;
	DWORD dwRet;

	EnterCriticalSection(&this->ReplyCS);
	if(!this->dwReplyCommand){
		// its just gonna timeout anyway, may as well be now.
		// this can happen because some error paths after calling 
		// SendCreateMessage don't bail properly.
		DPF(0,"ERROR: Called WaitForReply with NO REPLY TYPE SPECIFIED!\n");
		hr=DPERR_TIMEOUT;
		goto exit;
	}
	DPF(0,"WAITFORREPLY, Waiting for a x%x\n",this->dwReplyCommand);
	LeaveCriticalSection(&this->ReplyCS);

	dwRet=WaitForSingleObject(this->hReply, dwTimeout);
	
	EnterCriticalSection(&this->ReplyCS);
	
		if(this->pReplyBuffer){
			*ppReply=this->pReplyBuffer;
			*pcbReply=this->cbReplyBuffer;
			if(ppvSPHeader){
				*ppvSPHeader=this->pvReplySPHeader;
			}
			// got a reply
			hr=DP_OK;
			this->pReplyBuffer=NULL;
			this->pvReplySPHeader=NULL;
		} else {
			// didn't get a reply (timed out) or no memory for buffer
			DPF(0, "WaitForReply: timed out waiting for reply!\n");
			hr=DPERR_TIMEOUT;
			*ppReply=NULL;
		}
		this->dwReplyCommand=0;

exit:
	LeaveCriticalSection(&this->ReplyCS);
	
	return hr;
}

VOID FreeReplyBuffer(PCHAR pReplyBuffer)
{
	DPMEM_FREE(pReplyBuffer);
}

HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, PVOID pvSPHeader)
{
	HRESULT hr;
	EnterCriticalSection(&this->ReplyCS);

	// Normally we only allow one expected response, the only exception is we might get an
	// ADDFORWARDREPLY with error when waiting for a SUPERENUMPLAYERSREPLY, if there are more exceptions,
	// we can change the dwReplyCommand to a pointer to an array of things we are waiting for.
	// added another exception, when waiting for a SUPERENUMPLAYERREPLY x29, allow x3 (ENUMPLAYERSREPLY)
	// added another exception, when waiting for a ENUMPLAYERSREPLY x3, allow x24 (ADDFORWARDREPLY)
	if(
	   (dwReplyCommand==this->dwReplyCommand) || 
	   ((this->dwReplyCommand==DPSP_MSG_SUPERENUMPLAYERSREPLY) && 
	    ((dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY)||(dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY))
	   ) ||
	   ((this->dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY) &&
	   (dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY)
	   )
	  )
	{
		// winner
		ASSERT(!this->pReplyBuffer);
		DPF(5,"HANDLEREPLY: Got reply we wanted x%x\n",dwReplyCommand);
		this->pReplyBuffer=DPMEM_ALLOC(cbReplyBuffer+this->dwSPHeaderSize);
		if(this->pReplyBuffer){
			this->cbReplyBuffer=cbReplyBuffer; // need size for boundary checks for security.
			memcpy(this->pReplyBuffer,pReplyBuffer,cbReplyBuffer);
			if(pvSPHeader){
				this->pvReplySPHeader=this->pReplyBuffer+cbReplyBuffer;
				memcpy(this->pvReplySPHeader, pvSPHeader, this->dwSPHeaderSize);
			} else {
				this->pvReplySPHeader=NULL;
			}
		} else {
			DPF(0,"HandleReply couldn't allocate reply buffer, WaitForReply will think it timed out\n");
		}
		SetEvent(this->hReply);
		hr=DP_OK;
	} else {
		// bogus, don't want this reply
		DPF(0,"Rejecting Reply Command x%x I'm waiting for a x%x\n",dwReplyCommand,this->dwReplyCommand);
		hr=DPERR_NOTHANDLED;
	}
	LeaveCriticalSection(&this->ReplyCS);
	return hr;
}

// called by DirectPlayCreate,DirectPlayConnect
// pCallbacks is the vtbl we want to create w/
HRESULT InternalCreate(LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter,
	LPDPLCONNECTION lpConnect,LPVOID pCallbacks) 
{
    LPDPLAYI_DPLAY this=NULL;
	LPDPLAYI_DPLAY_INT pInt=NULL;
	HRESULT hr;
						
    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
    TRY
    {
    	if (lplpDP == NULL)
    	{
        	DPF_ERR("NULL pointer for receiving LPDIRECTPLAY!");
			return DPERR_INVALIDPARAMS;
    	}
    	
        *lplpDP = NULL;
        if (!VALID_READ_GUID_PTR(lpGUID))
        {
        	DPF_ERR("invalid guid!");
			return DPERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if (gbDX3SP)
	{
		DPF_ERR("DX3 Service Provider loaded - unable to create another DirectPlay object");
		return DPERR_ALREADYINITIALIZED;
	}

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif

    this = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY));
    if (!this) 
    {
    	DPF_ERR("out of memory");
        return E_OUTOFMEMORY;
    }

	this->dwSize = sizeof(DPLAYI_DPLAY);

	// set AppHack flags.
	hr=GetAppHacks(this);
	
	// allocate cached memory pools
	if(DP_OK != AllocMemoryPools(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

	// allocate support for handling replies.
	if(DP_OK != InitReply(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

    // alloc the callbacks
    this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(DPSP_SPCALLBACKS));
    if (!this->pcbSPCallbacks) 
    {
		DPF_ERR("could not create direct play - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
    }
	// stick our version in the table, so SP knows who they're dealing with
	this->pcbSPCallbacks->dwVersion = DPSP_MAJORVERSION;
	
	// get our aggregated lobby object
	hr = PRV_AllocateLobbyObject(this, &this->lpLobbyObject);
	if(FAILED(hr))
	{
		DPF(0,"could not create directplaylobby object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// get an idirectplay
	hr = GetInterface(this,&pInt,pCallbacks);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplay object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// are we loading a real SP, or were we called by our classfactory
	// in response to CoCreateInstance?
	if (IsEqualGUID(lpGUID,&GUID_NULL))
	{
		DPF(2,"InternalCreate - using class factory guid");
		this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
	}
	else 
	{
		// did they ask for the local_tcp sp?  ms golf shipped a private version of this, and, it's
		// broken. instead, use our winsock sp w/ a broadcast address - this works the same way (only
		// it's not broken:-)
		if (IsEqualGUID(lpGUID,&GUID_LOCAL_TCP))
		{
			LPDPADDRESS pAddress=NULL;
			DWORD dwAddressSize=0;

			// APP HACK for MSGOLF!
			DPF(0,"detected unsupported tcp/ip service provider - forcing to dpwsockx");
			if (lpConnect)
			{
				// they gave us an address - use it
				hr = LoadSP(this,(LPGUID)&GUID_TCP,lpConnect->lpAddress,lpConnect->dwAddressSize);						
			}
			else 
			{
				// they didn't pass a connection struct, go build a broadcast address
				hr = GetTCPBroadcastAddress((IDirectPlay *)pInt,&pAddress,&dwAddressSize);
				if (FAILED(hr))	ASSERT(FALSE);

				// if it failed, pvAddress is still NULL - winsock will pop a dialog. oh well.
				hr = LoadSP(this,(LPGUID)&GUID_TCP,pAddress,dwAddressSize);
				
				if (pAddress) DPMEM_FREE(pAddress);
			}
		}
		// go get the sp they asked for
		else if (lpConnect)
		{
			hr = LoadSP(this,lpGUID,lpConnect->lpAddress,lpConnect->dwAddressSize);			
		}
		else 
		{
			hr = LoadSP(this,lpGUID,NULL,0);			
		}

		if (FAILED(hr)) 
		{
			DPF(0,"could not create direct play - load sp failed! hr = 0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}
	}

	if(!(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)){

		hr=InitTimerWorkaround();
		
		if(FAILED(hr)){
			DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}

	}
	
	if(FAILED(hr)){
		DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	InitializeCriticalSection( &this->csNotify );

	// add this to the front of our dll object list
	this->pNextObject = gpObjectList;
	gpObjectList = this;
	gnObjects++;
	
	// init the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
		
	DPF(3,"InternalCreate :: created new dplay object.  %d objects outstanding",gnObjects);
	
    *lplpDP = (LPDIRECTPLAY)pInt;

    return DP_OK;

ERROR_INTERNALCREATE:

	if(this)
	{
		FiniReply(this);
		FreeMemoryPools(this);
		if(this->lpLobbyObject)
			PRV_DestroyDPLobby(this->lpLobbyObject);
		if(this->pcbSPCallbacks)
			DPMEM_FREE(this->pcbSPCallbacks);
		DPMEM_FREE(this);
	}

	if(pInt)
		DPMEM_FREE(pInt);

	return hr;

} // InternalCreate

HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter) 
{
	HRESULT hr;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayCreate)(lpGUID,lplpDP,pUnkOuter);
    }
#endif


	ENTER_DPLAY();
	
	hr = InternalCreate(lpGUID,lplpDP,pUnkOuter,NULL,&dpCallbacks);

	LEAVE_DPLAY();
	
	return hr;

}// DirectPlayCreate

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayEnumerate"

// See if a duplicate node exists
BOOL DoesDuplicateSPNodeWithDescriptionExist(LPGUID lpguid)
{
	LPSPNODE	pspNode = gSPNodes;

	while(pspNode)
	{
		// If the GUID's are equal and it had a description, return TRUE
		if(IsEqualGUID(&pspNode->guid, lpguid) &&
			(pspNode->dwNodeFlags & SPNODE_DESCRIPTION))
			return TRUE;
		   
		// Move to the next node
		pspNode = pspNode->pNextSPNode;
	}

	return FALSE;
}

void FreeSPNode(LPSPNODE pspNode)
{
	if(!pspNode)
		return;

	if(pspNode->lpszName)
		DPMEM_FREE(pspNode->lpszName);
	if(pspNode->lpszPath)
		DPMEM_FREE(pspNode->lpszPath);
	if(pspNode->lpszDescA)
		DPMEM_FREE(pspNode->lpszDescA);
	if(pspNode->lpszDescW)
		DPMEM_FREE(pspNode->lpszDescW);
	DPMEM_FREE(pspNode);
}

// Remove any duplicate SP Nodes from the list if they don't use a description
// string (workaround for pre-DX5.1 localization bug)
void RemoveDuplicateSPWithoutDescription(LPSPNODE pspNode)
{
	LPSPNODE	pspCurrent;
	LPSPNODE	pspPrev;
	LPSPNODE	pspNext;
	GUID		guid = pspNode->guid;
	

	// Move to the next node
	pspPrev = pspNode;
	pspCurrent = pspNode->pNextSPNode;

	// Walk the list
	while(pspCurrent)
	{
		// If the guids are equal and this node doesn't use a description string
		// then remove it from the list
		if((IsEqualGUID(&pspCurrent->guid, &guid)) &&
			(!(pspCurrent->dwNodeFlags & SPNODE_DESCRIPTION)))
		{
			// Remove it from the list and save the next pointer
			pspPrev->pNextSPNode = pspNext = pspCurrent->pNextSPNode;

			// free the current node
			FreeSPNode(pspCurrent);

			// Move to the next node
			pspCurrent = pspNext;
		}
		else
		{
			// Move to the next node
			pspPrev = pspCurrent;
			pspCurrent = pspCurrent->pNextSPNode;
		}
	}
}


// add a new node to the sp list
// called by GetKeyValues
HRESULT AddSPNode(LPWSTR lpszName,LPWSTR lpszGuid,LPWSTR lpszPath,DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwSPFlags, LPSTR lpszDescA, LPWSTR lpszDescW)
{
	LPSPNODE pspNode=NULL;
	int iStrLen; // string length, in bytes
	HRESULT hr=DP_OK;
	GUID guid;

	// First convert the guid
	hr = GUIDFromString(lpszGuid,&guid);
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPF_ERR("could not parse guid");
		return hr;
	}

	// If we aren't using the description, make sure an SP Node with the same
	// guid AND a valid description doesn't already in the list.  If it does,
	// we need to skip this node and not add it
	if(!(dwSPFlags & SPNODE_DESCRIPTION))
	{
		if(DoesDuplicateSPNodeWithDescriptionExist(&guid))
		{
			DPF(8, "Duplicate SP with a description exists, skipping node");
			return DP_OK;
		}
	}

	// alloc the spnode	
	pspNode = DPMEM_ALLOC(sizeof(SPNODE));
	if (!pspNode)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		return E_OUTOFMEMORY;
	}

	// alloc the strings
	iStrLen = WSTRLEN_BYTES(lpszName);
	pspNode->lpszName = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszName)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszName,lpszName,iStrLen);

	iStrLen = WSTRLEN_BYTES(lpszPath);
	pspNode->lpszPath = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszPath)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszPath,lpszPath,iStrLen);

	iStrLen = (lpszDescA ? lstrlenA(lpszDescA) : 0);
	if(iStrLen)
	{
		// Count the null terminator since lstrlen didn't
		iStrLen++;
		pspNode->lpszDescA = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescA)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescA,lpszDescA,iStrLen);

		iStrLen = WSTRLEN_BYTES(lpszDescW);
		pspNode->lpszDescW = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescW)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescW,lpszDescW,iStrLen);
	}

	pspNode->dwReserved1 = dwReserved1;
	pspNode->dwReserved2 = dwReserved2;

	// Save the guid
	memcpy(&(pspNode->guid),&guid,sizeof(guid));

	// Save the SP Node flags (internal flags)
	pspNode->dwNodeFlags = dwSPFlags;

	// add it to the (front of the) list
	pspNode->pNextSPNode = gSPNodes;
	gSPNodes= pspNode;

	// If this SP Node has a description, we need to walk the list and remove
	// any other SP nodes with the same GUID that DO NOT have a description.
	// This will get around our pre-DX5.1 problem of enumerating SP's twice
	// on localized versions of Win95 with US versions of games installed
	// NOTE: This function assumes the first node in the list is the one
	// we just added!!!!!
	if(dwSPFlags & SPNODE_DESCRIPTION)
		RemoveDuplicateSPWithoutDescription(pspNode);
	
	return DP_OK;

ERROR_EXIT:
	FreeSPNode(pspNode);
	return hr;

} // AddSPNode

/*
 ** GetKeyValue
 *
 *  CALLED BY: RegEnumerate
 *
 *  PARAMETERS:
 *		hKey - key above service provider
 *		lpszName - name of service provider key
 *
 *  DESCRIPTION: opens the service provider key, and reads
 *		sp data
 *
 *  RETURNS:  DP_OK or E_FAIL
 *
 */

HRESULT GetKeyValues(HKEY hKey,LPWSTR lpszName) 
{
	HKEY hKeySP;	
	LONG lErr;
	DWORD dwType;
	CHAR szDescA[DPLAY_REGISTRY_NAMELEN];
	WCHAR szDescW[DPLAY_REGISTRY_NAMELEN];
	WCHAR szPath[DPLAY_REGISTRY_NAMELEN];
	DWORD cchData = 0;
	WCHAR szGuid[GUID_STRING_SIZE]; // space for guid + {,-,-,}
	HRESULT hr;
	DWORD dwReserved1=0,dwReserved2=0; // for reading dwReserved1+2
	DWORD dwSPFlags = 0;

	// open the base key  
	lErr = OS_RegOpenKeyEx(hKey,lpszName,0,KEY_READ,&hKeySP);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// first see if the "Private" key exists.  If it does, then skip this SP
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Private"),NULL,&dwType,NULL,&cchData);
	if (ERROR_SUCCESS == lErr) 
	{
		// The key exists, so set the flag so we don't enumerate it
		dwSPFlags |= SPNODE_PRIVATE;
	}

	// path
	cchData = DPLAY_REGISTRY_NAMELEN * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Path"),NULL,&dwType,(LPBYTE)szPath,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read path err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got path = %ls\n",szPath);

	// guid
	cchData = GUID_STRING_SIZE * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Guid"),NULL,&dwType,(LPBYTE)szGuid,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read guid err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got guid = %ls\n",szGuid);

	// description A
	// NOTE: This value is always assumed to be an ANSI string, regardless of
	// which platform we are on.  On Win95, this is an ANSI (possibly multi-byte),
	// and on NT, although it is stored as Unicode, we always want to treat it
	// as an ANSI string
	cchData = sizeof(szDescA);
	lErr = RegQueryValueExA(hKeySP,"DescriptionA",NULL,&dwType,(LPBYTE)szDescA,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(5,"Could not read description err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	else
	{
		DPF(5,"got descriptionA = %s\n",szDescA);
		
		// Set our description flag
		dwSPFlags |= SPNODE_DESCRIPTION;

		// Now try to get the DescriptionW string if one exists.  If for some
		// reason a DescriptionW string exists, but the DescriptionA does not,
		// we pretend the DescriptionW string doesn't exist either.
		// NOTE: We always assume the DescriptionW string is a Unicode string,
		// even on Win95.  On Win95, this will be of the type REG_BINARY, but
		// it is really just a Unicode string.
		cchData = sizeof(szDescW);
		lErr = OS_RegQueryValueEx(hKeySP,TEXT("DescriptionW"),NULL,&dwType,(LPBYTE)szDescW,&cchData);
		if (ERROR_SUCCESS != lErr) 
		{
			DPF(5,"Could not get descriptionW, converting descriptionA");

			// We couldn't get descriptionW, so convert descriptionA...
			AnsiToWide(szDescW,szDescA,(lstrlenA(szDescA)+1));
		}
		else
		{
			DPF(5,"got descriptionW = %ls\n",szDescW);
		}

	}

	// reserved1
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved1"),NULL,&dwType,(LPBYTE)&dwReserved1,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved1 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved1 = %d\n",dwReserved1);

	// reserved2
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved2"),NULL,&dwType,(LPBYTE)&dwReserved2,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved2 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved2 = %d\n",dwReserved2);

	// If we have a description string, use it.  If not, use the key name
	hr = AddSPNode(lpszName,szGuid,szPath,dwReserved1,dwReserved2, dwSPFlags,
					szDescA, szDescW);

ERROR_EXIT:
	RegCloseKey(hKeySP);

	return hr;

} // GetKeyValues

// enumerate through the service providers stored under directplay in the
// registry
// read the data stored in the registry, and add it to our list of spnodes
HRESULT RegEnumerate() 
{
	LONG lErr;
	HKEY hKey;
	DWORD dwSubkey=0;
	WCHAR lpszName[DPLAY_REGISTRY_NAMELEN];
	DWORD cchName;
	HRESULT hr;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_PATH,0,KEY_READ,
				&hKey);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// enumerate subkeys
	do
	{
		// find an sp
		cchName= DPLAY_REGISTRY_NAMELEN;
		lErr = OS_RegEnumKeyEx(hKey,dwSubkey,lpszName,&cchName,
				NULL,NULL,0,NULL);
		
		if (ERROR_SUCCESS == lErr)
		{
			hr = GetKeyValues(hKey,lpszName);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying the rest of the sp's
			}
		}
		dwSubkey++;
	} while(ERROR_NO_MORE_ITEMS != lErr );

	RegCloseKey(hKey);

	return DP_OK;

} // RegEnumerate

#define FILE_NAME_SIZE 256

// used b4 we compare module name to "mech2.exe".  it's ok to hard code for english,
// since we're just special casing this one app.
void LowerCase(char * lpsz) 
{
	while (*lpsz)
	{
	    if (*lpsz >= 'A' && *lpsz <= 'Z') *lpsz = (*lpsz - 'A' + 'a');
		lpsz++;
	}
} // LowerCase


HRESULT InternalEnumerate()
{

	HRESULT hr=DP_OK;

	if (!gSPNodes)
	{
		// enum from the registry
		hr = RegEnumerate();		
	}
	
	return hr;	
} // InternalEnumerate

HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayEnumW)(pCallback,pContext);
    }
#endif	

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();

	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;
		LPWSTR	lpwszName;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
			lpwszName = pspNode->lpszDescW;
		else
			lpwszName = pspNode->lpszName;
		
		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpwszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	
} // DirectPlayEnumerateW

// Some DP 1.0 apps were declaring their callbacks to be _cdecl instead
// of _stdcall and relying on DPlay to generate stack frames to clean up after
// them. To keep them running we just turn on stack frame generation for this
// one call so that they keep running. Yuck.

// turn on stack frame generation (yes, I know the word "off" is in there - thank you VC)
#pragma optimize ("y", off)

HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	char lpszName[DPLAY_REGISTRY_NAMELEN];

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayEnumA)(pCallback,pContext);
    }
#endif		

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();
	
	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
		//	for backwards compat, we ANSIfy the Unicode string
			WideToAnsi(lpszName, pspNode->lpszDescW, DPLAY_REGISTRY_NAMELEN);
		else
			WideToAnsi(lpszName ,pspNode->lpszName,DPLAY_REGISTRY_NAMELEN);

		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	

} // DirectPlayEnumerateA

// hack for compat.
// apps that linked to dp1 by name will come through this entry
#undef DirectPlayEnumerate
HRESULT WINAPI DirectPlayEnumerate( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	return DirectPlayEnumerateA(  pCallback,  pContext);
} 

// restore default optimizations
#pragma optimize ("", on)

BOOL PASCAL DummyEnumSessionsCallBack(
    LPCDPSESSIONDESC2 lpDPSGameDesc,
    LPDWORD		lpdwTimeOut,
    DWORD		dwFlags,
    LPVOID		lpContext)
{
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindSessionInSessionList"

//
// called by ConnectFindSession
LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,GUID const *pGuid)
{
	LPSESSIONLIST pSession = this->pSessionList;
	BOOL bFoundIt = FALSE;
	HRESULT hr=DP_OK;

	while ((pSession) && !bFoundIt)
	{
		if (IsEqualGUID((&pSession->dpDesc.guidInstance),pGuid))
		{
			bFoundIt=TRUE;
		} 
		else pSession = pSession->pNextSession;
	}
	if (!bFoundIt) 
	{
		DPF_ERR("could not find matching session");
		return NULL;
	}
	
	return pSession;
} // FindSessionInSessionList

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayConnectW"

// how long we wait between checking local session list
// for session we're searching for.  
#define ENUM_TIME 100

//
// called by ConnectMe
HRESULT AsyncConnectFindSession(LPDIRECTPLAYLOBBY pIDL,
		LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	HRESULT hr;
	

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,
		lpConnect->lpSessionDesc,0,DummyEnumSessionsCallBack,
		NULL,(DPENUMSESSIONS_ASYNC | DPENUMSESSIONS_RETURNSTATUS));

	ENTER_DPLAY();
	
	if(SUCCEEDED(hr) || (hr == DPERR_CONNECTING))
	{
		// Turn the async flag on to say that we are processing
		PRV_TurnAsyncConnectOn(pIDL);
	}

	if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
	{
		return DP_OK;
	}

	// If things are okay, we need to return DPERR_CONNECTING to say that
	// we're still working (this gets around SP's like the winsock SP which
	// returns DP_OK during an async EnumSessions)
	if(SUCCEEDED(hr))
		return DPERR_CONNECTING;
	else
		return hr;
	
}  // AsyncConnectFindSession
		

HRESULT StopAsyncConnect(LPDIRECTPLAYLOBBY pIDL, LPDPLAYI_DPLAY this,
		LPDPLCONNECTION lpConnect)
{
	HRESULT hr;

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_STOPASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Failed stopping async enum - hr = 0x%08x\n", hr);
		return hr;
	}

	return DP_OK;

} // StopAsyncConnect


// enum 'till we find the right session, or run out of time
HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	// the total amount of time we'll wait to join
	DWORD dwTotalTimeout,dwTimeStarted;
    BOOL bFoundIt=FALSE;
	HRESULT hr;
	
	dwTotalTimeout = GetDefaultTimeout( this, TRUE) * DP_NAMETABLE_SCALE;

	// Now, if the value is over a minute, max it out at a minute
	if(dwTotalTimeout > DP_MAX_CONNECT_TIME)
		dwTotalTimeout = DP_MAX_CONNECT_TIME;
	DPF(3,"ConnectFindSession - total time out = %d\n",dwTotalTimeout);

	//
	// call enum once, just to kick start (e.g. get any dialogs out of 
	// the way
	 
	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("ConnectFindSession enum failed - hr = 0x%08lx\n", hr);
		return hr;
	}

	dwTimeStarted = GetTickCount();		

	while (dwTotalTimeout > (GetTickCount() - dwTimeStarted))
	{
		if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
		{
			bFoundIt = TRUE;
			break;
		}

		// we leave dplay here, since when we get to internal enum , the lock 
		// count has to be at one...
		LEAVE_DPLAY();
		
		// wait a bit, so replies can filter in...
		Sleep(ENUM_TIME);

		hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
			0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

		ENTER_DPLAY();
		
		if (FAILED(hr))
		{
			DPF(0,"ConnectFindSession enum failed - hr = 0x%08lx\n");
			return hr;
		}
	} 

	if (!bFoundIt)
	{
		DPF_ERR(" !@!@!@ !@!@!@ NO SESSION WAS FOUND! TIMEOUT !@!@!@ !@!@!@ ");
		return DPERR_NOSESSIONS;
	}
	
	return DP_OK; // found it!
	
}  // ConnectFindSession
		

// B#35348, take ALL, not just DPLAY in this fn.  Otherwise crashes in fail case of InternalOpenSession
HRESULT ConnectMe(LPDIRECTPLAYLOBBY pIDL, LPDIRECTPLAY2 FAR *lplpDP,
		IUnknown FAR *pUnkOuter, DWORD dwFlags) 
{
	HRESULT hr=DP_OK;
	IDirectPlay2 * pIDP2 = NULL;
	LPDPLAYI_DPLAY this = NULL;
	DWORD dwConnectSize;
	LPDPLCONNECTION lpConnect = NULL;

	ENTER_ALL();

	// First, see if we were already called with the async flag, and
	// see if our DPlay2 and DPLCONNECTION pointers already exist
	if(dwFlags & DPCONNECT_RETURNSTATUS)
	{
		// If our pointers exist, then just get them
		PRV_GetConnectPointers(pIDL, &pIDP2, &lpConnect);
	}
	else
	{
		// Make sure we're not already in an async mode
		if(PRV_IsAsyncConnectOn(pIDL))
		{
			// Since we're in the middle of an async Connect, we don't want
			// to blow away our pointers, so we'll just exit from here.
			DPF_ERR("Connect called without the async flag with an asynchronous Connect in progress!");
			goto JUST_EXIT;
		}
	}

	// Now, if our pointers exist, we can skip this part (aka we're already
	// in the middle of an asynchronous Connect, so we have the pointers)
	if(!(pIDP2 && lpConnect))
	{
		// find out how big for connect buffer + alloc it
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,NULL,&dwConnectSize);
		if (DPERR_BUFFERTOOSMALL != hr) 
		{
			// we passed NULL buffer.  If something other than too small 
			// is returned, we're hosed.
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		// alloc it
		lpConnect = DPMEM_ALLOC(dwConnectSize);
		if (!lpConnect)
		{
			DPF_ERR("could not get connect struct - out of memory");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		
		// set up the connect
		memset(lpConnect,0,dwConnectSize);
		lpConnect->dwSize = sizeof(DPLCONNECTION);

		// go get the connect buffer
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,lpConnect,&dwConnectSize);
		if (FAILED(hr))
		{
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		ASSERT(lpConnect);

		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_CONNECTIONSETTINGSREAD,
			DPLOBBYPR_GAMEID);

		hr =InternalCreate(&(lpConnect->guidSP),(LPDIRECTPLAY *)&pIDP2,NULL,lpConnect,&dpCallbacks2);
		if (FAILED(hr))
		{
			DPF(0,"internal create failed - hr = 0x%08lx\n",hr);
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		// If we're async, save off the DPlay2 and DPLCONNECTION pointers
		if(dwFlags & DPCONNECT_RETURNSTATUS)
			PRV_SaveConnectPointers(pIDL, pIDP2, lpConnect);
	}

	this = DPLAY_FROM_INT(pIDP2);
#ifdef DEBUG	
	hr = VALID_DPLAY_PTR( this );
	ASSERT( SUCCEEDED(hr) );
#endif 

	// if we're going to join, enum 1st. this is  so dplay will have an internal
	// list of sessions that we can then open.
	if (lpConnect->dwFlags & DPOPEN_JOIN)
	{
		// If the async flag was set, call our async version
		if(dwFlags & DPCONNECT_RETURNSTATUS)
		{
			// Call the non-asynchronous version			
			hr = AsyncConnectFindSession(pIDL,this,lpConnect);
			if (FAILED(hr))
			{
				// An error here is valid (i.e. DPERR_CONNECTING) if
				// we are doing an async Connect.  We don't want to
				// blow away any of our pointers, so just exit here.
				goto JUST_EXIT;
			}

			// Turn off the async stuff in the lobby object
			PRV_SaveConnectPointers(pIDL, NULL, NULL);
			PRV_TurnAsyncConnectOff(pIDL);
		}
		else
		{
			// Call the non-asynchronous version			
			hr = ConnectFindSession(this,lpConnect);
			if (FAILED(hr))
			{
				DPF_ERR("could not find matching session");
				// Send a system message to the lobby client about our status
				PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
					DPLOBBYPR_GAMEID);
				goto CLEANUP_EXIT;
			}
		}
	}

	// now, create or join
	hr = InternalOpenSession(this,lpConnect->lpSessionDesc,FALSE,lpConnect->dwFlags,
        TRUE,NULL,NULL);
	if (FAILED(hr))
	{
		DPF(0,"could not open session  - hr = 0x%08lx\n",hr);
		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
			DPLOBBYPR_GAMEID);
		goto CLEANUP_EXIT;
	}

	// Send a system message to the lobby client about our status
	PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTSUCCEEDED,
		DPLOBBYPR_GAMEID);

	// Save a copy of the lobby interface so that we can send
	// messages back to the server from inside dplay
	hr = IDirectPlayLobby_QueryInterface(pIDL, &IID_IDirectPlayLobby,
			&(this->lpLaunchingLobbyObject));
	if(FAILED(hr))
	{
		DPF(2, "Unable to QueryInterface for internal IDirectPlayLobby --");
		DPF(2, "Lobby Server will not be notified of session events");
	}

	// normal exit
	*lplpDP = pIDP2;

	// fall through

CLEANUP_EXIT:

	// If we were async, make sure our pointers are cleared
	if((dwFlags & DPCONNECT_RETURNSTATUS) && (PRV_IsAsyncConnectOn(pIDL)))
	{
		StopAsyncConnect(pIDL, this, lpConnect);
		PRV_SaveConnectPointers(pIDL, NULL, NULL);
		PRV_TurnAsyncConnectOff(pIDL);
	}

	if (lpConnect)
		DPMEM_FREE(lpConnect);

	LEAVE_ALL();

	if(FAILED(hr))
	{
		if (pIDP2)
			pIDP2->lpVtbl->Release(pIDP2);
	}

	return hr;

JUST_EXIT:
	
	// This lable is here to avoid doing an of the cleanup, but
	// still drop the lock in only one place.  There are several
	// exit paths (namely during an async Connect) where we
	// don't want to free our Connection Settings or our
	// IDirectPlay2 pointer.
	LEAVE_ALL();
	return hr;

} // ConnectMe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\classfac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	directplay class factory code
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	17-jan-97	andyco	created it from ddraw\classfac.c
 *	4/11/97		myronth	Added support for DirectPlayLobby objects
 *  12/01/99    aarono  Change ENTER_DPLAY/LEAVE_DPLAY to ENTER_ALL/LEAVE_ALL
 *                       manbug#28440
 *  02/18/2000	rodtoll	Updated to handle alternative gamevoice build. 
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 ***************************************************************************/
#include "dplaypr.h"
#include <initguid.h>

static IClassFactoryVtbl	directPlayClassFactoryVtbl;
static IClassFactoryVtbl	directPlayLobbyClassFactoryVtbl;

typedef struct DPLAYCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
} DPLAYCLASSFACTORY, *LPDPLAYCLASSFACTORY;

#define VALIDEX_DIRECTPLAYCF_PTR( ptr ) \
        ((!IsBadWritePtr( ptr, sizeof( DPLAYCLASSFACTORY ))) && \
        ((ptr->lpVtbl == &directPlayClassFactoryVtbl) || \
		(ptr->lpVtbl == &directPlayLobbyClassFactoryVtbl)))
		
#define DPF_MODNAME "DPCF_QueryInterface"

/*
 * DPCF_QueryInterface
 */
STDMETHODIMP DPCF_QueryInterface(
                LPCLASSFACTORY this,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
	HRESULT hr;
	
    DPF( 2, "ClassFactory::QueryInterface" );
	
	ENTER_DPLAY();

    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
			LEAVE_DPLAY();
            return E_FAIL;
        }

        if( !VALID_DWORD_PTR( ppvObj ) )
        {
            DPF_ERR( "Invalid object ptr" );
			LEAVE_DPLAY();
            return E_INVALIDARG;
        }
        *ppvObj = NULL;

        if( !VALID_READ_GUID_PTR( riid ) )
        {
            DPF_ERR( "Invalid iid ptr" );
            LEAVE_DPLAY();
            return E_INVALIDARG;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return E_FAIL;
    }

    if( IsEqualIID(riid, &IID_IClassFactory) ||
                    IsEqualIID(riid, &IID_IUnknown))
    {
        pcf->dwRefCnt++; 
        *ppvObj = this;
		hr = S_OK;
    }
    else
    { 
        DPF_ERR("E_NOINTERFACE" );
		hr = E_NOINTERFACE;
    }

	LEAVE_DPLAY();
	
	return hr;
	
} /* DPCF_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_AddRef"

/*
 * DPCF_AddRef
 */
STDMETHODIMP_(ULONG) DPCF_AddRef( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY pcf;

	ENTER_DPLAY();
	
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt++;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    DPF( 2, "ClassFactory::AddRef, dwRefCnt=%ld", pcf->dwRefCnt );
    LEAVE_DPLAY();
    return pcf->dwRefCnt;

} /* DPCF_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_Release"

/*
 * DPCF_Release
 */
STDMETHODIMP_(ULONG) DPCF_Release( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY	pcf;

    ENTER_DPLAY();
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt--;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }
    DPF( 2, "ClassFactory::Release, dwRefCnt=%ld", pcf->dwRefCnt );

    if( pcf->dwRefCnt != 0 )
    {
        LEAVE_DPLAY();
        return pcf->dwRefCnt;
    }

    DPMEM_FREE( pcf );
    LEAVE_DPLAY();
    return 0;

} /* DPCF_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::CreateInstance"

/*
 * DPCF_CreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_CreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlay * pidp;
	GUID GuidCF = GUID_NULL; 	// pass this to DirectPlayCreate
								// to indicate no load sp
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_ALL();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_ALL();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_ALL();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_ALL();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_ALL();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlay object
     *
     */
    hr = DirectPlayCreate(&GuidCF,&pidp,NULL);
	if (FAILED(hr))
	{
		LEAVE_ALL();	
		DPF_ERR("could not create DirectPlay object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlay) )
    {
		IDirectPlay2 * pidp2;

		hr = DP_QueryInterface(pidp,riid,&pidp2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidp->lpVtbl->Release(pidp);		
			LEAVE_ALL();	
			DPF_ERR("could not get requested DirectPlay interface");
			return hr;
		}

		// release the idp we used to get the pidp2
		pidp->lpVtbl->Release(pidp);

		*ppvObj= (LPVOID)pidp2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidp;
	}

    LEAVE_ALL();
    return DP_OK;

} /* DPCF_CreateInstance */


/*
 * DPCF_LobbyCreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_LobbyCreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlayLobby * pidpl;
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_DPLAY();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlayLobby object
     *
     */
    hr = DirectPlayLobbyCreate(NULL,&pidpl,NULL, NULL, 0);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();	
		DPF_ERR("could not create DirectPlayLobby object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		IDirectPlayLobby2 * pidpl2;

		hr = pidpl->lpVtbl->QueryInterface(pidpl,riid,&pidpl2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidpl->lpVtbl->Release(pidpl);		
			LEAVE_DPLAY();	
			DPF_ERR("could not get requested DirectPlayLobby interface");
			return hr;
		}

		// release the idpl we used to get the pidpl2
		pidpl->lpVtbl->Release(pidpl);

		*ppvObj= (LPVOID)pidpl2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidpl;
	}

    LEAVE_DPLAY();
    return DP_OK;

} /* DPCF_LobbyCreateInstance */


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::LockServer"

/*
 * DPCF_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP DPCF_LockServer(
                LPCLASSFACTORY this,
                BOOL fLock
				)
{
    HRESULT		hr;
    HANDLE		hdll;
    LPDPLAYCLASSFACTORY	pcf;

	ENTER_DPLAY();
	
    pcf = (LPDPLAYCLASSFACTORY) this;
    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Invalid this ptr" );
        return E_INVALIDARG;
    }

    /*
     * call CoLockObjectExternal
     */
    DPF( 2, "ClassFactory::LockServer" );
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        HRESULT (WINAPI * lpCoLockObjectExternal)(LPUNKNOWN, BOOL, BOOL );
        lpCoLockObjectExternal = (LPVOID) GetProcAddress( hdll, "CoLockObjectExternal" );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
            DPF_ERR( "Error! Could not get procaddr for CoLockObjectExternal" );
        }
    }
    else
    {
        DPF_ERR( "Error! Could not load OLE32.DLL" );
    }

	LEAVE_DPLAY();
	return hr;

} /* DPCF_LockServer */

#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

static IClassFactoryVtbl directPlayClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_CreateInstance,
        DPCF_LockServer
};

static IClassFactoryVtbl directPlayLobbyClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_LobbyCreateInstance,
        DPCF_LockServer
};

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT WINAPI DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
    HRESULT		hr;
	GUID		guidCLSID;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		if( IsEqualCLSID( rclsid, &CLSID_DirectPlay ) )
		{
			memcpy( &guidCLSID, &CLSID_DirectPlay, sizeof(GUID) );
		}
		else if( IsEqualCLSID( rclsid, &CLSID_DirectPlayLobby ) )
		{
			memcpy( &guidCLSID, &CLSID_DirectPlayLobby, sizeof(GUID) );
		}
		else
		{
			memcpy( &guidCLSID, rclsid, sizeof(GUID) );
		}

		return (*pfnGetClassObject)(&guidCLSID,riid,ppvObj);
	}
#endif

	ENTER_DPLAY();
	
    TRY
    {
	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();			
	        return E_INVALIDARG;
	    }
	    *ppvObj = NULL;
	    if( !VALID_READ_GUID_PTR( rclsid ) )
	    {
	        DPF_ERR( "Invalid clsid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }

    /*
     * is this one of our class ids?
     */
    if( !IsEqualCLSID( rclsid, &CLSID_DirectPlay ) && 
	   !IsEqualCLSID( rclsid, &CLSID_DirectPlayLobby ) )
    {
		DPF_ERR("requested invalid class object");
        LEAVE_DPLAY();			
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, &IID_IUnknown ) &&
       !IsEqualIID( riid, &IID_IClassFactory ) )
    {
        LEAVE_DPLAY();				
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = DPMEM_ALLOC( sizeof( DPLAYCLASSFACTORY ) );
    if( NULL == pcf)
    {
        LEAVE_DPLAY();
        return E_OUTOFMEMORY;
    }

    /* check the CLSID and set the appropriate vtbl
	 */
	if(IsEqualCLSID(rclsid, &CLSID_DirectPlayLobby))
		pcf->lpVtbl = &directPlayLobbyClassFactoryVtbl;
	else
		pcf->lpVtbl = &directPlayClassFactoryVtbl;

    pcf->dwRefCnt = 0;

    hr = DPCF_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DPMEM_FREE( pcf );
        *ppvObj = NULL;
        DPF( 0, "QueryInterface failed, rc=%08lx", hr );
    }
    else
    {
        DPF( 2, "DllGetClassObject succeeded, pcf=%08lx", pcf );
    }
	
    LEAVE_DPLAY();
    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT WINAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		return (*pfnDllCanUnLoadNow)();
	}
#endif

    DPF( 2, "DllCanUnloadNow called" );
   
	if (0 == gnObjects)
	{
		// no dplay objects, it's ok to go
		DPF(2,"OK to unload dll");
		hr = S_OK;
	}
	
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dblbuf.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dblbuf.c
*  Content:	   memory manager for double buffer memory for messages.
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/29/97   aarono    Original
*
* Synopsis:
*
***************************************************************************/

PVOID GetDoubleBuffer(UINT size)
{
}

VOID FreeDoubleBuffer(PVOID pBuffer)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\connect.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connect.c
 *  Content:	DirectPlay connection related methods
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    3/1/96	andyco	   	created it
 *	3/10/97		myronth		Added lobby support for EnumConnections and
 *							InitializeConnection, fixed uninit'd struct
 *	3/25/97		kipo		EnumConnections takes a const *GUID
 *	5/10/97		kipo		added GUID to EnumConnections callback
 *	5/12/97		kipo		fixed bugs #7516, 6411, 6888
 *	5/13/97		myronth		Set DPLAYI_DPLAY_SPSECURITY flag so that dplay
 *							lets the LP do all the security for a secure session
 *  7/28/97		sohailm		FindGuidCallback() was assuming pointers were valid after
 *                          duration of call.
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	01/20/97	sohailm		don't free sp list after EnumConnections (#17006)
 ***************************************************************************/
						
#include "dplaypr.h"
#include "dplobby.h"


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_EnumConnections"
  

// list of all sp info gotten from the registry
extern LPSPNODE gSPNodes;
// call internalenumearte to build a list of sp's / connections
// wrap the sp's in a dpaddress
// call 'em back
HRESULT InternalEnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK pCallback,LPVOID pvContext,DWORD dwFlags,
	BOOL fAnsi, BOOL bPreDP4)
{
	HRESULT hr = DP_OK;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	ADDRESSHEADER header;
	DPNAME name;
	LPWSTR lpwszName;
		
	TRY
    {
		if( !VALIDEX_CODE_PTR( pCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if ( pGuid && !VALID_READ_GUID_PTR( pGuid) )
		{
		    DPF_ERR( "Invalid guid" );
		    return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & (~(DPCONNECTION_DIRECTPLAY |
						DPCONNECTION_DIRECTPLAYLOBBY)))
		{
		    DPF_ERR( "Invalid dwFlags" );
		    return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	// A zero dwFlags value means enumerate all of them, so let's
	// make the code below a little easier
	if(!dwFlags)
		dwFlags = DPCONNECTION_DIRECTPLAY;

	// Enumerate lobby providers if the flags say so
	if(DPCONNECTION_DIRECTPLAYLOBBY & dwFlags)
	{
		hr = PRV_EnumConnections(pGuid, pCallback, pvContext, dwFlags, fAnsi);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			DPF(0, "Unable to enumerate Lobby Providers, hr = 0x%08x", hr);
		}

		// If enumerating lobby providers is the only things the user
		// requested, then bail
		if(!(dwFlags & ~(DPCONNECTION_DIRECTPLAYLOBBY)))
			return hr;
	}

	// Enumerate DirectPlay Service Providers
	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF_ERRVAL("could not enumerate reg entries - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set up the non-changing fields in addr
	// 1st, size
	memset(&header, 0, sizeof(ADDRESSHEADER));
	header.dpaSizeChunk.guidDataType = DPAID_TotalSize;
	header.dpaSizeChunk.dwDataSize = sizeof(DWORD);		
	header.dwTotalSize = sizeof(header);

	// next, SP guid
	header.dpaSPChunk.guidDataType = DPAID_ServiceProvider;
	header.dpaSPChunk.dwDataSize = sizeof(GUID);

	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the locks
	LEAVE_ALL();

	while ((pspNode) && (bContinue))
	{
		header.guidSP = pspNode->guid;
		
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			if (fAnsi)
			{
				// Use the description if one exists, and we already
				// have an ANSI version of it, so we don't need to
				// convert it...
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
				{
					// a-josbor: on a PRE-DPLAY4 interface, we need to simulate the old MBCS
					//	strings, so grab the UNICODE and convert it to MBCS
					if (bPreDP4)
					{
						name.lpszShortNameA = NULL; // 0 it out!
						GetAnsiString(&(name.lpszShortNameA), pspNode->lpszDescW);
					}
					else
					{
						name.lpszShortNameA = pspNode->lpszDescA;
					}
					
					// call the app
					bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

					if (bPreDP4)
					{
						DPMEM_FREE(name.lpszShortNameA);
					}
				}
				else
				{
					name.lpszShortNameA = NULL; // 0 it out!
					if (SUCCEEDED(GetAnsiString(&(name.lpszShortNameA),pspNode->lpszName)))
					{
						// call the app
						bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

						DPMEM_FREE(name.lpszShortNameA);
					}
				}
			}
			else 
			{
				// Use the description if one exists
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
					lpwszName = pspNode->lpszDescW;
				else
					lpwszName = pspNode->lpszName;

				name.lpszShortName = lpwszName;

				// call the app
				bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);
			}
		}

		pspNode = pspNode->pNextSPNode;

	} // while

	// take the locks back
	ENTER_ALL();
	
	return DP_OK;	
		
} // InternalEnumConnections

HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;
	DPF(7,"Entering DP_EnumConnections");

	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,FALSE, FALSE);
	
	LEAVE_ALL();
		
	return hr;
	
} // DP_EnumConnections

   
HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, FALSE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnections   

HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnectionsPreDP4   


// called by enumaddress - we're looking for DPAID_ServiceProvider
BOOL FAR PASCAL FindGuidCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	// is this a sp chunk
	if (IsEqualGUID(lpguidDataType, &DPAID_ServiceProvider))
	{
		// copy the guid
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		// all done!
		return FALSE;
	}
	// keep trying	
	return TRUE;

} // EnumConnectionData

// fake struct used only for pvAdress size validation - pvAddress must be at least this big
// dpaddress must have at least this must data in it to be valid for initializeconnection
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
} MINIMALADDRESS,*LPMINIMALADDRESS;

// get our tihs ptr, and call loadsp on it
HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags)
{
	HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	GUID guidSP = GUID_NULL; // the SP's guid
	LPDPADDRESS paddr;
	DWORD dwAddressSize;
				
	DPF(7,"Entering DP_InitializeConnection");

	ENTER_DPLAY();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (DPERR_UNINITIALIZED != hr)
		{
			DPF_ERR("bad or already initialized dplay ptr!");
			LEAVE_DPLAY();
			return DPERR_ALREADYINITIALIZED;
		}
		
		ASSERT(this->dwFlags & DPLAYI_DPLAY_UNINITIALIZED);
		
		// validate this address like it has never been validated before
		paddr = (LPDPADDRESS)pvAddress;
    	
		if (!VALID_READ_STRING_PTR(paddr,sizeof(MINIMALADDRESS)))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		// the size needs to be the 1st chunk
		if (!IsEqualGUID(&paddr->guidDataType, &DPAID_TotalSize))
		{
			DPF_ERR(" could not extract size from pvAdress - bad pvAddress");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}

		// address size follows paddr
		dwAddressSize = ((MINIMALADDRESS *)paddr)->dwTotalSize;

		if (!VALID_READ_STRING_PTR(paddr,dwAddressSize))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		
        if (dwFlags)
        {
        	DPF_ERR("invalid flags");
			LEAVE_DPLAY();
			return DPERR_INVALIDFLAGS;
        }
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return DPERR_EXCEPTION;
    }


	// First see if the DPADDRESS contains the LobbyProvider guid.  If it
	// does, load it.  If it doesn't then try looking for a DPlay SP.
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,
			PRV_FindLPGUIDInAddressCallback,pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find lobby provider guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}

	// If we found a lobby provider, try loading it
	if(!IsEqualGUID(&guidSP,&GUID_NULL))
	{
		hr = PRV_LoadSP(this->lpLobbyObject, &guidSP, pvAddress, dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Unable to load lobby provider - hr = 0x%08lx",hr);
			LEAVE_DPLAY();
			return hr;
		}

		// Mark the dplay object as lobby owned and consider it initialized
		// Also set the DPLAY_SPSECURITY flag so that dplay lets the LP do
		// all of the security.
		this->dwFlags |= (DPLAYI_DPLAY_LOBBYOWNS | DPLAYI_DPLAY_SPSECURITY);
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;

		// Increment the ref cnt on the dplay object (the release code expects
		// an extra ref cnt if the object has been initialized.  This is usually
		// for the IDirectPlaySP interface, but it works just fine in our case
		// for the lobby object's lobby SP).
		this->dwRefCnt++;

		LEAVE_DPLAY();
		return hr;
	}


	// We didn't find a Lobby Provider guid, so look for the SP guid
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,FindGuidCallback,
		pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find sp guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}


	// we found the SP, so load it
	if(!IsEqualGUID(&guidSP, &GUID_NULL))
	{
		// mark dplay as init'ed, since SP may need to make some calls...	
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;
		
		hr = LoadSP(this,&guidSP,(LPDPADDRESS)pvAddress,dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("could not load sp - hr = 0x%08lx",hr);
			this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
			LEAVE_DPLAY();
			return hr;
		}

		// At this point, DirectPlay is finished loading the SP, only
		// code related to the lobby exists beyond this point, so we'll
		// just exit from here.
		LEAVE_DPLAY();
		return hr;
	}


	// We must not have found a provider we can load...
	DPF_ERR("could not find a provider in address");
	LEAVE_DPLAY();
	return DPERR_INVALIDPARAMS;
	
} // DP_InitializeConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlay"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\do.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       do.c
*  Content:	helper functions for iplay.c
*  History:
*   Date		By		Reason
*   ====		==		======
*	6/29/96		andyco	created it to keep clutter down in iplay.c
***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"DoXXX"

// called by GetPlayer, GetGroup, InternalSetData to set up the player data
// flags can be DPSET_LOCAL or DPSET_REMOTE
// NOTE - can be called on a player, or on a group cast to a player!
HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvPlayerLocalData;
		dwDestSize = lpPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvPlayerData;
		dwDestSize = lpPlayer->dwPlayerDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempPlayerData;

			ASSERT(pvDest);
			pvTempPlayerData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempPlayerData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempPlayerData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvPlayerLocalData = pvDest;
		lpPlayer->dwPlayerLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvPlayerData = pvDest;
		lpPlayer->dwPlayerDataSize = dwDestSize;
	}

	return DP_OK;

} // DoPlayerData

// NOTE - can be called on a player, or on a group cast to a player!
// called by GetPlayer, GetGroup, InternalSetName to set the player name
HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName)
{
    HRESULT hr=DP_OK;

	if (pName)
	{
		// free the old ones, copy over the new ones
		if (pPlayer->lpszShortName) DPMEM_FREE(pPlayer->lpszShortName);
		hr = GetString(&(pPlayer->lpszShortName),pName->lpszShortName);
		if (FAILED(hr))
		{
			return hr;
		}

		if (pPlayer->lpszLongName) DPMEM_FREE(pPlayer->lpszLongName); 
		hr = GetString(&(pPlayer->lpszLongName),pName->lpszLongName);
		if (FAILED(hr))
		{
			return hr;
		} 
	}
	else	// no names given, so free old ones
	{
		if (pPlayer->lpszShortName)
		{
			DPMEM_FREE(pPlayer->lpszShortName);
			pPlayer->lpszShortName = NULL;
		}

		if (pPlayer->lpszLongName)
		{
			DPMEM_FREE(pPlayer->lpszLongName);
			pPlayer->lpszLongName = NULL;
		}
	}


    return hr;   	
} // DoPlayerName

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date   By  Reason
 *	============
 *	04-apr-95  ericeng  DirectPlay header file COM version
 *	07-jul-95  johnhall Making Program Management Dreams a Reality.
 *	19-jul-95  ericeng  Header file rationalization
 *	2/96		AndyCo	New dplay (dp2)
 *	4/8/96		AndyCo	added DPSESSION_PLAYERS_ENABLED
 *	4/18/96		AndyCo	dpcaps2
 *	5/3/96		andyco	idirectplay2
 *	5/6/96		andyco	unions for wchar and char
 *	5/23/96		andyco	added DPSESSION_MIGRATENAMESERVER, moved data to last
 *						element in addxxx messages to make packing easier
 *	5/31/96		andyco	added DPNAME,DPLAY_SETDATA_REMOTE,
 *						DPSET_GUARANTEED
 *
 *	6/9/95		andyco	DPLAY_SETDATA_REMOTE -> DPLAY_SETDATA_LOCAL for consistancy
 *						PLAYERNAME -> DPNAME, DPOPEN_xxx -> DPSESSION_CREATE
 *						/ DPSESSION_JOIN
 *	6/20/96		andyco	cleaned up flags, etc.
 *	6/22/96		andyco	added dwFlags to Open,GetCaps
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *  6/27/96     ajayj   defined flags DPSEND_OPENSTREAM and DPSEND_CLOSESTREAM
 *  6/29/96     ajayj   defined flag DPSESSION_PRIVATE and modified comment for
 *                      DPSESSION_PLAYERSDISABLED
 *	6/30/96		andyco	added DP(G)SET_REMOTE,_LOCAL
 *  7/5/96      ajayj   change DPSESSION_PRIVATE to DPSESSION_JOINDISABLED
 *                      added DPSESSION_NEWPLAYERSDISABLED and defined
 *                      old flag DPSESSION_PLAYERSDISABLED to be the same thing
 *  7/8/96      ajayj   Added loads of comments.
 *                      Alphabetized IDirectPlay2 vtable
 *                      Removed SaveSession and EnableNewPlayers from vtable
 *                      Removed structure DPSAVEDATA
 *                      Change terminology "Name Server" is now a session "Host"
 *                      DPCAPS_GROUP                -> DPCAPS_GROUPOPTIMIZED
 *                      DPCAPS_NAMESERVER           -> DPCAPS_ISHOST
 *                      DPSESSION_MIGRATENAMESERVER -> DPSESSION_MIGRATEHOST
 *                      DPSYS_NAMESERVER            -> DPSYS_HOST
 *                      LPDPENUMSESSIONCALLBACK2 - lpContext at end of param list
 *                      LPDPENUMPLAYERSCALLBACK2 - dwPlayerType after dpId
 *                      Changed numbering of DPSYS_HOST, DPSYS_DATACHANGED, and
 *                          DPSYS_NAMECHANGED system messages
 *                      DPMSG_NAMECHANGED, DPMSG_ADDPLAYER2 - changed name of
 *                          data member 'PlayerName' to 'dpnName'.
 *	7/09/96		kipo	changed DPSYS_ADDPLAYER to DPSYS_CREATEPLAYERORGROUP and
 *						DPSYS_DELETEPLAYER/GROUP to DPSYS_DESTROYPLAYERORGROUP;
 *						changed player data/name messages to
 *						DPSYS_SETPLAYERORGROUPDATA and DPMSG_SETPLAYERORGROUPNAME;
 *						made the old system messages obsolete.
 *  7/11/96     ajayj   Deleted some flags which weren't use at all in Dplay1 or DPlay3
 *  7/14/96     ajayj   Added constants DPID_SYSMSG, DPID_ALLPLAYERS
 *                      Added structures DPMSG_HOST, DPMSG_SESSIONLOST, DPMSG_CONNECT all
 *                          are typedefs of DPMSG_GENERIC
 *                      Made system message comments more consistent.
 *  7/20/96     kipo	The GetPlayerName interface declartion in IDirectPlay2 had an
 *						extra DWORD parameter at the end. #2523
 *  7/23/96     ajayj	Moved DPSYS_CONNECT to the obsolete DPlay1 constants section
 *  7/27/96     kipo    Added GUID to EnumGroupPlayers(); changed CreatePlayer()
 *                      to take an event handle instead of an event pointer.
 *  7/31/96     kipo    CreatePlayer() still had a LPHANDLE instead of a HANDLE parameter.
 *  8/1/96		andyco	added DPSESSION_KEEPALIVE, DPCAPS_OPTIMIZEKEEPALIVE flags
 *  8/1/96      sohailm Added IDirectPlay2 and IDirectPlay interface macros
 *  8/8/96      ajayj   typedef LPDIRECTPLAY to be struct IUnknown when the
 *                      symbol IDIRECTPLAY2_OR_GREATER is defined so app can
 *                      still QI on IDirectPlay to obtain IDirectPlay2.
 *  8/8/96      ajayj   added definitions for DPCAPS_GUARANTEEDOPTIMIZED and
 *                      DPCAPS_GUARANTEEDSUPPORTED
 *  8/10/96		andyco	added DPSESSION_DATACHANGEENABLED and player data to 
 *						destroy player message
 *  8/10/96     sohailm Bug# 2224: declared pointers in callbacks as const.
 *	8/13/96		myronth	Added DPERR_NOTLOBBIED
 *  8/16/96             andyco  backed out the constant changes.
 *  8/20/96     ajayj   fixed TABS. Remove DPENUMPLAYERS_ALL. MSINTERNAL
 *                      around DPSESSION_NOPLAYERMGMT.
 *	8/22/96		andyco	added DPENUMPLAYERS_ALL again.
 *  8/25/96		kipo	DPERR_NOINTERFACE was defined twice for some reason
 *  10/11/96    sohailm added struct DPMSG_SETSESSIONDESC and constant DPSYS_SETSESSIONDESC 
 *	11/11/96	andyco	added idirectplay3, DPID_SERVERPLAYER, DPPLAYER_SERVERPLAYER
 *	 2/10/97	kipo	commented out DPSEND_HIGHPRIORITY flag since its obsolete
 *	 2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *	 2/14/97	aarono	added DPERR_PENDING
 *	2/29/97		andyco	added clsid_directplay
 *	2/30/97		andyco	enumconnections, initializeconnection
 *	3/12/97		myronth	DPCONNECTION_* flags
 *  3/12/97     sohailm added SecureOpen() to IDirectPlay3 and 3A interfaces, corresponding macros,
 *                      DPCREDENTIALS and DPSECURITYDESC structures, DPSESSION_SECURESERVER flag,
 *                      and Security related errors.
 *	3/17/97		kipo	added support for DPADDRESSTYPEDESC structure
 *	3/24/97		kipo	IDirectPlay3 now inherits from IDirectPlay2
 *  3/24/97     sohailm added flags DPSESSION_PRIVATE, DPENUMSESSIONS_PASSWORDREQUIRED and 
 *                      errors DPERR_INVALIDPASSWORD,DPERR_JOINDISABLED,DPERR_PLAYERSMAXEDOUT
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/5/97		andyco	DPSESSION_MULTICASTSERVER
 *  4/09/97     sohailm Added error DPERR_CANTLOADSECURITYPACKAGE.
 *  4/23/97     sohialm Added flags DPCAPS_SIGNINGSUPPORTED, DPCAPS_ENCRYPTIONSUPPORTED, 
 *                      DPSEND_SIGNED and DPSEND_ENCRYTPED.
 *                      Added error DPERR_ENCRYPTIONNOTSUPPORTED.
 *  4/24/97     sohailm Added DPSYS_SECUREMESSAGE and DPMSG_SECUREMESSAGE.
 *	4/30/97		andyco	added groupingroup support
 *  5/7/97		ajayj	added back DPSEND_HIGHPRIORITY
 *	5/8/97		andyco	exposed server_player, client_server and removed update list
 *	5/8/97		myronth	moved DPLCONNECTION from dplobby.h, added StartSession,
 *						Get/SetGroupConnectionSettings, StartSession message
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *  5/12/97     sohailm renamed lpszSecurityPackageName field of DPSECURITYDESC to lpszSSPIProvider
 *                      added fields lpszCAPIProvider, dwCAPIProviderType, and dwEncryptionAlgorithm 
 *                       to DPSECURITYDESC.
 *                      added DPERR_CANTLOADCAPI and DPERR_NOTLOGGEDIN (not exposed).
 *	5/17/97		myronth	Added SendChatMessage, DPCHAT, and it's flags, Moved
 *						DPLCONNECTION flags below other definitions they reference
 *	5/18/97		kipo	added new DPENUM_PLAYERS and DPENUM_GROUP flags
 *  5/18/97     sohailm removed ms internal around DPERR_NOTLOGGEDIN.
 *  5/21/97     sohailm removed DPSECURE_SIGNED and DPSECURE_ENCRYPTED flags. We are going
 *                      to use DPSEND_SIGNED and DPSEND_ENCRYPTED instead.
 *	5/21/97		myronth	Changed DPMSG_CHAT structure to correct format (#8642)
 *  5/22/97		ajayj	Added typedefs for DPENUMGROUPS_ flags
 *	5/22/97		myronth	Added dwFlags member to DPMSG_CHAT (#8868)
 *  5/22/97		ajayj	Removed new DPLCONNECTION flags for lobby messaging
 *	5/23/97		kipo	Added support for return status codes
 *	5/25/97		kipo	Added DPERR_CONNECTING error
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *  5/30/97		ajayj	Added DPENUMGROUPS_ALL
 *	5/30/97		myronth	Added GetGroupParent
 *  5/30/97     sohailm Added domain name member to DPCREDENTIALS.
 *                      Added GetPlayerAccount() to IDirectPlay3, related macros, and DPACCOUNTDESC.
 *	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  5/30/97		ajayj	Added service provider GUIDs.
 *  6/09/97     sohailm Added DPERR_LOGONDENIED and removed DPERR_INVALIDCREDENTIALS.
 *  6/16/97     sohailm Removed DPCAPS_ENCRYPTIONOPTIZED and DPCAPS_SIGNINGOPTIMIZED.
 *	7/30/97		myronth	Added DPSEND_LOBBYSYSTEMMESSAGE for standard lobby messaging
 *  8/4/97		andyco	added DPSEND_ASYNC so we can make addforward async
 *	10/21/97	myronth	Added IDirectPlay4 interface definitions, also added
 *						hidden group flags and owner player flags
 *	10/21/97	andyco	added openvoice
 *	10/29/97	myronth	Fixed owner player flag, added SetGroupOwner message
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added DPCONNECT_ASYNC & STOPASYNC flags
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohaiml	added DPSESSON_OPTIMIZELATENCY and DPSESSION_OPTIMIZEBANDWIDTH.
 *  2/2/98      aarono  added DPERR_INVALIDPRIORITY
 *  2/5/98      aarono  changed SGBUFFER item order to lineup with WSABUF
 *  2/18/98     aarono  added new CAPS bits for info on new APIs behaviour
 *	2/18/98	   a-peterz	removed DPSESSION_OPTIMIZEBANDWIDTH.
 *	3/19/98	   a-peterz	DP[SYS/MSG]_SENDCOMPLETE were in the obsolete section.
 *	4/14/98	   a-peterz	#18340 DPSEND_NOCOPY made MSINTERNAL
 *  8/02/99		aarono  removed old voice support
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__

#include <ole2.h>       // for DECLARE_INTERFACE and HRESULT

/* avoid warnings in MSVC at Level4 */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)


/*
 * Some types
 */

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

typedef LPVOID (*LPRGLPVOID)[];
typedef LPRGLPVOID PRGPVOID, LPRGPVOID, PRGLPVOID, PAPVOID, LPAPVOID, PALPVOID, LPALPVOID;

#define VOL volatile
typedef VOID *VOL LPVOIDV;


#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectPlay objects
 */
DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {D1EB6D20-8923-11d0-9D97-00A0C90A43CB}
DEFINE_GUID(CLSID_DirectPlay,0xd1eb6d20, 0x8923, 0x11d0, 0x9d, 0x97, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * GUIDS used by Service Providers shipped with DirectPlay
 * Use these to identify Service Provider returned by EnumConnections
 */

// GUID for IPX service provider
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(DPSPGUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// GUID for TCP/IP service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(DPSPGUID_TCPIP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// GUID for Serial service provider
// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_SERIAL,						
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// GUID for Modem service provider
// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_MODEM,
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 ****************************************************************************/

#ifndef IDIRECTPLAY2_OR_GREATER
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else
typedef struct IUnknown           FAR *LPDIRECTPLAY;
#endif

typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2;
typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2A;
typedef struct IDirectPlay2       IDirectPlay2A;

typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3;
typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3A;
typedef struct IDirectPlay3       IDirectPlay3A;

typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4;
typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4A;
typedef struct IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID, FAR *LPDPID;

/*
 * DPID that system messages come from
 */
#define DPID_SYSMSG         0

/*
 * DPID representing all players in the session
 */
#define DPID_ALLPLAYERS     0

/*
 * DPID representing the server player
 */
#define DPID_SERVERPLAYER	1

//@@BEGIN_MSINTERNAL
/*
 * DPID representing the lobby's system player (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMPLAYER    2

/*
 * DPID representing the lobby's system group (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMGROUP     3

/*
 * DPID representing the lobby's system player for all remote
 * players and groups (only used internally and only used in lobby sessions)
 */
#define DPID_LOBBYREMOTESYSTEMPLAYER     4
//@@END_MSINTERNAL

/*
 * DPID representing the maxiumum ID in the range of DPID's reserved for
 * use by DirectPlay.
 */
#define DPID_RESERVEDRANGE     100

/*
 * The player ID is unknown (used with e.g. DPSESSION_NOMESSAGEID)
 */
#define DPID_UNKNOWN		0xFFFFFFFF

/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct
{
    DWORD dwSize;               // Size of structure, in bytes
    DWORD dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS, FAR *LPDPCAPS;

/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

/*
 * This DirectPlay player was created on this machine
 */
#define DPPLAYERCAPS_LOCAL			0x00000800

/*
 * Current Open settings supports all forms of Cancel
 */
#define DPCAPS_ASYNCCANCELSUPPORTED    0x00001000

/*
 * Current Open settings supports CancelAll, but not Cancel
 */
#define DPCAPS_ASYNCCANCELALLSUPPORTED 0x00002000

/*
 *  Current Open settings supports Send Timeouts for sends
 */
#define DPCAPS_SENDTIMEOUTSUPPORTED   0x00004000

/*
 *  Current Open settings supports send priority
 */
#define DPCAPS_SENDPRIORITYSUPPORTED   0x00008000

/*
 *  Current Open settings supports DPSEND_ASYNC flag
 */
#define DPCAPS_ASYNCSUPPORTED 		   0x00010000

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code.
 *
 * #define DPCAPS_NAMESERVICE          0x00000001
 * #define DPCAPS_NAMESERVER           DPCAPS_ISHOST
 * #define DPCAPS_GUARANTEED           0x00000004
 */
//@@END_MSINTERNAL

/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
    union
    {                           // Name of the session
        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
    };
    union
    {                           // Password of the session (optional)
        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
    };
    DWORD_PTR   dwReserved1;        // Reserved for future MS use.
    DWORD_PTR   dwReserved2;
    DWORD_PTR   dwUser1;            // For use by the application
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC2, FAR *LPDPSESSIONDESC2;

typedef DPSESSIONDESC2 * VOL LPDPSESSIONDESC2_V;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef const DPSESSIONDESC2 FAR *LPCDPSESSIONDESC2;
 
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008

//@@BEGIN_MSINTERNAL
/*
 * This flag tells DirectPlay not to generate player management messages 
 * (DPSYS_CREATEPLAYERORGROUP, DPSYS_DESTROYPLAYERORGROUP,
 * DPSYS_ADDPLAYERTOGROUP, DPSYS_DELETEPLAYERFROMGROUP,
 * DPSYS_SETPLAYERORGROUPDATA, DPSYS_SETPLAYERORGROUPNAME). 
 */
#define DPSESSION_NOPLAYERMGMT          0x00000010
//@@END_MSINTERNAL

/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000


/*
 * This flag tells DirectPlay to optimize communication for latency
 */
#define DPSESSION_OPTIMIZELATENCY		0x00008000

/*
 * This flag allows lobby launched games that aren't voice enabled
 * to get voice capabilities.
 */
#define DPSESSION_ALLOWVOICERETRO		0x00010000

/*
 * This flag supresses transmission of session desc changes.
 * DPSESSION_NODATAMESSAGES was supposed to do that, but SetSessionDesc
 * was ignoring the flag and some apps depended on the broken behavior, this
@@BEGIN_MSINTERNAL
 *	i.e. Jedi Knight
@@END_MSINTERNAL
 * flag allows applications to get the right behaviour without breaking apps depending
 * on old broken behavior.
 */
#define DPSESSION_NOSESSIONDESCMESSAGES		0x00020000
 
/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct 
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
    union
    {                           // The short or friendly name
        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
    };
    union
    {                           // The long or formal name
        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
    };

} DPNAME, FAR *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef const DPNAME FAR *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct 
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
    union
    {                           // User name of the account
        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
    };    
    union
    {                           // Password of the account
        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
    };    
    union
    {                           // Domain name of the account
        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
    };    
} DPCREDENTIALS, FAR *LPDPCREDENTIALS;

typedef const DPCREDENTIALS FAR *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // SSPI provider name
        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
    };
    union
    {                               // CAPI provider name
        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC, FAR *LPDPSECURITYDESC;

typedef const DPSECURITYDESC FAR *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // Account identifier
        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
    };
} DPACCOUNTDESC, FAR *LPDPACCOUNTDESC;

typedef const DPACCOUNTDESC FAR *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef const GUID FAR *LPCGUID;

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    DWORD               dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION, FAR *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef const DPLCONNECTION FAR *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct
{
    DWORD               dwSize;
    DWORD               dwFlags;
    union
    {                          // Message string
        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
    };    
} DPCHAT, FAR * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct 
{
	UINT         len;       // length of buffer data
	PUCHAR	     pData;		// pointer to buffer data
} SGBUFFER, *PSGBUFFER, FAR *LPSGBUFFER;


/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

/*
 * Callback for IDirectPlay2::EnumSessions
 */
typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK2)(
    LPCDPSESSIONDESC2   lpThisSD,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags,
    LPVOID              lpContext );

/*
 * This flag is set on the EnumSessions callback dwFlags parameter when
 * the time out has occurred. There will be no session data for this 
 * callback. If *lpdwTimeOut is set to a non-zero value and the 
 * EnumSessionsCallback function returns TRUE then EnumSessions will 
 * continue waiting until the next timeout occurs. Timeouts are in 
 * milliseconds.
 */
#define DPESC_TIMEDOUT          0x00000001


/*
 * Callback for IDirectPlay2::EnumPlayers
 *              IDirectPlay2::EnumGroups
 *              IDirectPlay2::EnumGroupPlayers
 */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK2)(
    DPID            dpId,
    DWORD           dwPlayerType,
    LPCDPNAME       lpName,
    DWORD           dwFlags,
    LPVOID          lpContext );


/*
 * Unicode callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for Unicode strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID      lpguidSP,
    LPWSTR      lpSPName,
    DWORD       dwMajorVersion,
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * ANSI callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for ANSI strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACKA)(
    LPGUID      lpguidSP,
    LPSTR       lpSPName,
    DWORD       dwMajorVersion,     
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * Callback for IDirectPlay3(A)::EnumConnections
 */
typedef BOOL (FAR PASCAL * LPDPENUMCONNECTIONSCALLBACK)(
    LPCGUID     lpguidSP,
	LPVOID		lpConnection,
	DWORD		dwConnectionSize,
    LPCDPNAME   lpName,
	DWORD 		dwFlags,
	LPVOID 		lpContext);


/*
 * API's
 */

#ifdef UNICODE
#define DirectPlayEnumerate     DirectPlayEnumerateW
#else
#define DirectPlayEnumerate     DirectPlayEnumerateA
#endif // UNICODE

extern HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA, LPVOID );
extern HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK, LPVOID );
extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay2
DECLARE_INTERFACE_( IDirectPlay2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay2 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay2_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay2_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay2_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay2_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)

#else /* C++ */

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay2_AddRef(p)                      (p)->AddRef()
#define IDirectPlay2_Release(p)                     (p)->Release()
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay2_Close(p)                       (p)->Close()
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay2_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay3
DECLARE_INTERFACE_( IDirectPlay3, IDirectPlay2 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
	STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
	STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
	STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
	STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
	STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
	STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
	STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay3 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay3_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay3_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay3_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay3_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)

#else /* C++ */

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay3_AddRef(p)                      (p)->AddRef()
#define IDirectPlay3_Release(p)                     (p)->Release()
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay3_Close(p)                       (p)->Close()
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay3_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay4 (and IDirectPlay4A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay4
DECLARE_INTERFACE_( IDirectPlay4, IDirectPlay3 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
    STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
    STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
    STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
    STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
    STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    /*** IDirectPlay4 methods ***/
    STDMETHOD(GetGroupOwner)        (THIS_ DPID, LPDPID) PURE;
    STDMETHOD(SetGroupOwner)        (THIS_ DPID, DPID) PURE;
    STDMETHOD(SendEx)               (THIS_ DPID, DPID, DWORD, LPVOID, DWORD, DWORD, DWORD, LPVOID, DWORD_PTR *) PURE;
    STDMETHOD(GetMessageQueue)      (THIS_ DPID, DPID, DWORD, LPDWORD, LPDWORD) PURE;
    STDMETHOD(CancelMessage)        (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(CancelPriority)       (THIS_ DWORD, DWORD, DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayX interface macros (for IDirectPlay4 and beyond)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayX_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayX_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->lpVtbl->CancelMessage(p,a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->lpVtbl->CancelPriority(p,a,b,c)
#define IDirectPlayX_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->lpVtbl->GetMessageQueue(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlayX_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->lpVtbl->SendEx(p,a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->lpVtbl->GetGroupOwner(p,a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->lpVtbl->SetGroupOwner(p,a,b)

#else /* C++ */

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayX_AddRef(p)                      (p)->AddRef()
#define IDirectPlayX_Release(p)                     (p)->Release()
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->CancelMessage(a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->CancelPriority(a,b,c)
#define IDirectPlayX_Close(p)                       (p)->Close()
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->GetMessageQueue(a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlayX_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->SendEx(a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->GetGroupOwner(a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->SetGroupOwner(a,b)

#endif

/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/

/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002


/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/

/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMPLAYERS_PREVIOUS   0x00000004
 */
//@@END_MSINTERNAL

/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800

/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000


/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           DPENUMPLAYERS_SERVERPLAYER

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              DPENUMPLAYERS_SPECTATOR

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  DPENUMPLAYERS_LOCAL

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   DPENUMPLAYERS_OWNER

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * This flag indicates that the subgroup was added to the group
 * instead of created in it.
 */
#define DPGROUP_SHORTCUT                DPENUMGROUPS_SHORTCUT
//@@END_MSINTERNAL

/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             DPENUMGROUPS_STAGINGAREA

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   DPENUMGROUPS_LOCAL

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   DPENUMGROUPS_HIDDEN


/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMSESSIONS_PREVIOUS     0x00000004
 */
//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
/*
 * Private for dplay use only.  Used by DPConnect.
 * Don't free the responses from previous enums
 */
 #define DPENUMSESSIONS_NOREFRESH	0x00000008
//@@END_MSINTERNAL

/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/

/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001


/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
 #define DPOPEN_RETURNSTATUS		DPENUMSESSIONS_RETURNSTATUS

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL


/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION					DPOPEN_CREATE

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION					DPOPEN_JOIN

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/

/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008


/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001

//@@BEGIN_MSINTERNAL
/*
 * Do not delete the DPSEND_HIGHPRIORITY, DPSEND_OPENSTREAM or
 * DPSEND_CLOSESTREAM flags so we don't cause compile errors
 * in apps written for DX3 that use them.
 */
//@@END_MSINTERNAL

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * Indicates that the message was on the pending queue
 */
#define DPSEND_PENDING              0x00000100
//@@END_MSINTERNAL

/*
 * Send message asynchronously, must check caps
 * before using this flag.  It is always provided
 * if the protocol flag is set.
 */
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400

//@@BEGIN_MSINTERNAL
/*
 * To make some system messages proceed asynchronously
 */
#define DPSEND_SYSMESS              (DPSEND_GUARANTEE|DPSEND_ASYNC)
//@@END_MSINTERNAL

/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRI              0x0000FFFF
#define DPSEND_MAX_PRIORITY         DPSEND_MAX_PRI

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPSEND_GUARANTEE            DPSEND_GUARANTEED
 * #define DPSEND_HIGHPRIORITY         0x00000002
 * #define DPSEND_TRYONCE              0x00000004
 */
 
/* This flag is used only for testing DPlay.
 *
 * When doing an async send, indicates that ownership of the
 * message buffers is passed to directplay.  Otherwise
 * DirectPlay must copy the buffer for an async send.
 */
#define DPSEND_NOCOPY               0x00000800

//@@END_MSINTERNAL

/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/

/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002


/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL
 
/*
 * Start an asynchronous connect which returns status codes
 */
#define DPCONNECT_RETURNSTATUS      (DPENUMSESSIONS_RETURNSTATUS)


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d


/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct
{
    DWORD       dwType;         // Message type
} DPMSG_GENERIC, FAR *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP, FAR *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP, FAR *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP, FAR *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     FAR *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP, FAR *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     FAR *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA, FAR *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME, FAR *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC, FAR *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          FAR *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   FAR *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct 
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE, FAR *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION, FAR *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT, FAR *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER, FAR *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	HRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE, *LPDPMSG_SENDCOMPLETE;

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           S_OK
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL
#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_INVALIDGROUP             	MAKE_DPHRESULT( 155 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_PENDING					E_PENDING
#define DPERR_SENDTOOBIG				MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 
#define DPERR_NOINTERFACE               E_NOINTERFACE
#define DPERR_CANNOTCREATESERVER        MAKE_DPHRESULT( 290 )
#define DPERR_PLAYERLOST                MAKE_DPHRESULT( 300 )
#define DPERR_SESSIONLOST               MAKE_DPHRESULT( 310 )
#define DPERR_UNINITIALIZED             MAKE_DPHRESULT( 320 )
#define DPERR_NONEWPLAYERS              MAKE_DPHRESULT( 330 )
#define DPERR_INVALIDPASSWORD           MAKE_DPHRESULT( 340 )
#define DPERR_CONNECTING                MAKE_DPHRESULT( 350 )
#define DPERR_CONNECTIONLOST            MAKE_DPHRESULT( 360 )
#define DPERR_UNKNOWNMESSAGE            MAKE_DPHRESULT( 370 )
#define DPERR_CANCELFAILED              MAKE_DPHRESULT( 380 )
#define DPERR_INVALIDPRIORITY           MAKE_DPHRESULT( 390 )
#define DPERR_NOTHANDLED                MAKE_DPHRESULT( 400 )
#define DPERR_CANCELLED                 MAKE_DPHRESULT( 410 )
#define DPERR_ABORTED                   MAKE_DPHRESULT( 420 )


#define DPERR_BUFFERTOOLARGE            MAKE_DPHRESULT( 1000 )
#define DPERR_CANTCREATEPROCESS         MAKE_DPHRESULT( 1010 )
#define DPERR_APPNOTSTARTED             MAKE_DPHRESULT( 1020 )
#define DPERR_INVALIDINTERFACE          MAKE_DPHRESULT( 1030 )
#define DPERR_NOSERVICEPROVIDER         MAKE_DPHRESULT( 1040 )
#define DPERR_UNKNOWNAPPLICATION        MAKE_DPHRESULT( 1050 )
#define DPERR_NOTLOBBIED                MAKE_DPHRESULT( 1070 )
#define DPERR_SERVICEPROVIDERLOADED		MAKE_DPHRESULT( 1080 )
#define DPERR_ALREADYREGISTERED			MAKE_DPHRESULT( 1090 )
#define DPERR_NOTREGISTERED				MAKE_DPHRESULT( 1100 )

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      MAKE_DPHRESULT(  2000 )
#define DPERR_CANTLOADSSPI              MAKE_DPHRESULT(  2010 )
#define DPERR_ENCRYPTIONFAILED          MAKE_DPHRESULT(  2020 )
#define DPERR_SIGNFAILED                MAKE_DPHRESULT(  2030 )
#define DPERR_CANTLOADSECURITYPACKAGE   MAKE_DPHRESULT(  2040 )
#define DPERR_ENCRYPTIONNOTSUPPORTED    MAKE_DPHRESULT(  2050 )
#define DPERR_CANTLOADCAPI              MAKE_DPHRESULT(  2060 )
#define DPERR_NOTLOGGEDIN               MAKE_DPHRESULT(  2070 )
#define DPERR_LOGONDENIED               MAKE_DPHRESULT(  2080 )


/****************************************************************************
 *
 * 	dplay 1.0 obsolete structures + interfaces
 *	Included for compatibility only. New apps should
 *	use IDirectPlay2
 *
 ****************************************************************************/

// define this to ignore obsolete interfaces and constants
#ifndef IDIRECTPLAY2_OR_GREATER

#define DPOPEN_OPENSESSION          DPOPEN_JOIN
#define DPOPEN_CREATESESSION        DPOPEN_CREATE

#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_PREVIOUS      0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect 
 * in the code
 */
//@@END_MSINTERNAL
#define DPSEND_GUARANTEE            DPSEND_GUARANTEED
#define DPSEND_TRYONCE              0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code
 */
//@@END_MSINTERNAL
#define DPCAPS_NAMESERVICE          0x00000001
#define DPCAPS_NAMESERVER           DPCAPS_ISHOST
#define DPCAPS_GUARANTEED           0x00000004

#define DPLONGNAMELEN               52
#define DPSHORTNAMELEN              20
#define DPSESSIONNAMELEN            32
#define DPPASSWORDLEN               16
#define DPUSERRESERVED              16

#define DPSYS_ADDPLAYER             0x0003
#define DPSYS_DELETEPLAYER          0x0005

#define DPSYS_DELETEGROUP           0x0020
#define DPSYS_DELETEPLAYERFROMGRP   0x0021
#define DPSYS_CONNECT               0x484b

typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef BOOL (PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  
    DWORD_PTR dwSession;                    
    DWORD   dwMaxPlayers;                 
    DWORD   dwCurrentPlayers;             
    DWORD   dwFlags;                      
    char    szSessionName[DPSESSIONNAMELEN];
    char    szUserField[DPUSERRESERVED];
    DWORD_PTR   dwReserved1;                  
    char    szPassword[DPPASSWORDLEN];    
    DWORD_PTR   dwReserved2;                  
    DWORD_PTR   dwUser1;
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC,*LPDPSESSIONDESC;

typedef BOOL (PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC lpDPSessionDesc,
    LPVOID      lpContext,
    LPDWORD     lpdwTimeOut,
    DWORD       dwFlags);

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD_PTR, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD_PTR, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};

/****************************************************************************
 *
 * IDirectPlay interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay_Close(p)                        (p)->lpVtbl->Close(p)
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->lpVtbl->CreateGroup(p,a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->lpVtbl->CreatePlayer(p,a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->lpVtbl->EnableNewPlayers(p,a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->lpVtbl->GetPlayerCaps(p,a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->lpVtbl->GetPlayerName(p,a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay_Open(p,a)                       (p)->lpVtbl->Open(p,a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->lpVtbl->SaveSession(p,a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->lpVtbl->SetPlayerName(p,a,b,c)

#else /* C++ */

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->AddPlayerToGroup(a,b)
#define IDirectPlay_Close(p)                        (p)->Close()
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->CreateGroup(a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->CreatePlayer(a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->DestroyGroup(a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->DestroyPlayer(a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->EnableNewPlayers(a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->EnumGroupPlayers(a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->EnumGroups(a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->GetMessageCount(a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->GetPlayerCaps(a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->GetPlayerName(a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->Initialize(a)
#define IDirectPlay_Open(p,a)                       (p)->Open(a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->Receive(a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->SaveSession(a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->Send(a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->SetPlayerName(a,b,c)

#endif

DEFINE_GUID(IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);

#endif // IDIRECTPLAY2_OR_GREATER

/****************************************************************************
 *
 * IDirectPlay macros (included regardless of IDIRECTPLAY2_OR_GREATER flag)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectPlay_Release(p)                      (p)->lpVtbl->Release(p)

#else

#define IDirectPlay_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectPlay_AddRef(p)                       (p)->AddRef()
#define IDirectPlay_Release(p)                      (p)->Release()

#endif // IDirectPlay interface macros 

#ifdef __cplusplus
};
#endif

/* restore warning settings */
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpdvtran.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpdvtran.c
 *  Content:	implements the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08/02/99	aarono	created it
 *  08/03/99	rodtoll	Modified notification table compaction algorithm
 *  08/04/99	aarono  Added IsValidEntity
 *  08/05/99    aarono  Moved voice over to DPMSG_VOICE
 *  08/10/99	rodtoll	Modified Notify so it does not notify new clients
 *                      who were created as a result of the notification.
 *	08/25/99	rodtoll	Implemented group membership check
 *	08/26/99	rodtoll	Added lock release to group membership check
 *  09/01/99	rodtoll	Added error checks in GetSession
 *  09/09/99	rodtoll	Updated to use new host migrating retrofit.for retrofit
 *				rodtoll	Added retrofit monitor thread
 *	09/10/99	rodtoll	Adjusted GetSessionInfo to call new DV_GetIDS func
 *  09/20/99	rodtoll	Updated to check for Protocol flag & ensure nopreserveorder is not specified
 *  10/05/99	rodtoll	Fixed check for dplay protocol, was missing a LEAVE_ALL()
 *  10/19/99	rodtoll	Fix: Bug #113904 - Lockup if StartSession fails in voice and
 *                      then Release is called on dplay object.
 * 	10/25/99	rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate 
 *  11/02/99	rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
 *  11/17/99	rodtoll	Fix: Bug #119585 - Connect failure cases return incorrect error codes
 *  11/23/99	rodtoll	Updated case where dplay not init to return DPVERR_TRANSPORTNOTINIT
 *  12/16/99	rodtoll Fix: Bug #122629 Fixed lockup exposed by new host migration
 *  01/14/00	rodtoll	Updated to return DV_OK when DVERR_PENDING is the error.
 *  01/20/00	rodtoll	Added DV_IsValidGroup / DV_IsValidPlayer to conform to new transport interface
 * 04/06/00     rodtoll Updated to match new approach to having only 1 voice server and 1 client attached to object
 *  04/06/00    rodtoll Updated code to return voice messages to layer immediately.  
 *  04/07/00    rodtoll Fixed Bug #32179 - Registering > 1 interface
 *              rodtoll Added support for nocopy sends (for voice)
 *  04/21/00    rodtoll Fixed crash when migrating because buffer was returned which wasn't from pool
 *  07/22/00	rodtoll	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  	Now for a thread to make an indication into voice they addref the interface
 *						so that the voice core can tell when all indications have returned.   
 *  07/31/00	rodtoll	Bug #41135 - Shutdown lockup -- now does not addref if notification
 *						is a session lost.  Added AddRefs() for VoiceReceive
 *
 ***************************************************************************/

#include "dplaypr.h"
#include "newdpf.h"
#include "dvretro.h"

VOID ClearTargetList(LPDPLAYI_DPLAY this);
HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags );

#undef DPF_MODNAME
#define DPF_MODNAME "DVoice"

// Notify all registered voice clients of an event.
VOID DVoiceNotify(LPDPLAYI_DPLAY this, DWORD dw1, DWORD_PTR dw2, DWORD_PTR dw3, DWORD dwObjectType )
{
	DWORD i;
	HRESULT hr;
	DVPROTOCOLMSG_IAMVOICEHOST dvMsg;
	DVTRANSPORT_BUFFERDESC dvBufferDesc;

	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification

	DPF(3,"DVoiceNotify this %x, dw1=%x, dw2=%x, dw3=%x\n",this,dw1,dw2,dw3);
	DPF(3,"gnDPCScount=%x\n",gnDPCSCount);

	// Grab a reference so we don't destroy voice end before all of these notifies have returned  
   	EnterCriticalSection( &this->csNotify );
	pClient = this->lpDxVoiceNotifyClient;
	pServer = this->lpDxVoiceNotifyServer;

	if( dw1 != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->lpVtbl->AddRef( pClient );

		if( pServer )
			pServer->lpVtbl->AddRef( pServer );
	}	
	
	LeaveCriticalSection( &this->csNotify );
	

	if( pClient != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    this->lpDxVoiceNotifyClient->lpVtbl->NotifyEvent( this->lpDxVoiceNotifyClient, dw1, dw2, dw3 );
    }

    if( pServer != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
    {
        this->lpDxVoiceNotifyServer->lpVtbl->NotifyEvent( this->lpDxVoiceNotifyServer, dw1, dw2, dw3 );
    }	
	
	// Handle addplayer events if I'm the host
	if( dw1 == DVEVENT_ADDPLAYER && this->bHost )
	{
		DPF( 1, "DVoiceNotify: A player was added and I'm the host.  Inform their dplay to launch connection" );

		dvMsg.bType = DVMSGID_IAMVOICEHOST;
		dvMsg.dpidHostID = this->dpidVoiceHost;

		ENTER_ALL();

        memset( &dvBufferDesc, 0x00, sizeof( DVTRANSPORT_BUFFERDESC ) );
		dvBufferDesc.dwBufferSize = sizeof( dvMsg );
		dvBufferDesc.pBufferData = (PBYTE) &dvMsg;
		dvBufferDesc.dwObjectType = 0;
		dvBufferDesc.lRefCount = 1;
		
		hr = DV_InternalSend( this, this->dpidVoiceHost , (DVID)dw2,&dvBufferDesc, NULL, DVTRANSPORT_SEND_GUARANTEED );

		if( hr != DVERR_PENDING && FAILED( hr ) )
		{
			DPF( 0, "DV_InternalSend Failed on I am host voice message hr=0x%x", hr );
		}

		LEAVE_ALL();
	}

	if(dw1 == DVEVENT_ADDPLAYERTOGROUP || dw1 == DVEVENT_REMOVEPLAYERFROMGROUP)
	{
		ENTER_ALL();
		ClearTargetList(this);
		LEAVE_ALL();
	}		

	if( dw1 != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->lpVtbl->Release( pClient );

		if( pServer )
			pServer->lpVtbl->Release( pServer );
	}
}

// Notify all registered voice clients of an event.
VOID DVoiceReceiveSpeechMessage(LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, LPVOID lpvBuffer, DWORD cbBuffer)
{
	UINT i;
	LPDVPROTOCOLMSG_IAMVOICEHOST lpdvmVoiceHost;
	HRESULT hr;

	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;

   	EnterCriticalSection( &this->csNotify );
	pClient = this->lpDxVoiceNotifyClient;
	pServer = this->lpDxVoiceNotifyServer;

	if( pClient )
		pClient->lpVtbl->AddRef(pClient);

	if( pServer )
		pServer->lpVtbl->AddRef(pServer);
	
   	LeaveCriticalSection( &this->csNotify );

	if( pClient != NULL )
	{
	    this->lpDxVoiceNotifyClient->lpVtbl->ReceiveSpeechMessage( this->lpDxVoiceNotifyClient, dvidFrom, dvidTo, lpvBuffer, cbBuffer );
    }

    if( pServer != NULL )
    {
        this->lpDxVoiceNotifyServer->lpVtbl->ReceiveSpeechMessage( this->lpDxVoiceNotifyServer, dvidFrom, dvidTo, lpvBuffer, cbBuffer );
    }
    
	lpdvmVoiceHost = (LPDVPROTOCOLMSG_IAMVOICEHOST) lpvBuffer;

	// If the message we received was i am voice server, then
	// launch the hack..
	if( lpdvmVoiceHost->bType == DVMSGID_IAMVOICEHOST )
	{
		// Check to ensure hack is enabled on this PC
		if( this->fLoadRetrofit )
		{
			this->dpidVoiceHost = lpdvmVoiceHost->dpidHostID;
			
			hr = DV_RunHelper( this, lpdvmVoiceHost->dpidHostID, FALSE );

			if( FAILED( hr ) )
			{
				DPF( 0, "DV_RunHelper Failed hr=0x%x", hr );
			}
		}
	}

	if( pClient )
		pClient->lpVtbl->Release(pClient);

	if( pServer )
		pServer->lpVtbl->Release(pServer);
	
}

HRESULT DV_Advise(LPDIRECTPLAY lpDP, LPUNKNOWN lpUnk, DWORD dwObjectType)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
    DPCAPS dpCaps;

    hr = DV_OK;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	if( this->lpsdDesc == NULL )
	{
		DPF_ERR( "No session has been started" );
		LEAVE_ALL();

		return DVERR_TRANSPORTNOSESSION;
	}

    if( this->lpsdDesc->dwFlags & DPSESSION_NOPRESERVEORDER )
    {
    	DPF_ERR( "Cannot run with nopreserveorder flag" );
    	LEAVE_ALL();
    	return DVERR_NOTSUPPORTED;
    }

    if( !(this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) &&
        !(this->dwSPFlags & DPCAPS_ASYNCSUPPORTED ) )
    {
    	DPF_ERR( "No async sends available" );
    	LEAVE_ALL();
    	return DVERR_NOTSUPPORTED;
    }
        
	// Make sure we're not running with the order not important flag
	if( !(this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) ||
	    (this->lpsdDesc->dwFlags & DPSESSION_NOPRESERVEORDER) )
	{
		DPF_ERR("Cannot run without protocol or with no preserve order flag" );
		LEAVE_ALL();
		return DVERR_NOTSUPPORTED;
	}

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
	    if( this->lpDxVoiceNotifyServer != NULL )
	    {
	        DPF( 0, "There is already a server interface registered on this object" );
	        hr = DVERR_GENERIC;
	    }
	    else
	    {
	    	EnterCriticalSection( &this->csNotify );
	        hr = lpUnk->lpVtbl->QueryInterface( lpUnk, &IID_IDirectPlayVoiceNotify, (void **) &this->lpDxVoiceNotifyServer );

	        if( FAILED( hr ) )
	        {
	            DPF( 0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = this->lpDxVoiceNotifyServer->lpVtbl->Initialize(this->lpDxVoiceNotifyServer);

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    this->lpDxVoiceNotifyServer->lpVtbl->Release( this->lpDxVoiceNotifyServer );
            	    this->lpDxVoiceNotifyServer = NULL;
            	}
	        }
	    	LeaveCriticalSection( &this->csNotify );	        
	    }
	    
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
    	EnterCriticalSection( &this->csNotify );	
	    if( this->lpDxVoiceNotifyClient != NULL )
	    {
	        DPF( 0, "There is already a client interface registered on this object" );
	        hr = DVERR_GENERIC;
	    }
	    else
	    {
	        hr = lpUnk->lpVtbl->QueryInterface( lpUnk, &IID_IDirectPlayVoiceNotify, (void **) &this->lpDxVoiceNotifyClient );

	        if( FAILED( hr ) )
	        {
	            DPF( 0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = this->lpDxVoiceNotifyClient->lpVtbl->Initialize(this->lpDxVoiceNotifyClient);

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    this->lpDxVoiceNotifyClient->lpVtbl->Release( this->lpDxVoiceNotifyClient );
            	    this->lpDxVoiceNotifyClient = NULL;
            	}
	        }
	    }	    
    	LeaveCriticalSection( &this->csNotify );	        
	}
	else
	{
	    DPF( 0, "Error: Invalid object type specified in advise" );
	    ASSERT( FALSE );
	    hr = DVERR_GENERIC;
	}	

    LEAVE_ALL();
    
	return hr;
}

HRESULT DV_UnAdvise(LPDIRECTPLAY lpDP, DWORD dwObjectType)
{
	DWORD dwIndex;
    LPDPLAYI_DPLAY this;
	HRESULT hr;
    
//	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
	//		LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		//LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			 

   	EnterCriticalSection( &this->csNotify );
    
	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
        if( this->lpDxVoiceNotifyServer != NULL )
	    {
    	    this->lpDxVoiceNotifyServer->lpVtbl->Release( this->lpDxVoiceNotifyServer );
    	    this->lpDxVoiceNotifyServer = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No server currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( this->lpDxVoiceNotifyClient != NULL )
	    {
    	    this->lpDxVoiceNotifyClient->lpVtbl->Release( this->lpDxVoiceNotifyClient );
    	    this->lpDxVoiceNotifyClient = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No client currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else
	{
	    DPF( 0, "Could not find interface to unadvise" );
	    hr = DVERR_GENERIC;
	}

   	LeaveCriticalSection( &this->csNotify );
	
//    LEAVE_ALL();
    
	return DP_OK;
}

HRESULT DV_IsGroupMember(LPDIRECTPLAY lpDP, DVID dvidGroup, DVID dvidPlayer)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;
	DWORD nPlayers;	
	DWORD i;

	// Shortcut for when target is all
	if( dvidGroup == DPID_ALLPLAYERS )
		return DP_OK;

   	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

		pGroup = GroupFromID(this,dvidGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			LEAVE_ALL();
			return DPERR_INVALIDGROUP;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			

    // any players to enumerate ?
    if (!pGroup->pGroupnodes || (0 == pGroup->nPlayers))
    {
    	LEAVE_ALL();
    	return E_FAIL;
    }

    pGroupnode = pGroup->pGroupnodes;
	nPlayers = pGroup->nPlayers;
	
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pGroupnode);
        
        if( pGroupnode->pPlayer->dwID == dvidPlayer )
        {
        	LEAVE_ALL();
        	return DP_OK;
        }

        pGroupnode=pGroupnode->pNextGroupnode;
    }

    LEAVE_ALL();    
    
	return E_FAIL;

}

// ASSUMES: ENTER_ALL() lock
HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags )
{
    HRESULT hr;

	LPDPLAYI_PLAYER pPlayerFrom,pPlayerTo;
	LPDPLAYI_GROUP pGroupTo;
	CHAR SendBuffer[2048];
	LPMSG_VOICE pMsgVoice;
	PCHAR pVoiceData;
	DWORD dwSendSize;
	DWORD dwDirectPlayFlags;
    // Send immediate completion of voice send.
	DVEVENTMSG_SENDCOMPLETE dvSendComplete;	

	dwSendSize = *((DWORD *) pBufferDesc->pBufferData);

	TRY
	{
		// check src player        
		pPlayerFrom = PlayerFromID(this,dvidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad voice player from");
    		return DPERR_INVALIDPLAYER;
		}
		
		if(pPlayerFrom->dwFlags&DPLAYI_PLAYER_SYSPLAYER){
			DPF(0,"Sendint From System Player pPlayerFrom %x?\n",pPlayerFrom);
    		return DPERR_INVALIDPLAYER;
		}

		// see if it's a player or group
		pPlayerTo = PlayerFromID(this,dvidTo);
		if (VALID_DPLAY_PLAYER(pPlayerTo)) 
		{		  
			pGroupTo = NULL;
		}
		else 
		{
			pGroupTo = GroupFromID(this,dvidTo);
			if (VALID_DPLAY_GROUP(pGroupTo)) 
			{
				pPlayerTo = NULL;
			}
			else 
			{
				// bogus id! - player may have been deleted...
				DPF_ERRVAL("bad voice player to %x\n",dvidTo);
				return DPERR_INVALIDPLAYER;
			}// not player or group
		} // group
	
	}
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;	
	}

	pMsgVoice=(LPMSG_VOICE)(SendBuffer+this->dwSPHeaderSize);
	pVoiceData=(PCHAR)(pMsgVoice+1);
	dwSendSize=pBufferDesc->dwBufferSize+sizeof(MSG_VOICE)+this->dwSPHeaderSize;

	SET_MESSAGE_HDR(pMsgVoice);
	SET_MESSAGE_COMMAND(pMsgVoice,DPSP_MSG_VOICE);
	pMsgVoice->dwIDTo=dvidTo;
	pMsgVoice->dwIDFrom=dvidFrom;
	memcpy(pVoiceData,pBufferDesc->pBufferData,pBufferDesc->dwBufferSize);

	dwDirectPlayFlags = 0;

	if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	{
		dwDirectPlayFlags |= DPSEND_GUARANTEED;
	}

	dwDirectPlayFlags |= DPSEND_ASYNC;

	// Loopback for client in same process as server case
    if( dvidFrom == dvidTo )
    {
    	hr = DV_OK;
		DVoiceReceiveSpeechMessage(this, dvidFrom, dvidTo, pBufferDesc->pBufferData, pBufferDesc->dwBufferSize);
    } else {
	    if(pPlayerTo){
			hr=SendDPMessage(this,pPlayerFrom,pPlayerTo,SendBuffer,dwSendSize,dwDirectPlayFlags,FALSE);		
		} else {
			// must be a group message
			ASSERT(pGroupTo);
			hr=SendGroupMessage(this,pPlayerFrom,pGroupTo,dwDirectPlayFlags,SendBuffer,dwSendSize,FALSE);
		}
	}

	// Sync messages don't generate callbacks
	if( !(dwFlags & DVTRANSPORT_SEND_SYNC) )
	{
		if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
		{
    		dvSendComplete.pvUserContext = pvUserContext;
    		dvSendComplete.hrSendResult = DV_OK;

    		DVoiceNotify( this, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType );
		}
	}

	return hr;
	
}

HRESULT DV_SendSpeech(LPDIRECTPLAY lpDP, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }	

    pBufferDesc->lRefCount = 1;

    hr = DV_InternalSend( this, dvidFrom, dvidTo, pBufferDesc, pvContext, dwFlags );

    if( hr == DPERR_PENDING )
    	hr = DV_OK;

    LEAVE_ALL();

    return hr;
}

/////////////////////////////////////////
// Support Routinesfor DV_SendSpeechEx //
/////////////////////////////////////////

VOID ClearTargetList(LPDPLAYI_DPLAY this)
{
	this->nTargets=0;
}

VOID ClearExpandedTargetList(LPDPLAYI_DPLAY this)
{
	this->nExpandedTargets=0;
}

HRESULT AddExpandedTargetListEntry(LPDPLAYI_DPLAY this, DPID dpid)
{
	#define GROW_SIZE 16
	
	LPDPID pdpid;
	
	if(this->nExpandedTargets == this->nExpandedTargetListLen){
		// Need more room, allocate another 16 entries

		pdpid=DPMEM_ALLOC((this->nExpandedTargetListLen+GROW_SIZE)*sizeof(DPID));

		if(!pdpid){
			return DPERR_NOMEMORY;
		}
		
		if(this->pExpandedTargetList){
			memcpy(pdpid, this->pExpandedTargetList, this->nExpandedTargetListLen*sizeof(DPID));
			DPMEM_FREE(this->pExpandedTargetList);
		}
		this->pExpandedTargetList = pdpid;
		this->nExpandedTargetListLen += GROW_SIZE;
	}

	this->pExpandedTargetList[this->nExpandedTargets++]=dpid;

	return DP_OK;

	#undef GROW_SIZE
}

void AddIfNotAlreadyFound( LPDPLAYI_DPLAY this, DPID dpidID )
{
	DWORD j;
	
	for(j=0;j<this->nExpandedTargets;j++)
	{
		if( this->pExpandedTargetList[j] == dpidID )
		{
			break;
		}
	}

	// It was not found, add him to the list
	if( j == this->nExpandedTargets )
	{
		AddExpandedTargetListEntry(this, dpidID);							
	}
}

HRESULT ExpandTargetList(LPDPLAYI_DPLAY this, DWORD nTargets, PDVID pdvidTo)
{
	HRESULT hr=DP_OK;
	UINT i, j;

	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;	

	// See if we need to change the expanded target list or we have it cached.
	
	if(nTargets != this->nTargets || memcmp(pdvidTo, this->pTargetList, nTargets * sizeof(DVID))){

		DPF(9, "ExpandTargetList, new list re-building cached list\n");
		
		// the target list is wrong, rebuild it.
		// First copy the new target list...
		if(nTargets > this->nTargetListLen){
			// Current list is too small, possibly non-existant, allocate one to cache the list.
			if(this->pTargetList){
				DPMEM_FREE(this->pTargetList);
			}
			this->pTargetList=(PDVID)DPMEM_ALLOC(nTargets * sizeof(DVID));
			if(this->pTargetList){
				this->nTargetListLen=nTargets;
			} else {
				this->nTargetListLen=0;
				this->nTargets=0;
				hr=DPERR_NOMEMORY;
				DPF(0,"Ran out of memory trying to cache target list!\n");
				goto exit;
			}
		}
		this->nTargets = nTargets;
		memcpy(this->pTargetList, pdvidTo, nTargets*sizeof(DPID));

		// OK we have the target list cached, now build the list we are going to send to.
		ClearExpandedTargetList(this);
		for(i=0;i<this->nTargets;i++)
		{
			// Multicast Code
			// MANBUG 31013 Revisit when we have a group optimized provider
			if( this->dwSPFlags & DPCAPS_GROUPOPTIMIZED )
			{
				ASSERT( FALSE );				
			}
			
			pPlayer = (LPDPLAYI_PLAYER)NameFromID(this,this->pTargetList[i]);

			// We only want valid player/groups
			if( pPlayer )
			{
				if( pPlayer->dwSize == sizeof( DPLAYI_PLAYER ) )
				{
					AddIfNotAlreadyFound( this, this->pTargetList[i] );
				}
				else
				{
					DWORD nPlayers;	

					pGroup = (LPDPLAYI_GROUP) pPlayer;

				    // any players to enumerate ?
				    if (pGroup->pGroupnodes && pGroup->nPlayers )
				    {
					    pGroupnode = pGroup->pGroupnodes;
						nPlayers = pGroup->nPlayers;
						
					    for (j=0; j < nPlayers; j++)
					    {
					        ASSERT(pGroupnode);
					        AddIfNotAlreadyFound( this, pGroupnode->pPlayer->dwID );
					        pGroupnode=pGroupnode->pNextGroupnode;
					    }
					 }
				}
			}
			
		}

	} else {
		DPF(9,"ExpandTargetList, using cached list\n");
	}

exit:
	return hr;
}

// DV_SendSpeechEx

HRESULT DV_SendSpeechEx(LPDIRECTPLAY lpDP, DVID dvidFrom, DWORD nTargets, PDVID pdvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	UINT i;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }	


	hr=ExpandTargetList(this, nTargets, pdvidTo);

	if(hr != DP_OK){
		goto exit;
	}

	pBufferDesc->lRefCount = this->nExpandedTargets;

	// Send to our expanded and duplicate removed list.
	for(i=0; i < this->nExpandedTargets; i++){

	    hr = DV_InternalSend( this, dvidFrom, this->pExpandedTargetList[i], pBufferDesc, pvContext, dwFlags );

	}    

exit:

    if( hr == DPERR_PENDING )
    	hr = DV_OK;

    LEAVE_ALL();

    return hr;
}

HRESULT DV_GetSessionInfo(LPDIRECTPLAY lpDP, LPDVTRANSPORTINFO lpdvTransportInfo )
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
    BOOL fLocalHost;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DVERR_TRANSPORTNOSESSION;
        }

        if( lpdvTransportInfo->dwSize < sizeof( DVTRANSPORTINFO ) )
        {
        	DPF_ERR( "Bad size of struct\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	lpdvTransportInfo->dwFlags = 0;

	if( this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER )
	{
		lpdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_CLIENTSERVER;
	}
	else
	{
		lpdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_PEERTOPEER;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_MULTICAST;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_MIGRATEHOST;		
	}

	lpdvTransportInfo->dvidLocalID = DPID_UNKNOWN;
	lpdvTransportInfo->dwMaxPlayers = 0;

	lpdvTransportInfo->dvidLocalID = DPID_UNKNOWN;
	lpdvTransportInfo->dvidSessionHost = DPID_UNKNOWN;

	// Needed, otherwise compiler is messing up this on the next call!
	fLocalHost = FALSE;

	hr = DV_GetIDS( this, &lpdvTransportInfo->dvidSessionHost, &lpdvTransportInfo->dvidLocalID, &fLocalHost  );

	if( FAILED( hr ) )
	{
		DPF( 0, "DV_GetIDS Failed: hr=0x%x", hr );
		LEAVE_ALL();
		return hr;
	}

	if( fLocalHost )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_LOCALHOST;
	}

    LEAVE_ALL();

	return DP_OK;

}

HRESULT DV_IsValidEntity (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

    // Players and groups have flags in the same location on their structure
    // so we don't need to check if its a player or a group to validate.
	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}

HRESULT DV_IsValidPlayer (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
		     pPlayer->dwSize == sizeof( DPLAYI_PLAYER ) ){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}

HRESULT DV_IsValidGroup (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
  			 pPlayer->dwSize == sizeof( DPLAYI_GROUP ) ){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}



#undef DPF_MODNAME
#define DPF_MODNMAE "HandleVoiceMessage"

HRESULT HandleVoiceMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize, DWORD dwSendFlags) 
{
	LPMSG_VOICE pmsg; // message cast from received buffer
	HRESULT hr=DP_OK;
	
	pmsg = (LPMSG_VOICE)pReceiveBuffer;

	LEAVE_DPLAY();
	ENTER_ALL();
	
	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return DVERR_TRANSPORTNOTINIT;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}

	// SECURITY
	if(dwMessageSize <= sizeof(MSG_VOICE))
	{
		goto exit;
	}

	DVoiceReceiveSpeechMessage(this, pmsg->dwIDFrom, pmsg->dwIDTo, (LPVOID)(pmsg+1), dwMessageSize-sizeof(MSG_VOICE));

exit:
	LEAVE_SERVICE();
	
	return DP_OK;
} // HandleVoiceMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	DPlay.DLL initialization
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *   1/16		andyco	ported from dplay to dp2
 *	11/04/96	myronth	added DPAsyncData crit section initialization
 *	2/26/97		myronth	removed DPAsyncData stuff
 *	3/1/97		andyco	added print verison string
 *	3/12/97		myronth	added LobbyProvider list cleanup
 *  3/12/97     sohailm added declarations for ghConnectionEvent,gpFuncTbl,gpFuncTblA,ghSecLib
 *                      replaced session desc string cleanup code with a call to FreeDesc()
 *	3/15/97		andyco	moved freesessionlist() -> freesessionlist(this) into dpunk.c
 *  5/12/97     sohailm renamed gpFuncTbl to gpSSPIFuncTbl and ghSecLib to ghSSPI.
 *                      added declarations for gpCAPIFuncTbl, ghCAPI.
 *                      added support to free CAPI function table and unload the library.
 *	6/4/97		kipo	bug #9453: added CloseHandle(ghReplyProcessed)
 *	8/22/97		myronth	Made a function out of the SPNode cleanup code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *   3/9/98     aarono  added init and delete of critical section for
 *                      packetize timeout list.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 * 07/26/00     aarono 	make application key r/w for everyone so dplay lobbied apps can be
 *                   	registered by non-admins.
 * 06/19/01     RichGr  DX8.0 added special security rights for "everyone" - remove them if they exist.
 ***************************************************************************/

#include "dplaypr.h"
#include "dpneed.h"
#include "dpmem.h"
#include "accctrl.h"
#include "dplobpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DLLMain"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime=TRUE;
LPCRITICAL_SECTION	gpcsDPlayCritSection,
					gpcsServiceCritSection,
					gpcsDPLCritSection,
					gpcsDPLQueueCritSection,
					gpcsDPLGameNodeCritSection;
BOOL gbWin95 = TRUE;
extern LPSPNODE gSPNodes;// from api.c
extern CRITICAL_SECTION g_SendTimeOutListLock; // from paketize.c

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request.
HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed, ghConnectionEvent;
#ifdef DEBUG
// count of dplay crit section
int gnDPCSCount; // count of dplay lock
#endif 
// global pointers to sspi function tables
PSecurityFunctionTableA	gpSSPIFuncTblA = NULL;  // Ansi
PSecurityFunctionTable	gpSSPIFuncTbl = NULL;   // Unicode
// global pointe to capi function table
LPCAPIFUNCTIONTABLE gpCAPIFuncTbl = NULL;

// sspi libaray handle, set when sspi is initialized
HINSTANCE ghSSPI=NULL;
// capi libaray handle, set when capi is initialized
HINSTANCE ghCAPI=NULL;


// free up the list of sp's built by directplayenum
HRESULT FreeSPList(LPSPNODE pspHead)
{
	LPSPNODE pspNext;

	while (pspHead)
	{
		// get the next node
		pspNext = pspHead->pNextSPNode;
		// free the current node
		FreeSPNode(pspHead);
		// repeat
		pspHead = pspNext;
	}
	
	return DP_OK;

} // FreeSPList

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MONOLITHIC BUILD REDIRECT FUNCTIONS
//

typedef HRESULT (WINAPI *PFN_DIRECTPLAYCREATE)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUM)(LPDPENUMDPCALLBACK lpEnumCallback,LPVOID lpContext);
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUMA)(LPDPENUMDPCALLBACKA lpEnumCallback,LPVOID lpContext );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_A)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_W)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

HMODULE ghRedirect = NULL;
PFN_DIRECTPLAYCREATE pfnDirectPlayCreate = NULL;
PFN_DIRECTPLAYENUMA pfnDirectPlayEnum = NULL;
PFN_DIRECTPLAYLOBBYCREATE_A pfnDirectPlayLobbyCreateA = NULL;
PFN_DIRECTPLAYLOBBYCREATE_W pfnDirectPlayLobbyCreateW = NULL;
PFN_DIRECTPLAYENUMA pfnDirectPlayEnumA = NULL;
PFN_DIRECTPLAYENUM pfnDirectPlayEnumW = NULL;
PFN_DLLGETCLASSOBJECT pfnGetClassObject = NULL;
PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow = NULL;

#ifdef DPLAY_LOADANDCHECKTRUE 

BOOL CheckForDPPrivateBit( DWORD dwBit )
{
    HKEY    hKey;
    LONG    lErr;
    DWORD	type;
    DWORD	cb;
    DWORD	id;
    DWORD	flags;
    BOOL    fResult;

    fResult = FALSE;
        
    lErr = OS_RegOpenKeyEx( DPLAY_LOADTREE_REGTREE, DPLAY_LOADTRUE_REGPATH,0,KEY_READ, &hKey );

    if( lErr != ERROR_SUCCESS )
    {
        return FALSE;
    }

    cb = sizeof(flags);

    lErr = RegQueryValueExA( hKey, DPLAY_LOADTRUE_REGKEY_A, NULL, &type, (LPSTR) &flags, &cb );

    if( type != REG_DWORD )
    {
        fResult = FALSE;
    }
    else if( flags & dwBit )
    {
        fResult = TRUE;
    }
    else
    {
        fResult = FALSE;
    }

    RegCloseKey( hKey );

    return fResult;
}

HRESULT InitializeRedirectFunctionTable()
{
    LONG lLastError;
    
    if( CheckForDPPrivateBit( DPLAY_LOADTRUE_BIT ) )
    {
        ghRedirect = OS_LoadLibrary( L"dplayx.dll" );

        if( ghRedirect == NULL )
        {
            lLastError = GetLastError();
            
            DPF( 0, "Could not load dplayx.dll error = 0x%x", lLastError );
			return DPERR_GENERIC;

        }

        pfnDirectPlayCreate = (PFN_DIRECTPLAYCREATE) GetProcAddress( ghRedirect, "DirectPlayCreate" );
        pfnDirectPlayEnum = (PFN_DIRECTPLAYENUMA) GetProcAddress( ghRedirect, "DirectPlayEnumerate" );
        pfnDirectPlayLobbyCreateA = (PFN_DIRECTPLAYLOBBYCREATE_A) GetProcAddress( ghRedirect, "DirectPlayLobbyCreateA" );
        pfnDirectPlayLobbyCreateW = (PFN_DIRECTPLAYLOBBYCREATE_W) GetProcAddress( ghRedirect, "DirectPlayLobbyCreateW" );
        pfnDirectPlayEnumA = (PFN_DIRECTPLAYENUMA) GetProcAddress( ghRedirect, "DirectPlayEnumerateA" );
        pfnDirectPlayEnumW = (PFN_DIRECTPLAYENUM) GetProcAddress( ghRedirect, "DirectPlayEnumerateW" );
		pfnGetClassObject = (PFN_DLLGETCLASSOBJECT) GetProcAddress( ghRedirect, "DllGetClassObject" );
		pfnDllCanUnLoadNow = (PFN_DLLCANUNLOADNOW) GetProcAddress( ghRedirect, "DllCanUnloadNow" );
    }

    return DP_OK;    
}

HRESULT FreeRedirectFunctionTable()
{
    if( ghRedirect != NULL )
        FreeLibrary( ghRedirect );

    return DP_OK;
}
#endif

#if 0
// walk the list of dplay objects, and shut 'em down!
HRESULT CleanUpObjectList()
{
#ifdef DEBUG	
	HRESULT hr;
#endif 	
	
	DPF_ERRVAL("cleaning up %d unreleased objects",gnObjects);
	while (gpObjectList)
	{
#ifdef DEBUG	
		hr = VALID_DPLAY_PTR(gpObjectList);
		// DPERR_UNINITIALIZED is a valid failure here...
		if (FAILED(hr) && (hr != DPERR_UNINITIALIZED))
		{
			DPF_ERR("bogus dplay in object list");
			ASSERT(FALSE);
		}
#endif 
		//		
		// when this returns 0, gpObjectList will be released
		// 
		while (DP_Release((LPDIRECTPLAY)gpObjectList->pInterfaces)) ;
	}

	return DP_OK;
		
} // CleanUpObjectList

#endif 

#ifdef DEBUG
void PrintVersionString(HINSTANCE hmod)
{
	LPBYTE 				pbVersion;
 	DWORD 				dwVersionSize;
	DWORD 				dwBogus; // for some reason, GetFileVersionInfoSize wants to set something
								// to 0.  go figure.
    DWORD				dwLength=0;
	LPSTR				pszVersion=NULL;

			
	dwVersionSize = GetFileVersionInfoSizeA("dplayx.dll",&dwBogus);
	if (0 == dwVersionSize )
	{
		DPF_ERR(" could not get version size");
		return ;
	}
	
	pbVersion = DPMEM_ALLOC(dwVersionSize);
	if (!pbVersion)
	{
		DPF_ERR("could not get version ! out of memory");
		return ;
	}
	
	if (!GetFileVersionInfoA("dplayx.dll",0,dwVersionSize,pbVersion))
	{
		DPF_ERR("could not get version info!");
		goto CLEANUP_EXIT;
	}

    if( !VerQueryValueA( pbVersion, "\\StringFileInfo\\040904E4\\FileVersion", (LPVOID *)&pszVersion, &dwLength ) )
    {
		DPF_ERR("could not query version");
		goto CLEANUP_EXIT;
    }

	OutputDebugStringA("\n");

    if( NULL != pszVersion )
    {
 		DPF(0," " "dplayx.dll" " - version = %s",pszVersion);
    }
	else 
	{
 		DPF(0," " "dplayx.dll" " - version unknown");
	}

	OutputDebugStringA("\n");	

	// fall through
		
CLEANUP_EXIT:
	DPMEM_FREE(pbVersion);
	return ;			

} // PrintVersionString

#endif  // DEBUG

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        #if 0
        _asm 
        {
        	 int 3
        };
		#endif 
        DisableThreadLibraryCalls( hmod );
        DPFINIT(); 

		
        /*
         * is this the first time?
         */
        if( InterlockedExchange( &bFirstTime, FALSE ) )
        {
            
            ASSERT( dwRefCnt == 0 );

	        /*
	         * initialize memory
	         */
			// Init this CSect first since the memory routines use it
			INIT_DPMEM_CSECT();

            if( !DPMEM_INIT() )
            {
                DPF( 1, "LEAVING, COULD NOT MemInit" );
                return FALSE;
            }
	
			#ifdef DEBUG
			PrintVersionString(hmod);
			#endif 
			
	        DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
                        GetCurrentProcessId(), GetCurrentThreadId() );
#ifdef DPLAY_LOADANDCHECKTRUE       
            InitializeRedirectFunctionTable();
#endif            

			// alloc the crit section
			gpcsDPlayCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPlayCritSection) 
			{
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the service crit section
			gpcsServiceCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsServiceCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby crit section
			gpcsDPLCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby Message Queue crit section
			gpcsDPLQueueCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLQueueCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby game node crit section
			gpcsDPLGameNodeCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLGameNodeCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPMEM_FREE(gpcsDPLQueueCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// set up the events
			ghEnumPlayersReplyEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
			ghRequestPlayerEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghReplyProcessed = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghConnectionEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

 	

			// Initialize CriticalSection for Packetize Timeout list
			InitializeCriticalSection(&g_PacketizeTimeoutListLock);

          	INIT_DPLAY_CSECT();
			INIT_SERVICE_CSECT();
          	INIT_DPLOBBY_CSECT();
			INIT_DPLQUEUE_CSECT();
			INIT_DPLGAMENODE_CSECT();
        }

        ENTER_DPLAY();

		// Set the platform flag
		if(OS_IsPlatformUnicode())
			gbWin95 = FALSE;

        dwRefCnt++;

        LEAVE_DPLAY();
        break;

    case DLL_PROCESS_DETACH:
        
        ENTER_DPLAY();

        DPF( 2, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
                DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

        dwRefCnt--;        
       	if (0==dwRefCnt) 
       	{		  
			DPF(0,"dplay going away!");

			if (0 != gnObjects)
			{
				DPF_ERR(" PROCESS UNLOADING WITH DPLAY OBJECTS UNRELEASED");			
				DPF_ERRVAL("%d unreleased objects",gnObjects);
			}
			
			FreeSPList(gSPNodes);
			gSPNodes = NULL;		// Just to be safe
			PRV_FreeLSPList(glpLSPHead);
			glpLSPHead = NULL;		// Just to be safe

			if (ghEnumPlayersReplyEvent) CloseHandle(ghEnumPlayersReplyEvent);
			if (ghRequestPlayerEvent) CloseHandle(ghRequestPlayerEvent);
			if (ghReplyProcessed) CloseHandle(ghReplyProcessed);
			if (ghConnectionEvent) CloseHandle(ghConnectionEvent);
            
			LEAVE_DPLAY();      	
       	    
       	    FINI_DPLAY_CSECT();	
			FINI_SERVICE_CSECT();
           	FINI_DPLOBBY_CSECT();
			FINI_DPLQUEUE_CSECT();
			FINI_DPLGAMENODE_CSECT();

			// Delete CriticalSection for Packetize Timeout list
			DeleteCriticalSection(&g_PacketizeTimeoutListLock); 

			DPMEM_FREE(gpcsDPlayCritSection);
			DPMEM_FREE(gpcsServiceCritSection);
			DPMEM_FREE(gpcsDPLCritSection);
			DPMEM_FREE(gpcsDPLQueueCritSection);
			DPMEM_FREE(gpcsDPLGameNodeCritSection);

            if (ghSSPI)
            {
                FreeLibrary(ghSSPI);
                ghSSPI = NULL;
            }
#ifdef DPLAY_LOADANDCHECKTRUE       
            FreeRedirectFunctionTable();
#endif            

            OS_ReleaseCAPIFunctionTable();

            if (ghCAPI)
            {
                FreeLibrary(ghCAPI);
                ghCAPI = NULL;
            }

			// Free this last since the memory routines use it
			FINI_DPMEM_CSECT();

        #ifdef DEBUG
			DPMEM_STATE();
        #endif // debug
			DPMEM_FINI(); 
       	} 
        else
        {
            LEAVE_DPLAY();		
        }

        break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);



#undef DPF_MODNAME
#define DPF_MODNAME "NTRemoveAnyExcessiveSecurityPermissions"

// NTRemoveAnyExcessiveSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to the old NTSetSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
HRESULT NTRemoveAnyExcessiveSecurityPermissions( HKEY hKey )
{
	HRESULT						hr=DPERR_GENERIC;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibraryA( "advapi32.dll" );

	if( !hModuleADVAPI32 )
	{
		DPF( 0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = (PFREESID)( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = (PSETSECURITYINFO)( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = (PSETENTRIESINACL)( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = (PBUILDTRUSTEEWITHSID)( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID)( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPF( 0, "Failed loading entry points" );
		hr = DPERR_GENERIC;
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( hKey, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPF( 0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
		} 
		else
		{
			DPF( 0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPF( 0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
//
HRESULT RegisterDefaultSettings()
{
	HKEY hKey;
	LONG lReturn;

    lReturn=OS_RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY,0 ,NULL,0,KEY_ALL_ACCESS,NULL,&hKey,NULL);
   	if( lReturn != ERROR_SUCCESS )
   	{
   		DPF(0,"Couldn't create registry key?\n");
   		return DPERR_GENERIC;
   	}

	if( OS_IsPlatformUnicode() )
	{
		HRESULT hr;

		// 6/19/01: DX8.0 added special security rights for "everyone" - remove them.
		hr = NTRemoveAnyExcessiveSecurityPermissions( hKey );

		if( FAILED( hr ) )
		{
			DPF( 0, "Error removing security permissions for app key hr=0x%x", hr );
		}
	} 

	RegCloseKey(hKey);

	return DP_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
//
HRESULT UnRegisterDefaultSettings()
{
	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPF( 0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
HRESULT WINAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpcpl.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpcpl.h
 *  Content:	DirectX CPL include file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-nov-96	andyco	created it
 *
 ***************************************************************************/

#ifndef __DPCPL_INCLUDED__
#define __DPCPL_INCLUDED__


#define MAX_NAME 256

typedef struct _DP_PERFDATA
{
    DWORD dwProcessID;
    UINT nSendBPS; // BPS = bytes per second
    UINT nReceiveBPS;
    UINT nSendPPS; // PPS = packets per second
    UINT nReceivePPS;
    UINT nSendErrors;
    BOOL bHost; // hosting?    
	UINT nPlayers;
    char pszSessionName[MAX_NAME];
    char pszFileName[MAX_NAME];
    char pszSPName[MAX_NAME];    
} DP_PERFDATA, * LPDP_PERFDATA;

#define FILE_MAP_SIZE sizeof(DP_PERFDATA)
#define FILE_MAP_NAME "__DPCPLMAP__"
#define EVENT_NAME  "__DPCPLEVENT__"
#define MUTEX_NAME "__DPCPLMUTEX__"
#define ACK_EVENT_NAME "__DPCPLACKEVENT__"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dplayi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:    DirectPlay internal include file for DPlay functions included
 *				by the lobby (not used in any of the DPlay files).
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	3/9/97		myronth	Created it
 *	3/17/97		myronth	Added player & group structs (only what we need)
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLAYI_INCLUDED__
#define __DPLAYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// Mimick the first part of the player/group struct.  This is really
// the only part we need.
typedef struct DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOID						pvPlayerData;
	DWORD						dwPlayerDataSize;
	LPVOID						pvPlayerLocalData;
	DWORD						dwPlayerLocalDataSize;
} DPLAYI_GROUP, * LPDPLAYI_GROUP;

typedef DPLAYI_GROUP DPLAYI_PLAYER;
typedef DPLAYI_PLAYER * LPDPLAYI_PLAYER;

typedef struct DPLAYI_DPLAY * LPDPLAYI_DPLAY;

// REVIEW!!!! -- Should we just include dplaysp.h to get this.  I really
// don't like having it defined in two places.
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

// DPlay Critical Section stuff
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection),gnDPCSCount--;ASSERT(gnDPCSCount>=0);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif
// End DPlay Critical Section stuff

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// handler.c
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, DWORD, LPVOID);

// iplay.c
extern HRESULT GetGroup(LPDPLAYI_DPLAY, LPDPLAYI_GROUP *,LPDPNAME,
						LPVOID, DWORD, DWORD);
extern HRESULT GetPlayer(LPDPLAYI_DPLAY, LPDPLAYI_PLAYER *,	LPDPNAME,
						HANDLE, LPVOID, DWORD, DWORD, LPWSTR);

// namesrv.c
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY, LPDWORD);


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLAYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dplaypr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaypr.h
 *  Content:	DirectPlay private header file
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	1/96	andyco	created it
 *	4/9/96	andyco	moved dplay private data structures here from dplayi.h 
 *	5/2/96	andyco	added dplayi_dplay_int interface pointer
 *	5/29/96	andyco	idplay2!
 *	6/8/96	andyco	moved player + group structs here from dplayi.h.
 *					replaced dplayi.h w/ dplaysp.h
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	kipo	added EnumConnectionData() method.
 *	6/25/96	kipo	added support for DPADDRESS.
 *	6/29/96 andyco	added localdata to player + group
 *	6/30/96	kipo	added support for CreateAddress() method.
 *  7/8/96  AjayJ   removed declaration for DP_SaveSession and DP_A_SaveSession
 *	7/24/96 andyco	changed nametable timeout to be 60 seconds
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  8/1/96	andyco	added keep alive files, sysplayer id to player struct
 *	8/6/96	andyco	added version to players + groups
 * 	8/8/96	andyco	changed around default timeout values - we now base 
 *					(or try to) off of sp's timeout
 *  8/9/96  sohailm added hSPModule member to DPLAYI_DPLAY structure
 *	8/16/96 andyco	added pNameServer to DPLAYI_DPLAY
 *  10/1/96 sohailm added CopySessionDesc2() and DoSessionCallbacks() prototypes
 *  10/2/96 sohailm added VALID_READ_*_PTR() macros
 *                  renamed GUID validation macros to use the term GUID instead of UUID
 *                  modified VALID_READ_GUID_PTR() macro to not check for null ptr
 * 10/9/96	andyco	added gbWaitingForReply so we know when we get a (player id,enumplayers)
 *					reply from the nameserver whether anyone is waiting.
 * 10/11/96 sohailm added InternalSetSessionDesc() and SendSessionDescChanged() prototypes
 * 10/12/96	andyco	added pSysGroup to DPLAYI_DPLAY
 * 10/28/96	andyco	added update list constants, pvUpdateList, dwUpdateListSize to 
 *					group / players
 *	1/1/97	andyco	added support for system players w/ groups
 *	2/1/97	andyco	changed dplayi_dplay_nametablepending to fdplayi_dplay_pending,
 *					since we now go into pending mode for guaranteed sends (since
 *					we drop the lock.
 *	2/25/97	andyco	added dll list of dplay objects
 *	3/6/97	myronth	added support for lobby object within dplay object
 *  3/12/97 sohailm added LOGINSTATE(enum type), NAMETABLE_PHCONTEXT(constant), pvData field
 *                  to nametable, security related fields to DPLAYI_PLAYER and DPLAYI_DPLAY, 
 *                  VALID_READ_DPCREDENTIALS() and VALID_READ_DPSECURITYDESC() macros, internal
 *                  error definitions, and some function prototypes.
 *	3/15/97	andyco	hung session list off of dplayi_dplay instead of being global
 *	3/17/97	kipo	added support for CreateCompoundAddress()
 *	3/20/97	myronth	Added IS_LOBBYOWNED macro
 *	3/24/97	andyco	dec debug lock counter b4 dropping lock!
 *  3/24/97 sohailm Added dwVersion field to session node and updated prototype for 
 *                  SendCreateMessage to take a session password
 *	3/25/97	kipo	EnumConnections takes a const *GUID now;
 *					added VALID_DPSESSIONDESC2_FLAGS macro
 *  3/28/97 sohailm allow DPOPEN_CREATE in the VALID_DPSESSIONDESC2_FLAGS macro so we don't break
 *                  monster truck.
 *	4/3/97	myronth	Added a few function prototypes needed by the lobby
 *					Also added dependency in dplobpr.h on this file so the
 *					lobby now pulls in all dplay internals
 *  3/31/97 sohailm Added a more descriptive comment about the reason for making DPOPEN_CREATE a valid
 *                  session desc flag.
 *  4/09/97 sohailm Added security related members (ulMaxSignatureSize and ulMaxContextBufferSize)
 *                  to DPLAYI_DPLAY structure.
 *	4/20/97	andyco	groups in groups
 *  4/23/97 sohailm Added flags DPLAYI_DPLAY_SIGNINGSUPPORTED and DPLAYI_DPLAY_ENCRYPTIONSUPPORTED.
 *  5/05/97 kipo	Added interface for CallAppEnumSessionsCallback()
 *	5/8/97	andyco	removed update list, added handy macros
 *	5/8/97	myronth	Exposed RemoveGroupFromGroup & DistributeGroupMessage to lobby
 *	5/12/97	kipo	Fixed bug #5406
 *	5/13/97	myronth	Added DPLAYI_DPLAY_SPSECURITY to override dplay handling security
 *  5/17/97 sohailm Added DPLOGIN_KEYEXCHANGE state to LOGINSTATE.
 *                  Added hCSP,hPublicKey,hEncryptionKey,hDecryptionKey,pPublicKey, 
 *                   and dwPublicKeySize to LPDPLAYI_DPLAY.
 *                  Added extern definitions for gpSSPIFuncTbl,gpSSPIFuncTblA,ghSSPI,ghCAPI.
 *                  Added macros VALID_DPSECURITYDESC_FLAGS() and VALID_DPCREDENTIALS_FLAGS() 
 *                  Added prototypes for DP_GetAccountDesc, DP_A_GetAccountDesc, and InternalGetAccountDesc().
 *	5/17/97	myronth	SendChatMessage function prototypes, structure validation macros
 *	5/18/97	kipo	added validation macros for EnumPlayers/Groups, CreatePlayer/Groups
 *  5/19/97 sohailm Added a new login state DPLOGIN_SUCCESS.
 *  5/21/97 sohailm Added VALID_SIGNING_STATE() macro and prototype for InternalHandleMessage().
 *	5/23/97	andyco	added DPLAYI_DPLAY_HANDLEMULTICAST
 *	5/23/97	kipo	Added support for return status codes
 *	5/30/97	myronth	Added GetGroupParent
 *  5/30/97 sohailm Added VALID_DPACCOUNTDESC_FLAGS() macro. Renamed GetAccountDesc and related
 *                  prototypes to GetPlayerAccount().
 *	5/30/97	kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  6/09/97 sohailm Renamed DPLOGIN_ACCESSDENIED to DPERR_LOGONDENIED
 *  6/22/97 sohailm Added CLIENTINFO structure and removed NAMETABLE_PHCONTEXT.
 *                  Moved phCredential and phContext from DPLAYI_PLAYER to DPLAYI_DPLAY.
 *                  Added pClientInfo to DPALAYI_PLAYER.
 *  6/23/97 sohailm Added hServerPublicKey to DPLAYI_DPLAY and hPublicKey to CLIENTINFO.
 *	8/5/97	andyco	async addforward
 *	8/19/97	myronth	Added pointer to lobby object that launched us
 *	8/19/97	myronth	Changed the object pointer to a lobby interface pointer
 *	8/29/97	sohailm	Added VALID_SPHEADER() macro
 *	8/22/97	myronth	Added Descriptions & flags to SPNODE structure
 *	10/21/97myronth	Added IDirectPlay4 structure definitions, added hidden
 *					and owner flags to macros, added owner method prototypes
 *	10/29/97myronth	Added group owner node structure, added node pointer to
 *					player struct, added owner ID to group struct
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97myronth	Added VALID_CONNECT_FLAGS macro (#12541)
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	11/24/97myronth	Fixed SetSessionDesc message for client/server (#15226)
 *	12/3/97	myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/21/98	myronth	Moved <mmsystem.h> include into this file for NT build
 *	1/27/98	myronth	Added prototype for NukeNameTableItem (#15255)
 *	1/28/98	sohailm	Added DP_MIN_KEEPALIVE_TIMEOUT and updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/3/98  aarono  updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/13/98 aarono  async support, added nPendingSends to player struct
 *  2/18/98 aarono  prototype of ConvertSendExDataToSendData for protocol
 *	2/18/98	a-peterz removed DPSESSION_OPTIMIZEBANDWIDTH.
 *  3/13/98 aarono  rearchitected packetizeandsendreliable
 *	5/11/98	a-peterz Add DPLAYI_DPLAY_ENUMACTIVE (#22920)
 *  6/6/98  aarono Fix for handling large loopback messages with protocol
 *  6/8/98  aarono Mark volatile fields
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98 aarono fix group SendEx ASYNC to use unique Header
 *  6/19/98 aarono add last ptr for message queues, makes insert
 *                 constant time instead of O(n) where n is number
 *                 of messages in queue.
 *  8/02/99	aarono removed old voice support
 *  8/02/99	rodtoll voice support
 *  8/04/99 aarono more voice support work
 *  8/18/99	rodtoll Added apphack flag for voice retrofit support
 *	8/20/99	rodtoll	Added members for out of process retrofit and removed old members
 *  9/02/99	rodtoll	Modified dplay interface validation macros to accept new interface
 *  9/09/99	rodtoll	Added members to support new retrofit launch procedure
 * 11/02/99	rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
 *  04/07/00 rodtoll Fixed Bug #32179 - Registering > 1 interface
 *           rodtoll Added support for nocopy sends (for voice)
 * 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                    added re-notification during simultaneous join CREATEPLAYERVERIFY
 * 07/22/00	rodtoll	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				Now for a thread to make an indication into voice they addref the interface
 *					so that the voice core can tell when all indications have returned.    
 *
 ***************************************************************************/

#ifndef __DPLAYPR_INCLUDED__
#define __DPLAYPR_INCLUDED__

#include <windows.h>
#include <stddef.h> // for offsetof
#include <sspi.h>   // for security info

#ifdef _WIN32_WINNT
#include <wincrypt.h>
#else
#define _WIN32_WINNT 0x400
#include <wincrypt.h> // for Crypto API
#undef _WIN32_WINNT
#endif

#include "dpf.h"
#include "dputils.h"
#include "dplaysp.h"
#include "dpmess.h"
#include "dpos.h"
#include "dpmem.h"
#include "dpcpl.h"
#include "dplobbyi.h"
#include "dpsecos.h"
#include "mcontext.h"
#include "fpm.h"
#include "bilink.h"
#include <mmsystem.h>
#include "dvoice.h"

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
typedef DIRECTPLAYCALLBACKS FAR * LPDIRECTPLAYCALLBACKS;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2;
typedef DIRECTPLAYCALLBACKS2 FAR * LPDIRECTPLAYCALLBACKS2;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2A;
typedef DIRECTPLAYCALLBACKS2A FAR * LPDIRECTPLAYCALLBACKS2A;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3;
typedef DIRECTPLAYCALLBACKS3 FAR * LPDIRECTPLAYCALLBACKS3;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3A;
typedef DIRECTPLAYCALLBACKS3A FAR * LPDIRECTPLAYCALLBACKS3A;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4;
typedef DIRECTPLAYCALLBACKS4 FAR * LPDIRECTPLAYCALLBACKS4;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4A;
typedef DIRECTPLAYCALLBACKS4A FAR * LPDIRECTPLAYCALLBACKS4A;


typedef struct IDirectPlaySPVtbl DIRECTPLAYCALLBACKSSP;
typedef DIRECTPLAYCALLBACKSSP FAR * LPDIRECTPLAYCALLBACKSSP;

typedef struct IDirectPlayVoiceTransportVtbl DIRECTPLAYVOICETRANSPORTCALLBACKS;
typedef DIRECTPLAYVOICETRANSPORTCALLBACKS FAR *LPDIRECTPLAYVOICETRANSPORTCALLBACKS;

// these guids are from dpwsock\dpsp.h
// we use them since golf shipped a bogus service provider
// when they ask for that service provider, we force it
// to the regular tcp/ip service provider

// the regular tcp/ip service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// the bogus service provider (bogus 'cause it still links w/ ddhelp.exe
// which is no longer dplay's friend
// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


/********************************************************************
*                                                                    
* data structures moved from dplayi.h.  private dplay data structure 
*                                                                    
********************************************************************/

/*                      */
/* ADDRESSHEADER 		*/
/*                      */
// header for dp address.  used by InternalEnumConnections and createaddress.
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
	DPADDRESS	dpaSPChunk; // the sp guid header
	GUID		guidSP; // the sp guid
	DPADDRESS	dpaAddressChunk; // the app's address header
	// address data follows
} ADDRESSHEADER, *LPADDRESSHEADER;



/*                      */
/* PACKET LIST	 		*/
/*                      */

#define INVALID_TIMER               0xFFFFFFFF

// each of this is a mesage that is being reconstructed on
// receive or a message that is being sent reliably using a
// simple ping-pong protocol.

typedef struct _PACKETNODE * LPPACKETNODE, *VOL LPPACKETNODE_V;
typedef struct _PACKETNODE
{
	union{
		LPPACKETNODE_V pNextPacketnode; // next packetnode in list-must be first element.		
		LPPACKETNODE_V pNext;		
	};	
	DWORD Signature;
	GUID guidMessage;     // id for this message
	LPBYTE pBuffer;       // pointer to message with extra space for SPHeader and MSG_PACKET for xmit.
	LPBYTE pMessage;      // message (excluding sp header)
	DWORD dwMessageSize;  // total size of message (excluding sp header)
	LPVOID pvSPHeader;    // header that came w/ 1st received packet, when not set, use dwIDTo/dwIDFrom and Send.
VOL	DWORD dwTotalPackets; 
VOL	DWORD dwSoFarPackets; // packets received/sent so far
	// new fields for reliability (ping-pong)
	BILINK RetryList;     // list of sends needing a retry.
	BILINK TimeoutList;   // list of sends timing out for retry.
	BOOL  bReliable;      // if set, we are doing the reliablity.
	BOOL  bReceive;       // set on all receives.
	LPDPLAYI_DPLAY lpDPlay;// dplay I/F ptr for use in TimeOuts
	DWORD dwLatency;      // assumed or observed round trip latency (ms).
	
VOL	UINT_PTR uRetryTimer;    // multi-media timer handle for re-xmit.
	DWORD Unique;
	
	UINT  tmTransmitTime; // Time of transmission of 1st try of packet.
	UINT  dwRetryCount;   // Number of times we retransmitted.
	UINT  tmLastReceive;  // Tick count we last got a receive on.
	// Fields used for Send (as opposed to Reply)
	DWORD dwIDTo;		  // To ID 
	DWORD dwIDFrom;       // From ID
	DWORD dwSendFlags;    // SendFlags
	
} PACKETNODE;


// client authentication states
typedef enum {
    DPLOGIN_NEGOTIATE,
    DPLOGIN_PROGRESS,
    DPLOGIN_ACCESSGRANTED,
    DPLOGIN_LOGONDENIED,
    DPLOGIN_ERROR,
	DPLOGIN_KEYEXCHANGE,
    DPLOGIN_SUCCESS
} LOGINSTATE;

// data structure used to store client specific information on 
// the server
typedef struct _CLIENTINFO
{
    CtxtHandle hContext;
    HCRYPTKEY hEncryptionKey;	// used for sending encrypted messages to client
    HCRYPTKEY hDecryptionKey;	// used for decrypting messages from client
    HCRYPTKEY hPublicKey;		// used for verification of signed messages from client
} CLIENTINFO, *LPCLIENTINFO;

/*                           */
/* SESSION DESCRIPTION LIST	 */
/*                           */
typedef struct _SESSIONLIST * LPSESSIONLIST, *VOL LPSESSIONLIST_V;
typedef struct _SESSIONLIST 
{
	DPSESSIONDESC2	dpDesc;
	LPVOID			pvSPMessageData;    // message data received w/ enumsessions reply
	LPSESSIONLIST_V	pNextSession;       // pointer to next session node
	DWORD			dwLastReply; // tick count when we last heard from this session
    DWORD           dwVersion;          // version of the sender
} SESSIONLIST;



/*                       */
/* PENDING LIST 		 */
/*                       */
typedef struct _PENDINGNODE * LPPENDINGNODE, *VOL LPPENDINGNODE_V;
typedef struct _PENDINGNODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	LPVOID  pHeader;
	DPID 	idFrom,idTo;
	LPPENDINGNODE_V pNextNode;
	DWORD 	dwSendFlags;
} PENDINGNODE;

/*                       */
/* MESSAGE LIST 		 */
/*                       */
typedef struct _MESSAGENODE * LPMESSAGENODE, *VOL LPMESSAGENODE_V;
typedef struct _MESSAGENODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	DPID 	idFrom,idTo;
	LPMESSAGENODE_V pNextMessage;
} MESSAGENODE;


/*                       */
/* NAME TABLE STUFF		 */
/*                       */

// each player id is defined as follows:
//      bits 0-15 : name table index
//      bits 16-31: uniqueness index
// the uniqueness index is used to make sure that if a location in the
// name table is reused, the user doesn't get the wrong contents
// index_mask masks off the uniqueness index from the name table index
#define INDEX_MASK 0x0000FFFF
// the initial size of the name table. when its full, we grow it by 2x.
#define NAMETABLE_INITSIZE 16
// used by nameserver to "hold" a slot for a client
#define NAMETABLE_PENDING ((DWORD_PTR)-1)

// max players is 2^16 (16 bits of index available in nametable)
#define DPLAY_MAX_PLAYERS  65536
// max buffer size is the max DWORD size
#define DPLAY_MAX_BUFFER_SIZE ((DWORD)-1)


/*                	       	*/
/* PLAYER + GROUP STUFF		*/
/*                       	*/

typedef struct _DPLAYI_PLAYER * LPDPLAYI_PLAYER,*VOL LPDPLAYI_PLAYER_V; 
typedef struct _DPLAYI_GROUP * LPDPLAYI_GROUP,*VOL LPDPLAYI_GROUP_V;
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY, *VOL LPDPLAYI_DPLAY_V;
typedef struct _DPLAYI_GROUPNODE * LPDPLAYI_GROUPNODE, *VOL LPDPLAYI_GROUPNODE_V;
typedef struct _DPLAYI_SUBGROUP * LPDPLAYI_SUBGROUP, *VOL LPDPLAYI_SUBGROUP_V;
typedef struct _DPLAYI_GROUPOWNER * LPDPLAYI_GROUPOWNER, *VOL LPDPLAYI_GROUPOWNER_V;

/*                      */
/* DPLAYI_GROUPNODES    */
/*                      */
// this is a node in the list of all system players in a group, 
// each system player has a list of all local players in the group hanging
// off it
typedef struct _DPLAYI_GROUPNODE
{
        LPDPLAYI_GROUPNODE_V    pNextGroupnode; // the next groupnode in the list
        LPDPLAYI_PLAYER_V       pPlayer;
		UINT					nPlayers; // if pPlayer is a system player, nPlayers is the #
										  // of players that sysplayer has in this group
} DPLAYI_GROUPNODE;


/*                      */
/* DPLAYI_SUBGROUP    */
/*                      */
// this is a node in the list of all groups contained by a group
typedef struct _DPLAYI_SUBGROUP
{
        LPDPLAYI_SUBGROUP_V    	pNextSubgroup; // the next SUBGROUP in the list
		LPDPLAYI_GROUP_V		pGroup;
		DWORD 					dwFlags; // DPGROUP_STAGINGAREA, DPGROUP_SHORTCUT
} DPLAYI_SUBGROUP;

/*                      */
/* DPLAYI_GROUPOWNER    */
/*                      */
// this is a node in the list of groups a player is the owner of
typedef struct _DPLAYI_GROUPOWNER
{
		LPDPLAYI_GROUPOWNER_V	pNext;	// the next GROUPOWNER node in the list
		LPDPLAYI_GROUP_V		pGroup; // pointer to the group this player is the owner of
} DPLAYI_GROUPOWNER, *VOL DPLAYI_GROUPOWNER_V;

/*              */
/* DPLAYI_GROUP */
/*              */
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this! 
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this groups sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a group belongs
	DPID						dwIDParent;	
	// fields above MUST BE kept common to player and group
    LPDPLAYI_GROUPNODE_V        pGroupnodes; // a list of the (non-system) players in the group
	LPDPLAYI_GROUPNODE_V 	    pSysPlayerGroupnodes; // a list of the system players to 
													  // whom group messages should be sent
    LPDPLAYI_GROUP_V            pNextGroup; // the list of all groups
VOL	UINT 						nPlayers; // # of players in the group
	LPDPLAYI_SUBGROUP_V			pSubgroups; // list of contained groups
VOL	UINT						nSubgroups;
	DWORD						dwOwnerID; // player id of the owner of this group (non-system player)
} DPLAYI_GROUP;

/*                      */
/* DPLAYI_PLAYER        */
/*                      */
// this is a node in the list of all players
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_PLAYER
{
    DWORD                       dwSize;
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this!
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this players sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a player belongs
	DPID						dwIDParent;		
	// fields above MUST BE kept common to player and group
    LPDPLAYI_PLAYER_V           pNextPlayer; // the list of all players
    HANDLE						hEvent; // handle to player event
	// the fields below are used w/ keep alives + player latencies
	DWORD						dwLatencyLastPing; // observed latency on last ping -used when nothing else avail.
	DWORD						dwNPings; // how many latency data points do we have
	// async
	DWORD                       nPendingSends; // count async sends that haven't completed.
	// better keepalive	- a-josbor
VOL	DWORD						dwChatterCount;	// how many times have we heard/reliably talked to player?
VOL	DWORD						dwUnansweredPings;	// how many continguous unanswered pings have there been?
VOL DWORD						dwProtLastSendBytes;	// how many bytes had we sent last time keepalives checked?
VOL	DWORD						dwProtLastRcvdBytes;	// how many bytes had we received last time keepalives checked?

	DWORD						dwTimeToDie;		// when the player should be killed due to connlost
    // security related
    LPCLIENTINFO                pClientInfo;  // pointer to client specific info
	// group owner list -- list of groups this player is the owner of
	LPDPLAYI_GROUPOWNER_V		pOwnerGroupList;
	BILINK                      PendingList;	// list of pending async sends.
	DWORD						dwCreateTime;	// time we created this player (if local)
} DPLAYI_PLAYER;

typedef struct _NAMETABLE 
{
    DWORD_PTR dwItem; // the data stored here
    // dwUnique is used to verify that this 
    // is a valid entry - it must match the unique index in
    // the users dpid
    DWORD dwUnique; // 0-2^16, incremented every time a new id is given out for this slot
    LPVOID pvData;  // data stored here depends on the type specified by dwItem
} NAMETABLE;

typedef struct _NAMETABLE * LPNAMETABLE, *VOL LPNAMETABLE_V;

typedef void (*FREE_ROUTINE)(LPVOID context, LPVOID pMem);

typedef struct _BufferFree {
	FREE_ROUTINE fnFree;
	LPVOID       lpvContext;
} BUFFERFREE, *LPBUFFERFREE, *PBUFFERFREE;

typedef struct _GroupHeader {
	MSG_PLAYERMESSAGE Msg;		// MUST BE AT FRONT
	struct _GroupHeader *pNext;
} GROUPHEADER, *LPGROUPHEADER, *PGROUPHEADER;

#define MAX_SG	8		// Maximum Scatter Gather Entries for a send - internal only.

// Send Paramters structure, used to lower the stack load in send path.
typedef struct _SENDPARMS {

	LPVOID           pPoolLink; // reserve void pointer at front 
								// so cs not overwritten by pool manager

	CRITICAL_SECTION cs;

	BILINK  PendingList;		// pending list on Group or Player

	UINT    RefCount;

	LPVOID  lpData;				// user buffer pointer
	DWORD   dwDataSize;			// user buffer length

	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_PLAYER pPlayerTo;
	LPDPLAYI_GROUP  pGroupTo;

	MESSAGENODE     msn;		// for linking this struct on receiveQ

	// ++ don't reorder +++++++++++++++++++++++++++++++++++++++++++
	// The following part of the structure is exactly the same
	// content as a DPMSG_SENDCOMPLETE - don't re-order
		
	DWORD   dwType;
	DPID	idFrom;
	DPID	idTo;
	DWORD   dwFlags;
	DWORD   dwPriority;			// 0-65535, SendEx Only
	DWORD   dwTimeout;			// in milliseconds, SendEx Only
	LPVOID  lpUserContext;  	// SendEx, ASYNC only.
	PVOID   hContext;           // handle to context list
	HRESULT hr;
	DWORD   dwSendCompletionTime;
	// -- order dependancy ends here -------------------------------

	DWORD_PTR dwMsgID;            // to store ID if user not provided.
	DWORD_PTR *lpdwMsgID;			// SendEx, ASYNC only.

	DWORD   dwSendTime;         // Time we were called in SendEx

	// parallel arrays for scatter gather, kept separate so we don't
	// have to transcribet the buffers to call the SP_SendEx i/f
	UINT       cBuffers;		// Number of filled in buffers.
	DWORD      dwTotalSize;     // total size of send data.
	SGBUFFER   Buffers[MAX_SG];	// the buffers 
	BUFFERFREE BufFree[MAX_SG]; // their free routines

	// support context mappings, also hContext above...
	UINT       iContext;		// next avail context in list
	UINT       nContext;        // number of contexts in list
	
	UINT       nComplete;		// number of completions

	PGROUPHEADER pGroupHeaders;	// when sending to group we may need many headers.
	
} SENDPARMS, *PSENDPARMS, *LPSENDPARMS;


/*                      */
/* DPLAYI_FLAGS         */
/*                      */
// this dplay object is in pending mode. we're either waiting for the nametable,
// or we've dropped our lock for a guaranteed send. either way - any incoming messages get
// pushed onto the pending q
#define DPLAYI_DPLAY_PENDING 			0x00000001
// we've lost the session. bummer.
#define DPLAYI_DPLAY_SESSIONLOST		0x00000002
// dplay is closed for bidness. set when we get a close or shutdown
#define DPLAYI_DPLAY_CLOSED				0x00000004
// there is (at least one) DX3 client in the game
#define DPLAYI_DPLAY_DX3INGAME			0x00000008
// indicates we're currently flushing the pending q. means player messages don't 
// need to be copied again
#define DPLAYI_DPLAY_EXECUTINGPENDING 	0x00000010
// our sp is a dx3 sp 
#define DPLAYI_DPLAY_DX3SP			   	0x00000020
// we were created by CoCreateInstance, but no SP has been loaded yet 
// (initialize hasn't been called)
#define DPLAYI_DPLAY_UNINITIALIZED	   	0x00000040
// the service thread is doing async enums
#define DPLAYI_DPLAY_ENUM			   	0x00000080
// the service thread is doing keepalives
#define DPLAYI_DPLAY_KEEPALIVE		   	0x00000100
// the lobby owns this dplay object
#define DPLAYI_DPLAY_LOBBYOWNS			0x00000200
// dplay is providing security 
#define DPLAYI_DPLAY_SECURITY           0x00000400
// an async enum is in process
#define DPLAYI_DPLAY_ENUMACTIVE		   	0x00000800
// encryption support is available
#define DPLAYI_DPLAY_ENCRYPTION         0x00001000
// the SP is handling security
#define DPLAYI_DPLAY_SPSECURITY			0x00002000
// we're processing a multicast message
#define DPLAYI_DPLAY_HANDLEMULTICAST	0x00004000
// sp isn't reliable - startup system messages use new packetize
#define DPLAYI_DPLAY_SPUNRELIABLE       0x00008000
// running protocol exclusively for datagram and reliable
#define DPLAYI_DPLAY_PROTOCOL           0x00020000
// if set protocol need not maintain reliable receive order
#define DPLAYI_DPLAY_PROTOCOLNOORDER    0x00040000

// We are in the transitory period between a nameserver dropping out
// and a new nameserver being elected.
#define DPLAYI_DPLAY_NONAMESERVER       0x00100000

#define DPLAYI_PROTOCOL DPLAYI_DPLAY_PROTOCOL

// flags that get reset on DP_CLOSE
// note that we don't reset enum  - this is because if we enumplayers in a remote session,
// we leave the enum thread alone on close
#define DPLAYI_DPLAY_SESSIONFLAGS (DPLAYI_DPLAY_PENDING | DPLAYI_DPLAY_SESSIONLOST | DPLAYI_DPLAY_CLOSED \
	|  DPLAYI_DPLAY_DX3INGAME | DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_KEEPALIVE \
    |  DPLAYI_DPLAY_ENCRYPTION | DPLAYI_DPLAY_SECURITY | DPLAYI_DPLAY_SPSECURITY \
    |  DPLAYI_DPLAY_PROTOCOL | DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOLNOORDER \
    |  DPLAYI_DPLAY_NONAMESERVER )

/*            */
/* APP HACKS  */
/*            */

// Japanese FORMULA1 crashes when we start our periodic multimedia timer
// since they were written for DirectPlay 5.0 we turn off the timer so
// we can't support the protocol OR reliable delivery.
#define DPLAY_APPHACK_NOTIMER		0x00000001

/*                      */
/* DPLAYI_SUPERPACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net - new for dx5
// see superpac.c
typedef struct _DPLAYI_SUPERPACKEDPLAYER
{
    DWORD             		    dwFixedSize; // size of this struct
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
	DWORD						dwMask;  // bitfield indicating which optional fields are present
} DPLAYI_SUPERPACKEDPLAYER,*LPDPLAYI_SUPERPACKEDPLAYER;
	
/*                      */
/* DPLAYI_PACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net
typedef struct _DPLAYI_PACKEDPLAYER
{
    DWORD                       dwSize; // packedplayer size + short name + long name
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    UINT                        iShortNameLength;
    UINT                        iLongNameLength; 
    DWORD                       dwSPDataSize;// sp data follows strings
	DWORD 						dwPlayerDataSize;
	DWORD						dwNumPlayers; // number of players in group. only used w/ groups.
	DWORD						dwIDSysPlayer; // id of this players sys player. player only
	DWORD						dwFixedSize; // size of packed player. we put this in struct
											//  so we can change it in future versions
	DWORD 						dwVersion; // version of this player or group
    // short name and then long name follow structure, then spdata, then playerdata
	// then, (for groups) list of player id's.
	//
	// ** added for DX5 **
	//
	DWORD						dwIDParent; // if it was creategroupingroup

} DPLAYI_PACKEDPLAYER, *LPDPLAYI_PACKEDPLAYER;

/*                      */
/* SP Node stuff		*/
/*                      */
// this is where the service provider info read from
// the registry is kept

typedef struct _SPNODE
{
	LPTSTR		lpszName;
	LPTSTR		lpszPath;
	GUID		guid;
	DWORD		dwID;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpszDescW;
	struct _SPNODE * VOL pNextSPNode;
} SPNODE,*LPSPNODE;

// flags for SP Nodes
#define		SPNODE_DESCRIPTION		(0x00000001)
#define		SPNODE_PRIVATE			(0x00000002)

// an iunknown, idirectplay or idirectplay2 interface
typedef struct _DPLAYI_DPLAY_INT * LPDPLAYI_DPLAY_INT, *VOL LPDPLAYI_DPLAY_INT_V;
typedef struct _DPLAYI_DPLAY_INT
{
	LPVOID 				lpVtbl;
	LPDPLAYI_DPLAY		lpDPlay;
VOL	LPDPLAYI_DPLAY_INT 	pNextInt;	  // next interface on the dplay object
	DWORD 				dwIntRefCnt; // reference count for this interface

} DPLAYI_DPLAY_INT;

// a list of the addforward requests sent by a host, waiting for ack
typedef struct _ADDFORWARDNODE  * LPADDFORWARDNODE, *VOL LPADDFORWARDNODE_V;
typedef struct _ADDFORWARDNODE
{
	LPADDFORWARDNODE_V 	pNextNode; // next element in list
	DPID				dwIDSysPlayer; // system player who generated the addforward
	DWORD				nAcksRecv;  // # acks so far
	DWORD				nAcksReq;  // # of acks required
	DWORD				dwGiveUpTickCount; // tick count after we give up on acks, 
											// and just send nametable
	LPVOID				pvSPHeader; // header from dwIDSysPlayer - used to reply to	
									// when we finally get the nametable
 	DPID				dpidFrom; // if it was sent secure, id for returning nametable
	DWORD				dwVersion; // version of requestor
} ADDFORWARDNODE;

// Note protocol structure is actually much larger (see protocol\arpdint.h) this is
// just the bit that the DPLAY core needs to access.
typedef struct _PROTOCOL_PART {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;

		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

} PROTOCOL_PART, *LPPROTOCOL_PART;

// this is the number of clients of IDirectXVoice in this process
// this is actually a ridiculously large number of client slots.
#define MAX_VOICE_CLIENTS	32							

// this is the "class" that implements idirectplay
typedef struct _DPLAYI_DPLAY
{
	DWORD 						dwSize;
	LPDPLAYI_DPLAY_INT_V		pInterfaces; // list of interface objects pointing to this dplay object
    DWORD                       dwRefCnt; // ref cnt for the dplay object
    DWORD                       dwFlags;  // dplayi_xxx (see dplayi.h)
    DWORD                       dwSPFlags; // Flags from last call to GetCaps on SP.
    LPDPSP_SPCALLBACKS          pcbSPCallbacks; // sp entry points
    LPDPLAYI_PLAYER_V           pPlayers; // list of all players 
    LPDPLAYI_GROUP_V            pGroups;  // list of all groups
    LPDPLAYI_PLAYER             pSysPlayer; // pointer to our system player
    LPNAMETABLE_V               pNameTable; // player id <--> player
VOL UINT						nGroups;  // total # of groups
VOL	UINT						nPlayers; // total # of players
VOL UINT                        uiNameTableSize; // current alloc'ed size of nametable
VOL UINT                        uiNameTableLastUsed; // mru name table index
    LPDPSESSIONDESC2_V          lpsdDesc; // session desc for the current session
	LPMESSAGENODE_V				pMessageList; // list of all messages for local users
	LPMESSAGENODE_V             pLastMessage; // last element in MessageList
VOL	UINT						nMessages; // # of messages in message list
	DWORD						dwSPHeaderSize; // size of sp blob
	
	LPPENDINGNODE_V				pMessagesPending; // List of commands waiting for nametable
	LPPENDINGNODE_V             pLastPendingMessage; // Last element in PendingList
	UINT						nMessagesPending; //count of commands waiting for nametable
	
	DWORD						dwSPMaxMessage; // max unreliable send size for SP
	DWORD						dwSPMaxMessageGuaranteed; // max reliable send size for SP

	// PacketizeAndSend vars.
	LPPACKETNODE_V				pPacketList;
VOL	UINT_PTR                    uPacketTickEvent;	// MM timer handle for 15 second ticker
VOL	UINT                        nPacketsTimingOut;	// number of receives we are timing out
	
	// Retry sup for FacketizeAndSendReliable
VOL	HANDLE                      hRetryThread;
VOL	HANDLE                      hRetry;			
	BILINK                      RetryList;
	
VOL	HANDLE						hDPlayThread;
    HINSTANCE                   hSPModule; // SP module instance
VOL	HANDLE						hDPlayThreadEvent;
	LPDPLAYI_PLAYER_V			pNameServer; // pointer to the player that is the 
											 // nameserver.  null if we are the nameserver
											// or if we  don't have a nameserver yet.
    LPDPLAYI_GROUP_V			pSysGroup;
	LPDPLAYI_PLAYER_V			pServerPlayer; // the apps server player

	// dwServerPlayerVersion is used to track the server's version between when we enumsessions
	// and enumplayers in a session.  It is extremely transient.  Set in GetNameTable, cleared on Send.
	UINT                        dwServerPlayerVersion; 
	
	// control panel support
	LPDP_PERFDATA 				pPerfData;
	HANDLE						hPerfThread;
	HANDLE						hPerfEvent;
    // security related (valid on server and client)
    LPDPSECURITYDESC            pSecurityDesc;      // security description
    ULONG                       ulMaxContextBufferSize; // max size of opaque buffers
    ULONG                       ulMaxSignatureSize; // max size of digital signature
    HCRYPTPROV                  hCSP;               // handle to crypto service provider
    HCRYPTKEY                   hPublicKey;         // handle to system player's public key
    LPBYTE                      pPublicKey;         // public key buffer
    DWORD                       dwPublicKeySize;    // size of public key buffer
	// security related (valid only on client)
    LPDPCREDENTIALS             pUserCredentials;   // user provided credentials
    LOGINSTATE                  LoginState;         // tells the state of authentication
    PCredHandle                 phCredential;       // pointer to player's credential handle (given by package)
    PCtxtHandle                 phContext;          // pointer to security context (client only)
    HCRYPTKEY                   hEncryptionKey;     // session key used for encryption (client only)
    HCRYPTKEY                   hDecryptionKey;     // session key used for decryption (client only)
    HCRYPTKEY                   hServerPublicKey;   // handle to system player's public key

	// pointer to the sp node for the current sp
	LPSPNODE 					pspNode;
	// data the sp can stash w/ each IDirectPlaySP	
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	IDirectPlaySP * 			pISP;
	LPDPLAYI_DPLAY_V			pNextObject; // pointer in our dll list of dplay objects
											// list is anchored at gpObjectList;
	DWORD						dwLastEnum;
	DWORD						dwLastPing;
	DWORD						dwEnumTimeout;
	LPBYTE						pbAsyncEnumBuffer;
	DWORD						dwEnumBufferSize;
	// Lobby stuff
	LPDPLOBBYI_DPLOBJECT		lpLobbyObject;	// pointer to our aggregated lobby object
	LPDIRECTPLAYLOBBY			lpLaunchingLobbyObject; // the lobby interface we were launched on

	// list of enumsessions responses
	// new sessions are added to this when handler.c receives enum responses
	LPSESSIONLIST_V				pSessionList; 
	DWORD						dwMinVersion; // the lowest version of a player in our session
	LPADDFORWARDNODE_V			pAddForwardList; // the list of addforward notifications waiting
	 											// for ack's
	LPPROTOCOL_PART             pProtocol;      // reliable protocol object

	LPFPOOL                     lpPlayerMsgPool;  // pool of player message headers.
	LPFPOOL                     lpSendParmsPool;  // pool of send parameter blocks.
	LPFPOOL                     lpMsgNodePool;

	// Pool of contexts for async send.
	PMSGCONTEXTTABLE            pMsgContexts;   // for async interface, context mapping table.
	LPVOID                      GrpMsgContextPool[MSG_FAST_CONTEXT_POOL_SIZE+1];
	CRITICAL_SECTION            ContextTableCS;

	// Support for waiting for and accepting Reply's
	CRITICAL_SECTION            ReplyCS;		// controls access to all vars in this section
VOL	HANDLE                      hReply;			// Autoreset event to wait for replies.
VOL	DWORD                       dwReplyCommand; // command reply we are waiting for 0xFFFF == ANY
												// if this is non-zero someone is already waiting.
	LPVOIDV                     pvReplySPHeader;// if reply has SPHeader, we store it here											
	PCHAR                       pReplyBuffer;   // Reply buffer goes here until accepted.
	DWORD						cbReplyBuffer;  // size of the reply buffer

	// a-josbor: helper for making sure we don't let more than MaxPlayers in the game
	//	only used by the NameServer
	DWORD						dwPlayerReservations;	// how many unclaimed Player ids have we given out
	DWORD						dwLastReservationTime;	// when did we give out the most recent reservation?

	// a-josbor: the version number of the sp was not previously being remembered.  Remember it.
	DWORD               		dwSPVersion;        //  version number 16 | 16 , major | minor version 

	DWORD						dwZombieCount;		// how many zombie players (conn lost)
	DWORD                       dwAppHacks;

	CRITICAL_SECTION			csNotify;
	// voice specific information.---------------------------------------------
	// Parallel arrays of VoiceNotify and context values.
	LPDIRECTPLAYVOICENOTIFY		lpDxVoiceNotifyClient;
	LPDIRECTPLAYVOICENOTIFY		lpDxVoiceNotifyServer;	

	// Send Target Cache for voice targets on DV_SendSpeechEx
	DWORD						nTargets;			     // number of used entries in the target list
	DWORD						nTargetListLen;          // max number of target list entries list can hold
	LPDPID						pTargetList;	  	   // ptr to target list array
	DWORD						nExpandedTargets;        // simplified list of targets, removes dup's
	DWORD						nExpandedTargetListLen;  // max number of target list entries list can hold
	LPDPID						pExpandedTargetList;	// ptr to array of simplified list of targets
	
	// Retrofit specific information
	BOOL						bCoInitializeCalled; // Was CoInitialize called by retrofit
	BYTE						bRetroActive;		 // 0 = inactive, 1 = active
	HANDLE						hRetroMessage;		 // Handle for retrofit lobby message receive notifications
	DWORD						dwRetroID;			 // Application ID for retrofit when lobby launched
	LPDIRECTPLAYLOBBY3A			lpdplRetro;			 // Lobby for communicating with retro app.
	HANDLE						hRetroWatcherStop;	 // Signal to stop watcher thread
	HANDLE						hRetroWatcherDone;	 // The watcher is now complete
VOL	BOOL						bHost;			     // Is this dplay the host?
	DPID					    dpidVoiceHost;		 // Cached host ID
	DPID						dpidLocalID;		 // Cached local ID
VOL	BOOL						fLoadRetrofit;		 // Load retrofit?
VOL	BOOL						fDidVoiceClose;
	// voice specifc information ends------------------------------------------
} DPLAYI_DPLAY;

/************************************************************
*                                                            
* global variables											 
*                                                            
************************************************************/

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
extern LPDPLAYI_DPLAY gpObjectList;
extern UINT gnObjects; // the # of dplay objects in the gpObjectList

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request. 
// alloc'ed and init'ed in dllmain.c
extern HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed;

// globals to hold buffer for enum players and new player id replies
// declared in handler.c
extern LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;

extern LPVOID gpvEnumPlayersHeader;

// set to TRUE when someone is waiting for our reply
// set to FALSE when they give up waiting, or when the reply shows up
extern BOOL gbWaitingForReply;
extern BOOL gbWaitingForEnumReply;

// set if we have a dx3 SP loaded. see api.c
extern BOOL gbDX3SP;											

// the vtable!
extern DIRECTPLAYCALLBACKS dpCallbacks;
extern DIRECTPLAYCALLBACKS2 dpCallbacks2;
extern DIRECTPLAYCALLBACKS2A dpCallbacks2A;
extern DIRECTPLAYCALLBACKS3 dpCallbacks3;
extern DIRECTPLAYCALLBACKS3A dpCallbacks3A;
extern DIRECTPLAYCALLBACKS4 dpCallbacks4;
extern DIRECTPLAYCALLBACKS4A dpCallbacks4A;
extern DIRECTPLAYCALLBACKSSP dpCallbacksSP;
extern DIRECTPLAYVOICETRANSPORTCALLBACKS dvtCallbacks;

// we're running mech. hack.
extern BOOL gbMech;

// set in dllmain.c if we're running on win95 (since win95 doesn't do 
// unicode)
extern BOOL gbWin95;

// pointers to sspi function tables
extern PSecurityFunctionTableA	gpSSPIFuncTblA;
extern PSecurityFunctionTable	gpSSPIFuncTbl;
extern LPCAPIFUNCTIONTABLE      gpCAPIFuncTbl;

// global event handle, used in dpsecure.c for synchronous authentication
extern HANDLE           ghConnectionEvent;

// global module handle to SSPI DLL
extern HINSTANCE ghSSPI;

// global module handle to CAPI DLL
extern HINSTANCE ghCAPI;

/********************************************************************************
*                                                                                
* macros and other cool stuff													 
*                                                                                
********************************************************************************/

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT
// ansi strlength + 1 for the terminating null
#define STRLEN(ptr) ((NULL==ptr) ? 0 : strlen(ptr) + 1)
//
// WSTRxxx defined in dpos.c.  
// we have our own strlen and strcmp for unicode since they're not in libc.lib
// and we don't want to link to msvcrt.dll
//
// unicode strlength + 1 for terminating nulls
#define WSTRLEN OS_StrLen
#define WSTRLEN_BYTES(ptr) (OS_StrLen(ptr) * sizeof(WCHAR))
#define WSTRCMP(ptr1,ptr2) ( memcmp(ptr1,ptr2,WSTRLEN_BYTES(ptr1)) )

// unicode strlength + 1 for terminating nulls
#define WSTRNLEN OS_StrnLen
#define WSTRNLEN_BYTES(ptr, dwMaxLen, bForceTermination) (OS_StrnLen(ptr, dwMaxLen/sizeof(WCHAR),bForceTermination) * sizeof(WCHAR))

// get the ansi length of a unicode string
#define WSTR_ANSILENGTH(psz) ( (psz == NULL) ? 0 : WideToAnsi(NULL,psz,0) )

// registry stuff - used in api.c
#define DPLAY_REGISTRY_PATH (TEXT("Software\\Microsoft\\DirectPlay\\Service Providers"))
#define DPLAY_REGISTRY_NAMELEN 512
#define DPLAY_MAX_FILENAMELEN 512

// number of sp timeouts we wait for a reply from a namesrvr for the nametable
// for the default this is ~ 2+ minutes (125 seconds).
#define DP_NAMETABLE_SCALE 25
// number of sp timeouts we wait for a reply from the namesrvr for a player id
// for the default, this is ~ 15 seconds
#define DP_GETID_SCALE 3
// generic timeout default
#define DP_DEFAULT_TIMEOUT (5*1000)
// max timeout we will wait for connect
#define DP_MAX_CONNECT_TIME	(60*1000)

// minimum time out between keep alives
#define DP_MIN_KEEPALIVE_TIMEOUT 1000

// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

//
// !!! NOTE: when taking SERVICE_LOCK and DPLAY_LOCK, you must always take the SERVICE_LOCK FIRST !!!
//

// crit section
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#define INIT_DPLAY_CSECT() InitializeCriticalSection(gpcsDPlayCritSection);
#define FINI_DPLAY_CSECT() DeleteCriticalSection(gpcsDPlayCritSection);
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);LeaveCriticalSection(gpcsDPlayCritSection);
//#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;DPF(9,"++>ENTER_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);
//#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);DPF(9,"<--LEAVE_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);LeaveCriticalSection(gpcsDPlayCritSection);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif

#define PACKETIZE_LOCK() EnterCriticalSection(&g_PacketizeTimeoutListLock);
#define PACKETIZE_UNLOCK() LeaveCriticalSection(&g_PacketizeTimeoutListLock);


// service crit section
extern LPCRITICAL_SECTION gpcsServiceCritSection;	// defined in dllmain.c
#define INIT_SERVICE_CSECT() InitializeCriticalSection(gpcsServiceCritSection);
#define FINI_SERVICE_CSECT() DeleteCriticalSection(gpcsServiceCritSection);

#ifdef DEBUG
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#else
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#endif

// macros to make sure we take the locks together in the correct order.
#define ENTER_ALL() ENTER_SERVICE();ENTER_DPLAY();
#define LEAVE_ALL() LEAVE_DPLAY();LEAVE_SERVICE();

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

#define DPLAY_FROM_INT(ptr) \
	( ptr ? ((LPDPLAYI_DPLAY_INT)ptr)->lpDPlay  : NULL)

// handy macros
#define CLIENT_SERVER(this) ( (this->lpsdDesc) \
	&& (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) )
	
// secure server is when the session desc is marked dpsession_secureserver
#define SECURE_SERVER(this)  ( (this->lpsdDesc) \
	&& (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) )
	
// is this the nameserver?
#define IAM_NAMESERVER(this) ( this->pSysPlayer \
	&& (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	
// validation macros

#define VALID_SIGNING_STATE(this) (                     \
        (DPLOGIN_ACCESSGRANTED == this->LoginState) ||  \
        (DPLOGIN_KEYEXCHANGE == this->LoginState) ||    \
        (DPLOGIN_SUCCESS == this->LoginState) )          

#define VALID_SPHEADER(ptr) (ptr && (DPSP_HEADER_LOCALMSG != ptr))

#define VALID_DPLAY_PLAYER( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_PLAYER)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_PLAYER )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_PLAYER)))

#define VALID_DPLAY_GROUP( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_GROUP)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_GROUP )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_GROUP)))

#define VALID_PLAYER_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( PLAYERDATA )) && \
        ((ptr)->dwSize == sizeof(PLAYERDATA)))

#define VALID_GROUP_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( GROUPDATA )) && \
        ((ptr)->dwSize == sizeof(GROUPDATA)))
		
#define VALID_DPLAY_INT( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY_INT )) && \
        ((ptr->lpVtbl == &dpCallbacks) || (ptr->lpVtbl == &dpCallbacks2) \
        || (ptr->lpVtbl == &dpCallbacks2A) || (ptr->lpVtbl == &dpCallbacksSP) \
		|| (ptr->lpVtbl == &dpCallbacks3) || (ptr->lpVtbl == &dpCallbacks3A) \
		|| (ptr->lpVtbl == &dpCallbacks4) || (ptr->lpVtbl == &dpCallbacks4A) \
		|| (ptr->lpVtbl == &dvtCallbacks) \
		) )

#define VALID_DPLAY_PTR( ptr ) \
	( (!ptr || IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY )) ) ? DPERR_INVALIDOBJECT : \
    (ptr->dwSize != sizeof(DPLAYI_DPLAY))  ? DPERR_INVALIDOBJECT : \
   	(ptr->dwFlags & DPLAYI_DPLAY_UNINITIALIZED) ? DPERR_UNINITIALIZED : DP_OK )

#define VALID_STRING_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_STRING_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_WRITE_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_ID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DPID)))

#define VALID_GUID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(GUID)))

#define VALID_READ_GUID_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(GUID)))

#define VALID_DWORD_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DWORD)))

#define VALID_READ_DWORD_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(DWORD)))

#define VALID_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_READ_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

#define VALID_READ_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

// DPOPEN_CREATE and DPOPEN_JOIN are valid session desc flags for Open on IDirectPlay, 
// but not for later interfaces. However, some apps (monster truc) that didn't upgrade well, 
// are passing these flags to later interfaces as well. We can't catch this error now as we'll 
// break these apps. The following macro treats these two flags as valid. Treating DPOPEN_CREATE
// as a valid flag is safe because it has not been reused. However, DPSESSION_NEWPLAYERSDISABLED
// has taken DPOPEN_JOIN's slot. Reusing this flag doesn't cause any problems because session 
// flags passed in during join are ignored in IDirectPlay2 and greater interfaces.
#define VALID_DPSESSIONDESC2_FLAGS(dwFlags) \
		(!((dwFlags) & \
				  ~(DPSESSION_NEWPLAYERSDISABLED | \
                    DPOPEN_CREATE | \
					DPSESSION_MIGRATEHOST | \
					DPSESSION_NOMESSAGEID | \
					DPSESSION_NOPLAYERMGMT | \
					DPSESSION_JOINDISABLED | \
					DPSESSION_KEEPALIVE | \
					DPSESSION_NODATAMESSAGES | \
					DPSESSION_SECURESERVER | \
					DPSESSION_PRIVATE | \
					DPSESSION_PASSWORDREQUIRED | \
					DPSESSION_CLIENTSERVER | \
					DPSESSION_MULTICASTSERVER | \
					DPSESSION_OPTIMIZELATENCY | \
					DPSESSION_DIRECTPLAYPROTOCOL | \
					DPSESSION_ALLOWVOICERETRO | \
					DPSESSION_NOSESSIONDESCMESSAGES | \
					DPSESSION_NOPRESERVEORDER ) \
		) )

#define VALIDEX_CODE_PTR( ptr ) \
		( ptr && !IsBadCodePtr( (LPVOID) ptr ) )

#define VALID_DPLAY_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( DPCAPS )) && \
        (ptr->dwSize == sizeof(DPCAPS)))

#define VALID_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPSECURITYDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSECURITYDESC )) && \
        (ptr->dwSize == sizeof(DPSECURITYDESC)))

#define VALID_DPSECURITYDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCREDENTIALS(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCREDENTIALS )) && \
        (ptr->dwSize == sizeof(DPCREDENTIALS)))

#define VALID_DPCREDENTIALS_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_DPACCOUNTDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCHAT(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCHAT )) && \
        (ptr->dwSize == sizeof(DPCHAT)))

#define VALID_SEND_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED | \
                    DPSEND_HIGHPRIORITY | \
                    DPSEND_TRYONCE | \
                    DPSEND_OPENSTREAM | \
                    DPSEND_CLOSESTREAM | \
                    DPSEND_SIGNED | \
                    DPSEND_ENCRYPTED | \
                    DPSEND_NOSENDCOMPLETEMSG | \
                    DPSEND_NOCOPY | \
                    DPSEND_ASYNC) \
		) )

#define VALID_RECEIVE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPRECEIVE_ALL | \
                    DPRECEIVE_TOPLAYER | \
                    DPRECEIVE_FROMPLAYER | \
                    DPRECEIVE_PEEK) \
		) )

#define VALID_CHAT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED) \
		) )

#define VALID_CREATEPLAYER_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPPLAYER_SERVERPLAYER | \
                    DPPLAYER_SPECTATOR) \
		) )

#define VALID_CREATEGROUP_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPGROUP_STAGINGAREA | \
					DPGROUP_HIDDEN) \
		) )

#define VALID_ENUMPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_GROUP | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMGROUPS_HIDDEN | \
					DPENUMGROUPS_SHORTCUT | \
                    DPENUMGROUPS_STAGINGAREA) \
		) )

// Note: allow DPENUMSESSIONS_PREVIOUS here even though its bogus...for compat
#define VALID_ENUMSESSIONS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMSESSIONS_AVAILABLE | \
                    DPENUMSESSIONS_ALL  | \
                    DPENUMSESSIONS_PREVIOUS  | \
                    DPENUMSESSIONS_NOREFRESH  | \
                    DPENUMSESSIONS_ASYNC  | \
                    DPENUMSESSIONS_STOPASYNC  | \
                    DPENUMSESSIONS_PASSWORDREQUIRED  | \
                    DPENUMSESSIONS_RETURNSTATUS) \
		) )

#define VALID_CONNECT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPCONNECT_RETURNSTATUS) \
		) )

#define VALID_OPEN_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPOPEN_JOIN | \
                    DPOPEN_CREATE  | \
                    DPOPEN_RETURNSTATUS ) \
		) )

#define DPCAPS1_SIZE (offsetof(DPCAPS,dwLatency))
#define VALID_DPLAY1_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, DPCAPS1_SIZE) && \
        (ptr->dwSize == DPCAPS1_SIZE))
	
#define IS_LOBBY_OWNED(ptr) \
		(ptr->dwFlags & DPLAYI_DPLAY_LOBBYOWNS)

#define CALLSP(fn,pdata) (fn(pdata))	
#define CALLSPVOID(fn) (fn())	

#define GetPlayerMessageHeader() (LPMSG_PLAYERMESSAGE)(this->lpPlayerMsgPool->Get(this->lpPlayerMsgPool))
#define PlayerMessageFreeFn this->lpPlayerMsgPool->Release
#define PlayerMessageFreeContext this->lpPlayerMsgPool

// For SENDPARM blocks
#define GetSendParms() (LPSENDPARMS)(this->lpSendParmsPool->Get(this->lpSendParmsPool))
#define FreeSendParms(_psp) (this->lpSendParmsPool->Release(this->lpSendParmsPool,(_psp)))

// For MessageNodes
//#define GetMessageNode() (LPMESSAGENODE)(this->lpMsgNodePool->Get(this->lpMsgNodePool))
//#define FreeMessageNode(_pmsn) (this->lpMsgNodePool->Release(this->lpMsgNodePool,(_pmsn))) 

#define TRY 		_try
#define EXCEPT(a)	_except( a )

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
#define DPAPI WINAPI

// constants for passing to inernalenumxxxx
enum 
{
	ENUM_2,
	ENUM_2A,
	ENUM_1
};

// constants for passing to internalreceive
enum 
{
	RECEIVE_2,
	RECEIVE_2A,
	RECEIVE_1
};

/********************************************************************
*                                                                    
* internal errors														 
*                                                                    
********************************************************************/
#define _FACDPI  0x786
#define MAKE_DPIHRESULT( code )    MAKE_HRESULT( 1, _FACDPI, code )

#define DPERR_VERIFYSIGNFAILED                MAKE_DPIHRESULT(  1000 )
#define DPERR_DECRYPTIONFAILED                MAKE_DPIHRESULT(  1010 )


/********************************************************************
*                                                                    
* prototypes														 
*                                                                    
********************************************************************/

// dpunk.c
extern HRESULT 	DPAPI DP_QueryInterface(LPDIRECTPLAY,REFIID riid, LPVOID * ppvObj); 
extern ULONG	DPAPI DP_AddRef(LPDIRECTPLAY);  
extern ULONG 	DPAPI DP_Release(LPDIRECTPLAY); 
extern HRESULT 	GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks);
extern HRESULT 	FreeSessionList(LPDPLAYI_DPLAY this);

// iplay.c

extern HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer); 
extern HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags);
extern HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags);
extern HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP); 
extern HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup); 
extern HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable); 
extern HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent);
extern HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount); 
extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes); 
extern HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) ;
extern HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid); 
extern HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,DWORD dwFlags ); 
extern HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
    LPVOID pvBuffer,LPDWORD pdwSize	); 
extern HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
    LPVOID pvBuffer,DWORD dwBufSize	); 
extern HRESULT DPAPI DP_SendEx(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPVOID lpData, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext,
	DWORD_PTR *lpdwMsgID);
extern HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpSDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials); 
extern HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags, 
                                      BOOL fPropagate);
extern HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags);
extern HRESULT DeallocPlayer(LPDPLAYI_PLAYER);
extern HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,BOOL fEnumOnly,
	DWORD dwFlags,BOOL fStuffInstanceGUID,LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials);
extern HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP,LPVOID pvBuffer,
	LPDWORD pdwSize, BOOL fAnsi);  
extern HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpSessionPassword, DWORD dwLobbyID);
extern HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID);
extern HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate);
extern HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate);
extern HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageData, DWORD cbSPDataSize, BOOL bNotifyProtocol);
extern HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageData,DWORD cbSPDataSize);
extern HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi);
extern HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer);
extern HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,
	BOOL fPropagate, BOOL fLookForNewNS) ;
extern HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,
	BOOL fPropagate);
extern HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,
	BOOL fPropagate); 
extern HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,
	BOOL fPropagate) ;
extern HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	);
extern LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id);
extern HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP, LPDPLAYI_PLAYER);
extern HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) ;	
extern HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) ;
extern HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) ;
extern HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,
	DPID idGroup,BOOL fPropagate);
extern HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove);
extern HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupOwner(LPDIRECTPLAY lpDP, DPID id,LPDPID idOwner);
extern HRESULT DPAPI DP_SetGroupOwner(LPDIRECTPLAY lpDP, DPID id,DPID idNewOwner);
extern HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this);
extern void FreePacketList(LPDPLAYI_DPLAY this);
extern HRESULT InternalGetCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,BOOL fPlayer,DWORD dwFlags);


// enum.c
extern HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pContext,
    DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags);
extern HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi); 
extern HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed);
extern HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi);
extern HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi);
extern HRESULT InternalEnumerate();
extern HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus);
extern HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive);
extern void KillThread(HANDLE hThread,HANDLE hEvent);
extern HRESULT StopEnumThread(LPDPLAYI_DPLAY this);
extern BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
				DWORD dwFlags, LPVOID lpContext);
extern HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) ;	

// namesrv.c
extern LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY,DWORD);
extern LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY,DWORD);
extern HRESULT AddItemToNameTable(LPDPLAYI_DPLAY,DWORD_PTR,DWORD *,BOOL,DWORD);
extern HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY ,DWORD );
extern HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this);
extern BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id);
extern LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD id);
extern DWORD_PTR NameFromID(LPDPLAYI_DPLAY, DWORD);
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID);
extern HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, DWORD cbMessageSize, LPVOID pvSPHeader);
extern HRESULT GrowTable(LPDPLAYI_DPLAY this);
extern void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer);
extern void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer);
extern DPID PlayerIDFromSysPlayerID(LPDPLAYI_DPLAY this,DPID dpidSysPlayer);

// pack.c
extern HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD dwBufferSize, UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader);
extern HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD *pdwBufferSize) ;
extern DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) ;
extern HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked, DWORD cbBuffer,
	LPVOID pvSPHeader,BOOL bPlayer, BOOL bVerifyOnly);


// sysmess.c
extern HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock);
extern HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,void * pPlayerOrGroup,BOOL fPlayer, 
    LPWSTR lpszSessionPassword);
extern HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize);
extern HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp);
extern HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,
	DWORD dwMessageSize,DWORD dwFlags, BOOL bIsPlyrMgmtMsg);
extern HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage);
extern HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage);
extern HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup);
extern HRESULT SendPlayerData(LPDPLAYI_DPLAY this,DPID idChanged,LPVOID pData,
	DWORD dwDataSize);
extern HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendMeNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags);
extern HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer);
extern HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,
	LPADDFORWARDNODE pnode);
extern HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) ;
extern HRESULT DoCreateVerify(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize, LPVOID pvSPHeader) ;
	
// dllmain.c
extern HRESULT FreeSPList();

// iplay1.c
extern HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent);
extern HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName); 
extern HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD_PTR dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD_PTR dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags);
extern HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pContext,
	DWORD dwFlags); 
extern HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength);
extern HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc ); 
extern HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec); 
extern HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,
	LPSTR lpszShortName,LPSTR lpszLongName);       	
	

// iplaya.c						 
extern HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID id,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
    LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) ;
extern HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,
	DWORD dwFlags,LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 pDesc,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc,
    DWORD dwFlags, LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) ;
extern HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr);
extern HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA);
extern HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc);
extern void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi);
extern HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials,BOOL fAnsi);
extern HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, 
    LPCDPCREDENTIALS lpCredentialsA);
extern HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi);
extern HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, 
    LPCDPSECURITYDESC lpSecDescA);
extern HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi);
extern HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);

// pending.c
extern HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this);
extern HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags);


// handler.c
extern HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwMessageFlags);
extern HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus);
extern HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion);
extern HRESULT HandleSessionLost(LPDPLAYI_DPLAY this);
extern HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER, LPBYTE, DWORD, BOOL, DWORD);
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, DWORD, LPVOID);
extern HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize);
extern HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize);
extern HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize);
extern HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion);
extern HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwMessageFlags);
extern DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer);
extern HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) ;
extern HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind);
extern HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion);
extern LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this);
extern VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp);
extern VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom);
 
// sphelp.c
extern HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries);
extern HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
	LPVOID lpContext);
extern HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext);
extern HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);
extern HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);

extern HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext);
extern HRESULT InternalCreateAddress(LPDIRECTPLAYSP pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);

// do.c
extern HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags);
extern HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName);

// paketize.c
extern HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply);
HRESULT PacketizeAndSendReliable(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader, BOOL bReply);
extern HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern void FreePacketNode(LPPACKETNODE pNode);
BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
	DWORD dwFlags);
HRESULT InitPacketize(LPDPLAYI_DPLAY this);
VOID FiniPacketize(LPDPLAYI_DPLAY this);
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this);
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this);
extern CRITICAL_SECTION g_PacketizeTimeoutListLock;

// dpthread.c
extern DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	LPVOID pvMessageHeader);
extern HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate);
	

// api.c
extern void LowerCase(char * lpsz);
extern HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect);
extern LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,
	GUID const *pGuid);
extern HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,
	DWORD dwAddressSize);	
extern void FreeSPNode(LPSPNODE pspNode);
VOID FreeMemoryPools(LPDPLAYI_DPLAY this);
VOID FiniReply(LPDPLAYI_DPLAY this);
HRESULT InitReply(LPDPLAYI_DPLAY this);
VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand);
VOID UnSetupForReply(LPDPLAYI_DPLAY this);
HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, DWORD *pcbReply, LPVOID *ppvSPHeader, DWORD dwTimeout);
VOID FreeReplyBuffer(PCHAR pReplyBuffer);
HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, LPVOID pvSPHeader);

// perf.c
extern DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT InitMappingStuff(LPDPLAYI_DPLAY this);

//connect.c
extern HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags);

// superpac.c
extern HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) ;
extern HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD dwBufferSize,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader);

//sgl.c
void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void FreeMessageBuffers(LPSENDPARMS psp);

//msgmem.c
void * MsgAlloc( int size );
void   MsgFree (void *context, void *pmem);

//sendparm.c
extern BOOL SendInitAlloc(void *pvsp);
extern VOID SendInit(void *pvsp);
extern VOID SendFini(void *pvsp);
extern VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL fFreeParms);

extern HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize);
extern UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext);
extern UINT pspAddRef(PSENDPARMS psp);
extern UINT pspAddRefNZ(PSENDPARMS psp);
extern UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp);

//apphack.c
extern HRESULT GetAppHacks(LPDPLAYI_DPLAY this);

// dpdvtran.c
extern VOID DVoiceNotify(LPDPLAYI_DPLAY this, DWORD dw1, DWORD_PTR dw2, DWORD_PTR dw3, DWORD dwObjectType );
extern VOID DVoiceReceiveSpeechMessage(LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, LPVOID lpvBuffer, DWORD cbBuffer);
extern HRESULT DV_Advise(LPDIRECTPLAY lpDP, LPUNKNOWN lpUnk, DWORD dwObjectType);
extern HRESULT DV_UnAdvise(LPDIRECTPLAY this, DWORD dwObjectType);
extern HRESULT DV_IsGroupMember(LPDIRECTPLAY lpDP, DVID dvidGroup, DVID dvidPlayer);
extern HRESULT DV_SendSpeech(LPDIRECTPLAY lpDP, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags);
extern HRESULT DV_SendSpeechEx(LPDIRECTPLAY lpDP, DVID dvidFrom, DWORD nTargets, PDVID pdvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags);
extern HRESULT DV_GetSessionInfo(LPDIRECTPLAY lpDP, LPDVTRANSPORTINFO lpdvTransportInfo );
extern HRESULT DV_IsValidEntity (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);
extern HRESULT HandleVoiceMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize, DWORD dwSendFlags);
extern HRESULT DV_IsValidGroup (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);
extern HRESULT DV_IsValidPlayer (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);

typedef HRESULT (WINAPI *PFN_DIRECTPLAYCREATE)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUM)(LPDPENUMDPCALLBACK lpEnumCallback,LPVOID lpContext);
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUMA)(LPDPENUMDPCALLBACKA lpEnumCallback, LPVOID lpContext );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_A)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_W)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern PFN_DIRECTPLAYCREATE pfnDirectPlayCreate;
extern PFN_DIRECTPLAYENUMA pfnDirectPlayEnum;
extern PFN_DIRECTPLAYLOBBYCREATE_A pfnDirectPlayLobbyCreateA;
extern PFN_DIRECTPLAYLOBBYCREATE_W pfnDirectPlayLobbyCreateW;
extern PFN_DIRECTPLAYENUMA pfnDirectPlayEnumA;
extern PFN_DIRECTPLAYENUM pfnDirectPlayEnumW;
extern PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow;
extern PFN_DLLGETCLASSOBJECT pfnGetClassObject;

extern HMODULE ghRedirect;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dplaysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysp.h
 *  Content:    DirectPlay Service Provider header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/96    	andyco  created it
 *  1/26/96   	andyco  list data structures
 *	2/15/96		andyco	packed structures (for net xport)
 *	3/16/96		andyco	added shutdown callback
 *	3/25/96		andyco	added sp nodes for sp enum
 *	3/28/96		andyco	added free receive buffer callback
 *	4/9/96		andyco	moved dplayi_dplay, packed player, spnode, etc. to dplaypr.h
 *	4/10/96		andyco	added getmessagesize,isvalidmessage fn's
 *  4/11/96		andyco	added spdata instead of reserving a bunch of dwords
 *	4/12/96		andyco	added dplay_xxx methods to get rid of dpmess.h macros
 *	4/18/96		andyco	added remote players to createplayer, getplayer + group
 *						list fn's
 *	4/25/96		andyco	got rid of dwreservedx. added dwSPHeaderSize. spblob  
 *						follows message
 *	5/2/96		andyco	replaced idirectplay * with iunknown *
 *	5/9/96		andyco	idirectplay2
 *	6/8/96		andyco	moved dplayi_player/group to dplaypr.h. ported from 
 *						(now defunct) dplayi.h.
 *	6/19/96		andyco	changed names, etc. for consistency
 *	6/22/96		andyco	tossed dwCookies. removed pUnk from callbacks.  removed sessiondesc
 *	 					from callbacks.  alphapathetical order.
 *	6/22/96		andyco	made DPlay_xxx functions a COM interface (IDirectPlaySP)
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/23/96		andyco	updated comments. removed bLocal from Create fn's (look 
 *						at flags).
 *	6/23/96		kipo	cleanup for service provider lab.
 *	6/24/96		kipo	added version number
 *	6/24/96		andyco	added getaddress
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/10/96		andyco	added dwflags to createaddress.  changed guid * to
 *						refguid in createaddress call.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  7/30/96     kipo    added DPLAYI_PLAYER_CREATEDPLAYEREVENT
 *  8/23/96     kipo    incremented major version number
 *	10/10/96	andyco	added optimized groups
 *	2/7/97		andyco	added idpsp to each callback
 *	3/04/97		kipo	updated gdwDPlaySPRefCount definition
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *	5/8/97		myronth	added DPLAYI_GROUP_STAGINGAREA (internal)
 *	5/18/97		kipo	added DPLAYI_PLAYER_SPECTATOR
 *	5/23/97		kipo	Added support for return status codes
 *	10/21/97	myronth	Added DPLAYI_GROUP_HIDDEN
 *	10/29/97	myronth	Added DPLAYI_PLAYER_OWNER (internal)
 *	10/31/97	andyco	added voice call
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohailm	Added dwSessionFlags to DPSP_OPENDATA
 *  4/1/98      aarono  Added DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE
 *  6/2/98		aarono  Added DPLAYI_PLAYER_BEING_DESTROYED to avoid
 *                       deleting more than once.
 *  8/02/99		aarono  removed old voice support
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAYSP_INCLUDED__
#define __DPLAYSP_INCLUDED__

#include "dplay.h"
#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectPlay Service Provider Structures
 *
 * Various structures used to invoke DirectPlay Service Providers.
 *
 *==========================================================================*/

/*
 * Callback for EnumMRU()
 */
typedef BOOL (PASCAL *LPENUMMRUCALLBACK)(
    LPCVOID         lpData,
    DWORD           dwDataSize,
    LPVOID          lpContext);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPSP_MAJORVERSION               0x00060000

/*
 * This is the major version number that DirectX 3 (DX3) shipped with
 */
#define DPSP_DX3VERSION               	0x00040000

/*
 * This is the major version number that DirectX 5 (DX5) shipped with
 */
#define DPSP_DX5VERSION               	0x00050000

/*
 * Masks to help check the version info
 */
#define DPSP_MAJORVERSIONMASK			0xFFFF0000

#define DPSP_MINORVERSIONMASK			0x0000FFFF

/*
 * DPLAYI_PLAYER_FLAGS
 *
 * These flags may be used with players or groups, as appropriate.
 * The service provider can get these by calling IDirectPlaySP->GetFlags()
 * as defined below.  The flags are also available in the dwFlags field
 * for most of the callback data structures.
 * 
 * These flags are set by DirectPlay - they are read only for the 
 * service provider
 *
 */

/*
 * Player is the system player (player only).
 */
#define DPLAYI_PLAYER_SYSPLAYER         0x00000001

/* 
 * Player is the name server (player only). Only valid when 
 * DPLAYI_PLAYER_SYSPLAYER is also set.
 */
#define DPLAYI_PLAYER_NAMESRVR          0x00000002

/*
 * Player belongs to a group (player only).
 */
#define DPLAYI_PLAYER_PLAYERINGROUP     0x00000004

/*
 * Player allocated on this IDirectPlay (player or group).
 */
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

//@@BEGIN_MSINTERNAL
/*
 * Player event allocated by DirectPlay (player only).
 * Used for compatability with the IDirectPlay1 API.
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_CREATEDPLAYEREVENT 0x00000010
//@@END_MSINTERNAL

/*
 * This group is the system group.  If the service provider returns
 * DPCAPS_GROUPOPTIMIZED on a GetCaps call, then DirectPlay will create
 * a system group containing all players in the game.  Sends by the application
 * to DPID_ALLPLAYERS will be sent to this group.  (group only).
 *												   
 */
#define DPLAYI_GROUP_SYSGROUP			0x00000020

/*
 * DirectPlay "owns" this group.  Sends to this group will be emulated by DirectPlay
 * (sends go to each individual member).  This flag  is set on a group if the
 * Service Provider returns failure to the CreateGroup or AddPlayerToGroup
 * callback. (group only).
 *
 */
#define DPLAYI_GROUP_DPLAYOWNS			0x00000040

/*
 * This player is the app's server player
 */
#define DPLAYI_PLAYER_APPSERVER       	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * This group is a staging area
 */
#define DPLAYI_GROUP_STAGINGAREA       	0x00000100
//@@END_MSINTERNAL

/*
 * This player is a spectator
 */
#define DPLAYI_PLAYER_SPECTATOR       	0x00000200

/*
 * This group is hidden
 */
#define DPLAYI_GROUP_HIDDEN		       	0x00000400

//@@BEGIN_MSINTERNAL
/*
 * Player is the owner of a group.  (Only used
 * internally, and only used during EnumGroupPlayers).
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_OWNER             0x00000800

// a-josbor: Internal flag that gets set when the Keepalive has
//	determined that this player should be killed
#define DPLAYI_PLAYER_ON_DEATH_ROW		0x00001000

// aarono: use this flag to mark players waiting for nametable.
// any sends to these players just return DPERR_UNAVAILABLE
// this bit is cleared when we transmit the nametable.
#define DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE 0x00002000

// a-josbor: set when we get an error back on a reliable
// send.  We don't kill them right away because there might
// be messages pending from them
#define DPLAYI_PLAYER_CONNECTION_LOST		0x00004000
/*
 * Used to stop re-entering destory player
 */
#define DPLAYI_PLAYER_BEING_DESTROYED 0x00010000

#define DPLAYI_PLAYER_NONPROP_FLAGS ( DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE | \
									  DPLAYI_PLAYER_BEING_DESTROYED | \
									  DPLAYI_PLAYER_ON_DEATH_ROW |\
									  DPLAYI_PLAYER_CONNECTION_LOST )

//@@END_MSINTERNAL


/*
 *	IDirectPlaySP
 *
 *	Service providers are passed an IDirectPlaySP interface
 *	in the SPInit method. This interface is used to call DirectPlay.
 */

struct IDirectPlaySP;

typedef struct IDirectPlaySP FAR* LPDIRECTPLAYSP;

#undef INTERFACE
#define INTERFACE IDirectPlaySP
DECLARE_INTERFACE_( IDirectPlaySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlaySP methods ***/
    STDMETHOD(AddMRUEntry)          (THIS_ LPCWSTR, LPCWSTR, LPCVOID, DWORD, DWORD) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID,REFGUID,LPCVOID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK,LPCVOID,DWORD,LPVOID) PURE;
    STDMETHOD(EnumMRUEntries)       (THIS_ LPCWSTR, LPCWSTR, LPENUMMRUCALLBACK, LPVOID) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetSPPlayerData)      (THIS_ DPID,LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(HandleMessage)        (THIS_ LPVOID,DWORD,LPVOID) PURE;
    STDMETHOD(SetSPPlayerData)      (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 5 ***/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSPData)      		(THIS_ LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(SetSPData)      		(THIS_ LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 6 ***/
    STDMETHOD_(VOID,SendComplete)   (THIS_ LPVOID,DWORD) PURE;
};

/*
 * GUID for IDirectPlaySP
 */
// {0C9F6360-CC61-11cf-ACEC-00AA006886E3}
DEFINE_GUID(IID_IDirectPlaySP, 0xc9f6360, 0xcc61, 0x11cf, 0xac, 0xec, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

/* CALLBACK DATA STRUCTURES
 *
 * These are passed by DirectPlay to the service provider when
 * the callback is invoked.
 */

/*
 * DPSP_ADDPLAYERTOGROUPDATA
 */
typedef struct _DPSP_ADDPLAYERTOGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_ADDPLAYERTOGROUPDATA;

typedef DPSP_ADDPLAYERTOGROUPDATA FAR* LPDPSP_ADDPLAYERTOGROUPDATA;

/*
 * DPSP_CLOSEDATA - used with CloseEx
 */
typedef struct _DPSP_CLOSEDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CLOSEDATA;

typedef DPSP_CLOSEDATA FAR* LPDPSP_CLOSEDATA;

/*
 * DPSP_CREATEGROUPDATA
 */
typedef struct _DPSP_CREATEGROUPDATA 
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    /*** fields added for security sweep ***/
    DWORD		cbSPDataSize;		// size of data pointed to by lpSPMessageHeader
} DPSP_CREATEGROUPDATA;

typedef DPSP_CREATEGROUPDATA FAR* LPDPSP_CREATEGROUPDATA;

/*
 * DPSP_CREATEPLAYERDATA
 */
typedef struct _DPSP_CREATEPLAYERDATA
{
    DPID        idPlayer;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    /*** fields added for security sweep ***/
    DWORD		cbSPDataSize;		// size of data pointed to by lpSPMessageHeader
} DPSP_CREATEPLAYERDATA;

typedef DPSP_CREATEPLAYERDATA FAR* LPDPSP_CREATEPLAYERDATA;

/*
 * DPSP_DELETEGROUPDATA
 */
typedef struct _DPSP_DELETEGROUPDATA
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEGROUPDATA;

typedef DPSP_DELETEGROUPDATA FAR* LPDPSP_DELETEGROUPDATA;

/*
 * DPSP_DELETEPLAYERDATA
 */
typedef struct _DPSP_DELETEPLAYERDATA
{
    DPID        idPlayer;           //  player being deleted 
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEPLAYERDATA;

typedef DPSP_DELETEPLAYERDATA FAR* LPDPSP_DELETEPLAYERDATA;

/*
 * DPSP_ENUMSESSIONSDATA
 */
typedef struct _DPSP_ENUMSESSIONSDATA
{
    LPVOID      lpMessage;          //  enum message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      //  TRUE to return status on progress of enum
} DPSP_ENUMSESSIONSDATA;                

typedef DPSP_ENUMSESSIONSDATA FAR* LPDPSP_ENUMSESSIONSDATA;

/*
 * DPSP_GETADDRESSDATA
 */
typedef struct _DPSP_GETADDRESSDATA
{ 
    DPID        idPlayer;           // player (or group) to get ADDRESS for 
    DWORD       dwFlags;            // DPLAYI_PLAYER_xxx flags for idPlayer
    LPDPADDRESS lpAddress;          // return buffer for address of idPlayer
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSDATA;

typedef DPSP_GETADDRESSDATA FAR* LPDPSP_GETADDRESSDATA;

/*
 * DPSP_GETADDRESSCHOICESDATA
 */
typedef struct _DPSP_GETADDRESSCHOICESDATA
{ 
    LPDPADDRESS lpAddress;          // return buffer for address choices
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSCHOICESDATA;

typedef DPSP_GETADDRESSCHOICESDATA FAR* LPDPSP_GETADDRESSCHOICESDATA;

/*
 * DPSP_GETCAPSDATA
 */
typedef struct _DPSP_GETCAPSDATA
{ 
    DPID        idPlayer;           //  player to get caps for 
    LPDPCAPS    lpCaps;
    DWORD       dwFlags;            //  DPGETCAPS_xxx 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETCAPSDATA;

typedef DPSP_GETCAPSDATA FAR* LPDPSP_GETCAPSDATA;

/*
 * DPSP_OPENDATA
 */
typedef struct _DPSP_OPENDATA
{ 
    BOOL        bCreate;            // TRUE if creating, FALSE if joining 
    LPVOID      lpSPMessageHeader;  // If we are joining a session, lpSPMessageData 
                                    // is the message data received with the 
                                    // EnumSessionsReply message. If we are creating 
                                    // a session, it will be set to NULL. 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      // TRUE to return status on progress of open
    /*** fields added for DX 6 ***/    
    DWORD		dwOpenFlags;		// flags passed by app to IDirectPlayX->Open(...)
    DWORD		dwSessionFlags;		// flags passed by app in the session desc
} DPSP_OPENDATA;

typedef DPSP_OPENDATA FAR* LPDPSP_OPENDATA;

/*
 * DPSP_REMOVEPLAYERFROMGROUPDATA
 */
typedef struct _DPSP_REMOVEPLAYERFROMGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REMOVEPLAYERFROMGROUPDATA;

typedef DPSP_REMOVEPLAYERFROMGROUPDATA FAR* LPDPSP_REMOVEPLAYERFROMGROUPDATA;

/*
 * DPSP_REPLYDATA
 */
typedef struct _DPSP_REPLYDATA
{			  
    LPVOID      lpSPMessageHeader;  //  header that was received by dplay 
                                    // (with the message we're replying to) 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    DPID        idNameServer;       //  player id of nameserver 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REPLYDATA;               

typedef DPSP_REPLYDATA FAR* LPDPSP_REPLYDATA;

/*
 * DPSP_SENDDATA
 */
typedef struct _DPSP_SENDDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDDATA;

typedef DPSP_SENDDATA FAR* LPDPSP_SENDDATA;

/*
 * DPSP_SENDTOGROUPDATA
 */
typedef struct _DPSP_SENDTOGROUPDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDTOGROUPDATA;

typedef DPSP_SENDTOGROUPDATA FAR* LPDPSP_SENDTOGROUPDATA;

/*
 * DPSP_SENDEXDATA
 */
typedef struct _DPSP_SENDEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    
} DPSP_SENDEXDATA;

typedef DPSP_SENDEXDATA FAR* LPDPSP_SENDEXDATA;


/*
 * DPSP_SENDTOGROUPEXDATA
 */
typedef struct _DPSP_SENDTOGROUPEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.

} DPSP_SENDTOGROUPEXDATA;

typedef DPSP_SENDTOGROUPEXDATA FAR* LPDPSP_SENDTOGROUPEXDATA;

/*
 * DPSP_GETMESSAGEQUEUE
 */
typedef struct _DPSP_GETMESSAGEQUEUEDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;
	DPID            idFrom;			
	DPID            idTo;
	LPDWORD         lpdwNumMsgs;
	LPDWORD         lpdwNumBytes;

} DPSP_GETMESSAGEQUEUEDATA;

typedef DPSP_GETMESSAGEQUEUEDATA FAR* LPDPSP_GETMESSAGEQUEUEDATA;

/*
 * DPSP_CANCELSEND
 */
 
#define DPCANCELSEND_PRIORITY		0x00000001
#define DPCANCELSEND_ALL            0x00000002

typedef struct _DPSP_CANCELDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;        // 0,DPCANCELSEND_PRIORITY,DPCANCELSEND_ALL,etc.
	LPRGLPVOID      lprglpvSPMsgID; // cancel just these messages      (dwFlags == 0)
	DWORD           cSPMsgID;       // number of message id's in array (dwFlags == 0)
	DWORD           dwMinPriority;  // cancel all sends at this priority (dwFlags==DPCANCELSEND_PRIORITY)
	DWORD           dwMaxPriority;  // cancel all sends between Min and Max.
	
} DPSP_CANCELDATA;

typedef DPSP_CANCELDATA FAR* LPDPSP_CANCELDATA;

/*
 * DPSP_SHUTDOWNDATA - used with ShutdownEx
 */
typedef struct _DPSP_SHUTDOWNDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SHUTDOWNDATA;

typedef DPSP_SHUTDOWNDATA FAR* LPDPSP_SHUTDOWNDATA;

/*
 * Prototypes for callbacks returned by SPInit.
 */
typedef HRESULT   (WINAPI *LPDPSP_CREATEPLAYER)(LPDPSP_CREATEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEPLAYER)(LPDPSP_DELETEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_SEND)(LPDPSP_SENDDATA);
typedef HRESULT   (WINAPI *LPDPSP_ENUMSESSIONS)(LPDPSP_ENUMSESSIONSDATA);
typedef HRESULT   (WINAPI *LPDPSP_REPLY)(LPDPSP_REPLYDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWN)(void);
typedef HRESULT   (WINAPI *LPDPSP_CREATEGROUP)(LPDPSP_CREATEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEGROUP)(LPDPSP_DELETEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_ADDPLAYERTOGROUP)(LPDPSP_ADDPLAYERTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_REMOVEPLAYERFROMGROUP)(LPDPSP_REMOVEPLAYERFROMGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETCAPS)(LPDPSP_GETCAPSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESS)(LPDPSP_GETADDRESSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESSCHOICES)(LPDPSP_GETADDRESSCHOICESDATA);
typedef HRESULT   (WINAPI *LPDPSP_OPEN)(LPDPSP_OPENDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSE)(void);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUP)(LPDPSP_SENDTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWNEX)(LPDPSP_SHUTDOWNDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSEEX)(LPDPSP_CLOSEDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDEX)(LPDPSP_SENDEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUPEX)(LPDPSP_SENDTOGROUPEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_CANCEL)(LPDPSP_CANCELDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETMESSAGEQUEUE)(LPDPSP_GETMESSAGEQUEUEDATA);

/*
 * DPSP_SPCALLBACKS
 *
 * Table of callback pointers passed to SPInit. The service provider should fill
 * in the functions it implements. If the service provider does not implement
 * a callback, it should not set the table value for the unimplemented callback.
 */
typedef struct _DPSP_SPCALLBACKS
{
    DWORD                       dwSize;             //  size of table 
    DWORD                       dwVersion;			// 	the DPSP_MAJORVERSION of this DPLAY object
													// 	for DX3, this was 0. 
    LPDPSP_ENUMSESSIONS         EnumSessions;       //  required 
    LPDPSP_REPLY                Reply;              //  required 
    LPDPSP_SEND                 Send;               //  required 
    LPDPSP_ADDPLAYERTOGROUP     AddPlayerToGroup;   //  optional 
    LPDPSP_CLOSE                Close;              //  optional - for DX3 compat only
    LPDPSP_CREATEGROUP          CreateGroup;        //  optional 
    LPDPSP_CREATEPLAYER         CreatePlayer;       //  optional 
    LPDPSP_DELETEGROUP          DeleteGroup;        //  optional 
    LPDPSP_DELETEPLAYER         DeletePlayer;       //  optional 
    LPDPSP_GETADDRESS           GetAddress;         //  optional 
    LPDPSP_GETCAPS              GetCaps;            //  required 
    LPDPSP_OPEN                 Open;               //  optional 
    LPDPSP_REMOVEPLAYERFROMGROUP RemovePlayerFromGroup; //  optional 
    LPDPSP_SENDTOGROUP          SendToGroup;        //  optional 
    LPDPSP_SHUTDOWN             Shutdown;           //  optional - for DX3 compat only
    /*** fields added for DX 5 ***/
    LPDPSP_CLOSEEX	            CloseEx;			//  optional 
    LPDPSP_SHUTDOWNEX			ShutdownEx;			//  optional 
    LPDPSP_GETADDRESSCHOICES	GetAddressChoices;	//  optional 
	/*** fields added for DX 6 ***/
    /*** for async ***/
    LPDPSP_SENDEX               SendEx;             //  optional - required for async
    LPDPSP_SENDTOGROUPEX        SendToGroupEx;      //  optional - optional for async
    LPDPSP_CANCEL               Cancel;             //  optional - optional for async, highly recommended
    LPDPSP_GETMESSAGEQUEUE      GetMessageQueue;    //  optional - optional for async, highly recommended
} DPSP_SPCALLBACKS;             

typedef DPSP_SPCALLBACKS FAR *LPDPSP_SPCALLBACKS;

/*
 * SPINITDATA
 *
 * Data structure passed to the service provider at SPInit.
 */
typedef struct _SPINITDATA 
{
    LPDPSP_SPCALLBACKS  lpCB;               //  service provider fills in entry points 
    IDirectPlaySP      	* lpISP;            //  used to call back into DirectPlay 
                                            // (e.g. when message is received) 
    LPWSTR              lpszName;           //  service provider name from registry 
    LPGUID              lpGuid;             //  service provider GUID from registry 
    DWORD               dwReserved1;        //  service provider-specific data from registry 
    DWORD               dwReserved2;        //  service provider-specific data from registry 
    DWORD               dwSPHeaderSize;     //  dwSPHeaderSize is the size of the 
                                            //  data the sp wants stored with each message.
                                            //  DirectPlay will allocate dwSPHeaderSize 
                                            //  bytes at the beginning of each message.
                                            //  The service provider can then do what 
                                            //  they want with these. 
    LPDPADDRESS         lpAddress;          //  address to use for connection
    DWORD               dwAddressSize;      //  size of address data
    DWORD               dwSPVersion;        //  version number 16 | 16 , major | minor version 
} SPINITDATA;

typedef SPINITDATA FAR* LPSPINITDATA;

/*
 * SPInit
 *
 * DirectPlay calls this function to initialize the service provider.
 * All service providers must export this entry point from their DLL.
 */
typedef HRESULT (WINAPI *LPDPSP_SPINIT)(LPSPINITDATA);

HRESULT WINAPI SPInit(LPSPINITDATA);

/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the service
 * provider, the server provider should statically link to DPLAYX.LIB and
 * increment this global during the SPINIT call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpmem.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.c
*  Content:	Memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/
#include "dplaypr.h"
#include "memalloc.h"
  
#ifdef MEMFAIL
#pragma message ("NOTE: Building with the MEMFAIL option")

//
// Typedefs for memory failure functions
//
typedef enum {NONE, RANDOM, BYTES, ALLOCS, OVERSIZED, TIME} FAILKEY;

FAILKEY	g_FailKey;
DWORD	g_dwSeed=0;
DWORD	g_dwStartTime=0;
DWORD	g_dwFailAfter=0;
BOOL	g_bKeepTally=FALSE;
DWORD	g_dwAllocTally=0;
DWORD	g_dwByteTally=0;

DWORD	g_dwAllocsBeforeFail=0;
DWORD	g_dwAllocsSinceFail=0;

BOOL	DPMEM_ForceFail( UINT uSize );
void	WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes );
void	ReadMemFailRegKeys( void );

#endif


//
// Globals
//
CRITICAL_SECTION	gcsMemoryCritSection;


//
// Definitions
//

#define ENTER_DPMEM() EnterCriticalSection(&gcsMemoryCritSection);
#define LEAVE_DPMEM() LeaveCriticalSection(&gcsMemoryCritSection);


//
// Functions
//
#undef DPF_MODNAME
#define DPF_MODNAME	"MemoryFunctions"


LPVOID DPMEM_Alloc(UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemAlloc(size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


LPVOID DPMEM_ReAlloc(LPVOID ptr, UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemReAlloc(ptr, size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


void DPMEM_Free(LPVOID ptr)
{

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	MemFree(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();
}


BOOL DPMEM_Init()
{
	BOOL	bReturn;


	// Call the heap routine
	bReturn = MemInit();	

	return bReturn;
}


void DPMEM_Fini()
{

	// Call the heap routine
	MemFini();	

}


void DPMEM_State()
{

	// NOTE: This function is only defined for debug
#ifdef DEBUG

	// Call the heap routine
	MemState();	

#endif // DEBUG

}


UINT_PTR DPMEM_Size(LPVOID ptr)
{
	UINT_PTR	uReturn;


	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	uReturn = MemSize(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return uReturn;
}


/////////////////////
#ifdef MEMFAIL
////////////////////

void ReadMemFailRegKeys( void )
{
    HKEY	hKey	= NULL;
    HRESULT hr		= DP_OK;
	char	szFailKey[256];

    // Open the reg key
    hr  = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
						"Software\\Microsoft\\DirectPlay\\MemFail", 0, 
						KEY_READ, 
						&hKey);

	if(ERROR_SUCCESS == hr)
	{
		DWORD	dwKeyType;
		DWORD	dwBufferSize;

		dwBufferSize = 256;
		hr=RegQueryValueExA(hKey, "FailKey", NULL, &dwKeyType,
							(BYTE *)szFailKey, &dwBufferSize  );
		if (FAILED(hr))
			goto FAILURE;

		// Set the g_FailKey based on the string we got from the registry
		if (!strcmp(szFailKey, "NONE"))
			g_FailKey	= NONE;

		if (!strcmp(szFailKey, "RANDOM"))
			g_FailKey	= RANDOM;
		
		if (!strcmp(szFailKey, "BYTES"))
			g_FailKey	= BYTES;
		
		if (!strcmp(szFailKey, "ALLOCS"))
			g_FailKey	= ALLOCS;
		
		if (!strcmp(szFailKey, "OVERSIZED"))
			g_FailKey	= OVERSIZED;
		
		if (!strcmp(szFailKey, "TIME"))
			g_FailKey	= TIME;

		dwBufferSize = sizeof(DWORD);
		hr=RegQueryValueExA(hKey, "FailAfter", NULL, &dwKeyType, (BYTE *) &g_dwFailAfter, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;

		dwBufferSize = sizeof(BOOL);
		hr=RegQueryValueExA(hKey, "KeepTally", NULL, &dwKeyType, (BYTE *) &g_bKeepTally, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;
    }

FAILURE:
	// Close the registry key
	hr=RegCloseKey(hKey);
	return;
}



void WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes )
{
	HRESULT		hr				= E_FAIL;
	HKEY		hKey			= NULL;

    // Open the reg key
    hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
							"Software\\Microsoft\\DirectPlay\\MemFail", 
							0,
							KEY_ALL_ACCESS, 
							&hKey );

	if (ERROR_SUCCESS != hr)
	{
		HKEY hKeyTop = NULL;
		hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
								"Software\\Microsoft\\DirectPlay", 
								0,
								KEY_ALL_ACCESS, 
								&hKeyTop);

		hr = RegCreateKeyA( hKeyTop,  "MemFail", &hKey );

		if (FAILED(hr))
			 goto FAILURE;

		RegCloseKey(hKeyTop);
	}

    hr=RegSetValueExA(hKey, "AllocTally",	0, REG_DWORD, (CONST BYTE *) &dwAllocs, sizeof(DWORD) );
    hr=RegSetValueExA(hKey, "ByteTally",	0, REG_DWORD, (CONST BYTE *) &dwBytes, sizeof(DWORD) );

FAILURE:
    // Close the registry key
    hr=RegCloseKey(hKey);
    return;
}


//
// Called with each memory allocation or reallocation
//
// Based on criteria from the registry, and the status of previous allocs
// this will either make the allocation succeed or fail.
//
BOOL DPMEM_ForceFail( UINT uSize )
{
	BOOL	bFail=FALSE;

	// If this is the first call, initialize the seed
	if (!g_dwSeed)
	{
		g_dwSeed	= GetTickCount();
		srand( g_dwSeed );
	}

	// Store the time of the first memory allocation
	if (!g_dwStartTime)
		g_dwStartTime	= GetTickCount();
	 
	// See what values are in the registry
	ReadMemFailRegKeys();

	//
	// Depending on what value the FailKey reg entry holds, fail, or pass
	//
	switch (g_FailKey)
	{
		case ALLOCS:
			if (g_dwAllocTally == g_dwFailAfter)
				return TRUE;
		break;

		case BYTES:
			if ((g_dwByteTally + uSize) > g_dwFailAfter)
				return TRUE;
		break;

		case OVERSIZED:
			if ( uSize > g_dwFailAfter )
				return TRUE;
		break;

		case RANDOM:
			if (!g_dwAllocsBeforeFail && g_dwFailAfter)
				g_dwAllocsBeforeFail	= rand() % g_dwFailAfter;

			if (g_dwAllocsSinceFail == g_dwAllocsBeforeFail)
			{
				g_dwAllocsSinceFail		= 0;
				g_dwAllocsBeforeFail	= 0;
				return TRUE;
			}
			else
				g_dwAllocsSinceFail++;
		break;

		case TIME:
			if ((GetTickCount() - g_dwStartTime) > (g_dwFailAfter * 1000))
				return TRUE;
		break;
	}

	// Increment our tallys
	g_dwAllocTally++;
	g_dwByteTally += uSize;

	// Write them back to the registry, if requested
	if (g_bKeepTally)
		WriteMemFailRegTally( g_dwAllocTally, g_dwByteTally );

	return bFail;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpmem.h ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.h
*  Content:	Header file for memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/

extern CRITICAL_SECTION gcsMemoryCritSection; // From dpmem.c


LPVOID DPMEM_Alloc(UINT);
LPVOID DPMEM_ReAlloc(LPVOID, UINT);
void DPMEM_Free(LPVOID);
void DPMEM_Fini(void);
void DPMEM_State(void);
BOOL DPMEM_Init(void);
UINT_PTR DPMEM_Size(LPVOID);


#define INIT_DPMEM_CSECT() InitializeCriticalSection(&gcsMemoryCritSection);
#define FINI_DPMEM_CSECT() DeleteCriticalSection(&gcsMemoryCritSection);

#define DPMEM_ALLOC(size) DPMEM_Alloc(size)
#define DPMEM_REALLOC(ptr, size) DPMEM_ReAlloc(ptr, size)
#define DPMEM_FREE(ptr) DPMEM_Free(ptr)
// These can be used so bounds checker can find leaks
//#define DPMEM_ALLOC(size) GlobalAlloc(GPTR, (size))
//#define DPMEM_REALLOC(ptr,size) GlobalReAlloc(ptr, size, 0)
//#define DPMEM_FREE(ptr) GlobalFree(ptr)

#define DPMEM_FINI() DPMEM_Fini()
#define DPMEM_STATE() DPMEM_State()
#define DPMEM_INIT() DPMEM_Init()
#define DPMEM_SIZE() DPMEM_Size()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpprot.h
 *  Content:	DirectPlay reliable protocol header for dplay.
 *
 *  Notes:      code backing this up in protocol.lib
 *
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 5/11/97 aarono   created
 * 2/18/98 aarono   added protos of Protocol* functions 
 * 2/19/98 aarono   eliminated ProtocolShutdown, ProtocolShutdownEx.
 *                  added FiniProtocol. Shuts down on DP_Close now.
 * 3/19/98 aarono   added ProtocolPreNotifyDeletePlayer
 ***************************************************************************/

#ifndef _DPPROT_H_
#define _DPPROT_H_

extern HRESULT WINAPI InitProtocol(LPDPLAYI_DPLAY this);
extern VOID    WINAPI FiniProtocol(LPVOID pProtocol);
extern HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
extern HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
extern HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
extern HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);

// New APIs for DX6
extern HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData);
extern HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData);
extern HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pGetMessageQueueData);

// Notify protocol when a DELETEPLAYER message is pended, so it can stop any ongoing sends.
extern HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer);

extern DWORD bForceDGAsync;

HRESULT 
DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader
	);

extern
VOID 
DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpos.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.h
 *  Content:	Function prototypes for OS wrapper functions
 *  History:
 *	Date	By		Reason
 *	====	==		======
 *	6/19/96	myronth	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96 andyco	changed the interface to GetAnsiString() to return an HRESULT
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/20/98	myronth	Moved PRV_SendStandardSystemMessage to dplobbyi.h
***************************************************************************/
#ifndef __DPOS_INCLUDED__
#define __DPOS_INCLUDED__

BOOL OS_IsPlatformUnicode(void);
BOOL OS_IsValidHandle(HANDLE handle);
HRESULT OS_CreateGuid(LPGUID pGuid);
int OS_StrLen(LPCWSTR lpwStr);
int OS_StrnLen(LPWSTR lpwStr, INT dwMaxLen, BOOL bForceTermination);
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2);
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWide,LPSTR pszAnsi);
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR pszWide);
HRESULT GetString(LPWSTR * ppszDest,LPWSTR pszSrc);
HINSTANCE OS_LoadLibrary(LPWSTR pszWFileName);
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName);
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL InitialState, LPWSTR lpName);
HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName);
HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName);
HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI);
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid);
HRESULT StringFromGUID(LPGUID lpGuid, LPWSTR lpwszGuid, DWORD dwBufferSize);
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize);
LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR pvKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult);	
LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData);	
LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszName,LPDWORD lpcchName,LPDWORD lpdwReserved,
	LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite );
long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData);
long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName);
long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName);
DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer);
int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2);
LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2);


#endif // __DPOS_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.c
 *  Content:	DirectPlay OS functions, and misc utils.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  5/7/96	andyco	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96	andyco	changed the interface to GetAnsiString() to return an HRESULT
 *  6/30/96 dereks  Added OS_RegSetValueEx(), OS_RegEnumValue(),
 *                  OS_RegDeleteValue(), OS_RegCreateKeyEx()
 *  7/3/96	andyco	GetAnsiString puts terminating NULL on string
 *	8/16/96	andyco	check for null strings on ansitowide and widetoansi
 *	12/11/96myronth	Fixed bug #4993
 *	3/31/97	myronth	Fixed DPF spew for getting shared buffer -- set it to 8
 *	8/22/97	myronth	Fixed OS_CreateGuid to use SUCCEEDED macro & return a
 *					valid hresult in the failure case (#10949)
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/26/98	myronth	Added OS_CompareString function
 *  6/25/99 aarono  B#24853 Unregister application not working because GUID
 *                  matching not working for GUID that don't have msb set
 *                  in the first GUID component.  Added padding before check.
 *  7/9/99  aarono  Cleaning up GetLastError misuse, must call right away,
 *                  before calling anything else, including DPF.
 *  5/16/01 RichGr  B#50737 Lobby-launched apps with a NULL current directory 
 *                  were failing on Win9x as the required buffer size was not being
 *                  returned from OS_GetCurrentDirectory().  Now fixed. 
 ****************************************************************************/
// note - these are not general purpose routines.  they are designed specifically
// for use with the file api.c, and they may not support all functionality of the
// function they are abstracting!

#include "dplaypr.h"
#include "rpc.h"

#undef DPF_MODNAME
#define DPF_MODNAME "OS_"

BOOL OS_IsPlatformUnicode()
{
	OSVERSIONINFOA	ver;
	BOOL			bReturn = FALSE;


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Just always call the ANSI function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- setting flag to ANSI");
		bReturn = FALSE;
	}
	else
	{
		switch(ver.dwPlatformId)
		{
			case VER_PLATFORM_WIN32_WINDOWS:
				DPF(9, "Platform detected as non-NT -- setting flag to ANSI");
				bReturn = FALSE;
				break;

			case VER_PLATFORM_WIN32_NT:
				DPF(9, "Platform detected as NT -- setting flag to Unicode");
				bReturn = TRUE;
				break;

			default:
				DPF_ERR("Unable to determine platform -- setting flag to ANSI");
				bReturn = FALSE;
				break;
		}
	}

	// Keep the compiler happy
	return bReturn;

}  // OS_IsUnicodePlatform


BOOL OS_IsValidHandle(HANDLE handle)
{
	HANDLE	hTemp;
	DWORD	dwError;


	// Validate the handle by calling DuplicateHandle.  This function
	// shouldn't change the state of the handle at all (except some
	// internal ref count or something).  So if it succeeds, then we
	// know we have a valid handle, otherwise, we will call it invalid.
	if(!DuplicateHandle(GetCurrentProcess(), handle,
						GetCurrentProcess(), &hTemp,
						DUPLICATE_SAME_ACCESS, FALSE,
						DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		DPF(0, "Duplicate Handle failed -- dwError = %lu",dwError);
		return FALSE;
	}

	// Now close our duplicate handle
	CloseHandle(hTemp);
	return TRUE;


} // OS_IsValidHandle


HRESULT OS_CreateGuid(LPGUID pGuid)
{
	RPC_STATUS rval;

	rval = UuidCreate(pGuid);

	// myronth -- changed this to use the succeeded macro so that in the
	// case where we are on a machine that doesn't have a network card,
	// this function will return a warning, but the pGuid will still be
	// unique enough for our purposes (only unique to the local machine).
	// Therefore, we will return a success in this case...
	if (SUCCEEDED(rval))
	{
		return DP_OK;
	}
	else
	{
		ASSERT(FALSE);
		DPF(0,"create guid failed - error = %d\n",rval);
		return rval;
	}

} // OS_CreateGuid

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;

    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++;
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		else
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	char lpTemp[GUID_STRING_SIZE];
	char *lpStr = lpTemp;

	memset(lpTemp,0,GUID_STRING_SIZE); // initialize
	
	WideToAnsi(lpStr,lpWStr,GUID_STRING_SIZE);

	lpTemp[GUID_STRING_SIZE-1]='\0';	// force NULL termination
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;

	// Fix for B#24853 GUIDs that don't have full significance fail
	// to be extracted properly.  This is because there aren't any
	// leading zeros stored in the GUID in the registry.  So we need
	// to zero pad the start of the GUID string before doing the
	// rest of the conversion.
	{
		int guidStrLen;
		char *lpScanStr=lpStr;

		guidStrLen=strlen(lpTemp);
		
		lpTemp[guidStrLen]='-'; //sentinel over terminating NULL

		while(*lpScanStr != '-'){ // find guid component separator
			lpScanStr++;
		}

		lpTemp[guidStrLen]='\0'; //eliminate sentinel

		// if this GUID's first component is not fully significant, then pad it.
		if(lpScanStr-lpStr < 8){
			int nPadBytes;
			nPadBytes = (int)(8-(lpScanStr-lpStr));
			if(guidStrLen + nPadBytes < GUID_STRING_SIZE-1){
				// there is room to pad it, so shift it.
				memmove(lpStr+nPadBytes, lpStr, GUID_STRING_SIZE-nPadBytes-1);
				// now write the pad bytes
				lpScanStr = lpStr;
				while(nPadBytes--){
					*(lpScanStr++)='0';
				}
			}
		}
	}
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr)
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString


// convert passed in guid to a string and place it in the buffer passed in
HRESULT StringFromGUID(LPGUID lpg, LPWSTR lpwszGuid, DWORD dwBufferSize)
{
	CHAR	szGuid[GUID_STRING_SIZE];


	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	if(gbWin95)
	{
		wsprintfA(szGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

		AnsiToWide(lpwszGuid, szGuid, lstrlenA(szGuid)+1);
	}
	else
	{
		wsprintf(lpwszGuid, TEXT("{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), lpg->Data1, lpg->Data2,
			lpg->Data3, lpg->Data4[0], lpg->Data4[1], lpg->Data4[2], lpg->Data4[3],
			lpg->Data4[4], lpg->Data4[5], lpg->Data4[6], lpg->Data4[7]);
	}

	return DP_OK;
}

// convert passed in guid to a string and place it in the buffer passed in
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize)
{
	ASSERT(lpszGuid);
	
	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	wsprintfA(lpszGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

	return DP_OK;
}

// compute a wide string length.
// use this instead of crt fn. so we don't have
// to link to msvcrt.lib (and there's no wstrlen in libc.lib)
// called by WSTRLEN macro
int OS_StrLen(LPCWSTR lpwStr)
{
	int i=1; // 1 for null terminator...

	if (!lpwStr) return 0;

	while (*lpwStr++) i++;

	return i;
} //OS_StrLen

// compute a wide string length.
// use this instead of crt fn. so we don't have
// to link to msvcrt.lib (and there's no wstrlen in libc.lib)
// called by WSTRLEN macro
int OS_StrnLen(LPWSTR lpwStr, INT dwMaxLen, BOOL bForceTermination)
{
	int i=1; // 1 for null terminator...

	if (!lpwStr || !dwMaxLen) return 0;

	while (*lpwStr)
	{
		if (i >= dwMaxLen)
		{
			break;
		}
		
		lpwStr++;
		i++;
	}

	if(bForceTermination){
		*lpwStr=L'\0';
	}

	return i;
} //OS_StrLen

// compare two wide strings
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2)
{
    if(!lpwStr1 || !lpwStr2)
    {
        if(!lpwStr1 && !lpwStr2) return 0;
        else return -1;
    }

    while(*lpwStr1 && *lpwStr2)
    {
        if(*lpwStr1 != *lpwStr2) return *lpwStr1 - *lpwStr2;

        lpwStr1++;
        lpwStr2++;
    }

    return 0;
} //OS_StrCmp

/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR lpszWide)
{
	int iStrLen;
	
	ASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return DP_OK;
	}

	// call wide to ansi to find out how big +1 for terminating NULL
	iStrLen = WideToAnsi(NULL,lpszWide,0) + 1;
	ASSERT(iStrLen > 0);

	*ppszAnsi = DPMEM_ALLOC(iStrLen);
	if (!*ppszAnsi)	
	{
		DPF_ERR("could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}
	WideToAnsi(*ppszAnsi,lpszWide,iStrLen);

	return DP_OK;
} // GetAnsiString

/*
 ** GetString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszDest - pointer to string
 *				lpszSrc - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and copies lpszSrc to lpszDest
 *
 *  RETURNS: strlength
 *
 */
HRESULT GetString(LPWSTR * ppszDest,LPWSTR lpszSrc)
{
	int iStrLen;

	ASSERT(ppszDest);

	if (!lpszSrc)
	{
		*ppszDest = NULL;
		return DP_OK;
	}

    // alloc dest string
    iStrLen=WSTRLEN_BYTES(lpszSrc) ;
    *ppszDest = DPMEM_ALLOC(iStrLen);
    if (!*ppszDest)
    {
            DPF_ERR("could not get string -- out of memory!");
            return E_OUTOFMEMORY;
    }
    // copy strings
	memcpy(*ppszDest,lpszSrc,iStrLen);
	
	return DP_OK;
} // GetString

HINSTANCE OS_LoadLibrary(LPWSTR lpszWFileName)
{
	if (gbWin95)
	{
		char FileName[DPLAY_MAX_FILENAMELEN];
		
		WideToAnsi(FileName,lpszWFileName,DPLAY_MAX_FILENAMELEN);
		
		return LoadLibraryA(FileName);
	}
	// nt, use unicode call
	return LoadLibrary(lpszWFileName);
} // OS_LoadLibrary

// we're always looking for "SPInit" name, so we can just use ansi
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName)
{
	// hmmm, no getprocaddressa, seems to be always ansi...
	return GetProcAddress(hModule,lpProcName);

} // OS_GetProcAddress

LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR lpszWKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult)
{
	if (gbWin95)
	{
		char lpszKeyStr[DPLAY_REGISTRY_NAMELEN];

		WideToAnsi(lpszKeyStr,lpszWKeyStr,DPLAY_REGISTRY_NAMELEN);

		return RegOpenKeyExA(hKey,lpszKeyStr,dwReserved,samDesired,phkResult);
	}
	else return RegOpenKeyEx(hKey,lpszWKeyStr,dwReserved,samDesired,phkResult);

} // OS_RegOpenKeyEx

LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszWValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData)
{

	ASSERT(lpcbData);

	if (gbWin95)
	{
		char lpszValueName[DPLAY_REGISTRY_NAMELEN];
		int iStrLen;
		LONG rval;
		DWORD dwSize = 0;
								
		ASSERT(lpcbData);
		ASSERT(lpdwType);

		WideToAnsi(lpszValueName,lpszWValueName,DPLAY_REGISTRY_NAMELEN);

		if(lpcbData)
			dwSize = *lpcbData;

		rval = RegQueryValueExA(hKey,lpszValueName,lpdwReserved,
			lpdwType,lpbData,&dwSize);

		// convert back to wchar
		// take into account the case where lpbData is NULL
		if ((ERROR_SUCCESS == rval) && (REG_SZ == *lpdwType) && (lpbData))
		{
			char * lpszTemp;

			DPF(9,"reg - converting string");
			
			//
			// dwSize is the size of the ansi string
			// iStrLen is the size of the unicode string
			// lpcbData is the size of the buffer
			// lpbData is an ansi version of the (unicode) string we want...
			//
			// make sure buffer will hold unicode string
			iStrLen = AnsiToWide(NULL,lpbData,0);
			if (*lpcbData < (DWORD) iStrLen)
			{
				DPF_ERR("buffer too small!");
				return ERROR_INSUFFICIENT_BUFFER;
			}
			lpszTemp = DPMEM_ALLOC(dwSize);
			if (!lpszTemp)
			{
				DPF_ERR("could not alloc buffer for string conversion");
				return ERROR_NOT_ENOUGH_MEMORY;
			}
			memcpy(lpszTemp,lpbData,dwSize);
			// lpszTemp now holds the ansi string
			iStrLen = AnsiToWide((WCHAR *)lpbData,lpszTemp,*lpcbData);
			// finally, the unicode string is in lpbData
			*lpcbData = iStrLen;
			DPMEM_FREE(lpszTemp);
		}
		else
		{
			// This function returns the number of bytes (not WCHARs)
			*lpcbData = dwSize * sizeof(WCHAR);
		}
		return rval;
	}
	else return RegQueryValueEx(hKey,lpszWValueName,lpdwReserved,
			lpdwType,lpbData,lpcbData);

}// OS_RegQueryValueEx


LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszWName,LPDWORD lpcchName,
	LPDWORD lpdwReserved,LPWSTR lpszClass, LPDWORD lpcchClass,
	PFILETIME lpftLastWrite )
{

	ASSERT(!lpdwReserved);
	ASSERT(!lpszClass);
	ASSERT(!lpcchClass);
	ASSERT(!lpftLastWrite);

	if (gbWin95)
	{
		char lpszName[DPLAY_REGISTRY_NAMELEN];
		LONG rval;
		DWORD dwNameLen = DPLAY_REGISTRY_NAMELEN;
								
		rval = RegEnumKeyExA(hKey,iSubkey,lpszName,&dwNameLen,NULL,
			NULL, NULL, NULL );

		// convert back to wchar
		if (ERROR_SUCCESS == rval)
		{
			*lpcchName = AnsiToWide(lpszWName,lpszName,DPLAY_REGISTRY_NAMELEN);
		}

		return rval;
	}
	else return RegEnumKeyEx(hKey,iSubkey,lpszWName,lpcchName,NULL,
			NULL, NULL, NULL );
} // OS_RegEnumKeyEx

//
// Additions from dplos.c in the dplobby project
//
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL bInitialState, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = CreateEventA(lpSA, bManualReset, bInitialState, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = CreateEvent(lpSA, bManualReset, bInitialState, lpName);
	}	

	return hEvent;
}


HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = CreateMutexA(lpSA, bInitialOwner, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = CreateMutex(lpSA, bInitialOwner, lpName);
	}	

	return hMutex;
}


HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = OpenEventA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = OpenEvent(dwAccess, bInherit, lpName);
	}	

	return hEvent;
}


HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = OpenMutexA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = OpenMutex(dwAccess, bInherit, lpName);
	}	

	return hMutex;
}


HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = CreateFileMappingA(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = CreateFileMapping(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpName);
	}	

	return hMapping;
}


HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping = NULL;
	LPSTR	lpszTemp = NULL;
	DWORD	dwError;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = OpenFileMappingA(dwAccess, bInherit, lpszTemp);
		if(!hMapping)
		{
			dwError = GetLastError();
			DPF(8, "Error getting shared memory file handle");
			DPF(8, "dwError = 0x%08x", dwError);
		}

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = OpenFileMapping(dwAccess, bInherit, lpName);
	}	

	return hMapping;
}


BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI)
{
	HRESULT	hr;
	BOOL	bResult;
	STARTUPINFOA	sia;
	LPSTR	lpszAppName = NULL,
			lpszCmdLine = NULL,
			lpszCurDir = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszAppName, lpwszAppName);
		if(SUCCEEDED(hr))
		{
			hr = GetAnsiString(&lpszCmdLine, lpwszCmdLine);
			if(SUCCEEDED(hr))
			{
				hr = GetAnsiString(&lpszCurDir, lpwszCurDir);
				if(FAILED(hr))
				{
					DPMEM_FREE(lpszAppName);
					DPMEM_FREE(lpszCmdLine);
					DPF_ERR("Couldn't allocate memory for temp CurDir string!");
					return FALSE;
				}
			}
			else
			{
				DPMEM_FREE(lpszAppName);
				DPF_ERR("Couldn't allocate memory for temp CmdLine string!");
				return FALSE;
			}
		}
		else
		{
			DPF_ERR("Couldn't allocate memory for temp AppName string!");
			return FALSE;
		}

		// Set up the ANSI STARTUPINFO structure, assuming we are not setting
		// any of the strings in the structures.  (This should be true since
		// the only place we call this is in dplgame.c and it doesn't send anything
		// in this structure).
		memcpy(&sia, lpSI, sizeof(STARTUPINFO));

		bResult = CreateProcessA(lpszAppName, lpszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpszCurDir, &sia, lpPI);

		if(lpszAppName)
			DPMEM_FREE(lpszAppName);
		if(lpszCmdLine)
			DPMEM_FREE(lpszCmdLine);
		if(lpszCurDir)
			DPMEM_FREE(lpszCurDir);
	}
	else
	{
		bResult = CreateProcess(lpwszAppName, lpwszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpwszCurDir, lpSI, lpPI);
	}	

	return bResult;
}


long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType,
	const BYTE *lpData, DWORD cbData)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegSetValueExA(hKey, lpszValueNameA, dwReserved, dwType, lpData, cbData);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegSetValueEx(hKey, lpszValueName, dwReserved, dwType, lpData, cbData);
    }

    return lResult;
}


long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName,
	LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData)
{
    LPSTR                   lpszValueNameA = NULL;
    long                    lResult=E_FAIL;

    if(gbWin95)
    {
        if(lpszValueName && lpcbValueName && *lpcbValueName)
        {
            if(!(lpszValueNameA = (LPSTR)DPMEM_ALLOC(*lpcbValueName)))
            {
                return ERROR_OUTOFMEMORY;
            }

	        lResult = RegEnumValueA(hKey, dwIndex, lpszValueNameA, lpcbValueName, lpReserved,
	        	lpdwType, lpbData, lpcbData);

	        if(lpszValueName && lpcbValueName && *lpcbValueName)
	        {
	            AnsiToWide(lpszValueName, lpszValueNameA, *lpcbValueName);
	        }

			if(lpszValueNameA)
		        DPMEM_FREE(lpszValueNameA);
        }
    }
    else
    {
        lResult = RegEnumValue(hKey, dwIndex, lpszValueName, lpcbValueName, lpReserved,
        	lpdwType, lpbData, lpcbData);
    }

    return lResult;
}


long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteValueA(hKey, lpszValueNameA);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegDeleteValue(hKey, lpszValueName);
    }

    return lResult;
}


long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass,
	DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult, LPDWORD lpdwDisposition)
{
    LPSTR                   lpszSubKeyA = NULL;
    LPSTR                   lpszClassA = NULL;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
    	if(!lpszSubKey){
    		return DPERR_GENERIC;
    	}
    	
    	if(FAILED(hr = GetAnsiString(&lpszSubKeyA, lpszSubKey)))
        {
            return (long)hr;
        }

        if(lpszClass && FAILED(hr = GetAnsiString(&lpszClassA, lpszClass)))
        {
            if(lpszSubKeyA)
            {
                DPMEM_FREE(lpszSubKeyA);
                return (long)hr;
            }
        }

        lResult = RegCreateKeyExA(hKey, lpszSubKeyA, dwReserved, lpszClassA, dwOptions,
        	samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

        if(lpszSubKeyA)
        {
            DPMEM_FREE(lpszSubKeyA);
        }

        if(lpszClassA)
        {
            DPMEM_FREE(lpszClassA);
        }
    }
    else
    {
        lResult = RegCreateKeyEx(hKey, lpszSubKey, dwReserved, lpszClass, dwOptions, samDesired,
        	lpSecurityAttributes, phkResult, lpdwDisposition);
    }

    return lResult;
}


long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName)
{
    LPSTR                   lpszKeyNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszKeyNameA, lpszKeyName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteKeyA(hKey, lpszKeyNameA);

        DPMEM_FREE(lpszKeyNameA);
    }
    else
    {
        lResult = RegDeleteKey(hKey, lpszKeyName);
    }

    return lResult;
}


DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer)
{
	LPSTR	lpszTemp = NULL;
	DWORD	dwResult = 0;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		if(lpBuffer)
		{
			lpszTemp = DPMEM_ALLOC(dwSize);
			if(!lpszTemp)
			{
				DPF_ERR("Unable to allocate memory for temporary CurrentDir string");
				return 0;
			}

			dwResult = GetCurrentDirectoryA(dwSize, lpszTemp);

			// Convert the string back to Unicode
			if(dwResult)
			{
				// NOTE: This min call is really unnecessary, but
				// just in case someone passes in a dwSize value which
				// is really a count of bytes instead of a count of
				// characters, we will make sure we don't
				// run off the end of our buffer (but the resulting
				// string will probably not be exactly what the caller
				// expects).
				AnsiToWide(lpBuffer, lpszTemp, min(dwResult, dwSize));
			}

			if(lpszTemp)
				DPMEM_FREE(lpszTemp);

		}
        else
        {
            // Get the size in bytes.
            dwResult = GetCurrentDirectoryA(0, NULL);
            dwResult *= 2;  // But allow for UNICODE.
        }
    }
    else
    {
        dwResult = GetCurrentDirectory(dwSize, lpBuffer);
    }	              

	return dwResult;
}


int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2)
{
	LPSTR	lpsz1 = NULL;
	LPSTR	lpsz2 = NULL;
	int		iReturn;
	HRESULT	hr;

	if(!lpwsz1 || !lpwsz2){
		// make prefix happy.
		return 0;
	}
	// If we're on Win95, alloc ANSI strings and call the ANSI API,
	// otherwise, just call the Unicode API.  If we fail allocating
	// memory, return zero which indicates the strings are not equal.
	if(gbWin95)
	{
		// Allocate ANSI strings
		hr = GetAnsiString(&lpsz1, lpwsz1);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		hr = GetAnsiString(&lpsz2, lpwsz2);
		if(FAILED(hr))
		{
			DPMEM_FREE(lpsz1);
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		// Now call the ANSI API
		iReturn = CompareStringA(Locale, dwCmpFlags, lpsz1, cchCount1,
					lpsz2, cchCount2);

		// Free the strings
		DPMEM_FREE(lpsz1);
		DPMEM_FREE(lpsz2);

	}
	else
	{
		iReturn = CompareString(Locale, dwCmpFlags, lpwsz1, cchCount1,
					lpwsz2, cchCount2);
	}

	return iReturn;

} // OS_CompareString

LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2)
{
	DWORD i;
	// returns a pointer to the first occurance of lpwsz2 in lpwsz1
	while(*lpwsz1){
	
		i=0;
		while( (*(lpwsz2+i) && *(lpwsz1+i)) && (*(lpwsz1+i) == *(lpwsz2+i))){
			i++;
		}
		if(*(lpwsz2+i)==L'\0'){
			return lpwsz1;
		}
		lpwsz1++;
	}
	return NULL;	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpmess.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpmessage.h
 *  Content:	DirectPlay message structures
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	2/10/96	andyco	created it
 *	3/15/96	andyco	added macros for manipulating messages (e.g. GET_MESSAGE_SIZE)
 *	4/21/96	andyco	added dwresreved3
 *	4/25/96	andyco	got rid of dwreservedx. spblob follows message. blobsize
 *					is lpdplayi_dplay->dwSPHeaderSize
 *	5/29/96 andyco	added playerdata
 *	6/22/96 andyco	added enumrequest,enumreply structs
 *	6/22/96	andyco	added groupidrequest, so server can refuse new players
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *	7/31/96	andyco	added ping,pingreply
 *	8/6/96	andyco	added version stuff.  dwCmd->dwCmdToken. added offset
 *					to all packed fields (so we can change struct size w/o
 *					breaking compat).
 *	8/22/96	andyco	added playerwrapper
 * 10/11/96 sohailm added struct _MSG_SESSIONDESC and constant DPSP_MSG_SESSIONDESCCHANGED
 * 01/17/97 sohailm added struct _MSG_REQUESTPLAYERID.
 * 03/12/97 sohailm added new security related messages, MSG_SIGNED and MSG_AUTHENTICATION 
 *                  structs, DPSP_HEADER_LOCALMSG(constant), and dwSecurityPackageNameOffset 
 *                  field to PLAYERIDREPLY.
 * 03/24/97 sohailm added DPSP_MSG_DX5VERSION, DPSP_MSG_ADDFORWARDREPLY, and struct MSG_ADDFORWARDREPLY
 * 03/25/97 sohailm DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION set to 4
 * 4/11/97	andyco	ask4multicast
 * 04/14/97 sohailm renamed structure MSG_SIGNED to MSG_SECURE, as we use the same structure for
 *                  both signing and encryption.
 *	4/20/97	andyco	group in group
 *	5/8/97	andyco	removed update list message
 *	5/8/97	myronth	StartSession
 * 05/12/97 sohailm Added DPSP_MSG_KEYEXCHANGE and DPSP_MSG_KEYEXCHANGEREPLY.
 *                  Added securitydesc, dwSSPIProviderOffset, and dwCAPIProviderOffset members
 *                   to MSG_PLAYERIDREPLY structure.
 *                  Added MSG_ACCESSGRANTED and MSG_KEYEXCHANGE structures.
 * 05/12/97 sohailm Bumped DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION to 6
 *	5/17/97	myronth	SendChatMessage
 * 06/09/97 sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 * 06/16/97 sohailm Added struct MSG_AUTHERROR.
 * 06/23/97 sohailm Added dwFlags to DPMSG_SECURE. Removed DPSP_MSG_ENCRYPTED.
 * 8/5/97	andyco	async addforward
 *	10/29/97myronth	Added MSG_GROUPOWNERCHANGED
 *	1/5/97	myronth	Added DX5A and DX6 message versions and added an hresult
 *					to MSG_PLAYERIDREPLY (#15891)
 *	1/20/98	myronth	#ifdef'd out voice support
 *  8/02/99	aarono  removed old voice support
 *  8/05/99 aarono  Added DPMSG_VOICE
 *  10/8/99 aarono  Added DPSP_MSG_DX8VERSION
 * 10/15/99 aarono  added DPSP_MSG_MULTICASTDELIVERY to fix multicast on 
 *                      the Direct Play Protocol.
 * 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *
 ***************************************************************************/


#ifndef __DPMESS_INCLUDED__
#define __DPMESS_INCLUDED__

// DPMESSAGES are send across the wire like other messages, their identifying mark is 
// that they begin with a special signature ('p','l','a','y') followed by a 2 byte
// little endian message id and then a 2 byte version number.

// The dplay reliable protocol violates this rule to save header bytes.  After the
// 'play' is a single 0xff byte which identifies the protocol.  In order to avoid
// ambiguity, no regular protocol message number may end in 0xff, i.e. 255,511, etc... 

// NOTE: NO MESSAGE NUMBER IS ALLOWED TO HAVE 0xFF IN THE LOW BYTE <<<LOOK HERE!!!!>>>
// this # goes in the top 16 bits of every dplay command
#define DPSP_MSG_DX3VERSION				1 // dx3
#define DPSP_MSG_AUTONAMETABLE          4 // the version in which client expects nametable
										  // to be sent on addforward	
#define DPSP_MSG_GROUPINGROUP           5 // the version we added group in group
#define DPSP_MSG_SESSIONNAMETABLE		7 // the version we send the session desc w/ enumplayersreply
#define DPSP_MSG_DX5VERSION             7 // dx5

#define DPSP_MSG_ASYNCADDFORWARD        8 // addforward requires an ack 
#define DPSP_MSG_DX5AVERSION			8 // dx5a
#define DPSP_MSG_RELIABLEVERSION        9 // introduced the reliable protocol
#define DPSP_MSG_DX6VERSION				9 // dx6
#define DPSP_MSG_DX61VERSION           10 // dx6.1
#define DPSP_MSG_DX61AVERSION          11 // dx6.1a
#define DPSP_MSG_DX8VERSION            12 // dx8, dxvoice - millenium ship
#define DPSP_MSG_DX8VERSION2			  13 // nametable fix - real DX8 
#define DPSP_MSG_VERSION			   13 // current

// these are the headers that go in the dwCmd field of the message
#define DPSP_MSG_ENUMSESSIONSREPLY 		1
#define DPSP_MSG_ENUMSESSIONS 			2
#define DPSP_MSG_ENUMPLAYERSREPLY 		3
#define DPSP_MSG_ENUMPLAYER 			4
#define DPSP_MSG_REQUESTPLAYERID		5
// there's a requestgroupid, since the server can turn down new players
// (based on dwmaxplayers) but not groups
#define DPSP_MSG_REQUESTGROUPID			6
// used for group + player
#define DPSP_MSG_REQUESTPLAYERREPLY		7
#define DPSP_MSG_CREATEPLAYER			8
#define DPSP_MSG_CREATEGROUP			9
#define DPSP_MSG_PLAYERMESSAGE			10
#define DPSP_MSG_DELETEPLAYER			11
#define DPSP_MSG_DELETEGROUP			12
#define DPSP_MSG_ADDPLAYERTOGROUP		13
#define DPSP_MSG_DELETEPLAYERFROMGROUP	14
#define DPSP_MSG_PLAYERDATACHANGED		15
#define DPSP_MSG_PLAYERNAMECHANGED		16
#define DPSP_MSG_GROUPDATACHANGED		17
#define DPSP_MSG_GROUPNAMECHANGED		18
#define DPSP_MSG_ADDFORWARDREQUEST		19
#define DPSP_MSG_NAMESERVER				20
#define DPSP_MSG_PACKET					21
#define DPSP_MSG_PING					22
#define DPSP_MSG_PINGREPLY				23
#define DPSP_MSG_YOUAREDEAD				24
#define DPSP_MSG_PLAYERWRAPPER			25
#define DPSP_MSG_SESSIONDESCCHANGED     26
#define DPSP_MSG_UPDATELIST				27
#define DPSP_MSG_CHALLENGE              28 
#define DPSP_MSG_ACCESSGRANTED          29
#define DPSP_MSG_LOGONDENIED            30
#define DPSP_MSG_AUTHERROR              31
#define DPSP_MSG_NEGOTIATE              32
#define DPSP_MSG_CHALLENGERESPONSE      33
#define DPSP_MSG_SIGNED                 34
#define DPSP_MSG_UNUSED1                35
#define DPSP_MSG_ADDFORWARDREPLY        36 
#define DPSP_MSG_ASK4MULTICAST			37
#define DPSP_MSG_ASK4MULTICASTGUARANTEED 38
#define DPSP_MSG_ADDSHORTCUTTOGROUP 	39
#define DPSP_MSG_DELETEGROUPFROMGROUP	40
#define DPSP_MSG_SUPERENUMPLAYERSREPLY 	41
#define DPSP_MSG_STARTSESSION			42
#define DPSP_MSG_KEYEXCHANGE            43
#define DPSP_MSG_KEYEXCHANGEREPLY       44
#define DPSP_MSG_CHAT					45
#define DPSP_MSG_ADDFORWARD				46
#define DPSP_MSG_ADDFORWARDACK			47
#define DPSP_MSG_PACKET2_DATA           48
#define DPSP_MSG_PACKET2_ACK            49
#define DPSP_MSG_GROUPOWNERCHANGED		50

#define DPSP_MSG_IAMNAMESERVER          53
#define DPSP_MSG_VOICE                  54
#define DPSP_MSG_MULTICASTDELIVERY      55
#define DPSP_MSG_CREATEPLAYERVERIFY			56

#define DPSP_MSG_DIEPIGGY				0x666
#define DPSP_MSG_PROTOCOL               0xFF		// See note above (LOOK HERE).

// flag for requesting async send on SendPlayerManagement Messages
#define DPSP_MSG_ASYNC					0x80000000

// if you are adding a new message that can be sent unsigned,
// add it to PermitMessage() in dpsecure.c

// MSG_HDR indicates a dplay system message
#define MSG_HDR 0x79616c70

#define IS_VALID_DPLAY_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )

#define IS_PLAYER_MESSAGE(pMsg) (!IS_VALID_DPLAY_MESSAGE(pMsg))

// calculate size for message + header
#define GET_MESSAGE_SIZE(this,MSG) (this->dwSPHeaderSize + sizeof(MSG))

#define COMMAND_MASK 0X0000FFFF
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)
#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )

#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (DPSP_MSG_VERSION<<16)) )

#define SET_MESSAGE_COMMAND_ONLY(pMsg,dwCmd) ((pMsg)->dwCmdToken =  \
			(((pMsg)->dwCmdToken & ~COMMAND_MASK)|(dwCmd & COMMAND_MASK)))

// This constant is used to indicate that a message is for a local player
#define DPSP_HEADER_LOCALMSG ((LPVOID)-1)

// dplay internal messages below. 
typedef struct _MSG_SYSMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
} MSG_SYSMESSAGE,*LPMSG_SYSMESSAGE;

// for sending out the player blob
typedef struct _MSG_PLAYERDATA
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
    DWORD dwDataSize;
	DWORD dwDataOffset; // offset (in bytes) of data (so we don't hardcode struct size) 
						// from beginning of message
	// data follows    	
} MSG_PLAYERDATA,*LPMSG_PLAYERDATA;

// sent when player name changes
typedef struct _MSG_PLAYERNAME
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
	DWORD dwShortOffset; // offset (in bytes) of short name from beginning of message.  
						// 0 means null short name.
	DWORD dwLongOffset;	// offset (in bytes) of long name from beginning of message.
						// 0 means null long name.
	// strings follow 
} MSG_PLAYERNAME,*LPMSG_PLAYERNAME;

// create player / group, delete player/group
typedef struct _MSG_PLAYERMGMTMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo; // player message is being sent to
    DWORD dwPlayerID; // player id effected
	DWORD dwGroupID; // group id effected
	DWORD dwCreateOffset; 	// offset of player / group creation stuff from beginning 
							// of message
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwPasswordOffset; // offset of session password
	// if it's an addplayer, the player data will follow this message
    // if it's an addforward, session password will follow the player data
} MSG_PLAYERMGMTMESSAGE,*LPMSG_PLAYERMGMTMESSAGE;

// sent by name srvr w/ session desc
typedef struct _MSG_ENUMSESSIONS
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	GUID  guidApplication;
	DWORD dwPasswordOffset;	// offset (in bytes) of password from beginning of message.
							// 0 means null password.
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;          // enum session flags passed in by the app
} MSG_ENUMSESSIONS,*LPMSG_ENUMSESSIONS;

// sent to nameserver
typedef struct _MSG_ENUMSESSIONSREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DPSESSIONDESC2 dpDesc; 
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
} MSG_ENUMSESSIONSREPLY,*LPMSG_ENUMSESSIONSREPLY;


// sent by namesrvr w/ list of all players and groups in session
typedef struct _MSG_ENUMPLAYERREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD nPlayers; //  # players we actually got
	DWORD nGroups; // # of groups we got
	DWORD dwPackedOffset; // offset (in bytes) of packed player structs from beginning of message
	// added for DX5
	DWORD nShortcuts; // # of groups w/ shortcuts
	DWORD dwDescOffset; // offset (in bytes) of session desc from beginning of message
						// always > 0
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
	DWORD dwPasswordOffset; // offset (in bytes) of session password from beginning of message.
					   	// 0 means null session name.
	// session name + password follow
    // player data will follow session name + password in reply buffer
	// group data follows players. see pack.c
} MSG_ENUMPLAYERSREPLY,*LPMSG_ENUMPLAYERSREPLY;

// sent to nameserver to request a player id
typedef struct _MSG_REQUESTPLAYERID
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;      // player flags (system/applicaton player)
} MSG_REQUESTPLAYERID,*LPMSG_REQUESTPLAYERID;

// sent by name srvr w/ new player id
typedef struct _MSG_PLAYERIDREPLY
{
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwID; //  the new id
	// the following fields are only available in
	// DX5 or later versions
	DPSECURITYDESC dpSecDesc;   // security description - populated only if server is secure.
    DWORD dwSSPIProviderOffset; // offset (in bytes) of sspi provider name from beginning of message.
					   			// 0 means null provider name.
    DWORD dwCAPIProviderOffset; // offset (in bytes) of capi provider name from beginning of message.
					   			// 0 means null provider name.
    HRESULT hr; // return code used in DX6 and after
	// provider name strings follow
}MSG_PLAYERIDREPLY,*LPMSG_PLAYERIDREPLY;

// a player to player message
typedef struct _MSG_PLAYERMESSAGE
{
	DPID idFrom,idTo;
} MSG_PLAYERMESSAGE,*LPMSG_PLAYERMESSAGE;

typedef struct _MSG_PACKET
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID; // this packet is # x of N
	DWORD dwDataSize; // total size of the data in this packet
					  // data follows MSG_PACKET struct
	DWORD dwOffset; // offset into reconstructed buffer for this packet
	DWORD dwTotalPackets; // total # of packets (N)
	DWORD dwMessageSize; // size of buffer to alloc at other end
	DWORD dwPackedOffset; // offset into this message of the actual packet data
						  // so we don't hardcode for struct sizes
} MSG_PACKET,*LPMSG_PACKET;	

typedef struct _MSG_PACKET_ACK
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID;  // ACK packet is # x of N
} MSG_PACKET_ACK,*LPMSG_PACKET_ACK;	

typedef struct _MSG_PACKET     MSG_PACKET2,     *LPMSG_PACKET2;
typedef struct _MSG_PACKET_ACK MSG_PACKET2_ACK, *LPMSG_PACKET2_ACK;

// sent by name srvr w/ new player id
typedef struct _MSG_PING
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom; //  the player who sent the ping
	DWORD dwTickCount; // tick count on message sending ping	
} MSG_PING,*LPMSG_PING;

// for sending out the session desc
typedef struct _MSG_SESSIONDESC
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo;
    DWORD dwSessionNameOffset;  // offsets of strings in the message
    DWORD dwPasswordOffset;     // so we don't hardcode for struct sizes
    DPSESSIONDESC2 dpDesc;
    // session name and password strings follow
} MSG_SESSIONDESC,*LPMSG_SESSIONDESC;


#define DPSECURE_SIGNEDBYSSPI			0x00000001
#define DPSECURE_SIGNEDBYCAPI			0x00000002
#define DPSECURE_ENCRYPTEDBYCAPI		0x00000004

// for sending signed messages
typedef struct _MSG_SECURE {
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataOffset;         // offset of dplay message
    DWORD dwDataSize;           // size of message
    DWORD dwSignatureSize;      // size of signature
	DWORD dwFlags;              // describes the contents
    // data and signature follow
} MSG_SECURE, *LPMSG_SECURE;

// Secure message format...
// [SPHeader | MSG_SECURE | Data | Signature ]

// authentication messages (negotiate, challenge, response, etc)
typedef struct _MSG_AUTHENTICATION {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataSize;           // size of opaque buffer
    DWORD dwDataOffset;         // offset of buffer
    // opaque buffer follows
} MSG_AUTHENTICATION, *LPMSG_AUTHENTICATION;

// for sending an error response to addforward (DX5)
// this message is sent by the nameserver to a client when addforward fails
typedef struct _MSG_ADDFORWARDREPLY {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why addforward failed
} MSG_ADDFORWARDREPLY, *LPMSG_ADDFORWARDREPLY;

// message sent to the server when we want him to multicast for us
typedef struct _MSG_ASK4MULTICAST {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DPID  idGroupTo;
	DPID  idPlayerFrom;
	DWORD dwMessageOffset;
} MSG_ASK4MULTICAST, *LPMSG_ASK4MULTICAST;

// when running the protocol, you can't send from a player except players
// on the system you are sending from, so for delivering through a multicast
// server we need to keep the message wrapped and crack it on deliver to get
// the addressing information correct on delivery.
typedef struct _MSG_ASK4MULTICAST MSG_MULTICASTDELIVERY, *LPMSG_MULTICASTDELIVERY;

typedef struct _MSG_STARTSESSION {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwConnOffset;
} MSG_STARTSESSION, *LPMSG_STARTSESSION;

typedef struct _MSG_ACCESSGRANTED {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwPublicKeySize;      // sender's public key blob size
    DWORD dwPublicKeyOffset;    // sender's public key
} MSG_ACCESSGRANTED, *LPMSG_ACCESSGRANTED;

typedef struct _MSG_KEYEXCHANGE {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwSessionKeySize;
    DWORD dwSessionKeyOffset;
    DWORD dwPublicKeySize;
    DWORD dwPublicKeyOffset;
} MSG_KEYEXCHANGE, *LPMSG_KEYEXCHANGE;

// chat message
typedef struct _MSG_CHAT
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDFrom;		// id of sending player
	DWORD dwIDTo;		// id of destination player
	DWORD dwFlags;		// DPCHAT flags
	DWORD dwMessageOffset; // offset (in bytes) of chat message from beginning of message.  
						// 0 means null message.
	// strings follow 
} MSG_CHAT,*LPMSG_CHAT;

// for sending an error response to an authentication message (DX5)
// this message is sent by the nameserver to a client when an authentication error occurs
typedef struct _MSG_AUTHERROR {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why authentication failed
} MSG_AUTHERROR, *LPMSG_AUTHERROR;

// acks an addforward message
typedef struct _MSG_ADDFORWARDACK{
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwID; // id that the addforward was sent for
} MSG_ADDFORWARDACK, *LPMSG_ADDFORWARDACK;

// group owner changed message
typedef struct _MSG_GROUPOWNERCHANGED
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDGroup;
	DWORD dwIDNewOwner;
	DWORD dwIDOldOwner;
} MSG_GROUPOWNERCHANGED,*LPMSG_GROUPOWNERCHANGED;

// Notification from the new name server to flip the
// necessary bits to make the nameserver bit true on 
// that player.
typedef struct _MSG_IAMNAMESERVER
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo; 		// req'd field for system messages.
	DWORD dwIDHost;     // id of the host
	DWORD dwFlags;		// new host flags 
	DWORD dwSPDataSize; // length of contiguous following SP data field.
	CHAR  SPData[];
} MSG_IAMNAMESERVER,*LPMSG_IAMNAMESERVER;

typedef struct _MSG_VOICE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDFrom;		// id of sending player
	DWORD dwIDTo;		// id of destination player or group
	// voice data follows
} MSG_VOICE,*LPMSG_VOICE;

// NOTE: we really only need the "To" address on the first packet of a message.
//       since most messages though are 1 packet, this is easier. On large messages
//       the extra 2 bytes per packet doesn't hurt.

#pragma pack(push,1)

// Message protocol header is variable using bit extension.  The first field
// is the from id, the second is the to id.  They can each be up to 3 bytes.
// This prototype allows allocators to calculate the worst case.
typedef struct _MSG_PROTOCOL {
	UCHAR   ToFromIds[6];		
} MSG_PROTOCOL, *LPMSG_PROTOCOL;

#pragma pack(pop)
// see protocol.h for the rest of the protocol header


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpsecos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.c
 *  Content:	Windows SSPI calls.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI)
 *  04/14/97    sohailm Added definitions for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Updated code to use gpSSPIFuncTbl instead of gpFuncTbl.
 *                      Added functions to access Crypto API.  
 *  05/29/97    sohailm Now we don't include null char in the size of credentials strings passed to sp.
 *                      Added QueryContextUserName(). Updated QueryContextBufferSize to return HRESULT.
 *  06/22/97    sohailm We return SSPI errors instead of DPERR_GENERIC now.
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *                      
 *
 ***************************************************************************/
#include <wtypes.h>
#include <newdpf.h>
#include <sspi.h>
#include "dplaypr.h"
#include "dpsecure.h"

/***************************************************************************
 * SSPI
 ***************************************************************************/

/*
 * Description: Checks to see if sspi function table has already been initialized
 */
BOOL OS_IsSSPIInitialized(void)
{
    if (gbWin95)
    {
        if (gpSSPIFuncTblA) return TRUE;
    }
    else 
    {
        if (gpSSPIFuncTbl) return TRUE;
    }

    return FALSE;
}

/*
 * Description: Initializes the security interface based on the operating system.
 */
BOOL OS_GetSSPIFunctionTable(HMODULE hModule)
{
    INIT_SECURITY_INTERFACE_A	addrProcISIA = NULL;
    INIT_SECURITY_INTERFACE 	addrProcISI = NULL;

    if (gbWin95)
    {
        addrProcISIA = (INIT_SECURITY_INTERFACE_A) GetProcAddress( hModule, 
            "InitSecurityInterfaceA");       

        if (addrProcISIA == NULL)
        {
            DPF(0,
               "GetProcAddress() of InitSecurityInterfaceA failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTblA = (*addrProcISIA)();
        if (gpSSPIFuncTblA == NULL)
        {
            DPF(0,"InitSecurityInterfaceA() failed [0x%08x]\n", GetLastError());
            return FALSE;
        }
    }
    else
    {
        addrProcISI = (INIT_SECURITY_INTERFACE_W) GetProcAddress(hModule, 
            "InitSecurityInterfaceW");       

        if (addrProcISI == NULL)
        {
            DPF(0, 
                "GetProcAddress() of InitSecurityInterface failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTbl = (*addrProcISI)();
        if (gpSSPIFuncTbl == NULL)
        {
            DPF(0,"InitSecurityInterface() failed [%d]\n", 
                GetLastError());
            return FALSE;
        }
    }
    
    // SUCCESS
    return TRUE;
}


SECURITY_STATUS OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
}

SECURITY_STATUS OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthDataW,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    )
{
    ASSERT(pwszPackageName);

    if (gbWin95)
    {
        SEC_WINNT_AUTH_IDENTITY_A *pAuthDataA=NULL;
        SEC_WINNT_AUTH_IDENTITY_A AuthDataA;
        SECURITY_STATUS status;
        HRESULT hr;
        LPSTR pszPackageName = NULL;

        ASSERT(gpSSPIFuncTblA);
        ZeroMemory(&AuthDataA, sizeof(AuthDataA));

        // get an ansi package name
        hr = GetAnsiString(&pszPackageName,pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get an ansi version of package name");
            status = E_FAIL;
            goto CLEANUP_EXIT;
        }

        if (pAuthDataW)
        {
            AuthDataA.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            // note - don't include null character in string size for credential strings
            if (pAuthDataW->User)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.User,pAuthDataW->User);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of username");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.UserLength = STRLEN(AuthDataA.User)-1;
            }
            if (pAuthDataW->Password)
            {
                // get an ansi password
                hr = GetAnsiString(&AuthDataA.Password,pAuthDataW->Password);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of password");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.PasswordLength = STRLEN(AuthDataA.Password)-1;
            }
            if (pAuthDataW->Domain)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.Domain,pAuthDataW->Domain);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of domain");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.DomainLength = STRLEN(AuthDataA.Domain)-1;
            }
            pAuthDataA = &AuthDataA;
        }

        status = (*(gpSSPIFuncTblA->AcquireCredentialsHandleA)) (
            NULL, 
            pszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataA, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );

            // fall through

        CLEANUP_EXIT:
            // cleanup all local allocations
            if (AuthDataA.User) DPMEM_FREE(AuthDataA.User);
            if (AuthDataA.Password) DPMEM_FREE(AuthDataA.Password);
            if (AuthDataA.Domain) DPMEM_FREE(AuthDataA.Domain);
            if (pszPackageName) DPMEM_FREE(pszPackageName);
            return status;
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcquireCredentialsHandle)) (
            NULL, 
            pwszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataW, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );
    }
}


SECURITY_STATUS OS_DeleteSecurityContext(
    PCtxtHandle phContext
    )
{
	CtxtHandle hNullContext;

    DPF(6,"Deleting security context handle 0x%08x",phContext);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullContext, sizeof(CtxtHandle));
	if (0 == memcmp(&hNullContext, phContext, sizeof(CtxtHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->DeleteSecurityContext)) (phContext);
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->DeleteSecurityContext)) (phContext);
    }
}

SECURITY_STATUS OS_FreeCredentialHandle(
    PCredHandle     phCredential
    )
{
	CredHandle hNullCredential;

    DPF(6,"Freeing credential handle 0x%08x",phCredential);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullCredential, sizeof(CredHandle));
	if (0 == memcmp(&hNullCredential, phCredential, sizeof(CredHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeCredentialHandle)) (phCredential);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeCredentialHandle)) (phCredential);        
    }
}

SECURITY_STATUS OS_FreeContextBuffer(
    PVOID   pBuffer
    )
{
    DPF(6,"Freeing context buffer 0x%08x",pBuffer);
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeContextBuffer)) (pBuffer);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeContextBuffer)) (pBuffer);        
    }
}

SECURITY_STATUS OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->InitializeSecurityContextA)) (
            phCredential,
            phContext,   
            NULL,        
            fContextReq, 
            0L,          
            SECURITY_NATIVE_DREP, 
            pInput,
            0L,    
            phNewContext,
            pOutput,     
            pfContextAttributes,
            ptsExpiry           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->InitializeSecurityContext)) (
            phCredential,       
            phContext,          
            NULL,               
            fContextReq,        
            0L,                 
            SECURITY_NATIVE_DREP,
            pInput,             
            0L,                 
            phNewContext,       
            pOutput,            
            pfContextAttributes,
            ptsExpiry           
            );
    }
}


SECURITY_STATUS OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
}


SECURITY_STATUS OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->QueryContextAttributesA)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->QueryContextAttributes)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextBufferSize"

HRESULT OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    )
{
    SECURITY_STATUS status;
    HRESULT hr;

    ASSERT(pwszPackageName);
    ASSERT(pulBufferSize);

    if (gbWin95)
    {
	    LPSTR pszPackageName=NULL;
        PSecPkgInfoA pspInfoA=NULL;

        ASSERT(gpSSPIFuncTblA);

        // get ansi version of security package name
        hr = GetAnsiString(&pszPackageName, pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get ansi version of package name");
            goto CLEANUP_EXIT_A;
        }
        // query package for info
        status = (*(gpSSPIFuncTblA->QuerySecurityPackageInfoA)) (
            pszPackageName,
            &pspInfoA
            );

        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_A;
        }
        // update the size
        if (pspInfoA)
        {
            *pulBufferSize = pspInfoA->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_A:
        // cleanup local allocations
        if (pszPackageName) DPMEM_FREE(pszPackageName);
        if (pspInfoA) OS_FreeContextBuffer(pspInfoA);
        return hr;
    }
    else
    {
        PSecPkgInfoW pspInfoW=NULL;

        ASSERT(gpSSPIFuncTbl);

        status = (*(gpSSPIFuncTbl->QuerySecurityPackageInfo)) (
            pwszPackageName,
            &pspInfoW
            );
        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_W;
        }

        if (pspInfoW)
        {
            *pulBufferSize = pspInfoW->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_W:
        // cleanup
        if (pspInfoW) OS_FreeContextBuffer(pspInfoW);
        return hr;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextUserName"

HRESULT OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    )
{
    SECURITY_STATUS status;
   	SecPkgContext_Names contextAttribs;
    HRESULT hr;

    ASSERT(phContext);
    ASSERT(ppwszUserName);

    // query the security package
    ZeroMemory(&contextAttribs,sizeof(contextAttribs));
	status = OS_QueryContextAttributes(phContext, SECPKG_ATTR_NAMES, &contextAttribs);
	if (!SEC_SUCCESS(status))
	{
        DPF_ERRVAL("QueryContextAttributes failed: Error=0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
	}

    if (gbWin95)
    {
        // convert username to unicode and copy it into caller's buffer
        hr = GetWideStringFromAnsi(ppwszUserName, (LPSTR)contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to convert username to wide format");
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        // copy unicode username as is into caller's buffer
        hr = GetString(ppwszUserName, contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to copy username");
            goto CLEANUP_EXIT;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    OS_FreeContextBuffer(contextAttribs.sUserName);
    return hr;
}

SECURITY_STATUS OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


SECURITY_STATUS OS_SealMessage(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pOutSecDesc,
    ULONG               MessageSeqNo
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTblA->SEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTbl->SEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
   }
}


SECURITY_STATUS OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTblA->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTbl->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


/***************************************************************************
 * CAPI
 ***************************************************************************/
extern BOOL
OS_IsCAPIInitialized(
    void
    )
{
    return (gpCAPIFuncTbl ? TRUE : FALSE);
}

BOOL
OS_GetCAPIFunctionTable(
    HMODULE hModule
    )
{
    ASSERT(hModule);
 
    // allocate memory for CAPI function table
    gpCAPIFuncTbl = DPMEM_ALLOC(sizeof(CAPIFUNCTIONTABLE));
    if (!gpCAPIFuncTbl)
    {
        DPF_ERR("Failed to create CAPI function table - out of memory");
        return FALSE;
    }

    // initialize function table
    if (gbWin95)
    {
        gpCAPIFuncTbl->CryptAcquireContextA = (PFN_CRYPTACQUIRECONTEXT_A)GetProcAddress(hModule,"CryptAcquireContextA");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextA)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextA");
            goto ERROR_EXIT;
        }
    }
    else
    {
        gpCAPIFuncTbl->CryptAcquireContextW = (PFN_CRYPTACQUIRECONTEXT_W)GetProcAddress(hModule,"CryptAcquireContextW");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextW)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextW");
            goto ERROR_EXIT;
        }
    }

    gpCAPIFuncTbl->CryptReleaseContext = (PFN_CRYPTRELEASECONTEXT) GetProcAddress(hModule,"CryptReleaseContext");
    if (NULL == gpCAPIFuncTbl->CryptReleaseContext)
    {
        DPF_ERR("Failed to get pointer to CryptReleaseContext");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptGenKey = (PFN_CRYPTGENKEY) GetProcAddress(hModule,"CryptGenKey");
    if (NULL == gpCAPIFuncTbl->CryptGenKey)
    {
        DPF_ERR("Failed to get pointer to CryptGenKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyKey = (PFN_CRYPTDESTROYKEY) GetProcAddress(hModule,"CryptDestroyKey");
    if (NULL == gpCAPIFuncTbl->CryptDestroyKey)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptExportKey = (PFN_CRYPTEXPORTKEY) GetProcAddress(hModule,"CryptExportKey");
    if (NULL == gpCAPIFuncTbl->CryptExportKey)
    {
        DPF_ERR("Failed to get pointer to CryptExportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptImportKey = (PFN_CRYPTIMPORTKEY) GetProcAddress(hModule,"CryptImportKey");
    if (NULL == gpCAPIFuncTbl->CryptImportKey)
    {
        DPF_ERR("Failed to get pointer to CryptImportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptEncrypt = (PFN_CRYPTENCRYPT) GetProcAddress(hModule,"CryptEncrypt");
    if (NULL == gpCAPIFuncTbl->CryptEncrypt)
    {
        DPF_ERR("Failed to get pointer to CryptEncrypt");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDecrypt = (PFN_CRYPTDECRYPT) GetProcAddress(hModule,"CryptDecrypt");
    if (NULL == gpCAPIFuncTbl->CryptDecrypt)
    {
        DPF_ERR("Failed to get pointer to CryptDecrypt");
        goto ERROR_EXIT;
    }
    
    gpCAPIFuncTbl->CryptCreateHash = (PFN_CRYPTCREATEHASH) GetProcAddress(hModule,"CryptCreateHash");
    if (NULL == gpCAPIFuncTbl->CryptCreateHash)
    {
        DPF_ERR("Failed to get pointer to CryptCreateHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyHash = (PFN_CRYPTDESTROYHASH) GetProcAddress(hModule,"CryptDestroyHash");
    if (NULL == gpCAPIFuncTbl->CryptDestroyHash)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptHashData = (PFN_CRYPTHASHDATA) GetProcAddress(hModule,"CryptHashData");
    if (NULL == gpCAPIFuncTbl->CryptHashData)
    {
        DPF_ERR("Failed to get pointer to CryptHashData");
        goto ERROR_EXIT;
    }

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptSignHashA = (PFN_CRYPTSIGNHASH_A) GetProcAddress(hModule,"CryptSignHashA");
		if (NULL == gpCAPIFuncTbl->CryptSignHashA)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptSignHashW = (PFN_CRYPTSIGNHASH_W) GetProcAddress(hModule,"CryptSignHashW");
		if (NULL == gpCAPIFuncTbl->CryptSignHashW)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashW");
			goto ERROR_EXIT;
		}
	}

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptVerifySignatureA = (PFN_CRYPTVERIFYSIGNATURE_A) GetProcAddress(hModule,"CryptVerifySignatureA");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureA)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptVerifySignatureW = (PFN_CRYPTVERIFYSIGNATURE_W) GetProcAddress(hModule,"CryptVerifySignatureW");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureW)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureW");
			goto ERROR_EXIT;
		}
	}

    // success
    return TRUE;

ERROR_EXIT:
    OS_ReleaseCAPIFunctionTable();
    return FALSE;
}

void
OS_ReleaseCAPIFunctionTable(
    void
    )
{
    if (gpCAPIFuncTbl)
    {
        DPMEM_FREE(gpCAPIFuncTbl);
        gpCAPIFuncTbl = NULL;
    }
}

BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvider,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    )
{
    BOOL fResult=0;

    ASSERT(gpCAPIFuncTbl);

	*lpdwLastError=0;

    if (gbWin95)
    {
        LPSTR pszContainer=NULL, pszProvider=NULL;
        HRESULT hr;

        if (pwszContainer)
        {
            hr = GetAnsiString(&pszContainer,pwszContainer);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi container name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        if (pwszProvider)
        {
            hr = GetAnsiString(&pszProvider,pwszProvider);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi provider name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptAcquireContextA(phProv,pszContainer,pszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();

        // fall through
    CLEANUP_EXIT:
        if (pszContainer) DPMEM_FREE(pszContainer);
        if (pszProvider) DPMEM_FREE(pszProvider);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptAcquireContext(phProv,pwszContainer,pwszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();
    }

    return fResult;
}

BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    )
{
	// don't pass null handles as it might crash the following call
	if (0 == hProv)
	{
		return TRUE;
	}
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptReleaseContext(hProv,dwFlags);
}

BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptGenKey(hProv,Algid,dwFlags,phKey);
}

BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    )
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hKey)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyKey(hKey);
}

BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptExportKey(hKey,hExpKey,dwBlobType,dwFlags,pbData,pdwDataLen);
}

BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptImportKey(hProv,pbData,dwDataLen,hPubKey,dwFlags,phKey);
}

BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptEncrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen,dwBufLen);
}

BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDecrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen);
}


BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptCreateHash(hProv,Algid,hKey,dwFlags,phHash);
}

BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	)
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hHash)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyHash(hHash);
}

BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptHashData(hHash,pbData,dwDataLen,dwFlags);
}

BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR pwszDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	)
{
	BOOL fResult=FALSE;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		fResult = gpCAPIFuncTbl->CryptSignHashA(hHash,dwKeySpec,pszDescription,dwFlags,pbSignature,pdwSigLen);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
	    fResult = gpCAPIFuncTbl->CryptSignHash(hHash,dwKeySpec,pwszDescription,dwFlags,pbSignature,pdwSigLen);
    }

    return fResult;
}

BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR pwszDescription,
	DWORD dwFlags
	)
{
	BOOL fResult=FALSE;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
            	//Can't DPF here, since we don't want to step on LastError.
                //DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptVerifySignatureA(hHash,pbSignature,dwSigLen,hPubKey,pszDescription,dwFlags);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptVerifySignature(hHash,pbSignature,dwSigLen,hPubKey,pwszDescription,dwFlags);
    }

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpsecos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.h
 *  Content:	DirectPlay's interface to SSPI.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through 
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Added prototypes for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Added prototypes for CAPI function calls.
 *  05/29/97    sohailm Added prototype for QueryContextUserName. Updated QueryContextBufferSize
 *                      prototype to return HRESULT.
 *  06/23/97    sohailm Added prototypes for CAPI message signing function calls.
 *
 ***************************************************************************/
#ifndef __DPSECOS_H__
#define __DPSECOS_H__

#include <sspi.h>

extern BOOL 
OS_IsSSPIInitialized(
    void
    );

extern BOOL 
OS_GetSSPIFunctionTable(
    HMODULE hModule
    );

extern BOOL
OS_IsCAPIInitialized(
    void
    );

extern BOOL 
OS_GetCAPIFunctionTable(
    HMODULE hModule
    );

extern void
OS_ReleaseCAPIFunctionTable(
    void
    );

/***************************************************************************
 * Security Support Provider Interface
 ***************************************************************************/

extern SECURITY_STATUS 
OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    );

extern SECURITY_STATUS 
OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    );

extern SECURITY_STATUS 
OS_DeleteSecurityContext(
    CtxtHandle *phContext
    );

extern SECURITY_STATUS 
OS_FreeCredentialHandle(
    PCredHandle     phCredential
    );

extern SECURITY_STATUS 
OS_FreeContextBuffer(
    PVOID   pBuffer
    );

extern SECURITY_STATUS 
OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    );

extern SECURITY_STATUS 
OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    );

extern HRESULT
OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    );

extern HRESULT 
OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    );

extern SECURITY_STATUS 
OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );

extern SECURITY_STATUS 
OS_SealMessage(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );


/***************************************************************************
 * Crypto Application Programming Interface
 ***************************************************************************/

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_A)(
    HCRYPTPROV  *phProv,
    LPSTR       pszContainer,
    LPSTR       pszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_W)(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTRELEASECONTEXT)(
    HCRYPTPROV hProv,
    DWORD dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTGENKEY)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYKEY)(
    HCRYPTKEY hKey);

typedef BOOL (WINAPI *PFN_CRYPTEXPORTKEY)(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTIMPORTKEY)(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTENCRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

typedef BOOL (WINAPI *PFN_CRYPTDECRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTCREATEHASH)(
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYHASH)(
	HCRYPTHASH hHash
	);

typedef BOOL (WINAPI *PFN_CRYPTHASHDATA)(
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_A)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_W)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_A)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCSTR sDescription,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_W)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCWSTR sDescription,
	DWORD dwFlags
	);

/*
 * CAPI Function table
 */
typedef struct _CAPIFUNCTIONTABLE{
    PFN_CRYPTACQUIRECONTEXT_A	CryptAcquireContextA;
    PFN_CRYPTACQUIRECONTEXT_W	CryptAcquireContextW;
    PFN_CRYPTRELEASECONTEXT		CryptReleaseContext;
    PFN_CRYPTGENKEY				CryptGenKey;
    PFN_CRYPTDESTROYKEY			CryptDestroyKey;
    PFN_CRYPTEXPORTKEY			CryptExportKey;
    PFN_CRYPTIMPORTKEY			CryptImportKey;
    PFN_CRYPTENCRYPT			CryptEncrypt;
    PFN_CRYPTDECRYPT			CryptDecrypt;
	PFN_CRYPTCREATEHASH			CryptCreateHash;
	PFN_CRYPTDESTROYHASH		CryptDestroyHash;
	PFN_CRYPTHASHDATA			CryptHashData;
	PFN_CRYPTSIGNHASH_A			CryptSignHashA;
	PFN_CRYPTSIGNHASH_W			CryptSignHashW;
	PFN_CRYPTVERIFYSIGNATURE_A	CryptVerifySignatureA;
	PFN_CRYPTVERIFYSIGNATURE_W	CryptVerifySignatureW;
} CAPIFUNCTIONTABLE, *LPCAPIFUNCTIONTABLE;

/*
 * Prototypes
 */
extern BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    );

extern BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    );

extern BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    );

extern BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    );

extern BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

extern BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	);

extern BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

extern BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

extern BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR sDescription,
	DWORD dwFlags
	);

#endif // __DPSECOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpsecure.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.c
 *  Content:	implements directplay security routines.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Added client-server security to directplay
 *  03/19/97    sohailm Wait for challenge to be processed before unblocking receive thread
 *  03/30/97    sohailm Send dwReserved1 field from session desc in enumsessions reply
 *  04/09/97    sohailm Return DPERR_CANTLOADSECURITYPACKAGE when package not found.
 *  04/23/97    sohailm Added support to query buffer sizes from the security package (.
 *                      Updated SignAndSendDPMessage() and VerifyMessage() to support
 *                      encryption in addition to signing. Now Addforward and SetSessionDesc 
 *                      messages are being encrypted for privacy.
 *  05/12/97    sohailm Added support to provide message privacy through Crypto API. 
 *                      Encryption code can be contionally compiled to use SSPI or CAPI.
 *  05/18/97    sohailm SecureSendDPMessage() was not getting the correct security context
 *                      if destination player was a user player.
 *  05/21/97    sohailm Now we toggle the flags DPSEND_SIGNED and DPSEND_ENCRYPTED off in
 *                      SecureSendDPMessage().
 *  05/22/97    sohailm Now we use a dplay key container with CAPI. Using the default key 
 *                      container was failing when the user wasn't logged on. 
 *  05/29/97    sohailm Now we don't include null char in size of credential strings.
 *                      ISC_REQ_SUPPLIED_CREDS flag is now obsolete - removed it
 *                      (thanks to NTLM).
 *  06/09/97    sohailm Added better error handling for SSPI and CAPI provider initialization.
 *  06/16/97    sohailm Now we return server authentication errors to the client.
 *                      Mapped SEC_E_UNKNOWN_CREDENTIALS sspi error to DPERR_LOGONDENIED on
 *                       the client because DPA returns this when passed blank credentials.
 *  06/22/97    sohailm Since QuerySecurityPackageInfo() is not supported on all platforms 
 *                      (NTLM,Win'95 Gold) added a work around to get this info from the context.
 *                      We were not keeping track of separate encryption/decryption keys for each client.                      
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  06/24/97    sohailm Code cleanup to prevent leaks etc.
 *  06/26/97    sohailm Don't modify the original message by encrypting in place. Make a local copy.
 *  06/27/97    sohailm Only sign the data portion of a signed message (bug:10373)
 *	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887)
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/
#include "dplaypr.h"
#include "dpos.h"
#include "dpsecure.h"

// Encryption/Decryption is done using symmetric keys or session keys, meaning
// the same key will be used for both encryption and decryption. Encryption support
// is provided using SSPI or CAPI depending on the SSPI_ENCRYPTION flag. CAPI is default.

// The process of exchanging session keys is as follows:
// 1. Server and Client each generate a public/private key pair. 
// 2. They exchange their pubic keys (through digitally signed messages).
// 3. Server and Client each generate a session key.
// 4. Each encrypts the session key with the receivers public key
// 5. They exchange the encrypted session keys.
// 6. Receiver will import the encrypted session key blobs into the CSP
//    thus completing the exchange.

// Implementation
//
// Client and Server generate public/private key pair in LoadServiceProvider() 
// Client generates session (encryption) key in SendKeysToServer()
// Server generates session (encryption) key in SendKeyExchangeReply()
// Server sends its public key to the client in the DPSP_MSG_ACCESSGRANTED message (signed)
// Client encrypts its session key using the server's public key and sends
//  it to the server along with the clients public key in DPSP_MSG_KEYEXCHANGE (signed).
// Server encrypts its session key using the client's public key and sends 
//  it to the client in DPSP_MSG_KEYEXCHANGEREPLY (signed).
// Exchange is done - now the server and client can send each other private messages.


//
// Globals
//
LPBYTE                  gpReceiveBuffer;
DWORD                   gdwReceiveBufferSize;

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSecurity"
//+----------------------------------------------------------------------------
//
//  Function:   InitSecurity
//
//  Description: This function initializes CAPI and SSPI.
//
//  Arguments:  this - dplay object
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;

    // check if we already initialized CAPI
    if (!OS_IsCAPIInitialized()) 
    {
        hr = InitCAPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("CAPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // check if we already initialized SSPI
    if (!OS_IsSSPIInitialized()) 
    {
        hr = InitSSPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("SSPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // success
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"InitCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitCAPI
//
//  Description: This function initializes CAPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitCAPI(
    void
    )
{
    HRESULT hr;

    //
    // Load CAPI DLL. We unload it only when dplay goes away.
    //
    ghCAPI = OS_LoadLibrary(CAPI_DLL);
    if (!ghCAPI)
    {
        DPF_ERRVAL("Can't load CAPI: Error=0x%08x",GetLastError());
        return DPERR_CANTLOADCAPI;
    }

    //
    // Get the Cryptographic Application Programming Interface
    //
    if (!OS_GetCAPIFunctionTable(ghCAPI))
    {
        DPF_ERR("Can't get the CAPI function table");
        hr = DPERR_CANTLOADCAPI;
        goto ERROR_EXIT;
    }

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghCAPI)
    {
        FreeLibrary(ghCAPI);
        ghCAPI = NULL;
    }
    return hr;

} // InitCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitSSPI
//
//  Description: This function initializes SSPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSSPI(
    void
    )
{
    HRESULT hr;

    //
    // Load SSPI DLL. We unload it only when dplay goes away.
    //
    if (gbWin95)
    {
        ghSSPI = OS_LoadLibrary (SSP_WIN95_DLL);
    }
    else
    {
        ghSSPI = OS_LoadLibrary (SSP_NT_DLL);
    }
    if (!ghSSPI)
    {
        DPF_ERRVAL("Cannot load SSPI: Error=0x%08x", GetLastError());
        return DPERR_CANTLOADSSPI;
    }

    //
    // Get the Security Service Provider Interface
    //
    if (!OS_GetSSPIFunctionTable(ghSSPI))
    {
        DPF_ERR("Can't get the SSPI function table");
        hr = DPERR_CANTLOADSSPI;
        goto ERROR_EXIT;
    }

    //
    // Initialize seed for random numbers used during encryption
    //
    srand(GetTickCount());

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghSSPI)
    {
        FreeLibrary(ghSSPI);
        ghSSPI = NULL;
    }
    return hr;

} // InitSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"LoadSecurityProviders"

//+----------------------------------------------------------------------------
//
//  Function:   LoadSecurityProviders
//
//  Description: This function loads the specified security providers (SSPI and CAPI) and
//               initializes the credentials handle and the necessary keys.
//
//  Arguments:  this - dplay object
//              dwFlags - server or client
//
//  Returns:    DP_OK, DPERR_UNSUPPORTED, DPERR_INVALIDPARAMS, DPERR_CANTLOADSECURITYPACKAGE, or
//              DPERR_OUTOFMEMORY, DPERR_GENERIC.
//
//-----------------------------------------------------------------------------
HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    )
{
    TimeStamp tsLifeTime;
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData = NULL;
    SEC_WINNT_AUTH_IDENTITY_W AuthData;
    SECURITY_STATUS SecStatus;
    ULONG ulCredType;
    PCredHandle phCredential=NULL;
    HCRYPTPROV hCSP=0;
    HCRYPTKEY hEncryptionKey=0;
    HCRYPTKEY hPublicKey=0;
    LPBYTE pPublicKeyBuffer=NULL;
    DWORD dwPublicKeyBufferSize = 0;
    HRESULT hr;
	BOOL fResult;
    DWORD dwError;
    ULONG ulMaxContextBufferSize=0;

    // lpszSSPIProvider is always initialized
    // lpszCAPIProvider could be NULL in which case CAPI will load Microsoft's RSA Base Provider
    ASSERT(this->pSecurityDesc->lpszSSPIProvider);
    // we shouldn't have a credential handle yet
    ASSERT(!(this->phCredential));

    //
    // SSPI
    //

    ZeroMemory(&AuthData,sizeof(AuthData));
    if (this->pUserCredentials)
    {
        // build a SEC_WINNT_AUTH_IDENTITY structure to pass credentials to 
        // SSPI package - this prevents the package from popping the login dialog

        // ************************************************************************
        // However, this data is package dependent. Passing credentials in this 
        // format will only work for packages that support the SEC_WINNT_AUTH_IDENTITY 
        // format for credentials.
        // ************************************************************************

        // note - do not include null character in the size of the strings
        if (this->pUserCredentials->lpszUsername)
        {
            AuthData.User = this->pUserCredentials->lpszUsername;
            AuthData.UserLength = WSTRLEN(AuthData.User)-1;
        }
        if (this->pUserCredentials->lpszPassword)
        {
            AuthData.Password = this->pUserCredentials->lpszPassword;
            AuthData.PasswordLength = WSTRLEN(AuthData.Password)-1;
        }
        if (this->pUserCredentials->lpszDomain)
        {
            AuthData.Domain = this->pUserCredentials->lpszDomain;
            AuthData.DomainLength = WSTRLEN(AuthData.Domain)-1;
        }

        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        pAuthData = &AuthData;
    }

    // allocate memory for the credential handle
    phCredential = DPMEM_ALLOC(sizeof(CredHandle));
    if (!phCredential)
    {
        DPF_ERR("Failed to allocate memory for credentials handle");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Select the appropriate credentials type
    //
    if (SSPI_SERVER == dwFlags)
    {
        DPF(9, "Setting server credentials");

        ulCredType = SECPKG_CRED_INBOUND;
    }
    else
    {
        DPF(9, "Setting client credentials");

        ulCredType = SECPKG_CRED_OUTBOUND;
    }

	// Calling acquire credentials loads the SSPI provider
    SecStatus = OS_AcquireCredentialsHandle(
        NULL, 
        this->pSecurityDesc->lpszSSPIProvider,
        ulCredType,
        NULL,
        pAuthData,
        NULL,
        NULL,
        phCredential,
        &tsLifeTime);
    if (!SEC_SUCCESS(SecStatus))
    {
        switch (SecStatus) {

        case SEC_E_SECPKG_NOT_FOUND:
            DPF_ERRVAL("SSPI provider %ls was not found\n",this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            break;

        case SEC_E_UNSUPPORTED_FUNCTION:
            DPF_ERR("This operation is not supported");
            hr = DPERR_UNSUPPORTED;
            break;

        case SEC_E_INVALID_TOKEN:
            DPF_ERRVAL("Credentials were passed in invalid format - check the format for %ls",\
                this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_INVALIDPARAMS;
            break;
            
        case SEC_E_UNKNOWN_CREDENTIALS:
            DPF_ERR("SSPI Provider returned unknown credentials error - mapping to logon denied");
            hr = DPERR_LOGONDENIED;
            break;

        default:
            DPF(0,"Acquire Credential handle failed [0x%x]\n", SecStatus);
            hr = SecStatus;
        }

        goto CLEANUP_EXIT;
    }

    // get the max buffer size used for opaque buffers during authentication
    hr = GetMaxContextBufferSize(this->pSecurityDesc, &ulMaxContextBufferSize);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get context buffer size: hr=0x%08x",hr);
        goto CLEANUP_EXIT;
    }

    //
	// CAPI
    //

    // delete any existing key containers 
    fResult = OS_CryptAcquireContext(
        &hCSP,                                  // handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_DELETEKEYSET,                     // delete any existing key container
        &dwError
        );

    if (!fResult)
    {

        switch (dwError) {

        case NTE_BAD_KEYSET_PARAM:
            DPF_ERRVAL("The CAPI provider name [%ls] is invalid",this->pSecurityDesc->lpszCAPIProvider);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_PROV_TYPE:
            DPF_ERRVAL("The CAPI provider type [%d] is invalid", this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_TYPE_NOT_DEF:
            DPF_ERRVAL("No registry entry exists for the CAPI provider type %d", \
                this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case ERROR_INVALID_PARAMETER:
            DPF_ERR("Invalid provider passed to the Crypto provider");
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_DLL_NOT_FOUND:
            DPF_ERR("The CAPI provider DLL doesn't exist or is not in the current path");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROVIDER_DLL_FAIL:
            DPF_ERR("The CAPI provider DLL file could not be loaded, and may not exist \
                If it exists, then the file is not a valid DLL");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_SIGNATURE:
            DPF_ERR("Warning!!! - CAPI provider DLL signature could not be verified. Either the DLL \
                or the signature has been tampered with");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        default:
            DPF(6,"Failed to delete key container: Error=0x%08x (ok)", dwError);
            // it's ok if we can't delete the container - don't fail yet
        }
    }


    // create a new key container 
    fResult = OS_CryptAcquireContext(
        &hCSP,       							// handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_NEWKEYSET,							// create a new key container
        &dwError
        );
    if (!fResult)
    {
        DPF_ERRVAL("Failed to create a key container: Error=0x%08x",dwError);
        hr = DPERR_CANTLOADSECURITYPACKAGE;
        goto CLEANUP_EXIT;
    }

	// create a public/private key pair
	hr = GetPublicKey(hCSP, &hPublicKey, &pPublicKeyBuffer, &dwPublicKeyBufferSize);
	if (FAILED(hr))
	{
        DPF_ERRVAL("Failed to create public/private key pair: hr=0x%08x", hr);
        goto CLEANUP_EXIT;
	}
	
    // success 

    // now remember everything in the dplay object
    this->phCredential = phCredential;
    this->ulMaxContextBufferSize = ulMaxContextBufferSize;
    this->hCSP = hCSP;
    this->hEncryptionKey = hEncryptionKey;
    this->hPublicKey = hPublicKey;
    this->pPublicKey = pPublicKeyBuffer;
    this->dwPublicKeySize = dwPublicKeyBufferSize;

    // mark that dplay is providing security
    this->dwFlags |= DPLAYI_DPLAY_SECURITY;
	this->dwFlags |= DPLAYI_DPLAY_ENCRYPTION;

    return DP_OK;

	// not a fall through

CLEANUP_EXIT:

	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hPublicKey);
    OS_CryptReleaseContext(hCSP,0);
    if (phCredential) 
	{
		OS_FreeCredentialHandle(phCredential);
		DPMEM_FREE(phCredential);
	}

    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // LoadSecurityProviders


#undef DPF_MODNAME
#define DPF_MODNAME	"GenerateAuthenticationMessage"

//+----------------------------------------------------------------------------
//
//  Function:   GenerateAuthenticateMessage
//
//  Description:   This function calls InitializeSecurityContext to generate 
//              an authentication message and sends it to the server.  
//              It generates different authentication messages depending on 
//              whether there's security token from the server to be used 
//              as input message or not (i.e. whether pInMsg is NULL).
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - pointer to the server's authentication message '
//                       containing the security token.
//              fContextReq - security context flags
//
//  Returns:    DP_OK, DPERR_OUTOFMEMORY, DPERR_AUTHENTICATIONFAILED, DPERR_LOGONDENIED
//
//-----------------------------------------------------------------------------
HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY          this,
    LPMSG_AUTHENTICATION    pInMsg,
    DWORD					dwInMsgLen,
    ULONG                   fContextReq
    )
{
    PCtxtHandle phCurrContext;
    DWORD dwOutMsgType, dwHeaderSize;
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    PSecBufferDesc pInSecDesc;
    ULONG     fContextAttrib;
    TimeStamp tsExpireTime;
    DWORD dwMessageSize;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg=NULL;
    HRESULT hr;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);

    if (pInMsg == NULL)
    {
        DPF(6, "Generating a negotiate message");
        //
        // This is the first time this function has been called, so the
        // message generated will be a MSG_NEGOTIATE.
        //
        phCurrContext = NULL;
        dwOutMsgType = DPSP_MSG_NEGOTIATE;
        pInSecDesc = NULL;

        // do we already have a security context ?
        if (this->phContext)
        {
            // get rid of it - we are re-negotiating
            DPF(5, "Removing existing security context");

            OS_DeleteSecurityContext(this->phContext);
            DPMEM_FREE(this->phContext);
            this->phContext = NULL;
        }

        //
        // Allocate memory to hold client's security context handle
        //
        this->phContext = DPMEM_ALLOC(sizeof(CtxtHandle));
        if (!this->phContext)
        {
            DPF_ERR("Failed to allocate security context handle - out of memory");
            return DPERR_OUTOFMEMORY;
        }
		DPF(6,"System player phContext=0x%08x", this->phContext);
    }
    else
    {
		DPF(6,"Using phContext=0x%08x for authentication",this->phContext);
        phCurrContext = this->phContext;
        dwOutMsgType = DPSP_MSG_CHALLENGERESPONSE;

		// SECURITY - validate authentication message
		if(dwInMsgLen < sizeof(MSG_AUTHENTICATION) || pInMsg->dwDataOffset < sizeof(MSG_AUTHENTICATION) ||
		   pInMsg->dwDataSize > dwInMsgLen-sizeof(MSG_AUTHENTICATION) ||
		   pInMsg->dwDataOffset + pInMsg->dwDataSize > dwInMsgLen )
		{
			DPF(1,"SECURITY WARN: invalid authentication message");
			hr = DPERR_AUTHENTICATIONFAILED;
			goto CLEANUP_EXIT;
		}

        //
        // Setup API's input security buffer to pass the client's negotiate
        // message to the SSPI.
        //
        inSecDesc.ulVersion = SECBUFFER_VERSION;
        inSecDesc.cBuffers = 1;
        inSecDesc.pBuffers = &inSecBuffer;

        inSecBuffer.cbBuffer = pInMsg->dwDataSize;
        inSecBuffer.BufferType = SECBUFFER_TOKEN;
        inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

        pInSecDesc = &inSecDesc;
    }

    dwHeaderSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION);

    //
    // Allocate memory for send buffer. 
    //
    pSendBuffer = DPMEM_ALLOC( dwHeaderSize + this->ulMaxContextBufferSize);

    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate authenticate message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    // Pass the client message buffer to SSPI via pvBuffer.
    //

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = pSendBuffer + dwHeaderSize;

    // determine the security context requirements
    fContextReq |= DPLAY_SECURITY_CONTEXT_REQ;

    //
    //  If user credential has been supplied, and if 'prompt user' flag has not 
    //  been set, SSPI will use the supplied credential
    //
    if (this->pUserCredentials)
    {
		DPF(6, "Using supplied credentials");
    }

    ASSERT(this->phContext);

    //
    // Generate a negotiate/challenge response message to be sent to the server.
    //    
    status = OS_InitializeSecurityContext(
        this->phCredential,                     // phCredential
        phCurrContext,                          // phContext
        NULL,                                   // pszTargetName
        fContextReq,                            // fContextReq
        0L,                                     // reserved1
        SECURITY_NATIVE_DREP,                   // TargetDataRep
        pInSecDesc,                             // pInput
        0L,                                     // reserved2
        this->phContext,                        // phNewContext
        &outSecDesc,                            // pOutput negotiate msg
        &fContextAttrib,                        // pfContextAttribute
        &tsExpireTime                           // ptsLifeTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if (SEC_E_NO_CREDENTIALS == status)           
        {
            //
            // If SSPI does not have user credentials, let the app collect them and try again
            // Note that we never allow the package to collect credentials. This is because of
            // two reasons:
            // 1. Apps don't like windows' dialogs popping up while they are page
            //    flipping.
            // 2. Not all security packages collect credentials (NTLM for one).
            //
            DPF(6, "No credentials specified. Ask user.");
            hr = DPERR_LOGONDENIED;
            goto CLEANUP_EXIT;
        }
        else
        {
            DPF(0,"Authentication message generation failed [0x%08x]\n", status);
            hr = status;
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        //
        // Success
        //
        if ((SEC_I_CONTINUE_NEEDED != status) &&
            (SEC_E_OK != status)) 
        {
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%08x]",status);
            ASSERT(FALSE);
            hr = status;
            goto CLEANUP_EXIT;
        }

        // fall through will send the message
    }

    //
    // Setup pointer to the security message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION)(pSendBuffer + this->dwSPHeaderSize);

    //
    // Setup directplay system message header 
    //
	SET_MESSAGE_HDR(pOutMsg);
    SET_MESSAGE_COMMAND(pOutMsg, dwOutMsgType);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;
    pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);

    //
    // Calculate actual message size to be sent
    //
    dwMessageSize = dwHeaderSize + outSecBuffer.cbBuffer;
    
    DPF(9,"Sending type = %d, length = %d\n", dwOutMsgType, dwMessageSize);

    //
    // Send message to the server
    //
    hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
    					dwMessageSize,DPSEND_GUARANTEED,FALSE);
	if (FAILED(hr))
    {
        DPF(0,"Send Msg (type:%d) Failed: ret = %8x\n", dwOutMsgType, hr);
        goto CLEANUP_EXIT;
    }

    // Success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:

	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
    return hr;

}   // GenerateAuthenticationMessage


#undef DPF_MODNAME
#define DPF_MODNAME "SendAuthenticationResponse"

HRESULT SetupLogonDeniedMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_LOGONDENIED);
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

HRESULT SetupAuthErrorMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, HRESULT hResult, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;
    LPMSG_AUTHERROR pAuthError = (LPMSG_AUTHERROR)pMsg;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    //
    // setup an authentication error message
    //
    SET_MESSAGE_COMMAND(pAuthError, DPSP_MSG_AUTHERROR);
    pAuthError->hResult = hResult;
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_AUTHERROR);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SendAuthenticationResponse
//
//  Description:   This function generates and sends an authentication response 
//              to the client.  It will generate and send either a challenge 
//              or the final authentication result to client depending on 
//              the type of client message (pointed to by pInMsg) passed 
//              to this function.
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - Points to the authentication message received from
//                       the server
//              pvSPHeader - pointer to reply sp header
//
//  Returns:    DPERR_OUTOFMEMORY or result form DoReply
//
//-----------------------------------------------------------------------------
HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    DWORD dwInMsgLen,
    LPVOID pvSPHeader
    )
{
    PCtxtHandle    phInContext=NULL, phOutContext=NULL;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    ULONG         fContextReq;
    ULONG         fAttribute;
    TimeStamp     tsExpireTime;
    SECURITY_STATUS status;
    DWORD dwHeaderSize=0, dwMessageSize=0, dwCommand, dwBufferSize;
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);
    ASSERT(pInMsg);

	// SECURITY
	if(dwInMsgLen < sizeof(MSG_AUTHENTICATION) || pInMsg->dwDataSize > dwInMsgLen ||
		pInMsg->dwDataSize > dwInMsgLen-sizeof(MSG_AUTHENTICATION) || 
		pInMsg->dwDataOffset < sizeof(MSG_AUTHENTICATION) || 
		pInMsg->dwDataOffset+pInMsg->dwDataSize > dwInMsgLen )
	{
		DPF(1,"SECURITY WARN: invalid Authentication message");
		return DPERR_GENERIC;		
	}


    // retrieve client info stored in nametable
    dwItem = NameFromID(this, pInMsg->dwIDFrom);
    pClientInfo = (LPCLIENTINFO) DataFromID(this, pInMsg->dwIDFrom);

    //
    // Which message did we get 
    //
    dwCommand = GET_MESSAGE_COMMAND(pInMsg);
    
    if (DPSP_MSG_NEGOTIATE == dwCommand)
    {
		DPF(6, "Received a negotiate message from player %d", pInMsg->dwIDFrom);

        phInContext = NULL;

        if (NAMETABLE_PENDING == dwItem)
		{
            if (pClientInfo)
            {
                // client has sent us another negotiate message instead of responding to our 
                // challenge. This can happen if communication link breaks down after the server 
                // responds to a negotiate.
			    DPF(6,"Removing existing information about client");

			    hr = RemoveClientInfo(pClientInfo);
                DPMEM_FREE(pClientInfo);
            }
		}
        else
        {
            // it's a duplicate id, we shouldn't be in this state
            DPF_ERRVAL("Player %d already exists in the nametable", pInMsg->dwIDFrom);
            ASSERT(FALSE);
            // don't respond for now 
            return DPERR_INVALIDPLAYER;
            // todo - we might want to send an error message.
        }

        //
        // Allocate memory to hold client information
        //
        pClientInfo = DPMEM_ALLOC(sizeof(CLIENTINFO));
        if (!pClientInfo)
        {
            DPF_ERR("Failed to allocate memory for client information - out of memory");
            return DPERR_OUTOFMEMORY;
        }
        //
        // Remember the pointer in the nametable temporarily
        //
        hr = SetClientInfo(this, pClientInfo, pInMsg->dwIDFrom);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to add client info to nametable for player %d", pInMsg->dwIDFrom);
            RemoveClientInfo(pClientInfo);
            DPMEM_FREE(pClientInfo);
            return hr;
        }

        phOutContext = &(pClientInfo->hContext);
    }
    else
    {
		DPF(6, "Received a challenge response from player %d", pInMsg->dwIDFrom);

        ASSERT(NAMETABLE_PENDING == dwItem);
        ASSERT(pClientInfo);

        //
        // Get the player context from name table
        //
        phInContext = phOutContext = &(pClientInfo->hContext);
    }

    DPF(6, "Using phInContext=0x%08x and phOutContext=0x%08x", phInContext, phOutContext);
    // 
    // Calculate buffer size needed for response. We are always allocating enough room 
    // for an authentication message. We use the same buffer to send access granted,
    // denied, or error system messages.
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + this->ulMaxContextBufferSize;

    //
    // Allocate memory for the buffer.
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup pointer to the message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION) (pSendBuffer + this->dwSPHeaderSize);

    //
    // Fill directplay system message header in the outgoing message buffer
    //
	SET_MESSAGE_HDR(pOutMsg);
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;

    //
    // Setup API's input security buffer to pass the client's negotiate
    // message to the SSPI.
    //
    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 1;
    inSecDesc.pBuffers = &inSecBuffer;

    inSecBuffer.cbBuffer = pInMsg->dwDataSize;
    inSecBuffer.BufferType = SECBUFFER_TOKEN;
    inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = (LPBYTE)pOutMsg + sizeof(MSG_AUTHENTICATION);

    // enfore the following requirements on the context 
    fContextReq = DPLAY_SECURITY_CONTEXT_REQ;

    ASSERT(phOutContext);

    //
    // pass it to the security package
    //
    status = OS_AcceptSecurityContext(
        this->phCredential, 
        phInContext, 
        &inSecDesc,
        fContextReq, 
        SECURITY_NATIVE_DREP, 
        phOutContext,
        &outSecDesc, 
        &fAttribute, 
        &tsExpireTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if ((SEC_E_LOGON_DENIED == status) ||
            (SEC_E_TARGET_UNKNOWN == status))
        {
            hr = SetupLogonDeniedMsg(this, pOutMsg, &dwMessageSize, pInMsg->dwIDFrom);
        }
        else
        {
            // Some other error occured - send an auth error message

            DPF_ERRVAL("Process authenticate request failed [0x%8x]\n", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }
    else
    {
        //
        // Success
        //
        if (SEC_E_OK == status)
        {
            //
            // Set up the max signature size for this package here. Although, 
            // the signature size is independent of the context, the only way to get it
            // in SSPI is through QueryContextAttributes (tied to a context). This
            // is why we setup this member here when the first client logs in.
            //
            if (0 == this->ulMaxSignatureSize)
            {
                hr = SetupMaxSignatureSize(this,phOutContext);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get signature size - not sending access granted message");

                    hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
                }
            }

            if (this->ulMaxSignatureSize)
            {
                // send an access granted message to the client
                DPF(6, "Sending access granted message");
                // 
                // Send an access granted message
                //
                hr = SendAccessGrantedMessage(this, pInMsg->dwIDFrom, pvSPHeader);
                if (FAILED(hr))
                {
                    DPF_ERRVAL("Failed to send access granted message: hr=0x%08x",hr);
                }
                // exit as we have already sent the message
                goto CLEANUP_EXIT;
            }

        }
        else if (SEC_I_CONTINUE_NEEDED == status)
        {
            DPF(6, "Sending challenge message");
            //
            // setup a challenge message
            //
            SET_MESSAGE_COMMAND(pOutMsg, DPSP_MSG_CHALLENGE);
            pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
            dwMessageSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + outSecBuffer.cbBuffer;
        }
        else
        {
            // todo - we do not support complete auth token at this time
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%8x]", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }

    // fall through will send the message

    //
    // Send reply to the client. We are using DoReply instead of SendDPMessage 
    // because we don't have a system player yet.
    //
    hr = DoReply(this, pSendBuffer, dwMessageSize, pvSPHeader, 0);
    if (FAILED(hr))
    {
        DPF(0, 
            "Send Authentication response failed for client[%d]\n",
            pInMsg->dwIDFrom);
    }

    // fall through

CLEANUP_EXIT:
    // cleanup allocations
    if (pSendBuffer) DPMEM_FREE(pSendBuffer);

    return hr;

}   // SendAuthenticationResponse

VOID CopyScatterGatherToContiguous(PUCHAR pBuffer, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD offset=0;
	UINT i;
	// copy the SG buffers into the single buffer. 
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              psp  - pointer to send parameter structure
//              bDropLock - flag whether to drop DPLAY_LOCK when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
// NOTE: see SecureSendDPMessageCAPIEx
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize, dwMsgSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;


    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(psp->pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
			if (!psp->pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(psp->pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + this->dwSPHeaderSize/*workaround*/ + psp->dwTotalSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        hr=E_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
    CopyScatterGatherToContiguous((LPBYTE)pSecureMsg+sizeof(MSG_SECURE)+this->dwSPHeaderSize/*workaround*/, 
    								psp->Buffers, psp->cBuffers, psp->dwTotalSize);

    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    dwMsgSize=pSecureMsg->dwDataSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (psp->dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(psp->pPlayerFrom) ? psp->pPlayerFrom->dwID : 0, 
		(psp->pPlayerTo) ? psp->pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

	ASSERT(dwSigSize <= this->ulMaxSignatureSize);
	#if 0
		if(dwSigSize > this->ulMaxSignatureSize){
			DEBUG_BREAK();
		}
	#endif	

    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
    hr=InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
    						 pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
    						 psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
    						 bDropLock);
	
CLEANUP_EXIT:    

	if(pSendBuffer){
		DPMEM_FREE(pSendBuffer);
	}

	return hr;	// since all alloc is on psp, it will get freed with the psp.

} // SecureSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessage
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
			if (!pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(pPlayerFrom) ? pPlayerFrom->dwID : 0, 
		(pPlayerTo) ? pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, 
        GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, dwFlags, bDropLock);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPIEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPIEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//				psp  - pointer to send parameters
//              bDropLock - whether to drop DPLAY_LOCK() when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//
// NOTE: we have to add in a dummy SP header to be encrypted with the message
//       because that's how the old version did it, and we must be compatible.
//       So as not to confuse all workarounds from what it would have been 
//       are marked with "workaround".
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{

	LPBYTE pMsg;
	DWORD  dwMsgSize;
	DWORD  dwMsgSizeMax;

	DWORD dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;
	DWORD MaxSign=100;
	LPMSG_SECURE pSecureMsg;


    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);


	dwMsgSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
	dwMsgSizeMax = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + MaxSign;
	
	pMsg = DPMEM_ALLOC(dwMsgSizeMax);

	if(!pMsg){
		DPF_ERR("Failed to allocate contiguous encryption buffer - out of memory\n");
		return DPERR_OUTOFMEMORY;
	}

	pSecureMsg=(LPMSG_SECURE)(pMsg+this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pSecureMsg);
	SET_MESSAGE_COMMAND(pSecureMsg, DPSP_MSG_SIGNED);

	CopyScatterGatherToContiguous(pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+this->dwSPHeaderSize/*workaround*/,
								  psp->Buffers,psp->cBuffers,psp->dwTotalSize);

    pSecureMsg->dwIDFrom     = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize   = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags      = DPSECURE_SIGNEDBYCAPI;
	//pSecureMsg->dwSignatureSize =			(filled in below when we know it)

	if (psp->dwFlags & DPSEND_ENCRYPTED)
	{
		// Encrypt the BODY of the message only
	
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
				if (!psp->pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE),		    // pointer to data
            &dwMsgSize                                      // size of data
			);
			
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE), dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			hr=DPERR_GENERIC;
			goto CLEANUP_EXIT;
		}
	}

	#ifdef DEBUG
	if(dwSigSize > MaxSign){
		DPF(0,"Buffer too Small, requested signature of size %d only allocated %d\n",dwSigSize, MaxSign);
		DEBUG_BREAK();
	}
	#endif

	pSecureMsg->dwSignatureSize = dwSigSize;

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// Warning, error may be incorrect since OS_CryptSignHash may call out and
		// cause the LastError to be changed.
		DPF_ERRVAL("Error 0x%x during CryptSignHash! (error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
							   pMsg, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
							   psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
							   bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	if(pMsg){
		DPMEM_FREE(pMsg);
	}

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

	return hr;
	
} // SecureSendDPMessageCAPIEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPI
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL, pLocalCopy=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

	if (dwFlags & DPSEND_ENCRYPTED)
	{
		//
		// Make a copy of the message, so we don't destroy the original message.
		// Sending messages to groups will not work otherwise.
		//
		// todo - update code to avoid the extra copy
		//
		pLocalCopy = DPMEM_ALLOC(dwMsgSize);
		if (!pLocalCopy)
		{
			DPF_ERR("Failed to make a local copy of message for encryption - out of memory");
			return DPERR_OUTOFMEMORY;
		}

		// copy the message into the buffer
		memcpy(pLocalCopy, pMsg, dwMsgSize);

		// now point to the local copy of the message
		pMsg = pLocalCopy;

		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if (!pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg,										    // pointer to data
            &dwMsgSize                                      // size of data
			);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg, dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			goto CLEANUP_EXIT;
		}
	}

	// Allocate memory for the signature
	// We allocate the send buffer and just put the signature directly into it

	dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize;

	pSendBuffer = DPMEM_ALLOC(dwBufferSize);
	if (!pSendBuffer)
	{
		DPF_ERR("Failed to allocate send buffer - out of memory");
		goto CLEANUP_EXIT;
	}

    // Copy message data into the send buffer
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYCAPI;
	if (dwFlags & DPSEND_ENCRYPTED)
	{
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
	}
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
    pSecureMsg->dwSignatureSize = dwSigSize;

	// todo - do we want to add a description to the signature ?

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pSendBuffer+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// WARNING The LastError may be incorrect since OS_CryptSignHash may call out
		// to DPF which can change the LastError value.
		DPF_ERRVAL("Error %x during CryptSignHash! (WARNING, error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}
    
    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, dwBufferSize, dwFlags,bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pLocalCopy) DPMEM_FREE(pLocalCopy);

	return hr;

} // SecureSendDPMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureDoReply"
//+----------------------------------------------------------------------------
//
//  Function:   SecureDoReply
//
//  Description:This function is used to send a signed or encrypted reply message. 
//              It is only used by the server to send secure messages to the client
//              during client logon.
//
//  Arguments:  this - pointer to dplay object
//              dpidFrom - sending player id
//              dpidTo - receiving player id
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (encrypted or signed)
//              pvSPHeader - sp header used for replying
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_INVALIDPLAYER, result from SignBuffer, 
//              EncryptBufferSSPI, or DoReply
//
//-----------------------------------------------------------------------------
HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	)
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);

    //
    // Get security context handle to use
    //
    if (IAM_NAMESERVER(this))
    {
		DWORD_PTR dwItem;

		dwItem = NameFromID(this,dpidTo);
		if (!dwItem)
		{
			DPF_ERR("Failed to send secure reply - invalid destination player");
			return DPERR_INVALIDPLAYER;
		}
		// we have a valid dest player id
		if (NAMETABLE_PENDING == dwItem)
		{
    	    // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = DataFromID(this, dpidTo);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

		    phContext = &(pClientInfo->hContext);
		    phEncryptionKey = &(pClientInfo->hEncryptionKey);
		}
		else 
		{
			// player has logged in
	        phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
	        phEncryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client side
        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    pSecureMsg->dwIDFrom = dpidFrom;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		dpidFrom, dpidTo, phContext);

    // 
    // Sign the entire message (including the wrapper) in the buffer. 
    // Signature follows the message.
    //
    hr = SignBuffer(
		phContext,			                            // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize,                         // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
	hr = DoReply(this, pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, 
		pvSPHeader, 0);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureDoReply

#undef DPF_MODNAME
#define DPF_MODNAME	"SignBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   SignBuffer
//
//  Description:This function signs a data buffer and puts the signature in it.
//
//  Arguments:  phContext - pointer to signing security context handle
//              pBuffer - data buffer
//              dwBufferSize - size of the buffer
//              pSig - signature buffer
//              pdwSigSize - pointer to signature size
//
//  Returns:    DP_OK if success, otherwise DPERR_SIGNFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc outSecDesc;
    SecBuffer outSecBuffer[2];
    SECURITY_STATUS status;

    ASSERT(pBuffer && pSig && pdwSigSize);

    DPF(6,"Signing buffer: data: %d",dwBufferSize);
    DPF(6,"Signing buffer: sig: %d",*pdwSigSize);

    // 
    // Setup message buffer to be signed
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 2;
    outSecDesc.pBuffers = &outSecBuffer[0];

    outSecBuffer[0].cbBuffer = dwBufferSize;
    outSecBuffer[0].BufferType = SECBUFFER_DATA;
    outSecBuffer[0].pvBuffer = pBuffer;

    outSecBuffer[1].cbBuffer = *pdwSigSize;
    outSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    outSecBuffer[1].pvBuffer = pSig;

    //
    // Sign the message
    //
    status = OS_MakeSignature(
        phContext,         // phContext
        0,                  // fQOP (Quality of Protection)
        &outSecDesc,        // pMessage
        0                   // MessageSeqNo
        );

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"Buffer couldn't be signed: 0x%08x", status);
        return DPERR_SIGNFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = outSecBuffer[1].cbBuffer;

    // 
    // Success
    //
	return DP_OK;

} // SignBuffer


#undef DPF_MODNAME
#define DPF_MODNAME "VerifyBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyBuffer
//
//  Description:This function verifies the digital signature of a data buffer, given
//              the signature
//
//  Arguments:  hContext - Handle to client's security context
//              pBuffer - Points to signed message 
//              dwBufferSize - Size of the message
//              pSig - Points to the signature
//              dwSigSize - Size of the signature
// 
//  Returns:    DP_OK if signature verifies OK. Otherwise, DPERR_VERIFYFAILED is returned.
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    )
{
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc;
    SecBuffer inSecBuffer[2];

    DPF(6,"Verifying buffer: data: %d",dwBufferSize);
    DPF(6,"Verifying buffer: sig: %d",dwSigSize);

    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 2;
    inSecDesc.pBuffers = &inSecBuffer[0];

    inSecBuffer[0].cbBuffer = dwBufferSize;
    inSecBuffer[0].BufferType = SECBUFFER_DATA;
    inSecBuffer[0].pvBuffer = pBuffer;
    inSecBuffer[1].cbBuffer = dwSigSize;
    inSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    inSecBuffer[1].pvBuffer = pSig;

    status = OS_VerifySignature(phContext, &inSecDesc, 0, 0);

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"******** Buffer verification failed: 0x%08x ********", status);
        return DPERR_VERIFYSIGNFAILED;
    }

    //
    // Success
    //
    return DP_OK;

}   // VerifyBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureSSPI
//
//  Description:This function verifies the digital signature on a secure message using
//              the Security Support Provider Interface (SSPI).
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    PCtxtHandle phContext=NULL;
    DWORD_PTR dwItem;
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

	DPF(6,"Using SSPI for Signature verification");
    //
    // Retrieve security context handle to verify the message
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phContext = &(pClientInfo->hContext);
        }
        else
        {
            // player has logged in
            phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
        }
    }
    else
    {
        // client
        phContext = this->phContext;
    }

	//
	// Verify signature
	//
    hr = VerifyBuffer( 
        phContext,                                       // sec context handle
		(LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	 // pointer to embedded message
		pSecureMsg->dwDataSize,							 // size of embedded message
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset + pSecureMsg->dwDataSize,
														 // pointer to signature
        pSecureMsg->dwSignatureSize                      // size of signature
        );

    return hr;

}   // VerifySignatureSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureCAPI
//
//  Description:This function verifies the digital signature on a message using the
//              Crypto API.
//
//  Arguments:  this - pointer to dplay object
//              pSecureMsg - secure message that came off the wire
// 
//  Returns:    DP_OK, DPERR_GENERIC, DPERR_INVALIDPLAYER, DPERR_VERIFYSIGNFAILED,
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    )
{
    DWORD_PTR dwItem;
    HRESULT hr = DPERR_GENERIC;
	HCRYPTHASH hHash=0;
	HCRYPTKEY *phPublicKey;

	DPF(6,"Using CAPI for Signature verification");

    //
    // Retrieve sender's public key
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phPublicKey = &(pClientInfo->hPublicKey);
        }
        else
        {
            // player has logged in
            phPublicKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hPublicKey);
        }
    }
    else
    {
        // client
        phPublicKey = &(this->hServerPublicKey);
    }

	ASSERT(phPublicKey);

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset, pSecureMsg->dwDataSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Validate digital signature.
	if(!OS_CryptVerifySignature(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+pSecureMsg->dwDataSize, 
		pSecureMsg->dwSignatureSize, *phPublicKey, NULL, 0)) 
	{
		if(GetLastError() == NTE_BAD_SIGNATURE) 
		{
			DPF_ERR("********** Signature verification failed *********");
			hr = DPERR_VERIFYSIGNFAILED;
		} 
		else 
		{
			DPF_ERRVAL("Error %x during CryptVerifySignature!\n", GetLastError());
		}
		goto CLEANUP_EXIT;
	} 

	hr = DP_OK;
	//
	// Fall through
	//

CLEANUP_EXIT:

	OS_CryptDestroyHash(hHash);
    return hr;

}   // VerifySignatureCAPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifyMessage"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyMessage
//
//  Description:This function verifies a secure message. If the message is signed,
//              it will verify the digital signature on it. If the message is encrypted,
//              it will verify the digital signature on the message to make sure it has
//              not been tampered with and then decrypt it.
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

    if (!this->pSysPlayer)
    {
        DPF_ERR("Can't verify message - no system player yet");
        return DPERR_GENERIC;
    }

	// Parameter Validation.  Validate the secure message buffer.

	if(dwMessageSize < (DWORD)(sizeof(MSG_SECURE))){
		DPF_ERR("ATTACK WARN: Invalid secure message, too small\n");
	}

	if(pSecureMsg->dwDataOffset > SPMAXMESSAGELEN || pSecureMsg->dwDataSize > SPMAXMESSAGELEN || pSecureMsg->dwSignatureSize > SPMAXMESSAGELEN)
	{
		DPF_ERR("ATTACK WARN: Invalid size of offset field in secure message");
		return DPERR_GENERIC;
	}


	if((pSecureMsg->dwDataOffset > dwMessageSize)||
	   (pSecureMsg->dwDataOffset + pSecureMsg->dwDataSize + pSecureMsg->dwSignatureSize > dwMessageSize)){
		DPF_ERR("ATTACK WARN: Invalid message size in secure message");
		return DPERR_GENERIC;
	}

	DPF(6,"Verifying signature for message 0x%08x from player %d", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);
	//
	// Verify the digital signature on the message
	//

	if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYCAPI)
	{
		hr = VerifySignatureCAPI(this, pSecureMsg);
	}
	else if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYSSPI)
	{
		// sspi signature includes the secure message not just the contents
		// (this is how it was coded)
		hr = VerifySignatureSSPI(this, pReceiveBuffer, dwMessageSize);
	}
	else
	{
		// flags were not set
		return DPERR_INVALIDPARAMS;
	}

	if (FAILED(hr))
	{
		return hr;
	}

	//
	// Decrypt the message, if it was encrypted
	//

	if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
	{
		hr = DecryptMessageCAPI(this, pSecureMsg);
	}

    return hr;

}   // VerifyMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"EncryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   EncryptBufferSSPI
//
//  Description:This function encrypts the Buffer passed in the buffer in place.
//              It also setups up the checksum in the structure.              
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be encrypted
//              pdwBufferSize - pointer to Buffer size. If encryption succeeds, this will be
//                              be updated to the encrypted Buffer size
//              pSig - buffer for the signature
//              pdwSigSize - pointer to sig size. If encryption succeeds, this will be
//                           updated to the size of generated signature.
// 
//  Returns:    DP_OK if success, otherwise DPERR_ENCRYPTIONFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer,
    LPDWORD pdwBufferSize,
    LPBYTE pSig,
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc   SecDesc;
    SecBuffer       SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

    ASSERT(pSig);
    ASSERT(pdwSigSize);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup security buffer to pass the outgoing message to SealMessage()
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    //
    // Encrypt the outgoing message
    //
    status = OS_SealMessage(phContext, 0L, &SecDesc, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Encryption failed: %8x", status);
        return DPERR_ENCRYPTIONFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

}   // EncryptBufferSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"DecryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   DecryptBufferSSPI
//
//  Description:This function decrypts the Buffer passed in the buffer in place.
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be decrypted
//              dwBufferSize - Buffer buffer size
//              pSig - signature buffer
//              dwSigSize - signature buffer size
// 
//  Returns:    DP_OK if success, otherwise DPERR_DECRYPTIONFAILED, DPERR_ENCRYPTIONNOTSUPPORTED.
//
//-----------------------------------------------------------------------------
HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD pdwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc SecDesc;
    SecBuffer     SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

	ASSERT(pdwBufferSize);
	ASSERT(pdwSigSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup API's input security buffer to pass the client's encrypted 
    // message to UnsealMessage().
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    status = OS_UnSealMessage(phContext, &SecDesc, 0L, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Decryption failed: %8x\n", GetLastError());
        return DPERR_DECRYPTIONFAILED;
    }

	*pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

} // DecryptBufferSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "EncryptBufferCAPI"

HRESULT EncryptBufferCAPI(LPDPLAYI_DPLAY this, HCRYPTKEY *phEncryptionKey, LPBYTE pBuffer, LPDWORD pdwBufferSize)
{
	BOOL fResult;
	DWORD dwEncryptedSize, dwError;

    ASSERT(phEncryptionKey);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    DPF(6,"Encrypt buffer using CAPI: size=%d",*pdwBufferSize);

	dwEncryptedSize = *pdwBufferSize;

	// encrypt buffer using CAPI
    fResult = OS_CryptEncrypt(
        *phEncryptionKey,           // session key for encryption
        0,                          // no hash needed - we are singing using SSPI
        TRUE,                       // final block
        0,                          // reserved
        pBuffer,                    // buffer to be encrypted
        &dwEncryptedSize,           // size of encrypted data
        *pdwBufferSize				// size of buffer
        );

    if (!fResult)
    {
        dwError = GetLastError();
        if (ERROR_MORE_DATA == dwError)
        {
            DPF_ERR("Block encryption is not supported in this release");
        }
        else
        {
            DPF(0,"Failed to encrypt buffer: Error=%d",dwError);
        }
        return DPERR_ENCRYPTIONFAILED;
    }

	// initialize the number of bytes encrypted
	*pdwBufferSize = dwEncryptedSize;

	// success
	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecryptMessageCAPI"

HRESULT DecryptMessageCAPI(LPDPLAYI_DPLAY this, LPMSG_SECURE pSecureMsg)
{
	BOOL fResult;
	DWORD_PTR dwItem;
	HCRYPTKEY *phDecryptionKey;

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

	DPF(6,"Decrypting message 0x%08x from player %d using CAPI", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);

	//
	// Retrieve sender's decryption key
	//
	if (IAM_NAMESERVER(this))
	{
		dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
		if (0==dwItem)
		{
			DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
			return DPERR_INVALIDPLAYER;
		}
		if (NAMETABLE_PENDING == dwItem)
		{
			// player hasn't logged in yet
			LPCLIENTINFO pClientInfo;

			pClientInfo = (LPCLIENTINFO) DataFromID(this, pSecureMsg->dwIDFrom);
			if (!pClientInfo)
			{
				DPF_ERR("No client info available for this player");
				return DPERR_GENERIC;
			}

			phDecryptionKey = &(pClientInfo->hDecryptionKey);
		}
		else
		{
			// player has logged in
			phDecryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hDecryptionKey);
		}
	}
	else
	{
		// client
		phDecryptionKey = &(this->hDecryptionKey);
	}

	ASSERT(phDecryptionKey);

	// decrypt buffer using CAPI
    fResult = OS_CryptDecrypt(
        *phDecryptionKey,								// session key for decryption
        0,												// no hash used
        TRUE,											// final block
        0,												// reserved
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	// buffer to be decrypted
        &(pSecureMsg->dwDataSize)						// size of buffer
        );
	if (!fResult)
	{
		DPF_ERRVAL("Buffer decryption failed: Error=0x%08x",GetLastError());
		return DPERR_GENERIC;
	}

	// success
	return DP_OK;

} // DecryptMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"Login"
//+----------------------------------------------------------------------------
//
//  Function:   Login
//
//  Description:This function does the user authentication synchronously.
//
//  Arguments:  this - pointer to dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT 
Login(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;
    DWORD dwRet, dwTimeout;

    ASSERT(this->pSysPlayer);

    // check if we are already logged in
    if (DPLOGIN_SUCCESS == this->LoginState) return DP_OK;

    dwTimeout = DP_LOGIN_SCALE*GetDefaultTimeout(this, TRUE);

    // always start in negotiate mode
    this->LoginState = DPLOGIN_NEGOTIATE;

    while (TRUE)
    {
        switch (this->LoginState) {

        case DPLOGIN_NEGOTIATE:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send a Negotiate message to the server.
            //
            hr = GenerateAuthenticationMessage(this, NULL, 0, 0);
            if (FAILED(hr))
            {
                DPF_ERR("Generate Negotiate message failed");
                // we are not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                goto CLEANUP_EXIT;
            }
            break;

        case DPLOGIN_ACCESSGRANTED:
			{
				LPMSG_ACCESSGRANTED pMsg = (LPMSG_ACCESSGRANTED) gpReceiveBuffer;
				DWORD dwMsgSize = gdwReceiveBufferSize;
				HCRYPTKEY hServerPublicKey;

				// SECURITY, verify fields in ACCESSGRANTED message are good.
				if((pMsg->dwPublicKeyOffset > dwMsgSize)||(pMsg->dwPublicKeyOffset < sizeof(MSG_ACCESSGRANTED)) ||
				   (pMsg->dwPublicKeySize > dwMsgSize-sizeof(MSG_ACCESSGRANTED)) ||
				   (pMsg->dwPublicKeySize + pMsg->dwPublicKeyOffset > dwMsgSize) )
				{
					DPF_ERR("SECURITY WARN: invalid contents in ACCESSGRANTED message");
					hr = DPERR_AUTHENTICATIONFAILED;
					goto UNBLOCK_EXIT;
				}

				ASSERT(this->phContext);
				// we are initializing the signature buffer size here because SSPI 
				// requires a context to query for this information.
				hr = SetupMaxSignatureSize(this,this->phContext);
				if (FAILED(hr))
				{
					DPF_ERR("Failed to get max signature size");
                    // unblock sp thread on our way out
					goto UNBLOCK_EXIT;
				}
				// We successfully logged into the server. Now we need to setup session
				// keys for encryption/decryption. 

				// import server's public key which is contained in the access granted message 
				hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset, pMsg->dwPublicKeySize, &hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to import server's public key: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // unblock receive thread on our way out
					goto UNBLOCK_EXIT;
				}

	            // we are done with the receive buffer, now unblock the receive thread
		        SetEvent(ghReplyProcessed);

				// remember server's public key
				this->hServerPublicKey = hServerPublicKey;

                // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	            // until we finish processing it.
                gbWaitingForReply = TRUE;

				// send our session and public keys to server
				hr = SendKeysToServer(this, hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to send keys to server: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // we are not waiting for a reply anymore
                    gbWaitingForReply = FALSE;
					goto CLEANUP_EXIT;
				}
			}
			break;
      
        case DPLOGIN_LOGONDENIED:
            DPF_ERR("Log in failed: Access denied");
            hr = DPERR_LOGONDENIED;
            // reset login state
            this->LoginState = DPLOGIN_NEGOTIATE;
            // let the app handle now so it can collect credentials from user and try again
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_ERROR:
            // we are not looking at version here because this change is being made
            // for DirectPlay 5.0 post beta2. We don't want to bump the version this late.
            // todo - remove this check after DirectPlay 5.0 ships.
            if (gdwReceiveBufferSize > sizeof(MSG_SYSMESSAGE))
            {
                LPMSG_AUTHERROR pAuthErrorMsg = (LPMSG_AUTHERROR) gpReceiveBuffer;
                DWORD dwMsgSize = gdwReceiveBufferSize;
                
				// SECURITY
                if(dwMsgSize < sizeof(MSG_AUTHERROR))
                {
                	DPF_ERR("SECURITY WARN: Login Error, improperly formatted");
                	hr = DPERR_AUTHENTICATIONFAILED;
                	goto CLEANUP_EXIT;
                }
                DPF_ERRVAL("An authentication error occured on the server: Error=0x%08x",pAuthErrorMsg->hResult);
                hr = pAuthErrorMsg->hResult;
            }
            else
            {
                DPF_ERR("Login failed: Authentication error");    
                hr = DPERR_AUTHENTICATIONFAILED;
            }
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_PROGRESS:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send response to challenge
            //
            hr = GenerateAuthenticationMessage(this, (LPMSG_AUTHENTICATION)gpReceiveBuffer, gdwReceiveBufferSize, 0);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Generate challenge response failed",hr);
                // not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
            }
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);
            break;

		case DPLOGIN_KEYEXCHANGE:
            // we received server's session key
			hr = ProcessKeyExchangeReply(this,(LPMSG_KEYEXCHANGE)gpReceiveBuffer, gdwReceiveBufferSize);
			if (FAILED(hr))
			{
                DPF_ERRVAL("Failed to process key exchage reply from server: hr = 0x%08x",hr);
                hr = DPERR_AUTHENTICATIONFAILED;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
			}
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);

            // keys were exchanged successfully. we are done.
            this->LoginState = DPLOGIN_SUCCESS;
			hr = DP_OK;

    		DPF(5, "Log in successful");
			goto CLEANUP_EXIT;
			break;

        default:
            // make sure we notice 
            ASSERT(FALSE);
            DPF_ERR("Invalid login status\n");
            hr = DPERR_AUTHENTICATIONFAILED;
            goto CLEANUP_EXIT;
            break;
        }
        //
        // Block if we sent a message until we get a response
        //
        if (gbWaitingForReply)
        {
	        // we're protected by the service crit section here, so we can leave dplay
	        // (for reply to be processed)
	        LEAVE_DPLAY();

            // wait for the answer
            dwRet = WaitForSingleObject(ghConnectionEvent,dwTimeout);

	        ENTER_DPLAY();
	        
	        // notice that we look at gbWaitingForReply here instead of dwRet.
	        // this is because we may have timed out just as the reply arrived.
	        // since the reply had the dplay lock, dwRet would be WAIT_TIMEOUT, but
	        // we would have actually received the reply.
	        if (gbWaitingForReply)	
	        {
                DPF_ERR("Waiting for authentication message...Time out");
		        // gbWaitingForReply would have been set to FALSE when the reply arrived
		        // if it's not FALSE, no reply arrived...
		        gbWaitingForReply = FALSE; // reset this for next time
		        hr = DPERR_TIMEOUT;
                goto CLEANUP_EXIT;
	        }

            // we got a response, clear the event
            ResetEvent(ghConnectionEvent);

            // don't unblock the receive thread if we need to process the contents of
            // the receive buffer. We'll unblock the thread after we are done.
            if ((DPLOGIN_PROGRESS != this->LoginState) &&
				(DPLOGIN_KEYEXCHANGE != this->LoginState) &&
                (DPLOGIN_ACCESSGRANTED != this->LoginState))
            {
                // unblock the receive thread
                SetEvent(ghReplyProcessed);
            }

        }   // if (gbWaitingForReply)

    } //  while (TRUE)

    // we never fall through here

// unblock receive thread on our way out
UNBLOCK_EXIT:
    SetEvent(ghReplyProcessed);

// cleanup and bail
CLEANUP_EXIT:
	gpReceiveBuffer = NULL;
    gdwReceiveBufferSize = 0;
    return hr;

} // Login


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleAuthenticationReply"
//+----------------------------------------------------------------------------
//
//  Function:   HandleAuthenticationReply
//
//  Description:This function wakes up the requesting thread, and waits for them 
//              to finish w/ the response buffer
//
//  Arguments:  pReceiveBuffer - buffer received from the sp
//              dwSize - buffer size
// 
//  Returns:    DP_OK or E_FAIL
//
//-----------------------------------------------------------------------------
HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwSize
    ) 
{
	DWORD dwRet;

	// 1st, see if anyone is waiting
	if (!gbWaitingForReply)
	{
		DPF(1,"reply arrived - no one waiting, returning");
		LEAVE_DPLAY();
		return DP_OK;
	}
	// reply is here, reset flag. we do this inside dplay, so whoever is waiting
	// can timeout while we're here, but if they look at gbWaitingForReply they'll
	// see reply actually arrived.
	gbWaitingForReply = FALSE;

    DPF(1,"got authentication reply");
    gpReceiveBuffer = pReceiveBuffer;
    gdwReceiveBufferSize = dwSize;

	// we leave dplay, since the thread in dpsecure.c will need 
	// to enter dplay to process response
	LEAVE_DPLAY();
	
	// let login() party on the buffer
	SetEvent(ghConnectionEvent);

	//
	// wait for Reply to be processed
    dwRet = WaitForSingleObject(ghReplyProcessed,INFINITE);
	if (dwRet != WAIT_OBJECT_0)
	{
		// this should *NEVER* happen
		ASSERT(FALSE);
		return E_FAIL;
	}

	// success!
	ResetEvent(ghReplyProcessed);		

	// note we leave w/ the dplay lock dropped.
	// our caller will just exit (not dropping the lock again).
	return DP_OK;

} // HandleAuthenticationReply


#undef DPF_MODNAME
#define DPF_MODNAME	"SetClientInfo"
//+----------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Description:This function stores client informaton in the nametable
//              given a player id.
//
//  Arguments:  this - pointer to dplay object
//              pClientInfo - pointer to client info.
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER
//
//-----------------------------------------------------------------------------
HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    )
{
	DWORD dwUnmangledID;
    DWORD index,unique;

    // check if we got a valid id
    if (!IsValidID(this,id))
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    // decrypt the id
	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index > this->uiNameTableSize ) 
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(this->pNameTable[index].dwItem == NAMETABLE_PENDING);

	DPF(5,"Setting pClientInfo=0x%08x in nametable for player %d",pClientInfo,id);

	this->pNameTable[index].pvData = pClientInfo;

	return DP_OK;
} // SetClientInfo


#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientInfo"

HRESULT RemoveClientInfo(LPCLIENTINFO pClientInfo)
{
    HRESULT hr;
    BOOL fResult;

    hr = OS_DeleteSecurityContext(&(pClientInfo->hContext));
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's security context",hr);
    }

    fResult = OS_CryptDestroyKey(pClientInfo->hEncryptionKey);
    if (! fResult)
    {
        DPF_ERR("Failed to remove client's encryption key");
    }

    fResult = OS_CryptDestroyKey(pClientInfo->hDecryptionKey);
    if (! fResult)
    {
        DPF_ERR("Failed to remove client's decryption key");
    }

    fResult = OS_CryptDestroyKey(pClientInfo->hPublicKey);
    if (! fResult)
    {
        DPF_ERR("Failed to remove client's public key");
    }

    return DP_OK;
} // RemoveClientInfo

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientFromNameTable"
//+----------------------------------------------------------------------------
//
//  Function:   RemoveClientFromNameTable
//
//  Description:This function removes a player and the client info associated with 
//              it from the nametable.
//
//  Arguments:  this - pointer to dplay object
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER, or result from FreeNameTableEntry
//
//-----------------------------------------------------------------------------
HRESULT 
RemoveClientFromNameTable(
    LPDPLAYI_DPLAY this, 
    DPID dpID
    )
{
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    dwItem = NameFromID(this, dpID);
    if (!dwItem)
    {
        DPF(1, "Player %d doesn't exist", dpID);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(NAMETABLE_PENDING == dwItem);

    // 
    // Cleanup client info
    //
    pClientInfo = (LPCLIENTINFO) DataFromID(this,dpID);
    if (pClientInfo)
    {
        RemoveClientInfo(pClientInfo);
        // FreeNameTableEntry below will free up the memory
    }

    //
    // Remove client from name table
    //
    hr = FreeNameTableEntry(this, dpID);
    if (FAILED(hr))
    {
        DPF(0,"Couldn't remove client %d from name table: error [0x%8x]", dpID, hr);
        return hr;
    }

    //
    // Success
    //
    return DP_OK;
} // RemoveClientFromNameTable


#undef DPF_MODNAME
#define DPF_MODNAME	"PermitMessage"
//+----------------------------------------------------------------------------
//
//  Function:   PermitMessage
//
//  Description:This function verifies if a message is safe to process
//              when the session is secure.
//
//  Arguments:  dwCommand - message type
//              dwVersion - dplay version of the sender
// 
//  Returns:    TRUE if unsigned message is ok to process, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    )
{
    // don't allow any dx3 messages
    if (DPSP_MSG_DX3VERSION == dwVersion)
    {
        return FALSE;
    }

    // only allow the following messages through
    if ((dwCommand == DPSP_MSG_ENUMSESSIONS) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERID) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERREPLY) ||
         (dwCommand == DPSP_MSG_PLAYERWRAPPER) ||
         (dwCommand == DPSP_MSG_PLAYERMESSAGE) ||
         (dwCommand == DPSP_MSG_NEGOTIATE) ||
         (dwCommand == DPSP_MSG_CHALLENGE) ||
         (dwCommand == DPSP_MSG_AUTHERROR) ||        
         (dwCommand == DPSP_MSG_LOGONDENIED) ||        
         (dwCommand == DPSP_MSG_CHALLENGERESPONSE) ||
         (dwCommand == DPSP_MSG_SIGNED) ||
         (dwCommand == DPSP_MSG_PING) ||
         (dwCommand == DPSP_MSG_PINGREPLY))
    {
        return TRUE;
    }

    return FALSE;
} // PermitMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"GetMaxContextBufferSize"
//+----------------------------------------------------------------------------
//
//  Function:   GetMaxContextBufferSize
//
//  Description:This function returns the max buffer size used by the specified provider
//              for authentication tokens. First we try to get this information using
//              QuerySecurityPackageInfo() function. If it is not supported (NTLM on Win'95 Gold)
//              we query the information from a temporary context.
//
//  Arguments:  pSecDesc - pointer to security description
//              pulMaxContextBufferSize - pointer to max context buffer size 

// 
//  Returns:    DP_OK or sspi error
//
//-----------------------------------------------------------------------------
HRESULT GetMaxContextBufferSize(LPDPSECURITYDESC pSecDesc, ULONG *pulMaxContextBufferSize)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;
    SecBufferDesc outSecDesc;
    SecBuffer     outSecBuffer;
    LPBYTE pBuffer=NULL;
    ULONG     fContextAttrib=0;
    TimeStamp tsExpireTime;
    CtxtHandle hContext;
    CredHandle hCredential;
    HRESULT hr;
    DWORD dwMaxBufferSize=100*1024; // we are assuming that the max size will be atmost 100K
    DWORD dwCurBufferSize=0;

    ASSERT(pulMaxContextBufferSize);

    // try to get it in the normal way
    hr = OS_QueryContextBufferSize(pSecDesc->lpszSSPIProvider, pulMaxContextBufferSize);
    if (SUCCEEDED(hr))
    {
        DPF(6,"Got a max context buffer size of %d using QuerySecurityPackageInfo",*pulMaxContextBufferSize);
        return hr;
    }

	ZeroMemory(&hContext, sizeof(CtxtHandle));
	ZeroMemory(&hCredential, sizeof(CredHandle));

    // ok, looks like we need to try harder

    // acquire an outbound credential handle so we can create a temporary context
    // on both the server as well as the client
    status = OS_AcquireCredentialsHandle(
        NULL, 
        pSecDesc->lpszSSPIProvider,
        SECPKG_CRED_OUTBOUND,
        NULL,
        NULL,
        NULL,
        NULL,
        &hCredential,
        &tsExpireTime);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to get temporary credential handle: Error = 0x%08x",status);
		hr = status;
        goto CLEANUP_EXIT;
    }

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.BufferType = SECBUFFER_TOKEN;

    DPF_ERR("Trying to create a temporary security context");

    do 
    {
        dwCurBufferSize += 1024;    // increase the buffer size in 1K increments

        DPF(6,"Trying with context buffer size %d", dwCurBufferSize);

        pBuffer = DPMEM_ALLOC(dwCurBufferSize);
        if (!pBuffer)
        {
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }

        outSecBuffer.cbBuffer = dwCurBufferSize;
        outSecBuffer.pvBuffer = pBuffer;

        // create a temporary context so we can get the buffer sizes
        status = OS_InitializeSecurityContext(
            &hCredential,                           // phCredential
            NULL,                                   // phInContext
            NULL,                                   // pszTargetName
            DPLAY_SECURITY_CONTEXT_REQ,             // fContextReq
            0L,                                     // reserved1
            SECURITY_NATIVE_DREP,                   // TargetDataRep
            NULL,                                   // pInput
            0L,                                     // reserved2
            &hContext,                              // phNewContext
            &outSecDesc,                            // pOutput negotiate msg
            &fContextAttrib,                        // pfContextAttribute
            &tsExpireTime                           // ptsLifeTime
            );

        // get rid of the buffer
        DPMEM_FREE(pBuffer);

    } while ((SEC_E_INSUFFICIENT_MEMORY == status) && (dwCurBufferSize <= dwMaxBufferSize));

    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to create temporary security context: Error = 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    //
    // We have a security context, now query for the correct buffer size
    //
    ZeroMemory(&spContextSizes, sizeof(SecPkgContext_Sizes));

    status = OS_QueryContextAttributes(&hContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    *pulMaxContextBufferSize = spContextSizes.cbMaxToken;

    DPF(6,"Max context buffer size = %d", spContextSizes.cbMaxToken);

    // success
    hr = DP_OK;

CLEANUP_EXIT:
	OS_FreeCredentialHandle(&hCredential);
	OS_DeleteSecurityContext(&hContext);
    return hr;

} // GetMaxContextBufferSize

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMaxSignatureSize"
//+----------------------------------------------------------------------------
//
//  Function:   SetupMaxSignatureSize
//
//  Description:This function queries the security package for max signature size
//              and stores it in the dplay object.
//
//  Arguments:  this - dplay object
// 
//  Returns:    DP_OK or DPERR_GENERIC
//
//-----------------------------------------------------------------------------
HRESULT SetupMaxSignatureSize(LPDPLAYI_DPLAY this, PCtxtHandle phContext)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;

    memset(&spContextSizes, 0, sizeof(SecPkgContext_Sizes));

    //
    // query for the buffer sizes
    //
    status = OS_QueryContextAttributes(phContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        return status;
    }

    this->ulMaxSignatureSize = spContextSizes.cbMaxSignature;

    // success
    return DP_OK;
} // SetupMaxSignatureSize


#undef DPF_MODNAME
#define DPF_MODNAME	"SendAccessGrantedMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SendAccessGrantedMessage
//
//  Description:This function sends a signed access granted message to a client. 
//              We also piggy back the server's public key on this message.
//
//  Arguments:  this - dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT SendAccessGrantedMessage(LPDPLAYI_DPLAY this, DPID dpidTo, LPVOID pvSPHeader)
{
	LPMSG_ACCESSGRANTED pMsg=NULL;
	LPBYTE pSendBuffer=NULL;
	DWORD dwMessageSize;
	HRESULT hr;

    ASSERT(this->pSysPlayer);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ACCESSGRANTED) + this->dwPublicKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send access granted message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pMsg = (LPMSG_ACCESSGRANTED) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_ACCESSGRANTED);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_ACCESSGRANTED);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	
	// copy the public key data into the send buffer
	memcpy((LPBYTE)pMsg + sizeof(MSG_ACCESSGRANTED), this->pPublicKey, this->dwPublicKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize, 
		DPSEND_SIGNED|DPSEND_GUARANTEED,pvSPHeader);
	
	DPMEM_FREE(pSendBuffer);

	return hr;
} // SendAccessGrantedMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeysToServer"

HRESULT SendKeysToServer(LPDPLAYI_DPLAY this, HCRYPTKEY hServerPublicKey)
{
	LPMSG_KEYEXCHANGE pMsg=NULL;
	LPBYTE pSendBuffer=NULL, pEncryptionKey=NULL;
	DWORD dwMessageSize, dwEncryptionKeySize=0;
    BOOL fResult;
    DWORD dwError;
    HCRYPTKEY hEncryptionKey=0;
	HRESULT hr=DPERR_GENERIC;

    ASSERT(this->pSysPlayer);

	// create a new session key for encrypting messages to the server
	// and store its handle in the dplay object
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create encryption key: Error=0x%08x", dwError);
        }
		goto CLEANUP_EXIT;
	}

	// export client's encryption key 
	// note - pEncryptionKey will be filled after the call - we need to free it
	hr = ExportEncryptionKey(&hEncryptionKey, hServerPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + this->dwPublicKeySize + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send keys to server - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pMsg = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_KEYEXCHANGE);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_KEYEXCHANGE);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	pMsg->dwSessionKeyOffset = pMsg->dwPublicKeyOffset + pMsg->dwPublicKeySize;
	pMsg->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pMsg + pMsg->dwPublicKeyOffset, this->pPublicKey, this->dwPublicKeySize);
	memcpy((LPBYTE)pMsg + pMsg->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
			dwMessageSize,DPSEND_GUARANTEED,FALSE); 	
			
	if (FAILED(hr))
	{
		DPF_ERR("Message send failed");
		goto CLEANUP_EXIT;
	}

	// Success

    // remember our key
    this->hEncryptionKey = hEncryptionKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	// free the buffer allocated by ExportEncryptionKey()
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:	
	OS_CryptDestroyKey(hEncryptionKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeysToServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendKeyExchangeReply"

HRESULT SendKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg, DWORD dwMsgLen, DPID dpidTo,
	LPVOID pvSPHeader)
{
	HCRYPTKEY hClientPublicKey=0, hEncryptionKey=0, hDecryptionKey=0;
	LPBYTE pEncryptionKey=NULL;
	LPBYTE pSendBuffer=NULL;
	LPMSG_KEYEXCHANGE pReply=NULL;
	DWORD dwEncryptionKeySize, dwMessageSize;
    LPCLIENTINFO pClientInfo;
    BOOL fResult;
    DWORD dwError;
	HRESULT hr=DPERR_GENERIC;


	// SECURITY
	if(dwMsgLen < sizeof(MSG_KEYEXCHANGE) || pMsg->dwSessionKeyOffset > dwMsgLen || pMsg->dwPublicKeyOffset > dwMsgLen ||
		pMsg->dwPublicKeySize > dwMsgLen || pMsg->dwSessionKeySize > dwMsgLen || 
		pMsg->dwPublicKeySize + pMsg->dwSessionKeySize + sizeof(MSG_KEYEXCHANGE) > dwMsgLen ||
		pMsg->dwSessionKeyOffset < sizeof(MSG_KEYEXCHANGE) || pMsg->dwPublicKeyOffset < sizeof(MSG_KEYEXCHANGE)||
		pMsg->dwSessionKeyOffset + pMsg->dwSessionKeySize > dwMsgLen ||
		pMsg->dwPublicKeyOffset + pMsg->dwPublicKeySize > dwMsgLen )
	{
		DPF(1,"SECURITY WARN: sker invalid key exchange message received");
		return DPERR_GENERIC;
	}

    pClientInfo = (LPCLIENTINFO)DataFromID(this,dpidTo);
    if (!pClientInfo)
    {
        DPF_ERRVAL("No client info available for %d",dpidTo);
        return hr;
    }

	// import client's public key
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset,pMsg->dwPublicKeySize,&hClientPublicKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's public key\n");
		goto CLEANUP_EXIT;
	}

	// import client's encryption key (server will use this for decrypting client messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's encryption key\n");
		goto CLEANUP_EXIT;
	}


	// create a new session key for encrypting messages to this client
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create session key: Error=0x%08x", dwError);
        }
        goto CLEANUP_EXIT;
	}

	// export server's encryption key
	hr = ExportEncryptionKey(&hEncryptionKey, hClientPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// now send reply

	// message size + encryption key size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send session key to client - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pReply = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply,DPSP_MSG_KEYEXCHANGEREPLY);
	
	// only encryption key is sent - public key was already sent with access granted message
	pReply->dwSessionKeyOffset = sizeof(MSG_KEYEXCHANGE);
	pReply->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pReply + pReply->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize,
		DPSEND_SIGNED,pvSPHeader); 	
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	// success

	// remember the keys
    pClientInfo->hEncryptionKey = hEncryptionKey;
    pClientInfo->hDecryptionKey = hDecryptionKey;
	pClientInfo->hPublicKey     = hClientPublicKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hDecryptionKey);
	OS_CryptDestroyKey(hClientPublicKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeyExchangeReply


#undef DPF_MODNAME
#define DPF_MODNAME "ProcessKeyExchangeReply"

HRESULT ProcessKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg, DWORD dwMsgLen)
{
	HRESULT hr;
    HCRYPTKEY hDecryptionKey=0;

	// SECURITY validate KEYEXCHANGE message
	if(dwMsgLen < sizeof(MSG_KEYEXCHANGE) || pMsg->dwSessionKeyOffset > dwMsgLen || pMsg->dwPublicKeyOffset > dwMsgLen ||
		pMsg->dwPublicKeySize > dwMsgLen || pMsg->dwSessionKeySize > dwMsgLen || 
		pMsg->dwPublicKeySize + pMsg->dwSessionKeySize + sizeof(MSG_KEYEXCHANGE) > dwMsgLen ||
		pMsg->dwSessionKeyOffset < sizeof(MSG_KEYEXCHANGE) || (pMsg->dwPublicKeyOffset && pMsg->dwPublicKeyOffset < sizeof(MSG_KEYEXCHANGE))||
		pMsg->dwSessionKeyOffset + pMsg->dwSessionKeySize > dwMsgLen ||
		pMsg->dwPublicKeyOffset + pMsg->dwPublicKeySize > dwMsgLen )
	{
		DPF(1,"SECURITY WARN: pker invalid key exchange message received");
		return DPERR_GENERIC;
	}

	// import server's encryption key (client will use this for decrypting server messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import server's encryption key\n");
		goto CLEANUP_EXIT;
	}

	// we have successfully established session keys on either side. now we can start sending
	// encrypted messages.
    this->hDecryptionKey = hDecryptionKey;

	// success
	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hDecryptionKey);

	return hr;
} // ProcessKeyExchangeReply

#undef DPF_MODNAME
#define DPF_MODNAME "GetPublicKey"

HRESULT GetPublicKey(HCRYPTPROV hCSP, HCRYPTKEY *phPublicKey, LPBYTE *ppBuffer, LPDWORD pdwBufferSize)
{
    BOOL fResult;
    LPBYTE pPublicKeyBuffer=NULL;
    HCRYPTKEY hPublicKey=0;
    DWORD dwPublicKeySize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(hCSP);
    ASSERT(phPublicKey);
    ASSERT(ppBuffer);
    ASSERT(pdwBufferSize);

    // create a new public/private key pair
    fResult = OS_CryptGenKey(
        hCSP,                                   // handle to CSP
        AT_KEYEXCHANGE,                         // used for key exchange
        CRYPT_CREATE_SALT,                      // use a random salt value
        &hPublicKey                             // key handle
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to create public/private keys: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwPublicKeySize                        // size of the buffer
        );

    if (0 == dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // allocate buffer to hold the public key
    pPublicKeyBuffer = DPMEM_ALLOC(dwPublicKeySize);
    if (!pPublicKeyBuffer)
    {
        DPF_ERR("Failed to setup public key - out of memory");
        hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        pPublicKeyBuffer,                       // buffer to store the key
        &dwPublicKeySize                        // size of the data exported
        );

    if (!fResult || !dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // now return the correct info
    *phPublicKey = hPublicKey;
    *ppBuffer = pPublicKeyBuffer;
    *pdwBufferSize = dwPublicKeySize;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hPublicKey);
    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // GetPublicKey

#undef DPF_MODNAME
#define DPF_MODNAME "ExportEncryptionKey"

HRESULT ExportEncryptionKey(HCRYPTKEY *phEncryptionKey, HCRYPTKEY hDestUserPubKey, 
    LPBYTE *ppBuffer, LPDWORD pdwSize)
{
    BOOL fResult;
    LPBYTE pBuffer = NULL;
    DWORD dwSize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(phEncryptionKey);
    ASSERT(ppBuffer);
    ASSERT(pdwSize);

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to key being exported
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwSize                                 // size of the buffer
        );

    if (0 == dwSize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        return DPERR_GENERIC;
    }

    // allocate buffer
    pBuffer = DPMEM_ALLOC(dwSize);
    if (!pBuffer)
    {
        DPF_ERR("Failed to allocate memory for key");
        return DPERR_OUTOFMEMORY;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to the public key
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        pBuffer,                                // buffer to store key
        &dwSize                                 // size of the buffer
        );

    if (!fResult || !dwSize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // return the buffer and its size
    *ppBuffer = pBuffer;
    *pdwSize = dwSize;

	// don't free the encryption key buffer - caller will free it.

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
    if (pBuffer) DPMEM_FREE(pBuffer);
    return hr;

} // ExportEncryptionKey


#undef DPF_MODNAME
#define DPF_MODNAME "ImportKey"

HRESULT ImportKey(LPDPLAYI_DPLAY this, LPBYTE pBuffer, DWORD dwSize, HCRYPTKEY *phKey)
{
    BOOL fResult;
	HRESULT hr=DPERR_GENERIC;
	HCRYPTKEY hKey=0;

    ASSERT(pBuffer);
    ASSERT(phKey);

    fResult = OS_CryptImportKey(
        this->hCSP,         // handle to crypto service provider
        pBuffer,            // buffer containing exported key
        dwSize,             // size of buffer
        0,                  // sender's key
        0,                  // flags
        &hKey				// store handle the new key here
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to import key: Error=0x%08x",GetLastError());
		goto CLEANUP_EXIT;
    }

	*phKey = hKey;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hKey);

	return hr;

} // ImportKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpsecure.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.h
 *  Content:	DirectPlay security definitions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Removed definitions for buffer sizes and DPLAYI_SEALED struct.
 *  05/12/97    sohailm Added prototypes for CAPI (encryption/decryption) related functions.
 *  05/22/97    sohailm Added dplay key container name.
 *  06/09/97    sohailm Made NTLM the default security package instead of DPA.
 *  06/23/97    sohailm Added function prototypes related to signing support through CAPI.
 *  02/25/02    a-aogus Added SPMAXMESSAGELEN limit for verifying indication lengths.
 *
 ***************************************************************************/
#ifndef __DPSECURE_H__
#define __DPSECURE_H__

#include <windows.h>
#include <sspi.h>
#include "dpsecos.h" 

// a limit for accepting messages
#define SPMAXMESSAGELEN ((DWORD)( 1048576 - 1))

// 
// Definitions
//
#define DPLAY_DEFAULT_SECURITY_PACKAGE L"NTLM" // Default security package used by directplay
#define DPLAY_KEY_CONTAINER L"DPLAY"          // key container name for use with CAPI
#define DPLAY_SECURITY_CONTEXT_REQ (ISC_REQ_CONFIDENTIALITY | \
                                    ISC_REQ_USE_SESSION_KEY | \
                                    ISC_REQ_REPLAY_DETECT)

#define SSPI_CLIENT 0
#define SSPI_SERVER 1
#define DP_LOGIN_SCALE                  5     

#define SEALMESSAGE     Reserved3             // Entry which points to SealMessage
#define UNSEALMESSAGE   Reserved4             // Entry which points to UnsealMessage

//
//  Names of secruity DLL
//

#define SSP_NT_DLL          L"security.dll"
#define SSP_WIN95_DLL       L"secur32.dll"
#define SSP_SSPC_DLL        L"msapsspc.dll"
#define SSP_SSPS_DLL        L"msapssps.dll"
#define CAPI_DLL            L"advapi32.dll"

#define SEC_SUCCESS(Status) ((Status) >= 0)

// 
// Function Prototypes
//

// dpsecure.c
extern HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY
    );

extern HRESULT 
InitCAPI(
    void
    );

extern HINSTANCE
LoadSSPI (
    void
    );

extern HRESULT 
InitSSPI(
    void
    );

extern HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    );

extern HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    DWORD dwInMsgLen,
    ULONG fContextReq
    );

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    DWORD dwInMsgLen,
    LPVOID pvSPHeader
    );

extern HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
	);

extern HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	);

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    DWORD dwInMsgLen,
    LPVOID pvSPHeader
    );

extern HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    );

extern HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    );

extern HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pData, 
    LPDWORD pdwDataSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
EncryptBufferCAPI(
	LPDPLAYI_DPLAY this, 
    HCRYPTKEY *phEncryptionKey,
	LPBYTE pBuffer, 
	LPDWORD pdwBufferSize
	);

extern HRESULT 
DecryptMessageCAPI(
	LPDPLAYI_DPLAY this, 
	LPMSG_SECURE pSecureMsg
	);

extern HRESULT 
Login(
    LPDPLAYI_DPLAY this
    );

extern HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwCmd
    );

extern HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    );

extern HRESULT 
RemoveClientInfo(
    LPCLIENTINFO pClientInfo
    );

extern HRESULT 
RemoveClientFromNameTable(
   LPDPLAYI_DPLAY this, 
   DWORD dwID
   );

extern BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    );

extern HRESULT 
GetMaxContextBufferSize(
    LPDPSECURITYDESC pSecDesc,
    ULONG *pulMaxContextBufferSize
    );

extern HRESULT 
SetupMaxSignatureSize(
    LPDPLAYI_DPLAY this,
    PCtxtHandle phContext
    );

extern HRESULT 
SendAccessGrantedMessage(
    LPDPLAYI_DPLAY this, 
    DPID dpidTo,
	LPVOID pvSPHeader
    );


extern HRESULT 
SendKeysToServer(
	LPDPLAYI_DPLAY this, 
	HCRYPTKEY hServerPublicKey
	);

extern HRESULT 
SendKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg, 
	DWORD dwMsgLen,
	DPID dpidTo,
	LPVOID pvSPHeader
	);

extern HRESULT 
ProcessKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg,
	DWORD dwMsgLen
	);

extern HRESULT 
GetPublicKey(
    HCRYPTPROV hCSP, 
    HCRYPTKEY *phPublicKey, 
    LPBYTE *ppBuffer, 
    LPDWORD pdwBufferSize
    );

extern HRESULT 
ExportEncryptionKey(
    HCRYPTKEY *phEncryptionKey,
	HCRYPTKEY hDestUserPubKey, 
	LPBYTE *ppBuffer, 
	LPDWORD pdwSize
	);

extern HRESULT
ImportKey(
	LPDPLAYI_DPLAY this, 
	LPBYTE pBuffer, 
	DWORD dwSize, 
	HCRYPTKEY *phKey
	);

#endif // __DPSECURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpthread.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dpthread.c
*  Content:		dplay worker thread.  sends pings / enum sessions requests,
*				looks for dead players
*
*  History:
*   Date		By		Reason
*   ====		==		======
*	8/1/96		andyco	created it 
*	8/8/96		andyco	changed to call getdefaulttimeout
*	9/3/96		andyco	take an extra lock in killplayer	  
*	9/4/96		andyco	DON'T take extra locks - it's dangerous - 
*						don't need 'em
*	11/12/96	andyco	check if we're nameserver every time we go through
*						the player list.  and, when we delete someone,
*						restart at the beginning of the list.
* 	3/5/97		andyco	renamed from ping.c
*	5/23/97		kipo	Added support for return status codes
*	7/30/97		andyco	removed youaredead on getting ping from invalid player
*   8/4/97		andyco	dpthread watches add forward list on this ptr, watching
*						for add forward requests that haven't been fully ack'ed, 
*						and sending out the nametable to them.
*	1/28/98		sohailm	Added a minimum threshold to keep alive timeout.
*   2/13/98     aarono  Added flag to internal destroy player calls for async
*   4/6/98      aarono  changed killplayer to send player delete messages
*                       and do host migration if necessary.
*   5/08/98    a-peterz #22920 Reset Async EnumSession on failure and
*						always use ReturnStatus to prevent dialogs in thread
*   6/6/98      aarono  avoid protocol deadlock by sending pings async
*
***************************************************************************/

#include "dplaypr.h"
#include "..\protocol\arpstruc.h"
#include "..\protocol\arpdint.h"

// KEEPALIVE_SCALE * dwTimeout is how often we  ping
#define KEEPALIVE_SCALE 12

// reservation timeout scale
#define RESERVATION_TIMEOUT_SCALE	12

// how many consecutive unanswered pings before we nuke the player
#define UNANSWERED_PINGS_BEFORE_EXECUTION	8

// KILL_SCALE * dwTimeout is how long we wait before we nuke if we've got 
// < MINIMUM_PINGS.  Otherwise is the number of standard deviations
// off the mean that we wait before nuking
#define KILL_SCALE 25

#undef DPF_MODNAME
#define DPF_MODNAME	"... ping -- "

HRESULT SendPing(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerTo,BOOL bReply,
	DWORD dwTickCount)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_PING pPing;
	DWORD dwFlags;

	ASSERT(this->pSysPlayer);
	
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PING); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pPing = (LPMSG_PING)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pPing);

	if (bReply)
	{
		// we're sending them a ping reply
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PINGREPLY);
		// pass them back the tick count from the ping message
		// so they can figure latency
		pPing->dwTickCount = dwTickCount;
	}
	else 
	{
		// we're generating a ping request
		// store the tick count so we can compute latency when 
		// we get reply
		// Note, in sending case, we don't have dwTickCount is 
		// not passed in.
		ASSERT(dwTickCount==0);
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PING);
		pPing->dwTickCount = GetTickCount();
	}
	pPing->dwIDFrom = this->pSysPlayer->dwID;
   
    // send reply back to whoever sent ping
    if(this->pProtocol){
    	dwFlags = DPSEND_ASYNC|DPSEND_HIGHPRIORITY;
    } else {
    	dwFlags = 0;
    }

	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,dwFlags,FALSE);
	
	if (FAILED(hr) && (hr!=DPERR_PENDING))
	{
		DPF(5, "In SendPing, SendDPMessage returned %d", hr);
	}

	DPMEM_FREE(pSendBuffer);
	
	return hr;
	
} // SendPing

// when we get a ping from someone we don't recognize, we tell that someone
// to go away and leave us alone
HRESULT  SendYouAreDead(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_SYSMESSAGE pmsg;

	ASSERT(IAM_NAMESERVER(this));
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pmsg = (LPMSG_SYSMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_YOUAREDEAD);
	
	hr = DoReply(this,pSendBuffer,dwMessageSize,pvMessageHeader, 0);
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;
} // SendYouAreDead

// got a ping request or reply
HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	LPMSG_PING pPing = (LPMSG_PING)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayerFrom;
	BOOL bReply;
	HRESULT hr=DP_OK;
	DWORD dwCmd = GET_MESSAGE_COMMAND(pPing);
	
	bReply = (DPSP_MSG_PINGREPLY == dwCmd) ? TRUE : FALSE;
	
	pPlayerFrom = PlayerFromID(this,pPing->dwIDFrom);
    if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
    {
		DPF_ERR(" ACK !!! RECEIVED PING FROM INVALID (DEAD) PLAYER");
		if (IAM_NAMESERVER(this))
		{
			hr = SendYouAreDead(this,pReceiveBuffer,pvMessageHeader);
		}
		return DPERR_INVALIDPLAYER ;
    }

	if (bReply)
	{		
		// they are responding to our ping request
		DWORD dwTicks = abs(GetTickCount() - pPing->dwTickCount);
		if(dwTicks==0){
			dwTicks=5;	// resolution worst case 10ms, assume half if we can't observe.
		}
		pPlayerFrom->dwLatencyLastPing = (dwTicks/2)+1;
		DPF(4,"got ping reply from player id %d dwTicks = %d \n",pPlayerFrom->dwID,dwTicks);
		pPlayerFrom->dwUnansweredPings = 0;	// we're not really counting, just setting a threshold

	}
	else 
	{
		// they sent us a ping request
		hr = SendPing(this,pPlayerFrom,TRUE,pPing->dwTickCount);
		if (FAILED(hr))
		{
			DPF(7, "SendPing returned %d", hr);
		}
	} // reply
	
	return hr;
} // HandlePing


#undef DPF_MODNAME
#define DPF_MODNAME	"DirectPlay Worker Thread"

//
// called by KeepAliveThreadProc
// when we detect pSysPlayer is gone, we nuke him, and all of his local 
// players from the global name table
HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	DWORD dwIDSysPlayer; // cache this for after we destroy sysplayer

	ASSERT(pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);

	DPF(9,"->KillPlayer(0x%x,0x%x,%d)\n", this, pSysPlayer, fPropagate);
	DPF(1,"KillPlayer :: Killing system player id = %d\n",pSysPlayer->dwID);

	dwIDSysPlayer = pSysPlayer->dwID;
	
	// 1st destroy the sysplayer
	// we don't want to try to tell a dead sysplayer that one of their local players
	// is gone...
	DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pSysPlayer = 0x%x)\n", pSysPlayer);
	hr = InternalDestroyPlayer(this,pSysPlayer,fPropagate,TRUE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	// next, destroy any players created w/ that sysplayer
	pPlayer = this->pPlayers;

	// for the record, this code is horked, not to mention broken. 
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;

		DPF(9, "in KillPlayer, checking player %d\n", pPlayer->dwID); 
		if (pPlayer->dwIDSysPlayer == dwIDSysPlayer)
		{
			DPF(1,"in KillPlayer, Killing player id = %d\n",pPlayer->dwID);		
			// kill player
			if(!fPropagate){
				DPF(9,"Calling QDeleteAndDestroyMessagesForPlayer\n");
				QDeleteAndDestroyMessagesForPlayer(this, pPlayer);
			}
			
			DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pPlayer = 0x%x)\n", pPlayer);
			hr = InternalDestroyPlayer(this,pPlayer,fPropagate,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"InternalDestroyPlayer returned err: 0x%x\n", hr);
				ASSERT(FALSE);
			}
			
			// we deleted a player, so the list may be changed go back to beginning
			pPlayerNext=this->pPlayers; 
		} 
		
		pPlayer = pPlayerNext;
	}
	
	return DP_OK;
} // KillPlayer


// when we get a session lost, the handlesessionlost routine (handler.c)
// sets a flag telling the keep alive thread to delete all remote players
HRESULT DeleteRemotePlayers(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;

	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;
		 
		// if it's a remote player, make it go bye bye
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			hr = InternalDestroyPlayer(this,pPlayer,FALSE,TRUE);	
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayerNext;
	}

	// since we've killed all remote players, it's safe to turn 
	// of this flag (e.g. so new people could now join our game)
	this->dwFlags &= ~DPLAYI_DPLAY_SESSIONLOST;	
	return DP_OK;
	
} // DeleteRemotePlayers

// check the player list, looking for dead players, and sending pings
// if necessary
HRESULT DoPingThing(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	BOOL bNameServer,bCheck,bKill;
	BOOL bWeHaveCasualties = FALSE;

	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		return E_FAIL;
		
	if (!this->pSysPlayer)	
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
		
	pPlayer = this->pPlayers;

	while (pPlayer)
	{
		ASSERT(VALID_DPLAY_PLAYER(pPlayer));
		
		bNameServer = (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		pPlayerNext = pPlayer->pNextPlayer;
		
		if (bNameServer || this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		{
			bCheck = (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) 
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& !(pPlayer->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)) ? TRUE : FALSE;
		}
		else 
		{
			bCheck = (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		}

		if (bCheck)
		{
			BOOL	bProtocolHasChatter = FALSE;
			bKill = FALSE;			

			DPF(9, "in DoPingThing: Checking player %d\n", pPlayer->dwID);
			// a-josbor:  check chatter on the Protocol, if it's on
			if (this->pProtocol)
			{
				ASSERT(this->dwFlags & DPLAYI_DPLAY_PROTOCOL);
			}

			if (this->dwFlags & DPLAYI_DPLAY_PROTOCOL)
			{
				PSESSION     pSession = NULL;

				if (pPlayer)
				{
					pSession= GetSession((PPROTOCOL) this->pProtocol,pPlayer->dwID);

					if (pSession)
					{
						if ((pSession->RemoteBytesReceived != pPlayer->dwProtLastSendBytes) || 
							(pSession->LocalBytesReceived != pPlayer->dwProtLastRcvdBytes))
						{
							DPF(9,"Player %d not pinged because Protocol says there was traffic (%d in/%d out) since last\n",pPlayer->dwID,
								pSession->LocalBytesReceived - pPlayer->dwProtLastRcvdBytes,
								pSession->RemoteBytesReceived - pPlayer->dwProtLastSendBytes);
							pPlayer->dwProtLastSendBytes = pSession->RemoteBytesReceived;
							pPlayer->dwProtLastRcvdBytes = pSession->LocalBytesReceived;
							bProtocolHasChatter = TRUE;	
							pPlayer->dwUnansweredPings=0;
						}
						else
						{
							DPF(9,"Protocol says Player %d had no traffic\n",pPlayer->dwID);
						}
						
						DecSessionRef(pSession);	// release our reference to the session
					}
					else
					{
						DPF(7, "Unable to get Protocol Session ptr for Player %d!\n", pPlayer->dwID);
					}
				}
			}

			if (!bProtocolHasChatter) // if Protocol thinks the player hasn't sent or recvd, we should ping...
			{
				// a-josbor: Bug 15252- be more conservative about pinging.  Only do
				// 	it if we haven't heard from them since the last time we pinged
				if (pPlayer->dwChatterCount == 0)
				{
					DPF(9,"Player %d had %d unanswered pings\n", pPlayer->dwID, pPlayer->dwUnansweredPings);
					// no chatter has occurred since last time we pinged.
					bKill = (pPlayer->dwUnansweredPings >= UNANSWERED_PINGS_BEFORE_EXECUTION);

					if (bKill)
					{
						DPF(9,"Setting DEATHROW on %d because of unanswered pings!\n", pPlayer->dwID);
					
						// a-josbor: we can't kill them yet because it could
						// mess up our chatter count for other players.
						// we therefore just mark them for death, and run through
						// the list when we exit this loop
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
					else 
					{
						DPF(9, "Pinging player %d\n", pPlayer->dwID);
						hr = SendPing(this,pPlayer,FALSE,0);
						if (FAILED(hr)&&hr!=DPERR_PENDING)
						{
							DPF(4, "In DoPingThing, SendPing returned %d", hr);
						}
    					DPF(6,"Player %d pinged. (%d Unanswered)\n",pPlayer->dwID, pPlayer->dwUnansweredPings);
						pPlayer->dwUnansweredPings++;
					}
				}
				else	// chatter has occurred since last ping
				{
					DPF(9,"Player %d not pinged.  Chatter == %d\n",pPlayer->dwID, pPlayer->dwChatterCount);
					pPlayer->dwChatterCount = 0;
					pPlayer->dwUnansweredPings = 0;
				}
			}
		} // bCheck
		
		pPlayer = pPlayerNext;
	}

//	a-josbor: we didn't delete in the loop above, so do it here
	if (bWeHaveCasualties)  //	we now have to service any dead players.  
	{
//		go back through the whole list, looking for the victims
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			ASSERT(VALID_DPLAY_PLAYER(pPlayer));
			pPlayerNext = pPlayer->pNextPlayer;
			if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
			{
				DPF(9, "in DoPingThing: calling KillPlayer on %d\n", pPlayer->dwID);
				hr = KillPlayer(this,pPlayer,TRUE);
				if (FAILED(hr))
				{
					// if we had a problem killing them, unset the bit
					// so we don't keep trying
					pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
					ASSERT(FALSE);
				}
				// we deleted pPlayer, and all of its local players.
				// so - pNextPlayer could have been deleted.  to be safe, we restart at 
				// the beginning of the list
				pPlayerNext = this->pPlayers;
			}
			pPlayer = pPlayerNext;
		}
	}
	
	return DP_OK;
		
} // DoPingThings
							   
// figure out when to schedule next event, based on current time, last event,
// and event spacing.  (returns timeout in milliseconds suitable for passing
// to waitforsingleobject).
// called by GetDPlayThreadTimeout
DWORD GetEventTimeout(DWORD dwLastEvent,DWORD dwEventSpacing)
{
	DWORD dwCurrentTime = GetTickCount();
	
	// is it already over due?
	if ( (dwCurrentTime - dwLastEvent) > dwEventSpacing ) return 0;
	// else	return the event spacing relative to the current time
	return dwEventSpacing - (dwCurrentTime - dwLastEvent);
	
} // GetEventTimeout	

// figure out which timeout to use
DWORD GetDPlayThreadTimeout(LPDPLAYI_DPLAY this,DWORD dwKeepAliveTimeout)
{
	DWORD dwTimeout,dwAddForwardTime;
	LPADDFORWARDNODE pAddForward;
	
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
	{
		// is there an enum too?
		if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
		{
			DWORD dwKillEvent,dwEnumEvent;
			
			dwKillEvent = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
			dwEnumEvent = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
			
			dwTimeout = (dwKillEvent < dwEnumEvent) ? dwKillEvent : dwEnumEvent;
		}												
		else 
		{
			// only keep alive is running, use that
			dwTimeout = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
		}
	}
	else if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
	{
		// only enum is running, use that 
		dwTimeout = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
	}
	else if(this->dwZombieCount)
	{
		dwTimeout = dwKeepAliveTimeout;
	} 
	else
	{
		// hmmm, neither enum nor keepalive is happening.
		// we'll just go to sleep until something changes
		dwTimeout = INFINITE;
	}
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// see how long till we give up waiting for ack's on this node and just send
		// the nametable
		dwAddForwardTime = pAddForward->dwGiveUpTickCount - GetTickCount();
		// if that's smaller than our current timeout, then we have a winner
		if ( dwAddForwardTime < dwTimeout) dwTimeout = dwAddForwardTime;
		pAddForward = pAddForward->pNextNode;
	}

	return dwTimeout;
	
} // GetDPlayThreadTimeout

void CheckAddForwardList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	LPADDFORWARDNODE pAddForward,pAddForwardNext;
	HRESULT hr;
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// save next node now, in case FreeAddForwardNode blows it away
		pAddForwardNext = pAddForward->pNextNode;
		if (GetTickCount() > pAddForward->dwGiveUpTickCount)
		{
			// clear doesn't have nametable from requesting player.
			pPlayer=PlayerFromID(this, pAddForward->dwIDSysPlayer);
			if(pPlayer){
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
			}
			DPF(0,"giving up waiting for an add forward response - sending nametable to joining client!");
		    hr = NS_HandleEnumPlayers(this, pAddForward->pvSPHeader, pAddForward->dpidFrom,
				pAddForward->dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			
			hr = FreeAddForwardNode(this,pAddForward);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		pAddForward = pAddForwardNext;
	} 
	
} // CheckAddForwardList

//
// worker thread for dplay
// sleep for a while.  wake up and see 1.  if we need to send an enumsession request, 2. if we 
// need to send a ping and 3. if anyone has died
//
DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this)
{
    HRESULT hr;
	DWORD dwKeepAliveTimeout;
	DWORD dwTimeout; // smaller of enum / keep alive timeout
	DWORD dwCurrentTime;
				
#ifdef DEBUG
	// makes for nice startup spew...
	dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
	if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
		dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
	dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);
	DPF(1,"starting DirectPlay Worker Thread - initial timeout = %d\n",dwTimeout);
#endif // DEBUG

 	while (1)
 	{
		// grab the latest timeouts...
		dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
		if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
			dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
		dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);

		WaitForSingleObject(this->hDPlayThreadEvent,dwTimeout);

		ENTER_ALL();
		
		dwCurrentTime = GetTickCount();		
		DPF(9,"DPLAY Thread woke up at t=%d", dwCurrentTime);

		// are we closed? is 'this' bogus?
		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_ALL();
			goto ERROR_EXIT;
		}
		
		
		// session lost?				
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			// session was lost, we need to clean up
			hr = DeleteRemotePlayers(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// keep going
		}
		
		// time to send ping?
		if ((this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
			&& (dwCurrentTime - this->dwLastPing >= dwKeepAliveTimeout))
		{
			DoPingThing(this);
			this->dwLastPing = GetTickCount();
		}

		// if we have zombies, walk the player list looking for them
		if (this->dwZombieCount > 0)
		{
			LPDPLAYI_PLAYER pPlayer,pPlayerNext;
			BOOL 			bWeHaveCasualties = FALSE;
			BOOL			bFoundZombies = FALSE;
			
			DPF(9, "We have zombies!  Walking the player list...");
			
			dwCurrentTime = GetTickCount();
			
			pPlayer = this->pPlayers;
			while (pPlayer)
			{
				ASSERT(VALID_DPLAY_PLAYER(pPlayer));
				pPlayerNext = pPlayer->pNextPlayer;
				if ((pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST))
				{
					bFoundZombies = TRUE;
					if (pPlayer->dwTimeToDie < dwCurrentTime)
					{
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
				}			
				pPlayer = pPlayerNext;
			}

			// sanity
			if (!bFoundZombies)
				this->dwZombieCount = 0;
				
		//	a-josbor: we didn't delete in the loop above, so do it here
			if (bWeHaveCasualties)  //	we now have to service any dead players.  
			{
		//		go back through the whole list, looking for the victims
				pPlayer = this->pPlayers;
				while (pPlayer)
				{
					ASSERT(VALID_DPLAY_PLAYER(pPlayer));
					pPlayerNext = pPlayer->pNextPlayer;
					if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
					{
						DPF(3, "Killing Zombie player %d", pPlayer->dwID);
						hr = KillPlayer(this,pPlayer,TRUE);
						if (FAILED(hr))
						{
							// if we had a problem killing them, unset the bit
							// so we don't keep trying
							pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
							ASSERT(FALSE);
						}
						else
						{
							this->dwZombieCount--;
						}
						// we deleted pPlayer, and all of its local players.
						// so - pNextPlayer could have been deleted.  to be safe, we restart at 
						// the beginning of the list
						pPlayerNext = this->pPlayers;
					}
					pPlayer = pPlayerNext;
				}
			}

		}

		// time to send an enum?		
		dwCurrentTime = GetTickCount();
		if ((this->dwFlags & DPLAYI_DPLAY_ENUM) 
			&& (dwCurrentTime - this->dwLastEnum >= this->dwEnumTimeout))
		{
			// send enum request
			// Set bReturnStatus because we can't allow dialogs from this thread - no msg pump.
			hr = CallSPEnumSessions(this,this->pbAsyncEnumBuffer,this->dwEnumBufferSize,0, TRUE);
			if (FAILED(hr) && hr != DPERR_CONNECTING) 
			{
				DPF_ERRVAL("CallSPEnumSessions failed - hr = %08lx\n",hr);

				// No more async Enum's by this service thread until the app thread
				// restarts the process.  If the connection was lost, the SP can
				// dialogs from the app thread.

				// reset the flag
				this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
				// make sure we don't send an enum request when we wake up
				this->dwEnumTimeout = INFINITE;
				// free up the buffer
				DPMEM_FREE(this->pbAsyncEnumBuffer);
				this->pbAsyncEnumBuffer = NULL;
			}
			
			this->dwLastEnum = GetTickCount();	
		}
		
		// time to give up waiting for acks on an add forward, and just send the client the 
		// nametable?
		CheckAddForwardList(this);		

		// a-josbor: time to clear out the reservation count?
		if (IAM_NAMESERVER(this))
		{
			if (dwCurrentTime > this->dwLastReservationTime + 
					(GetDefaultTimeout(this, FALSE) * RESERVATION_TIMEOUT_SCALE))
			{
				this->dwPlayerReservations = 0;
				this->dwLastReservationTime = dwCurrentTime;
			}	
		}
		
		LEAVE_ALL();
	}	

ERROR_EXIT:
	DPF(1,"DPlay thread exiting");
	return 0;

}  // DPlayThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dpunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpunk.c
 *  Content:	IUnknown implementation for dplay
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	1/96	andyco	created it
 *	5/20	andyco	idirectplay2
 *	6/26/96	kipo	use the CALLSPVOID macro
 *	7/10/96	andyco	#2282 - addref addrefs int ref cnt, not obj ref cnt.  
 *					changed dp_close(this) to dp_close(this->pInterfaces...) DUH!
 *	7/16/96	kipo	include dplaysp.h so we declare our GUID once in dplay.dll
 *  8/9/96  sohailm free the sp when dplay goes away
 *	9/1/96	andyco	take service lock + drop dplay on sp_shutdown
 *  10/3/96 sohailm renamed GUID validation macros to use the term GUID instead of UUID
 *                  added a check for null lpGuid in QueryInterface parameter validation
 *	1/24/97	andyco	call freelibrary on the sp 
 *	3/12/97	myronth	added lobby object cleanup code
 *	3/15/97	andyco	destroy dplay b4 interface, so apps using the interface off a timer
 *					don't get hosed.
 *	5/13/97	myronth	Drop the locks before calling the lobby cleanup otherwise
 *					the dplay worker thread in the lower object can't take them
 *					and we hang.  (Bug #8414)
 *	8/19/97	myronth	Release copy of the lobby interface we were launched on
 *	10/21/97myronth	Added IDirectPlay4 and 4A interfaces to QI
 *  12/18/97 aarono Free memory pools
 *   2/18/98 aarono dispatch HandleMessage to protocol when active
 *   2/19/98 aarono don't call protocol for Shutdown, done in DP_Close now.
 *   3/16/98 aarono moved FreePacketList to Release from DP_Close
 *  8/02/99	rodtoll voice support - added Voice object to QueryInterface
 *  07/22/00 rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				 Now for a thread to make an indication into voice they addref the interface
 *					 so that the voice core can tell when all indications have returned.    
 ***************************************************************************/

#define INITGUID
#include "dplaypr.h"
#include "dplobby.h"	// Needed to get the DEFINE_GUID's to work
#include "dplaysp.h"	// Same here
#include "dpprot.h"
#include <initguid.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME "GetInterface"

// find an interface with the pCallbacks vtbl on this object.
// if one doesn't exist, create it
// ref count and return the interface
HRESULT GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks)
{
	LPDPLAYI_DPLAY_INT pCurrentInts = this->pInterfaces;
	BOOL bFound = FALSE;

	ASSERT(ppInt);

	// see if there is already an interface
	while (pCurrentInts && !bFound)
	{
		if (pCurrentInts->lpVtbl == pCallbacks)
		{
			bFound = TRUE;
		}
		else pCurrentInts = pCurrentInts->pNextInt;
	}
	// if there is, return it
	if (bFound)
	{
		*ppInt = pCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}
	// else, 
	// create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY_INT));
	if (!*ppInt) 
	{
		DPF_ERR("could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPlay = this;
	(*ppInt)->pNextInt = this->pInterfaces;
	(*ppInt)->lpVtbl = pCallbacks;
	this->pInterfaces = *ppInt;
	this->dwRefCnt++; // one this->dwRefCnt for each interface object...
	return DP_OK;
	
} // GetInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_QueryInterface"
HRESULT DPAPI DP_QueryInterface(LPDIRECTPLAY lpDP, REFIID riid, LPVOID * ppvObj) 
{
    
    LPDPLAYI_DPLAY this;
    HRESULT hr;

  	DPF(7,"Entering DP_QueryInterface");
	ENTER_DPLAY();
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to QI
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return hr;
			}
		}

		if ( !riid || (!VALID_READ_GUID_PTR(riid)) )
		{
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}
		
		if (!ppvObj || (!VALID_GUID_PTR(ppvObj)) )
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid object pointer");
			return DPERR_INVALIDPARAMS;
		}
		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlay) )
    {
		// get an idirectplay
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectPlay2) )
	{
		// get an idirectplay2
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay2A) )
	{
		// get an idirectplay2A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay3) )
	{
		// get an idirectplay3
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay3A) )
	{
		// get an idirectplay3A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay4) )
	{
		// get an idirectplay4
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay4A) )
	{
		// get an idirectplay4A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4A );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayVoiceTransport) )
	{
		hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj,
			(LPVOID)&dvtCallbacks );
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLAY();
    return hr;

}//DP_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_AddRef"
ULONG DPAPI DP_AddRef(LPDIRECTPLAY lpDP) 
{
	DWORD dwRefCnt;
    LPDPLAYI_DPLAY_INT pInt;

	DPF(7,"Entering DP_AddRef");

    ENTER_DPLAY();
    
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
            LEAVE_DPLAY();
            return 0;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    pInt->dwIntRefCnt++;
    dwRefCnt = pInt->dwIntRefCnt;

    LEAVE_DPLAY();
    return dwRefCnt;		

}//DP_AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Release"

// remove pInt from the list of interfaces, and the free it
HRESULT  DestroyDPlayInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT pInt) 
{
	LPDPLAYI_DPLAY_INT pIntPrev; // the interface preceeding pInt in the list
	BOOL bFound=FALSE;

	if (NULL == this->pInterfaces) return DP_OK;

	// remove pInt from the list of interfaces
	if (this->pInterfaces == pInt) 
	{
		// it's the 1st one, just remove it
		this->pInterfaces = pInt->pNextInt;
	}
	else 
	{
		pIntPrev = this->pInterfaces;
		while (pIntPrev && !bFound)
		{
			if (pIntPrev->pNextInt == pInt)
			{
				bFound = TRUE;
			}
			else pIntPrev = pIntPrev->pNextInt;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		pIntPrev->pNextInt = pInt->pNextInt;
		
	}

	DPMEM_FREE(pInt);

	return DP_OK;
} // DestroyDPlayInterface

// take this dplay object out of the list of dplay objects (gpObjectList)
HRESULT RemoveThisFromList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_DPLAY search,prev;
	
	ASSERT(gpObjectList); // better have at least this in list
	
	DPF(3,"removing this = 0x%08lx from object list", this);
	
	// is it the head?
	if (this == gpObjectList)
	{
		// remove from the front
		gpObjectList = gpObjectList->pNextObject;
		return DP_OK;
	}
	
	// else 
	prev = gpObjectList;
	search = gpObjectList->pNextObject;
	
	while ( (search) && (search != this))
	{
		prev = search;
		search = search->pNextObject;
	}

	if (search != this)
	{
		DPF_ERR("could not find this ptr in object list - badbadbad");
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	// else
	ASSERT(prev);	
	prev->pNextObject = this->pNextObject;

	return DP_OK;
	
} // RemoveThisFromList

// free the list of session nodes attached to this pointer
HRESULT FreeSessionList(LPDPLAYI_DPLAY this)
{
	LPSESSIONLIST pNext,pCurrent;

	pCurrent = this->pSessionList;
	while (pCurrent)
	{
		//
		// pCurrent is the current node to destroy
		// pNext is the next node in the list  - get it before we destroy pCurrent...
		//
		pNext = pCurrent->pNextSession;
		// 
		// now, destroy pCurrent
		//
		// free up the sp blob stored w/ the desc
		if (pCurrent->pvSPMessageData) DPMEM_FREE(pCurrent->pvSPMessageData);
		
        FreeDesc(&(pCurrent->dpDesc), FALSE);
		// free the session node
		DPMEM_FREE(pCurrent);
		// move onto next node
		pCurrent = pNext;
	}

	this->pSessionList = NULL;

	return DP_OK;
}// FreeSessionList

// Called from Release
HRESULT DestroyDPlay(LPDPLAYI_DPLAY this)
{
	HRESULT hr=DP_OK;
    DWORD dwError;

	if (this->lpsdDesc) // session open?
	{
		DPF(9,"Closing session %x this->dwFlags %x \n",this->lpsdDesc,this->dwFlags);
	   	// leave dplay, so if sp has threads waiting to get in, they can...
		LEAVE_ALL();

		hr=DP_Close((LPDIRECTPLAY)this->pInterfaces);

		ENTER_ALL();
	} else {
		DPF(0,"Closing with no open sessions\n");
	}

	if(hr==DP_OK){

		// Shutdown extended Timers
		FiniTimerWorkaround();

		// free up the session list
		FreeSessionList(this);
		
	   	// mark dplay as closed
		this->dwFlags |= DPLAYI_DPLAY_CLOSED;

		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// free any packets we're holding
		// drops and reacquires locks, shouldn't hurt here since we drop again.
		FreePacketList(this); 

		FiniReply(this);

		LEAVE_ALL();
		
		// kill the worker thread
		if(this->hDPlayThread){
			KillThread(this->hDPlayThread,this->hDPlayThreadEvent);
			this->hDPlayThread = 0;
			this->hDPlayThreadEvent = 0;
		}	

		ENTER_SERVICE();

	    if (this->pcbSPCallbacks->ShutdownEx)  
	    {
			DPSP_SHUTDOWNDATA shutdata;		
		
			shutdata.lpISP = this->pISP;
	   		hr = CALLSP(this->pcbSPCallbacks->ShutdownEx,&shutdata);
	    }
		else if (this->pcbSPCallbacks->Shutdown) 
		{
	   		hr = CALLSPVOID( this->pcbSPCallbacks->Shutdown );
		}
		else 
		{
			// shutdown is optional
			hr = DP_OK;
		}
	    
		ENTER_DPLAY();
		
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		if (this->dwFlags & DPLAYI_DPLAY_DX3SP)	
		{
			// if there's one loaded, this must be it -
			// since we're destroying the dx3 sp - reset our global flag
			gbDX3SP = FALSE;
		}
		
		// free the sp Data
		if (this->pvSPLocalData)	
		{
			DPMEM_FREE(this->pvSPLocalData);
			this->pvSPLocalData = NULL;
			this->dwSPLocalDataSize = 0;
		}

		// Free memory pools
		FreeMemoryPools(this);

		// free all interfaces
		while (this->pInterfaces)
		{
			hr = DestroyDPlayInterface(this,this->pInterfaces);	
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}
		}

		ASSERT(NULL == this->pInterfaces);

		// callbacks should be set in directplaycreate
		ASSERT(this->pcbSPCallbacks);
		DPMEM_FREE(this->pcbSPCallbacks);

	    // unload sp module
	    if (this->hSPModule)
	    {
	        if (!FreeLibrary(this->hSPModule))
	        {
	            ASSERT(FALSE);
				dwError = GetLastError();
				DPF_ERR("could not free sp module");
				DPF(0, "dwError = %d", dwError);
	        }
	    }
		
		if (this->pbAsyncEnumBuffer) DPMEM_FREE(this->pbAsyncEnumBuffer);
		// remove this from the dll object list
		RemoveThisFromList(this);
		gnObjects--;
		
		// just to be safe
		this->dwSize = 0xdeadbeef;

		// Drop the locks so that the lower dplay object in dpldplay can
		// get back in.  If we don't drop these, the worker thread in
		// dplay will hang trying to get these when it goes to shutdown
		LEAVE_ALL();
		
		// If we were lobby launched, release the interface we used to
		// communicate with the lobby server
		if(this->lpLaunchingLobbyObject)
		{
			IDirectPlayLobby_Release(this->lpLaunchingLobbyObject);
			this->lpLaunchingLobbyObject = NULL;	// just to be safe
		}

		// destroy the lobby object
		PRV_FreeAllLobbyObjects(this->lpLobbyObject);
		this->lpLobbyObject = NULL;		// just to be safe

		DeleteCriticalSection( &this->csNotify );			

		// Take the locks back
		ENTER_ALL();	
		
		DPMEM_FREE(this);	
		return DP_OK;
	}	else {
		DPF(0,"Someone called close after last release?\n");
		ASSERT(0);
		return DP_OK; // don't rock the boat.
	}
} // DestroyDPlay

ULONG DPAPI DP_Release(LPDIRECTPLAY lpDP)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_DPLAY_INT pInt;
    HRESULT hr=DP_OK;
	DWORD dwReleaseCnt=1;	// if we've been init'ed, we release at 1, otherwise we 
							// release at 0, unless it is a lobby-owned object in
							// which case we still release at 1
	ULONG rc;
								
	DPF(7,"Entering DP_Release");
	
	ENTER_ALL();    
	
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
			LEAVE_ALL();
            return 0;
		}
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to release
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_ALL();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return 0;
			}
			else 
			{
				// we were unitialized - no IDirectPlaySP to account for
				dwReleaseCnt = 0; 
			}
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return 0;
    }

	// dec the interface count
	rc=--pInt->dwIntRefCnt;
	if (0 == rc)
	{
		// since we've destroyed an interface, dec the object count
	    this->dwRefCnt--;
		
	    if (dwReleaseCnt == this->dwRefCnt) // destroy @ ref = 1, 1 for IDirectPlaySP
	    {
			// nuke the dplay object
			if (1 == dwReleaseCnt) DPF(1,"direct play object - ref cnt = 1 (1 for IDirectPlaySP)!");
			else DPF(1,"direct play object - ref cnt = 0 (SP not initialized)!");
			
			hr = DestroyDPlay(this);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    } // 0 == this->dwRefCnt
		else
		{
			// if we destroyed dplay, it nuked all interfaces for us
			// otherwise, we do it here
			DPF(1,"destroying interface - int ref cnt = 0");
			// take interface out of the table
			hr = DestroyDPlayInterface(this,pInt);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}

			// Destroy critical section for protecting voice interfaces
		}
		
		LEAVE_ALL();
		return 0;

	} //0 == pInt->dwIntRefCnt 
	   	
	LEAVE_ALL();
    return rc;
	
}//DP_Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dvretro.h ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:        dvretro.h
*  Content:	 	Retrofit functions
*  History:
*
*   Date		By		Reason
*   ====		==		======
*   08/05/99	rodtoll	created it
*   08/20/99	rodtoll	Updated for new out of process retrofit
*   09/09/99	rodtoll	Added new function prototype
*
***************************************************************************/

#ifndef __DVRETRO_H
#define __DVRETRO_H

#define DVMSGID_IAMVOICEHOST	0

typedef struct _DVPROTOCOLMSG_IAMVOICEHOST
{
	BYTE	bType;
	DPID	dpidHostID;
} DVPROTOCOLMSG_IAMVOICEHOST, *LPDVPROTOCOLMSG_IAMVOICEHOST;

extern HRESULT DV_Retro_Start( LPDPLAYI_DPLAY This );
extern HRESULT DV_Retro_Stop( LPDPLAYI_DPLAY This );
extern HRESULT DV_RunHelper( LPDPLAYI_DPLAY this, DPID dpidHost, BOOL fLocalHost );
extern HRESULT DV_GetIDS( LPDPLAYI_DPLAY This, DPID *lpdpidHost, DPID *lpdpidLocalID, LPBOOL lpfLocalHost );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "dplaypr.h"
#include "windows.h"
#include "fpm.h"

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = DPMEM_ALLOC(this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			DPMEM_FREE(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	ASSERT(0);

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			DPMEM_FREE(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		DPMEM_FREE(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		ASSERT(0);
	}
	DeleteCriticalSection(&this->cs);
	DPMEM_FREE(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)DPMEM_ALLOC(sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\enum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.c
 *  Content:	DirectPlay callbacks
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  1/96	andyco	created it
 *	3/1/96	andyco	added enum players + groups
 *	4/8/96	andyco	moved leave_dplay past callsp in enumsessions. now, only
 *					one thread at a time inside sp.
 *	5/16/96	andyco	dplay2 - internal xxx
 *	6/19/96	kipo	Bug #1960. DebugFillStringA() and DebugFillString()
 *					were not checking for NULL string parameters, which are
 *					allowed if you pass in NULL for the short or long names in
 *					a PlayerName structure.
 *					Bug #2047. Changed DP_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Bug #2013. CheckSessionDesc() was not checking for valid password
 *					pointers before doing string operations on the passwords.
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	andyco	added guid + password to enumsessions request
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   fixed up parameter ordering in callback function calls for
 *                  LPDPENUMPLAYERSCALLBACK2 and LPDPENUMSESSIONSCALLBACK2
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *  7/27/96 kipo	Bug #2682. InternalEnumPlayers() with the DPENUMPLAYERS_GROUP flag
 *					set was calling DP_EnumGroups() instead of InternalEnumGroups().
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *	8/6/96	andyco	version in commands.  extensible on the wire support.
 *	8/8/96	andyco	changed docallback to check enum flags (ENUM_LOCAL, etc.) and
 *					to check for sysplayers (moved from enumplayers).  changed
 *					internalenumxxx to check bResult from docallback.  bug 2874.
 *					modified getdefaulttimeout to be the method called by all dplay
 *					functions needing a timeout.  bug 2235,2329.
 *  8/21/96	andyco	check flags passed to enum. bug 3289
 *	8/22/96	andyco	oops.  reset dwflags when calling enumgroups from enumplayers.
 *  9/30/96 sohailm bug #3060: drop dplay lock(s) during enum callbacks
 *                  added CopySessionDesc2() and DoSessionCallbacks() functions
 *                  modified GetPlayerName() to get new strings for UNICODE instead of copying ptrs
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 * 10/12/96 sohailm renamed goto labels for consistency
 *                  added error checking to CopySessionDesc2()
 * 10/12/96	andyco 	don't enum sysgroup.
 * 	1/16/97 sohailm if flags are not specified to EnumSessions, now we return
 *                  only the available sessions (4491).
 *	1/15/97	andyco	added dperr_invalidgroup
 *	3/7/97	andyco	async enumsessions
 *	3/4/97	kipo	pulled nPlayers and nGroups into local variables instead of
 *					using the this pointer in InternalEnumGroups/Player/GroupPlayers
 *					so reentrancy when we drop the lock doesn't hose us.
 *	3/10/97	andyco	drop dplay + service locks b4 calling dp_close on enumplayers(session)
 *	3/12/97	myronth	lobby support for EnumSessions                  
 *	3/13/97	myronth	flagged unsupported lobby methods as such
 *  3/13/97 sohailm updated call to InternalOpenSession() to reflect changes in params.
 *	3/17/97	myronth	Removed check for lobby in EnumGroups/EnumPlayers
 *	3/20/97	myronth	Removed check for lobby in EnumGroupPlayers, use macro
 *  3/24/97 sohailm Updated DoSessionsCallback to skip filtering sessions on the client
 *                  if they are DX5 or greater
 *  3/27/97 sohailm Return an error, if players or groups in current session are enumerated
 *                  before opening the session (4973)
 *	4/2/97	myronth	EnumPlayers always returns DPERR_ACCESSDENIED for lobby connections
 *	4/7/97	myronth	EnumGroupPlayers now returns DPERR_ACESSDENIED for
 *					lobby connections with an idGroup of DPID_ALLPLAYERS, and
 *					also for EnumGroups and EnumGroupPlayers in remote sessions
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/06/97	kipo	Fixed stack save/restore for non-optimized builds
 *	5/8/97	andyco	Fixed fix stack save/restore
 *	5/18/97	kipo	Updated for new flags for EnumPlayer/Groups; do better filtering
 *					for players and groups in DoCallback().
 *	5/23/97	kipo	Added support for return status codes
 *	10/21/97myronth	Added support for hidden groups
 *	10/29/97myronth	Added support for owner flag on EnumGroupPlayers
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *  3/26/98 aarono  Fix InternalEnumGroupPlayers assumptions about when pPlayer
 *                  can become invalid.
 *  5/11/98 a-peterz Don't reenter async CallSPEnumSessions() (#22920)
 ***************************************************************************/

 // todo - docallback should pass copy of pvPlayerData
 // todo - do we use bContinue w/ EnumGroups / EnumPlayers?
#include "dplaypr.h"
#include <memalloc.h>

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Enum"

#ifdef DEBUG 
#define DEBUGFILLSTRINGA DebugFillStringA
#define DEBUGFILLSTRING DebugFillString
#else
#define DEBUGFILLSTRING(lpsz)
#define DEBUGFILLSTRINGA(lpsz)
#endif 

#ifdef DEBUG

void DebugFillStringA(LPSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;

	iStrLen = STRLEN(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillStringA

void DebugFillString(LPWSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;
	
	iStrLen = WSTRLEN_BYTES(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillString

#endif // DEBUG


// 
// fill in a playername struct for the player (or group).
// if ansi strings haven't been created yet for this player, create 'em!
// 
void GetPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName,BOOL fAnsi)
{
	memset(pName,0,sizeof(DPNAME));
	pName->dwSize = sizeof(DPNAME);

	if (fAnsi)
	{
	    GetAnsiString(&(pName->lpszShortNameA),pPlayer->lpszShortName);
		GetAnsiString(&(pName->lpszLongNameA),pPlayer->lpszLongName);
	}
	else 
	{
		GetString(&(pName->lpszShortName), pPlayer->lpszShortName);
		GetString(&(pName->lpszLongName), pPlayer->lpszLongName);
	}

	return ;
} // GetPlayerName

BOOL GetCallbackFlags(LPDPLAYI_PLAYER pPlayer, DWORD dwFlags,
					  LPDWORD lpdwCallbackFlags)
{
	DWORD	dwCallbackFlags;

	//
	// first determine if this player matches the filter criteria
	//

	// never enum system players
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		return (FALSE);
	}
	
	// they want local players
	if (dwFlags & DPENUMPLAYERS_LOCAL)
	{
		// not a local player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			return (FALSE);
		}
	}
	
	// they want remote players
	if (dwFlags & DPENUMPLAYERS_REMOTE)
	{
		// not a remote player
		if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			return (FALSE);
		}
	}
	
	// they want server players
	if (dwFlags & DPENUMPLAYERS_SERVERPLAYER)
	{
		// not a server player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))
		{
			return (FALSE);
		}
	}

	// they want spectators
	if (dwFlags & DPENUMPLAYERS_SPECTATOR)
	{
		// not a spectator
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR))
		{
			return (FALSE);
		}
	}

	// they want the group owner
	if (dwFlags & DPENUMPLAYERS_OWNER)
	{
		// not the group owner
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_OWNER))
		{
			return (FALSE);
		}
	}

	// they want staging areas
	if (dwFlags & DPENUMGROUPS_STAGINGAREA)
	{
		// not a staging area
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			return (FALSE);
		}
	}

	// they want hidden groups
	if (dwFlags & DPENUMGROUPS_HIDDEN)
	{
		// not a hidden group
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			return (FALSE);
		}
	}

	//
	// now build the flags to be passed to the callback
	//

	// flags start out set to the flags passed to Enum_xxx
	dwCallbackFlags = dwFlags;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
		dwCallbackFlags |= DPENUMPLAYERS_SERVERPLAYER;

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
		dwCallbackFlags |= DPENUMPLAYERS_SPECTATOR;

	// player is the group owner
	if (pPlayer->dwFlags & DPLAYI_PLAYER_OWNER)
		dwCallbackFlags |= DPENUMPLAYERS_OWNER;

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
		dwCallbackFlags |= DPENUMGROUPS_STAGINGAREA;

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
		dwCallbackFlags |= DPENUMGROUPS_HIDDEN;

	// return the flags to pass to the callback
	*lpdwCallbackFlags = dwCallbackFlags;
	return (TRUE);
}

/*
 ** DoCallback
 *
 *  CALLED BY:	InternalEnumPlayers,InternalEnumGroups,InternalEnumGroupPlayers
 *
 *  PARAMETERS:
 *			pPlayerOrGroup - a LPDPLAYI_GROUP or LPDPLAYI_PLAYER struct.
 *			dwFlags - flags passed to enum
 *			pvContext - app supplied context
 *			lpEnumCallback - callback fn, either LPDPENUMPLAYERSCALLBACK or
 *				LPDPENUMPLAYERSCALLBACK2.
 *			dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *				indicates what type of callback fn we have (which interface 
 *				we were called from).
 *			fPlayer - whether pPlayerOrGroup is a player (TRUE) or a group.
 *
 *  DESCRIPTION:
 *			figures out what type of callback we're calling. sets up the 
 *			data structs, and calls it.
 *
 *  RETURNS:
 *			BOOL - the result of the callback.
 *
 */
BOOL DoCallback(LPDPLAYI_PLAYER pPlayer,DWORD dwFlags,LPVOID pvContext,
	LPVOID lpEnumCallback,DWORD dwEnumFlags,BOOL fPlayer)
{
	HRESULT hr = DP_OK;
	BOOL bResult;
	DWORD dwCallbackFlags;

	// get flags to pass to callback. If this fails we don't
	// need to do the callback for this player
	if (!GetCallbackFlags(pPlayer, dwFlags, &dwCallbackFlags))
	{
		// don't need to call the calback
		return TRUE;
	}
	
	switch (dwEnumFlags)
	{
		case ENUM_1:
		{
			// a dplay 10 callback
			// just get the strings and call
			LPSTR lpszShortName=NULL,lpszLongName=NULL;
            DPID idPlayer;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetAnsiString(&(lpszShortName),pPlayer->lpszShortName);
			GetAnsiString(&(lpszLongName),pPlayer->lpszLongName);

            // drop the locks 
			LEAVE_ALL();

            // call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK)lpEnumCallback)(idPlayer,lpszShortName,
					lpszLongName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			DEBUGFILLSTRINGA(lpszShortName);
			DEBUGFILLSTRINGA(lpszLongName);

			if (lpszShortName) DPMEM_FREE(lpszShortName);
			if (lpszLongName) DPMEM_FREE(lpszLongName);
			
			// we're done here...
			return bResult;
		}
		
		case ENUM_2:
		case ENUM_2A:
        {
        	DPNAME PlayerName;
	        BOOL fAnsi;
            DPID idPlayer;

			// need to get a player (or group) data 
			fAnsi = (ENUM_2A == dwEnumFlags) ? TRUE : FALSE;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetPlayerName(pPlayer,&PlayerName,fAnsi);

            // drop the locks
			LEAVE_ALL();

			// call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK2)lpEnumCallback)(idPlayer,fPlayer,
				&PlayerName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			// free the strings
			if (PlayerName.lpszShortNameA) DPMEM_FREE(PlayerName.lpszShortNameA);
			if (PlayerName.lpszLongNameA) DPMEM_FREE(PlayerName.lpszLongNameA);

			break;
        }

		default:
			bResult=FALSE; // never happens, but lets make prefix happy.
			ASSERT(FALSE);
			break;
	}
	
	return bResult;

} //DoCallback

/*
 ** EnumJoinSession
 *
 *  CALLED BY: InternalEnumPlayers,InternalEnumGroups
 *
 *  PARAMETERS:
 *			this - this ptr
 *			pGuid - instance guid of session to join
 *
 *  DESCRIPTION:
 *			finds a session, calls open on it.
 * 			called before enuming w/ DPENUMPLAYERS_SESSION
 * 			while we're trying to enum the players in a different session
 * 					*** ASSUMES SERVICE LOCK + DPLAY LOCK TAKEN ***
 * 			 		*** ASSUMES DPLAY LOCK COUNT IS @ 1 ***
 *
 *  RETURNS:   OpenSession hr, or  DPERR_NOSESSIONS if no matching
 *			session is available
 *
 */
HRESULT EnumJoinSession(LPDPLAYI_DPLAY this,LPGUID pGuid)
{
	LPSESSIONLIST pSession;
	HRESULT hr=DP_OK;

	if (this->lpsdDesc) 
	{
		DPF_ERR("DPENUMPLAYERS_SESSION flag set when session already open!");
		return E_FAIL;
	}

	pSession = FindSessionInSessionList(this,pGuid);	
	if (!pSession) 
	{
		DPF_ERR("could not find matching session to open");
		return DPERR_NOSESSIONS;
	}

	hr = InternalOpenSession(this,&(pSession->dpDesc),TRUE,DPOPEN_JOIN,FALSE,NULL,NULL);

	if (FAILED(hr)) 
	{	
		DPF(0,"enum sessions - could not open session - hr = 0x%08lx\n",hr);
		return hr;
	}

	return DP_OK;
}  // EnumJoinSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupsInGroup"

// struct used to store group id's + flags while we drop locks
typedef struct 
{
	DPID 	id;
	DWORD	dwFlags;
} DPIDANDFLAGS,*LPDPIDANDFLAGS;

HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bResult=TRUE;
    LPDPIDANDFLAGS pIDArray;
	DWORD nSubgroups;
	LPDPLAYI_GROUP pGroupEnum; // group passed to docallback
    UINT i;
	DWORD dwCallbackFlags; // flags we pass to callback
	
	DPF(5,"got enum GroupsInGroups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pSubgroups || (0 == pGroup->nSubgroups))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nSubgroups * sizeof(DPIDANDFLAGS));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pSubgroup = pGroup->pSubgroups;
	nSubgroups = pGroup->nSubgroups;
    for (i=0; i < nSubgroups; i++)
    {
        ASSERT(pSubgroup);
        pIDArray[i].id = pSubgroup->pGroup->dwID;
		pIDArray[i].dwFlags = pSubgroup->dwFlags; // e.g.  DPGROUP_SHORTCUT
        pSubgroup = pSubgroup->pNextSubgroup;
    }

    // walk through the group calling by player
    for (i=0; (i < nSubgroups ) && bResult; i++)
    {        
        pGroupEnum = GroupFromID(this, pIDArray[i].id);
        // player could have been deleted while we dropped the locks
        if (VALID_DPLAY_GROUP(pGroupEnum))
        {
			// they want shortcuts
			if (dwFlags & DPENUMGROUPS_SHORTCUT)
			{
				// this is not a shortcut, so skip calling them back
				if (!(pIDArray[i].dwFlags & DPGROUP_SHORTCUT))
					continue;
			}

			// start with flags passed in
			dwCallbackFlags = dwFlags;

			// set shortcuts flag
			if (pIDArray[i].dwFlags & DPGROUP_SHORTCUT)
				dwCallbackFlags |= DPENUMGROUPS_SHORTCUT;

			bResult = DoCallback((LPDPLAYI_PLAYER)pGroupEnum, dwCallbackFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();		
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

} // InternalEnumGroupsInGroup

HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupPlayers"

HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    LPDPLAYI_PLAYER pPlayer;
    UINT i;
	DPID dwGroupOwnerID;
	
	DPF(5,"got enum groupplayerss ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pGroupnodes || (0 == pGroup->nPlayers))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pGroupnode = pGroup->pGroupnodes;
	nPlayers = pGroup->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pGroupnode);
        pIDArray[i] = pGroupnode->pPlayer->dwID;
        pGroupnode=pGroupnode->pNextGroupnode;
    }

	// we snapshot the owner here, because it could go away during the callbacks.
	dwGroupOwnerID = pGroup->dwOwnerID;

    // walk through the group calling by player
    for (i=0; (i < nPlayers ) && bResult; i++)
    {        
		// player could have been deleted while we dropped the locks
        pPlayer = PlayerFromID(this, pIDArray[i]);

		if(pPlayer){

			// We need to see if this player is the group's owner, if it is,
			// temporarily set the internal owner flag so the external one
			// gets set correctly in the callback
			if(pPlayer->dwID == dwGroupOwnerID)
				pPlayer->dwFlags |= DPLAYI_PLAYER_OWNER;
			
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
				                    dwEnumFlags,TRUE);

			// need to reacquire the pointer since we dropped the locks on callback.
			pPlayer = PlayerFromID(this, pIDArray[i]);
			if(pPlayer){
				// Clear the temporary owner flag (which will never be set
				// unless we did it above)
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_OWNER);
			}	
		}
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//DP_EnumGroupPlayers

HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();	
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroups"
HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nGroups;
    UINT i;
	
	DPF(5,"got enum groups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		// EnumGroups in a remote session is not allowed for lobby connections
		if((IS_LOBBY_OWNED(this)) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating groups in a remote lobby session is not supported");
			return DPERR_ACCESSDENIED;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// do we need to open a session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate groups in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }
	
	// how many top-level groups}
	nGroups =0;
	pGroup = this->pGroups;
	while (pGroup)
	{
		if (0 == pGroup->dwIDParent) nGroups++;
		pGroup = pGroup->pNextGroup;
	}
	
    // are there any groups to enumerate ?
    if (0 == nGroups)
    {
        // no groups
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for the array of group ids
    pIDArray = DPMEM_ALLOC(nGroups * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current group ids
    pGroup = this->pGroups;
	i = 0;
	while (pGroup && (i < nGroups))
	{
        if (0 == pGroup->dwIDParent) 
        {
        	pIDArray[i] = pGroup->dwID;
			i++;
        }
        pGroup=pGroup->pNextGroup;
    }

    // call user for every valid group
    for (i=0; (i < nGroups) && bResult; i++)
    {        
        pGroup = GroupFromID(this, pIDArray[i]);
        // group could have been deleted while we dropped the locks
        if (pGroup && !(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
        {
		    bResult = DoCallback((LPDPLAYI_PLAYER)pGroup, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through

CLEANUP_EXIT:

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//InternalEnumGroups


HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();

	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();
	
	return hr;

}  // DP_EnumGroups

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumPlayers"
HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    UINT i;
		
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		// This call should always return DPERR_ACCESSDENIED for
		// lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("EnumPlayers is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate players in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }

    // any players to enumerate ?
    if (!this->pPlayers || (0==this->lpsdDesc->dwCurrentPlayers))
    {
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(this->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pPlayer = this->pPlayers;
	nPlayers = this->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pPlayer);
        pIDArray[i] = pPlayer->dwID;
        pPlayer=pPlayer->pNextPlayer;
    }

    // iterate over the player id array, calling the app for every valid player
    for (i=0; (i < nPlayers) && bResult; i++)
    {        
        pPlayer = PlayerFromID(this, pIDArray[i]);
        // player could have been deleted while we dropped the locks
        if (pPlayer)
        {
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,TRUE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

	if (dwFlags & DPENUMPLAYERS_GROUP) 
	{
		DWORD dwStrippedFlags; // flags to pass to internalenumgroups
	
		// reset flags - DPENUMPLAYERS_GROUP, DPENUMPLAYERS_SERVERPLAYER, DPENUMPLAYERS_SPECTATOR
		// is illegal to pass to InternalEnumGroups, and if DPENUMPLAYERS_SESSION is set,
		// we've already joined the session
		dwStrippedFlags = dwFlags & ~(DPENUMPLAYERS_GROUP |
									  DPENUMPLAYERS_SESSION |
									  DPENUMPLAYERS_SERVERPLAYER |
									  DPENUMPLAYERS_SPECTATOR);
		hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,
			dwStrippedFlags, dwEnumFlags);
	}

    // fall through
CLEANUP_EXIT:

	if (DPENUMPLAYERS_SESSION & dwFlags )  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;
        
}//InternalEnumPlayers


HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();

	return hr;

}//DP_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumSessions"
// make sure the user desc, and the desc found by enum, match 
// if fEnumAll is set, don't check passwords or player counts
HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi)
{
	int iStrLen;

	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidApplication),&(lpsdSession->guidApplication))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password if the session has one
	if (lpsdSession->lpszPassword)
	{
		iStrLen = fAnsi ? STRLEN(lpsdSession->lpszPasswordA) : 
						  WSTRLEN(lpsdSession->lpszPassword);
		if (iStrLen)
		{
			int iCmp;

			if (lpsdUser->lpszPassword)	// make sure there is a password
			{
				iCmp = fAnsi ? strcmp(lpsdSession->lpszPasswordA,lpsdUser->lpszPasswordA) :
							   WSTRCMP(lpsdSession->lpszPassword,lpsdUser->lpszPassword);
				if (0 != iCmp) return E_FAIL;
			}
			else
				return E_FAIL;			// no password in description, so bail
		}
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;

	
	return DP_OK;
} // CheckSessionDesc

// called by InternalEnumSessions, KeepAliveThreadProc, GetNameTable 
// and GetNewPlayerID.  Calls GetCaps get the latency.
// tries for guaranteed, falls back to unreliable or default as necessary.
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed)
{
	DPCAPS caps;
	HRESULT hr;

	memset(&caps,0,sizeof(caps));
	caps.dwSize = sizeof(caps);

	if (fGuaranteed)
	{
		// call idirectplay::getcaps.  see what it has to say...
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
		if (SUCCEEDED(hr))
		{
			if (caps.dwTimeout) return caps.dwTimeout;
			// else 
			goto RETURN_DEFAULT; 
		}
		// else, fall through and try not guaranteed		
	}

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return DP_DEFAULT_TIMEOUT;
	}
	
	if (caps.dwTimeout){
		if(caps.dwTimeout >= 1000) {
			return caps.dwTimeout;
		} else {
			return 1000;
		}	
	}	

	// else 
RETURN_DEFAULT:

	// they returned success, but didn't set the caps
	DPF(0,"error - SP not returning valid timeout. Using DPlay default = %d\n",DP_DEFAULT_TIMEOUT);
	return DP_DEFAULT_TIMEOUT;

} // GetDefaultTimeout

// called by internalenumsessions, and by dplaythreadproc
HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus)
{
	DPSP_ENUMSESSIONSDATA ed;
	HRESULT hr;
	   
	if (!this->pcbSPCallbacks->EnumSessions) 
	{
		DPF_ERR("SP NOT IMPLEMENTING REQUIRED ENUMSESSIONS ENTRY");
		ASSERT(FALSE);
		return E_NOTIMPL;
	}
   
   	ASSERT(pBuffer);
	
   	ed.lpMessage = pBuffer;
	ed.dwMessageSize = dwMessageSize;
	ed.lpISP = this->pISP;
	ed.bReturnStatus = bReturnStatus;
	hr = CALLSP(this->pcbSPCallbacks->EnumSessions,&ed); 
	if (FAILED(hr)) 
	{
		if (hr != DPERR_CONNECTING)
			DPF(0,"enum failed - hr = %08lx\n",hr);
		return hr;
	}

	if (!dwTimeout) return DP_OK; // all done
	
	// we leave dplay so that the sp can get inside dp (in handler.c) w/
	// any responses    
	
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	
	LEAVE_DPLAY();
	Sleep(dwTimeout);
	ENTER_DPLAY();
	
	return DP_OK;
	
} // CallSPEnumSessions
	
HRESULT StopEnumThread(LPDPLAYI_DPLAY this)
{
	if (!(this->dwFlags & DPLAYI_DPLAY_ENUM))
	{
		DPF_ERR("COULD NOT STOP ASYNC ENUM - IT'S NOT RUNNING");
		return E_FAIL;
	}
	
	// stop the async thread.
	// mark dplay as being not enum'ing
	this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
	// make sure it doesn't send an enum request when we wake it up
	this->dwEnumTimeout = INFINITE;
	
	// free up the buffer
	ASSERT(this->pbAsyncEnumBuffer);
	DPMEM_FREE(this->pbAsyncEnumBuffer);
	this->pbAsyncEnumBuffer = NULL;

	// set the worker threads event, so it picks up the new timeout
	SetEvent(this->hDPlayThreadEvent);

	// we're done
	return DP_OK;

}  // StopEnumThread	

/*
 ** InternalEnumSessions
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: lpDP - idirectplay(2,2a) interface pointer
 *				lpsdDesc - session desc - validated only
 *				dwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *				dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *					indicates what type of session desc we have
 *
 *  DESCRIPTION:  calls service provider for enum sessions, and waits for responses
 *					*** ASSUMES SERVICE + DPLAY LOCKS TAKEN ***
 *					*** ASSUMES DPLAY LOCK COUNT IS AT 1 ***
 *
 *  RETURNS: E_OUTOFMEMORY, or SP hresult from sp_enumsessions
 *
 */
HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    BOOL bContinue=TRUE;
	LPBYTE pBuffer; // buffer we're going to send
    LPMSG_ENUMSESSIONS pmsg; // cast from pBuffer
	DWORD dwMessageSize;
	UINT nPasswordLen; // password length, in bytes
	BOOL bReturnStatus; // true to override dialogs and return status

	DPF(9, "InternalEnumSessions: Parameters(0x%p, 0x%p, %u, 0x%p, 0x%x)",
		lpDP, lpsdDesc, dwTimeout, lpEnumCallback, dwFlags);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
		{
		    DPF_ERR( "Invalid session description" );
		    return DPERR_INVALIDPARAMS;
		}
		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		// check callback
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALID_ENUMSESSIONS_FLAGS(dwFlags))
		{
		    DPF_ERR( "Invalid flags" );
		    return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// note - andyco - we may want to lift this restriction...
	if (this->lpsdDesc)
	{
		DPF_ERR("can't enum sessions - session already open");
		return E_FAIL;
	}

	if ( !(dwFlags & (DPENUMSESSIONS_NOREFRESH | DPENUMSESSIONS_ASYNC)) ) 
	{
		FreeSessionList(this);		
	}

	// if this is a lobby-owned object, call the lobby code
	if(IS_LOBBY_OWNED(this))
	{
		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// REVIEW!!!! -- Is there a way we can keep from having to drop the lock
		// here??? What are the ramifications of doing so???  Can we potentially
		// cause a crash when the user comes back in???

		// We need to drop the lock for the lobby since it may call
		// EnumSessions on another DPlay object (like dpldplay does).
		LEAVE_DPLAY();
		hr = PRV_EnumSessions(this->lpLobbyObject, lpsdDesc, dwTimeout, dwFlags);
		ENTER_DPLAY();
		DPF(9, "InternalEnumSessions: Return [0x%lx] (lobby owned)", hr);
		return hr;
	}

	// if app wants async, and our async thread is already running, we're done
	if  ( (dwFlags & DPENUMSESSIONS_ASYNC ) && (this->dwFlags & DPLAYI_DPLAY_ENUM) )
	{
		// we'll let whatever interface they called on just walk the list
		DPF(9, "InternalEnumSessions: Return [DP_OK] (async enum running)");
		return DP_OK;
	}
	
	if (dwFlags & DPENUMSESSIONS_STOPASYNC)
	{
		hr = StopEnumThread(this);
		DPF(9, "InternalEnumSessions: Return [0x%lx] (stop async)", hr);
		return hr;
	}
	
	// Are we already in a call to the SP's EnumSession?
	if  (this->dwFlags & DPLAYI_DPLAY_ENUMACTIVE)
	{
		// App must be doing async and SP may have a connection dialog up
		DPF(9, "InternalEnumSessions: Return [DPERR_CONNECTING] (enum active)");
		return DPERR_CONNECTING;
	}
	
	nPasswordLen = WSTRLEN_BYTES(lpsdDesc->lpszPassword);
													
	// message size + blob size + password size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONS);
	dwMessageSize += nPasswordLen;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_ENUMSESSIONS)(pBuffer + this->dwSPHeaderSize);
	// set up msg
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ENUMSESSIONS);
	pmsg->guidApplication = lpsdDesc->guidApplication;
    pmsg->dwFlags = dwFlags;
	
	if (nPasswordLen)
	{
		pmsg->dwPasswordOffset = sizeof(MSG_ENUMSESSIONS);
		// copy over password
		memcpy((LPBYTE)pmsg+sizeof(MSG_ENUMSESSIONS),lpsdDesc->lpszPassword,nPasswordLen);
	} 
	else
	{
		pmsg->dwPasswordOffset = 0;
	}

	// if the app doesn't want to guess on a timeout, we'll "do
	// the right thing"
	if (0 == dwTimeout) dwTimeout = GetDefaultTimeout(this,TRUE);

	// app can request that the SP not display any status
	// dialogs while enumerating by setting this flag. The SP
	// will return status codes while enumeration is in progress

	bReturnStatus = (dwFlags & DPENUMSESSIONS_RETURNSTATUS) ? TRUE : FALSE; 

	// if it's an async all, startup the async thread
	if (dwFlags & DPENUMSESSIONS_ASYNC)
	{
		// it's async
		// call the sp, so it can do its dialog thing syncro, but don't block waiting
		// on replies
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,0, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}

		// set up the worker thread
		this->dwEnumTimeout = dwTimeout;
		this->dwLastEnum = GetTickCount(); // just sent one above
		this->dwFlags |= DPLAYI_DPLAY_ENUM;
		this->pbAsyncEnumBuffer = pBuffer;
		this->dwEnumBufferSize = dwMessageSize;
		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	else 
	{
		// it's not async
		// call the sp and block waiting for a response
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,dwTimeout, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}
		// we're not starting an async - we're done w/ the buffer		
		DPMEM_FREE(pBuffer);		
	}
	
	DPF(9, "InternalEnumSessions: Return [0x%lx]", hr);
	
	// normal exit
	return hr;
	
ERROR_EXIT:
	if (hr != DPERR_CONNECTING)
		DPF_ERRVAL("SP Enum Sessions Failed - hr = 0x%08lx\n",hr);	
	if (pBuffer) DPMEM_FREE(pBuffer);
	return hr;
	
} // InternalEnumSessions

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
    DWORD dwFlags) 
{
    LPDPLAYI_DPLAY this;
	HRESULT hr=DP_OK;
	BOOL bContinue = TRUE;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
	        goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,lpsdDesc,dwTimeout,(LPVOID)lpEnumCallback,
			dwFlags);
		if (FAILED(hr)) 
		{
			if (hr != DPERR_CONNECTING)
				DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
		}

        hr = DoSessionCallbacks(this, lpsdDesc, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, FALSE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,
	    	DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through
CLEANUP_EXIT:

	LEAVE_ALL();
	
    return hr;

}//DP_EnumSessions


/*
 ** CopySessionDesc2
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: pSessionDescDest - session description ptr (destination)
 *				pSessionDescSrc - session description ptr (source)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies session description while allocating memory for name and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSessionDescDest && pSessionDescSrc);

    memcpy(pSessionDescDest, pSessionDescSrc, sizeof(DPSESSIONDESC2));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSessionDescDest->lpszSessionNameA), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSessionDescDest->lpszPasswordA), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSessionDescDest->lpszSessionName), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSessionDescDest->lpszPassword), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeDesc(pSessionDescDest, bAnsi);
    return hr;
}
 
void FreeSessionNode(LPSESSIONLIST pNode)
{
	// free up the sp blob stored w/ the desc
	if (pNode->pvSPMessageData) DPMEM_FREE(pNode->pvSPMessageData);
	// free the strings	store w/ the desc
	if (pNode->dpDesc.lpszSessionName) DPMEM_FREE(pNode->dpDesc.lpszSessionName);
	if (pNode->dpDesc.lpszPassword) DPMEM_FREE(pNode->dpDesc.lpszPassword);
	// free the session node
	DPMEM_FREE(pNode);
	
	return ;
	
} // FreeSessionNode


 // if we don't hear from a session after this many this->dwEnumTimeouts, we 
// "expire" it
#define DPSESSION_EXPIRE_SCALE 5
/*
 ** DoSessionCallbacks
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions
 *
 *  PARAMETERS: this pointer
 *				lpsdDesc - session desc (always UNICODE) - validated only
 *				lpdwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *              pvContext - app supplied context 
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *              lpbContinue - place holder for callback result
 *              bAnsi - ANSI or UNICODE
 *
 *  DESCRIPTION:  Does protected session callbacks while dropping the dplay locks
 *
 *  RETURNS: DP_OK, DPERR_OUTOFMEMORY
 *
 */
HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi)
{
    LPSESSIONLIST lpSessionNode,lpSessionNodePrev;
    UINT i, nSessions=0;
    LPGUID pGuidArray;
    HRESULT hr;
    DPSESSIONDESC2 sdesc;

    // default behavior when flags are not specified
    if (!dwFlags) dwFlags = DPENUMSESSIONS_AVAILABLE;

    // count the number of matching sessions
    lpSessionNode = this->pSessionList;
	lpSessionNodePrev = NULL;
    while (lpSessionNode) 
    {
		// is this session expired?
		if ( (this->dwFlags & DPLAYI_DPLAY_ENUM) && (GetTickCount() - lpSessionNode->dwLastReply > 
			this->dwEnumTimeout*DPSESSION_EXPIRE_SCALE ) )
		{
	    	if (lpSessionNode->dpDesc.lpszSessionName != NULL)
	    	{
		    	DPF(4, "Expiring session \"%ls\" (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
					lpSessionNode->dpDesc.lpszSessionName,
					lpSessionNode->dpDesc.guidApplication.Data1,
					lpSessionNode->dpDesc.guidApplication.Data2,
					lpSessionNode->dpDesc.guidApplication.Data3,
					lpSessionNode->dpDesc.guidApplication.Data4[0],
					lpSessionNode->dpDesc.guidApplication.Data4[1],
					lpSessionNode->dpDesc.guidApplication.Data4[2],
					lpSessionNode->dpDesc.guidApplication.Data4[3],
					lpSessionNode->dpDesc.guidApplication.Data4[4],
					lpSessionNode->dpDesc.guidApplication.Data4[5],
					lpSessionNode->dpDesc.guidApplication.Data4[6],
					lpSessionNode->dpDesc.guidApplication.Data4[7],
					lpSessionNode->dpDesc.guidInstance.Data1,
					lpSessionNode->dpDesc.guidInstance.Data2,
					lpSessionNode->dpDesc.guidInstance.Data3,
					lpSessionNode->dpDesc.guidInstance.Data4[0],
					lpSessionNode->dpDesc.guidInstance.Data4[1],
					lpSessionNode->dpDesc.guidInstance.Data4[2],
					lpSessionNode->dpDesc.guidInstance.Data4[3],
					lpSessionNode->dpDesc.guidInstance.Data4[4],
					lpSessionNode->dpDesc.guidInstance.Data4[5],
					lpSessionNode->dpDesc.guidInstance.Data4[6],
					lpSessionNode->dpDesc.guidInstance.Data4[7]);
	    	}
	    	else
	    	{
		    	DPF(4, "Expiring unnamed session (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
					lpSessionNode->dpDesc.guidApplication.Data1,
					lpSessionNode->dpDesc.guidApplication.Data2,
					lpSessionNode->dpDesc.guidApplication.Data3,
					lpSessionNode->dpDesc.guidApplication.Data4[0],
					lpSessionNode->dpDesc.guidApplication.Data4[1],
					lpSessionNode->dpDesc.guidApplication.Data4[2],
					lpSessionNode->dpDesc.guidApplication.Data4[3],
					lpSessionNode->dpDesc.guidApplication.Data4[4],
					lpSessionNode->dpDesc.guidApplication.Data4[5],
					lpSessionNode->dpDesc.guidApplication.Data4[6],
					lpSessionNode->dpDesc.guidApplication.Data4[7],
					lpSessionNode->dpDesc.guidInstance.Data1,
					lpSessionNode->dpDesc.guidInstance.Data2,
					lpSessionNode->dpDesc.guidInstance.Data3,
					lpSessionNode->dpDesc.guidInstance.Data4[0],
					lpSessionNode->dpDesc.guidInstance.Data4[1],
					lpSessionNode->dpDesc.guidInstance.Data4[2],
					lpSessionNode->dpDesc.guidInstance.Data4[3],
					lpSessionNode->dpDesc.guidInstance.Data4[4],
					lpSessionNode->dpDesc.guidInstance.Data4[5],
					lpSessionNode->dpDesc.guidInstance.Data4[6],
					lpSessionNode->dpDesc.guidInstance.Data4[7]);
	    	}
	    	
			// expire session
			if (lpSessionNodePrev)
			{
				// remove this session node from the middle of the list
				lpSessionNodePrev->pNextSession = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = lpSessionNodePrev->pNextSession;
			}
			else 
			{
				// take it off the front
				this->pSessionList = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = this->pSessionList;
			}
		}
		else 
		{
            // Filtering is done on the server for DX5 or greater
            if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
            {
		    	if (lpSessionNode->dpDesc.lpszSessionName != NULL)
		    	{
			    	DPF(4, "Using DX5+ session \"%ls\" (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
						lpSessionNode->dpDesc.lpszSessionName,
						lpSessionNode->dpDesc.guidApplication.Data1,
						lpSessionNode->dpDesc.guidApplication.Data2,
						lpSessionNode->dpDesc.guidApplication.Data3,
						lpSessionNode->dpDesc.guidApplication.Data4[0],
						lpSessionNode->dpDesc.guidApplication.Data4[1],
						lpSessionNode->dpDesc.guidApplication.Data4[2],
						lpSessionNode->dpDesc.guidApplication.Data4[3],
						lpSessionNode->dpDesc.guidApplication.Data4[4],
						lpSessionNode->dpDesc.guidApplication.Data4[5],
						lpSessionNode->dpDesc.guidApplication.Data4[6],
						lpSessionNode->dpDesc.guidApplication.Data4[7],
						lpSessionNode->dpDesc.guidInstance.Data1,
						lpSessionNode->dpDesc.guidInstance.Data2,
						lpSessionNode->dpDesc.guidInstance.Data3,
						lpSessionNode->dpDesc.guidInstance.Data4[0],
						lpSessionNode->dpDesc.guidInstance.Data4[1],
						lpSessionNode->dpDesc.guidInstance.Data4[2],
						lpSessionNode->dpDesc.guidInstance.Data4[3],
						lpSessionNode->dpDesc.guidInstance.Data4[4],
						lpSessionNode->dpDesc.guidInstance.Data4[5],
						lpSessionNode->dpDesc.guidInstance.Data4[6],
						lpSessionNode->dpDesc.guidInstance.Data4[7]);
		    	}
		    	else
		    	{
			    	DPF(4, "Using unnamed DX5+ session (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
						lpSessionNode->dpDesc.guidApplication.Data1,
						lpSessionNode->dpDesc.guidApplication.Data2,
						lpSessionNode->dpDesc.guidApplication.Data3,
						lpSessionNode->dpDesc.guidApplication.Data4[0],
						lpSessionNode->dpDesc.guidApplication.Data4[1],
						lpSessionNode->dpDesc.guidApplication.Data4[2],
						lpSessionNode->dpDesc.guidApplication.Data4[3],
						lpSessionNode->dpDesc.guidApplication.Data4[4],
						lpSessionNode->dpDesc.guidApplication.Data4[5],
						lpSessionNode->dpDesc.guidApplication.Data4[6],
						lpSessionNode->dpDesc.guidApplication.Data4[7],
						lpSessionNode->dpDesc.guidInstance.Data1,
						lpSessionNode->dpDesc.guidInstance.Data2,
						lpSessionNode->dpDesc.guidInstance.Data3,
						lpSessionNode->dpDesc.guidInstance.Data4[0],
						lpSessionNode->dpDesc.guidInstance.Data4[1],
						lpSessionNode->dpDesc.guidInstance.Data4[2],
						lpSessionNode->dpDesc.guidInstance.Data4[3],
						lpSessionNode->dpDesc.guidInstance.Data4[4],
						lpSessionNode->dpDesc.guidInstance.Data4[5],
						lpSessionNode->dpDesc.guidInstance.Data4[6],
						lpSessionNode->dpDesc.guidInstance.Data4[7]);
		    	}
	    	
                nSessions++;
            }
            else  // for previous versions, filtering is done on the client
            {
	            // make sure this session matches what the user asked for...
			    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
	            
		    	if (lpSessionNode->dpDesc.lpszSessionName != NULL)
		    	{
			    	DPF(4, "Checking pre-DX5 session \"%ls\" returned 0x%lx, (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
						lpSessionNode->dpDesc.lpszSessionName,
						hr,
						lpSessionNode->dpDesc.guidApplication.Data1,
						lpSessionNode->dpDesc.guidApplication.Data2,
						lpSessionNode->dpDesc.guidApplication.Data3,
						lpSessionNode->dpDesc.guidApplication.Data4[0],
						lpSessionNode->dpDesc.guidApplication.Data4[1],
						lpSessionNode->dpDesc.guidApplication.Data4[2],
						lpSessionNode->dpDesc.guidApplication.Data4[3],
						lpSessionNode->dpDesc.guidApplication.Data4[4],
						lpSessionNode->dpDesc.guidApplication.Data4[5],
						lpSessionNode->dpDesc.guidApplication.Data4[6],
						lpSessionNode->dpDesc.guidApplication.Data4[7],
						lpSessionNode->dpDesc.guidInstance.Data1,
						lpSessionNode->dpDesc.guidInstance.Data2,
						lpSessionNode->dpDesc.guidInstance.Data3,
						lpSessionNode->dpDesc.guidInstance.Data4[0],
						lpSessionNode->dpDesc.guidInstance.Data4[1],
						lpSessionNode->dpDesc.guidInstance.Data4[2],
						lpSessionNode->dpDesc.guidInstance.Data4[3],
						lpSessionNode->dpDesc.guidInstance.Data4[4],
						lpSessionNode->dpDesc.guidInstance.Data4[5],
						lpSessionNode->dpDesc.guidInstance.Data4[6],
						lpSessionNode->dpDesc.guidInstance.Data4[7]);
		    	}
		    	else
		    	{
			    	DPF(4, "Checking unnamed pre-DX5 session returned 0x%lx, (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
						hr,
						lpSessionNode->dpDesc.guidApplication.Data1,
						lpSessionNode->dpDesc.guidApplication.Data2,
						lpSessionNode->dpDesc.guidApplication.Data3,
						lpSessionNode->dpDesc.guidApplication.Data4[0],
						lpSessionNode->dpDesc.guidApplication.Data4[1],
						lpSessionNode->dpDesc.guidApplication.Data4[2],
						lpSessionNode->dpDesc.guidApplication.Data4[3],
						lpSessionNode->dpDesc.guidApplication.Data4[4],
						lpSessionNode->dpDesc.guidApplication.Data4[5],
						lpSessionNode->dpDesc.guidApplication.Data4[6],
						lpSessionNode->dpDesc.guidApplication.Data4[7],
						lpSessionNode->dpDesc.guidInstance.Data1,
						lpSessionNode->dpDesc.guidInstance.Data2,
						lpSessionNode->dpDesc.guidInstance.Data3,
						lpSessionNode->dpDesc.guidInstance.Data4[0],
						lpSessionNode->dpDesc.guidInstance.Data4[1],
						lpSessionNode->dpDesc.guidInstance.Data4[2],
						lpSessionNode->dpDesc.guidInstance.Data4[3],
						lpSessionNode->dpDesc.guidInstance.Data4[4],
						lpSessionNode->dpDesc.guidInstance.Data4[5],
						lpSessionNode->dpDesc.guidInstance.Data4[6],
						lpSessionNode->dpDesc.guidInstance.Data4[7]);
		    	}
		    	
		        if (SUCCEEDED(hr)) 
		        {
	                // increment the count
	                nSessions++;
	            }
            }

	        lpSessionNode = lpSessionNode->pNextSession;
		}
    }

    // are there any sessions to enumerate ?
    if (0 == nSessions)
    {
        return DP_OK;
    }

    // allocate memory for the session guids array
    pGuidArray = DPMEM_ALLOC(nSessions * sizeof(GUID));
    if (!pGuidArray)
	    {
        DPF_ERR("Could not allocate array for session guids");
        return DPERR_OUTOFMEMORY;
    }

    // fill the session guid and session desc arrays
    i=0;
    lpSessionNode = this->pSessionList;
    while (lpSessionNode)
    {
        // Filtering is done on the server for DX5 or greater
        if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
        {
            pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
            i++;
        }
        else  // for previous versions, filtering is done on the client
        {
            // make sure this session matches what the user asked for...
		    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
            if (SUCCEEDED(hr)) 
	        {
                pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
                i++;
            }
        }
        lpSessionNode = lpSessionNode->pNextSession;
    }

	// iterate over the guid list and callback w/ results	
    for (i=0; i < nSessions && *lpbContinue; i++)
    {        
        // check if the session is still valid 'cause session list could get 
        // deleted if EnumSessions is called while we dropped the locks
        lpSessionNode = FindSessionInSessionList(this,&pGuidArray[i]);	
        if (lpSessionNode)
        {
            // make a local copy of the session desc
            hr = CopySessionDesc2(&sdesc, &(lpSessionNode->dpDesc), bAnsi);
		    if (FAILED(hr))
		    {
			    DPF(0,"could not copy session desc hr = 0x%08lx\n",hr);
			    goto CLEANUP_EXIT;
		    }

            // drop the locks
			LEAVE_ALL();

            // call the app
		    *lpbContinue = CallAppEnumSessionsCallback(lpEnumCallback,&sdesc,lpdwTimeout,0,pvContext);	

            // reacquire locks
			ENTER_ALL();

            // free the strings allocated in CopySessionDesc2
            FreeDesc(&sdesc, bAnsi);
        }
        else
        {
	    	DPF(2, "Lost instance {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}), skipping.",
				pGuidArray[i].Data1,
				pGuidArray[i].Data2,
				pGuidArray[i].Data3,
				pGuidArray[i].Data4[0],
				pGuidArray[i].Data4[1],
				pGuidArray[i].Data4[2],
				pGuidArray[i].Data4[3],
				pGuidArray[i].Data4[4],
				pGuidArray[i].Data4[5],
				pGuidArray[i].Data4[6],
				pGuidArray[i].Data4[7]);
        }
    }

    // setting this explicitly here 'cause CheckSessionDesc could fail which is OK
    hr = DP_OK;

CLEANUP_EXIT:
    // cleanup allocations
    if (pGuidArray) 
    {
        DPMEM_FREE(pGuidArray);
    }

    return hr;
}


// Some apps (ok, "Outlaws" from LucasArts) were declaring their callbacks to
// be _cdecl instead of _stdcall and were relying on DPlay to generate stack frames to
// clean up after them. To keep them running we have to reset the stack pointer
// after returning from their callback, which will pop the parameters they were supposed to.
//
// Unfortunately, we can't use that nifty "#pragma optimize ("y", off)" here to turn on
// stack frames to fix this problem. This is because we don't have any local stack variables,
// so the compiler doesn't need to restore the stack pointer. I tried adding stack varibles
// but this ended up popping the wrong parameters and generally did not work 100%. So, an
// assembly language version seemed the safest way to go. This way it will always be correct,
// no matter what the compiler or how things change in the original functions.

// This fix won't affect applications that actually do clean up their parameters, since
// ESP == EBP when we return from calling them, so doing the "mov esp,ebp" won't change
// anything.

#if defined(_M_IX86)

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	// why we declare lpStackPtr :
	// 1. we use it as a return value (hence its type of 'bool')
	// 2. we use it as a temporary place to stash esp, so we don't confuse the compiler 
	BOOL lpStackPtr = FALSE;

	_asm {
		// Save stack pointer
		mov		dword ptr [lpStackPtr],esp
		
		mov		eax,dword ptr [lpContext]
		push	eax
		mov		eax,dword ptr [dwFlags]
		push	eax
		mov		eax,dword ptr [lpdwTimeout]
		push	eax
		mov		eax,dword ptr [lpSessionDesc]
		push	eax
		call	dword ptr [lpEnumCallback]
		
		// Restore stack pointer
		mov		esp,dword ptr [lpStackPtr]
		// immediately below, the compiler will generate a 'mov eax,dword ptr [lpStackPtr]'
		// we make sure lpStackPtr has the real return value we want.  this gets rid of 
		// a compiler warning (need to return something explicitly), plus force the compiler
		// to actually alloc space for lpStackPtr.
		mov		dword ptr [lpStackPtr],eax
	}
	
	return lpStackPtr;
}

#else

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	return (lpEnumCallback(lpSessionDesc, lpdwTimeout, dwFlags, lpContext));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\dvretro.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:        dvretro.c
*  Content:	 	Retrofit functions
*  History:
*
*   Date		By		Reason
*   ====		==		======
*   08/05/99	rodtoll	created it
*	08/20/99	rodtoll	Replaced in-process retrofit with lobby launch
*					    of dxvhelp.exe.
*						Added call to CoInitialize
*	08/23/99	rodtoll	Modified to match retrofit names to game session names
*   09/09/99	rodtoll	Updated with new retro launch procedure
*   09/10/99	rodtoll	Created DV_GetIDS to handle lookup of IDs.  Fixes bug with new 
*                       retrofit launch.
*               rodtoll	Adjusted guards to prevent multiple lobby launches
*				rodtoll	Added iamnameserver broadcast to catch clients that
*                       we missed notifications for after migration
*				rodtoll	Adjusted timeout in wait for thread shutdown to INFINITE
* 	10/25/99	rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate
*   11/04/99	rodtoll Fix: Calling CoUninitialize destroying dplay object too early in retrofit apps.
*						Plus closed a memory leak		
*   11/17/99	rodtoll	Fix: Bug #119585 - Connect failure cases return incorrect error codes
*   11/22/99	rodtoll	Updated case where no local player present to return DVERR_TRANSPORTNOPLAYER
 *  12/16/99	rodtoll Fix: Bug #122629 Fixed crash exposed by new host migration
*   02/15/2000	rodtoll	Fix: Bug #132715 Voice is not workin after rejoining session - Thread
*                       create was failing
*   05/01/2000  rodtoll Fix: Bug #33747 - Problems w/host migration w/old dplay.
*   06/03/2000  rodtoll Reverse integrating fixes in hawk branch for voice host migration issues
*
***************************************************************************/

#define DVF_DEBUGLEVEL_RETROFIT				2

#include <windows.h>
#include <objbase.h>
#include "dplaypr.h"
#include "dvretro.h"
#include "newdpf.h"
#include "memalloc.h"

#define GUID_STRLEN		37

#include <initguid.h>
// {D08922EF-59C1-48c8-90DA-E6BC275D5C8D}
DEFINE_GUID(APPID_DXVHELP, 0xd08922ef, 0x59c1, 0x48c8, 0x90, 0xda, 0xe6, 0xbc, 0x27, 0x5d, 0x5c, 0x8d);

extern HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags );

// Retrieve the local IDs
//
HRESULT DV_GetIDS( LPDPLAYI_DPLAY This, DPID *lpdpidHost, DPID *lpdpidLocalID, LPBOOL lpfLocalHost )
{
	LPDPLAYI_PLAYER pPlayerWalker;
	BYTE bCount;	
	HRESULT hr = DPERR_INVALIDPLAYER;

	*lpdpidHost = DPID_UNKNOWN;
	*lpdpidLocalID = DPID_UNKNOWN;
	
	pPlayerWalker=This->pPlayers;

	bCount = 0;

	if( This->pNameServer == This->pSysPlayer )
	{
		(*lpfLocalHost) = TRUE;
	}
	else
	{
		(*lpfLocalHost) = FALSE;
	}

	while(pPlayerWalker)
	{
		if( !(bCount & 1) && ((pPlayerWalker->dwFlags & (DPLAYI_PLAYER_PLAYERLOCAL|DPLAYI_PLAYER_SYSPLAYER))==DPLAYI_PLAYER_PLAYERLOCAL))
		{
			if( pPlayerWalker->dwID == pPlayerWalker->dwIDSysPlayer )
			{
				DPF( 0, "Picking wrong ID" );			
				DebugBreak();
			}
			
			DPF( 0, "FOUND: dwID=0x%x dwSysPlayer=0x%x dwFlags=0x%x", 
				 pPlayerWalker->dwID, pPlayerWalker->dwIDSysPlayer,  pPlayerWalker->dwFlags );
				 
			*lpdpidLocalID = pPlayerWalker->dwID;
			bCount |= 1;
		}

	
		if( !(bCount & 2) && ((pPlayerWalker->dwFlags & DPLAYI_PLAYER_SYSPLAYER)==0))
		{
			if( This->pNameServer != NULL && pPlayerWalker->dwIDSysPlayer == This->pNameServer->dwID )
			{
				*lpdpidHost = pPlayerWalker->dwID;
				bCount |= 2;
			}
		}

		pPlayerWalker = pPlayerWalker->pNextPlayer;

		if( bCount == 3 )
		{
			hr = DP_OK;
			break;
		}
	}

	if( *lpdpidLocalID == DPID_UNKNOWN )
	{
		DPF( 0, "Could not find local player to bind to" );
		return DVERR_TRANSPORTNOPLAYER;
	}

	return DV_OK;
}

HRESULT DV_Retro_Start( LPDPLAYI_DPLAY This )
{
	HRESULT hr;
	BOOL fLocalHost;

	// This variable set MUST be here, otherwise optimizing 
	// compiler screws up handling of This/fLocalHost
	fLocalHost = FALSE;

	This->bCoInitializeCalled = FALSE;
	This->bHost = FALSE;	

   	hr = DV_GetIDS( This, &This->dpidVoiceHost, &This->dpidLocalID, &fLocalHost );

	if( FAILED( hr ) )
   	{
   		DDASSERT( FALSE );
   		return DPERR_INVALIDPLAYER;
   	}

	if( fLocalHost )
	{
	   	DPF( DVF_DEBUGLEVEL_RETROFIT, "DV_Retro_Start: This player is the host, launching immediately" );
		DV_RunHelper( This, This->dpidVoiceHost, fLocalHost );
	}
	else
	{
		DPF( DVF_DEBUGLEVEL_RETROFIT, "DV_Retro_Start: This player is not the host, waiting for notification" );
	}

	return DV_OK;
}

// This thread is responsible for watching the retrofit
LONG DV_Retro_WatchThread( LPVOID lpParam ) 
{
	LPDPLAYI_DPLAY This = (LPDPLAYI_DPLAY) lpParam;
	HANDLE hEventArray[2];
	LPDPLMSG_GENERIC lpdplGeneric;
	DWORD dwBufferSize;
	LPBYTE lpbBuffer;
	DWORD dwReceiveSize;
	DWORD dwMessageFlags;
	HRESULT hr;
	DVPROTOCOLMSG_IAMVOICEHOST dvMsg;
	DWORD dwResult;
	DVTRANSPORT_BUFFERDESC dvBufferDesc;	
	
	hEventArray[0] = This->hRetroMessage;
	hEventArray[1] = This->hRetroWatcherStop;

	lpbBuffer = MemAlloc( 3000 );
	dwBufferSize = 3000;

	if(!lpbBuffer){
	DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: No Memory, NOT Launching retrofit thread\n" );	
		goto THREAD_LOOP_BREAK;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Launching retrofit thread\n" );	

	while( 1 )
	{
		dwResult = WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE );
		
		if( dwResult == WAIT_TIMEOUT )
		{
			hr = GetLastError();

			DPF( 0, "RetroThread; Wait failed hr=0x%x", hr );

			break;
		}
		else if( dwResult == WAIT_FAILED ) 
		{
			hr = GetLastError();

			DPF( 0, "RetroThread; Wait failed hr=0x%x", hr );

			break;
		}
		else if( dwResult != WAIT_OBJECT_0 )
		{
			DPF( 0, "RetroThread: Exiting thread!" );

			break;
		}

		hr = DP_OK;

		DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Waking up\n" );

		while( 1 ) 
		{
			dwReceiveSize = dwBufferSize;

			hr = This->lpdplRetro->lpVtbl->ReceiveLobbyMessage( This->lpdplRetro, 0, This->dwRetroID, &dwMessageFlags, lpbBuffer, &dwReceiveSize );

			if( hr == DPERR_NOMESSAGES || hr == DPERR_APPNOTSTARTED )
			{
				DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Waking up\n" );			
				break;
			}
			else if( hr == DPERR_BUFFERTOOSMALL  )
			{
				free( lpbBuffer );
				lpbBuffer = malloc( dwReceiveSize );
				dwBufferSize = dwReceiveSize;
				continue;
			}
			else if( hr == DP_OK )
			{
				DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Got a message\n" );
				
				if( dwMessageFlags & DPLMSG_SYSTEM )
				{
					lpdplGeneric = (LPDPLMSG_GENERIC) lpbBuffer;

					DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Was a system message\n" );					

					if( lpdplGeneric->dwType == DPLSYS_DPLAYCONNECTSUCCEEDED )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "Connection of retrofit app suceeded" );
					}
					else if( lpdplGeneric->dwType == DPLSYS_DPLAYCONNECTFAILED )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "Connection of retrofit failed.." );
						goto THREAD_LOOP_BREAK;
					}
					else if( lpdplGeneric->dwType == DPLSYS_NEWSESSIONHOST )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "This client just became the host!" );
						This->bHost = TRUE;
						This->dpidVoiceHost = This->dpidLocalID;

						dvMsg.bType = DVMSGID_IAMVOICEHOST;
						dvMsg.dpidHostID = This->dpidLocalID;
						
                        memset( &dvBufferDesc, 0x00, sizeof( DVTRANSPORT_BUFFERDESC ) );
                		dvBufferDesc.dwBufferSize = sizeof( dvMsg );
            		    dvBufferDesc.pBufferData = (PBYTE) &dvMsg;
            	    	dvBufferDesc.dwObjectType = 0;
                		dvBufferDesc.lRefCount = 1;						

						// Notify all hosts in case I missed a new player join notification
						hr = DV_InternalSend( This, This->dpidLocalID, DPID_ALLPLAYERS, &dvBufferDesc, NULL, DVTRANSPORT_SEND_GUARANTEED );

						if( hr != DPERR_PENDING && FAILED( hr ) )
						{
							DPF( DVF_DEBUGLEVEL_RETROFIT, "Failed to send notification of host migration hr=0x%x", hr );
						}
					}
				}
			}
			else
			{
				DPF( 0, "Error calling ReceiveLobbyMessage() hr = 0x%x", hr );
				goto THREAD_LOOP_BREAK;
			}
		}
	}

THREAD_LOOP_BREAK:

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit Watcher: Thread shutdown" );

	if(lpbBuffer) 
	{
		MemFree( lpbBuffer );
	}	

	SetEvent( This->hRetroWatcherDone );	

	return 0;
}

HRESULT DV_RunHelper( LPDPLAYI_DPLAY This, DPID dpidHost, BOOL fLocalHost )
{
	DPLCONNECTION dplConnection;
    LPDIRECTPLAYLOBBY lpdpLobby;	
	DPSESSIONDESC2 dpSessionDesc;
	DVTRANSPORTINFO dvTransportInfo;
	LPBYTE lpbAddress = NULL;
	DWORD dwAddressSize, dwOriginalSize;
	LPDIRECTPLAY4A lpDirectPlay4A;
	HRESULT hr;
	DWORD dwMessageFlags;
	DPNAME dpName;
	LPBYTE lpbNameBuffer = NULL;
	DWORD dwNameSize;
	HANDLE hThread;
	DWORD dwThreadID;

	if( This->bRetroActive != 0 )
	{
		DPF( 0, "Retrofit started, not restarting.." );
		return DPERR_GENERIC;
	}

	This->bRetroActive = 1;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Starting launch procedure" );

	dplConnection.dwFlags= 0;
    dplConnection.dwSize = sizeof( DPLCONNECTION );	

	if( fLocalHost )
	{
		dplConnection.dwFlags |= DPLCONNECTION_CREATESESSION;
		This->bHost = TRUE;
	}
	else
	{
		dplConnection.dwFlags |= DPLCONNECTION_JOINSESSION;
    }

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieving dplay interface" );    

	// get an IDirectPlay4A interface to use
	hr = GetInterface(This,(LPDPLAYI_DPLAY_INT *) &lpDirectPlay4A,&dpCallbacks4A);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplay object. hr = 0x%08lx\n",hr);
        goto EXIT_CLEANUP;
	}

	dwAddressSize = 0;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieving player address" );    	
    
	hr = lpDirectPlay4A->lpVtbl->GetPlayerAddress( lpDirectPlay4A, dpidHost, NULL, &dwAddressSize );

	if( hr != DPERR_BUFFERTOOSMALL && hr != DPERR_UNSUPPORTED )
	{
		DPF( 0, "Unable to retrieve size of host address hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got address size" );    		

	lpbAddress = MemAlloc( dwAddressSize );

	if( lpbAddress == NULL )
	{
		DPF( 0, "Unable to allocate memory -- retrofit failure" );
		return DPERR_OUTOFMEMORY;
	}

	hr = lpDirectPlay4A->lpVtbl->GetPlayerAddress( lpDirectPlay4A, dpidHost, lpbAddress, &dwAddressSize );

	if( hr == DPERR_UNSUPPORTED )
	{
		DPF( 0, "Unable to get host's address, not supported. Sending NULL" );
		MemFree( lpbAddress );
		lpbAddress = NULL;
		dwAddressSize = 0;
	}
	else if( FAILED( hr ) )
	{
		DPF( 0, "Unable to retrieve host's address (0x%x)-- retrofit failure hr=0x%08lx", dpidHost, hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got address" );    			

	memset( &dpSessionDesc, 0, sizeof( DPSESSIONDESC2 ) );

    dpSessionDesc.dwFlags = DPSESSION_DIRECTPLAYPROTOCOL | DPSESSION_KEEPALIVE | DPSESSION_MIGRATEHOST;
    memcpy( &dpSessionDesc.guidInstance, &GUID_NULL, sizeof( GUID ) );
    memcpy( &dpSessionDesc.guidApplication, &APPID_DXVHELP, sizeof( GUID ) );
    dpSessionDesc.dwSize = sizeof( DPSESSIONDESC2 );
    dpSessionDesc.dwMaxPlayers = 0;
    dpSessionDesc.dwCurrentPlayers = 0;
    dpSessionDesc.lpszSessionName = NULL;
    dpSessionDesc.lpszSessionNameA = NULL;
    dpSessionDesc.lpszPassword = NULL;
    dpSessionDesc.lpszPasswordA = NULL;

    dplConnection.lpSessionDesc = &dpSessionDesc;

	dwNameSize = 0;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Getting player name" );    				

	hr = lpDirectPlay4A->lpVtbl->GetPlayerName( lpDirectPlay4A, dpidHost, NULL, &dwNameSize );

	if( hr == DPERR_BUFFERTOOSMALL )
	{
		lpbNameBuffer = MemAlloc( dwNameSize );
		
		hr = lpDirectPlay4A->lpVtbl->GetPlayerName( lpDirectPlay4A, dpidHost, lpbNameBuffer, &dwNameSize );

		if( hr == DP_OK )	
		{
			DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got player name" );    						
			dplConnection.lpPlayerName = (LPDPNAME) lpbNameBuffer;
		}
	}

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to retrieve player name.  Defaulting to none. hr=0x%x", hr );
		
		dpName.dwSize = sizeof( DPNAME );
		dpName.dwFlags = 0;
		dpName.lpszShortNameA = NULL;
		dpName.lpszLongNameA = NULL;

		dplConnection.lpPlayerName = &dpName;	
	}

    memcpy( &dplConnection.guidSP, &This->pspNode->guid, sizeof( GUID ) );

    dplConnection.lpAddress = lpbAddress;
    dplConnection.dwAddressSize = dwAddressSize;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Creating lobby" );    						

	hr = DirectPlayLobbyCreateA( NULL, &lpdpLobby, NULL, NULL, 0);

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to create the lobby object hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Lobby created" );    							

	hr = lpdpLobby->lpVtbl->QueryInterface( lpdpLobby, &IID_IDirectPlayLobby3A, (void **) &This->lpdplRetro );

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Interface queried" );    								

	lpdpLobby->lpVtbl->Release(lpdpLobby);

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to create the lobby object hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieved interface and released old" );    									

	This->hRetroMessage = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroMessage == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr );
		goto EXIT_CLEANUP;
	}

	This->hRetroWatcherDone = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroWatcherDone == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr );
		goto EXIT_CLEANUP;
	}

	This->hRetroWatcherStop = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroWatcherStop == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr  );
		goto EXIT_CLEANUP;
	}


	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Running application" );	
	
	hr = This->lpdplRetro->lpVtbl->RunApplication( This->lpdplRetro, 0, &This->dwRetroID, &dplConnection, This->hRetroMessage );

	if( FAILED( hr ) )
	{
		DPF( DVF_DEBUGLEVEL_RETROFIT, "Unable to RunApplication() hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Application has been run!" );			


	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Launching thread!" );			

	// Start retro thread watcher.  Handles lobby communications 
	hThread = CreateThread( NULL, 0, DV_Retro_WatchThread, This, 0, &dwThreadID );

	if( !hThread )
	{
		DPF( 0, "ERROR Could not launch retrofit thread!" );
		hr = DVERR_GENERIC;
		goto EXIT_CLEANUP;
	}		

	MemFree( lpbAddress );

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Done Launching thread!" );				

	MemFree( lpbNameBuffer );
	lpbAddress = NULL;

	lpDirectPlay4A->lpVtbl->Release(lpDirectPlay4A);	

	return DP_OK;
	
EXIT_CLEANUP:

	if( This->hRetroWatcherStop != NULL )
	{
		// Shutdown the watcher thread
		SetEvent( This->hRetroWatcherStop );
		WaitForSingleObject( This->hRetroWatcherDone, 3000 );

		CloseHandle( This->hRetroWatcherStop );
		CloseHandle( This->hRetroWatcherDone );

		This->hRetroWatcherStop = NULL;
		This->hRetroWatcherDone = NULL;
	}

	if( lpbAddress != NULL )
	{
		MemFree( lpbAddress );
	}

	if( lpbNameBuffer != NULL )
	{
		MemFree( lpbNameBuffer );
	}

	if( This->lpdplRetro != NULL )
	{
		This->lpdplRetro->lpVtbl->Release(This->lpdplRetro);
		This->lpdplRetro = NULL;
	}

	if( lpDirectPlay4A != NULL )
		lpDirectPlay4A->lpVtbl->Release(lpDirectPlay4A);

	This->bRetroActive = 0;		


	return hr;

}
	

HRESULT DV_Retro_Stop( LPDPLAYI_DPLAY This )
{
	DWORD dwTerminate = 0xFFFF;

	if( This->bRetroActive == 0 )
	{
		DPF( 0, "Retrofit not started, not stopping.." );
		return DPERR_GENERIC;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "RETROFIT SHUTDOWN!!" );

	if( This->lpdplRetro != NULL )
	{
		//This->lpdplRetro->lpVtbl->SendLobbyMessage( This->lpdplRetro, 0, This->dwRetroID, &dwTerminate, sizeof( DWORD ) );

		// Shutdown the watcher thread
		SetEvent( This->hRetroWatcherStop );
		WaitForSingleObject( This->hRetroWatcherDone, INFINITE );

		This->lpdplRetro->lpVtbl->Release( This->lpdplRetro );
		This->lpdplRetro = NULL;

		CloseHandle( This->hRetroWatcherStop );
		CloseHandle( This->hRetroWatcherDone );

		This->hRetroWatcherStop = NULL;
		This->hRetroWatcherDone = NULL;
	}

	if( This->bCoInitializeCalled )
	{
		//CoUninitialize();
	}	

	This->bCoInitializeCalled = FALSE;

	This->bRetroActive = 0;

	return DP_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\iplay1.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplay1.c
 *  Content:	entry points for idirectplay1. entry points common to
 *				idirectplay1 and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	6/19/96	kipo	Bug #2047. Changed DP_1_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. CopyName() was not checking the application buffer
 *					size correctly before copying the buffer.
 *	6/20/96	andyco	added WSTRLEN_BYTES so we get the right strlength in copy string
 *	6/22/96	andyco	pass unicode sessiondesc2 to internalenumsessions so 
 *					we can send the password w/ the request
 *	6/26/96	andyco	pass DP_Open only DPOPEN_OPEN or DPOPEN_JOIN.  Also, 
 *					made sure we get service lock b4 getting dplay lock on enums.
 *	6/26/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *	7/10/96	kipo	converter DPSYS_DELETEPLAYERORGROUP message to a DPSYS_DELETEPLAYER
 *					or DPSYS_DELETEGROUP message for DP1.0 compatability.
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *	7/11/96	andyco	wrapped receive param check in try / except
 * 7/30/96 	kipo    player event is a handle now
 *	8/10/96	andyco 	check DPSESSION_JOINDISABLED in checksessiondesc
 *  8/12/96	andyco	call internalreceive so we can get addplayer 10 size correct.
 *  8/13/96	kipo	bug #3186: return currentPlayers in DP 1.0 session description.
 *  8/13/96 kipo	bug #3203: DP_1_GetPlayerName() should allow player and groups.
 *  10/2/96 sohailm bug #2847: replaced VALID_DPSESSIONDESC_PTR() macros with 
 *                  VALID_READ_DPSESSIONDESC_PTR() macros where appropriate.
 * 10/14/96 sohailm bug #3526: not validating session id before dereferencing as guid pointer
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreatePlayer"

HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer;
	DPNAME Name;
	HANDLE hEvent = NULL;	// assume we won't use events for this player
	HRESULT	hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check event
		if (phEvent && !VALID_DWORD_PTR(phEvent))
		{
	        DPF_ERR( "bad event pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if (phEvent && *phEvent)
		{
			DPF(3,"warning, *phEvent is non-null - dplay will be stomping this data!");
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// caller wants to use events
	if (phEvent)
	{
		ENTER_DPLAY();

		// create a manual-reset event
		hEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

		LEAVE_DPLAY();

		if (!hEvent)
		{
	        DPF_ERR( "could not create event" );
	        hr = DPERR_NOMEMORY;
			goto Failure;
		}
	}

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);
	
	// call the ansi entry w/ the new struct
	hr = DP_A_CreatePlayer(lpDP, pidPlayerID,&Name,hEvent,NULL,0,0);
	if FAILED(hr)
		goto Failure;

	if (hEvent)
	{
		ENTER_DPLAY();

		// get pointer to player structure
        lpPlayer = PlayerFromID(this,*pidPlayerID);

        if (!VALID_DPLAY_PLAYER(lpPlayer))
		{
	        DPF_ERR( "invalid player ID" );
			hr = DPERR_INVALIDPLAYER;
			LEAVE_DPLAY();
			goto Failure;
		}

		// remember to delete this event when player is deleted
		lpPlayer->dwFlags |= DPLAYI_PLAYER_CREATEDPLAYEREVENT;

		// return event we created
		*phEvent = hEvent;
		LEAVE_DPLAY();
	}

	return (DP_OK);

Failure:
	if (hEvent)
		CloseHandle(hEvent);
		
	return (hr);

} // DP_1_CreatePlayer
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreateGroup"

HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_CreateGroup(lpDP, pidGroupID,&Name,NULL,0,0);

} // DP_1_CreateGroup
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroupPlayers"

HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,NULL,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroupPlayers
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroups"

HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD_PTR dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroups
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumPlayers"

HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD_PTR dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();

	return hr;

} // DP_1_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumSessions"

// convert a unicode dpsessiondesc2 to (ansi) dpsessiondesc
// note we can't memcpy, since fields are not lined up
void Get10Desc(LPDPSESSIONDESC pDesc1,LPDPSESSIONDESC2 pDesc)
{
	memset(pDesc1,0,sizeof(DPSESSIONDESC));
	// copy over fields
	pDesc1->dwSize = sizeof(DPSESSIONDESC);
	pDesc1->guidSession = pDesc->guidApplication;
	pDesc1->dwMaxPlayers = pDesc->dwMaxPlayers;
	pDesc1->dwCurrentPlayers = pDesc->dwCurrentPlayers;
	pDesc1->dwFlags = pDesc->dwFlags;
	pDesc1->dwReserved1 = pDesc->dwReserved1;
	pDesc1->dwReserved2 = pDesc->dwReserved2;
	pDesc1->dwUser1 = pDesc->dwUser1;
	pDesc1->dwUser2 = pDesc->dwUser2;
	pDesc1->dwUser3 = pDesc->dwUser3;
	pDesc1->dwUser4 = pDesc->dwUser4;
	
	if (pDesc->lpszSessionName)
	{
		WideToAnsi(pDesc1->szSessionName,pDesc->lpszSessionName,DPSESSIONNAMELEN);
	}
	if (pDesc->lpszPassword)
	{
		WideToAnsi(pDesc1->szPassword,pDesc->lpszPassword,DPPASSWORDLEN);		
	}

	// use the pointer to the guid as the dwSession
	pDesc1->dwSession = (DWORD_PTR) &(pDesc->guidInstance);

} // Get10Desc

// same code as CheckSessionDesc, but for old desc.
// we need different code path here, since fields in  LPDPSESSIONDESC
// and LPDPSESSIONDESC2 don't line up
HRESULT CheckSessionDesc1(LPDPSESSIONDESC lpsdUser,LPDPSESSIONDESC lpsdSession,
	DWORD dwFlags)
{
	int iStrLen;


	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidSession),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidSession),&(lpsdSession->guidSession))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password
	iStrLen = STRLEN(lpsdSession->szPassword);
	if (iStrLen)
	{
		int iCmp;

		iCmp = strcmp(lpsdSession->szPassword,lpsdUser->szPassword);
		if (0 != iCmp) return E_FAIL;
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;
	
	return DP_OK;
} // CheckSessionDesc1

void Desc2FromDesc1(LPDPSESSIONDESC2 lpsdDesc2,LPDPSESSIONDESC lpsdDesc1)
{
	memset(lpsdDesc2,0,sizeof(DPSESSIONDESC2));
	lpsdDesc2->dwSize = sizeof(DPSESSIONDESC2);
	lpsdDesc2->dwFlags = lpsdDesc1->dwFlags;
	lpsdDesc2->guidApplication = lpsdDesc1->guidSession;// in sessiondesc1, session = game
	lpsdDesc2->dwMaxPlayers = lpsdDesc1->dwMaxPlayers;
	lpsdDesc2->dwUser1 = lpsdDesc1->dwUser1;
	lpsdDesc2->dwUser2 = lpsdDesc1->dwUser2;
	lpsdDesc2->dwUser3 = lpsdDesc1->dwUser3;
	lpsdDesc2->dwUser4 = lpsdDesc1->dwUser4;

	lpsdDesc2->lpszSessionNameA = lpsdDesc1->szSessionName;
	lpsdDesc2->lpszPasswordA = lpsdDesc1->szPassword;

	return ;
} // Desc2FromDesc1

HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags) 
{
	HRESULT hr;
	BOOL bContinue = TRUE;
	LPSESSIONLIST pSessionList;
	DPSESSIONDESC2 desc2,descW;
	DPSESSIONDESC desc1;
	GUID guidInstance;
	LPDPLAYI_DPLAY this;
	
	ENTER_ALL();

    TRY
    {		
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
			 
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
			LEAVE_ALL();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwSession) guidInstance = *((LPGUID)lpsdDesc->dwSession);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	hr = GetWideDesc(&descW,&desc2);
	if (FAILED(hr))
	{
		LEAVE_ALL();
		return hr;
	}

	while (bContinue)
	{
		//  do the enum. 
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			FreeDesc( &descW,FALSE);
			LEAVE_ALL();
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			return hr;
		}

		// callback w/ results	
		pSessionList = this->pSessionList;
	    while (pSessionList && bContinue)
	    {
			Get10Desc(&desc1,&(pSessionList->dpDesc));

			// make sure this session matches what the user asked for...
			hr = CheckSessionDesc1(lpsdDesc,&desc1,dwFlags);
			if (SUCCEEDED(hr)) 
			{
		        bContinue = lpEnumCallback( &desc1,pvContext,&dwTimeout,0);				
			}
			pSessionList = pSessionList->pNextSession;
	    } 
	    
		// done...
	    if (bContinue) bContinue = lpEnumCallback(NULL,pvContext,&dwTimeout,DPESC_TIMEDOUT);

	} // while bContinue

	FreeDesc( &descW,FALSE);
	
	LEAVE_ALL();

    return DP_OK;

} // DP_1_EnumSessions

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetCaps"

HRESULT Internal_1_GetCaps(LPDIRECTPLAY lpDP,LPDPCAPS lpDPCaps,DPID idPlayer,BOOL fPlayer) 
{
	DPCAPS dpcaps; // pass this to iplay2 when we get passed an old caps
	BOOL bOldCaps;
	HRESULT hr;
	DWORD dwFlags;

	TRY
	{
		if (VALID_DPLAY_CAPS(lpDPCaps))	
		{
			bOldCaps = FALSE;
		}
		else 
		{
			if (VALID_DPLAY1_CAPS(lpDPCaps))	
			{
				bOldCaps = TRUE;
				
				// take lock so we don't hose crt
				ENTER_DPLAY();
				memset(&dpcaps,0,sizeof(DPCAPS));
				memcpy(&dpcaps,lpDPCaps,lpDPCaps->dwSize);
				dpcaps.dwSize = sizeof(DPCAPS);
				LEAVE_DPLAY();
				
			}
			else 
			{
		        DPF_ERR( "BAD CAPS POINTER" );
		        return DPERR_INVALIDPARAMS;
			}
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
	}

	dwFlags = lpDPCaps->dwFlags;
	dpcaps.dwFlags = 0;

	if (bOldCaps)
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,&dpcaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,&dpcaps,dwFlags);
		}
		if (FAILED(hr)) return hr;

		// take lock so we don't hose crt
		ENTER_DPLAY();
		memcpy(lpDPCaps,&dpcaps,lpDPCaps->dwSize);
		LEAVE_DPLAY();
		
		return hr;
	}
	else 
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,lpDPCaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,lpDPCaps,dwFlags);
		}
	}
	
	return hr;
} // Internal_1_GetCaps

HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps) 
{

	return Internal_1_GetCaps(lpDP,lpDPCaps,0,FALSE);

} // DP_1_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerCaps"

HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps) 
{
	
	return Internal_1_GetCaps(lpDP,lpDPCaps,idPlayer,TRUE);

} // DP_1_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerName"

// called by getplayer name. copies lpszSrc (as much as will fit) to lpszDest
// set pdwDestLength to the size of lpszDest 
// returns DPERR_BUFFERTOOSMALL or DP_OK
HRESULT CopyName(LPSTR lpszDest,LPWSTR lpszSrc,DWORD * pdwDestLength) 
{
    UINT iStrLen; // str length, in bytes of what we're copying

	// ask wide to ansi how long
	iStrLen = WSTR_ANSILENGTH(lpszSrc);

	if (iStrLen > *pdwDestLength)
	{
		*pdwDestLength = iStrLen;
		return DPERR_BUFFERTOOSMALL;
	}

	*pdwDestLength = iStrLen;
	if (lpszSrc) 
	{
		WideToAnsi(lpszDest,lpszSrc,iStrLen);
	}
	
    return DP_OK;

} // CopyName

HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		lpPlayer = PlayerFromID(this,idPlayer);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,idPlayer);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERR("SP - passed bad player / group id");
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

        // check the strings - (this is redundant, since the SEH will catch the bd pdw below,
		// but nothing wrong w/ belt + suspenders)
		if ( (!VALID_DWORD_PTR(pdwShortNameLength)) || (!VALID_DWORD_PTR(pdwLongNameLength)) )
		{
            LEAVE_DPLAY();
			DPF_ERR("bad length pointer");
            return DPERR_INVALIDPARAMS;
		}

		// if the string is null, they just get the length
		if (!lpszShortName)*pdwShortNameLength = 0;
		if (!lpszLongName) *pdwLongNameLength = 0;

        if ((*pdwShortNameLength) && (!VALID_STRING_PTR(lpszShortName,*pdwShortNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }
        if ((*pdwLongNameLength) && (!VALID_STRING_PTR(lpszLongName,*pdwLongNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
    
    hr = CopyName(lpszShortName,lpPlayer->lpszShortName,pdwShortNameLength);

    hr |= CopyName(lpszLongName,lpPlayer->lpszLongName,pdwLongNameLength);

    LEAVE_DPLAY();
    return hr;

}//DP_1_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Open"

HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc ) 
{
	DPSESSIONDESC2 desc2;
	GUID guidInstance;
	DWORD dwFlags;

	ENTER_DPLAY();

    TRY
    {
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
        	LEAVE_DPLAY();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwFlags & DPOPEN_JOIN)
		{
            if (!VALID_READ_GUID_PTR((LPGUID)lpsdDesc->dwSession))
            {
        	    LEAVE_DPLAY();
			    DPF_ERR("Bad session id");	
	            return DPERR_INVALIDPARAMS;
            }
			// get the guid
			guidInstance = *((LPGUID)lpsdDesc->dwSession);
			dwFlags = DPOPEN_JOIN;
		}
		else 
		{
			dwFlags = DPOPEN_CREATE;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	LEAVE_DPLAY();

	return DP_A_Open(lpDP, &desc2,dwFlags ) ;
		
} // DP_1_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Receive"

// pvBuffer points to an DPMSG_CREATEPLAYERORGROUP mess
// convert it to an DPMSG_ADDPLAYER mess
HRESULT BuildAddPlayer1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_ADDPLAYER msg;
	LPDPMSG_CREATEPLAYERORGROUP pmsg2 = (LPDPMSG_CREATEPLAYERORGROUP) pvBuffer;

	memset(&msg,0,sizeof(DPMSG_ADDPLAYER));
	
	msg.dwType = DPSYS_ADDPLAYER;
	msg.dwPlayerType = pmsg2->dwPlayerType;
	msg.dpId = pmsg2->dpId;
	msg.dwCurrentPlayers = pmsg2->dwCurrentPlayers;
	
	if (pmsg2->dpnName.lpszShortName)
	{
		WideToAnsi(msg.szShortName,pmsg2->dpnName.lpszShortName,DPSHORTNAMELEN);				
	}

	if (pmsg2->dpnName.lpszLongName)
	{
		WideToAnsi(msg.szLongName,pmsg2->dpnName.lpszLongName,DPLONGNAMELEN);		
	}
	
	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildAddPlayer1

// pvBuffer points to an DPMSG_DESTROYPLAYERORGROUP mess
// convert it to a DPMSG_DELETEPLAYER
HRESULT BuildDeletePlayerOrDeleteGroup1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_DELETEPLAYER msg;
	LPDPMSG_DESTROYPLAYERORGROUP pmsg2 = (LPDPMSG_DESTROYPLAYERORGROUP) pvBuffer;

	if (pmsg2->dwPlayerType == DPPLAYERTYPE_PLAYER)
	{
		msg.dwType = DPSYS_DELETEPLAYER;
		msg.dpId = pmsg2->dpId;
	}
	else
	{
		msg.dwType = DPSYS_DELETEGROUP;
		msg.dpId = pmsg2->dpId;
	}

	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildDeletePlayerOrDeleteGroup1


HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;
	DWORD dwOrigSize=0; 

	ENTER_DPLAY();
	
    TRY
    {						 
		if (pdwSize) dwOrigSize = *pdwSize;    
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating pdwSize" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_1);

	if (FAILED(hr)) 
	{
		LEAVE_DPLAY();
		return hr;
	}

	// see if its a addplayer mess
	if (0 == *pidFrom )
	{
		switch (((DPMSG_GENERIC *)pvBuffer)->dwType)
		{
		case DPSYS_CREATEPLAYERORGROUP:
			if (sizeof(DPMSG_ADDPLAYER) > dwOrigSize ) 
			{
				ASSERT(FALSE); // should never happen!
			}
			else 
			{
				// convert the iplay 20 add player to a 10 add player
				BuildAddPlayer1(pvBuffer,pdwSize);
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			if (sizeof(DPMSG_DELETEPLAYER) > dwOrigSize ) 
			{
				*pdwSize = 	sizeof(DPMSG_DELETEPLAYER);
				hr = DPERR_BUFFERTOOSMALL;
			}
			else 
			{
				// convert the iplay 2.0 delete player/group to a 1.0 delete player or delete group
				BuildDeletePlayerOrDeleteGroup1(pvBuffer,pdwSize);
			}
			break;
		}
		
	} // 0 == pidFrom
	
	LEAVE_DPLAY();
	
	return hr;

} // DP_1_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SaveSession"

HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec) 
{
	return E_NOTIMPL;
} // DP_1_SaveSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SetPlayerName"

/*
 ** AnsiSetString
 *
 *  CALLED BY: DP_SetPlayerName
 *
 *  PARAMETERS: ppszDest - string to set, lpszSrc - string to copy
 *
 *  DESCRIPTION: frees *ppszDest. alloc's a new ppszDest to hold lpszSrc
 *
 *  RETURNS: DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT AnsiSetString(LPWSTR * ppszDest,LPSTR lpszSrc)
{
    if (!ppszDest) return E_UNEXPECTED;
    if (*ppszDest) DPMEM_FREE(*ppszDest);
	
	GetWideStringFromAnsi(ppszDest,lpszSrc);

	return DP_OK;

} // AnsiSetString

HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_SetPlayerName(lpDP, idPlayer,&Name,0);

}//DP_1_SetPlayerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\iplaya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplaya.c
 *  Content:	ansi entry points for idirectplay2A. entry points common to
 *				idirectplay2A and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	5/21/96	andyco	added internal_a_createplayer, dp_a_creategroup
 *	6/19/96	kipo	Bug #2047. Changed DP_A_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. DP_A_GetGroupName() and DP_A_GetPlayerName()
 *					had the player boolean was swapped so that it always
 *					returned an error.
 *	6/21/96	kipo	Deal with a null DPNAME in GetWideNameFromAnsiName().
 *	6/22/96	andyco	we were leaking a session desc in enumsessions
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *                  Deleted function DP_A_SaveSession
 *	7/10/96	kipo	changed system message names
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  10/1/96 sohailm updated DP_A_EnumSessions() to do protected callbacks
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 *  10/2/96 sohailm added code to validate user's DPNAME ptrs before accessing them
 * 10/11/96 sohailm Implemented DP_A_SetSessionDesc. Renamed labels for consistency.
 *	12/5/96	andyco	set the wide name to 0 in GetWideNameFromAnsiName before we
 *					validate params - this prevents freeing bogus pointer 
 *					if there's an error. Bug 4924.
 *  2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *  3/12/97 sohailm added functions SecureOpenA, GetWideCredentials, FreeCredentials,
 *                  GetSecurityDesc, FreeSecurityDesc, ValidateOpenParamsA.
 *                  modified DP_Open to use ValidateOpenParamsA.
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/8/97	myronth	Fixed memory leak, added StartSession ANSI conversion
 *  5/12/97 sohailm Update DP_A_SecureOpen(), FreeSecurityDesc() and GetWideSecurityDesc() 
 *                  to handle CAPIProvider name.
 *                  Fix for deadlock problem seen when SecureOpen fails (8386).
 *                  Added DP_A_GetAccountDesc().
 *	5/17/97	myronth	ANSI SendChatMessage
 *	5/17/97	myronth	Bug #8649 -- Forgot to drop lock on failed Open
 *	5/18/97	kipo	Adjust size of messages correctly.
 *  5/29/97 sohaim  Updated FreeCredentials(), GetWideCredentials(), DP_A_SecureOpen() to 
 *                  handle domain name.
 *	6/4/97	kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
 *  6/09/97 sohailm More parameter validation in DP_A_SecureOpen()
 *	9/29/97	myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/19/97myronth	Fixed error paths in DP_A_Open (#9757)
 ***************************************************************************/


// note - we always LEAVE_DPLAY(); before calling idirectplay2 fn's. this is 
// because some idirectplay2 fn's (ones that create a player ( take service lock)) 
// require the dplay lock to be completely dropped.


// todo - build messages!!!

#include "dplaypr.h"
#include "dpsecure.h" // !! Review - move headers into dplaypr !!

#undef DPF_MODNAME
#define DPF_MODNAME "GetWideStringFromAnsi"
			   
// utility function to convert the ansi string lpszStr to a wide string.  also, allocs space
// for the wide string
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr)
{
	int iStrLen;

	ASSERT(ppszWStr);

	if (!lpszStr) 
	{
		*ppszWStr = NULL;
		return DP_OK;
	}

	// alloc space for the wstr
	iStrLen = STRLEN(lpszStr);
	*ppszWStr = DPMEM_ALLOC(iStrLen * sizeof(WCHAR));
	if (!*ppszWStr)
	{
		DPF_ERR("could not get unicode string - out of memory");
		return E_OUTOFMEMORY;
	}

	// get the wstr
   	AnsiToWide(*ppszWStr,lpszStr,iStrLen);

	return DP_OK;
} // GetWideStringFromAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreatePlayer"


// get a wide playername struct from an ansi one
// assumes dplay lock taken
HRESULT GetWideNameFromAnsiName(LPDPNAME pWide,LPDPNAME pAnsi)
{
	LPSTR lpszShortName,lpszLongName;
	HRESULT hr;

	TRY 
	{
		// we assume pWide is valid - it's off our stack
		// init it here.  so, if we fail, it won't have garbage
		// which we try to free up...
		memset(pWide,0,sizeof(DPNAME));
		
        if (pAnsi && !VALID_READ_DPNAME_PTR(pAnsi))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

        if (pAnsi)
			lpszShortName = pAnsi->lpszShortNameA;
		else
			lpszShortName = NULL;

		if (pAnsi)
			lpszLongName = pAnsi->lpszLongNameA;
		else
			lpszLongName = NULL;

		if ( lpszShortName && !VALID_READ_STRING_PTR(lpszShortName,STRLEN(lpszShortName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpszLongName && !VALID_READ_STRING_PTR(lpszLongName,STRLEN(lpszLongName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }			      

    // get wchar versions of the strings
	hr = GetWideStringFromAnsi(&(pWide->lpszShortName),lpszShortName);
	if (FAILED(hr)) 
	{
		return hr;
	}
	hr = GetWideStringFromAnsi(&(pWide->lpszLongName),lpszLongName);
	if (FAILED(hr)) 
	{
		return hr;
	}

	// success - mark name as valid
	pWide->dwSize = sizeof(DPNAME);
	
	return DP_OK;	

} // GetWideNameFromAnsiName

// checks string params - then allocs unicode strings and calls DP_CreatePlayer
HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_CreatePlayer(lpDP, pID,&WName,hEvent,pvData,dwDataSize,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreatePlayer         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreateGroup"

// gets an ansi groupdata, and then calls DP_A_CreateGroup
HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroup(lpDP, pID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreateGroup         

HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroupInGroup(lpDP,idParentGroup, pidGroupID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} //DP_A_CreateGroup


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroupPlayers"

HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID idGroup, LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_A_EnumGroupPlayers     
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroups"

HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2A);


	LEAVE_ALL();

	return hr;

} // DP_A_EnumGroups           
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumPlayers"

HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_2A);

	LEAVE_ALL();

	return hr;

} // DP_A_EnumPlayers          
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumSessions"
// convert a unicode session desc to ansi
HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc)
{
	
	memcpy(pDescA,pDesc,sizeof(DPSESSIONDESC2));
	
	// convert session name
	if (pDesc->lpszSessionName)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszSessionNameA),pDesc->lpszSessionName);
	}
	
	// convert password
	if (pDesc->lpszPassword)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszPasswordA),pDesc->lpszPassword);
	}

	return DP_OK;

} // GetAnsiDesc

// frees the strings in a session desc
void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi)
{
	if (fAnsi)
	{
		if (pDesc->lpszPasswordA) DPMEM_FREE(pDesc->lpszPasswordA); 
		if (pDesc->lpszSessionNameA) DPMEM_FREE(pDesc->lpszSessionNameA);
		pDesc->lpszPasswordA = NULL;
		pDesc->lpszSessionNameA = NULL;
	}
	else 
	{
		if (pDesc->lpszPassword) DPMEM_FREE(pDesc->lpszPassword); 
		if (pDesc->lpszSessionName) DPMEM_FREE(pDesc->lpszSessionName);
		pDesc->lpszPassword = NULL;
		pDesc->lpszSessionName =NULL;
	}

} // FreeDesc

// convert an ansi session desc to unicode
HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA)
{
	LPWSTR lpsz;
	HRESULT hr;

	memcpy(pDesc,pDescA,sizeof(DPSESSIONDESC2));
	// convert session name
	// alloc a new session name
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszSessionNameA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert SessionName string to Unicode, hr = 0x%08x", hr);
		return hr;
	}
	// store the new one
	pDesc->lpszSessionName = lpsz;

	// convert password
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszPasswordA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert Password string to Unicode, hr = 0x%08x", hr);
		return hr;
	}

	// store the new one
	pDesc->lpszPassword = lpsz;

	return DP_OK;

} // GetWideDesc

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwTimeout,
	LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;
	BOOL bContinue = TRUE;
	DPSESSIONDESC2 descW;

 	ENTER_ALL();

	// validate strings and the this ptr
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }
	
	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT1;
		}

        hr = DoSessionCallbacks(this, &descW, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, TRUE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT1;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through

CLEANUP_EXIT1:
	FreeDesc( &descW,FALSE);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

} // DP_A_EnumSessions         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetGroupName"

HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerName"

HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetPlayerName
 
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetSessionDesc"

HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateOpenParamsA"
HRESULT ValidateOpenParamsA(LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
	if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
	{
		DPF_ERR("invalid session desc");
		return DPERR_INVALIDPARAMS;
	}
	// check strings
	if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
		STRLEN(lpsdDesc->lpszSessionNameA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
		STRLEN(lpsdDesc->lpszPasswordA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Open"

HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}
	
	LEAVE_DPLAY();
	
	hr = DP_Open(lpDP,&descW,dwFlags);

	ENTER_DPLAY();
	
	FreeDesc(&descW,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Open
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Receive"

// convert a unicode system message to an ansi one
// called by DP_A_Receive
//
// for namechanged and addplayer (only two sysmessages w/ strings),
// we're going to extract the strings from the uniciode message,
// and rebuild the message w/ ansi versions
HRESULT BuildAnsiMessage(LPDIRECTPLAY lpDP,LPVOID pvBuffer,LPDWORD pdwSize)
{
	DWORD dwType;
	LPSTR pszShortName=NULL,pszLongName=NULL; // our new ansi strings
	UINT nShortLen=0,nLongLen=0;
	DWORD dwAnsiSize;  // size for ansi msg
	LPBYTE pBufferIndex; // scratch pointer used to repack


	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;
	
	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
		{
			LPDPMSG_CREATEPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + pmsg->dwDataSize
				 + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

			if (pmsg->lpData)
			{
				memcpy(pBufferIndex,pmsg->lpData,pmsg->dwDataSize);
				pmsg->lpData = pBufferIndex;
				pBufferIndex += pmsg->dwDataSize;
			}
			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			break;
			
		} // ADDPLAYER

		case DPSYS_DESTROYPLAYERORGROUP:
		{
			LPDPMSG_DESTROYPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pmsg->dwLocalDataSize + pmsg->dwRemoteDataSize
						+ nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

			if (pmsg->lpLocalData)
			{
				memcpy(pBufferIndex,pmsg->lpLocalData,pmsg->dwLocalDataSize);
				pmsg->lpLocalData = pBufferIndex;
				pBufferIndex += pmsg->dwLocalDataSize;
			}

			if (pmsg->lpRemoteData)
			{
				memcpy(pBufferIndex,pmsg->lpRemoteData,pmsg->dwRemoteDataSize);
				pmsg->lpRemoteData = pBufferIndex;
				pBufferIndex += pmsg->dwRemoteDataSize;
			}

			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
				pBufferIndex += nLongLen;
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			
			break;
		} // DESTROYPLAYER

		case DPSYS_SETPLAYERORGROUPNAME:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
			LPDPMSG_SETPLAYERORGROUPNAME pmsg;

			pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;

			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}
			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETPLAYERORGROUPNAME) + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETPLAYERORGROUPNAME:

		case DPSYS_SETSESSIONDESC:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
            UINT nSessionNameLen=0, nPasswordLen=0;
            LPSTR pszSessionName=NULL, pszPassword=NULL;
			LPDPMSG_SETSESSIONDESC pmsg;

			pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;

			if (pmsg->dpDesc.lpszSessionName)
			{
				GetAnsiString(&pszSessionName,pmsg->dpDesc.lpszSessionName);
				nSessionNameLen = STRLEN(pszSessionName);
			}
			if (pmsg->dpDesc.lpszPassword)
			{
				GetAnsiString(&pszPassword,pmsg->dpDesc.lpszPassword);
				nPasswordLen = STRLEN(pszPassword);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETSESSIONDESC) + nSessionNameLen + nPasswordLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszSessionName)
					DPMEM_FREE(pszSessionName);
				if (pszPassword)
					DPMEM_FREE(pszPassword);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);
			if (pszSessionName) 
			{
				memcpy(pBufferIndex,pszSessionName,nSessionNameLen);
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszSessionName);
				pBufferIndex += nSessionNameLen;
			}
			else 
			{
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)NULL;				
			}

			if (pszPassword) 
			{
				memcpy(pBufferIndex,pszPassword,nPasswordLen);
				pmsg->dpDesc.lpszPasswordA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszPassword);
			}
			else 
			{
				pmsg->dpDesc.lpszPasswordA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETSESSIONDESC:

		case DPSYS_STARTSESSION:
		{
			LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;
			HRESULT					hr;
		
			hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace(pmsg->lpConn, pdwSize,
					sizeof(DPMSG_STARTSESSION));
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to convert DPLCONNECTION structure to ANSI, hr = 0x%08x", hr);
				return hr;
			}
			break;
		}

		case DPSYS_CHAT:
		{
			LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;
			LPSTR			pszMessage = NULL;
			UINT			nStringSize = 0;
			
			if (pmsg->lpChat->lpszMessage)
			{
				GetAnsiString(&pszMessage,pmsg->lpChat->lpszMessage);
				nStringSize = STRLEN(pszMessage);
			}
			
			dwAnsiSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + nStringSize; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszMessage)
					DPMEM_FREE(pszMessage);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CHAT) + sizeof(DPCHAT);
			if (pszMessage) 
			{
				memcpy(pBufferIndex, pszMessage, nStringSize);
				pmsg->lpChat->lpszMessageA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszMessage);
			}
			// all done
			break;
		}

		default:
			// do nothing
			break;
	}

	return DP_OK;

} // BuildAnsiMessage

HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2A);

	if (FAILED(hr)) 
	{
		goto CLEANUP_EXIT;
	}
	
	// if it's a system message, we may need to convert strings to ansi
	if (0 == *pidFrom )
	{
		// it's a system message
		hr = BuildAnsiMessage(lpDP,pvBuffer,pdwSize);
	}

CLEANUP_EXIT:
	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Receive        

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetGroupName"
HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetGroupName(lpDP, id,&WName,dwFlags);
	}								 
		
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetPlayerName"
HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetPlayerName(lpDP,id,&WName,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetSessionDesc"
HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
    BOOL bPropogate;
	LPDPLAYI_DPLAY this;
							
	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			hr = DPERR_NOSESSIONS;
			goto CLEANUP_EXIT;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}

	if(this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES){
		bPropogate=FALSE;
	} else {
		bPropogate=TRUE;
	}
		
	hr = InternalSetSessionDesc(lpDP,&descW,dwFlags,bPropogate);
	
	FreeDesc(&descW,FALSE);

    // fall through

CLEANUP_EXIT:

	LEAVE_DPLAY();	
	return hr;

} // DP_A_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SecureOpen"

// frees the strings in a credentials structure
HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpCredentials->lpszUsernameA)
        {
            DPMEM_FREE(lpCredentials->lpszUsernameA);
            lpCredentials->lpszUsernameA = NULL;
        }
        if (lpCredentials->lpszPasswordA)
        {
            DPMEM_FREE(lpCredentials->lpszPasswordA);
            lpCredentials->lpszPasswordA = NULL;
        }
        if (lpCredentials->lpszDomainA)
        {
            DPMEM_FREE(lpCredentials->lpszDomainA);
            lpCredentials->lpszDomainA = NULL;
        }
    }
    else
    {
        if (lpCredentials->lpszUsername)
        {
            DPMEM_FREE(lpCredentials->lpszUsername);
            lpCredentials->lpszUsername = NULL;
        }
        if (lpCredentials->lpszPassword)
        {
            DPMEM_FREE(lpCredentials->lpszPassword);
            lpCredentials->lpszPassword = NULL;
        }
        if (lpCredentials->lpszDomain)
        {
            DPMEM_FREE(lpCredentials->lpszDomain);
            lpCredentials->lpszDomain = NULL;
        }
    }

    return DP_OK;
} // FreeCredentials


// create a unicode credentials struct from an ansi one
HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, LPCDPCREDENTIALS lpCredentialsA)
{
    HRESULT hr;

    ASSERT(lpCredentialsW && lpCredentialsA);

    memcpy(lpCredentialsW, lpCredentialsA, sizeof(DPCREDENTIALS));

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszUsername), lpCredentialsA->lpszUsernameA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszPassword), lpCredentialsA->lpszPasswordA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszDomain), lpCredentialsA->lpszDomainA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeCredentials(lpCredentialsW,FALSE);
    return hr;
} // GetWideCredentials

// frees the strings in a security desc structure
HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpSecDesc->lpszSSPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProviderA);
            lpSecDesc->lpszSSPIProviderA = NULL;
        }
        if (lpSecDesc->lpszCAPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProviderA);
            lpSecDesc->lpszCAPIProviderA = NULL;
        }
    }
    else
    {
        if (lpSecDesc->lpszSSPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProvider);
            lpSecDesc->lpszSSPIProvider = NULL;
        }
        if (lpSecDesc->lpszCAPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProvider);
            lpSecDesc->lpszCAPIProvider = NULL;
        }
    }

    return DP_OK;
} // FreeSecurityDesc

// create a unicode security description struct from an ansi one
HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, LPCDPSECURITYDESC lpSecDescA)
{
    HRESULT hr;

    ASSERT(lpSecDescW && lpSecDescA);

	memcpy(lpSecDescW,lpSecDescA,sizeof(DPSECURITYDESC));

    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszSSPIProvider), 
        lpSecDescA->lpszSSPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszCAPIProvider), 
        lpSecDescA->lpszCAPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeSecurityDesc(lpSecDescW,FALSE);
    return hr;
} // GetWideSecurityDesc

HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
    DPCREDENTIALS credW;
    DPSECURITYDESC secDescW;
    LPDPCREDENTIALS pIntCreds=NULL;
    LPDPSECURITYDESC pIntSecDesc=NULL;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        // validate regular open params
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
        // validate additional params

        // null lpSecDesc is ok, will use default
        if (lpSecDesc)            
        {
            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid security desc");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpSecDesc->lpszSSPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProviderA,
			    STRLEN(lpSecDesc->lpszSSPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad SSPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpSecDesc->lpszCAPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProviderA,
			    STRLEN(lpSecDesc->lpszCAPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad CAPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid credentials structure");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpCredentials->lpszUsernameA && !VALID_READ_STRING_PTR(lpCredentials->lpszUsernameA,
			    STRLEN(lpCredentials->lpszUsernameA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad user name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszPasswordA && !VALID_READ_STRING_PTR(lpCredentials->lpszPasswordA,
			    STRLEN(lpCredentials->lpszPasswordA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad password string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszDomainA && !VALID_READ_STRING_PTR(lpCredentials->lpszDomainA,
			    STRLEN(lpCredentials->lpszDomainA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad domain name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // initialize here so we can call cleanup routines
    memset(&descW, 0, sizeof(DPSESSIONDESC2));
    memset(&credW, 0, sizeof(DPCREDENTIALS));
    memset(&secDescW, 0, sizeof(DPSECURITYDESC));

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}

    if (lpCredentials)
    {
	    hr = GetWideCredentials(&credW,lpCredentials);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntCreds = &credW;
    }

    if (lpSecDesc)
    {
	    hr = GetWideSecurityDesc(&secDescW,lpSecDesc);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntSecDesc = &secDescW;
    }

	LEAVE_DPLAY();
	
	hr = DP_SecureOpen(lpDP,&descW,dwFlags,pIntSecDesc,pIntCreds);

	ENTER_DPLAY();

CLEANUP_EXIT:    
	FreeDesc(&descW,FALSE);
    FreeCredentials(&credW,FALSE);
    FreeSecurityDesc(&secDescW, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SecureOpen


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerAccount"

HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SendChatMessage"
HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
	HRESULT hr;
	DPCHAT dpc;
	LPWSTR lpwszMessage = NULL; // unicode message

	ENTER_DPLAY();

    TRY
    {
		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}
		
		// check message string
		lpwszMessage = lpMsg->lpszMessage;
		if ( !lpwszMessage ||
			!VALID_READ_STRING_PTR(lpwszMessage,WSTRLEN_BYTES(lpwszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGEA;
    }
	
	// Get a Unicode copy of the string
	hr = GetWideStringFromAnsi(&lpwszMessage, lpMsg->lpszMessageA);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert message string to Unicode, hr = 0x%08x", hr);
		goto EXIT_SENDCHATMESSAGEA;
	}

	// Copy the user's DPCHAT struct into our local one and change the
	// message string pointer
	memcpy(&dpc, lpMsg, sizeof(DPCHAT));
	dpc.lpszMessage = lpwszMessage;

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_SendChatMessage(lpDP, idFrom, idTo, dwFlags, &dpc);
		
	ENTER_DPLAY();
	
	if(lpwszMessage)
		DPMEM_FREE(lpwszMessage);

EXIT_SENDCHATMESSAGEA:

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SendChatMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\loopbksp.h ===
#include "windows.h"
#include "windowsx.h"
#include "dplay.h"
#include "dplaysp.h"
#include "dplaypr.h"
#include "newdpf.h"

#define MAX_LOOPBACK_SEND_SIZE 2048

// {8AEF46DA-4B31-4732-958F-AF25D0B0BCD8}
DEFINE_GUID(GUID_DPLAY_LOOPBACKSP, 
0x8aef46da, 0x4b31, 0x4732, 0x95, 0x8f, 0xaf, 0x25, 0xd0, 0xb0, 0xbc, 0xd8);

// {5A030546-81F0-4055-A65C-3CC0B65B9792}
DEFINE_GUID(GUID_LOOPBACK, 
0x5a030546, 0x81f0, 0x4055, 0xa6, 0x5c, 0x3c, 0xc0, 0xb6, 0x5b, 0x97, 0x92);

typedef struct _GLOBALDATA{
	CRITICAL_SECTION cs;
	DWORD			 dwNumPlayers;
}GLOBALDATA,*LPGLOBALDATA;

extern HRESULT WINAPI LBSPInit(LPSPINITDATA pSD);
extern HRESULT WINAPI LBSP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd);
extern HRESULT WINAPI LBSP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd);
extern HRESULT WINAPI LBSP_SendEx(LPDPSP_SENDEXDATA psd);
extern HRESULT WINAPI LBSP_Send(LPDPSP_SENDDATA psd);
extern HRESULT WINAPI LBSP_Shutdown(LPDPSP_SHUTDOWNDATA psd);
extern HRESULT WINAPI LBSP_Open(LPDPSP_OPENDATA pod);
extern HRESULT WINAPI LBSP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT WINAPI LBSP_GetCaps(LPDPSP_GETCAPSDATA pcd);
extern HRESULT WINAPI LBSP_GetAddress(LPDPSP_GETADDRESSDATA pad);
extern HRESULT WINAPI LBSP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped);
extern HRESULT WINAPI LBSP_Reply(LPDPSP_REPLYDATA prd);

extern SPNODE LBSPNode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\loopbksp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       loopbksp.c
 *  Content:	direct play loopback service provider (built-in)
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 * 10/4/99		aarono  created for loopback tests on audio support.
 ***************************************************************************/

#define INITGUID 

#include "windows.h"
#include "windowsx.h"
#include "dplay.h"
#include "dplaysp.h"
#include "newdpf.h"
#include "loopbksp.h"

SPNODE LBSPNode;
// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI LBSPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
	GLOBALDATA gd,*pgd;
	UINT dwSize;

	// Zero out global data
	memset(&gd,0,sizeof(gd));

    // set up callbacks
    pSD->lpCB->CreatePlayer = LBSP_CreatePlayer;
    pSD->lpCB->DeletePlayer = LBSP_DeletePlayer;
    pSD->lpCB->Send = LBSP_Send;
    pSD->lpCB->EnumSessions = LBSP_EnumSessions;
    pSD->lpCB->Reply = LBSP_Reply;
	pSD->lpCB->ShutdownEx = LBSP_Shutdown;
	pSD->lpCB->GetCaps = LBSP_GetCaps;
	pSD->lpCB->Open = LBSP_Open;
	pSD->lpCB->CloseEx = LBSP_Close;
	pSD->lpCB->GetAddress = LBSP_GetAddress;
   	//pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
   	//pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
    pSD->lpCB->SendEx		   = LBSP_SendEx;                  // required for async
   	//pSD->lpCB->GetMessageQueue = LBSP_GetMessageQueue;    

	pSD->dwSPHeaderSize = 0;

	// return version number so DirectPlay will treat us with respect
	pSD->dwSPVersion = (DPSP_MAJORVERSION);

	// store the globaldata
	hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
	
	hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}

	// Initialize the critical section stored in the global data.
	InitializeCriticalSection(&pgd->cs);
	
	// success!
	return DP_OK;    

ERROR_EXIT:

	DPF_ERR("Loopback SPInit - abnormal exit");

	return hr;

} // SPInit

HRESULT WINAPI LBSP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->cs);
	pgd->dwNumPlayers++;
	DPF(9,"Loopback SP: new player, now have %d",pgd->dwNumPlayers);
	LeaveCriticalSection(&pgd->cs);

	return DP_OK;
} // CreatePlayer

HRESULT WINAPI LBSP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9, "Loopback SP: Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
		pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
	
	// get the global data
	hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->cs);
	pgd->dwNumPlayers--;
	DPF(9,"Loopback SP: delete player, now have %d",pgd->dwNumPlayers);
	LeaveCriticalSection(&pgd->cs);

	return DP_OK;

} // DeletePlayer

HRESULT WINAPI LBSP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr;

	DWORD cbTotalBytesToCopy;
	DWORD cbBytesToCopy;
	DWORD iWritePos;
	DWORD iSrcBuf;

	CHAR SendData[MAX_LOOPBACK_SEND_SIZE];

	// Gather data into 1 buffer;
	
	iWritePos=0;
	iSrcBuf=0;
	cbTotalBytesToCopy=psd->dwMessageSize;

	if(cbTotalBytesToCopy > MAX_LOOPBACK_SEND_SIZE){
		DPF(0,"Loopback SP: trying to send too big a message %d bytes, max is %d bytes",cbTotalBytesToCopy, MAX_LOOPBACK_SEND_SIZE);
		return DPERR_SENDTOOBIG;
	}
	
	while(cbTotalBytesToCopy){
		cbBytesToCopy=(*(psd->lpSendBuffers+iSrcBuf)).len;
		memcpy(&SendData[iWritePos], (*(psd->lpSendBuffers+iSrcBuf)).pData, cbBytesToCopy);
		cbTotalBytesToCopy -= cbBytesToCopy;
		iWritePos += cbBytesToCopy;
	}

	// Loop back to message handler

	hr=psd->lpISP->lpVtbl->HandleMessage(psd->lpISP, SendData, psd->dwMessageSize,NULL);

	if(psd->dwFlags & DPSEND_ASYNC){

		if(!(psd->dwFlags & DPSEND_NOSENDCOMPLETEMSG)){
			// Complete the message
			psd->lpISP->lpVtbl->SendComplete(psd->lpISP, psd->lpDPContext, hr);
		}

		return DPERR_PENDING;

	} else {
	
		return DP_OK;
		
	}

} // SendEx

HRESULT WINAPI LBSP_Send(LPDPSP_SENDDATA psd)
{
	HRESULT hr;

	hr=psd->lpISP->lpVtbl->HandleMessage(psd->lpISP, psd->lpMessage, psd->dwMessageSize,NULL);

	return DP_OK;
} // send


HRESULT WINAPI LBSP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
	HRESULT hr;

	DPF(9,"Loopback SP_EnumSessions");
	
	hr=ped->lpISP->lpVtbl->HandleMessage(ped->lpISP, ped->lpMessage, ped->dwMessageSize,NULL);

	return DP_OK;
}

HRESULT WINAPI LBSP_Reply(LPDPSP_REPLYDATA prd)
{
	HRESULT hr;

	DPF(9,"Loopback SP_Reply");
	
	hr=prd->lpISP->lpVtbl->HandleMessage(prd->lpISP, prd->lpMessage, prd->dwMessageSize,NULL);

	return DP_OK;
}

HRESULT WINAPI LBSP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9,"Loopback SP_Shutdown");

	// get the global data
	hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP Shutdown: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	DeleteCriticalSection(&pgd->cs);

	return DP_OK;
}

HRESULT WINAPI LBSP_Open(LPDPSP_OPENDATA pod) 
{
	DPF(9,"Loopback SP_Open");
	return DP_OK;
}

HRESULT WINAPI LBSP_Close(LPDPSP_CLOSEDATA pcd)
{
	DPF(9,"Loopback SP_Close");
	return DP_OK;
}
// sp only sets fields it cares about

HRESULT WINAPI LBSP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{

	pcd->lpCaps->dwHeaderLength = 0;
	pcd->lpCaps->dwMaxBufferSize = MAX_LOOPBACK_SEND_SIZE;

	pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);

	pcd->lpCaps->dwLatency = 500;
	pcd->lpCaps->dwTimeout = 5000;

	return DP_OK;

} // SP_GetCaps

HRESULT WINAPI LBSP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9,"Loopback SP_GetAddress");

	// get the global data
	hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP Shutdown: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	hr = pad->lpISP->lpVtbl->CreateAddress(pad->lpISP, &GUID_DPLAY_LOOPBACKSP, &GUID_LOOPBACK, NULL,0,pad->lpAddress,pad->lpdwAddressSize);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\mcontext.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.h
 *  Content:	structures for message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      got rid of special case for 1 context
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/
#ifndef _MSG_CONTEXT_H_
#define _MSG_CONTEXT_H_
		
#define MSG_FAST_CONTEXT_POOL_SIZE  20

#define INIT_CONTEXT_TABLE_SIZE     16
#define CONTEXT_TABLE_GROW_SIZE     16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

#define LIST_END 0xFFFFFFFF

typedef PVOID (*PAPVOID)[]; // pointer to array of void pointers

typedef struct _SENDPARMS SENDPARMS, *PSENDPARMS, *LPSENDPARMS;

typedef struct _MsgContextEntry {
	PSENDPARMS psp;
	DWORD      nUnique;
	DWORD	   nContexts;
	union {
		PAPVOID   papv;	 
		UINT      iNextAvail;
	};	
} MSGCONTEXTENTRY, *PMSGCONTEXTENTRY;

typedef struct _MsgContextTable {
	UINT nUnique;
 	UINT nTableSize;
 	UINT iNextAvail;
 	MSGCONTEXTENTRY MsgContextEntry[0];
} MSGCONTEXTTABLE, *PMSGCONTEXTTABLE;

VOID InitTablePool(LPDPLAYI_DPLAY this);
VOID FiniTablePool(LPDPLAYI_DPLAY this);


//Internal
HRESULT InitContextTable(LPDPLAYI_DPLAY this);
VOID FiniContextTable(LPDPLAYI_DPLAY this);
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries);
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID pList, UINT nArrayEntries);

//External
HRESULT ReadContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID *lplpContextArray, PUINT lpnArrayEntries,BOOL bVerify);
HRESULT WriteContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID papvContextArray, 	UINT nArrayEntries);
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context);
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries);
PSENDPARMS pspFromContext(LPDPLAYI_DPLAY this, 	PVOID Context, BOOL bAddRef);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\mcontext.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.c
 *  Content:	message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      fixed bugs found by async testing
 *  2/18/98     aarono      wasn't dropping lock in error path - fixed
 *  6/20/98     aarono      pspFromContext, used count w/o init.
 *  12/22/2000  aarono      Whistler B#190380 use process heap for retail
 *  01/12/2001  aarono      Whistler B#285097 not freeing to right heap.
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/

/*

	Structures:

	Context mapping is done on the array of MSGCONTEXTENTRY's 
	this->pMsgContexts.  This is a MsgContextTable which can be
	grown if it gets empty.  Each context provided is an integer
	index from 0 to the list size.  To avoid context collisions
	the context is composed of 2 parts.  A high 16 bits that is 
	cycled with every allocation and the low 16 bits which is the
	index in the context table. 
	
*/


#include "dplaypr.h"
#include "mcontext.h"

// Allocate the pool heads for context mapping buffers.
// sizes range from 2 to MSG_FAST_CONTEXT_POOL_SIZE. Larger
// allocations are off the heap.
VOID InitTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;

	// Initialize the group context list pool.
	for (i=0; i < MSG_FAST_CONTEXT_POOL_SIZE; i++){
		this->GrpMsgContextPool[i]=0;
	}

	InitializeCriticalSection(&this->ContextTableCS);
	
}

// Free the pools and the head of the context mapping buffers.
// Note, not protected so all buffer ownership must already
// have reverted.
VOID FiniTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;
	PVOID pFree;
	
	for(i=0;i<MSG_FAST_CONTEXT_POOL_SIZE;i++){
		while(this->GrpMsgContextPool[i]){
			pFree=this->GrpMsgContextPool[i];
			this->GrpMsgContextPool[i]=*((PVOID *)this->GrpMsgContextPool[i]);
			DPMEM_FREE(pFree);
		}
	}
	DeleteCriticalSection(&this->ContextTableCS);
}

// Initializes the ContextTable.  The context table is an array of MSGCONTEXTENTRY's
// each one is used to map a DPLAY send context to the SP's internal context.  Entries
// are either a single entry or a list.  In the case of a list, a pointer to the list
// is entered into the CONTEXTENTRY.  Lists are allocated from the TablePool.
HRESULT InitContextTable(LPDPLAYI_DPLAY this)
{
	INT i;

	// Allocate the context mapping table
	this->pMsgContexts=(PMSGCONTEXTTABLE)DPMEM_ALLOC(sizeof(MSGCONTEXTTABLE)+
									INIT_CONTEXT_TABLE_SIZE * sizeof(MSGCONTEXTENTRY));

	if(!this->pMsgContexts){
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the context mapping table.
	// this->pMsgContexts->nUnique=0; //by ZERO_INIT
	this->pMsgContexts->nTableSize=INIT_CONTEXT_TABLE_SIZE;

	this->pMsgContexts->iNextAvail=0;
	for(i=0;i<INIT_CONTEXT_TABLE_SIZE-1;i++){
		this->pMsgContexts->MsgContextEntry[i].iNextAvail=i+1;
	}
	this->pMsgContexts->MsgContextEntry[INIT_CONTEXT_TABLE_SIZE-1].iNextAvail = LIST_END;

	return DP_OK;
}

// FiniContextTable - uninitialize the context table
VOID FiniContextTable(LPDPLAYI_DPLAY this)
{
	if(this->pMsgContexts){
		DPMEM_FREE(this->pMsgContexts);
		this->pMsgContexts=NULL;
	}	
}

// verify the context is the one allocated, i.e. hasn't been recycled.
BOOL VerifyContext(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	if(iEntry > Table.nTableSize-1){
		return FALSE;
	}

	if(Entry[iEntry].nUnique && 
	   (Entry[iEntry].nUnique == ((DWORD_PTR)Context & CONTEXT_UNIQUE_MASK))
	  )
	{
		return TRUE;
	} else {
		return FALSE;
	}

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT ReadContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID *ppapvContextArray, 	//output
	PUINT lpnArrayEntries,   		//output
	BOOL  bVerify					// whether we need to verify the Context
	
)
{
	HRESULT hr=DP_OK;
	
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);

	if(bVerify && !VerifyContext(this,Context)){
		hr=DPERR_GENERIC;
		goto EXIT;
	}

	*lpnArrayEntries=Entry[iEntry].nContexts;
//	if(*lpnArrayEntries==1){
//		*ppapvContextArray=(PAPVOID)(&Entry[iEntry].pv);
//	} else {
		*ppapvContextArray=Entry[iEntry].papv;
//	}

EXIT:	
	LeaveCriticalSection(&this->ContextTableCS);

	return hr;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Sets a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT WriteContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID papvContextArray, 	
	UINT    nArrayEntries		
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	Entry[iEntry].nContexts=nArrayEntries;
	Entry[iEntry].papv = papvContextArray;
	LeaveCriticalSection(&this->ContextTableCS);
	
	return DP_OK;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}


// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array 
PSENDPARMS pspFromContext(
	LPDPLAYI_DPLAY this, 
	PVOID Context,
	BOOL  bAddRef
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	PSENDPARMS psp;
	UINT count;
	
	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	if(VerifyContext(this,Context)){
		psp=Entry[iEntry].psp;
		if(bAddRef){
			count=pspAddRefNZ(psp); 
			if(count==0){
				psp=NULL; // object already being freed.
			}
		}
	} else {
		psp=NULL;
	}
	LeaveCriticalSection(&this->ContextTableCS);

	return psp;
	
	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// allocates a list of contexts from the Table Pool.
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries)
{
	PAPVOID papv;

	ASSERT(nArrayEntries);

	EnterCriticalSection(&this->ContextTableCS);
	
	if((nArrayEntries <= MSG_FAST_CONTEXT_POOL_SIZE) &&
	   (papv=(PAPVOID)this->GrpMsgContextPool[nArrayEntries]))
	{
		this->GrpMsgContextPool[nArrayEntries]=*(PVOID *)this->GrpMsgContextPool[nArrayEntries];
		LeaveCriticalSection(&this->ContextTableCS);
	}
	else 
	{
		LeaveCriticalSection(&this->ContextTableCS);
		papv=DPMEM_ALLOC(nArrayEntries*sizeof(PVOID));
	}
	return papv;
}

// releases the memory associated with a context list
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID papv, UINT nArrayEntries)
{
	#define pNext ((PVOID *)papv)

	if(nArrayEntries){
		if(nArrayEntries > MSG_FAST_CONTEXT_POOL_SIZE){
			ASSERT(0);
			DPMEM_FREE(papv);
		} else {
			EnterCriticalSection(&this->ContextTableCS);
			*pNext = this->GrpMsgContextPool[nArrayEntries];
			this->GrpMsgContextPool[nArrayEntries]=(PVOID)papv;
			LeaveCriticalSection(&this->ContextTableCS);
		}
	}
	#undef pNext
}

// returns a context list entry to the free pool.
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define iEntry ((UINT_PTR)Context&CONTEXT_INDEX_MASK)

	PAPVOID papv;
	UINT 	nContexts;

	EnterCriticalSection(&this->ContextTableCS);

		// save this so we can do free outside lock.
		nContexts=Entry[iEntry].nContexts;
		papv=Entry[iEntry].papv;

		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;

		Entry[iEntry].nUnique=0;  // flags not in use.
	
	LeaveCriticalSection(&this->ContextTableCS);

	if(nContexts){
		FreeContextList(this, papv,nContexts);
	}
	
	
	#undef iEntry
	#undef Entry
	#undef Table
	#undef pTable
}

// allocates a context table of the appropriate size and returns the handle
// to use to manipulate the table.
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define NewTable (*pNewTable)

	UINT              i;
	UINT_PTR		  iEntry;
	PMSGCONTEXTTABLE  pNewTable;

	// First find a free context table entry.
	EnterCriticalSection(&this->ContextTableCS);

	if(Table.iNextAvail == LIST_END) {
		// Need to re-allocate the table.

		// Allocate the new table.

		// Allocate the context mapping table
		pNewTable=(PMSGCONTEXTTABLE)DPMEM_ALLOC(sizeof(MSGCONTEXTTABLE)+
				(Table.nTableSize+CONTEXT_TABLE_GROW_SIZE) * sizeof(MSGCONTEXTENTRY));

		if(!pNewTable){
			LeaveCriticalSection(&this->ContextTableCS);
			return NULL;
		}
		
		memcpy(pNewTable, pTable, Table.nTableSize*sizeof(MSGCONTEXTENTRY)+sizeof(MSGCONTEXTTABLE));

		DPMEM_FREE(pTable);

		NewTable.iNextAvail=NewTable.nTableSize;
		NewTable.nTableSize=NewTable.nTableSize+CONTEXT_TABLE_GROW_SIZE;
		
		for(i=NewTable.iNextAvail; i < NewTable.nTableSize-1; i++){
			NewTable.MsgContextEntry[i].iNextAvail=i+1;
		}
		NewTable.MsgContextEntry[NewTable.nTableSize-1].iNextAvail = LIST_END;
		
		pTable=pNewTable;

	}

	iEntry=Table.iNextAvail;
	Table.iNextAvail=Entry[Table.iNextAvail].iNextAvail;

	LeaveCriticalSection(&this->ContextTableCS);
	
	// If this is an array, look for array buffers of the pooled size, else allocate

	Entry[iEntry].nContexts = nArrayEntries;
	Entry[iEntry].psp       = psp;


	Entry[iEntry].papv = AllocContextList(this, nArrayEntries);
	
	if(!Entry[iEntry].papv){
		ASSERT(0);
		// couldn't get a context list, free the entry and bail.
		EnterCriticalSection(&this->ContextTableCS);
		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;
		LeaveCriticalSection(&this->ContextTableCS);
		return NULL;
	}

	EnterCriticalSection(&this->ContextTableCS);
	
	// increment uniqueness, never zero.
	do {
		pTable->nUnique += UNIQUE_ADD;
	} while(!pTable->nUnique);

	Entry[iEntry].nUnique=pTable->nUnique;

	LeaveCriticalSection(&this->ContextTableCS);

	ASSERT(((iEntry+Entry[iEntry].nUnique)&CONTEXT_INDEX_MASK) == iEntry);

	return ((PVOID)(iEntry+Entry[iEntry].nUnique));
	
	#undef pTable
	#undef Table
	#undef NewTable
	#undef Entry
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\iplay.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       iplay.c
*  Content:	IDirectPlay implementation
*  History:
*   Date		By		Reason
*   ====		==		======
* 	1/96		andyco	created it
*  	1/30/96		andyco	1st pass at list mgmt
*  	2/1/96		andyco	added namesrv support
*	2/15/96		andyco	added player messages
*	3/31/96		andyco	bugfest! !leaks	
*	4/10/96		andyco	made sp callbacks optional.  validated spdata after
*						create player
*	5/9/96		andyco	idirectplay2 
*	5/21/96		andyco	getcaps, getplayer/groupdata, getsessiondesc
*	5/31/96		andyco	playername, etc.
*	6/10/96		andyco	getxxxname,getsessiondesc copy data, don't give out ptrs.
*	6/19/96		kipo	Bug #1804. Return *pdwSize correctly in DP_Receive if
*						application buffer is too small.
*						Bug #1957. Calls to InternalSetName() had the player boolean
*						and flags parameters switched.
*						Bug #1959. In DP_DestroyGroup() the loop to remove all players
*						in the group was not doing lpGroupnode = lpGroupnode->pNextGroupnode,
*						causing it to reference through a deleted node and crash.
*						Bug #2017. InternalSetData() and SetPlayerData() had similar problems.
*						Memory leaks and crashes were occuring when MemReAlloc() returned
*						a NULL. Also, InternalSetData() was not checking to see if the data
*						length was zero before doing all this work, and was not returning
*						the HRESULT returned by SendDataChanged().
*						Derek Bug. DP_GetGroupName() and DP_GetPlayerName() had the boolean for
*						players and groups were swapped.
*						Derek Bug. InternalGetData() was not checking the application buffer size
*						correctly before copying the buffer.
*	6/20/96		andyco	added WSTRLEN_BYTES
*	6/21/96		kipo	Bug #2083. InternalGetSessionDesc() was using sizeof(DPNAME) instead
*						of sizeof(DPSESSIONDESC2); free existing names if you pass in a null
*						DPNAME structure.
*	6/23/96		kipo	updated for latest service provider interfaces.

*	6/25/96		kipo	added support for DPADDRESS.
*	6/30/96		andyco	added remote + local data, moved setdata to do.c. made 
*						getplayer,internalsetxxx share code.
*	7/1/96		andyco	changed check for !LOCAL instead of REMOTE, since
*						* & 0 will never be !0  (!)
*  7/8/96       ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
*                       to 'dpnName' to match DPLAY.H
*                       Change DPCAPS_NAMESERVER to DPCAPS_ISHOST
*                       Deleted function DP_SaveSession
*	7/10/96		andyco	added pending on nametable download
*	7/10/96		kipo	renamed system messages
*   7/11/96     ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
*	7/11/96		andyco	1. dp_destroyplayer was calling dp_deleteplayerfromgroup
*						passing dplayi_dplay instead of dplayi_int.  doh.  	#2330.
*						2. internalopensession was getting session name from
*						user strings, not from nameservers session desc.  caused
*						the name server to appear not to migrate.  #2216.
*						3.  Getplayeraddress changed to look for null callback
*						and return e_notimpl.  #2327. 
*   7/20/96     kipo	InternalGetSessionDesc() was calling STRLEN on a UNICODE
*						string and thus returning the wrong session name length. #2524
*	7/27/96		kipo	Bug #2691. Need to increment/decrement lpGroup->nPlayers when
*						you add/delete players from a group so the name table packing
*						includes the players in groups.	 Player event is a handle now.
*	8/1/96		andyco	changed dp_destroyplayer to internaldestroy.  added 
*						keepalivethreadproc.
*	8/6/96		andyco	added id mangling
*	8/8/96		andyco	added internalxxx for all player mgmt fn's to handle 
*						correctly propagating messages.
*	8/9/96		andyco	check max player on player creation
*	8/10/96		andyco	guaranteed flags.  no more terminatethread for 
*						keepalive thread
*  8/12/96		andyco	added internalreceive so we can get addplayer 10 size correct.
*  8/16/96		andyco 	store nameserver for new id requests
*  8/23/96		kipo	call OS_IsValidHandle() on even passed to CreatePlayer
*  8/28/96		andyco	don't freenametable if getnametable fails - we need 
*						it to get rid of sysplayer (bug 3537)
*  8/30/96		andyco	fix up pointers on destroyplayerorgroup(3655)
*  9/3/96		andyco	drop lock on close,destroyplayer sp callback
*  9/4/96		andyco	DON'T drop lock on destroyplayer!
*  10/2/96      sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
*                       where appropriate.
*  10/2/96      sohailm added code to validate user's DPNAME ptrs before accessing them
*  10/9/96		andyco	got rid of race condition in handlereply by adding
*						gbWaitingForReply. raid #3848.
*  10/10/96		andyco	set this->lpsdDesc to NULL if SP OpenSession call fails,
*						so we can call open again.  raid # 3784.
*  10/11/96     sohailm implemented DP_SetSessionDesc() and InternalSetSessionDesc()
*                       added code to fix up DPSYS_SETSESSIONDESC message pointers
*  10/12/96		andyco	added DPLAYI_GROUP_DPLAYOWNS.  SysGroup. 
*  11/11/96		andyco	support for DPLAYI_PLAYER_APPSERVER, free updatelists w/ 
*						player / groups.  always create sysgroup- no just if 
*						sp optimizes it.
* 11/20/96		andyco	added control panel (perf) thread startup / shutdown.
*						this thread updates the directx control panel w/ dplay
*						stats. see perf.c
*	12/5/96		andyco	if CreateSystemPlayer fails, bail before we try + create 
*						system group (and die)! Bug 4840.
*  01/09/96     sohailm do not return an error if dwMaxPlayers is set to zero (#5171)
*                       return the right error code if dwMaxPlayers is being set to
*                        less than dwCurrentPlayers (#5175)
*  01/16/97     sohailm client now checks if session is allowing players before 
*                       opening it (#4574)
*	1/15/96		andyco	handle groups correctly - added system player groupnode
*						support. 
*	1/24/97		andyco	detect dx3 nameservers. check pidTo + pidFrom in receive.
*						don't allow send of a NULL buffer. Raid 5294,5402, 5403, 5427.
* 	1/28/97		andyco	fixed setdata / setname to pass fPropagate so we can do permission
*						checking
*	2/1/97		andyco	dplay drops lock on send.  take service lock on dp_ entry points.
*	2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
*	2/15/97		andyco	remember the nameserver, even if it's local
*	2/18/97		kipo	fix bugs #4933 and #4934 by checking for invalid flags
*						in InternalCreatePlayer
*   2/26/97     sohailm don't let dwMaxPlayers to be set to more than sp can handle (5447)
*   2/26/97     sohailm initialize the reserved fields in the session desc 
*                       when session is created(4499).
*	3/5/97		andyco	changed keepalive thread to dplay thread
*	3/10/97		andyco	reset only session flags on close
*	3/12/97		myronth	added lobby support for Open & Close
*	3/13/97		myronth	flagged unsupported lobby methods as such
*   3/13/97     sohailm added functions SecureOpen(), CopyCredentials(), ValidateOpenParams(),
*                       modified InternalOpenSession to handle security, and DP_Open to 
*                       to use ValidateOpenParams().
*	3/17/97		myronth	Added lobby support for Create/DestroyGroup/Player
*	3/20/97		myronth	Added lobby support for AddPlayerToGroup and
*						DeletePlayerFromGroup, changed to use IS_LOBBYOWNED macro
*	3/21/97		myronth	Added lobby support for SetGroup/PlayerName, 
*						Get/SetGroup/PlayerData
*   3/18/97     sohailm Added support to cleanup context ptrs from the nametable during Close()
*                       Updated GetNameTable() to not send a nametable request if nameserver is 
*                       DX5 or greater (optimization - nameserver responds to addforward).
*                       Open and SetSessionDesc set the DPSESSION_PASSWORDREQUIRED flag if session
*                       requires a password.
*	3/25/97		kipo	treat zero-length password strings just like NULL password
*						strings for DX3 compatability; check for valid session flags
*						in Open and SetSessionDesc.
*   3/28/97     sohailm don't allow toggling DPSESSION_SECURESERVER in SetSessionDesc.
*   3/30/97     sohailm when open fails, drop the dplay lock before calling close so we don't 
*                       assert in close.
*   3/31/97     sohailm changed dpf to print out session desc flags in hex (open)
*	3/31/97		myronth	Added use of the propagate flag for all player management
*						messages which can come from the lobby.  If the flag is
*						cleared, it means the lobby called it for a remote player.
*   4/02/97     sohailm now we reset the login state when session is closed (7192)
*	4/10/97		myronth	Added support for GetCaps/GetPlayerCaps, fixed GetPlayerAddress
*	4/20/97		andyco	group in group
*   4/23/97     sohailm Added support for reporting signing and encryption caps.
*                       Added support for player message signing and encryption.
*	5/8/97		andyco	removed update list
*	5/8/97		myronth	Turned on system players for lobby-owned objects, made
*						subgroup methods work with the lobby
*	5/11/97		kipo	Fixed bugs #5408, 5406, 7435, 5249, 5250
*	5/13/97		myronth	Pass credentials to lobby's Open call, SecureOpen
*  05/17/97     sohailm Updated InternalOpenSession, Close, and SecureOpen to support CAPI encryption
*                       Removed check for dwMaxPlayers > allowed by SP (5448).
*                       Enabled encryption support.
*                       Now we check the flags in security desc and credentials (8387)
*                       Added DP_GetAccountDesc(), InternalGetAccountDesc().
*	5/17/97		myronth	SendChatMessage and it's pointer fixups
*	5/17/97		kipo	There was a bug in GetNameTable() where it was setting
*						the ghReplyProcessed event twice on the way out,
*						which would let handler.c in, trashing the buffer
*						that GetNameTable() was using.
*	5/17/97		myronth	Can't AddGroupToGroup on the same group
*	5/18/97		kipo	Don't allow group operations on the system group
*	5/18/97		kipo	Set DPLAYI_GROUP_STAGINGAREA flag in InternalCreatePlayer
*   5/18/97     sohailm Now we check if client is logged in before we allow send on 
*                       a secure player to player message.
*	5/20/97		myronth	Changed when lobby is called in AddPlayerToGroup,
*						DeletePlayerFromGroup, and DestroyGroup. (Bug #8586)
*						Removed the STAGINGAREA error case for CreateGroup (Bug #8743)
*   5/21/97     kipo	Bug #8744: DPSESSION_MULTICASTSERVER can't be changed
*						by SetSessionDesc().
*	5/21/97		myronth	Moved AddPlayerToGroup call in the lobby to eliminate
*						a race condition
*   5/22/97     kipo	Bug #8330: because the session list is not global in DX
*						we had a regression with X-Wing vs. Tie Fighter, fixed
*						by re-aquiring the session; added DPSP_MSG_AUTONAMETABLE
*						check in GetNameTable
*	5/22/97		myronth	Changed when lobby is called in DeletePlayerFromGroup
*						and DestroyGroup.  Now drop locks in several other
*						functions when we call the lobby.
*	5/23/97		andyco	unpack session desc w/ nametable. don't allow send
*						to non-local player unless i'm the multicastserver
*	5/23/97		kipo	Added support for return status codes
*	5/23/97		myronth	Fixed DeleteGroupFromGroup bug #8396, changed name of
*						RemoveGroupFromGroups to RemoveGroupFromAllGroups
*   5/24/97     sohailm We weren't setting the security description parameters correctly
*                       when user passed in a NULL CAPI provider name.
*	5/27/97		myronth	Re-fixed #8396 at a higher level
*	5/30/97		myronth	Added DP_GetGroupParent
*   5/30/97     sohailm update CopyCredentials() and DP_SecureOpen() to handle domain name.
*                       Added DP_GetPlayerAccount() and InternalGetPlayerAccount()
*	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
*	6/2/97		andyco	raid 9199 + 9063.  multicast server + client server error checking.
*	6/4/97		myronth	Bug #9146 -- SendChatMessage with remote From player should fail
*	6/4/97		myronth	Bug #9507 -- Failed lobby Open was leaving the dplay object initialized
*	6/4/97		kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
*	6/6/97		myronth	Moved call to lobby in InternalDeletePlayerFromGroup
*   6/09/97     sohailm More parameter validation in DP_SecureOpen()
*	6/11/97		myronth	Drop dplay lock before calling lobby GetCaps/GetPlayerCaps (#9756)
*   6/16/97     sohailm no security on sps that don't support reliable messages (#9872).
*   6/22/97     sohailm Secure messages are now routed using the multi-casting code.
*                       Added check to not allow raw player messages in a secure session.
*   6/23/97     sohailm Cleanup public keys when session is closed.
*   6/24/97     sohailm We were releasing the crypt context before releasing keys (#10272).
*   6/25/97     kipo	Only allow secure server when client server is also set
*   7/28/97		sohailm Enable multicast with security by default.
*						Removed check for client-server when secure session is requested.
*						Raw player messages are not allowed in a secure session.
*   8/4/97		andyco	reset this->dwMinVersion on close
*	8/19/97		myronth	Added <mmsystem.h> dependency to make the NT build happy
*	8/29/97		sohailm	return hresult in RemoveGroupFromGroupList (bug 10927) + 
*						don't drop lock in RemoveGroupFromGroupList (bug 10933).
*	9/29/97		myronth	SetPlayer/GroupData/Name calls to lobby now wait for
*						response from server before changing local info (#12554)
*						SendChatMessage sends to remote players for DPID_ALLPLAYERS (#12524)
*	10/21/97	myronth	Added hidden flag to CreateGroup, Added stubbed out
*						group owner methods
*	10/29/97	myronth	Added support for group owners (affects Create/DestroyGroup,
*						CreateGroupInGroup, DestroyPlayer)
*	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
*   11/17/19    aarono  Added SendEx/GetMessageQueue/CancelSend
*	11/19/97	myronth	Allow host to destroy remote players (#12901) and
*						fixed bug in InternalGetCaps (#12634)
*	11/24/97	myronth	Fixed CreateGroupInGroup w/ ParentID = 0 (#15245)
*						and EnumJoinSession w/ max players (#15229)
*	12/5/97		andyco	voice stuff
*	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887), Also fixed
*						CreateGroupInGroup for invalid parent (#15245), and
*						Removed invalid DeleteGroupFromGroup msg for real
*						child groups (#15264)
*	12/29/97	sohailm	Clients can't join secure session if hosted with DPOPEN_RETURNSTATUS (#15239)
*						Send SetSessionDesc system message reliably (#15461)
*	01/14/98	sohailm	Clear DPCAPS_GROUPOPTIMIZED flag when CLIENT_SERVER, DX3_INGAME,
*						or SECURE_SERVER (#15210)
*	1/20/98		myronth	#ifdef'd out voice support
*	1/26/98		sohailm	added session flags to SP_OPEN data structure
*	1/26/98		sohailm added an upper bound to join timeout.
*   2/2/98      aarono  moved FreePacketList and re-ordered locking to avoid 
*                       deadlock on close.
*   2/2/98      aarono  fixed error checking on priority in DP_SendEx
*   2/3/98      aarono  changed when we get remote version to DP_Open
*   2/3/98      aarono  changed open to get frame size again in case changed because protocol running.
*   2/13/98     aarono  async support
*   2/18/98     aarono  moved ProtocolInit into Open
*                       call protocol direct rather than through table.
*   2/19/98     aarono  call FiniProtocol in DP_Close
*   3/5/98	    aarono	B#18776 don't allow changing DPSESSION_DIRECTPROTOCOL in SetSessionDesc
*   3/5/98	    aarono	B#19916 don't allow GetMessageQueue on idFrom a group.
*   3/10/98     aarono  adding ref on dplay object insufficient, added ENTER_DPLAY()
*                       to DP_Cancel and DP_GetMessageQueue.
*   3/12/98     aarono  fixed DP_Close to shutdown threads better
*   3/13/98     aarono  fixed packetize shutdown for packetizeandsendreliable change
*   3/13/98     aarono  fixed protocol initialization path by getting caps everytime
*   3/13/98     aarono  changed DP_SendEx to validate send parms earlier.
*   3/19/98     aarono  don't let app change DPSESSION_OPTIMIZELATENCY flag.
*   3/30/98     aarono  fix locking in MessageQueue and Cancel methods.
*   3/31/98    a-peterz #21331: Check flags before using them.
*   4/15/98     aarono  B#22909 validate idTo on GetMessageQueue
*   4/23/98     aarono  fix memory leak in GetNameTable
*   6/2/98      aarono  don't wait for pending sends
*                       pass DPSEND_NOCOPY to protocol if present
*                       fix psp accounting on error in SendEx
*                       Make GetMessageQueue ask for System Queue
*   6/6/98      aarono  Don't drop DPLAY() lock across ProtocolDeletePlayer
*                       since code around it can't handle it.
*   6/8/98      aarono+peterz B#25311 BellHop can't shutdown, because of
*                       re-enter to close, made this OK.
*  6/10/98 aarono add PendingList to PLAYER and SENDPARM, complete pending
*                     sends on close before blowing away PLAYER
*  6/19/98      aarono add last ptr for message queues, makes insert
*                      constant time instead of O(n) where n is number
*                      of messages in queue.
*  6/22/98      aarono NULL sysplayer when blowing it away.
*  1/27/99      aarono don't call SP when create player not there.
*  7/9/99       aarono MANBUG#25328 not protecting release of protocol
*                      properly can cause exception when racing close.
*  8/02/99		aarono removed old voice support
*  8/05/99      aarono Moved voice over to DPMSG_VOICE
*  8/05/99		rodtoll Added call into retrofit
*  8/20/99		rodtoll	Added support for new retrofit
*  10/25/99		pnewson added support for launching voice via new 
*						application flags
* 11/02/99		rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
* 12/13/99		pnewson bugs #123583, 123601, 123604 - support to launch dpvhelp.exe on 
*						apps that are not registered or badly registered
* 05/19/00      rodtoll Bug #34304 - Retrofit is launched for non-TCP/IP providers
* 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
*                       added re-notification during simultaneous join CREATEPLAYERVERIFY
* 07/22/00 rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
*   				 Now for a thread to make an indication into voice they addref the interface
*					 so that the voice core can tell when all indications have returned.    
* 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
* 01/18/2001	rodtoll	Prevent retrofit from running on Whistler
*
***************************************************************************/

// issues:
// 	some stuff in try/except blocks is not really dangerous...
  
// todo - get latency w/ player caps
// todo - who has right to set session desc?

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
#include "dvretro.h"
#include "dplobpr.h"

// todo - This #define can be removed once we fix the DPF stuff on NT.
// currently, this is not getting defined by the makefile like it is
// on Win95, so we need to define it here. -- myronth
#ifndef PROF_SECT
#define PROF_SECT	"DirectPlay"
#endif // PROF_SECT

// registry keys and value names
#define DPLAY_REGISTRY_APPS		"Software\\Microsoft\\DirectPlay\\Applications"
#define REGSTR_VAL_GUID	    	"Guid"
#define REGSTR_VAL_FLAGS	    "dwFlags"

#undef DPF_MODNAME
#define DPF_MODNAME "DPVoiceCheckOS"
// DPVoiceCheckOS
//
// This function returns TRUE if this is a platform the retrofit runs on.
//
// This function will return DVERR_GENERIC if this is a platform the retrofit does not
// run on.
//
HRESULT DPVoiceCheckOS()
{
	OSVERSIONINFOA osVerInfo;
	LONG lLastError;

	osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );

	if( GetVersionExA( &osVerInfo ) )
	{
		// Win2K
		if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
			// NOTE: If we enable Whistler support we have to ensure that this returns an error
			// 		 if we're booting in safe-mode!
			/*
			// Whistler -- Major Version = 5 & Build # > 2195
			if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
			{
				return DV_OK;
			}*/

			return DVERR_GENERIC;
		}
		// Win9X
		else
		{
			// Millenium Major = 4, Minor = 90
			if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
			{
				return DV_OK;
			}

			return DVERR_GENERIC;
		}
	}
	else
	{
		lLastError = GetLastError();

		return DVERR_GENERIC;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"LookupVoiceRetrofitFlag"
BOOL LookupVoiceRetrofitFlag(LPGUID lpguidApp)
{
	CHAR szAppKeyName[_MAX_PATH];
	CHAR szGuidValueName[_MAX_PATH];
	CHAR szFlagsValueName[_MAX_PATH];
	CHAR szFileValueName[_MAX_PATH];
	CHAR szFile[_MAX_PATH];
	CHAR szLauncherValueName[_MAX_PATH];
	CHAR szLauncher[_MAX_PATH];
	CHAR name[_MAX_PATH];
	CHAR guidString[_MAX_PATH];
	WCHAR guidWString[_MAX_PATH];
	LONG lErr;
	HKEY hKey;
	DWORD index;
	INT i;
	HRESULT hr;
    DWORD	type;
    DWORD	cb;
    DWORD	flags;
    BOOL fRet = FALSE;
	HANDLE hFile;
	CHAR file_name[_MAX_PATH]; // general purpose
	CHAR name_last[_MAX_PATH]; // stores last component of file_name

	// Shortcut to ensure retrofit doesn't load on Whistler  
	if( FAILED( DPVoiceCheckOS() ) )
		return FALSE;

	file_name[0]=0; // make prefix happy.

    // Dump the guid for debug purposes.
    DPF(5, "Looking up Voice Retrofit Flag for app");
    DPF(5, "App GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
    	lpguidApp->Data1,
    	lpguidApp->Data2,
    	lpguidApp->Data3,
    	lpguidApp->Data4[0],
    	lpguidApp->Data4[1],
    	lpguidApp->Data4[2],
    	lpguidApp->Data4[3],
    	lpguidApp->Data4[4],
    	lpguidApp->Data4[5],
    	lpguidApp->Data4[6],
    	lpguidApp->Data4[7]);    	

	// sniff out the exe file name of the current game
    hFile =  GetModuleHandleA( NULL );
	
	GetModuleFileNameA( hFile, file_name, sizeof(file_name));
	file_name[sizeof(file_name) - 1] = '\0';	// ensure NULL termination

	DPF(5,"Full App NAME: %s",file_name);

    i = strlen( file_name )-1;
    while( i >=0 && file_name[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name_last, &file_name[i] );
	DPF(5,"App EXE NAME: %s", name_last);
    
	
	// look in the applications key to see if the voice retrofit should be run
	
	hr = WideToAnsi(szAppKeyName, SZ_DPLAY_APPS_KEY, OS_StrLen(SZ_DPLAY_APPS_KEY));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert key name to ANSI");
		return FALSE;
	}
	hr = WideToAnsi(szGuidValueName, SZ_GUID, OS_StrLen(SZ_GUID));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}
	hr = WideToAnsi(szFlagsValueName, SZ_DWFLAGS, OS_StrLen(SZ_DWFLAGS));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}

	hr = WideToAnsi(szFileValueName, SZ_FILE, OS_StrLen(SZ_FILE));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}

	hr = WideToAnsi(szLauncherValueName, SZ_LAUNCHER, OS_StrLen(SZ_LAUNCHER));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}
	
	lErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,szAppKeyName,0,KEY_READ,&hKey);
	
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d, there must be no applications registered",lErr);
		return FALSE;	// ok, no registered apps, no voice
	}

	// read the dwFlags value from the root app key for the default retrofit decision
	cb = sizeof( flags );
    if( !RegQueryValueExA( hKey, szFlagsValueName, NULL, &type, (LPSTR) &flags, &cb ) )
	{
		DPF(5, "Found global application flags, checking for DPLAPP_AUTOVOICE");
		if (flags & DPLAPP_AUTOVOICE)
		{
			DPF(5, "Found global application flags (0x%08x), defaulting to voice retrofit ON", flags);
			fRet = TRUE;			
		}
		else
		{
			DPF(5, "Found global application flags (0x%08x), defaulting to voice retrofit OFF", flags);
			fRet = FALSE;
		}
	}
	else
	{
		DPF(5, "No global application flags found, defaulting to voice retrofit OFF");
		fRet = FALSE;
	}

	index = 0;
    /*
     * run through all keys
     */
    while( !RegEnumKeyA( hKey, index, name, sizeof( name ) ) )
    {
		HKEY	hsubkey;
	    GUID 	guid;
	    BOOL 	fMatch;

		
		if(!RegOpenKeyA(hKey,name,&hsubkey))
		{
			// get the GUID for this entry
			cb = sizeof( guidString );
		    if( !RegQueryValueExA( hsubkey, szGuidValueName, NULL, &type, guidString, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry GUID: %s", guidString);
				   	// convert the string from the registry to a real guid
				   	hr = AnsiToWide(guidWString, guidString, cb);
				   	if (!FAILED(hr))
				   	{
				   		hr = GUIDFromString(guidWString, &guid);
				   		if (FAILED(hr))
						{
							DPF( 0, "    Error converting from string to guid");
							guid = GUID_NULL;
						}
					} else {
				   		DPF(0, "    Unable to convert string to wide string");
						guid = GUID_NULL;
					}
				} else {
				   	DPF( 0, "    Guid not a string!!!" );
					guid = GUID_NULL;
				}
			} else {
				DPF( 0, "    Guid name not found!!!" );
				guid = GUID_NULL;
		    }

			// get the "File" for this entry
			cb = sizeof( szFile );
		    if( !RegQueryValueExA( hsubkey, szFileValueName, NULL, &type, szFile, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry File: %s", szFile);
				} else {
				   	DPF( 0, "    File not a string!!!" );
					szFile[0] = 0;
				}
			} else {
				DPF( 0, "    File name not found!!!" );
				szFile[0] = 0;
		    }

			// get the "Launcher" for this entry
			cb = sizeof( szLauncher );
		    if( !RegQueryValueExA( hsubkey, szLauncherValueName, NULL, &type, szLauncher, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry Launcher: %s", szLauncher);
				} else {
				   	DPF( 0, "    Launcher not a string!!!" );
					szLauncher[0] = 0;
				}
			} else {
				DPF( 0, "    Launcher name not found!!!" );
				szLauncher[0] = 0;
		    }

		   	// check to see if this entry's GUID matches the app GUID,
		   	// or if the exe name matches the File or Launcher entries
			fMatch = FALSE;
		   	if (!IsEqualGUID(&guid, &GUID_NULL))
		   	{
			   	if (IsEqualGUID(&guid, lpguidApp))
			   	{
			   		DPF(5, "Found matching app GUID in registry");
			   		fMatch = TRUE;
			   	}
			}
			if (szFile[0] != 0)
			{
				if (_stricmp(szFile, name_last) == 0)
				{
			   		DPF(5, "Found matching app File in registry");
			   		fMatch = TRUE;
				}
			}
			if (szLauncher[0] != 0)
			{
				if (_stricmp(szLauncher, name_last) == 0)
				{
			   		DPF(5, "Found matching app Launcher in registry");
			   		fMatch = TRUE;
				}
			}

			if (fMatch == TRUE)
			{
		   		// we have a match, get the flags
			    cb = sizeof( flags );
			    if( !RegQueryValueExA( hsubkey, szFlagsValueName, NULL, &type, (LPSTR) &flags, &cb ) )
			    {
					if( (type == REG_DWORD) || (type == REG_BINARY && cb == sizeof( flags )) )
					{
						DPF(5, "App flags: %x", flags);
						// we have the flags, set the retrofit bit if the flags
						// indicate to do so
						if ((flags & DPLAPP_AUTOVOICE) && !(flags & DPLAPP_SELFVOICE))
						{
							// that's it, turn on the voice
							DPF(5, "Found app specific retrofit flags (%08x), voice retrofit ON", flags);
							fRet = TRUE;
						}
						else
						{
							DPF(5, "Found app specific retrofit flags (%08x), voice retrofit OFF", flags);
							fRet = FALSE;
						}
				    } else {
				    	DPF( 0, "    Not BINARY DWORD flags\n");
				    }
				} else {
					DPF( 0, "    No flags found for app %s", name );
			    }
				break; // get out of loop
			}
			
		}
		if(hsubkey)RegCloseKey(hsubkey);
		hsubkey=NULL;
		index++;
	}

	RegCloseKey(hKey);

	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddGroupToGroup"
HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_GROUP lpGroupTo; 
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_SUBGROUP lpSubgroup;
	
	DPF(5,"adding group id %d to group id %d fPropagate = %d\n",idGroup,idGroupTo,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroupTo = GroupFromID(this,idGroupTo);
        if ((!VALID_DPLAY_GROUP(lpGroupTo)) || (DPID_ALLPLAYERS == idGroupTo)) 
        {
			DPF_ERRVAL("invalid parent group id = %d", idGroupTo);
            return DPERR_INVALIDGROUP;
        }

        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// make sure they aren't trying to add a group to itself
	if(lpGroupTo == lpGroup)
	{
		DPF_ERR("Cannot add a group to itself");
		return DPERR_INVALIDGROUP;
	}

	// make sure group isn't already in group
	lpSubgroup = lpGroupTo->pSubgroups;
    while (lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(0,"group already in group!");
			return DP_OK;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

    // need a new DPLAYI_SUBGROUP
    lpSubgroup = DPMEM_ALLOC(sizeof(DPLAYI_SUBGROUP));
    if (!lpSubgroup) 
    {
        DPF_ERR("out of memory getting groupnode");
        return E_OUTOFMEMORY;
    }

	if (fPropagate)
	{
		if (dwFlags & DPGROUP_SHORTCUT)
		{
			hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDSHORTCUTTOGROUP, idGroup, 
				idGroupTo);
			
		}
				
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote group and we don't want to call it back in that case.
	// Also, if the DPGROUP_SHORTCUT flag is not set, then this is
	// being called from CreateGroupInGroup, so don't call the lobby
	// in that case.  The lobby will be called from DP_CreateGroupInGroup
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (dwFlags & DPGROUP_SHORTCUT))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddGroupToGroup(this->lpLobbyObject, idGroupTo, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, free our memory and exit without adding the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add group to group, hr = 0x%08x", hr);
			DPMEM_FREE(lpSubgroup);
			return hr;
		}
	}

	// set up the players groupnode
    lpSubgroup->pGroup = lpGroup;
	lpSubgroup->dwFlags = dwFlags;
	
	// stick it on the front
	lpSubgroup->pNextSubgroup = lpGroupTo->pSubgroups;
	lpGroupTo->pSubgroups = lpSubgroup;
	// update groupto
	lpGroupTo->nSubgroups++;

    // updates groups group info
    lpGroup->nGroups++;
    lpGroup->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
	
    return DP_OK;
	
}  // InternalAddGroupToGroup  

HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	hr = InternalAddGroupToGroup(lpDP,idGroupTo,idGroup,DPGROUP_SHORTCUT,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_AddGroupToGroup

  
#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddPlayerToGroup"

// we asked the SP to add a player to this group
// the SP failed, so we make the group dplay owned
// this means we have to call the sp to remove all players and destroy the group (just call
// the SP, we don't actually destroy the group)
HRESULT MakeGroupDPlayOwned(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup)
{
	HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode;
	DPSP_REMOVEPLAYERFROMGROUPDATA removedata;
	DPSP_DELETEGROUPDATA deletedata;
	
    ASSERT(!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS));

    if (this->pcbSPCallbacks->RemovePlayerFromGroup) 
    {
		// a-josbor: ask the sp to remove all players from the group
		// only do this if we have an SP that is DX6 or later!
		if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		{
		    lpGroupnode = lpGroup->pGroupnodes;
		    while ( lpGroupnode )
		    {
		        ASSERT(lpGroupnode->pPlayer);
			     // notify sp
				removedata.idPlayer = lpGroupnode->pPlayer->dwID;
				removedata.idGroup = lpGroup->dwID;        
				removedata.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
			    if (FAILED(hr)) 
			    {
					DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
					// keep going
			    }
			    lpGroupnode = lpGroupnode->pNextGroupnode;
			}
		}
		
		// ask the sp remove all the system players from the group 
	    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	    while ( lpGroupnode )
	    {
	        ASSERT(lpGroupnode->pPlayer);
		     // notify sp
			removedata.idPlayer = lpGroupnode->pPlayer->dwID;
			removedata.idGroup = lpGroup->dwID;        
			removedata.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
		    if (FAILED(hr)) 
		    {
				DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
				// keep going
		    }
		    lpGroupnode = lpGroupnode->pNextGroupnode;
		}
		
		
	}
	else 
	{
		// no callback - no biggie
	}
	
	// now, tell sp to nuke group
    if (this->pcbSPCallbacks->DeleteGroup) 
    {
	    // call sp
		deletedata.idGroup = lpGroup->dwID;
		deletedata.dwFlags = lpGroup->dwFlags;
		deletedata.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&deletedata);
		if (FAILED(hr)) 
		{
			DPF(0,"MakeGroupDPlayOwned :: SP - delete group failed - hr = 0x%08lx\n",hr);
			// keep going
		}
    }
	else 
	{
		// no callback - no biggie
	}
											   
	// dplay owns it!										   
    lpGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
    
    return DP_OK;
			
} // MakeGroupDPlayOwned

LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id)
{
	BOOL bFound = FALSE;
	LPDPLAYI_GROUPNODE pFoundNode = NULL;
	
	while (pGroupnode && !bFound)
	{
		if (pGroupnode->pPlayer->dwID == id)
		{
			bFound = TRUE;
			pFoundNode = pGroupnode;
		}
		else 
		{
			pGroupnode = pGroupnode->pNextGroupnode;	
		}
	} // while
	
	return pFoundNode;
	
} // FindPlayerInGroupList


// assumption: we only add sys players to sys groups
HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUPNODE lpGroupnode,lpSysGroupnode=NULL, lpGroupNodeAlloc=NULL;
	DPSP_ADDPLAYERTOGROUPDATA data;
	BOOL fSysPlayer = FALSE;
	
	DPF(5,"adding player id %d to group id %d fPropagate = %d\n",idPlayer,idGroup,fPropagate);

    //
	// Validate parameters
    // 
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroup = GroupFromID(this,idGroup);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d",idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);
        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	//
	// Ensure that sys players are only added
	// to sysgroups
	//

	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP); // should only add sysplayers to sysgroup!
		fSysPlayer = TRUE;
	}
	

	//
	// Ensure that we don't add a player
	// to a group of which he is already a 
	// member
	//
	if (fSysPlayer)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;	// sys players go in the sysplayer group nodes
	} else {
		lpGroupnode = lpGroup->pGroupnodes;				// regular players go in the regular player list
	}	
		
    while (lpGroupnode) 
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
			if (fSysPlayer)  
				DPF(3,"system player already in group!");
			else 
				DPF(0,"player already in group -- idGroup = %lx, idPlayer = %lx", idGroup, idPlayer);
				
			return DP_OK;			// we found the player already in this group.  Just return quietly.
        }
		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }


	//	alloc the player's node now
	lpGroupNodeAlloc=DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
	if(!lpGroupNodeAlloc){
		return DPERR_NOMEMORY;
	}
	

	// if the player being added isn't a sys player and there is no DX3 in the game,
	//	we need to make sure the sys player for this player is in the game
	if (!fSysPlayer && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		LPDPLAYI_PLAYER pSysPlayer = PlayerFromID(this,lpPlayer->dwIDSysPlayer);
		ASSERT(VALID_DPLAY_PLAYER(pSysPlayer));
		if (!VALID_DPLAY_PLAYER(pSysPlayer))
		{
			DPF(0,"could not find system player");
			ASSERT(FALSE);
			// let it go...
			hr = E_FAIL;
			goto EXIT;
		}
			
		// is this players system player in the group?
		lpSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);

		// if not, we go ahead and add it.  
		if (!lpSysGroupnode)
		{

			 // alloc a groupnode for the system player
		    lpSysGroupnode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
		    if (!lpSysGroupnode) 
		    {
		        DPF_ERR("out of memory adding system group node");
		        hr=E_OUTOFMEMORY;
		        goto EXIT;
		    }

			//
			// NOTE: In DX6, we add both the sysplayers and the regular players to the
			//       group AND INFORM THE SP.  It is up to the SP to distinguish
			//       systemplayers and regular players in a group.  The SP may
			//       deliver receives EITHER to the sysplayers or the regular
			//       players but not both.  The SP can differentiate sysplayers
			//       from regular players based on the flags passed into 
			//       SP_CreatePlayer.

			// now, inform the SP that we're adding this player to the group
			// this matches what happened with pre-DX6 SPs ( only sys players
			//	added to non-sys groups were told to the SP)
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->AddPlayerToGroup))
		    {
				ASSERT(lpSysGroupnode);
				data.idPlayer = pSysPlayer->dwID;
				data.idGroup = lpGroup->dwID;
 				data.lpISP = this->pISP;
				        
			    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
		    }
			else 
			{
				// SP not required to implement this
				hr = DP_OK;
			}
		    if (FAILED(hr)) 
		    {
				DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

				// take ownership of this group
				hr = MakeGroupDPlayOwned(this,lpGroup);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					// keep going.  sp may have not been able to clean up group - we keep trying...
					hr = DP_OK;
				}
		    } // FAILED(hr)

//			add our new group node to the front of the list
		    lpSysGroupnode->pNextGroupnode = lpGroup->pSysPlayerGroupnodes;
		    lpSysGroupnode->pPlayer = pSysPlayer;
		    lpSysGroupnode->nPlayers = 1;
		    lpGroup->pSysPlayerGroupnodes = lpSysGroupnode;

			// update the counts for the sysplayer
		    pSysPlayer->nGroups++;
	    	pSysPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
		}
		else
		{
			lpSysGroupnode->nPlayers++;
		}
	}


//	Now add the player that was originally passed to us

	//	grab the pre-alloced group node
    lpGroupnode = lpGroupNodeAlloc;
	lpGroupNodeAlloc = NULL;
	
	//	first send the notification to the others.  Note we don't
	//	propagate sys group info
	if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDPLAYERTOGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	//	now, inform the SP that we're adding this player to the group
	//	a-josbor: only if this is DX6 or later
    if (((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		&& !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
		&& (this->pcbSPCallbacks->AddPlayerToGroup) )
    {
		data.idPlayer = idPlayer;
		data.idGroup = idGroup;
		data.lpISP = this->pISP;
		        
	    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
    }
	else 
	{
		// SP not required to implement this
		hr = DP_OK;
	}
    if (FAILED(hr)) 
    {
		DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

		// take ownership of this group
		hr = MakeGroupDPlayOwned(this,lpGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going.  sp may have not been able to clean up group - we keep trying...
			hr = DP_OK;
		}
    } // FAILED(hr)


	//
	// Update all the group cruft
	//

	// set up the player's groupnode	
	lpGroupnode->pNextGroupnode = 
		(fSysPlayer) ? lpGroup->pSysPlayerGroupnodes : lpGroup->pGroupnodes; // put the new node on the right list
	lpGroupnode->pPlayer = lpPlayer;
	lpGroupnode->nPlayers = 0;

	// fix up the groups structure
	if (fSysPlayer)
	{
		lpGroup->pSysPlayerGroupnodes = lpGroupnode;
	}
	else
	{
		lpGroup->pGroupnodes = lpGroupnode;
		lpGroup->nPlayers++;
	}
	
	// fix up the player struct
	lpPlayer->nGroups++;
	lpPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;		


	//
	// Finally, give the lobby a crack at
	// it, if necessary.


	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddPlayerToGroup(this->lpLobbyObject, idGroup, idPlayer);
		
		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, remove the player from the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add player to group, hr = 0x%08x", hr);
			InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
					idGroup, idPlayer, FALSE);
		}
	}

EXIT:
	if(lpGroupNodeAlloc){
		DPMEM_FREE(lpGroupNodeAlloc);
	}
	
    return hr;
}  // InternalAddPlayerToGroup  


HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	// bug 5807 - don't allow user to addplayer to system group
	if (DPID_ALLPLAYERS == idGroup)
	{
		LEAVE_ALL();
		DPF_ERRVAL("invalid group id = %d", idGroup);
		return DPERR_INVALIDGROUP;
	}

	hr = InternalAddPlayerToGroup(lpDP,idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_AddPlayerToGroup

#undef DPF_MODNAME
#define DPF_MODNAME "FreePacketList"
// remove any packetized mesages that haven't been completed yet
void FreePacketList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode,pNodeNext;
	UINT_PTR uTickEvent;

	//
	// Packet list nulled here to keep PacketizeTick from
	// accessing the list while we are freeing it.
	//
	
	pNode = this->pPacketList;
	this->pPacketList = NULL;
	uTickEvent=this->uPacketTickEvent;
	this->uPacketTickEvent=0;

	LEAVE_DPLAY();
	if(uTickEvent){
		// Shutdown the ticker that ages out 
		// PacketizeAndSend Receives. -- can't hold DPLAY lock when
		// calling timeKillEvent on an event that takes the lock since
		// on NT timeKillEvent doesn't return until the function is
		// done, which would cause a deadlock if we had the lock.
		timeKillEvent((DWORD)uTickEvent);
	}	
	ENTER_DPLAY();

	while (pNode)
	{
		pNodeNext = pNode->pNextPacketnode;

		if(pNode->bReliable && pNode->bReceive){
			this->nPacketsTimingOut -= 1;
			ASSERT(!(this->nPacketsTimingOut&0x80000000));
		}

		// free up the packet node
		FreePacketNode(pNode);
				
		pNode = pNodeNext;
	}
	
	ASSERT(this->nPacketsTimingOut == 0);

	Sleep(0); // allow expired timers to run.

	return ;
	
} // FreePacketList

// remove any pending messages
void FreePendingList(LPDPLAYI_DPLAY this)
{
	LPPENDINGNODE pmsg,pmsgNext;

	pmsg = this->pMessagesPending;
	while (pmsg)
	{
		pmsgNext = pmsg->pNextNode;
		if (pmsg->pMessage) DPMEM_FREE(pmsg->pMessage);
		if (VALID_SPHEADER(pmsg->pHeader)) DPMEM_FREE(pmsg->pHeader);
		DPMEM_FREE(pmsg);
		pmsg = pmsgNext;
	}

	this->pMessagesPending = NULL;
	this->pLastPendingMessage = NULL;
	
	ASSERT(0 == this->nMessagesPending);

	return ;
		
} // FreePendingList 

// nuke our keep alive thread or our control panel thread
// signal the thread (so it will wake up and exit), then wait for it to
// go away
void KillThread(HANDLE hThread,HANDLE hEvent)
{
	DWORD dwRet;
	
	if (hThread)
	{
		SetEvent(hEvent);
		
		// wait for it to die
		dwRet = WaitForSingleObject(hThread,INFINITE);
		if (WAIT_OBJECT_0 != dwRet) 
		{
			ASSERT(FALSE);
			// sholuld never happen
		}
		
		if (!CloseHandle(hThread))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close thread - err = %d\n",dwErr);
		}

		if (!CloseHandle(hEvent))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close event handle - err = %d\n",dwErr);
		}
		
	}
	else 
	{
		ASSERT(!hEvent);
	}

	return ;
	
} // KillThread

// called by DP_Close
void CloseSecurity(LPDPLAYI_DPLAY this)
{
    // free up the security desc
    if (this->pSecurityDesc)
    {
        FreeSecurityDesc(this->pSecurityDesc,FALSE);
        DPMEM_FREE(this->pSecurityDesc);
        this->pSecurityDesc = NULL;
    }

    if (this->phCredential)
    {
        OS_FreeCredentialHandle(this->phCredential);
        DPMEM_FREE(this->phCredential);
        this->phCredential = NULL;
    }

    // free up user credentials
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }

    if (this->phContext)
    {
        OS_DeleteSecurityContext(this->phContext);
        DPMEM_FREE(this->phContext);
        this->phContext = NULL;
    }

    // cleanup CAPI stuff
    if (this->hPublicKey) 
    {
        OS_CryptDestroyKey(this->hPublicKey);
        this->hPublicKey = 0;
    }
    if (this->hServerPublicKey) 
    {
        OS_CryptDestroyKey(this->hServerPublicKey);
        this->hServerPublicKey = 0;
    }
    if (this->hEncryptionKey) 
    {
        OS_CryptDestroyKey(this->hEncryptionKey);
        this->hEncryptionKey = 0;
    }
    
    if (this->hDecryptionKey) 
    {
        OS_CryptDestroyKey(this->hDecryptionKey);
        this->hDecryptionKey = 0;
    }

    if (this->pPublicKey)
    {
	    DPMEM_FREE(this->pPublicKey);
	    this->pPublicKey = NULL;
    }

	// All objects contained in a crypt context must be released before 
	// freeing the context. Otherwise, it will cause handle leaks.
    if (this->hCSP) 
    {
        OS_CryptReleaseContext(this->hCSP,0);
        this->hCSP = 0;
    }

    // reset login state
    this->LoginState = DPLOGIN_NEGOTIATE;
    // reset the buffer sizes
    this->ulMaxContextBufferSize = 0;
    this->ulMaxSignatureSize = 0;

} // CloseSecurity


// Release a message node and any buffer that is stored on it.
VOID FreeMessageNode(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn)
{
	PSENDPARMS psp;
	DWORD dwType=0;

	if(pmsn->pMessage)
	{	
		dwType=(*((LPDPMSG_GENERIC)pmsn->pMessage)).dwType;

		// check for DPSYS_SENDCOMPLETE
		if (pmsn->idFrom == DPID_SYSMSG && dwType == DPSYS_SENDCOMPLETE)
		{
			DPF(8,"Freeing a DPSYS_SENDCOMPLETE message. pmsn == 0x%x", pmsn);
			psp=CONTAINING_RECORD(pmsn,SENDPARMS,msn);
			FreeSendParms(psp);
			// a-josbor: note, we don't free the pmsn because it's freed by FreeSendParams,
			//	according to aarono
		}
		else
		{
			DPMEM_FREE(pmsn->pMessage);
			DPMEM_FREE(pmsn);
		}
	}
	
	this->nMessages--;
}



// Note on closing of Retry and Keepalive thread.  The Retry and KeepAlive threads both do ENTER_ALL's
// in their processing path.  So when we wait for them to complete in DP_Close, we don't know if the
// interface pointer is still valid after we return (since we must drop both locks in order to wait or
// else we would deadlock).  So we flag that that part of shutdown is done and we go back to the top
// of DP_Close and revalidate the 'this' pointer before going on.

HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	LPDPLAYI_GROUP pGroup,pGroupNext;
	LPMESSAGENODE pmsg,pmsgNext;
	int nMessages=0;
    DWORD index;
    LPCLIENTINFO pClientInfo;
	HANDLE hPerfThread;
	HANDLE hPerfEvent;
	BOOL   fDidClose=FALSE;
	BOOL   bWaitForDplayThread=FALSE;

Top:
	ENTER_ALL();

	DPF(8, "DP_Close: Parameters: (0x%x)", lpDP);
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Notify the voice layer that the session is stopped.
    if( !this->fDidVoiceClose )
    {    
		this->fDidVoiceClose = TRUE;    
	    LEAVE_ALL();
		DVoiceNotify( this, DVEVENT_STOPSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );    
		goto Top;
    }

	if (!this->lpsdDesc) 
	{
		LEAVE_ALL();
		DPF_ERR("no session!");
		return DPERR_NOSESSIONS;
	}

	// rodtoll
	// Performing voice shutdown
	if( this->fLoadRetrofit )
	{
		DV_Retro_Stop( this );	
	}

	// stop the enum thread
	if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
	{
		StopEnumThread(this);
		bWaitForDplayThread=TRUE;
	} else {
		bWaitForDplayThread=FALSE;
	}

	// mark dplay as closed
	this->dwFlags |= DPLAYI_DPLAY_CLOSED;

	// if keep alives are on, turn 'em off
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE || bWaitForDplayThread)	
	{
		HANDLE hWait;
		this->dwFlags &= ~DPLAYI_DPLAY_KEEPALIVE;
		// tell thread to wake up and smell the new settings
		SetEvent(this->hDPlayThreadEvent);
		hWait=this->hDPlayThread;
		this->hDPlayThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hPerfThread){
		// drop the locks, in case our threads are blocked trying to get in
		hPerfThread=this->hPerfThread;
		hPerfEvent=this->hPerfEvent;
		this->hPerfThread=0;
		this->hPerfEvent=0;
		LEAVE_ALL();
		KillThread(hPerfThread,hPerfEvent);
		goto Top;
	}
	
	// first, destroy all local players except sysplayer
	// (sysplayer is last local player to be destroyed, since it
	// needs to send destroy messages)

	pPlayer=this->pPlayers;
	
	while (pPlayer)
	{
		pPlayerNext=pPlayer->pNextPlayer;
		// store next player now (so we don't blow it away...)
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{

			if(pPlayer != this->pSysPlayer){
				hr = InternalDestroyPlayer(this,pPlayer,TRUE,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				} else {
					pPlayerNext=this->pPlayers; // list may have been nuked, back to beginning.
				}	
			} else {
				DPF(0,"Just avoided nuking sysplayer w/o sysplayer flag set on it! this %x pPlayer %x\n",this,pPlayer);
				DEBUG_BREAK();
			}
		}
		pPlayer=pPlayerNext;
	}

	// destroy groups - note, this will also destroy the sysgroup...
	pGroup = this->pGroups;
	while (pGroup)
	{
		// store next Group now (so we don't blow it away...)
		pGroupNext = pGroup->pNextGroup;
		if (pGroup != this->pSysGroup) // destroy sysgroup later
		{
			hr = InternalDestroyGroup(this,pGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// since internaldestroygroup may have nuked > 1 group (sub-groups)
			// we reset to beginning of list
			pGroupNext =  this->pGroups;
		}
		pGroup = pGroupNext;
	}

    // security related cleanup
    if (SECURE_SERVER(this))
    {
        if (this->pSysPlayer && IAM_NAMESERVER(this))
        {
            // cleanup any lingering client info structures - this could happen
            // if nameserver gives out an id in response to a negotiate message 
            // and the client never comes back
            for (index=0; index < this->uiNameTableSize; index++)
            {
                if ((NAMETABLE_PENDING == this->pNameTable[index].dwItem))
                {
                    // is client info stored in here ?
                    pClientInfo = (LPCLIENTINFO) this->pNameTable[index].pvData;
                    if (pClientInfo)
                    {
                        RemoveClientInfo(pClientInfo);
                        // free up the memory
                        DPMEM_FREE(pClientInfo);
                    }
                }
            }
        }
    }

	// sysplayer should be only local player left
	// we could have a session w/ no sysplayer if it was 
	// opened enumonly
	if (this->pSysPlayer)
	{
		hr = InternalDestroyPlayer(this,this->pSysPlayer,TRUE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}// sysplayer
	this->pSysPlayer = NULL;

	// now, destroy sys group
	if (this->pSysGroup)
	{
			hr = InternalDestroyGroup(this,this->pSysGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	}
	this->pGroups = NULL;
	this->pSysGroup = NULL;


	// finally, destroy all non-local players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{

		// store next player now (so we don't blow it away...)
		pPlayerNext = pPlayer->pNextPlayer;

		ASSERT(!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL));
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}

		pPlayer = pPlayerNext;
	}
 	this->pPlayers = NULL;

	PACKETIZE_LOCK();

	// on IPX we need to give the sockets a chance to do their sending...
	if(!EMPTY_BILINK(&this->RetryList))
	{
		PACKETIZE_UNLOCK();
		Sleep(2500);
	} else {
		PACKETIZE_UNLOCK();
	}

	//
	// if the retry thread is running, shut it down.
	//
	if(this->hRetryThread){
		HANDLE hWait;
		SetEvent(this->hRetry);
		hWait=this->hRetryThread;
		this->hRetryThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hRetry){
		FiniPacketize(this); // cleans up handle and critical section.
	}	

	// notify sp
	// drop locks, in case sp needs has any threads blocked on handlemessage

	if(!fDidClose){
		
		// If this object is lobby-owned, call the lobby here
		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_ALL();
			
			hr = PRV_Close(this->lpLobbyObject);
			fDidClose=TRUE;
			
			goto Top;
		}
		else
		{
			if (this->pcbSPCallbacks->CloseEx) 
			{
				DPSP_CLOSEDATA cd;
				
				cd.lpISP = this->pISP;

				LEAVE_DPLAY();
	    		hr = CALLSP(this->pcbSPCallbacks->CloseEx,&cd);					
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;

			}
			else if (this->pcbSPCallbacks->Close) 
			{
				// dx3 sp's had a VOID arg list for shutdown
				LEAVE_DPLAY();
	    		hr = CALLSPVOID( this->pcbSPCallbacks->Close );
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;
	    		
			}
			else 
			{
				// no callback - no biggie
				hr = DP_OK;
			}
		}
		
		if (FAILED(hr)) 
	    {
			DPF(0,"Close session failed - hr = 0x%08lx\n",hr);
			// keep going...
	    }
	}
	

	// Shutdown the protocol if running.
	if(this->pProtocol){
		// need to NULL this->pProtocol before dropping lock.
		LPPROTOCOL_PART pProtocol=this->pProtocol;
		this->pProtocol=NULL;
		LEAVE_ALL();
		FiniProtocol(pProtocol);
		goto Top;
	}

	// get rid of any messages left in the apps q
	pmsgNext = this->pMessageList;
	DPF(0,"close - cleaning up %d messages\n",this->nMessages);
	while (pmsgNext)
	{
		pmsg = pmsgNext;
		pmsgNext = pmsg->pNextMessage;
		// free up this message node
		FreeMessageNode(this, pmsg);
	}
	ASSERT(0 == this->nMessages);
	this->pMessageList = NULL;
	this->pLastMessage = NULL;

    // the cleanup needs to happen after we are done sending secure messages 
    if (SECURE_SERVER(this))
    {
		CloseSecurity(this);
    }

	// free up the session desc
	if (this->lpsdDesc)
	{
        FreeDesc(this->lpsdDesc,FALSE);
        DPMEM_FREE(this->lpsdDesc);
    	this->lpsdDesc=NULL;
	} 

	// free up the name table
	if (this->pNameTable) DPMEM_FREE(this->pNameTable);
	this->pNameTable=NULL;
	this->uiNameTableSize = 0;
	this->uiNameTableLastUsed = 0;


	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		FreePendingList(this);		
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
	}

	// reset all session level flags
	this->dwFlags &= ~ (DPLAYI_DPLAY_SESSIONFLAGS);

	// reset the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
	
	while (this->pAddForwardList) FreeAddForwardNode(this,this->pAddForwardList);
	this->pAddForwardList = NULL;

	if(this->pTargetList){
		DPMEM_FREE(this->pTargetList);
	}

	if(this->pExpandedTargetList){
		DPMEM_FREE(this->pExpandedTargetList);
	}

	LEAVE_ALL();

	DPF(8, "Leaving DP_Close");

    return DP_OK;
        
}//DP_Close

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer/DP_CreateGroup"

// allocate player structure
HRESULT AllocatePlayer( LPDPLAYI_PLAYER * lplpPlayer)
{
    LPDPLAYI_PLAYER pPlayer;

    // alloc memory for the player
    pPlayer = DPMEM_ALLOC(sizeof(DPLAYI_PLAYER));
    
    if (!pPlayer) 
    {
		*lplpPlayer = NULL;
        DPF_ERR("player alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pPlayer->dwSize = sizeof(DPLAYI_PLAYER); // used to validate structure

    // return the new player
    *lplpPlayer = pPlayer;
    
    return DP_OK;
} // AllocatePlayer

// done w/ player data structure
HRESULT DeallocPlayer(LPDPLAYI_PLAYER lpPlayer) 
{
    if (!lpPlayer) return E_UNEXPECTED;
	if ((lpPlayer->hEvent) &&
		(lpPlayer->dwFlags & DPLAYI_PLAYER_CREATEDPLAYEREVENT))
	{
		CloseHandle(lpPlayer->hEvent);
	}
    if (lpPlayer->lpszShortName) DPMEM_FREE(lpPlayer->lpszShortName);
    if (lpPlayer->lpszLongName) DPMEM_FREE(lpPlayer->lpszLongName);
	if (lpPlayer->pvPlayerData) DPMEM_FREE(lpPlayer->pvPlayerData);
	if (lpPlayer->pvPlayerLocalData) DPMEM_FREE(lpPlayer->pvPlayerLocalData);

	// free it's sp data
	if (lpPlayer->pvSPData) DPMEM_FREE(lpPlayer->pvSPData);
	if (lpPlayer->pvSPLocalData) DPMEM_FREE(lpPlayer->pvSPLocalData);	

    // free security context and credential handle
    if (lpPlayer->pClientInfo) 
    {
        RemoveClientInfo(lpPlayer->pClientInfo);
        DPMEM_FREE(lpPlayer->pClientInfo);
        lpPlayer->pClientInfo = NULL;
    }

#ifdef DEBUG
    lpPlayer->lpszShortName= IntToPtr(0xBEEDBEBE);
    lpPlayer->lpszLongName= IntToPtr(0xBEEDBEBE); 
	lpPlayer->pvPlayerData= IntToPtr(0xBEEDBEBE); 
	lpPlayer->pvPlayerLocalData= IntToPtr(0xBEEDBEBE);
	lpPlayer->pvSPData= IntToPtr(0xBEEDBEBE);
	lpPlayer->pvSPLocalData= IntToPtr(0xBEEDBEBE);
#endif 		

    lpPlayer->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory
    DPMEM_FREE(lpPlayer);

    return DP_OK;

} // DeallocPlayer

// call sp's create player callback
// called by GetPlayer and UnpackPlayerList
HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageHeader, DWORD cbSPDataSize, BOOL bNotifyProtocol)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEPLAYERDATA cpd;

    if (this->pcbSPCallbacks->CreatePlayer || (bNotifyProtocol && this->pProtocol)) 
    {
	    // call sp
		memset(&cpd,0,sizeof(cpd));
	    cpd.idPlayer = pPlayer->dwID;
		cpd.lpSPMessageHeader = pvSPMessageHeader;
		cpd.dwFlags = pPlayer->dwFlags;
		cpd.lpISP = this->pISP;
		cpd.cbSPDataSize = cbSPDataSize;

		if(bNotifyProtocol && this->pProtocol){
			hr = ProtocolCreatePlayer(&cpd); // calls SP too.
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->CreatePlayer,&cpd);	    	
		}    
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create player failed - hr = 0x%08lx\n",hr);
			return hr;
	    }
    }
	else 
	{
		// its ok if the sp doesn't implement this...
	}

	return hr;

} // CallSPCreatePlayer


/*
 ** GetPlayer	
 *
 *  CALLED BY:	InternalCreatePlayer,unpack player list and handledeadnameserver.
 *
 *  PARAMETERS:
 *		this - dplay object
 *		ppPlayer - pointer to player to create. return value
 *		pName - strings
 *		phEvent - handle to receive event
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *      dwFlags - player flags
 *      lpszPassword - session password, if creating a system player. NULL otherwise.
 *		dwLobbyID -- ID of the player in a lobby sesssion, assigned by the lobby server
 *
 *  DESCRIPTION: Creates the player. Allocs the player structure,and sets the data and calls the 
 *		sp (and adds to nametable) if local.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or sp scode
 *
 */
HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpszSessionPassword, DWORD dwLobbyID)
{
    HRESULT hr = DP_OK;
    DWORD id=0;
	LPDPLAYI_PLAYER pLastPlayer;

	
	DPF(8, "GetPlayer: Parameters:(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, %u, 0x%x, 0x%x, %u)",
		this, ppPlayer, pName, hEvent, pvData, dwDataSize, dwFlags, lpszSessionPassword, dwLobbyID);

    // a-josbor: First thing: decrement our reservation count if it's a
    //	remote player.  We want to do this even if there is an error
    //	creating the player
    if (IAM_NAMESERVER(this) && !(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
    	if (this->dwPlayerReservations > 0)	// just in case...
    		this->dwPlayerReservations--;
    }


    // allocate / initialize a dplayi_player structure
    hr = AllocatePlayer( ppPlayer );
    if (FAILED(hr)) 
    {
    	return hr;
    }

	// update player fields
    (*ppPlayer)->lpDP = this;
    (*ppPlayer)->dwFlags = dwFlags;
    (*ppPlayer)->hEvent = hEvent;	
	(*ppPlayer)->nPendingSends = 0;
	InitBilink(&((*ppPlayer)->PendingList));
	
	// set up the name
	hr = DoPlayerName(*ppPlayer,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData(*ppPlayer,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

     // if it's the app server, remember it
    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
    {
    	this->pServerPlayer = (*ppPlayer);
    }

     // if it's the name server, remember it
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"creating name server");
		this->pNameServer = (*ppPlayer);
	}

	// add local player to name table.  
	// if its not local, unpack will add it for us, 
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
	    // if it's the app server, use the reserved appplayer id
	    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
	    {
		    (*ppPlayer)->dwID = DPID_SERVERPLAYER;
	    }
	    else 
	    {
		    // get a player id, add player to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppPlayer),&id,TRUE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }
		    
			(*ppPlayer)->dwID = id;
	    }

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppPlayer)->dwIDSysPlayer = this->pSysPlayer->dwID;
			(*ppPlayer)->dwCreateTime = timeGetTime();
		}
		
		(*ppPlayer)->dwVersion = DPSP_MSG_VERSION;
		
		// give sp a pop at the player...
		hr = CallSPCreatePlayer(this,*ppPlayer,TRUE,NULL,0,TRUE);
		if (FAILED(hr))
		{
			FreeNameTableEntry(this,id);
			goto ERROR_EXIT;
		}

		// notify all local and remote players of new player
		// unpack will send create messages for non-local players...
		hr = SendCreateMessage( this, *ppPlayer,TRUE, lpszSessionPassword);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// hmmm, what to do with a failure here?
			// keep going...
			hr = DP_OK;
		}

		// add player to system group.
		// unpack will do this for non-local players
		if (this->pSysGroup)
		{
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			(*ppPlayer)->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
		}

	}  // local

	// new sysplayers go on the front of the list
	// this is so when we unpack players and add them to the system group, we always
	// need to unpack system players first...
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// slap 'em on the front
		(*ppPlayer)->pNextPlayer = this->pPlayers;
		this->pPlayers = *ppPlayer;
	}
	else 
	{
		// put new non-sysplayer at the back of the list
		pLastPlayer = this->pPlayers;
		if (!pLastPlayer) 
		{
			this->pPlayers = (*ppPlayer);
		}
		else 
		{
			// find the last system player in the list - insert our new 
			// player behind it...
			while ((pLastPlayer->pNextPlayer) 
				&& (pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
			{
				pLastPlayer = pLastPlayer->pNextPlayer;		
			}
			ASSERT(pLastPlayer);
			// also, if there's a dx3 in the session, the list may be out of order
			if(!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
			{
				ASSERT(pLastPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
				if(pLastPlayer->pNextPlayer)
				{
					ASSERT(!(pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER));
				}
			}
			(*ppPlayer)->pNextPlayer = pLastPlayer->pNextPlayer;
			pLastPlayer->pNextPlayer = (*ppPlayer);
		}
	}

	if (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		this->lpsdDesc->dwCurrentPlayers++;
	}

	this->nPlayers++;
	
	DPF(8, "GetPlayer: Returning DP_OK", hr);

	// SUCCESS
    return hr;

ERROR_EXIT:
	
	DPF(0,"*****	GetPlayer failed - hr = 0x%08lx !!!\n",hr);
	DeallocPlayer(*ppPlayer);
	*ppPlayer = NULL;
	return hr;
    	
} // GetPlayer


HRESULT AllocGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP * ppGroup)
{

    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP pGroup;

    // alloc memory for the group
    pGroup = DPMEM_ALLOC(sizeof(DPLAYI_GROUP));
    
    if (!pGroup) 
    {
        DPF_ERR("group alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pGroup->dwSize = sizeof(DPLAYI_GROUP); // used to validate structure

    // return the new group
    *ppGroup = pGroup;
    			
    return hr;

} // AllocGroup

HRESULT DeallocGroup(LPDPLAYI_GROUP lpGroup) 
{
    if (lpGroup->lpszShortName) DPMEM_FREE(lpGroup->lpszShortName);
    if (lpGroup->lpszLongName) DPMEM_FREE(lpGroup->lpszLongName);
	if (lpGroup->pvPlayerData) DPMEM_FREE(lpGroup->pvPlayerData);
	if (lpGroup->pvPlayerLocalData) DPMEM_FREE(lpGroup->pvPlayerLocalData);

    lpGroup->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory	
    DPMEM_FREE(lpGroup);

    return DP_OK;
    
} // DeallocGroup

// call sp's create group callback
// called by GetGroup and UnpackGroupList
HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageHeader, DWORD cbSPDataSize)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEGROUPDATA cgd;

	if (this->dwFlags & DPLAYI_DPLAY_DX3INGAME)
	{
		// no optimized groups w/ dx3
		hr = E_NOTIMPL;
	}
    else if (this->pcbSPCallbacks->CreateGroup) 
    {
	    // call sp
		memset(&cgd,0,sizeof(cgd));
	    cgd.idGroup = pGroup->dwID;
		cgd.lpSPMessageHeader = pvSPMessageHeader;
		cgd.dwFlags = pGroup->dwFlags;
		cgd.lpISP = this->pISP;
		cgd.cbSPDataSize = cbSPDataSize;

	    hr = CALLSP(this->pcbSPCallbacks->CreateGroup,&cgd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create group failed - hr = 0x%08lx\n",hr);
	    }

    }
	else 
	{
		// if they don't support it - dplay will emulate it
		hr = E_NOTIMPL;
	}

	if (FAILED(hr))
	{
		// the SP couldn't do it.  mark group as owned by dplay.
		pGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
	}
	
	return DP_OK;

} // CallSPCreateGroup

// called by DP_CreateGroup and UnpackPlayerAndGroupList
// actually creates the group.
// todo - make this and getplayer use the same code!
HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID)
{
	HRESULT hr;
	DWORD id;
	LPDPLAYI_GROUP pLastGroup; // stick new groups on end
	
    // create a group
    hr = AllocGroup(this, (LPDPLAYI_GROUP *)ppGroup);
    if (FAILED(hr)) 
    {
        return hr;
    }

	// set up the name
	hr = DoPlayerName((LPDPLAYI_PLAYER)*ppGroup,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData((LPDPLAYI_PLAYER)*ppGroup,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// store the flags
	(*ppGroup)->dwFlags = dwFlags;
    (*ppGroup)->lpDP = this;
   	(*ppGroup)->dwIDParent = idParent;
	
	if ((*ppGroup)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)  
	{
		if ((*ppGroup)->dwFlags & DPLAYI_GROUP_SYSGROUP)
		{
			// use the reserved id for the system group
			(*ppGroup)->dwID = DPID_ALLPLAYERS;
		}
		else 
		{
		    // get a Group id, add Group to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppGroup),&id,FALSE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }

			(*ppGroup)->dwID = id;
		}
		

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppGroup)->dwIDSysPlayer = this->pSysPlayer->dwID;
		}

		(*ppGroup)->dwVersion = DPSP_MSG_VERSION;
		
		// tell sp about group
		hr = CallSPCreateGroup(this,*ppGroup,TRUE,NULL,0);
		if (FAILED(hr))
		{
			// make group dplay owned
			(*ppGroup)->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
		}

		// don't send create message if it's the system group
		if (!(dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// notify all local and remote players of new group
			// unpack will send create messages for non-local groups...
			hr = SendCreateMessage( this, *ppGroup,FALSE,NULL);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// hmmm, what to do with a failure here?
				// keep going...
				hr = DP_OK;
			}
		}

	}  // local

	// andyco - DX5 - new groups go on back

	if (this->pGroups) // empty list?
	{
		pLastGroup = this->pGroups;	
		// find the last one
		while (pLastGroup->pNextGroup)
		{
			 pLastGroup = pLastGroup->pNextGroup;
		}
		// found the end, stick the new group on
		ASSERT(pLastGroup);
		pLastGroup->pNextGroup = *ppGroup;
	}
	else 
	{
		this->pGroups = *ppGroup;
	}
	
	this->nGroups++;    

	return hr;

ERROR_EXIT:

	DPF(0,"*** GetGroup failed - hr = 0x%08lx\n",hr);
	DeallocGroup(*ppGroup);
	return hr;

} // GetGroup	


void MakeLocalPlayerGroupOwner(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpOwner)
{
	LPDPLAYI_GROUPOWNER		lpOwnerNode = NULL;


	ASSERT(lpGroup);

	// If we don't have a player, just make the server player own the group
	if(!lpOwner)
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;

	// Allocate memory for the owner node
	lpOwnerNode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPOWNER));
	if(!lpOwnerNode)
	{
		DPF_ERR("Unable to allocate memory for groupowner node");
		// So just set the group's owner to DPID_SERVERPLAYER
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;
		return;
	}

	// Setup the node
	lpOwnerNode->pGroup = lpGroup;

	// Add it to the list
	lpOwnerNode->pNext = lpOwner->pOwnerGroupList;
	lpOwner->pOwnerGroupList = lpOwnerNode;

	// Set the group's owner ID
	lpGroup->dwOwnerID = lpOwner->dwID;

} // MakeLocalPlayerGroupOwner


/*
 ** InternalCreatePlayer	
 *
 *  CALLED BY:	DP_CreatePlayer,DP_CreateGroup,
 *
 *  PARAMETERS:
 *		lpDP - dplay interface pointer
 *		pid -  player / group id - return value
 *		pName - strings
 *		phEvent - handle to receive event. NULL for groups
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *		dwCreateFlags - dwFlags passed to create fn.
 *
 *  DESCRIPTION: validates params for DP_CreatePlayer/Group.
 *				calls GetPlayer or GetGroup to create + set up
 *				the player or group.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or GetPlayer/Group error code.
 *
 */

// assumes service + dplay lock taken!
HRESULT InternalCreatePlayer(LPDIRECTPLAY lpDP, LPDPID pid,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,BOOL fPlayer,DPID idParent)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DWORD dwPlayerFlags;
	LPWSTR lpszShortName,lpszLongName;
	LPDPLAYI_PLAYER lpPlayer=NULL;
	LPDPLAYI_GROUP lpGroup=NULL;
	LPDPLAYI_PLAYER lpRandomPlayer=NULL;
	DPID idOwner;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc) 
		{
			DPF_ERR("must join session before creating players");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DWORD_PTR(pid))
		{
			DPF_ERR("invalid pid pointer");
			return DPERR_INVALIDPARAMS;
		}
        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}
		// check event handle
		if ((hEvent) && (!OS_IsValidHandle(hEvent)))
		{
	        DPF_ERR( "bad event handle" );
	        return DPERR_INVALIDPARAMS;
		}		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}

		if (fPlayer)
		{
			// check player flags
			if (!VALID_CREATEPLAYER_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		else
		{
			// check group flags
			if (!VALID_CREATEGROUP_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		
		// only nameserver can create serverplayer
		if ( (dwFlags & DPPLAYER_SERVERPLAYER) && !(IAM_NAMESERVER(this)) )
		{
			DPF_ERR("only host can create server player");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// see if we're allowed to create a player
	if (fPlayer)
	{
		if ( this->lpsdDesc->dwMaxPlayers ) 
		{
			if (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers )
			{
				DPF(1,"can't create new player - exceeded dwMaxPlayers");
				return DPERR_CANTCREATEPLAYER;
			}
		}
		if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
		{
			DPF_ERR("can't create new player - DPSESSION_NEWPLAYERSDISABLED");
			return DPERR_CANTCREATEPLAYER;
		}
		// in a client server session, the session host (server) can't create
		// any players other than the DPID_SERVERPLAYER
		if ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) && 
			(IAM_NAMESERVER(this)) && !(dwFlags & DPPLAYER_SERVERPLAYER) )
		{
			DPF_ERR(" session host can only create DPPLAYER_SERVERPLAYER");
			return DPERR_ACCESSDENIED;
		}
	}

	// If this object is lobby-owned, do the server stuff and take
	// care of the rest of the nametable stuff from the lobby code.
	if(IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock so the lobby's receive thread can
		// get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_CreatePlayer(this->lpLobbyObject, pid, pName, hEvent,
								pvData, dwDataSize, dwFlags);
		}
		else
		{
			// If it's a group, someone on this machine needs to be the group
			// owner, so just randomly pick a local player.  If there aren't
			// any local players, make the server player be the owner.
			lpRandomPlayer = GetRandomLocalPlayer(this);
			idOwner = (lpRandomPlayer ? lpRandomPlayer->dwID : DPID_SERVERPLAYER);
			
			// If there is a parent ID, then this is a CreateGroupInGroup call
			if(idParent)
			{
				hr = PRV_CreateGroupInGroup(this->lpLobbyObject, idParent,
						pid, pName,	pvData, dwDataSize, dwFlags, idOwner);
			}
			else
			{
				hr = PRV_CreateGroup(this->lpLobbyObject, pid, pName,
						pvData, dwDataSize, dwFlags, idOwner);
			}

			// Store the owner in the group, and create a reference node in the player
			if(SUCCEEDED(hr))
			{
				// Get the player the lobby just created
				lpGroup = GroupFromID(this, *pid);
				if(lpGroup)
					MakeLocalPlayerGroupOwner(this, lpGroup, lpRandomPlayer);
			}
		}
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating player or group on the lobby, hr = 0x%08x", hr);
		}

		// Since all of the work below is already done by the lobby,
		// we can exit here.
		return hr;
	}

	// go get a player
	dwPlayerFlags =  DPLAYI_PLAYER_PLAYERLOCAL;
	
	if (dwFlags & DPPLAYER_SERVERPLAYER)
	{
		if (this->pServerPlayer)
		{
			DPF_ERR("server player already exists");
			return DPERR_CANTCREATEPLAYER;
		}
		// else
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;
	}

	if (dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	if (dwFlags & DPGROUP_STAGINGAREA)
		dwPlayerFlags |= DPLAYI_GROUP_STAGINGAREA;

	if(dwFlags & DPGROUP_HIDDEN)
		dwPlayerFlags |= DPLAYI_GROUP_HIDDEN;

	if (fPlayer)
	{
	    hr = GetPlayer(this, &lpPlayer,pName,hEvent,pvData,dwDataSize,dwPlayerFlags,NULL,0);
	}
	else 
	{
	    hr = GetGroup(this, &lpGroup,pName,pvData,dwDataSize,dwPlayerFlags,idParent,0);
	}
    if (FAILED(hr)) 
    {
		DPF(0,"Create player / group failed - hr = 0x%08lx\n",hr);
		if (hr == DPERR_TIMEOUT)
			hr = DPERR_CANTCREATEPLAYER;
        return hr;
    }

	// Check to ensure it's a player before we start the 
	// retrofit, don't start in a group create or system
	// player create.
	//
	if( lpPlayer && !(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) )
	{
		if ( ((this->lpLaunchingLobbyObject)?(this->lpsdDesc->dwFlags&DPSESSION_ALLOWVOICERETRO):TRUE) &&
			 (LookupVoiceRetrofitFlag(&this->lpsdDesc->guidApplication) ) && 
			 (memcmp( &this->pspNode->guid,&DPSPGUID_TCPIP, sizeof( GUID ) ) == 0 ) )
		{
		    this->fLoadRetrofit = TRUE;
			DPF(1, "Retrofit flag detected: Calling DV_Retro_Start");
			DV_Retro_Start( this );
		}
		else
		{
		    this->fLoadRetrofit = FALSE;		
			DPF(1, "Retrofit flag NOT detected: NOT Calling DV_Retro_Start");
			DPF(1, "OR Non-TCP provider specified" );
		}
	}
	
	// store the return value
	if (fPlayer) *pid = lpPlayer->dwID;
	else *pid = lpGroup->dwID;

	if (hr == DPERR_TIMEOUT)
		hr = DPERR_CANTCREATEPLAYER;

	return hr;
} // InternalCreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer"
HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidPlayerID,pName,hEvent,pvData,
		dwDataSize,dwFlags,TRUE,0) ;

	LEAVE_ALL();		
	
	return hr;

}// DP_CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroup"
HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,0) ;

	LEAVE_ALL();
	
	return hr;
        
} // DP	_CreateGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroupInGroup"

HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT			hr;
	LPDPLAYI_GROUP	pGroup = NULL;
	LPDPLAYI_DPLAY	this = NULL;


	ENTER_ALL();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// We must have a valid parent -- zero is not a valid parent.
	    pGroup = GroupFromID(this,idParentGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idParentGroup)) 
	    {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idParentGroup);
	        return DPERR_INVALIDGROUP;
	    }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// go get the group
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,idParentGroup) ;
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not create group - hr = 0x%08lx\n",hr);
		goto CLEANUP_EXIT;
	}

	// add group to group
	hr = InternalAddGroupToGroup(lpDP,idParentGroup,*pidGroupID,dwFlags,TRUE);	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
		DP_DestroyGroup(lpDP,*pidGroupID);
		*pidGroupID = 0;
	}

	// fall through

CLEANUP_EXIT:		
	
	LEAVE_ALL();
	
	return hr;
        
} // DP_CreateGroupInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeleteGroupFromGroup"

// delete lpGroupRemove from lpGroup
HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove)
{
    HRESULT hr=DP_OK;
	LPDPLAYI_SUBGROUP lpSubgroup,lpSubgroupPrev=NULL;
    BOOL bFoundIt=FALSE;

	lpSubgroup = lpGroup->pSubgroups;
	
    // find the groupnode corresponding to this player
    while ( (lpSubgroup) && (!bFoundIt))
    {
        if (lpSubgroup->pGroup == lpGroupRemove) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpSubgroupPrev) 
            {
                // remove groupnode from beginning of list
            	lpGroup->pSubgroups = lpSubgroup->pNextSubgroup;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpSubgroupPrev->pNextSubgroup = lpSubgroup->pNextSubgroup;
            }
        } 
		else 
		{
			// check next node
	        lpSubgroupPrev = lpSubgroup;
	        lpSubgroup = lpSubgroup->pNextSubgroup;
		}        
    } // while

    if (bFoundIt) 
    {
		lpGroup->nSubgroups--;		// one less group in this group			

		// free up groupnode
    	DPMEM_FREE(lpSubgroup);

        lpGroupRemove->nGroups--;
        if (0 == lpGroupRemove->nGroups) 
        {
            // mark player as not in any group
            lpGroupRemove->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		// this can happen - e.g. group deleted, etc. off the wire
		DPF(4,"could not remove group from group - player id %d not found in group id %d\n",
				lpGroup->dwID,lpGroupRemove->dwID);
    	hr = E_FAIL; 
    }
    
    return hr;
} // RemoveGroupFromGroup

HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUP lpGroupFrom; 	
	
	DPF(5,"deleting group id %d from group id %d - propagate = %d",idGroup,idGroupFrom,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
        lpGroupFrom = GroupFromID(this,idGroupFrom);
        if ((!VALID_DPLAY_GROUP(lpGroupFrom)) || (DPID_ALLPLAYERS == idGroupFrom)) 
        {
			DPF(0, "invalid Group From id -- idGroupFrom = %lx", idGroupFrom);
            return DPERR_INVALIDGROUP;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First, if this is a parent/child relationship, then the fPropagate flag must be
	// set to FALSE because we never give out DeleteGroupInGroup messages for
	// real subgroups (non-shortcuts).  Bug #15264.
	if(lpGroup->dwIDParent == lpGroupFrom->dwID)
		fPropagate = FALSE;

    hr = RemoveGroupFromGroup(lpGroupFrom,lpGroup);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote group and we dont want to call it back
	// in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeleteGroupFromGroup(this->lpLobbyObject, idGroupFrom, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting group from group on the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

    // don't bother telling people about the sysgroup or system players
    if (fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUPFROMGROUP, idGroup, 
			idGroupFrom);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

    return hr;
	
} // InternalDeleteGroupFromGroup

HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
	

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
		// Make sure this is a shortcut and not a parent-child (bug #8396)
		if((lpGroup->dwIDParent == idGroupFrom))
		{
			LEAVE_ALL();
			DPF_ERR("Cannot delete a child group from it's parent, please use DestroyGroup");
			return DPERR_ACCESSDENIED;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	hr = InternalDeleteGroupFromGroup(lpDP, idGroupFrom,idGroup,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeleteGroupFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeletePlayerFromGroup"

// delete lpPlayer from lpGroupnode. called by DP_DeletePlayerFromGroup
// returns DP_OK or E_FAIL if player isn't in group
HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_PLAYER lpPlayer)
{
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodePrev = NULL;
    BOOL bFoundIt=FALSE;
	LPDPLAYI_GROUPNODE * ppRootGroupnode;
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pSysPlayerGroupnodes);
	}
	else 
	{
		lpGroupnode = lpGroup->pGroupnodes;		
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pGroupnodes);		
	}
	
    // find the groupnode corresponding to this player
    while ( (lpGroupnode) && (!bFoundIt))
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpGroupnodePrev) 
            {
                // remove groupnode from beginning of list
            	*ppRootGroupnode = lpGroupnode->pNextGroupnode;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpGroupnodePrev->pNextGroupnode = lpGroupnode->pNextGroupnode;
            }
        } // (lpGroupnode->pPlayer == lpPlayer) 
		else 
		{
			// check next node
	        lpGroupnodePrev=lpGroupnode;
	        lpGroupnode = lpGroupnode->pNextGroupnode;
		}        
    } // while

    if (bFoundIt) 
    {
		if (!(DPLAYI_PLAYER_SYSPLAYER & lpPlayer->dwFlags))
		{
			// only dec the player count on non-system players
			lpGroup->nPlayers--;		// one less player in this group			
		}


		// free up groupnode
    	DPMEM_FREE(lpGroupnode);

        lpPlayer->nGroups--;
        if (0==lpPlayer->nGroups) 
        {
            // mark player as not in any group
            lpPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		DPF(4,"could not remove player from group - player id %d not found in group id %d\n",
				lpPlayer->dwID,lpGroup->dwID);
    	hr = DPERR_INVALIDPLAYER; 
    }
    
    return hr;
} // RemovePlayerFromGroup

HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
	DPSP_REMOVEPLAYERFROMGROUPDATA data;
	LPDPLAYI_GROUPNODE pSysGroupnode;
	
	DPF(5,"deleting player id %d from group id %d - propagate = %d",idPlayer,idGroup,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);

        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

//	a-josbor: tell the SP that we have removed this player from the group
	// only do this if we have an SP that is DX6 or later!
	if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
	{
		if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
			&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		{
			data.idPlayer = lpPlayer->dwID;
			data.idGroup = lpGroup->dwID;        
			data.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		}
		else 
		{
			// no callback - no biggie
		}
		if (FAILED(hr)) 
		{
			DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		}
	}
	
//	now do the actual removal
    hr = RemovePlayerFromGroup(lpGroup,lpPlayer);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

    // don't bother telling people about the sysgroup or system players
    if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && !(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		&& fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYERFROMGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

	// update the system player groupnode.
 	pSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);
	if (pSysGroupnode)
	{
		pSysGroupnode->nPlayers--;
		// when this goes to 0, remove the system player from the group
	    // notify sp if we need to (notify both pre and post DX6 SPs)
		if (pSysGroupnode->nPlayers == 0 && !(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		    {
				data.idPlayer = pSysGroupnode->pPlayer->dwID;
				data.idGroup = lpGroup->dwID;        
				data.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		    }
			else 
			{
				// no callback - no biggie
			}
		    if (FAILED(hr)) 
		    {
				DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		    }

		    hr = RemovePlayerFromGroup(lpGroup,pSysGroupnode->pPlayer);
		    if (FAILED(hr)) 
		    {
				ASSERT(FALSE);
		    }

		}
	}

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote player and we dont want to call it back
	// in that case.  OR if the group is the system group, we don't want to
	// call the lobby
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (idGroup != 0))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeletePlayerFromGroup(this->lpLobbyObject, idGroup, idPlayer);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting player from group on the lobby, hr = 0x%08x", hr);
			
			// If this failed, we need to add the player back into the group
			InternalAddPlayerToGroup(lpDP, idGroup, idPlayer, FALSE);
		}
	}

    return DP_OK;
	
} // InternalDeletePlayerFromGroup

HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();

	if (DPID_ALLPLAYERS == idGroup)
	{
		DPF_ERRVAL("invalid group id = %d", idGroup);
		LEAVE_ALL();
		return DPERR_INVALIDGROUP;
	}

	hr = InternalDeletePlayerFromGroup(lpDP, idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeletePlayerFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyPlayer"

/*
 ** RemovePlayerFromGroups
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeletePlayerFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemovePlayerFromGroups(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroup;
    LPDPLAYI_GROUPNODE_V lpNodes;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroup=this->pGroups;

    	while (lpGroup && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP) )
    	{
	 		if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				lpNodes = lpGroup->pSysPlayerGroupnodes;
			}
			else
			{
				lpNodes = lpGroup->pGroupnodes;
			}

	   		if (FindPlayerInGroupList(lpNodes,lpPlayer->dwID))
    		{
	        	// this fn. will attempt to remove player from group.
	            // (if players not in group, no big deal).
	            // when player is removed from all groups, DP_DeletePlayerFromGroup
	            // resets DPLAYI_FLAGS_PLAYERINGROUP
	        	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroup->dwID,lpPlayer->dwID,fPropagate);
				// ISSUE:  If the remove fails, we could get hosed in an infinite loop
				//		so we just move on to the next group
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeletePlayerFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...

					lpGroup = lpGroup->pNextGroup;
				}
				else
				{
					lpGroup = this->pGroups;
				}
			}
			else
			{
	        	lpGroup=lpGroup->pNextGroup;
	        }
	    }	
    }
    return DP_OK;
        
} // RemovePlayerFromGroups

/*
 ** RemovePlayerFromPlayerList
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: takes player out of dplay objects list of players
 *
 *  RETURNS: DP_OK unless player is not in list
 *
 */

HRESULT RemovePlayerFromPlayerList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer) 
{
    LPDPLAYI_PLAYER pRefPlayer,pPrevPlayer;
    BOOL bFoundIt=FALSE;
    
    pRefPlayer=this->pPlayers;
    pPrevPlayer=NULL;
    
    
    while ( (pRefPlayer) && (!bFoundIt))
    {
        if (pRefPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            if (!pPrevPlayer)
            {
                // remove from front of list
            	this->pPlayers=pRefPlayer->pNextPlayer;
            }
            else
            {
            	// remove this player from the middle (or end) of list
  	        	pPrevPlayer->pNextPlayer = pRefPlayer->pNextPlayer;
            }
        }

        pPrevPlayer=pRefPlayer;
        pRefPlayer = pRefPlayer->pNextPlayer;
    }

    if (!bFoundIt) 
    {
    	ASSERT(FALSE);
    	DEBUG_BREAK();
    	return E_UNEXPECTED;	
    }
    return DP_OK;
}	// RemovePlayerFromPlayerList


void RemoveOwnerFromGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpPlayer, BOOL fPropagate)
{
	LPDPLAYI_GROUPOWNER		lpNode, lpPrev = NULL;
	HRESULT					hr;

	ASSERT(lpGroup);
	ASSERT(lpPlayer);

	lpNode = lpPlayer->pOwnerGroupList;

	// Walk the list of groups in the player's list
	while(lpNode)
	{
		if(lpNode->pGroup == lpGroup)
		{
			// Remove the node from the list
			if(lpPrev)
				lpPrev->pNext = lpNode->pNext;
			else
				lpPlayer->pOwnerGroupList = lpNode->pNext;

			// Now free the node
			DPMEM_FREE(lpNode);
			lpNode = NULL;
		}
		else
		{
			// Move to the next node
			lpPrev = lpNode;
			lpNode = lpNode->pNext;
		}
	}

	// If the player is local, and the group is local, we want to set the
	// owner of the group to be the server player.  If the player is remote,
	// or if the gorup is remote, we don't
	// want to touch it, because they may not really be going away, they
	// may only be getting purged from the nametable due to our
	// nametable partitioning algorithm.
	// Also, make sure the propagate flag is set, otherwise we don't
	// need to tell the server or the other players at all (this happens
	// if the group is being destroyed)
	if(fPropagate && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Change the owner of the group to the server player
		hr = DPL_SetGroupOwner((LPDIRECTPLAY)this->pInterfaces, lpGroup->dwID,
				DPID_SERVERPLAYER);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to set group owner to DPID_SERVERPLAYER, hr = 0x%08x", hr);
		}

		// Take the lock back
		ENTER_DPLAY();
	}

} // RemoveOwnerFromGroup

// Completes all pending sends from a player right away.
VOID CompletePendingSends(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	BILINK *pBilink;
	PSENDPARMS psp, pspcopy;

	pBilink=pPlayer->PendingList.next;
	while(pBilink!=&pPlayer->PendingList){
		psp=CONTAINING_RECORD(pBilink, SENDPARMS, PendingList);
		pBilink=pBilink->next;
		
		Delete(&psp->PendingList);
		InitBilink(&psp->PendingList);
		pspcopy=GetSendParms(); // allocates send parm, sets refcount to 1.
		if(pspcopy){
			DPF(5,"Queueing completion of send psp %x not really yet completed, using copy %x\n",psp, pspcopy);
			memcpy(&pspcopy->PendingList, &psp->PendingList, sizeof(SENDPARMS)-offsetof(SENDPARMS,PendingList));
			InitBilink(&pspcopy->PendingList);
			pspcopy->hr=DPERR_INVALIDPLAYER;
			pspcopy->dwSendCompletionTime=timeGetTime();
			QueueSendCompletion(this, pspcopy);
		}
	}
}

/*
 ** InternalDestroyPlayer
 *
 *  CALLED BY:	DP_DestroyPlayer,KillPlayer (from ping.c)
 *
 *  PARAMETERS: 
 *				lpPlayer - player we want killed
 *				fPropagate - if we're called from KillPlayer (ping.c) and we want
 *					to remove the player from the global nametable, this is TRUE
 *				fLookForNewNS - if this is the Nameserver, whether or not to look for another
 *  DESCRIPTION:
 *				kills the player
 *
 *  RETURNS:
 *				pretty much DP_OK
 *
 */
HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate,BOOL fLookForNewNS) 
{
    HRESULT hr = DP_OK;
    DPSP_DELETEPLAYERDATA dd;
	BOOL fNameServer = lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR;
	BOOL fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	DPID dwPlayerID;

	ASSERT(lpPlayer != NULL);
	
	#ifdef DEBUG
	if(lpPlayer->nPendingSends){
		DPF(0,"WARNING:Destroying player with %d pending sends...\n",lpPlayer->nPendingSends);
	}
	#endif
	
	DPF(5,"destroying player - id = %d\n",lpPlayer->dwID);
	DPF(5,"local = %d, nameserver = %d", fLocal, fNameServer);

	if (lpPlayer == this->pSysPlayer)
	{
		// it's only leagal to delete the Sys player if we're closing
		ASSERT(this->dwFlags & DPLAYI_DPLAY_CLOSED);
		if (!(this->dwFlags & DPLAYI_DPLAY_CLOSED))
			return DPERR_GENERIC;
	}
	
	dwPlayerID=lpPlayer->dwID;

	DPF(8,"In InternalDestroyPlayer, calling CompletePendingSends...\n");
	CompletePendingSends(this,lpPlayer);

	// If this is a lobby object, call the lobby code instead of calling
	// a dplay SP.  The CALLSP code which follows will not get executed
	// since the callback will not exist for a lobby-owned object.  However,
	// if the fPropagate flag is cleared, it means the lobby called us
	// for a remote player, so don't call it back.  Don't call the lobby
	// if it is a system player either.
	if((IS_LOBBY_OWNED(this)) && (fPropagate) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyPlayer(this->lpLobbyObject, lpPlayer->dwID);
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy player, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemovePlayerFromGroups (and InternalDelete-
			// PlayerFromGroup), because it will fail since the lobby has
			// already deleted the player.
			fPropagate = FALSE;
		}
	}

	if(lpPlayer->dwFlags & DPLAYI_PLAYER_BEING_DESTROYED){
		return DPERR_INVALIDPLAYER;
	} else {
		lpPlayer->dwFlags |= DPLAYI_PLAYER_BEING_DESTROYED;
	}	

	// remove player from any groups
	hr = RemovePlayerFromGroups(this,lpPlayer,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	// call the sp
	if (this->pcbSPCallbacks->DeletePlayer || this->pProtocol)
	{
		// call sp
		dd.idPlayer = lpPlayer->dwID;
		dd.dwFlags = lpPlayer->dwFlags; 
		dd.lpISP = this->pISP;

		ASSERT(gnDPCSCount==1);

		if(this->pProtocol){
			hr = ProtocolDeletePlayer(&dd); 
		} 
		
		if(this->pcbSPCallbacks->DeletePlayer){
	    	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
			if (FAILED(hr)) 
			{
				DPF_ERR(" SP could not delete player!!"); 
			}
	    }	

	}
	else 
	{
		// sp doesn't need to implement this one...
	}
	
    // remove player from player list
    hr = RemovePlayerFromPlayerList(this,lpPlayer);
	this->nPlayers--;
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER, lpPlayer->dwID, 
			0);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		// could have lost player pointer in SendPlayerManagementMessage, re-establish
		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during propogation of Delete\n",dwPlayerID);
			goto EXIT;
		}
	}

	
	// app server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		DPF(4,"destroying app server");
		this->pServerPlayer = NULL;
	}

	// name server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"destroying name server");
		this->pNameServer = NULL;
	}
	
	// Owner of any groups?  Then remove ourselves as the owner.
	while(lpPlayer->pOwnerGroupList)
	{
		RemoveOwnerFromGroup(this, lpPlayer->pOwnerGroupList->pGroup,
			lpPlayer, TRUE);

		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during RemoveOwnerFromGroup\n", dwPlayerID);
			goto EXIT;
		}
	}

    FreeNameTableEntry(this,lpPlayer->dwID);

    // update sessiondesc
    if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) this->lpsdDesc->dwCurrentPlayers--;

    // deallocate strings + player
    DeallocPlayer(lpPlayer);

	// if we're pushing this delete across the wire, and its the 
	// nameserver we deleted, see if we're the new name server	
	if ( (fNameServer || 
		 (this->dwMinVersion >= DPSP_MSG_DX61AVERSION && this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		 ) && !fLocal &&  fLookForNewNS)
	{
		// We shouldn't ever get in here if we're a lobby-owned object
		ASSERT(!IS_LOBBY_OWNED(this));

		hr = HandleDeadNameServer(this);
		if (FAILED(hr))
		{
			DPF(0,"HandleDeadNameServer returned error: 0x%x\n", hr);
			ASSERT(FALSE);
		}
	}
	
    // todo - cruise any messages (this will apply to lobby objects as well)
EXIT:
    return DP_OK;
	
} // InternalDestroyPlayer

HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	BOOL fLocal;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
    
	fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	
	// Because of bug #12901, we want the host to be able to destroy all
	// players (even remote players) so they can implement their
	// own keep-alives.
	if ((!fLocal) && (!IAM_NAMESERVER(this)))
	{
		LEAVE_ALL();
		DPF_ERR("attempt to destroy non-local player.  not gonna happen.");
		return DPERR_ACCESSDENIED;
	}
		
	hr = InternalDestroyPlayer(this,lpPlayer,TRUE,TRUE);

	LEAVE_ALL();

    return hr;
       
}//DP_DestroyPlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyGroup"

HRESULT RemoveGroupFromGroupList(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup) 
{
	LPDPLAYI_GROUP lpGroupPrev,lpGroupSearch;
	BOOL bFoundIt=FALSE;

	// remove the group from the list
	lpGroupSearch = this->pGroups;
	lpGroupPrev=NULL;
	
	while ((lpGroupSearch)&&(!bFoundIt))
	{
		if (lpGroupSearch->dwID == lpGroup->dwID) bFoundIt=TRUE;
		else 
		{
			lpGroupPrev=lpGroupSearch;
			lpGroupSearch=lpGroupSearch->pNextGroup;
		}
	} 

	if (!bFoundIt) 
	{
		ASSERT(FALSE);
		DPF_ERR("bad group!");
        return DPERR_INVALIDPARAMS;
	}

	ASSERT(lpGroupSearch->pGroupnodes == NULL);
	if (lpGroupPrev) lpGroupPrev->pNextGroup = lpGroupSearch->pNextGroup;
    else this->pGroups = lpGroupSearch->pNextGroup;

	// success
	return DP_OK;
	
} // RemoveGroupFromGroupList

/*
 ** RemoveGroupFromAllGroups
 *
 *  CALLED BY: DP_DestroyGroup
 *
 *  PARAMETERS:
 *	lpGroup - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeleteGroupFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemoveGroupFromAllGroups(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroupFrom;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroupFrom=this->pGroups;
        
    	while (lpGroupFrom && (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    	{
			// Don't try to remove any groups from the system group
			// because there will never be any in it and we're just
			// wasting our time
			if(lpGroupFrom->dwID != DPID_ALLPLAYERS)
			{
				// this fn. will attempt to remove player from group.
				// (if players not in group, no big deal).
				// when player is removed from all groups, DP_DeleteGroupFromGroup
				// resets DPLAYI_FLAGS_PLAYERINGROUP
            	hr = InternalDeleteGroupFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroupFrom->dwID,lpGroup->dwID,fPropagate);
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeleteGroupFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...
				}
			}
            lpGroupFrom=lpGroupFrom->pNextGroup;		
    	}	
    }
    return DP_OK;
        
} // RemoveGroupFromAllGroups

//
// called by DP_DestroyGroup and SP_HandlePlayerMgmt and DP_Close
// if called by DP_DestroyGroup, fPropagate is TRUE, and we should remove group
// from global nametable.  Otherwise, we just remove from our nametable
HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate)
{
	HRESULT hr;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeNext; 
	DPSP_DELETEGROUPDATA dd;
	LPDPLAYI_SUBGROUP pSubgroup,pSubgroupNext;
	LPDPLAYI_PLAYER pOwner = NULL;
	 	
	// If this is a lobby object, call the lobby.  Unless the fPropagate flag
	// is cleared.  If it is cleared, it means the lobby called us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyGroup(this->lpLobbyObject, lpGroup->dwID);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy group, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemoveGroupsFromGroups (and InternalDelete-
			// GroupFromGroup), because it will fail since the lobby has
			// already deleted the group.  Ditto for all the following
			// DeleteGroup.... and DeletePlayer calls.
			fPropagate = FALSE;
		}
	}

    // remove group from any groups
    hr = RemoveGroupFromAllGroups(this,lpGroup,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

    // remove all players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pGroupnodes;
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// If this is a lobby object, we don't need to propagate the
		// DeletePlayerFromGroup message because the server already
		// knows about it.  Besides, it will fail out since the lobby
		// code has already removed the GroupID from the map table.
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}

    // remove all system players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	// only system group can have system players in a group w/ no corresponding app player
	if (lpGroupnode) ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP);
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// we never propagate this since it's sysplayer stuff...
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			FALSE);
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}
	
	// remove all groups from group
	// if subgroup is not a shortcut, destroy subgroup too
	pSubgroup = lpGroup->pSubgroups;
	while (pSubgroup)
	{
		pSubgroupNext = pSubgroup->pNextSubgroup;

		if (! (pSubgroup->dwFlags & DPGROUP_SHORTCUT) )
		{
			LPDPLAYI_GROUP pGroupKill = pSubgroup->pGroup; // pSubgroup	is gonna get
															// nuked b4 we're done with it
			
			// it's not a shortcut, it's contained.  remove it, then destroy it.
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,pSubgroup->pGroup->dwID,FALSE);
			
			hr = InternalDestroyGroup(this,pGroupKill,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
			
			// we may have effected the list - start over to be safe
			pSubgroupNext = lpGroup->pSubgroups;
		}
		else 
		{
			// it's  a shortcut, delete it
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
				lpGroup->dwID,pSubgroup->pGroup->dwID,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		}
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}

		pSubgroup = pSubgroupNext;
	}
	
	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUP, 0, lpGroup->dwID);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
		}
	}

	if (!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && (this->pcbSPCallbacks->DeleteGroup) )
	{
		// call sp
		dd.idGroup = lpGroup->dwID;
		dd.dwFlags = lpGroup->dwFlags;
		dd.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&dd);
		if (FAILED(hr)) 
		{
			DPF_ERR("sp - could not delete group!!"); 
		}
	}
	else 
	{
		// sp doesn't need to implement this one...
	}

	// Are we a lobby session and is there an owner.  If so, remove the owner
	// node from the player's list.
	if(IS_LOBBY_OWNED(this) && (lpGroup->dwOwnerID != DPID_SERVERPLAYER))
	{
		pOwner = PlayerFromID(this, lpGroup->dwOwnerID);
		if(pOwner)
			RemoveOwnerFromGroup(this, lpGroup, pOwner, FALSE);
	}

    hr = FreeNameTableEntry(this,lpGroup->dwID);
	if (FAILED(hr))
	{
    	return hr;
	}
	
	hr = RemoveGroupFromGroupList(this,lpGroup);
	if (FAILED(hr))
	{
    	return hr;
	}

	DeallocGroup(lpGroup);

	this->nGroups--;
	
	return DP_OK;
	
} // InternalDestroyGroup

HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP lpGroup;
	BOOL fLocal;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
		
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }

	fLocal = (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;
	DPF(3,"destroying group - fLocal = %d\n",fLocal);
	
	hr = InternalDestroyGroup( this, lpGroup, TRUE);

	LEAVE_ALL();
    return hr;
        
}//DP_DestroyGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnableNewPlayers"

HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
	
	if (!this->lpsdDesc) 
	{
		LEAVE_DPLAY();
		DPF_ERR("must open a session before enabling new players");
		return DPERR_NOSESSIONS;
	}

    // set dp_bNewPlayersEnabled
    if (bEnable) 
    {
		this->lpsdDesc->dwFlags &= ~DPSESSION_NEWPLAYERSDISABLED;
    }
    else
    {
		this->lpsdDesc->dwFlags |= DPSESSION_NEWPLAYERSDISABLED;
    } 
	
	
    LEAVE_DPLAY();
    return hr;

}//DP_EnableNewPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetCaps"

void SetDefaultCaps(LPDPCAPS lpDPCaps)
{

	// just to be safe (belt + suspenders!)
	memset(lpDPCaps,0,sizeof(DPCAPS));

	lpDPCaps->dwSize = sizeof(DPCAPS);
		
	// we show the 0 values here, just to be explicit
	lpDPCaps->dwMaxBufferSize 		= DPLAY_MAX_BUFFER_SIZE;
	lpDPCaps->dwMaxQueueSize		= 0;    
	lpDPCaps->dwMaxPlayers			= DPLAY_MAX_PLAYERS;			
	lpDPCaps->dwHundredBaud			= 0;     
	lpDPCaps->dwLatency				= 0;
	lpDPCaps->dwMaxLocalPlayers		= DPLAY_MAX_PLAYERS;	
	lpDPCaps->dwFlags				= 0;
	lpDPCaps->dwHeaderLength		= 0;
	lpDPCaps->dwTimeout				= 0;

	return;

} // SetDefaultCaps

// called by InternalGetCaps.  set dpplayercaps
HRESULT GetPlayerCaps(LPDPCAPS lpCaps,LPDPLAYI_PLAYER lpPlayer)
{
	ASSERT(lpPlayer);
	if (!lpPlayer) return E_FAIL; // ACK!
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		lpCaps->dwFlags |= DPPLAYERCAPS_LOCAL;		
	} 

	if(!lpCaps->dwLatency){
		// neither SP or Protocol had a guess at the latency, so use our best guess. 
		lpCaps->dwLatency=lpPlayer->dwLatencyLastPing;
	}

	return DP_OK;		
} // GetPlayerCaps

// called by getcaps,getplayercaps
// assumes dplay lock taken!
HRESULT InternalGetCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,BOOL fPlayer,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DPSP_GETCAPSDATA gcd;
	LPDPLAYI_PLAYER lpPlayer;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!VALID_DPLAY_CAPS(lpDPCaps))
		{
			DPF_ERR("invalid caps struct");
	        return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & ~DPGETCAPS_GUARANTEED)
		{
			DPF_ERR("invalid caps flags");
			return DPERR_INVALIDPARAMS;
		}
        if (fPlayer)
        {
	        lpPlayer = PlayerFromID(this,idPlayer);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERR("invalid player");
	            return DPERR_INVALIDPLAYER;
	        }	
        } 
		else 
		{
			lpPlayer = NULL;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	SetDefaultCaps(lpDPCaps);

	// If this is lobby-owned, call the lobby provider here and let it fill
	// in the caps structure
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the dplay lock
		LEAVE_DPLAY();
		
		// Call the appropriate GetCaps or GetPlayerCaps in the lobby
		if(!lpPlayer)
		{
			hr = PRV_GetCaps(this->lpLobbyObject, dwFlags, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetCaps in the lobby, hr = 0x%08x", hr);
			}
		}
		else
		{
			hr = PRV_GetPlayerCaps(this->lpLobbyObject, dwFlags, idPlayer, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetPlayerCaps in the lobby, hr = 0x%08x", hr);
			}
		}

		// Take the lock back
		ENTER_DPLAY();

		// If we failed, bail
		if(FAILED(hr))
			return hr;
	}


    // get caps from sp
    if (this->pcbSPCallbacks->GetCaps) 
    {
		// call sp
		gcd.lpCaps = lpDPCaps;
		gcd.dwFlags = dwFlags;
		if (lpPlayer) gcd.idPlayer = lpPlayer->dwID;
		else gcd.idPlayer = 0;
		gcd.lpISP = this->pISP;

		if(this->pProtocol){
			hr = ProtocolGetCaps(&gcd); // calls sp and patches returns
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->GetCaps,&gcd);	    	
	    }
  	    if (FAILED(hr)) 
	    {
			DPF(0,"sp get caps failed - hr = 0x%08lx\n",hr);
	    }
  	}
	else 
	{
		// no callback is ok
	}
	
	// if the buffer size is zero, set it to the max (#12634)
	if(lpDPCaps->dwMaxBufferSize == 0)
		lpDPCaps->dwMaxBufferSize = DPLAY_MAX_BUFFER_SIZE;

	// fix up max buffer size (since we add header) raid # 2324
	lpDPCaps->dwMaxBufferSize -= sizeof(MSG_PLAYERMESSAGE);

	// for dx3, we don't support guaranteed unless sp does
	if (lpDPCaps->dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)	
	{
		lpDPCaps->dwFlags |= DPCAPS_GUARANTEEDSUPPORTED;
	} else {
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	// are we the host? (nameserver)
	if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)) 
	{
		lpDPCaps->dwFlags |= DPCAPS_ISHOST;
	}
	else 
	{
		lpDPCaps->dwFlags &= ~DPCAPS_ISHOST;
	} 

    // setup security caps
    if (this->dwFlags & DPLAYI_DPLAY_SECURITY)
    {
        // digital signing is supported
        lpDPCaps->dwFlags |= DPCAPS_SIGNINGSUPPORTED;

        // do we have encryption support ?
        if (this->dwFlags & DPLAYI_DPLAY_ENCRYPTION)
        {
            lpDPCaps->dwFlags |= DPCAPS_ENCRYPTIONSUPPORTED;
        }
        else
        {
            lpDPCaps->dwFlags &= ~DPCAPS_ENCRYPTIONSUPPORTED;
        }

    }
    
    if (lpDPCaps->dwFlags & DPCAPS_GROUPOPTIMIZED)
    {
    	// sp wants to optimize groups
    	if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||
    		(this->lpsdDesc && (this->lpsdDesc->dwFlags & (DPSESSION_CLIENTSERVER | DPSESSION_SECURESERVER))))
		{
			// if these conditions are true dplay will take over the owndership of groups
			// and won't allow sp to optimize groups
			lpDPCaps->dwFlags &= ~(DPCAPS_GROUPOPTIMIZED);
		}
	}

	this->dwSPFlags = lpDPCaps->dwFlags;	// remember the SP caps to validate send params.
	
	// player caps - note, we just stuff 'em on top of dpcaps for compatibility
	if (fPlayer) hr = GetPlayerCaps(lpDPCaps,lpPlayer);

	return hr;

} // InternalGetCaps

HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,0, lpDPCaps,FALSE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageCount"

HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		if (idPlayer)
		{
			LPDPLAYI_PLAYER pPlayer;

			pPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(pPlayer)) 
			{
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				LEAVE_DPLAY();
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwCount))
		{
	        DPF_ERR( "bad count pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}
		*pdwCount = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	if (!idPlayer)
	{
		*pdwCount = (DWORD)this->nMessages;		
	} 
	else 
	{
		pmsg = this->pMessageList; //  1st message
		while (pmsg)
		{		
			if (pmsg->idTo == idPlayer) (*pdwCount)++;
			pmsg = pmsg->pNextMessage;
		}
	}

    LEAVE_DPLAY();
    return hr;
        
}//DP_GetMessageCount

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAddress"

HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) 
{
	
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer = NULL;
    HRESULT hr = DP_OK;
	DPSP_GETADDRESSDATA dad;
	DPSP_GETADDRESSCHOICESDATA dac;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		// check player address if there is one
		if (idPlayer != DPID_ALLPLAYERS)
		{
			lpPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(lpPlayer)) 
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwAddressSize))
		{
	        DPF_ERR( "bad size pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if (!pvAddress) *pdwAddressSize = 0;

		if (*pdwAddressSize && 
			!VALID_STRING_PTR(pvAddress,*pdwAddressSize))
		{
	        DPF_ERR( "bad addresss buffer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_DPLAY();
			DPF_ERR("GetPlayerAddress not supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if they ask for the player address for all players, then we give
	// them the address choices available for this service provider
	if (DPID_ALLPLAYERS == idPlayer)
	{
		if (this->pcbSPCallbacks->GetAddressChoices)
		{
			dac.lpAddress = pvAddress;
			dac.lpdwAddressSize = pdwAddressSize;
			dac.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddressChoices,&dac);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}

	// otherwise just get address for the given player
	else
	{
		if (this->pcbSPCallbacks->GetAddress)
		{
			dad.idPlayer = lpPlayer->dwIDSysPlayer;
			dad.lpAddress = pvAddress;
			dad.lpdwAddressSize = pdwAddressSize;
			dad.dwFlags = lpPlayer->dwFlags;
			dad.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddress,&dad);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}
 
	LEAVE_DPLAY();

	return hr;
		
} // DP_GetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerCaps"

HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,idPlayer, lpDPCaps,TRUE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerData/GetGroupData"

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckGetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPGET_REMOTE | DPGET_LOCAL) )
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}

	return DP_OK;

} // CheckSetDataFlags

// take a pointer to a buffer, stick a player(or group) data in it, slap the strings
// on the end.  
HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;
	LPVOID pvSource; // local or remote data
	DWORD dwSourceSize;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwDataSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvData) *pdwDataSize = 0;
		if (*pdwDataSize && !VALID_STRING_PTR(pvData,*pdwDataSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}
		// check flags
		hr = CheckGetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("invalid get data flags");
			return hr;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// figure out which source they want
	if (dwFlags & DPGET_LOCAL)
	{
		pvSource = pPlayer->pvPlayerLocalData;
		dwSourceSize = pPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		// If this is a lobby-owned object, we need to go get the data
		// from the lobby server.  We will never store it locally (sorry
		// for the pun).
		if(!IS_LOBBY_OWNED(this))
		{
			pvSource = pPlayer->pvPlayerData;
			dwSourceSize = pPlayer->dwPlayerDataSize;
		}
		else
		{
			// Drop the lock so response from the lobby can get back in
			ASSERT(1 == gnDPCSCount);
			LEAVE_DPLAY();
			
			// Get the data from the lobby
			if(fPlayer)
			{
				hr = PRV_GetPlayerData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}
			else
			{
				hr = PRV_GetGroupData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}

			// Take the lock again
			ENTER_DPLAY();
			
			// Since we've already copied the data into the caller's buffer,
			// we can just exit from here.
			return hr;
		}
	}

	// see if we've got space for it
	if (*pdwDataSize < dwSourceSize)
	{
		// not enough space
		*pdwDataSize = dwSourceSize;
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		// copy it
		*pdwDataSize = dwSourceSize;
		hr = DP_OK;
		memcpy(pvData,pvSource,*pdwDataSize);		
	}
	
	return hr;
	
} // InternalGetData  

HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;
	

} // DP_GetGroupData   

HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupName"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.  
HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	UINT nShortLen,nLongLen; // length in bytes of strings
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvBuffer) *pdwSize = 0;
		if (*pdwSize && !VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nShortLen = WSTR_ANSILENGTH(pPlayer->lpszShortName);
		nLongLen = WSTR_ANSILENGTH(pPlayer->lpszLongName);
	}
	else 
	{
		nShortLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
		nLongLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	}

	// see if buffer is big enough
	if (*pdwSize < sizeof(DPNAME) + nShortLen + nLongLen )
	{
		*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);
	
	// set up the playername struct, followed by strings
	*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
	((LPDPNAME)pvBuffer)->dwSize = sizeof(DPNAME);

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		// short name, then long name
		psz = (LPBYTE)pvBuffer+sizeof(DPNAME);

		if (pPlayer->lpszShortName)
		{
			// string goes after name struct in buffer
			WideToAnsi(psz,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortNameA = psz;
			// now, long name
			psz += nShortLen;
		}
		
		if (pPlayer->lpszLongName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongNameA = psz;
		}

	}
	else 
	{
		LPWSTR pszW;

		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPNAME));

		// short name, then long name
		if (pPlayer->lpszShortName)
		{
			// string goes after player name struct in buffer
			memcpy(pszW,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortName = pszW;
		}
		
		if (pPlayer->lpszLongName)
		{
			// now, long name
			pszW = (LPWSTR)((LPBYTE)pszW + nShortLen);
			// string goes after session desc in buffer
			memcpy(pszW,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongName = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetName

HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)	
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerName"

HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, FALSE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetFlags"

HRESULT  InternalGetFlags(LPDIRECTPLAY lpDP,DPID id,LPDWORD pdwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwFlags))
		{
			DPF_ERR("invalid flags pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// get the flags
	*pdwFlags = GetPlayerFlags(pPlayer);
	
	return DP_OK;
	
} // InternalGetFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerFlags"

HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupFlags"

HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetSessionDesc"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.
HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen,nPasswordLen; // session name length, in bytes
	HRESULT hr;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting desc!");
			return DPERR_NOSESSIONS;
		}
		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nPasswordLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszPassword);
		nNameLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszSessionName);
	}
	else 
	{
		nPasswordLen = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);	
		nNameLen = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	}	
	
	if (*pdwSize < sizeof(DPSESSIONDESC2) + nNameLen  + nPasswordLen)
	{
		*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);

	*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;

	// pack it up
	memcpy(pvBuffer,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		psz = (LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2);

		if (this->lpsdDesc->lpszSessionName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionNameA = psz;
		}
		
		if (this->lpsdDesc->lpszPassword)
		{
			// now, password
			psz += nNameLen;
			// password follows session same
			WideToAnsi(psz,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPasswordA = psz;
		}
	}
	else 
	{
		LPWSTR pszW;
		
		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2));
		
		if (this->lpsdDesc->lpszSessionName)
		{
			// 1st, session name
			memcpy(pszW,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionName = pszW;
		}			
		
		if (this->lpsdDesc->lpszPassword)
		{
			// then, password
			pszW = (LPWSTR)((LPBYTE)pszW + nNameLen);
			memcpy(pszW,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPassword = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetSessionDesc

HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Initialize"

HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid) 
{
    return DPERR_ALREADYINITIALIZED;	
}//DP_Initialize

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Open"

// get the system player / system group
HRESULT CreateSystemPlayer(LPDPLAYI_DPLAY this,DWORD dwFlags, LPWSTR lpszPassword)
{
	HRESULT hr;
	

   	// Even though the DPID_LOBBYSYSTEMPLAYER looks conspicuous here, it will
	// not have any effect in dplay sessions.  It will only be used if
	// we are in a lobby session.  Same for DPID_LOBBYSYSTEMGROUP below.
	hr = GetPlayer(this,&this->pSysPlayer,NULL,NULL,NULL,0,dwFlags,
			lpszPassword,DPID_LOBBYSYSTEMPLAYER);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create sysplayer - hr = 0x%08lx\n",hr);
		return hr;
    }

	// Create a system group.  This will be the group of all players
	// when we get a send to dpid_allplayers, we send it to this group and let sp 
	// optimize it.
   	hr = GetGroup(this,&((LPDPLAYI_GROUP)this->pSysGroup),NULL,NULL,0,
			DPLAYI_GROUP_SYSGROUP | DPLAYI_PLAYER_PLAYERLOCAL,0,
			DPID_LOBBYSYSTEMGROUP);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create system group - hr = 0x%08lx\n",hr);
		return hr;
    }
    
	ASSERT(this->pSysPlayer);

   	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
   			this->pSysPlayer->dwID,FALSE);
    if (FAILED(hr)) 
    {
		ASSERT(FALSE);
        DPF(0,"Could not add system player to  system group - hr = 0x%08lx\n",hr);
    }

	return hr;	

} // CreateSystemPlayer

// get the session desc out of an enumplayers reply
HRESULT UnpackSessionDesc(LPDPLAYI_DPLAY this,LPMSG_ENUMPLAYERSREPLY pmsg, DWORD cbReply)
{
	LPDPSESSIONDESC2 psdNew;
	HRESULT hr;
	LPWSTR lpsz;
	LPBYTE pBuffer=(LPBYTE)pmsg;
	
	ASSERT(this->lpsdDesc); // should have had one, with open

	// SECURITY - verify the reply buffer.

	if(pmsg->dwPackedOffset > cbReply || pmsg->dwPackedOffset-sizeof(WCHAR) > cbReply)
	{
		DPF(1,"SECURITY WARN: invalid packed offset in ENUMPLAYERSREPLY");
		return DPERR_GENERIC;
	}

	if(pmsg->dwDescOffset > cbReply || pmsg->dwDescOffset + sizeof(DPSESSIONDESC2) > pmsg->dwPackedOffset)
	{
		DPF(1,"SECURITY WARN: invalid session offset in ENUMPLAYERSREPLY");
		return DPERR_GENERIC;
	}

	if(pmsg->dwNameOffset && pmsg->dwNameOffset-sizeof(WCHAR) > pmsg->dwPackedOffset)
	{
		DPF(1,"SECURITY WARN: invalid session name in ENUMPLAYERSREPLY");
		return DPERR_GENERIC;
	}

	if(pmsg->dwPasswordOffset && pmsg->dwPasswordOffset-sizeof(WCHAR) > pmsg->dwPackedOffset)
	{
		DPF(1,"SECURITY WARN: invalid password in ENUMPLAYERSREPLY");
		return DPERR_GENERIC;
	}

	// ensure the session descriptor is BEFORE the password and name.
	if(pmsg->dwNameOffset < pmsg->dwDescOffset || pmsg->dwPasswordOffset && pmsg->dwPasswordOffset < pmsg->dwDescOffset)
	{
		DPF(1,"SECURITY WARN: invalid ordering in ENUMPLAYERSREPLY");
		return DPERR_GENERIC;
	}

	if(pmsg->dwNameOffset || pmsg->dwPasswordOffset){
		// Force NULL termination of password and name if present.
		// note assumes that the name and password are after the session
		// descriptor.
		pBuffer[pmsg->dwPackedOffset-1]=0;
		pBuffer[pmsg->dwPackedOffset-2]=0;
	}
	

	psdNew = (LPDPSESSIONDESC2)((LPBYTE)pmsg + pmsg->dwDescOffset);
	
	// free any old strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	
	// copy over the new desc
	memcpy(this->lpsdDesc,psdNew,sizeof(DPSESSIONDESC2));
		
	if (pmsg->dwNameOffset){
		GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwNameOffset) );
	} else {
		lpsz = NULL;
	}
	this->lpsdDesc->lpszSessionName = lpsz;

	if (pmsg->dwPasswordOffset){
		GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwPasswordOffset) );
	}else{ 
		lpsz = NULL;
	}	
	this->lpsdDesc->lpszPassword = lpsz;
	
	return DP_OK;

} // UnpackSessionDesc

// called when we first join a session
// downloads the list of players and groups in the session from the nameserver
// called by internalopensession
HRESULT GetNameTable(LPDPLAYI_DPLAY this, DWORD dwServerVersion, BOOL fEnumOnly)
{
    UINT nPlayers,nGroups,nShortcuts; 
    LPMSG_SYSMESSAGE pmereq;
	LPBYTE pBuffer;
	LPBYTE pReply=NULL;
	DWORD  cbReply=0;
	LPVOID pvSPHeader;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	DWORD dwTimeout;
	DWORD dwVersion;
    DWORD dwCommand;

	DWORD dwReplyCommand;

	LPMSG_ENUMPLAYERSREPLY lpEnumReply;

    // send an enumplayers message if enumerating players in a remote session or
    // if nameserver won't automagically respond w/ the nametable on the addforward
    if ((fEnumOnly) || (dwServerVersion < DPSP_MSG_AUTONAMETABLE))
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	    pBuffer = DPMEM_ALLOC(dwMessageSize);
	    if (!pBuffer) 
	    {
		    DPF_ERR("could not send request - out of memory");
		    return E_OUTOFMEMORY;
	    }

	    // pmsg follows sp blob
	    pmereq = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

        // build a message to send to the sp
   	    SET_MESSAGE_HDR(pmereq);

        SET_MESSAGE_COMMAND(pmereq,DPSP_MSG_ENUMPLAYER);

        // !! Review - the following stuff is already set in SendCreateMessage (AddForward)!!

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(dwServerVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)){
			dwReplyCommand = DPSP_MSG_SUPERENUMPLAYERSREPLY;
		} else {
			dwReplyCommand = DPSP_MSG_ENUMPLAYERSREPLY;
		}


		SetupForReply(this,dwReplyCommand);

    	DPF(2,"requesting nametable");	

		//this->dwServerPlayerVersion=dwServerVersion; //moved to DP_Open

	    hr = SendDPMessage(this,this->pSysPlayer,NULL,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);

	    DPMEM_FREE(pBuffer); // done w/ message
	    
	    if (FAILED(hr)) 
	    {
	    	UnSetupForReply(this);
		    DPF_ERRVAL("could not send enumplayers request, hr = 0x%08lx", hr);
		    return hr;
	    }
    } 
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= (DP_NAMETABLE_SCALE-5);// scale up the amount of time we wait 
										// (nametable can be big)
										
	if (dwTimeout > DP_MAX_CONNECT_TIME)
		dwTimeout = DP_MAX_CONNECT_TIME;

	// changing to 30 sec on client, 15 sec on host.
	if(dwTimeout < DP_MAX_CONNECT_TIME/2){
		dwTimeout = DP_MAX_CONNECT_TIME/2;  
	}	

    DPF(2,"waiting for nametable:: timeout = %d\n",dwTimeout);	

	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

	hr=WaitForReply(this, &pReply, &cbReply, &pvSPHeader, dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	// got a buffer with a message in it

	// SECURITY
	if(cbReply < sizeof(MSG_SYSMESSAGE)){
   		DPF(1,"SECURITY WARN: INVALID REPLY, TOO SHORT");
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

    // if nameserver is DX5 or greater, it will respond with the nametable if 
    // addforward succeeds, otherwise it will respond with an addforwardreply containing
    // the error.
    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReply);
    if (DPSP_MSG_ADDFORWARDREPLY == dwCommand)
    {
    	if(cbReply < sizeof(MSG_ADDFORWARDREPLY)){
    		DPF(1,"SECURITY WARN: INVALID ADDFORWARD REPLY, TOO SHORT");
    		hr=DPERR_GENERIC;
    		goto CLEANUP_EXIT;
    	}
        hr = ((LPMSG_ADDFORWARDREPLY)pReply)->hResult;
        DPF_ERRVAL("Addforward failed: hr = 0x%08x\n",hr);

		// let handler.c continue
        goto CLEANUP_EXIT;
    }
	//
	// if it's a dx3 nameserver, the nametable will not be in the correct order
	//
	dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);
	if (DPSP_MSG_DX3VERSION == dwVersion) 
	{
		DPF(1,"name server is DX3");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if(cbReply < sizeof(MSG_ENUMPLAYERSREPLY))
	{
		DPF(1,"SECURITY WARN: EnumPlayersReply is too short");
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	nPlayers = ((LPMSG_ENUMPLAYERSREPLY)pReply)->nPlayers;
	nGroups =  ((LPMSG_ENUMPLAYERSREPLY)pReply)->nGroups;
	
	DPF(0,"received %d players and %d groups from name server\n",nPlayers,nGroups);

	if (dwVersion >= DPSP_MSG_SESSIONNAMETABLE)
	{
		hr = UnpackSessionDesc(this,(LPMSG_ENUMPLAYERSREPLY)pReply,cbReply);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	// unpack  player list (player buffer follows enumreply message in buffer)
	this->lpsdDesc->dwCurrentPlayers = 0; // unpack will generate correct player count

	lpEnumReply = (LPMSG_ENUMPLAYERSREPLY)pReply;
	// SECURITY - ensure the response is big enough to be valid. (for DX3 interop need another case)
	//            and that the offset of the packed data is within the buffer boundary.
	if(	(cbReply < sizeof(MSG_ENUMPLAYERSREPLY)) || 
		(lpEnumReply->dwPackedOffset > cbReply))
	{
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}
	
	if (GET_MESSAGE_COMMAND(lpEnumReply) == DPSP_MSG_SUPERENUMPLAYERSREPLY)
	{

		nShortcuts = lpEnumReply->nShortcuts;
	
		UnSuperpackPlayerAndGroupList(this,pReply+lpEnumReply->dwPackedOffset, cbReply-lpEnumReply->dwPackedOffset,
			nPlayers,nGroups,nShortcuts,pvSPHeader);
	}
	else 
	{
		ASSERT(GET_MESSAGE_COMMAND((LPMSG_ENUMPLAYERSREPLY)pReply)== DPSP_MSG_ENUMPLAYERSREPLY);
		UnpackPlayerAndGroupList(this,pReply+lpEnumReply->dwPackedOffset, cbReply-lpEnumReply->dwPackedOffset,
			nPlayers,nGroups,pvSPHeader);
	}

	if (this->pSysPlayer)
	{
		// execute any pending commands we may have queud
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE); // ?
		}
	}

// if we sucessfully received the name table, we have already
// set ghReplyProcessed to let handler.c run again. We do NOT
// want to set the event again or handler.c will not block the
// next time around.

CLEANUP_EXIT:
	if(pReply){
		FreeReplyBuffer(pReply);	
	}	
	
    // done
    return hr;

} // GetNameTable 

// called by InternalOpenSession
HRESULT AllocNameTable(LPDPLAYI_DPLAY this)
{
	UINT nPlayers;

	// now, alloc space for the nametable
    nPlayers =  this->lpsdDesc->dwCurrentPlayers + NAMETABLE_INITSIZE;
    
    // alloc the nametable
    this->pNameTable = DPMEM_ALLOC(nPlayers*sizeof(NAMETABLE));
    if (!this->pNameTable) 
    {
    	return E_OUTOFMEMORY;
    }
    
    this->uiNameTableSize  = nPlayers;
    DPF(0,"created name table of size %d\n",nPlayers);

	return DP_OK;

} // AllocNameTable

// todo - do we only do this on iplay1?
// put a DPSYS_CONNECTED in the apps message q
HRESULT DoConnected(LPDPLAYI_DPLAY this)
{
	LPDPMSG_GENERIC pconnected;
	LPMESSAGENODE pmsn;

	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pconnected)
	{
		DPMEM_FREE(pmsn);
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected->dwType = DPSYS_CONNECT;
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pconnected;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	ASSERT(!this->pMessageList);
	this->pMessageList = pmsn;
	this->pLastMessage = pmsn;
	this->nMessages = 1;

	return DP_OK;

} // DoConnected

// called by internalenumsessions or internalopensession
// start our worker thread
// bKeepAlive is TRUE if we need keepalive, false if we need async enums
// if it's false, the seup was done in internalenum
HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive)
{
	DWORD dwThreadID;
	DPCAPS caps;
	HRESULT hr;

	if (bKeepAlive)	
	{
		// 1st, see if sp can do it
		memset(&caps,0,sizeof(caps));
		caps.dwSize = sizeof(caps);
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
		if (FAILED(hr))	
		{
			ASSERT(FALSE);
		}
		else 
		{
			// if sp does it, don't start the thread
			if (caps.dwFlags & DPCAPS_KEEPALIVEOPTIMIZED) return DP_OK;
		}
		
		// SP doesn't do it - we have to
		this->dwFlags |= DPLAYI_DPLAY_KEEPALIVE;
		this->dwLastPing = GetTickCount();
	}
	
	if (this->hDPlayThread)
	{
		// already running...just signal it that something has changed
		SetEvent(this->hDPlayThreadEvent);
		return DP_OK;
	}

	// get us a event
	this->hDPlayThreadEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hDPlayThreadEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create worker thread event - err = %d\n",dwErr);
		return E_FAIL;
	}
	
	this->hDPlayThread = CreateThread(NULL,0,DPlayThreadProc,this,0,&dwThreadID);
	if (!this->hDPlayThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create worker thread - err = %d\n",dwErr);

		CloseHandle(this->hDPlayThreadEvent);
		this->hDPlayThreadEvent = 0;
		return E_FAIL;
	}
	
	return DP_OK;
	
} // StartDPlayThread

void StartPerf(LPDPLAYI_DPLAY this)
{
	DWORD dwThreadID;
	UINT nWantCPL;
	HRESULT hr;
	
	// 1st, see if we the user wants one
	nWantCPL = GetProfileIntA( PROF_SECT, "dxcpl", 0);
	// they must enter non-zero if they want it
	if (0 == nWantCPL)
	{
		// they don't want it
		// let's see if the dpcpl is running, just to make sure
		hr = InitMappingStuff(this);
		// if this failed, dplay cpl is not running
		if (FAILED(hr)) return ;
		// if the cpl is running, we'll talk to it
	}
	
	// get us a event
	this->hPerfEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hPerfEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create perf event - err = %d\n",dwErr);
		return ;
	}
	
	this->hPerfThread = CreateThread(NULL,0,PerfThreadProc,this,0,&dwThreadID);
	if (!this->hPerfThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create perf thread - err = %d\n",dwErr);
		CloseHandle(this->hPerfEvent);
		this->hPerfEvent = 0;
		return ;
	}
	
	return ;
	
} // StartPerf

/*
 ** CopyCredentials
 *
 *  CALLED BY: InternalOpenSession()
 *
 *  PARAMETERS: pCredentialsDest - user credentials ptr (destination)
 *				pCredentialsSrc - user credentials ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies user credentials while allocating memory for username and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopyCredentials(LPDPCREDENTIALS pCredentialsDest, 
                         LPCDPCREDENTIALS pCredentialsSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pCredentialsDest && pCredentialsSrc);

    memcpy(pCredentialsDest, pCredentialsSrc, sizeof(DPCREDENTIALS));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pCredentialsDest->lpszUsernameA), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszPasswordA), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszDomainA), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pCredentialsDest->lpszUsername), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszPassword), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszDomain), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeCredentials(pCredentialsDest, bAnsi);
    return hr;
} // CopyCredentials

HRESULT SetupSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC lpSecDesc)
{
    HRESULT hr;
    LPDPSECURITYDESC pSecDescLocal;
    LPWSTR pwszSSPIProvider=NULL,pwszCAPIProvider=NULL;
    DWORD dwCAPIProviderType,dwEncryptionAlgorithm;

    // alloc space for the security description
    pSecDescLocal = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDescLocal) 
    {
        DPF_ERR("couldn't allocate space for security desc - out of memory!");
        return DPERR_OUTOFMEMORY;
    }           

    // if app doesn't provide a security desc, setup defaults
    if (NULL == lpSecDesc)
    {
        // use default SSPI provider
        DPF(0, "No security description was provided - using defaults (NTLM and Microsoft's RSA Base Provider)");
        hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }
	    // use default CAPI provider 
        // NULL means Microsoft's RSA Base Provider
	    dwCAPIProviderType = PROV_RSA_FULL; // full support
	    dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
    }
    else
    {
        // app passed in a security desc

	    // setup the SSPI provider
	    if (lpSecDesc->lpszSSPIProvider)
	    {
            DPF(0,"Using SSPI Provider: \"%ls\"", lpSecDesc->lpszSSPIProvider);
		    // copy the package name provided by application
            hr = GetString(&pwszSSPIProvider, lpSecDesc->lpszSSPIProvider);
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No SSPI provider specified - using the default: %ls",DPLAY_DEFAULT_SECURITY_PACKAGE);
		    hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    }
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }

	    // setup the CAPI provider
	    if (lpSecDesc->lpszCAPIProvider)
	    {
            dwCAPIProviderType = lpSecDesc->dwCAPIProviderType;
            dwEncryptionAlgorithm = lpSecDesc->dwEncryptionAlgorithm;

		    DPF(0, "Using CAPI provider: \"%ls\"",lpSecDesc->lpszCAPIProvider);

		    // copy the package name provided by application
            hr = GetString(&pwszCAPIProvider, lpSecDesc->lpszCAPIProvider);
		    if (FAILED(hr))
		    {
			    DPF_ERRVAL("Failed to setup default CAPI Provider: hr = 0x%08lx", hr);
			    goto CLEANUP_EXIT;
		    }
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No CAPI provider specified - using Microsoft's RSA Base Provider");

	        // use default CAPI provider 
            // NULL means Microsoft's RSA Base Provider
	        dwCAPIProviderType = PROV_RSA_FULL; // full support
	        dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
	    }
    }

    // success

    // setup a security description
    pSecDescLocal->lpszSSPIProvider = pwszSSPIProvider;
    pSecDescLocal->lpszCAPIProvider = pwszCAPIProvider;
    pSecDescLocal->dwCAPIProviderType = dwCAPIProviderType;
    pSecDescLocal->dwEncryptionAlgorithm = dwEncryptionAlgorithm;
    pSecDescLocal->dwSize = sizeof(DPSECURITYDESC);
    pSecDescLocal->dwFlags = 0;

    // remember it in the dplay object
    this->pSecurityDesc = pSecDescLocal;

    return DP_OK;

CLEANUP_EXIT:

    if (pwszSSPIProvider) DPMEM_FREE(pwszSSPIProvider);
    if (pwszCAPIProvider) DPMEM_FREE(pwszCAPIProvider);
    if (pSecDescLocal) DPMEM_FREE(pSecDescLocal);

    return hr;
}  // SetupSecurityDesc

// find (or create) the session pointed to by lpSDesc.
// fEnumOnly means don't actually join - don't create the sysplayer...
HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,
	BOOL fEnumOnly,DWORD dwFlags,BOOL fStuffInstanceGUID, 
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr = DP_OK;
    BOOL bNameSrvr = FALSE;
    DWORD dwPlayerFlags; // flags for our system player
    LPDPSESSIONDESC2 lpLocalDesc=NULL;
	DPSP_OPENDATA opd;
	BOOL bCreate;
	LPSESSIONLIST pSession;
    DWORD dwServerVersion=0;
	BOOL bReturnStatus; // true to override dialogs and return status
	DPCAPS dpCaps;


	DPF(5, "InternalOpenSession: Parameters: (0x%x, 0x%x, %i, 0x%x, %i, 0x%x, 0x%x)",
		this, lpSDesc, fEnumOnly, dwFlags, fStuffInstanceGUID, lpSecDesc, lpCredentials);

	this->fDidVoiceClose = FALSE;

    //
	//
	// alloc space for the game description. if we create a game, we
	// use the passsed sessiondesc. if we join a game, we use the session
	// desc that enum stored for us.
    lpLocalDesc = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
    if (!lpLocalDesc) 
    {
    	DPF_ERR("open session - out of memory!");
        return E_OUTOFMEMORY;
    }

	// flags for the sysplayer
    dwPlayerFlags = DPLAYI_PLAYER_SYSPLAYER | DPLAYI_PLAYER_PLAYERLOCAL;

	// app can request that the SP not display any status
	// dialogs while opening by setting this flag. The SP
	// will return status codes while open is in progress

	bReturnStatus = (dwFlags & DPOPEN_RETURNSTATUS) ? TRUE : FALSE; 

	// 
	// get the session desc
    if (dwFlags & DPOPEN_JOIN) 
    {
		bCreate = FALSE;
		
		// find the matching session...
		pSession = FindSessionInSessionList(this,&(lpSDesc->guidInstance));	
		if (!pSession) 
		{
			DPF_ERR("could not find matching session to open");
            hr = DPERR_NOSESSIONS;
            goto CLEANUP_EXIT;
		}

    	DPF(0,"Remote dplay version %x\n",pSession->dwVersion);
	    this->dwServerPlayerVersion = pSession->dwVersion;

        if (pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER)
        {
            //joining a secure session

            //do not allow enumeration on a remote session without authentication
            if (fEnumOnly)
            {
                DPF(0, "Can't enumerate a secure session without logging in");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }
        else
        {
            // joining an unsecure session
            if (lpSecDesc)
            {
                DPF_ERR("Passed security description while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
            if (lpCredentials)
            {
                DPF_ERR("Passed credentials while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
        }

        // if session we are trying to join is password protected
        if (pSession->dpDesc.dwFlags & DPSESSION_PASSWORDREQUIRED)
        {
            // do not allow enumeration of players without joining
            if (fEnumOnly)
            {
			    DPF(0,"session requires a password - join session before enumerating players\n");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }

        // check if the session is available to join
	    if ((pSession->dpDesc.dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
            (pSession->dpDesc.dwFlags & DPSESSION_JOINDISABLED))
        {
			DPF(0,"session is not allowing players to join\n");
            hr = DPERR_NONEWPLAYERS;
            goto CLEANUP_EXIT;
        }
	    
		// make sure we haven't reached the maximum number of players in
		// the session, unless we are just enum'ing, then let it join anyway
		if ((!fEnumOnly) && (pSession->dpDesc.dwMaxPlayers && 
           (pSession->dpDesc.dwCurrentPlayers >= pSession->dpDesc.dwMaxPlayers)))
		{
			DPF_ERR("Session already contains the maximum number of players");
			hr = DPERR_NONEWPLAYERS;
			goto CLEANUP_EXIT;
		}

        // initialize security, if we are joining a secure session, unless the SP
		// (or LP) is handling the security, in which case we can skip this
        if((pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER) &&
			(!(this->dwFlags & DPLAYI_DPLAY_SPSECURITY)))
        {
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI: hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }
        }
        
	    memcpy(lpLocalDesc,&(pSession->dpDesc),sizeof(DPSESSIONDESC2));

		// copy over the strings from the session desc supplied by the namesrvr
		GetString(&(lpLocalDesc->lpszSessionName),pSession->dpDesc.lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),pSession->dpDesc.lpszPassword);
    }
	else
    {    	
	    this->dwServerPlayerVersion = DPSP_MSG_VERSION;
        // if we are creating a secure server
        if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
        {
			if(lpSDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
				DPF(0, "Tried to run protocol on secure session, not allowed, returning INVALIDFLAGS\n");
				hr=DPERR_INVALIDFLAGS;
				goto CLEANUP_EXIT;
			}
			
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }

            // we shouldn't have security desc yet
            ASSERT(!this->pSecurityDesc);

            // setup security description
            hr = SetupSecurityDesc(this, lpSecDesc);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Failed to setup security description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		// create a session.
		// copy the passed desc, and create a name server
		bCreate = TRUE;

		ASSERT(DPOPEN_CREATE & dwFlags);
	    memcpy(lpLocalDesc,lpSDesc,sizeof(DPSESSIONDESC2));

		// a-josbor: see if the WIN.INI file tells us to force the protocol on
		if (!(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL))
		{
		    if (GetProfileIntA( "DirectPlay", "Protocol", 0 ) == 1)
		    {
	            DPF(0, "Warning!  DirectProtocol turned ON by WIN.INI setting\n");
		    	lpLocalDesc->dwFlags |= DPSESSION_DIRECTPLAYPROTOCOL;
		    	bForceDGAsync=TRUE;
		    }
		}
		
        // init session desc properly
        lpLocalDesc->dwCurrentPlayers = 0;

    	dwPlayerFlags |= DPLAYI_PLAYER_NAMESRVR;

		// get a guid for this session
		// if we're stuffing the guid (called by dpconnect) then leave
		// the guid alone
		if (!fStuffInstanceGUID) OS_CreateGuid(&(lpLocalDesc->guidInstance));

		// copy over the strings from the session desc supplied by the user	
		GetString(&(lpLocalDesc->lpszSessionName),lpSDesc->lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),lpSDesc->lpszPassword);

		// set up the player id xor key
		// the tick count serves as a pretty good randomizer
		lpLocalDesc->dwReserved1 = GetTickCount();
        // initialize the reserved fields
        lpLocalDesc->dwReserved2 = 0;
        // if session has a password, setup the PASSWORDREQUIRED flag in the session desc 
		// treat zero-length string like a NULL password to be compatible with
		// the behavior of DX3
        if ((lpSDesc->lpszPassword) &&
			(WSTRLEN(lpSDesc->lpszPassword) > 1))
        {
            lpLocalDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
        }
		// if session is secure, use multicast
		if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
		{
			DPF(0,"Session is secure - enabling multicast");
			lpLocalDesc->dwFlags |= DPSESSION_MULTICASTSERVER;
		}
		
    } // create
		
    if (lpCredentials)
    {
        // app passed in user credentials - remember them in the dplay object
        // so we can use them while acquiring the credentials handle (after getting 
        // the package name from the server)
        ASSERT(!this->pUserCredentials);

        // allocate memory for storing credentials
        this->pUserCredentials = DPMEM_ALLOC(sizeof(DPCREDENTIALS));
        if (!this->pUserCredentials)
        {
            DPF_ERR("Failed to allocate credentials structure - out of memory!");
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
        // remember the user credentials in the directplay object
        hr = CopyCredentials(this->pUserCredentials,lpCredentials, FALSE);                
        if (FAILED(hr))
        {
            DPF_ERRVAL("Couldn't store credentials: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }
    }

	// we  should not have a session desc yet!
	ASSERT(!this->lpsdDesc);

	// If this is a lobby-owned object, call the lobby here
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the lock so the lobby's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Open a session to the lobby
		hr = PRV_Open(this->lpLobbyObject, lpLocalDesc, dwFlags, lpCredentials);
		// Take the lock back
		ENTER_DPLAY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed to Open lobby session, hr = 0x%08x", hr);
			goto CLEANUP_EXIT;
		}
	}

	// store the new session desc
    this->lpsdDesc =lpLocalDesc;
	// fixup protocol flags
	if(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOL;
		DPF(0,">>>RUNNING WITH DIRECTPROTOCOL<<<\n");
	}
	if(lpLocalDesc->dwFlags & DPSESSION_NOPRESERVEORDER){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOLNOORDER;
	}

    if (this->pcbSPCallbacks->Open) 
    {
		opd.bCreate = bCreate;
		if (bCreate)
		{
			opd.lpSPMessageHeader = NULL;
		}
		else 
		{
			opd.lpSPMessageHeader = pSession->pvSPMessageData;
		}
		
		opd.lpISP = this->pISP;
		opd.bReturnStatus = bReturnStatus;
		opd.dwOpenFlags = dwFlags;
		opd.dwSessionFlags = this->lpsdDesc->dwFlags;
		
	    hr = CALLSP(this->pcbSPCallbacks->Open,&opd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
            goto CLEANUP_EXIT;
	    }
    }
	else 
	{
		// no callback - no biggie
	}

	// Get Caps so we can tell if we need the protocol.

    ZeroMemory(&dpCaps,sizeof(dpCaps));
    dpCaps.dwSize = sizeof(dpCaps);
	hr=InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
    if (SUCCEEDED(hr) && !(dpCaps.dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)){
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	if(this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOL)){
	
		hr=InitPacketize(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
	}
	
	if(this->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Initialize Dplay's reliable protocol on the interface.
		hr=InitProtocol(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// Get message sizes (again) since different with protocol running.
		hr=GetMaxMessageSize(this);
	    if (FAILED(hr))
	    {
	    	DPF_ERRVAL("Failed to get message sizes with protocol running hr=%08x\n",hr);
	        ASSERT(FALSE);
	        goto CLEANUP_EXIT;
	    }

	} 

	// alloc the nametable
	hr = AllocNameTable(this);
    if (FAILED(hr)) 
    {
		DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
		// since we've succeeded sp's open call, shut down the session
        goto CLOSESESSION_EXIT;
    }

	// get the system player
	if (!fEnumOnly)
	{
		// we're actually joining this session
		hr = CreateSystemPlayer(this,dwPlayerFlags,lpSDesc->lpszPassword);
		if (FAILED(hr))
		{
			DPF_ERR("could not get system player");
            goto CLOSESESSION_EXIT;
		}

		// If we're a lobby object, we can skip everything that follows because it
		// has either already been done, or doesn't apply to lobbies.
		if(IS_LOBBY_OWNED(this))
			return hr;

        // setup credentials for the system player
        if ((DPOPEN_CREATE & dwFlags) && (lpSDesc->dwFlags & DPSESSION_SECURESERVER))
        {
			hr = LoadSecurityProviders(this,SSPI_SERVER);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to setup credentials");
                goto CLOSESESSION_EXIT;
            }
        }

		// put a DPSYS_CONNECT in the apps queue
		// we do this only for mech, since mech needs it
		// (but it breaks doom ii, so we can't do it always)
		if (gbMech) hr = DoConnected(this);

		// stop the enum thread
		if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
		{
			StopEnumThread(this);
		}

		// a-josbor: if we're the nameserver start the DPLAY thread.  That's where we
		// clean up the reservation list
		// also start it up if we're using keepalives
		if ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)
			|| (IAM_NAMESERVER(this)))
		{
			StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
		}
		
		// start up the perf thread
		StartPerf(this);
		
	}

	//
    // get the name table
    // need to get the list of players from the name server
   	if (!(dwPlayerFlags & DPLAYI_PLAYER_NAMESRVR))
   	{
        ASSERT(pSession);
        // pass the name server's version so we don't send an enumplayers message
        // if it is dx5 or later
        hr = GetNameTable(this, pSession->dwVersion, fEnumOnly);	
		if (FAILED(hr)) 
		{
			DPF_ERR("could not download name table!");
            goto CLOSESESSION_EXIT;
		}
   	}

    // cleanup credentials - we don't want them hanging in our dplay object
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }

	DPF(8, "InternalOpenSession: Returning DP_OK");

    // success
	return DP_OK;

    // if we reach here, we have allocated a session and perhaps initialized this->lpsdDesc
CLEANUP_EXIT:
    FreeDesc(lpLocalDesc, FALSE);
    DPMEM_FREE(lpLocalDesc);
    
    this->lpsdDesc = NULL;
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }
    if(this->pProtocol){
    	FiniProtocol(this->pProtocol);
    	this->pProtocol=NULL;
    }
    if(this->hRetryThread){
    	this->dwFlags |= DPLAYI_DPLAY_CLOSED;
    	KillThread(this->hRetryThread, this->hRetry);
    	this->hRetryThread=0;
    	FiniPacketize(this);
    	this->dwFlags &= ~DPLAYI_DPLAY_CLOSED;
    }
    
	DPF(8, "InternalOpenSession: Returning (cleanup exit) [0x%lx]", hr);
	
    return hr;

    // if we reach here, sp's open call was successfull
CLOSESESSION_EXIT:
    LEAVE_ALL();
    DP_Close((IDirectPlay *)this->pInterfaces);
    ENTER_ALL();
    
	DPF(8, "InternalOpenSession: Returning (closesession exit) [0x%lx]", hr);
	
    return hr;

} // InternalOpenSession

// assumes it is being called in a TRY block
HRESULT ValidateOpenParams(LPDPLAYI_DPLAY this, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
    HRESULT hr;
    DPCAPS dpCaps;

    if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
    {
  		DPF_ERR("invalid session desc");
        return DPERR_INVALIDPARAMS;
    }

	if (!VALID_OPEN_FLAGS(dwFlags))
	{
  		DPF_ERR("invalid flags");
        return DPERR_INVALIDPARAMS;
	}

	// REVIEW NOTE: DX3 did not check for invalid flags in the session desc.
	// Therefore, apps may have been passing in garbage here and we would
	// not have caught it. Now we are checking to make sure the flags are valid.
	// This could cause a regression, since we will fail now where we did not before.

	if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
	{
  		DPF_ERRVAL("invalid flags (0x%08x) in session desc!",lpsdDesc->dwFlags);
		ASSERT(FALSE);				// assert so we pay attention!
        return DPERR_INVALIDFLAGS;
	}
	
    // don't allow nameserver migration with 
    // DPSESSION_SECURESERVER or DPSESSION_CLIENTSERVER	or DPSESSION_MULTICASTSERVER
    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
	    DPF_ERR("Can't set host migration on a secure server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER))
    {
	    DPF_ERR("Can't set host migration on client server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER))
    {
	    DPF_ERR("Can't set host migration on multicast server");
	    return DPERR_INVALIDFLAGS;
    }

	if ((lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) && 
		(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		DPF(0,"Warning! Player messages sent secure will contain headers");
	}

	if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
		WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
		WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    if ((dwFlags & DPOPEN_CREATE) && (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        // dplay security is only available if sp supports reliable communication
        ZeroMemory(&dpCaps,sizeof(dpCaps));
        dpCaps.dwSize = sizeof(dpCaps);
	    hr = InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get caps: hr=0x%08x",hr);
            return hr;
        }
        if (!(dpCaps.dwFlags & DPCAPS_GUARANTEEDSUPPORTED))
        {
            DPF_ERR("Can't host a secure session - sp doesn't support reliable messages");
            return DPERR_UNSUPPORTED;
        }
    }

    // all params are ok
    return DP_OK;
}

// In DX3 the list of sessions was stored in a global list.
// In DX5, the list is stored with the DirectPlay object.
//
// This means if a DX3 app did an EnumSessions() on one object
// and then Open(JOIN) on a different object, the session list would
// be preserved between objects and the join would work.
//
// On DX5 this would fail since the session list was not preserved.
//
// We found one DX3 game (X-Wing vs. Tie Fighter) that was depending on
// this - there may be more. The fix was to simply EnumSessions again
// until the requested session was found.

#define FILE_NAME_SIZE	256

BOOL XWingHack(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc)
{
	DPLCONNECTION	connect;
	char			lpszFileName[FILE_NAME_SIZE];
	char			lpszXWing[] = "z_xvt__.exe";
	char			*lpszCheck;
	HRESULT			hr;

	// get path name of app we are running
	if (!GetModuleFileNameA(NULL,lpszFileName,FILE_NAME_SIZE)) 
		return (FALSE);
	lpszFileName[FILE_NAME_SIZE - 1] = '\0';	// ensure NULL termination

	// make sure string is big enough
	if (STRLEN(lpszFileName) < STRLEN(lpszXWing))
		return (FALSE);

	// match app name against characters at end of path name
	lpszCheck = lpszFileName + STRLEN(lpszFileName) - STRLEN(lpszXWing);

	LowerCase(lpszCheck);

	// bail if name does not match
	if (0 != strcmp(lpszCheck, lpszXWing))
		return (FALSE);

	DPF(1,"Found X-Wing!!!");

	memset(&connect, 0, sizeof(DPLCONNECTION));
	connect.lpSessionDesc = lpsdDesc;

	// get this session instance into the session list if it takes all night
	DPF(1,"Re-aquiring session...");
	hr = ConnectFindSession(this, &connect);

	if FAILED(hr)
		return (FALSE);
	else
		return (TRUE);
}

HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // parameter validation
        hr = ValidateOpenParams(this, lpsdDesc, dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
	        return hr;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);

	// this is a hack to make X-Wing vs. Tie Fighter work
	// it will go out on the network, find the specified session
	// and add it to the session list.
	if ((DPERR_NOSESSIONS == hr) && (XWingHack(this, lpsdDesc)))
	{
		hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);
	}

	LEAVE_ALL();
    return hr;
        
}//DP_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Receive"

// we've just copied our private pmsg over to users pvBuffer
// if it was a system message, we need to fix up our pointers
void FixUpPointers(LPVOID pvBuffer)  
{
	DWORD dwType;
	UINT nShortLen=0,nLongLen=0;
	LPBYTE pBufferIndex;

	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;

	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
			{
				LPDPMSG_CREATEPLAYERORGROUP pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				// now, lpData - follows strings
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}

			}		
			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			{
				
				LPDPMSG_SETPLAYERORGROUPDATA pmsg = (LPDPMSG_SETPLAYERORGROUPDATA)pvBuffer;
				 				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPDATA);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}


			}
			break;
			
		case DPSYS_SETPLAYERORGROUPNAME:
			{
				LPDPMSG_SETPLAYERORGROUPNAME pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:	
			{
				LPDPMSG_DESTROYPLAYERORGROUP pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

				// fix up local data pointer
				if (pmsg->lpLocalData)
				{
					pmsg->lpLocalData = pBufferIndex;
					pBufferIndex += pmsg->dwLocalDataSize;
				}
				// fix up remote data pointer
				if (pmsg->lpRemoteData)
				{
					pmsg->lpRemoteData = pBufferIndex;
					pBufferIndex += pmsg->dwRemoteDataSize;
				}

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				
			}
			break;

		case DPSYS_SETSESSIONDESC:
			{
                UINT nSessionNameLen, nPasswordLen;
				LPDPMSG_SETSESSIONDESC pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);

				nSessionNameLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszSessionName);
				nPasswordLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszPassword);

				// fix up string pointers - strings follow msg
				if (nSessionNameLen)
				{
					pmsg->dpDesc.lpszSessionName = (LPWSTR)pBufferIndex;
					pBufferIndex += nSessionNameLen;
				}
				if (nPasswordLen)
				{
					pmsg->dpDesc.lpszPassword = (LPWSTR)pBufferIndex;
				}
			}
			break;

        case DPSYS_SECUREMESSAGE:
            {
                LPDPMSG_SECUREMESSAGE pmsg = (LPDPMSG_SECUREMESSAGE)pvBuffer;

                // fix up data pointer
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SECUREMESSAGE);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}
            }
            break;

		case DPSYS_STARTSESSION:
			{
				LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;

				// First fix up the DPLCONNECTION pointer itself
				pmsg->lpConn = (LPDPLCONNECTION)((LPBYTE)pmsg +
								sizeof(DPMSG_STARTSESSION));
				
				// Call the function in the lobby which does this
				PRV_FixupDPLCONNECTIONPointers(pmsg->lpConn);
			}
			break;
		
		case DPSYS_CHAT:
			{
				LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;

				pmsg->lpChat = (LPDPCHAT)((LPBYTE)pmsg + sizeof(DPMSG_CHAT));
				pmsg->lpChat->lpszMessage = (LPWSTR)((LPBYTE)pmsg + sizeof(DPMSG_CHAT) +
						sizeof(DPCHAT));
			}
			break;

		default:
			// no ptrs to fix up...
			break;
	} // switch

	return ;
	
} // FixUpPointers

// if its an addlayer message, return size of dplay 10 add player message
DWORD OldMessageSize(LPMESSAGENODE pmsg)
{
	DWORD dwType;

	dwType = ((LPDPMSG_GENERIC)(pmsg->pMessage))->dwType;

	if (DPSYS_ADDPLAYER == dwType)
	{
		// make sure we tell the app to alloc enough space for the larger of the
		// addplayer1 and the addplayer2
		if (pmsg->dwMessageSize < sizeof(DPMSG_ADDPLAYER)) return sizeof(DPMSG_ADDPLAYER);
		else return pmsg->dwMessageSize;
	}
	// else
	return pmsg->dwMessageSize;
} // OldMessageSize

// called by dp_1_receive,dp_a_receive, dp_receive
// dwCaller is RECEIVE_2,RECEIVE_2A, or RECEIVE_1 depending on who called 
// us
HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg,pmsgPrev=NULL;
	DWORD dwActualSize; // message size may be adjusted if
						// it's a 1.0 system message
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		if  ((!pidTo) || (!VALID_ID_PTR(pidTo)))
		{
	        DPF_ERR( "Bad pidTo" );
	        return DPERR_INVALIDPARAMS;
		}

		if ((!pidFrom) || (!VALID_ID_PTR(pidFrom)))
		{
	        DPF_ERR( "Bad pidFrom" );
	        return DPERR_INVALIDPARAMS;
		}

		if (!VALID_RECEIVE_FLAGS(dwFlags))
		{
	        DPF_ERR( "invalid flags" );
	        return DPERR_INVALIDFLAGS;
		}

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	pmsgPrev = NULL;
	pmsg = this->pMessageList; //  1st message

	// check for a match to or from a specific player
	if (dwFlags & (DPRECEIVE_TOPLAYER | DPRECEIVE_FROMPLAYER))
	{
		// loop over all the messages in the queue
		while (pmsg)
		{
			// both "to" and "from" must match
			if ((dwFlags & DPRECEIVE_TOPLAYER) &&
				(dwFlags & DPRECEIVE_FROMPLAYER))
			{
				// make sure both id's match
				if ((pmsg->idTo == *pidTo) &&
					(pmsg->idFrom == *pidFrom))
				{
					break;
				}
			}

			// just "to" has to match
			else if (dwFlags & DPRECEIVE_TOPLAYER)
			{
				// make sure "to" id's match
				if (pmsg->idTo == *pidTo)
				{
					break;
				}
			}

			// just "from" has to match
			else if (dwFlags & DPRECEIVE_FROMPLAYER)
			{
				// make sure "from" id's match
				if (pmsg->idFrom == *pidFrom)
				{
					break;
				}
			}

			// no match found, so go to next message
			pmsgPrev = pmsg;
			pmsg = pmsg->pNextMessage;
		}
	}

	// there are no messages for us
	if (!pmsg) 
	{
		return DPERR_NOMESSAGES;
	}
   
	// if it's 1.0, we may need to resize 
	if ((dwCaller == RECEIVE_1) && (0 == pmsg->idFrom))
	{
		dwActualSize = OldMessageSize(pmsg);
	}
	else 
	{
		dwActualSize = pmsg->dwMessageSize;
	}
	// see if the apps buffer is big enough
	if (*pdwSize < dwActualSize)
	{
		*pdwSize = dwActualSize;		// tell app how much is needed
		return DPERR_BUFFERTOOSMALL;
	}

	// copy the buffer over
	memcpy((LPBYTE *)pvBuffer,pmsg->pMessage,pmsg->dwMessageSize);
	*pdwSize = pmsg->dwMessageSize;
	*pidTo = pmsg->idTo;
	*pidFrom = pmsg->idFrom;

	DPF(5,"player id %d received message from player id %d\n",*pidTo,*pidFrom);

	if (0 == *pidFrom)
	{
		FixUpPointers(pvBuffer);
	}
	// remove message (unless its a peek)
	if (!(dwFlags & DPRECEIVE_PEEK))
	{
		if (!pmsgPrev) 
		{
			// 1st message on list
			this->pMessageList = pmsg->pNextMessage;
		} else {
			// not 1st message on list
			pmsgPrev->pNextMessage = pmsg->pNextMessage;
		}	
		
		if(pmsg == this->pLastMessage){
			this->pLastMessage = pmsgPrev;
		}

		FreeMessageNode(this, pmsg);
	}

    return hr;
        
}// InternalReceive


HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize	) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2);
		
	LEAVE_DPLAY();
	
	return hr;
			
}//DP_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParms(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize,LPDPLAYI_PLAYER *ppPlayerFrom,
                LPDPLAYI_PLAYER *ppPlayerTo, LPDPLAYI_GROUP *ppGroupTo, BOOL *pbToPlayer)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		*ppPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(*ppPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			return DPERR_INVALIDPLAYER;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			*ppPlayerTo = PlayerFromID(this,idTo);
			if (VALID_DPLAY_PLAYER(*ppPlayerTo)) 
			{		  
				*pbToPlayer = TRUE;
			}
			else 
			{
				*ppGroupTo = GroupFromID(this,idTo);
				if (VALID_DPLAY_GROUP(*ppGroupTo)) 
				{
					*pbToPlayer = FALSE;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					return DPERR_INVALIDPARAMS;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(dwFlags))
		{
			DPF_ERR("bad dwFlags");
            return DPERR_INVALIDPARAMS;
		}

		if((dwFlags & DPSEND_ASYNC)){
			DPF_ERR("trying async send on old send api");
			return DPERR_UNSUPPORTED;
		}

        if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
                return DPERR_INVALIDPARAMS;
            }

            // secure message can only be sent reliable
            if (!(dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
                return DPERR_INVALIDPARAMS;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(pvBuffer,dwBufSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (0 == dwBufSize)
		{
			DPF_ERR("invalid buffer size");
			return DPERR_INVALIDPARAMS;			
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        return DPERR_INVALIDPARAMS;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((*ppPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }
    
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Send"
HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo; 
    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;
	BOOL bToPlayer= FALSE;

	ENTER_ALL();

	hr=ValidateCommonSendParms(lpDP, idFrom, idTo, dwFlags, pvBuffer, dwBufSize,
							   &pPlayerFrom, &pPlayerTo, &pGroupTo, &bToPlayer);

	if(FAILED(hr)){
		LEAVE_ALL();
		return hr;
	}

    this = DPLAY_FROM_INT(lpDP);
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
		// Since the lobby already sent the message, we can just return
		// from here.
		LEAVE_ALL();
		return hr;
	}

	// do the send
	if (bToPlayer)
	{
		hr = SendPlayerMessage( this, pPlayerFrom, pPlayerTo, dwFlags, pvBuffer, 
			dwBufSize);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
				dwBufSize,TRUE);
	}

	if (FAILED(hr)) DPF(0," send failed - hr = 0x%08lx\n",hr);

	LEAVE_ALL();
    return hr;
        
}//DP_Send

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParmsEx(LPDIRECTPLAY lpDP, LPSENDPARMS psp)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
		if (!VALID_DPLAY_PLAYER(psp->pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr=DPERR_INVALIDPLAYER;
    		goto ERROR_EXIT;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			psp->pPlayerTo = PlayerFromID(this,psp->idTo);
			if (VALID_DPLAY_PLAYER(psp->pPlayerTo)) 
			{		  
				psp->pGroupTo = NULL;
			}
			else 
			{
				psp->pGroupTo = GroupFromID(this,psp->idTo);
				if (VALID_DPLAY_GROUP(psp->pGroupTo)) 
				{
					psp->pPlayerTo = NULL;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr=DPERR_INVALIDPLAYER;
		    		goto ERROR_EXIT;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(psp->dwFlags))
		{
			DPF_ERR("bad dwFlags");
			hr=DPERR_INVALIDFLAGS;
    		goto ERROR_EXIT;
		}

		if((psp->dwFlags & DPSEND_ASYNC) && !(this->dwSPFlags & DPCAPS_ASYNCSUPPORTED)){
			DPF_ERR("trying async send when not supported");
			return DPERR_UNSUPPORTED;
		}

        if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }

            // secure message can only be sent reliable
            if (!(psp->dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(psp->lpData,psp->dwDataSize))
		{
	        DPF_ERR( "bad buffer pointer" );
    		goto INVALID_PARMS_EXIT;
		}

		if(!VALID_DWORD_PTR(psp->lpdwMsgID)){
			DPF_ERR( "bad message id pointer\n");
    		goto INVALID_PARMS_EXIT;
		}

		if (0 == psp->dwDataSize)
		{
			DPF_ERR("invalid buffer size");
    		goto INVALID_PARMS_EXIT;
		}
		

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
		goto INVALID_PARMS_EXIT;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((psp->pPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (psp->dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((psp->dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }

	if(psp->dwPriority && !(this->dwSPFlags & DPCAPS_SENDPRIORITYSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    if(psp->dwPriority > DPSEND_MAX_PRI){
	    DPF_ERR( "Priority is too high for user send" );		
	    hr=DPERR_INVALIDPRIORITY;
    	goto ERROR_EXIT;
    }

	if(psp->dwTimeout && !(this->dwSPFlags & DPCAPS_SENDTIMEOUTSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    // do tests for async send validity
    if(psp->dwFlags & DPSEND_ASYNC){
    	#ifdef DEBUG
		if(psp->dwTimeout > 60000*60){
   			DPF_ERR("SendTimeOut is greater than 1 hour?");
    	} else if(psp->dwTimeout > 60000*5){
    		DPF_ERR( "SendTimeOut is greater than 5 minutes?");
    	}
    	#endif
    } else {
    	// A synchronous send.  
    	if(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG){
    		DPF_ERR( "Can't use DPSEND_NOSENDCOMPLETEMSG on synchronous send\n");
    		return DPERR_INVALIDFLAGS;
    	}
    }
    
    return DP_OK;

INVALID_PARMS_EXIT:    
	return DPERR_INVALIDPARAMS;

ERROR_EXIT:
	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendEx"

#ifdef DEBUG
UINT nCallsToSend=0;
#endif

HRESULT DPAPI DP_SendEx(
	LPDIRECTPLAY lpDP, 
	DPID idFrom, 
	DPID idTo, 
	DWORD dwFlags,
	LPVOID lpData, 
	DWORD dwDataSize, 
	DWORD dwPriority, 
	DWORD dwTimeout, 
	LPVOID lpUserContext,
	DWORD_PTR *lpdwMsgID)
{
    HRESULT hr = DP_OK;

    LPDPLAYI_DPLAY this;
	LPSENDPARMS psp;

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	// make sure we 0 out his returned msg id.  Just to be safe
	if (lpdwMsgID)
		*lpdwMsgID = 0;

	if(FAILED(hr)){
		return hr;
	}

	psp=GetSendParms(); // allocates send parm, sets refcount to 1.

	if(!psp){
		return DPERR_OUTOFMEMORY;
	}
	
	InitBilink(&psp->PendingList);

	psp->dwSendTime    = timeGetTime();

	psp->idFrom        = idFrom;
	psp->idTo          = idTo;
	psp->dwFlags       = dwFlags;
	psp->lpData        = lpData;		// user buffer, not valid after return from call
	psp->dwDataSize    = dwDataSize;    // unless DPSEND_NOCOPY is set.
	psp->dwPriority    = dwPriority;
	psp->dwTimeout     = dwTimeout;
	psp->lpUserContext = lpUserContext;
	psp->lpdwMsgID     = lpdwMsgID;
		
	if(!psp->lpdwMsgID){
		psp->lpdwMsgID = &psp->dwMsgID;
	}

	psp->hr            = DP_OK;
	
	psp->cBuffers         = 0;
	psp->dwTotalSize      = dwDataSize;

	psp->iContext = 0;
	psp->nContext = 0; 
	psp->nComplete= 0;
	psp->hContext = NULL;

	ENTER_ALL();

	hr=ValidateCommonSendParmsEx(lpDP, psp); // Fills in players and groups.
	
	if(FAILED(hr)){
		psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;		
		goto EXIT;
	}

	//
	// Double buffer the send memory if necessary.
	//
	
	if((psp->dwFlags & DPSEND_ASYNC) && !(psp->dwFlags & DPSEND_NOCOPY))
	{
		// ASYNC send and sender retains ownership of send buffers, so we must copy.
		psp->Buffers[0].pData      = MsgAlloc(psp->dwDataSize);
		if(!psp->Buffers[0].pData){
			hr=DPERR_OUTOFMEMORY;
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
			goto EXIT;
		}
		psp->Buffers[0].len        = psp->dwDataSize;
		
		memcpy(psp->Buffers[0].pData,psp->lpData,psp->dwDataSize);
		
		psp->BufFree[0].fnFree     = MsgFree;
		psp->BufFree[0].lpvContext = NULL;

		if(this->pProtocol){
			psp->dwFlags |= DPSEND_NOCOPY;	// we copied the data, so the protocol doesn't need to.
		}
		
	} else {
		psp->Buffers[0].pData = lpData;
		psp->Buffers[0].len   = dwDataSize;
		psp->BufFree[0].fnFree = NULL;
		psp->BufFree[0].lpvContext = NULL;
	}
	psp->cBuffers=1;
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		// NOTE: MYRONTH, MAKE PRV_SendEx
		//      - not likely now, DP4 being put to bed AO 04/03/2001
		#if 0
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
						
		// Since the lobby already sent the message, we can just return
		// from here.
		#endif
		hr=E_NOTIMPL;
		LEAVE_ALL();
		return hr;
	}

	if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags & DPSEND_ASYNC)){
		InterlockedIncrement(&psp->pPlayerFrom->nPendingSends);
		InsertBefore(&psp->PendingList, &psp->pPlayerFrom->PendingList);
		DPF(9,"INC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
	}	

	// do the send
	if (psp->pPlayerTo)
	{
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendPlayerMessageEx( this, psp );
	}
	else 
	{
		ASSERT(psp->pGroupTo);
		// send to group
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendGroupMessageEx(this, psp, TRUE);
	}

EXIT:
	if(FAILED(hr) && hr!=DPERR_PENDING){
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG)){
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if(psp->pPlayerFrom){
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				Delete(&psp->PendingList);
				InitBilink(&psp->PendingList);
			}
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
		}
	}

	LEAVE_ALL();

	pspDecRef(this,psp); // remove this functions reference.

    return hr;

} // DP_SendEx

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;
	PSENDPARMS psp=NULL;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(dwFlags){
		// Reserved for future expansion of API.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwMsgID){

                psp=pspFromContext(this, (LPVOID)(DWORD_PTR)dwMsgID, TRUE); // adds a reference to psp

		if(!psp){
			hr=DPERR_UNKNOWNMESSAGE;
			goto ERROR_EXIT;
		}

		EnterCriticalSection(&psp->cs);
		if(psp->nComplete){
			LeaveCriticalSection(&psp->cs);
			hr=DPERR_CANCELFAILED;
			goto ERROR_EXIT2;
		}
		LeaveCriticalSection(&psp->cs);

		// We don't need to lock the Context list, since it cannot grow now since the send returned, so
		// the list is held in place by the refcount on the psp.
		ReadContextList(this, psp->hContext, &CancelData.lprglpvSPMsgID, &CancelData.cSPMsgID,FALSE);
	} else {
		CancelData.dwFlags=DPCANCELSEND_ALL;
		CancelData.lprglpvSPMsgID = 0;
		CancelData.cSPMsgID       = 0;
	}
	
	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = 0;
	CancelData.dwMinPriority  = 0;
	CancelData.dwMaxPriority  = 0;
	
	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate.
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT2:
	if(psp){
		pspDecRef(this, psp);
	}	

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
	
} // DP_CancelMessage

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwFlags){
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(dwMinPriority > dwMaxPriority){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	if(dwMaxPriority > DPSEND_MAX_PRIORITY){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = DPCANCELSEND_PRIORITY;
	CancelData.lprglpvSPMsgID = NULL;
	CancelData.cSPMsgID       = 0;
	CancelData.dwMinPriority  = dwMinPriority;
	CancelData.dwMaxPriority  = dwMaxPriority;

	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_CancelPriority

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageQueue"

extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_GETMESSAGEQUEUEDATA GetMessageQueueData;
	LPMESSAGENODE pmsn;
	LPDPLAYI_PLAYER lpPlayer;
	DWORD dwPlayerFlags;


	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!dwFlags){
		dwFlags=DPMESSAGEQUEUE_SEND;
	}

	if( (!(dwFlags & (DPMESSAGEQUEUE_SEND|DPMESSAGEQUEUE_RECEIVE) ) ) || 
		((dwFlags-1 & dwFlags)!=0)
	  )
	{
		// an invalid flag bit is set OR more than one flag bit is set.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	// Parameter Validation - yada yada yada
	if(dwFlags==DPMESSAGEQUEUE_SEND){	
	
		if(!this->pcbSPCallbacks->GetMessageQueue && !(this->pProtocol)){
			hr=DPERR_UNSUPPORTED;
			goto ERROR_EXIT;
		}
		
		if(idFrom){
		
			// can only get send queue for local from players.
			
			lpPlayer=PlayerFromID(this,idFrom);

			// make sure this is not a group.
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //ISSUE: only works because players/groups differ in size!
				lpPlayer=NULL;
			}
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	

			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			
			if(!lpPlayer) {
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}

			// Route messages through system player on host unless DX3 in game
			// Messages delivered by host use the embedded FromID in the message
			// to notify the receiver who the message was from.

			if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   		(! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
			{
				ASSERT(lpPlayer->dwIDSysPlayer);
				idTo = lpPlayer->dwIDSysPlayer;
			}

		}
		
	} else {
		// must be asking for the receive queue
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	
			
			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		// can't receive messages from a group.
		if(idFrom){
		
			lpPlayer=PlayerFromID(this,idFrom);
			
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //ISSUE: only works because players/groups differ in size!
				lpPlayer=NULL;
			}

			if(!lpPlayer){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
	}


	if(dwFlags == DPMESSAGEQUEUE_SEND){

		// Get the send queue from the SP.
	
		GetMessageQueueData.lpISP   = this->pISP;
		GetMessageQueueData.dwFlags = 0;
		GetMessageQueueData.idFrom  = idFrom;
		GetMessageQueueData.idTo    = idTo;
		if(lpdwNumMsgs){
			GetMessageQueueData.lpdwNumMsgs = &dwNumMsgs;
		} else {
			GetMessageQueueData.lpdwNumMsgs = NULL;
		}
		if(lpdwNumBytes){
			GetMessageQueueData.lpdwNumBytes = &dwNumBytes;
		} else {
			GetMessageQueueData.lpdwNumBytes = NULL;
		}
		if(this->pProtocol){
			hr=ProtocolGetMessageQueue(&GetMessageQueueData);
		} else {
			hr=CALLSP(this->pcbSPCallbacks->GetMessageQueue,&GetMessageQueueData);
		}	

		if(FAILED(hr)){
			goto ERROR_EXIT;
		}
		

	} else {

		ASSERT(dwFlags == DPMESSAGEQUEUE_RECEIVE);
		// Get DPLAY's receive Queue
	
	
		dwNumMsgs  = 0;
		dwNumBytes = 0;

		pmsn = this->pMessageList;

		// optimization: if we don't specify to or from, and don't want bytes, just
		//	grab the count
		if (!idTo && !idFrom && !lpdwNumBytes)
		{
			dwNumMsgs = this->nMessages;
		} 
		else			// the normal way
		{
			while (pmsn)
			{
				BOOL count = TRUE;

				if (idTo && idTo != pmsn->idTo)
				{
					count = FALSE;
				}	

				if (idFrom && idFrom != pmsn->idFrom)
				{
					count = FALSE;
				}	

				if (count)
				{
					dwNumMsgs++;
					dwNumBytes+=pmsn->dwMessageSize;
				}
				pmsn = pmsn->pNextMessage;
			}
		}
	}
	
	TRY {
		if(lpdwNumMsgs){
			*lpdwNumMsgs = dwNumMsgs;
		}
		if(lpdwNumBytes){
			*lpdwNumBytes = dwNumBytes;
		}	
	} EXCEPT( EXCEPTION_EXECUTE_HANDLER ) {
        DPF_ERR( "GetMessageQueue: Exception encountered setting returned values" );
        hr=DPERR_INVALIDPARAMS;
    }
 

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_GetMessageQueue

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupData"  

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckSetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPSET_REMOTE | DPSET_LOCAL | DPSET_GUARANTEED)) 
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}
	if ( (dwFlags & DPSET_LOCAL) && (dwFlags & DPSET_GUARANTEED) )
	{
		DPF_ERR(" invalid dwFlags combination");
		return DPERR_INVALIDPARAMS;
	}
	
	return DP_OK;

} // CheckSetDataFlags

/*
 ** InternalSetData
 *
 *  CALLED BY:	DP_SetGroupData and DP_SetPlayerData, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupData or DP_SetPlayerData - this
 * 			means we need to propagate the data - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the data on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player data.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
		    lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set data on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}
		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}
    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
   
	// If this is a lobby-owned object, and it's remote, then call the lobby
	if(!(dwFlags & DPSET_LOCAL) && IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.
		// In that case, the lobby provider's receive thread needs to
		// be able to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_SetPlayerData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}

		// Take the lock again
		ENTER_DPLAY();

		// If we failed, exit here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupData in the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the data
	hr = DoPlayerData(lpPlayer,pvData,dwDataSize,dwFlags);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set data - hr = 0x%08lx\n",hr);
		return hr;
    }
	
	if (!(dwFlags & DPSET_LOCAL))
	{
		// tell the world
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				ASSERT(1 == gnDPCSCount);
				LEAVE_DPLAY();
				hr = SendDataChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEE);
				ENTER_DPLAY();
			}	
			else
			{
				hr = SendDataChanged(this,lpPlayer,fPlayer,0);
			}
		}
	}

	return hr;

} // InternalSetData

HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,FALSE,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupData   


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerData"

HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,TRUE,TRUE);
															  
	LEAVE_DPLAY();
	
	return hr;
	
} // DP_SetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupName/SetPlayerName"

/*
 ** InternalSetName
 *
 *  CALLED BY:	DP_SetGroupName and DP_SetPlayerName, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupName or DP_SetPlayerName - this
 * 			means we need to propagate the Name - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the Name on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player Name.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPWSTR lpszShortName,lpszLongName;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set name on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}

        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared.  If it is cleared, it means the lobby called into us
	// to set the name of a remote group.  We don't want to call the lobby
	// back in that case.
	if(!(dwFlags & DPSET_LOCAL) && (IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		if(fPlayer)
		{
			hr = PRV_SetPlayerName(this->lpLobbyObject, id, pName, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupName(this->lpLobbyObject, id, pName, dwFlags);
		}

		// Take the lock back
		ENTER_DPLAY();

		// If it failed, just bail here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupName in lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the name
	hr = DoPlayerName(lpPlayer,pName);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set name - hr = 0x%08lx\n",hr);
		return hr;
    }

	if (!(dwFlags & DPSET_LOCAL))
	{
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEED);
			}											  
			else
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,0);
			} 	
		}
	}

	return hr;

} // InternalSetName

HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,FALSE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerName"

HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,TRUE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalSetSessionDesc"
HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc, DWORD dwFlags, BOOL fPropagate)
{
	LPDPLAYI_DPLAY this;
    HRESULT hr;
    DPCAPS dpCaps;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			return DPERR_NOSESSIONS;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
		{
			DPF_ERR("invalid session desc flags");
			return DPERR_INVALIDFLAGS;
		}

		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
        // no flags are supported
        if (dwFlags != 0)
        {
	        DPF_ERR( "Invalid flags" );
	        return DPERR_INVALIDPARAMS;
        }

		// This method is not supported for lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("SetSessionDesc not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // check to make sure there is a system player
	if (!this->pSysPlayer)
	{
		DPF(1,"SetSessionDesc - session not currently open - failing");
		return E_FAIL;
	}

    // only a host can change the session desc
    // fPropagate is used here to distinguish between a user call and an
    // internal call (e.g. from handler.c)
    if ( fPropagate && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
    {
		DPF_ERR("A non-host can't set session desc");
		return DPERR_ACCESSDENIED;
    }

    // can't set max allowed players to less than current players
    // unless it is zero which means unlimited max players
	if ((lpsdDesc->dwMaxPlayers > 0) &&
        (lpsdDesc->dwMaxPlayers < this->lpsdDesc->dwCurrentPlayers))
	{
		DPF_ERR("can't set max players < current players");
		return DPERR_INVALIDPARAMS;
	}

    // get the caps so we can check how many max players sp allows
    dpCaps.dwSize = sizeof(DPCAPS);
    hr = InternalGetCaps(lpDP, 0, &dpCaps, FALSE, 0);
    if (FAILED(hr))
    {
        DPF_ERR("couldn't get caps for the current session");
        return hr;
    }

	// we don't allow reseting the following flags 
    //   DPSESSION_NOMESSAGEID, 
    //   DPSESSION_KEEPALIVE, 
    //   DPSESSION_MIGRATEHOST
    //   DPSESSION_SECURESERVER
    //   DPSESSION_CLIENTSERVER
    // all other flags are OK
    
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ==
			(lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)) )
	{
		DPF_ERR("error - can not reset DPSESSION_NOMESSAGEID");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE) ==
			(lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)) )
	{
		DPF_ERR("error - can not reset DPSESSION_KEEPALIVE");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) ==
			(lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MIGRATEHOST");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_SECURESERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_SECURESERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_CLIENTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MULTICASTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) == 
			(lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)) )
	{
		DPF_ERR("error - can not change DPSESSION_DIRECTPLAYPROTOCOL\n");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY) == 
			(lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY)) )
	{
		DPF_ERR("error - can not change DPSESSION_OPTIMIZELATENCY\n");
		return DPERR_INVALIDPARAMS;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_ALLOWVOICERETRO ){
		// Don't allow over-riding this flag.
		lpsdDesc->dwFlags |= DPSESSION_ALLOWVOICERETRO;
	}

    // update the existing session desc
	this->lpsdDesc->dwFlags = lpsdDesc->dwFlags;
	this->lpsdDesc->dwMaxPlayers = lpsdDesc->dwMaxPlayers;
	this->lpsdDesc->dwUser1 = lpsdDesc->dwUser1;
	this->lpsdDesc->dwUser2 = lpsdDesc->dwUser2;
	this->lpsdDesc->dwUser3	= lpsdDesc->dwUser3;
	this->lpsdDesc->dwUser4	= lpsdDesc->dwUser4;

	// copy strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	GetString(&(this->lpsdDesc->lpszSessionName),lpsdDesc->lpszSessionName);

	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	GetString(&(this->lpsdDesc->lpszPassword),lpsdDesc->lpszPassword);

    // if session has a password, setup the password required flag
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        this->lpsdDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
    }
    else
    {
        this->lpsdDesc->dwFlags &= ~DPSESSION_PASSWORDREQUIRED;
    }

    // tell the world/local players
	if (fPropagate)
	{
		// send this message guaranteed
	    hr = SendSessionDescChanged(this, dwFlags | DPSEND_GUARANTEED);
	}

    return hr;
} // InternalSetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetSessionDesc"
HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
    HRESULT hr;
    BOOL bPropogate;
	LPDPLAYI_DPLAY this;

	ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto exit;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			hr = DPERR_NOSESSIONS;
			goto exit;
		}
	} 
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto exit;
    }

	if(this->lpsdDesc->dwFlags & DPSESSION_NOSESSIONDESCMESSAGES){
		bPropogate=FALSE;
	} else {
		bPropogate=TRUE;
	}

    hr = InternalSetSessionDesc(lpDP, lpsdDesc, dwFlags, bPropogate);


exit:
    LEAVE_DPLAY();

    return hr;
} // DP_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SecureOpen"

HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,                             
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // validate regular open params
        hr = ValidateOpenParams(this,lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
		    return hr;
        }

        // validate the additional params
        // null lpSecDesc is ok, we'll use the default
        if (lpSecDesc)            
        {
            // app passed in a security desc 

            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
	            goto INVALID_PARAMS_EXIT;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
    			DPF_ERR("invalid security desc");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpSecDesc->lpszSSPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszSSPIProvider)) ) 
		    {
	            DPF_ERR( "bad SSPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpSecDesc->lpszCAPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszCAPIProvider)) ) 
		    {
	            DPF_ERR( "bad CAPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // app passed in credentials

            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list
            
            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
    			DPF_ERR("invalid credentials structure");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpCredentials->lpszUsername && !VALID_READ_STRING_PTR(lpCredentials->lpszUsername,
			    WSTRLEN_BYTES(lpCredentials->lpszUsername)) ) 
		    {
	            DPF_ERR( "bad user name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszPassword && !VALID_READ_STRING_PTR(lpCredentials->lpszPassword,
			    WSTRLEN_BYTES(lpCredentials->lpszPassword)) ) 
		    {
	            DPF_ERR( "bad password string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszDomain && !VALID_READ_STRING_PTR(lpCredentials->lpszDomain,
			    WSTRLEN_BYTES(lpCredentials->lpszDomain)) ) 
		    {
	            DPF_ERR( "bad domain name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr=DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,lpSecDesc,lpCredentials);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

INVALID_PARAMS_EXIT:
	hr=DPERR_INVALIDPARAMS;
	goto CLEANUP_EXIT;
	
}//DP_SecureOpen

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAccount"

// take a pointer to a buffer, stick an account desc in it, slap the strings
// on the end.
HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen=0; // user name length, in bytes
	HRESULT hr;
	LPDPACCOUNTDESC pAccountDesc;
    PCtxtHandle phContext;
    DWORD dwBufferSize=0;
    LPDPLAYI_PLAYER pPlayer;
    LPWSTR pwszUserName=NULL;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        if (!VALID_DPACCOUNTDESC_FLAGS(dwFlags))
        {
  		    DPF_ERRVAL("invalid flags (0x%08x)",dwFlags);
            return DPERR_INVALIDFLAGS;
        }

        // need to have a session
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting account desc!");
			return DPERR_NOSESSIONS;
		}

        // must be a secure session
        if (!SECURE_SERVER(this))
        {
            DPF_ERR("session is not secure!");
            return DPERR_UNSUPPORTED;
        }

        // allowed only on a nameserver
        if (!IAM_NAMESERVER(this))
        {
            DPF_ERR("can't get account info on the client!");
            return DPERR_ACCESSDENIED;
        }

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;

		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

        // get the player structure for the specified id
        pPlayer = PlayerFromID(this,dpid);
        if (!pPlayer)
        {
            DPF_ERRVAL("Failed to get security context handle - Invalid player id %d", dpid);
            return DPERR_INVALIDPLAYER;
        }

        if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
        {
            // assert so we notice!
            ASSERT(FALSE);
            DPF_ERR("Failed to get security context handle - a system player was passed");
            return DPERR_INVALIDPLAYER;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // only system players have a security context handle
    // so get the corresponding system player
    pPlayer = PlayerFromID(this,pPlayer->dwIDSysPlayer);
    if (!pPlayer)
    {
        DPF_ERRVAL("Failed to locate system player (%d)",pPlayer->dwIDSysPlayer);
        return DPERR_INVALIDPLAYER;
    }

    // check if they are asking for nameserver's account description
    if (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
    {
        // yep, can't do it
        DPF_ERR("Can't get nameserver's account description");
        return DPERR_INVALIDPLAYER;
    }

    // if we reach here means player is logged in, so just grab the context handle
    // belonging to the system player
    phContext = &(pPlayer->pClientInfo->hContext);

    // get user name associated with this security context
    hr = OS_QueryContextUserName(phContext,&pwszUserName);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get user name associated: hr=0x%08x",hr);
        return hr;
    }

    // remember the length of the username
    nNameLen = WSTRLEN(pwszUserName);

    // calculate the required buffer size
    dwBufferSize = sizeof(DPACCOUNTDESC);

    // add the size of username
    if (fAnsi)
    {
        dwBufferSize += nNameLen;
    }
    else
    {
        dwBufferSize += WSTRLEN_BYTES(pwszUserName);
    }

    // check if user passed in a big enough buffer
	if (*pdwSize < dwBufferSize)
	{
		*pdwSize = dwBufferSize;
        hr = DPERR_BUFFERTOOSMALL;
        goto CLEANUP_EXIT;
	}

	// zero buffer passed in
	ZeroMemory(pvBuffer,*pdwSize);
    // use the buffer as an accountdesc
	pAccountDesc = (LPDPACCOUNTDESC) pvBuffer;
    pAccountDesc->dwSize = sizeof(DPACCOUNTDESC);
    // flags are zero for now

    // set buffer size to return to app
	*pdwSize = dwBufferSize;

    // copy username string into the buffer after the desc.
    if (nNameLen)
    {
		LPBYTE pbUsername = (LPBYTE)pvBuffer+sizeof(DPACCOUNTDESC);

        // return string in the proper format to the app
        if (fAnsi)
        {
            // app called the ansi interface, so convert string to ansi before copying
            WideToAnsi(pbUsername,pwszUserName,nNameLen);
            pAccountDesc->lpszAccountIDA = (LPSTR)pbUsername;
        }
        else
        {
            // app called the unicode interface, so just copy the strings over
            wcscpy((LPWSTR)pbUsername, pwszUserName);
            pAccountDesc->lpszAccountID = (LPWSTR)pbUsername;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    if (pwszUserName) DPMEM_FREE(pwszUserName);
	return hr;
} // InternalGetPlayerAccount


HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendChatMessage"
/*
 ** DP_SendChatMessage
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Send a chat message to the appropriate players
 *
 */
HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER pPlayerFrom = NULL, pPlayerTo = NULL;
	LPWSTR lpszMessage = NULL;
	BOOL bToPlayer = FALSE;

	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto EXIT_SENDCHATMESSAGE;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto EXIT_SENDCHATMESSAGE;
		}

		// if the player from is remote, fail the call
		if(!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("Cannot send a chat message FROM a remote player");
			hr = DPERR_ACCESSDENIED;
			goto EXIT_SENDCHATMESSAGE;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			pPlayerTo = PlayerFromID(this,idTo);
			if(VALID_DPLAY_PLAYER(pPlayerTo))
			{
				bToPlayer = TRUE;
			}
			else
			{		  
				pPlayerTo = (LPDPLAYI_PLAYER)GroupFromID(this,idTo);
				if (!VALID_DPLAY_GROUP(((LPDPLAYI_GROUP)pPlayerTo))) 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr = DPERR_INVALIDPARAMS;
					goto EXIT_SENDCHATMESSAGE;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if(!VALID_CHAT_FLAGS(dwFlags))
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// verify the flags inside the DPCHAT struct (none currently defined)
		if(lpMsg->dwFlags)
		{
			DPF_ERR("Invalid flags in the DPCHAT structure");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}
		
		// check message string
		lpszMessage = lpMsg->lpszMessage;
		if ( !lpszMessage ||
			!VALID_READ_STRING_PTR(lpszMessage,WSTRLEN_BYTES(lpszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGE;
    }
	
	// do the send
	if(!IS_LOBBY_OWNED(this))
	{
		// just send to the player
		hr = SendChatMessage(this, pPlayerFrom, pPlayerTo, dwFlags, lpMsg, bToPlayer);
	}
	else
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_SendChatMessage(this->lpLobbyObject, idFrom, idTo, dwFlags, lpMsg);

		// Take the lock back
		ENTER_DPLAY();
	}

	if (FAILED(hr))
	{
		DPF_ERRVAL("SendChatMessage failed - hr = 0x%08lx\n",hr);
	}


EXIT_SENDCHATMESSAGE:

	LEAVE_ALL();

	return hr;

} // DP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupParent"
/*
 ** DP_GetGroupParent
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Get the DPID of a group's parent group
 *
 */
HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent)	
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;


	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

	    pGroup = GroupFromID(this,idGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idGroup)) 
	    {
			LEAVE_DPLAY();
			DPF_ERRVAL("invalid group id = %d", idGroup);
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(pidParent))
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid pidParent");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// Fill in the group's parent
	*pidParent = pGroup->dwIDParent;

	LEAVE_DPLAY();
	return DP_OK;

} // DP_GetGroupParent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\msgmem.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
*
*  File:       msgmem.c
*  Content:	   message memory management
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/31/97   aarono    Original
*
*
* Abstract
* --------
* (AO 12-31-97)
* Contention is that using the heap manager is not actually significant
* vs doing our own memory management for message buffers.  I do not
* currently support this contention and believe that directplay should not
* call HeapAlloc or GlobalAlloc in the hot path.  In order to prove this
* though I will first use HeapAlloc and GlobalAlloc for a profile run
* through these routines.  If the per hit is significant for a server type
* configuration then we will write our own packet memory manager. If the
* perf hit of using system heap is negligible this fill will be left as is.
***************************************************************************/

#include "dplaypr.h"

void * MsgAlloc( int size )
{
	return DPMEM_ALLOC(size);
}

void MsgFree (void *context, void *pmem)
{
	DPMEM_FREE(pmem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\namesrv.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       namesrv.c
 *  Content:	name management code
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  1/96		andyco	created it
 *	4/15/96		andyco	added handledeadnameserver
 *	6/19/96		kipo	Fixed a problem in GrowTable() with MemReAlloc() returning
 *						NULL, which caused a memory leak and possibly a crash if someone
 *						was not expecting this->pNameTable to ever be NULL.
 *	6/22/96		andyco	indicate whether we're asking for player or group id
 *						in sendnsnewidrequest.
 *	8/1/96		andyco	changed dp_destroyplayer to internaldestroy
 *	8/6/96		andyco	version in commands.  extensible on the wire support. 
 *						id mangling.
 *	8/8/96		andyco	 get playerid timeout from sp (by calling getdefaultimeout).
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 *	10/14/96	andyco	check nametable index BEFORE using it...bug 3946
 *	12/18/96	andyco	moved bogus assert on additemtonametable 
 *  01/17/97    sohailm now we send player flags in request player id message
 *	1/15/98		andyco	cleaned up handledeadnameserver - no longer nukes
 *						old sysplayer.
 *  3/14/97     sohailm integrated security code into SendNewIDRequest, 
 *                      added functions IsValidID and DataFromID. Updated function NameFromID
 *                      to use IsValidID.
 *	3/17/97		myronth	Fixed AddItemToNameTable to work from lobby objects
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Updated SendCreateMessage call to pass NULL for session password
 *  3/28/97     sohailm Request group id message is being signed now if session is secure
 *  4/14/97     sohailm Updated calls to SetupCredentials() to reflect change in params.
 *	5/8/97		myronth	Fixed comment to better reflect the state of affairs
 *  5/12/97     sohialm Updated SendNSNewIDRequest() to process the new PLAYERIDREPLY format
 *	5/17/97		kipo	There was a bug in SendNSNewIDRequest() where it was setting
 *						the ghReplyProcessed event twice on the way out,
 *						which would let handler.c in, trashing the buffer
 *						that SendNSNewIDRequest() was using.
  *	5/18/97		andyco	changed nameserver migration to always send delete / create messages
 *						for new host. nuke item in table if  we add something new
 *						to non-empty spot.
 *	6/16/97		andyco	reset ping timer when we become host
 *  6/22/97     sohailm added support to store security desc in the dplay object on the client
 *	8/19/97		myronth	Send lobby system message when we become the host
 *	8/19/97		myronth	Changed to different lobby system message function
 *	9/29/97		myronth	Fixed group ID on DeleteGroup msgs generated by the
 *						corrupt nametable fixup code (#12533)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/29/97	myronth	Nametable corruption fixes (#15234, #15254)
 *	12/29/97	sohailm	Don't migrate the host in client server or secure sessions (#15224)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	Changed PRV_SendStandardSystemMessage
 *	1/27/98		myronth	Moved debug spew for nametable corruption
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  2/18/98     aarono  changed to direct calls to protocol
 *  8/04/99     aarono  added HOSTMIGRATION notification for DirectVoice
 *  8/10/99		rodtoll	Fixed host migration notification (For DXVoice)
 * 04/06/00     rodtoll Updated to match new approach to having only 1 voice server and 1 client attached to object 
 * 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
 ***************************************************************************/


#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"NS_AllocNameTableEntry"


HRESULT GrowTable(LPDPLAYI_DPLAY this) 
{
	LPVOID	pvTempNameTable;

    pvTempNameTable = DPMEM_REALLOC(this->pNameTable,sizeof(NAMETABLE)*this->uiNameTableSize*2);
    if (!pvTempNameTable) 
    {
    	DPF_ERR("COULD NOT GROW NAME TABLE");	
        return E_OUTOFMEMORY;
    }

    this->pNameTable = pvTempNameTable;
    this->uiNameTableSize *= 2;
    DPF(1,"Grew name table to %d entries\n",this->uiNameTableSize);
    return DP_OK;

}

// this code only executes on the NameServer

DPID MangleID(DWORD index,DWORD dwUnique,DWORD dwKey)
{
	DPID id;

    // construct a mangled id, = dwUnique<<16 | index ^ key
    id = dwUnique<<16;
    id |= index;
   	id ^= dwKey;

	return id;
} // MangleID

HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID)
{
    DWORD index;
    BOOL bFoundSlot=FALSE;
    HRESULT hr = DP_OK;
	BOOL bInvalidID = TRUE; // set to FALSE only when we decide this is not
							// not a restricted id
	
    // find the first unoccupied bucket
    index = this->uiNameTableLastUsed;

    // search fron lastused to end. we do this to keep the
    // bucket usage uniformly distributed in the list (i.e. don't
    // always search from beginning for empty slot...)
    while (!bFoundSlot && (index < this->uiNameTableSize))
    {
        // is this slot empty?
        bFoundSlot = (0 == this->pNameTable[index].dwItem);
        if (!bFoundSlot) index++;
    }
    if (!bFoundSlot) 
    {
        index = 0;
        // search from beginning to last used
        while (!bFoundSlot && (index < this->uiNameTableLastUsed))
        {
            // is this slot empty?
            bFoundSlot = (0 == this->pNameTable[index].dwItem);
            if (!bFoundSlot) index++;
        }
            	
    }
    if (!bFoundSlot) 
    {
    	hr = GrowTable(this);
        if (FAILED(hr)) 
        {
                return hr;
        }
        // try again
    	return NS_AllocNameTableEntry(this,pID);
    }

    // make sure we don't reuse b4 client has time to set item
    this->pNameTable[index].dwItem = NAMETABLE_PENDING;
	this->pNameTable[index].dwUnique++;

    this->uiNameTableLastUsed = index;

    while (bInvalidID)
    {
		// mangle it!
		*pID = MangleID(index,this->pNameTable[index].dwUnique,(DWORD)this->lpsdDesc->dwReserved1);

		// EEEK!  make sure the mangled id is not one of our reserved id's 
		if ( (DPID_SERVERPLAYER == *pID ) || (DPID_ALLPLAYERS == *pID) || 
			(DPID_UNKNOWN == *pID) )
		{
			// bump the unique count, and try again
			DPF(2,"NS_AllocNameTableEntry  --  found invalid id - trying again");
			this->pNameTable[index].dwUnique++;
		}
		else 
		{
			// this id is ok
			bInvalidID = FALSE;
		}
    
    } // while
	
    return DP_OK;
        
} // NS_AllocNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"SendNSNewIDRequest"

/*
 ** CopySecurityDesc
 *
 *  CALLED BY: SendNSNewIDRequest()
 *
 *  PARAMETERS: pSecDescDest - security description ptr (destination)
 *				pSecDescSrc - security descrption ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies a security description while allocating memory for SSPIProvider 
 *                and CAPIProvider strings. These strings need to be freed by the calling 
 *                function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySecurityDesc(LPDPSECURITYDESC pSecDescDest, 
                         LPCDPSECURITYDESC pSecDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSecDescDest && pSecDescSrc);

    memcpy(pSecDescDest, pSecDescSrc, sizeof(DPSECURITYDESC));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSecDescDest->lpszSSPIProviderA), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSecDescDest->lpszCAPIProviderA), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSecDescDest->lpszSSPIProvider), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSecDescDest->lpszCAPIProvider), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeSecurityDesc(pSecDescDest, bAnsi);
    return hr;
} // CopySecurityDesc

// copies the security desc into the dplay object
HRESULT StoreSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC pInSecDesc)
{
    LPDPSECURITYDESC pSecDesc;
    HRESULT hr;

    pSecDesc = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDesc)
    {
        DPF_ERR("Failed to store security desc - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    hr = CopySecurityDesc(pSecDesc, pInSecDesc, FALSE);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to copy security desc - hr=0x%08x",hr);
        goto ERROR_EXIT;
    }

    DPF(1,"SSPI provider: %ls",pSecDesc->lpszSSPIProvider);
    if (pSecDesc->lpszCAPIProvider)
    {
        DPF(1,"CAPI provider: %ls",pSecDesc->lpszCAPIProvider);
    }
    else
    {
        DPF(1,"CAPI provider: Microsoft's RSA Base Provider");
    }

    // success
    this->pSecurityDesc = pSecDesc;
    return DP_OK;

    // NOT a fall through

ERROR_EXIT:

    if (pSecDesc) 
    {
        FreeSecurityDesc(pSecDesc,FALSE);
        DPMEM_FREE(pSecDesc);
    }
    return hr;
}

// send a request for a new id to the namesrvr
// reply will include the id
// hmm, we should send the player stuff w/ the id request,  so ns doesn't get out of sync
HRESULT SendNSNewIDRequest(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer) 
{
    LPMSG_REQUESTPLAYERID pmsg; // the request we will send
    LPMSG_PLAYERIDREPLY pReply=NULL;
    LPBYTE pcReply=NULL;
    DWORD cbReply;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	LPBYTE pBuffer;
	DWORD dwTimeout, dwVersion;
    BOOL fLogin=FALSE;
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_REQUESTPLAYERID);
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_REQUESTPLAYERID)(pBuffer + this->dwSPHeaderSize);

	// set up msg
    SET_MESSAGE_HDR(pmsg);
    if (fPlayer) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTPLAYERID);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTGROUPID);

    // need to send flags to name server so it can verify permissions
    // before creating an ID for this player
    pmsg->dwFlags = ((LPDPLAYI_PLAYER)dwItem)->dwFlags;
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= DP_GETID_SCALE;

	if(dwTimeout < 30000){
		dwTimeout=30000;
	}

	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));

	DPF(2,"sending new player id request :: flags = %d,timeout = %d\n",((LPDPLAYI_GROUP)dwItem)->dwFlags,dwTimeout);

	if(this->pSysPlayer){
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}	

	SetupForReply(this, DPSP_MSG_REQUESTPLAYERREPLY);
	
    // call send
	// note that this->pNameServer will be NULL when we're requesting our
	// sysplayers id.  it will be non-null for subsequent requests.
	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pBuffer,
						dwMessageSize,DPSEND_GUARANTEED,FALSE);

	DPMEM_FREE(pBuffer);
	if (FAILED(hr)) 
	{
		DPF_ERR("could not send newplayerid request");
		UnSetupForReply(this);
		return hr;
	}
	
	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

    // wait for the answer
    hr = WaitForReply(this,(PCHAR *)&pReply,&cbReply,NULL,dwTimeout);
	pcReply = (LPBYTE)pReply;

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	ASSERT(pReply);

    // get the message version
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);

	// In DX6 and later versioned messages, there is a return code in the
	// reply.  We need to make sure it wasn't an error (#15891)
	if(dwVersion >= DPSP_MSG_DX6VERSION)
	{
		// If we fail, 
		if(FAILED(pReply->hr))
		{
			hr = pReply->hr;
			goto CLEANUP_EXIT;
		}
	}

    *pid = pReply->dwID;

    // If server is DX5 or later and is secure, the reply will contain a security 
	// description detailing the security packages needed for establishing a secure channel
	// with the server.
    if (( dwVersion >= DPSP_MSG_DX5VERSION ) && (pReply->dwSSPIProviderOffset))
    {
        // fix up pointers in security desc in the reply buffer
        if(pReply->dwSSPIProviderOffset > cbReply-sizeof(WCHAR))
        {
            DPF(4,"SECURITY WARN, invalid security provider SSPI offset\n");	
            hr=DPERR_GENERIC;
            goto CLEANUP_EXIT;
        }
        // ensure NULL termination of provider name's
        pcReply[cbReply-2]=0;
        pcReply[cbReply-1]=0;
        
		pReply->dpSecDesc.lpszSSPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwSSPIProviderOffset);
		if (pReply->dwCAPIProviderOffset)
		{
			if(pReply->dwCAPIProviderOffset > cbReply-sizeof(WCHAR)){
	            DPF(4,"SECURITY WARN, invalid security provider CAPI offset\n");	
	            hr=DPERR_GENERIC;
	            goto CLEANUP_EXIT;
			}
			pReply->dpSecDesc.lpszCAPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwCAPIProviderOffset);
		}

        hr = StoreSecurityDesc(this, &(pReply->dpSecDesc));
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to store security desc: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }

        // we need to login
        fLogin = TRUE;

        // set the system player id here, so authentication routines can use it
    	ASSERT(this->pSysPlayer);
        this->pSysPlayer->dwID = *pid;

		// Initialize SSPI and CAPI providers
		hr = LoadSecurityProviders(this, SSPI_CLIENT);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to setup security providers");

			// let handler.c continue
            goto CLEANUP_EXIT;
        }
    }

    if (fLogin)
    {
        hr = Login(this);
        if (FAILED(hr))
        {
            DPF_ERR("User authentication failed...Exiting");
        }
    }


    DPF(2,"received id # %d from name server\n",*pid);

	if(this->pSysPlayer){
		ExecutePendingCommands(this);
	}	

CLEANUP_EXIT:	
    // done
    if(pReply){
		FreeReplyBuffer((PCHAR)pReply);
	}	
    return hr;

} // SendNSNewIDRequest 
	
#undef DPF_MODNAME
#define DPF_MODNAME	"AddItemToNameTable"

// NukeNameTable (below) is about to nuke a player from our (corrupted) nametable
// this routine puts a delete message for that player in our apps message q
// we build a DPSP_MSG_PLAYERMGMT w/ just enough info for BuildDeleteMessage to 
// do it's thing
void QDeleteMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	
	if (fPlayer)
	{
		DPF(5, "Queueing DESTROYPLAYER message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
		msg.dwPlayerID = pPlayer->dwID;
	}
	else
	{
		DPF(5, "Queueing DESTROYGROUP message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUP);
		msg.dwGroupID = pPlayer->dwID;
	}
	
	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteMessage


void QDeletePlayerFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_PLAYER pPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pPlayer->dwID;
	
	DPF(5, "Queueing DELETEPLAYERFROMGROUP message idGroupFrom = %lx, idPlayer = %lx", pGroup->dwID, pPlayer->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeletePlayerFromGroupMessage


void QDeleteGroupFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_GROUP pSubgroup)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUPFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pSubgroup->dwID;
	
	DPF(5, "Queueing DELETEGROUPFROMGROUP message idGroupFrom = %lx, idGroup = %lx", pGroup->dwID, pSubgroup->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteGroupFromGroupMessage


void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom)
    {
		// Only walk the list if it's not the system group	
		if(!(pGroupFrom->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// Next walk the list of players in the group
			pGroupnode = pGroupFrom->pGroupnodes;
			while(pGroupnode)
			{
				if(pGroupnode->pPlayer->dwID == pPlayer->dwID)
				{
					// Queue the DeletePlayerFromGroup message
					QDeletePlayerFromGroupMessage(this, pGroupFrom, pGroupnode->pPlayer);
				}

				// Move to the next one
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Now queue the final destroy message for the player
	QDeleteMessage(this,pPlayer,TRUE);

} // QDeleteAndDestroyMessagesForPlayer


void QDestroyMessageForGroupAndFamily(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP pGroup)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom && (pGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    {
		// Walk the subgroups for this group and see if the group being
		// destroyed is among them.  If it is, send a message.		
		pSubgroup = pGroupFrom->pSubgroups;
		while(pSubgroup)
		{
			// If the ID's match, send the message, but also
			// make sure we don't send a DeleteGroupFromGroup message for
			// a real parent/child relationship
			if((pSubgroup->pGroup->dwID == pGroup->dwID) &&
				(pGroupFrom->dwID != pGroup->dwIDParent))
			{
				QDeleteGroupFromGroupMessage(this, pGroupFrom, pGroup);
			}

			// Move to the next one
			pSubgroup = pSubgroup->pNextSubgroup;
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Next walk the list of players in the group
    pGroupnode = pGroup->pGroupnodes;
    while (pGroupnode)
    {
		// Queue the DeletePlayerFromGroup message
		QDeletePlayerFromGroupMessage(this, pGroup, pGroupnode->pPlayer);

		// Move to the next one
		pGroupnode = pGroupnode->pNextGroupnode;
	}

	// Next walk the list of subgroups (this includes both childres & shortcuts)
	pSubgroup = pGroup->pSubgroups;
	while(pSubgroup)
	{
		// See if the group is just a shortcut or a real child
		if(!(pSubgroup->dwFlags & DPGROUP_SHORTCUT))
		{
			// It's a real child, so just setup the destroy messages
			// NOTE: This goes recursive right here
			QDestroyMessageForGroupAndFamily(this, pSubgroup->pGroup);
		}
		else
		{
			// It's a shortcut, so just queue the deletegroupfromgroup message
			QDeleteGroupFromGroupMessage(this, pGroup, pSubgroup->pGroup);
		}

		// Move to the next one
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	// Now queue the destroy message for the group itself
	QDeleteMessage(this,(LPDPLAYI_PLAYER)pGroup,FALSE);

} // QDestroyMessageForGroupAndFamily


void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	HRESULT hr;
	BOOL fPlayer;
	LPDPLAYI_GROUP pGroup;
	

    TRY
    {
		if (VALID_DPLAY_PLAYER(pPlayer)) fPlayer = TRUE;
		else 
		{
			pGroup = (LPDPLAYI_GROUP)pPlayer;
			if (!VALID_DPLAY_GROUP(pGroup))
			{
				DPF_ERR("found item in nametable - it's not a player or a group - AAAAGH - it's a creepy monster");
				return;
			}
		 	fPlayer = FALSE;
		}
		DPF(0," invalid item found - fPlayer = %d  id = %lx\n",fPlayer,pPlayer->dwID);		
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		ASSERT(FALSE); // ACK!
		return ;
    }

	// now, delete it!	
	if (fPlayer)
	{
		// put a  mesage in the apps message q that the player is being deleted
		QDeleteAndDestroyMessagesForPlayer(this,pPlayer);

		// destroy the player
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
	}
	else
	{
		// put messages in the apps message q that the group and all it's
		// children (and shortcuts) are being destroyed
		QDestroyMessageForGroupAndFamily(this, (LPDPLAYI_GROUP)pPlayer);
		
		// destroy the group
		hr = InternalDestroyGroup(this,(LPDPLAYI_GROUP)pPlayer,FALSE);
	}
	if (FAILED(hr))
	{
		DPF(0,"COULD NOT NUKE ITEM hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	return;
	
}  // NukeNameTableItem


HRESULT AddItemToNameTable(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer,DWORD dwLobbyID)
{
    HRESULT hr=DP_OK;
	DWORD dwUnmangledID;
    DWORD index,unique;
  	BOOL bLocal;
	LPDPLAYI_PLAYER pPlayer = (LPDPLAYI_PLAYER)dwItem;

	// we can cast either a group or a player to a player, since the flags are 
	// in the same place...
	bLocal = (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;

	// non-local players don't need a new index
	if(bLocal)
	{
	  	// If this object is lobby owned, we won't be a nameserver,
		// but we always want to alloc the ID locally anyway
		if(IS_LOBBY_OWNED(this))
		{
			hr = NS_AllocNameTableEntry(this, pid);
		}
		else
		{
			ASSERT(this->pSysPlayer);

			// ask ns for an index
			// if we're the namesrvr, just go get it
			if(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
			{
				hr = NS_AllocNameTableEntry(this,pid);    	
			}
			else 
			{
				hr = SendNSNewIDRequest(this,dwItem,pid,fPlayer);
			}
		}

		if (FAILED(hr)) 
		{
			DPF_ERR("could not get new id for item");
			return hr;	
		}
	}

	dwUnmangledID = *pid ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

	// do we need to grow the table?
	// if so, keep growing it until its big enough...
    while (index >= this->uiNameTableSize) 
    {
        hr = GrowTable(this);
        if (FAILED(hr)) 
        {
            return hr;
        }

    }

    if (index > this->uiNameTableSize ) 
    {
        ASSERT(FALSE); // ??? rut ro
        return E_UNEXPECTED;
    }

	// if there is already something here, we're in trouble.
	// this means we missed a system message (e.g. deleteplayer or deletegroup)
	// and our nametable is corrupt.  we will hope for the best, and delete the
	// item here. andyco.
	if (this->pNameTable[index].dwItem &&  (NAMETABLE_PENDING != this->pNameTable[index].dwItem))
	{
		DPF(5,"		!!!   NAMETABLE CORRUPTION DETECTED.  DPLAY WILL CORRECT ITSELF	!!!");
		NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
	} 

	this->pNameTable[index].dwItem = dwItem;
	this->pNameTable[index].dwUnique = unique;

	// If this is a lobby session, we need to make the ID be the lobby ID
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_AddMapIDNode(this->lpLobbyObject, dwLobbyID, *pid);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to add an entry to the map table, hr = 0x%08x", hr);
			NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
			return hr;
		}

		// Fix the output dpid to be the lobby ID
		*pid = dwLobbyID;
	}

	return hr;
} // AddItemToNameTable

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeNameTableEntry"

// mark this spot in the name table as unused
HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY this,DWORD dpid)
{
    HRESULT hr=DP_OK;
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DWORD id;

	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return E_UNEXPECTED;
	}

	// don't get upset if they try to free the system group or server player id	
	if (DPID_ALLPLAYERS == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_ALLPLAYERS - ignoring");
		return DP_OK;
	}
	
	if (DPID_SERVERPLAYER == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_SERVERPLAYER - ignoring");
		return DP_OK;
	}
	
	
	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF_ERRVAL("Unable to unmap id %lu, not freeing nametable entry", dpid);
			ASSERT(FALSE);
			return DPERR_INVALIDPARAM;
		}
	}
	else
		id = dpid;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
    index = dwUnmangledID & INDEX_MASK;
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	ASSERT(FALSE); 	// ACK!!!
    	// this should *NEVER* happen!
    	// should almost be an int 3 here ?
    	// andyco. 10/14/96
    	DPF_ERR("asked for element outside table!");
        return E_UNEXPECTED;
    }

    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF_ERR("asked for invalid element");
        return E_UNEXPECTED;	 
    }

    if (NAMETABLE_PENDING == this->pNameTable[index].dwItem)
    {
        // remove client info
        if (this->pNameTable[index].pvData)
        {
            DPMEM_FREE(this->pNameTable[index].pvData);
        }
    }

    this->pNameTable[index].dwItem = 0;
    this->pNameTable[index].pvData = NULL;

	// Now delete them from the map table if this is a lobby session
	if(IS_LOBBY_OWNED(this))
	{
		PRV_DeleteMapIDNode(this->lpLobbyObject, dpid);
	}

    return hr;
}// FreeNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"IsValidID"

// check the element at location index in the nametable.
// (if its unique code matches) 
BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id) 
{	
	if (DPID_ALLPLAYERS == id)
	{
		// it's ok.  they tried to resolve the system group to a player
		DPF(8,"asked for id == DPID_ALLPLAYERS - failing");
		return FALSE;
	}
	
	if (DPID_SERVERPLAYER == id)
	{
		// it's ok.  they tried to resolve the server player to a group.
		DPF(8,"asked for id == DPID_SERVERPLAYER - failing");
		return FALSE;
	}
	
	if (!(this->lpsdDesc))
	{
		DPF(1,"unable to resolve player id - session closed");
		return FALSE;
	}	
	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return FALSE;
	}

    return TRUE;

} // IsValidID

#undef DPF_MODNAME
#define DPF_MODNAME	"DataFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return NULL;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id))
        return NULL;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"DataFromID:asked for element outside table - id = %d!",id);
        return NULL;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"DataFromID:asked for element w/ invalid tag - id = %d!",id);
        return NULL;
    }

    return this->pNameTable[index].pvData;
} // DataFromID

#undef DPF_MODNAME
#define DPF_MODNAME	"NameFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
DWORD_PTR NameFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return 0;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id)) return 0;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"NameFromID:asked for element outside table - id = %d!",id);
        return 0;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"NameFromID:asked for element w/ invalid tag - id = %d!",id);
        return 0;
    }

    return this->pNameTable[index].dwItem;
} // NameFromID
    
// return a dplay group corresponding to id.
// return null if id not valid
LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY this,DWORD idGroupID) 
{
	if (DPID_ALLPLAYERS == idGroupID)
	{
		if (!this->pSysGroup)
		{
			DPF_ERR("System group not found");
			return NULL;	
		} 
		return this->pSysGroup;
	}
    return (LPDPLAYI_GROUP)NameFromID(this,idGroupID);	
} // GroupFromID
// return a dplay player corresponding to id.
// return null if id not valid
LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY this,DWORD idPlayerID)
{
	if (DPID_SERVERPLAYER == idPlayerID)
	{
		if (!this->pServerPlayer)
		{
			DPF_ERR(" server player not found");
			return NULL;	
		} 
		return this->pServerPlayer;
	}
    return (LPDPLAYI_PLAYER)NameFromID(this,idPlayerID);		
} // PlayerFromID

DPID PlayerIDFromSysPlayerID(LPDPLAYI_DPLAY this,DPID dpidSysPlayer)
{
	LPDPLAYI_PLAYER pPlayerWalker=this->pPlayers;
	
	while(pPlayerWalker)
	{
		if(pPlayerWalker->dwIDSysPlayer == dpidSysPlayer){
			return pPlayerWalker->dwID;
		}
		pPlayerWalker = pPlayerWalker->pNextPlayer;
	}
	return 0;
}

// Someone is telling us they are the new nameserver.
HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, DWORD cbMessageSize, LPVOID pvSPHeader)
{
	LPDPLAYI_PLAYER pPlayer;
	HRESULT hr;
	DPSP_DELETEPLAYERDATA dd;
	LPBYTE pBuffer = (LPBYTE)pmsg;

	// SECURITY
	if(cbMessageSize < sizeof(MSG_IAMNAMESERVER)){
		DPF(1,"SECURITY WARN: Invalid I Am NameServer Message");
	}

	if(pmsg->dwSPDataSize > cbMessageSize || pmsg->dwSPDataSize + sizeof(MSG_IAMNAMESERVER) > cbMessageSize){
		DPF(1,"SECURITY WARN: Invalid I Am NameServer Message, SPDataSize overflows buffer");
	}

	pPlayer=PlayerFromID(this, pmsg->dwIDHost);

	if(!pPlayer){
		return DPERR_INVALIDPLAYER;
	}

	if(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL){
		return DP_OK;
	}

	dd.idPlayer       = pPlayer->dwID;
	dd.dwFlags        = pPlayer->dwFlags;
	dd.lpISP          = this->pISP;

	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer, &dd);

	if(FAILED(hr)){
		DPF_ERR("SP Could Not Delete Player in preparation for flags change in NS_HandleIamNameServer\n");
	}

	pPlayer->dwFlags = ((pPlayer->dwFlags & DPLAYI_PLAYER_NONPROP_FLAGS) | pmsg->dwFlags);
	
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
	
	pPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;//paranoia
	this->pNameServer = pPlayer;

	// NOTE: blows away the header.  May not be compatible with all SPs.
	if(pPlayer->pvSPData){
		DPMEM_FREE(pPlayer->pvSPData);
	}

	pPlayer->pvSPData=DPMEM_ALLOC(pmsg->dwSPDataSize+1);
	if(!pPlayer->pvSPData){
		DPF_ERR("Ran out of memory trying to allocate spdata block\n");
		hr=DPERR_OUTOFMEMORY;
		return hr;
	}
	memcpy(pPlayer->pvSPData, pmsg->SPData, pmsg->dwSPDataSize);
	pPlayer->dwSPDataSize=pmsg->dwSPDataSize;
	
	hr = CallSPCreatePlayer(this,pPlayer,FALSE,pvSPHeader,pmsg->dwSPDataSize,FALSE);
	
	if(FAILED(hr)){
		DPF_ERR("SP Couldn't Recreate Player in NS_HandleIamNameServer\n");
		return hr;
	}
	
	this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;

	LEAVE_DPLAY();

	DVoiceNotify(this,DVEVENT_MIGRATEHOST,PlayerIDFromSysPlayerID(this,pPlayer->dwID),0, DVTRANSPORT_OBJECTTYPE_BOTH);
	
	ENTER_ALL();

	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return hr;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}
	
	
	LEAVE_SERVICE();
	
	return hr;

}


// the nameserver has migrated to this client
// we need to recreate our sysplayer as  the nameserver
// we don't actually destroy the sysplayer, we just call the sp's
// destroy for the old (non-nameserver) and then create for the
// new (nameserver)
HRESULT MakeMeNameServer(LPDPLAYI_DPLAY this)
{
    DPSP_DELETEPLAYERDATA dd;
	HRESULT hr;

	DPF(0,"the name server has migrated to this client!");
	ASSERT(this->pSysPlayer);

	if (!this->pSysPlayer)
		return E_FAIL;

	// call sp delete player
	if (this->pcbSPCallbacks->DeletePlayer)
    {
	    // call sp
		dd.idPlayer = this->pSysPlayer->dwID;
		dd.dwFlags = this->pSysPlayer->dwFlags;
		dd.lpISP = this->pISP;

 	 	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
 	 	
		if (FAILED(hr)) 
		{
			DPF_ERR(" SP could not delete sysplayer in preparation for migration"); 
			ASSERT(FALSE);
			// keep trying...
		}
	}
	
	// free up the sp data
	if (this->pSysPlayer->pvSPData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPData);
		this->pSysPlayer->pvSPData = NULL;
	}
	
	if (this->pSysPlayer->pvSPLocalData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPLocalData);	
		this->pSysPlayer->pvSPLocalData = NULL;
	}
	this->pSysPlayer->dwSPLocalDataSize = 0;
	this->pSysPlayer->dwSPDataSize = 0;

	// get the sp to make us a nameserver (poof - you're a nameserver!)	
	this->pSysPlayer->dwFlags |= DPLAYI_PLAYER_NAMESRVR;
	// now, call the sp to create our nameserver
	hr = CallSPCreatePlayer(this,this->pSysPlayer,TRUE,NULL,0,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"could not migrate nameserver - sp create player failed hr = 0x%08lx\n",hr);
		DPF(0,"game play should continue normally, but there is no more nameserver");
		// we should be ok to keep going here.  the nameserver is toast, but the game should go on...
		return hr;
	}

	// a-josbor: make sure the dplay thread is running to care for the reservation count
	StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	

	// remember that we are the system player
	this->pNameServer = this->pSysPlayer;

	if((this->dwMinVersion >= DPSP_MSG_DX61VERSION) && 
	   (this->dwMinVersion >= DPSP_MSG_DX61AVERSION || this->pProtocol)){
		// we used to tell everyone that the system player was deleted and then
		// recreated.  This is a very bad thing to do with the protocol running
		// so we instead send an IAMHOST message to give the other players a chance
		// to update their information on who is the name server.
		hr=SendIAmNameServer(this);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
	} else {
		// tell the world about our new player
		// 1st, delete the non-nameserver old player
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER|DPSP_MSG_ASYNC, 
			this->pSysPlayer->dwID,0);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		
		// now, create the new nameserver player
		hr = SendCreateMessage( this, this->pSysPlayer,TRUE,NULL);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

	}
	// tell our local players we're the nameserver
	hr = SendMeNameServer(this);
	if (FAILED(hr))
	{
		DPF(0,"could not send name server message - hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	// Send a system message to the lobby server, telling them the
	// host just migrated to this client
	PRV_SendStandardSystemMessage(this->lpLaunchingLobbyObject,
			DPLSYS_NEWSESSIONHOST, DPLOBBYPR_GAMEID);

	// reset our ping counter, so we don't start sending pings
	// until things have settled down...
	this->dwLastPing = GetTickCount();
	
	return DP_OK;
	
} // MakeMeNameServer

// called by handler.c when it gets a dp_deleteplayer on 
// the namesrvr
HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this)
{
	DWORD IDMin; // the minimum player id, and the index of that id
	BOOL bFound = FALSE;
	LPDPLAYI_PLAYER pPlayer,pNewServer = NULL;	
	HRESULT hr = DP_OK;

	// In a client-server or secure session, don't migrate the host
	if ( (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) 
		||  (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) 
		|| !(this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) )
	{
		DPF(0,"Name server is dead.  Game over!");
		return HandleSessionLost(this);
	}

	DPF(0,"Name server dead.  Finding new name server");

	IDMin = (DWORD) -1;

	// search the name table, looking for a new namesrvr
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if (DPLAYI_PLAYER_SYSPLAYER & pPlayer->dwFlags )
		{
			if (pPlayer->dwID < IDMin) 
			{
				bFound=TRUE;
				IDMin = pPlayer->dwID;
				pNewServer = pPlayer;
			} // id < idMin
		} // sysplayer
		pPlayer = pPlayer->pNextPlayer;
	} // while

	if (!bFound) 
	{
		DPF(0,"Could not find new name srvr - ack!");
		return E_FAIL;
	}

	DPF(0,"found new name srvr - id = %d\n",IDMin);

	if (this->pSysPlayer && (this->pSysPlayer->dwID == IDMin)) 
	{
		this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
		hr = MakeMeNameServer(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// we should be ok to keep going here
		}
	} // id == idmin
	else {
		// Mark no nameserver and do keepalives until we find one.
		this->dwFlags |= DPLAYI_DPLAY_NONAMESERVER;
		StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
	}

	return hr;

} // HandleDeadNameServer


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\pack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pack.c
 *  Content:	packs / unpacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	4/15/96		andyco	unpack calls sp's create player fn
 *	4/22/96		andyco	unapck takes pmsg 
 *	5/31/96		andyco	group and players use same pack / unpack show
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/25/96		andyco 	check data size before unpack
 *	7/10/96		andyco	don't unpack our sysplayer (pending already put 
 *						'em in the table)
 *	7/27/96		kipo	call PackPlayer() with bPlayer == FALSE to pack players
 *						in group along with the rest of the group data.
 *	8/1/96		andyco	added system player id to packed struct
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *	10/14/96	andyco	don't pack up system group.  add players to system
 *						group after unpacking.
 *	1/15/97		andyco	set new players' sysplayer id early enough to add
 *						to system group
 *	2/15/97		andyco	moved "remember name server" to iplay.c 
 *  3/12/97     sohailm updated UnpackPlayer() to move the security context ptr from the
 *                      nametable to the player structure when session is secure
 *  3/24/97     sohailm updated UnPackPlayer to pass NULL for session password to GetPlayer and
 *                      SendCreateMessage
 *	4/20/97		andyco	group in group 
 *	5/8/97		andyco	packing for CLIENT_SERVER
 *  6/22/97     sohailm Updated code to use pClientInfo.
 *   8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 *   3/1/02     a-aogus security validation of nametable operations
 ***************************************************************************/

// todo - handle unpack error on create group/player

 /**************************************************************************
 *
 * packed player format :                                            
 *                                                                   
 * 		+ for player                                                    
 * 	                                                                  
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 	                                                                  
 * 		+ for group                                                     
 *
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 			DWORD  dwIDs[dwNumPlayers] // size = pPacked->dwNumPlayers
 *
 *	packed player list format :
 *	
 *		msg (e.g. CreatePlayer,CreateGroup,EnumPlayersReply)
 *		PackedPlayer[nPlayers]
 *		PackedGroup[nGroups]
 *		msgdata[this->dwSPHeaderSize] (set by sp on send / receive)
 *	
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"Pack -- "

// andyco - todo - remove TODOTODOTODO hack
// put in to find stress bug where system player hasn't been added yet
void CheckStressHack(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_PLAYER pSearchPlayer = this->pPlayers;
	
	if (!pPlayer) return ;
	
	while (pSearchPlayer)
	{
		if ( !(pSearchPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && (pSearchPlayer->dwIDSysPlayer == pPlayer->dwID)
			&& !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
		{
			DPF(0,"player in nametable before system player!");
			ASSERT(FALSE);
#if 0 // - andyco removed for beta 1
			DPF(0,"found player in nametable before system player - going to int 3 - contact andyco");
			DebugBreak();
#endif 			
		}
		pSearchPlayer = pSearchPlayer->pNextPlayer;
	}

	return ;
		
} // CheckStressHack

/*
 ** UnpackPlayer
 *
 *  CALLED BY: UnpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *      cbBuffer - size remaining in the packed buffer
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *      bVerifyOnly - only verify the structure is viable, i.e. has plausible
 *                     offsets and contents and will not crash us when reading.
 *
 *  DESCRIPTION: unpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked,DWORD cbBuffer, 
	LPVOID pvSPHeader,BOOL bPlayer, BOOL bVerifyOnly)
{
    LPWSTR lpszShortName, lpszLongName;
	DWORD dwFlags;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex = (LPBYTE)pPacked;
	HRESULT hr;
	DWORD cbBufferRemaining;

	// Verify the fixed size isn't bogus.  Note comparisons are done before subtraction
	// to avoid getting fooled by very large integer numbers which would result in actual
	// addition rather than subtraction in the cbBufferRemaining calculation.  By guaranteeing
	// the size of the integers up front, this problem is avoided.

	if(pPacked->dwFixedSize > cbBuffer)
	{
		DPF(1,"SECURITY WARN: Bogus fixed size in packed player\n");
		DEBUG_BREAK();
		return DPERR_GENERIC;
	}
	
	cbBufferRemaining = cbBuffer - pPacked->dwFixedSize;
	
	// unpack the strings  - they follow the packed player in the buffer
	if (pPacked->iShortNameLength) 
	{
		if(pPacked->iShortNameLength > cbBufferRemaining)
		{
			DPF(1,"SECURITY WARN: bogus short name length in packed player\n");
			return DPERR_GENERIC;
		}
		cbBufferRemaining -= pPacked->iShortNameLength;
		lpszShortName = (WCHAR *)(pBufferIndex + pPacked->dwFixedSize);

		// ensure NULL termination, -1 because length should include NULL termination
		lpszShortName[(pPacked->iShortNameLength - 1) / sizeof(WCHAR)]=L'\0';
	}	
	else lpszShortName = NULL;

	if (pPacked->iLongNameLength) 
	{
		if(pPacked->iLongNameLength > cbBufferRemaining){
			DPF(1,"SECURITY WARN: bogus long name length in packed player\n");
			return DPERR_GENERIC;
		}
		cbBufferRemaining -= pPacked->iLongNameLength;
		lpszLongName =(WCHAR *)( pBufferIndex + pPacked->dwFixedSize
			+ pPacked->iShortNameLength);
		
		// ensure NULL termination, -1 because length should include NULL termination
		lpszLongName[(pPacked->iLongNameLength - 1) / sizeof(WCHAR)]=L'\0';
	}
	else lpszLongName = NULL;

	dwFlags = pPacked->dwFlags;
	
	// player is not local
	dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;

	if(pPacked->dwSPDataSize > cbBufferRemaining){
		DPF(1,"SECURITY WARN: bogus SPDataSize in packed player\n");
		return DPERR_GENERIC;
	}
	
	cbBufferRemaining -= pPacked->dwSPDataSize;
		
	pvPlayerData = pBufferIndex + pPacked->dwFixedSize + 
		pPacked->iShortNameLength + pPacked->iLongNameLength + 
		pPacked->dwSPDataSize;

	if(pPacked->dwPlayerDataSize > cbBufferRemaining){
		DPF(1,"SECURITY WARN: bogus PlayerDataSize in packed player\n");
		return DPERR_GENERIC;
	}

	if(bVerifyOnly){
		// if we made it this far, the packed player seems at
		// least reasonable from a security scan point of view.
		return DP_OK;
	}

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,NULL,0);
		// andyco - debug code to catch stress bug 
		// todo - REMOVE HACKHACK TODOTODO
		if ( SUCCEEDED(hr) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			CheckStressHack(this,pNewPlayer);
		}
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,0,0);
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			return hr;
			// rut ro!
		}
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = pPacked->dwIDSysPlayer;
	pNewPlayer->dwVersion = pPacked->dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}
	
	if (pPacked->dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(pPacked->dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = pPacked->dwSPDataSize;
	
		pvSPData = 	pBufferIndex + pPacked->dwFixedSize + pPacked->iShortNameLength 
			+ pPacked->iLongNameLength;
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,pPacked->dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the pClientInfo from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,pPacked->dwSPDataSize,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader,pPacked->dwSPDataSize);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on unpack
	}
	
	// if it's a group, unpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList;
		DWORD dwPlayerID;

		if ( (pNewPlayer->dwVersion >= DPSP_MSG_GROUPINGROUP) && (pPacked->dwIDParent) )
		{
			pNewGroup->dwIDParent = pPacked->dwIDParent;
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwIDParent,
				pNewGroup->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}

		nPlayers = pPacked->dwNumPlayers;
		// list of id's is list thing in packed buffer
		pdwIDList = (LPDWORD) ((LPBYTE)pPacked + pPacked->dwFixedSize + 
			pPacked->iShortNameLength + pPacked->iLongNameLength + 
			pPacked->dwSPDataSize + pPacked->dwPlayerDataSize);

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		// all done!
	} // !bPlayer

	return hr;

}// UnpackPlayer

/*
 ** VerifyPackedPlayerAndGroupList
 *
 *  CALLED BY: UnpackPlayerAndGroupList
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *      cbBuffer - size of the buffer
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *
 *  DESCRIPTION:
 *      SECURITY addition.  Before accepting a playerlist from the wire, we need to 
 *      verify that the contents are not corrupted and won't lead us to touching memory
 *      that is not ours.  
 *
 *  RETURNS:
 *
 */

HRESULT VerifyPackedPlayerAndGroupList(LPDPLAYI_DPLAY this, LPBYTE pBuffer, DWORD cbBuffer, UINT nPlayers,
	UINT nGroups)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_PACKEDPLAYER pPacked;
	INT cbRemaining=cbBuffer;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		// don't unpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		if ( !(this->pSysPlayer && (pPacked->dwID == this->pSysPlayer->dwID)) )
		{
			// not really unpacking, just verifying structure is ok
			hr = UnpackPlayer(this,pPacked,cbRemaining, NULL,TRUE,TRUE);
			if (FAILED(hr))
			{
				goto exit;
			}
		}

		nPlayers --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;
		cbRemaining -= pPacked->dwSize;
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifyPackedPlayerAndGroupList, invalid buffer\n");
			hr=DPERR_GENERIC;
			goto exit;
		}
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;

		// not really unpacking, just verifying structure is ok.
		hr = UnpackPlayer(this,pPacked,cbRemaining,NULL,FALSE,TRUE);
		if (FAILED(hr))
		{
			goto exit;
			// keep trying
		}
		nGroups --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
		cbRemaining -= pPacked->dwSize;
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifyPackedPlayerAndGroupList, invalid buffer\n");
			hr=DPERR_GENERIC;
			goto exit;
		}
   	} 
exit:
	return hr;

}

/*
 ** UnpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD dwBufferSize, UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_PACKEDPLAYER pPacked;
	INT cbRemaining=dwBufferSize;

	//
	// SECURITY - need to verify the entire player and group list before attempting
	//            to unpack, otherwise we would need a way to rewind from partial 
	//            unpacking if the unpack failed late in the structure, leaving 
	//            DirectPlay in an indeterminate state.
	//
	hr = VerifyPackedPlayerAndGroupList(this,pBuffer,dwBufferSize,nPlayers,nGroups);
	if( hr != DP_OK ){
		DPF(1,"SECURITY WARN: Player and GroupList unpack check failed, not unpacking\n");
		goto exit;
	}	

	// Ok, the buffers are good, actually add the players and groups to our internal tables

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		// don't unpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		if ( !(this->pSysPlayer && (pPacked->dwID == this->pSysPlayer->dwID)) )
		{
			hr = UnpackPlayer(this,pPacked,cbRemaining,pvSPHeader,TRUE,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying
			}
		}

		nPlayers --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
		cbRemaining -= pPacked->dwSize;
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifyPackedPlayerAndGroupList, invalid buffer\n");
			hr=DPERR_GENERIC;
			goto exit;
		}
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		
		hr = UnpackPlayer(this,pPacked,cbRemaining,pvSPHeader,FALSE,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nGroups --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
		cbRemaining -= pPacked->dwSize;
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifyPackedPlayerAndGroupList, invalid buffer\n");
			hr=DPERR_GENERIC;
			goto exit;
		}
   	}
   	
exit:		
	return hr;

} // UnpackPlayerAndGroupList

DWORD PackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	LPDPLAYI_DPLAY this = pPlayer->lpDP;
	
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_PACKEDPLAYER) + 
		pPlayer->dwPlayerDataSize + pPlayer->dwSPDataSize;
		
	return dwSize;
} // PackedPlayerSize


DWORD PackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	
	// space for player stuff, plus space for group list 
	dwSize = PackedPlayerSize((LPDPLAYI_PLAYER)pGroup) + 
		pGroup->nPlayers*sizeof(DPID);
		
	return dwSize;	
} // PackedGroupSize

// returns how big the packed player structure is for the nPlayers
DWORD PackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
	
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += PackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += PackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
}// PackedBufferSize

// constructs a packedplayer object from pPlayer. stores result in pBuffer
// returns size of packed player
DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	DPLAYI_PACKEDPLAYER Packed;
	int iShortStrLen=0,iLongStrLen=0;
	LPBYTE pBufferIndex = pBuffer;
		
	if (!pBuffer)
	{
		return PackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	// just to be safe
	memset(&Packed,0,sizeof(DPLAYI_PACKEDPLAYER));
	
	// figure out how big the packed struct is, setting short and long strlen
	iShortStrLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	if (bPlayer)
	{
		Packed.dwSize =  PackedPlayerSize(pPlayer);
		Packed.dwNumPlayers = 0;
	}
	else 
	{
		Packed.dwSize = PackedGroupSize((LPDPLAYI_GROUP)pPlayer);
		Packed.dwNumPlayers = ((LPDPLAYI_GROUP)pPlayer)->nPlayers;
	}
	
	Packed.iShortNameLength = iShortStrLen;
	Packed.iLongNameLength = iLongStrLen;
	
	// copy over relevant fields
	Packed.dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS); 
	Packed.dwID = pPlayer->dwID;
	Packed.dwPlayerDataSize = pPlayer->dwPlayerDataSize;

	Packed.dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	Packed.dwVersion = pPlayer->dwVersion;	
	Packed.dwFixedSize = sizeof(DPLAYI_PACKEDPLAYER);
	Packed.dwIDParent = pPlayer->dwIDParent;
	
	// start filling up variable size structs behind the fixed size one
	pBufferIndex+= sizeof(Packed);
	
	// store strings after packed
	if (pPlayer->lpszShortName)	
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		pBufferIndex += iShortStrLen;
	}
	if (pPlayer->lpszLongName)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		pBufferIndex += iLongStrLen;
	}

	// pack sp data
	if (pPlayer->pvSPData)
	{
		// store spdata after strings
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;
		Packed.dwSPDataSize = pPlayer->dwSPDataSize;
	}
	else 
	{
		Packed.dwSPDataSize = 0;
	}

	if (pPlayer->pvPlayerData)
	{
		// copy playerdata after spdata
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
	}

	// if it's a group, store the list of id's after the playerdata
	if (!bPlayer)
	{
		LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;
		LPDPID pdwBufferIndex;
		
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		pBufferIndex += pPlayer->dwPlayerDataSize;
		pdwBufferIndex = (LPDPID)pBufferIndex;

		// add the players in the group onto the list
		while (pGroupnode)
		{
			ASSERT(pGroupnode->pPlayer);
			*pdwBufferIndex++ = pGroupnode->pPlayer->dwID;
			pGroupnode = pGroupnode->pNextGroupnode;
		}
	}

	// store the fixed size packed struct in buffer
	memcpy(pBuffer,&Packed,sizeof(Packed));

	// all done
	return Packed.dwSize;	
	
} // PackPlayer

					
HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{

	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;

	if (!pBuffer) 
	{
		if (CLIENT_SERVER(this))
		{
			ASSERT(this->pSysPlayer);
			*pdwBufferSize = PackedBufferSize(this->pSysPlayer,1,TRUE);
			if (this->pServerPlayer) 
			{
				*pdwBufferSize += PackedBufferSize(this->pServerPlayer,1,TRUE);
			}
		}
		else 
		{
			*pdwBufferSize = PackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
			*pdwBufferSize += PackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		}
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	// if we're client server, just send the minimum info...
	if (CLIENT_SERVER(this))
	{
		ASSERT(this->pSysPlayer);	
		pBuffer += PackPlayer(this->pSysPlayer,pBuffer,TRUE);
		if (this->pServerPlayer) 
		{
				pBuffer += PackPlayer(this->pServerPlayer,pBuffer,TRUE);
		}
		return DP_OK;
	}
			
	// if not, pack all players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += PackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, pack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += PackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// PackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\paketize.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       paketize.c
*  Content:		break sends or replies up into sp-size packets
*  History:
*   Date		By		Reason
*   ====		==		======
*	7/25/96		andyco	created it 'cause IPX wont packetize for
*						us.
*	7/26/96		kipo	check for pvSPHeader == NULL before calling memcpy (#2654)
*   3/18/97     sohailm HandlePacket shouldn't copy the sp header if it is
*                       DPSP_HEADER_LOCALMSG
*   6/17/97     aarono  Added reliability
*   2/2/98      aarono  Added test for closing to SendTimeOut
*   2/3/98      aarono  Fixed Paketize test for RAW mode
*   2/18/98     aarono  changed error checks to FAILED(hr)
*   3/5/98      aarono  NeedsReliablePacketize won't say so for 
*                       ENUMSESSIONSREPLY as this can lead to machines with
*                       improper IPX net number hanging up the host.
*   3/9/98      aarono  added more messages to packetize to avoid deadlocks.
*   3/13/98     aarono  rearchitected packetize retry/timeout for NT mmTimer 
*                       contraints.
*   3/26/98     aarono  B#21476 free retry packet nodes during close
*   4/1/98      aarono  B#21476 also need to free from timeoutlist
*   4/24/98     aarono  DX5 compat, reduce size of packetize messages
*    6/6/98     aarono  Fix for handling large loopback messages with protocol
*   6/19/98     aarono  Don't do our own reliability when the SP does it already.
*   8/21/98     aarono  Don't send packetize messages to machines with no nametable.
*   8/05/99     aarono  Packetize Reliabe VOICE message.
*   6/26/00     aarono  Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
*                       added re-notification during simultaneous join CREATEPLAYERVERIFY
*
***************************************************************************/

#include "dplaypr.h"
#include <mmsystem.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandlePacket"

VOID StartPacketizeTicker(LPDPLAYI_DPLAY this);
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pmsg);
VOID SendNextPacket(LPDPLAYI_DPLAY this, LPPACKETNODE pNode, BOOL bInDplay);
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode);

#define PACKETIZE_RECEIVE_TIMEOUT   60000	/* Always give up after this ms time */
#define MIN_RECEIVE_TIMEOUT         10000   /* Never give up before this ms time */
#define TICKER_INTERVAL  			15000	/* Check for expired receives this often*/
#define TICKER_RESOLUTION 			1000	/* How accurate we want the ticker (not very) */
#define MAX_PACKETIZE_RETRY 		16		/* Generally how often to retry before giving up*/

#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#define NODE_SIGN SIGNATURE('N','O','D','E')
#define NODE_UNSIGN SIGNATURE('n','o','d','e')

// The PacketizeTimeoutListLock controls access to the PacketizeTimeoutList AND the 
// RetryList in each DPLAY object.  Use PACKETIZE_LOCK() PACKETIZE_UNLOCK() macros.
CRITICAL_SECTION g_PacketizeTimeoutListLock;
BILINK           g_PacketizeTimeoutList={&g_PacketizeTimeoutList, &g_PacketizeTimeoutList};


BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, DWORD dwFlags)
{

	if ((dwFlags & DPSEND_GUARANTEED) &&
	    (this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && 
	    (dwVersion >= DPSP_MSG_RELIABLEVERSION))
	{
		switch (dwCommand)
		{
			//case DPSP_MSG_ENUMSESSIONSREPLY: -- can't do enumsession reply on packetizer
			//                                    since remote may be invalid subnet, hanging
			//                                    machine as IPX does RIPs, actually crashing IPX too.
			case DPSP_MSG_ENUMSESSIONS:
			case DPSP_MSG_ENUMPLAYER:
			case DPSP_MSG_ENUMPLAYERSREPLY:
			case DPSP_MSG_REQUESTGROUPID:
			case DPSP_MSG_REQUESTPLAYERID:
			case DPSP_MSG_CREATEGROUP:
			case DPSP_MSG_DELETEGROUP:
			case DPSP_MSG_REQUESTPLAYERREPLY:
			case DPSP_MSG_ADDFORWARDREQUEST:
			case DPSP_MSG_NAMESERVER:
			case DPSP_MSG_SESSIONDESCCHANGED:
			case DPSP_MSG_CREATEPLAYER:	
			case DPSP_MSG_DELETEPLAYER: 
			case DPSP_MSG_ADDPLAYERTOGROUP:
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
			case DPSP_MSG_ADDFORWARDREPLY:
			case DPSP_MSG_ADDSHORTCUTTOGROUP:
			case DPSP_MSG_DELETEGROUPFROMGROUP:
			case DPSP_MSG_SUPERENUMPLAYERSREPLY:
			case DPSP_MSG_CHAT:
			case DPSP_MSG_ADDFORWARD:			
			case DPSP_MSG_ADDFORWARDACK:
			case DPSP_MSG_ASK4MULTICAST:
			case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			case DPSP_MSG_IAMNAMESERVER:
			case DPSP_MSG_CREATEPLAYERVERIFY:
	//		case DPSP_MSG_VOICE:
			return TRUE;
				
			default:
				return FALSE;
		}
	} else {
		return FALSE;
	}

}

// Not quite symetric with Init, must kill the thread before calling this.
// key of non-zero this->hRetry to see if this is necessary.
VOID FiniPacketize(LPDPLAYI_DPLAY this)
{
	FreePacketizeRetryList(this);
	CloseHandle(this->hRetry);
	this->hRetry=0;
}

// Free Packetize Retry List
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode;
	BILINK *pBilink;

	PACKETIZE_LOCK();

	// pull off retry list
	while(!EMPTY_BILINK(&this->RetryList)){
		pBilink=this->RetryList.next;
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);

		BlowAwayPacketNode(this, pNode);
	}	

	// pull off timeout list
	pBilink=g_PacketizeTimeoutList.next;
	while(pBilink != &g_PacketizeTimeoutList){
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(this==pNode->lpDPlay){
			BlowAwayPacketNode(this, pNode);
		}
	}

	PACKETIZE_UNLOCK();
}

// Initialize for packetize and send reliable.
HRESULT InitPacketize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DWORD dwThreadID;

	this->hRetry=CreateEventA(NULL,FALSE,FALSE,NULL);
	if(!this->hRetry){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread event\n");
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	this->hRetryThread=CreateThread(NULL,4096,PacketizeRetryThread,this,0,&dwThreadID);
	if(!this->hRetryThread){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread\n");
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	InitBilink(&this->RetryList);

	hr=DP_OK;
	
EXIT:
	return hr;

ERROR_EXIT:
	if(this->hRetry){
		CloseHandle(this->hRetry);
		this->hRetry=0;
	}
	return hr;
}

// need a thread to do retries for reliable sends due to problems dealing
// with differences between NT and Win95 mmTimers.
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this)
{
	BILINK *pBilink;
	LPPACKETNODE pNode;
	UINT tmCurrentTime;

	DPF(9,"==>PacketizeRetryThread starting\n");

	while(TRUE){
	
		// wait for a message to send or shutdown.
		WaitForSingleObject(this->hRetry, INFINITE); 

		if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
			// we test here in case of an error during startup, in this
			// case the error path of startup is the only thread that
			// could have signaled us.
			break;
		}
		
		tmCurrentTime=timeGetTime();
		
		ENTER_ALL();
		PACKETIZE_LOCK();
		
		while(!EMPTY_BILINK(&this->RetryList)){

			pBilink=this->RetryList.next;
			pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
			
			if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
			{
				// DP_CLOSE signaled us to shut down.
				PACKETIZE_UNLOCK();
				LEAVE_ALL();
				goto ERROR_EXIT;
			}

			pNode->dwRetryCount++;
			if((pNode->dwRetryCount>=MAX_PACKETIZE_RETRY) && 
		 	   (tmCurrentTime-pNode->tmTransmitTime > MIN_RECEIVE_TIMEOUT)){
				DPF(5,"Packetize SendTimeOut: Exceeded Max Retries, giving up (quietly!)\n");
				BlowAwayPacketNode(this, pNode);
				continue;
			}

			if(this->pProtocol){
				EnterCriticalSection(&this->pProtocol->m_SPLock);// don't re-enter SP.
				SendNextPacket(this,pNode,TRUE);
				LeaveCriticalSection(&this->pProtocol->m_SPLock);
			} else {
				SendNextPacket(this,pNode,TRUE);
			}	
		}
		
		PACKETIZE_UNLOCK();
		LEAVE_ALL();
	}


	DPF(1,"<== PacketizeRetryThread Exiting\n");
ERROR_EXIT:
	return TRUE;
	
}

VOID CancelPacketizeRetryTimer(LPPACKETNODE  pNode)
{
	UINT_PTR uRetry=0;
	HRESULT rc;
	DWORD Unique;

	ASSERT(pNode->bReliable);

	PACKETIZE_LOCK();
	
		if(!EMPTY_BILINK(&pNode->TimeoutList)){
			uRetry=pNode->uRetryTimer;
			Unique=pNode->Unique;
			pNode->uRetryTimer=0;
			Delete(&pNode->TimeoutList);
			InitBilink(&pNode->TimeoutList);
		}	

		if(!EMPTY_BILINK(&pNode->RetryList)){
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
		}
		
	PACKETIZE_UNLOCK();
	
	if(uRetry){
		rc=CancelMyTimer(uRetry,Unique);
		DPF(9,"CancelTimer:KillEvent %x returned %x\n",uRetry,rc);
	}	
}

// free up the contents of a single packetnode
// called by handlepacket and DP_Close (via FreePacketList)
void FreePacketNode(LPPACKETNODE pNode)
{
#ifdef DEBUG
	DPF(8,"Freeing Packet Node: %x",pNode);
	if(pNode->bReliable){
		DPF(8," Reliable ");
	}else{
		DPF(8," Unreliable ");
	}
	if(pNode->bReceive){
		DPF(8,"Receive, age %d ms\n",timeGetTime()-pNode->tmLastReceive);
	} else {
		DPF(8,"Send\n");
	}

	if(pNode->Signature != NODE_SIGN){
		DPF(0,"INVALID PACKET NODE %x, Sign %x\n",pNode, pNode->Signature);
		DEBUG_BREAK();
	}
#endif
	
	if(pNode->bReliable && !(pNode->bReceive)){
		CancelPacketizeRetryTimer(pNode);
	}	
	pNode->Signature=NODE_UNSIGN;
	if (pNode->pBuffer) DPMEM_FREE(pNode->pBuffer);
	if (VALID_SPHEADER(pNode->pvSPHeader)) DPMEM_FREE(pNode->pvSPHeader);
	DPMEM_FREE(pNode);

} // FreePacketNode

// like FreePacketNode, but also does the list removal - only for Send nodes.
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode)
{
	LPPACKETNODE pNodeWalker;

	DPF(8,"==>BlowAwayPacketNode\n");

	pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

	while(pNodeWalker && pNodeWalker->pNext!=pNode){
		pNodeWalker=pNodeWalker->pNext;
		ASSERT(pNodeWalker->Signature==NODE_SIGN);
	}
	if(pNodeWalker){
		pNodeWalker->pNext=pNode->pNext;
	}else{
		DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
		ASSERT(0);
		DEBUG_BREAK();
	}
		
	FreePacketNode(pNode);
	DPF(8,"<==BlowAwayPacketNode\n");
}

/*
 ** NewPacketnode
 *
 *  CALLED BY:	 HandlePacket, PacketizeAndSend.
 *
 *  PARAMETERS:
 *				ppNode - node to be alloc'ed
 *				pmsg - first packet received in message we're alloc'ing for
 *
 *  DESCRIPTION:
 *				alloc space for a new packetnode
 *				set up static data (e.g. guid, total num packets, etc.)
 *				we actually copy pmsg->pmessage over in HandlePacket
 *
 *  			Note: PacketNodes are used for both sending and receiving
 *                    Packetized Messages
 *
 *  RETURNS:  DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT NewPacketnode(
	LPDPLAYI_DPLAY this,
	LPPACKETNODE * ppNode,
	LPGUID lpGUID,
	DWORD  dwMessageSize,
	DWORD  dwTotalPackets,
	LPVOID pvSPHeader
)	
{
	HRESULT hr;
	DWORD   dwExtraSize;

	LPPACKETNODE pNode;

	// alloc the node
	pNode = DPMEM_ALLOC(sizeof(PACKETNODE));
	
	if (!pNode)
	{
		DPF_ERR("could not get new packetnode -  out of memory");
		hr =  E_OUTOFMEMORY;
		return hr;
	}

	InitBilink(&pNode->TimeoutList);
	InitBilink(&pNode->RetryList);

	pNode->Signature = NODE_SIGN; // must be here so error path doesn't debug_break()
	
	DPF(8,"NewPacketNode: %x\n",pNode);

	dwExtraSize=this->dwSPHeaderSize+sizeof(MSG_PACKET);
	// alloc the buffer - extra space at front so we can build send buffers.
	pNode->pBuffer = DPMEM_ALLOC(dwMessageSize+dwExtraSize);
	if (!pNode->pBuffer)
	{
		DPF_ERR("could not get buffer for new packetnode -  out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	
	pNode->pMessage = pNode->pBuffer + dwExtraSize;

	// alloc and copy the header (if necessary)
	
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
	
		pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNode->pvSPHeader)
		{
			DPF_ERR("could not get header for new packetnode");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		
	}	

	// stick the new node on the front of the list
	pNode->pNextPacketnode = this->pPacketList;
	this->pPacketList = pNode;

	pNode->guidMessage = *lpGUID;
	pNode->dwMessageSize = dwMessageSize; 
	pNode->dwTotalPackets = dwTotalPackets;

	*ppNode = pNode;
	
	return DP_OK;

ERROR_EXIT:

	FreePacketNode(pNode);
	return hr;

} // NewPacketnode

// called by handler.c
// we received a packet.
HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPMSG_PACKET pmsg = (LPMSG_PACKET)pReceiveBuffer;
	LPPACKETNODE pNode,pNodePrev;
	BOOL bFoundIt = FALSE;
	HRESULT hr;
	BOOL bRetry;
	ULONG command;

	command=GET_MESSAGE_COMMAND(pmsg);

	if(dwMessageSize < sizeof(MSG_PACKET_ACK)){
		DPF(1,"SECURITY WARN: Invalid Packetized Message");
		return DPERR_GENERIC;
	}

	// see if this packet is in the list
	pNode = this->pPacketList;
	pNodePrev = NULL;
	while (pNode && !bFoundIt)
	{
		if ( IsEqualIID(&(pNode->guidMessage),&(pmsg->guidMessage)))
	 	{
			bFoundIt = TRUE;
		}
		else 
		{
			// keep looking
			pNodePrev = pNode;
			pNode = pNode->pNextPacketnode;
		}
	}

	// SECURITY
	switch(command){
		case DPSP_MSG_PACKET:
		case DPSP_MSG_PACKET2_DATA:

			// SECURITY - validate the message, buffers and pointers
			if(dwMessageSize < sizeof(MSG_PACKET) ||
				pmsg->dwPackedOffset > dwMessageSize || 
				pmsg->dwDataSize > dwMessageSize-sizeof(MSG_PACKET) || 
				pmsg->dwPackedOffset + pmsg->dwDataSize > dwMessageSize)
			{
				DPF(1,"SECURITY WARN: Invalid Packetized Message");
				return DPERR_GENERIC;
			}

			// SECURITY - validate the positioning in the total message
			if(pmsg->dwOffset + pmsg->dwDataSize > pmsg->dwMessageSize || (pNode && (pNode->dwMessageSize != pmsg->dwMessageSize)))
			{
				DPF(1,"SECURITY WARN: Invalid Packetized Message, data bounds");	
				return DPERR_GENERIC;
			}
			
			break;

		default:
			break;
	}

	if (!bFoundIt)
	{
		switch(command){
			case DPSP_MSG_PACKET:
			case DPSP_MSG_PACKET2_DATA:
				// 
				// this is a new mesage
				DPF(8,"creating new packetnode");
				
				hr = NewPacketnode(this,&pNode,&pmsg->guidMessage,pmsg->dwMessageSize,pmsg->dwTotalPackets,pvSPHeader);

				if (FAILED(hr))
				{
					DPF_ERR(" could not get new packetnode");
					return hr;
				}

				if(command==DPSP_MSG_PACKET2_DATA){
					pNode->bReliable=TRUE;
					pNode->bReceive=TRUE;
				} else {
					ASSERT(command==DPSP_MSG_PACKET);
					pNode->bReliable=FALSE;
					pNode->bReceive=TRUE;
				}
				break;
				
			case DPSP_MSG_PACKET2_ACK:	
				DPF(6,"Got ACK for MSG that is no longer around\n");
				goto exit;
				break;
		}

	}
	else 
	{
		DPF(8," got packet for existing message");
	}

	if(command==DPSP_MSG_PACKET2_ACK){

		// GOT AN ACK
		
		CancelPacketizeRetryTimer(pNode);

		// Copy return info if necessary.
		if(!pNode->pvSPHeader && pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
			// ACK from SEND has return information, copy so we can use Reply instead of Send.
			pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
			if (pNode->pvSPHeader){
				memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
			}	
		}	

		if(pmsg->dwPacketID==pNode->dwSoFarPackets){
			// Got ack for last send, update stats, send next packet.
			pNode->dwSoFarPackets++;
			pNode->dwLatency = timeGetTime()-pNode->tmTransmitTime; 
			pNode->dwRetryCount = 0;
			if (pNode->dwLatency < 25){
				DPF(5, "Packetize: Got really low latency %dms, using 25ms to be safe\n",pNode->dwLatency);
				pNode->dwLatency = 25; 
			}	
			SendNextPacket(this, pNode, TRUE); // will also terminate the send if no more to send.
		} else {
			DPF(8,"Rejecting extra ACK\n");
		}
		
	} else {

		// DATA PACKET
		
		// copy this packet's data into the node
		if(pmsg->dwPacketID==pNode->dwSoFarPackets){

			memcpy(pNode->pMessage + pmsg->dwOffset,pReceiveBuffer + sizeof(MSG_PACKET),
					pmsg->dwDataSize);


			if(pmsg->dwOffset+pmsg->dwDataSize > pNode->dwMessageSize){
				DPF(0,"Packetize HandlePacket Message to big, pmsg->dwOffset %d, pmsg->dwDataSize %d, pNode->dwMessageSize %d\n",pmsg->dwOffset,pmsg->dwDataSize,pNode->dwMessageSize);
				DEBUG_BREAK();
			}
			
			pNode->dwSoFarPackets++;
			bRetry=FALSE;
			DPF(8,"received %d packets out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		} else {
			bRetry=TRUE;
			DPF(8,"received duplicate of %d packet out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		}
		
		if(command==DPSP_MSG_PACKET2_DATA){
			// ACK original or Retry.
			ASSERT(pNode->bReliable);
			DPF(8,"HandlePacket: Sending ACK\n");
			SendPacketizeACK(this,pNode,pmsg); // see header for side effects.
		}

		if(pNode->bReliable){
			pNode->tmLastReceive=timeGetTime();
		}	

		if (pNode->dwSoFarPackets == pNode->dwTotalPackets && !bRetry)
		{
			// GOT A COMPLETE MESSAGE
			// call handler
			DPF(8," HANDLE PACKET COMPLETED PACKETIZED MESSAGE !!! ");

			// take it out of the list - must be done before releasing lock.
			if(command==DPSP_MSG_PACKET){
			
				LPPACKETNODE pNodeWalker;

				pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

				while(pNodeWalker && pNodeWalker->pNext!=pNode){
					pNodeWalker=pNodeWalker->pNext;
				}
				if(pNodeWalker){
					pNodeWalker->pNext=pNode->pNext;
				}else{
					DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
					ASSERT(0);
				}
				
			}
			//
			// we leave dplay, since the handler counts on being able to drop the lock
			// (so if we have another thread blocked on a reply, it can process it, 
			// e.g. getnametable)
			LEAVE_DPLAY();
			
			hr = DP_SP_HandleNonProtocolMessage((IDirectPlaySP *)this->pInterfaces,pNode->pMessage,
					pNode->dwMessageSize,pNode->pvSPHeader);

			ENTER_DPLAY();
			
			// free up the packet node
			if(command==DPSP_MSG_PACKET){
				#ifdef DEBUG
				if(pNode->Signature != NODE_SIGN){
					DPF(0,"Invalid Node %x, Signature %x\n",pNode, pNode->Signature);
					DEBUG_BREAK();
				}
				#endif
				FreePacketNode(pNode);
			} else {
				ASSERT(command==DPSP_MSG_PACKET2_DATA);
				// We dropped the lock, so make sure still in the node
				// list before we free the buffer.
				pNodePrev = this->pPacketList;
				while(pNodePrev){ 
					if(pNodePrev==pNode){
						if (pNode->pBuffer){
							// don't need the memory any more, still need the node
							// to handle ACKing retries by the other machine
							DPMEM_FREE(pNode->pBuffer);
							pNode->pBuffer=NULL;
						}	
						break;
					}
					pNodePrev=pNodePrev->pNextPacketnode;
				}

				StartPacketizeTicker(this);
				// Type 2's are removed by the ticker, after 1 minute.
			}

			return hr;
		}
	}	
	// otherwise, wait for more packets...
exit:			
	return DP_OK;

}  // HandlePacket

#undef DPF_MODNAME
#define DPF_MODNAME	"PacketizeAndSend"

// how many packets will it take to send this message?
// dwMessageSize is the message size originally passed to senddpmessage 
// (or doreply)
UINT GetNPackets(LPDPLAYI_DPLAY this,DWORD dwMessageSize,DWORD dwFlags)
{
	DWORD dwPacketSpace; // space available in a packet
	UINT nPackets;

	// how much data will we need to send (neglecting headers)
	dwMessageSize -= this->dwSPHeaderSize;

	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSpace = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSpace = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSpace = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSpace = this->dwSPMaxMessage;		
		}
	}

	// now, we need to put a SP header and a dplay packet header on the front
	// dwPacketSpace will be the amount of data (as opposed to header) each packet
	// can carry
	dwPacketSpace -= (this->dwSPHeaderSize + sizeof(MSG_PACKET));
	DPF(8,"get packets : space / packet = %d\n",dwPacketSpace);

	nPackets = dwMessageSize / dwPacketSpace;
	if (0 != (dwMessageSize % dwPacketSpace)) nPackets++; // little bit left over

	DPF(8,"get packets : message size = %d, packets needed = %d\n",dwMessageSize,nPackets);

	return nPackets;
	
} // GetNPackets

// called by PacketizeAndSend and HandlePacket(for ACKing)
HRESULT ReplyPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPVOID pvMessageHeader, USHORT dwVersion)
{
	HRESULT hr;

	hr = DoReply(this,pSendPacket,dwPacketSize,pvMessageHeader,dwVersion);

	return hr;

} // ReplyPacket

// called by PacketizeAndSend	
HRESULT SendPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags, BOOL bReply)
{
	HRESULT hr;

	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendPacket,dwPacketSize,dwFlags,bReply);

	return hr;

} // SendPacket


void CALLBACK SendTimeOut( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	LPPACKETNODE pNode=(LPPACKETNODE)dwUser,pNodeWalker;
	UINT tmCurrentTime;
	BILINK *pBilink;
	UINT bFound=FALSE;

	tmCurrentTime=timeGetTime();

	DPF(4,"==>PacketizeSendTimeOut uID %x dwUser %x\n",uID,dwUser);

	// we know that if we find a node on the timeout list, that:
	// 	1. the node must be valid, because it must be pulled off to be freed.
	//  2. its this pointer is valid, because DP_Close frees the list before
	//     freeing the 'this' pointer AND DP_Close takes the TimeOutListLock
	//     to do the removal.

	PACKETIZE_LOCK();

	pBilink=g_PacketizeTimeoutList.next;

	while(pBilink != &g_PacketizeTimeoutList){
		pNodeWalker=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(pNode == pNodeWalker){
			if(pNode->uRetryTimer==uID || pNode->uRetryTimer==INVALID_TIMER){
				DPF(9,"Found Node %x in List, signalling retry thread\n",dwUser);
				pNode->uRetryTimer=0;
				Delete(&pNode->TimeoutList);		
				InitBilink(&pNode->TimeoutList);
				InsertAfter(&pNode->RetryList, &pNode->lpDPlay->RetryList);
				SetEvent(pNode->lpDPlay->hRetry);
				break;
			}
		}
	}

	PACKETIZE_UNLOCK();
	
}

VOID SendNextPacket(
	LPDPLAYI_DPLAY this, 
	LPPACKETNODE pNode,
	BOOL bInDplay
	)
{
	HRESULT hr;
	LPBYTE pSendPacket; // packet we're going to send out (header ptr)
	LPBYTE pSendData;   // data area of the packet
	DWORD dwPacketSpace; // space available in the data area
	DWORD dwPacketSize;
	DWORD dwBytesSoFar;
	LPMSG_PACKET pmsg;	// pointer to packet header (after SPHeader);

	BOOL bReply;

    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;

	if(pNode->dwSoFarPackets==pNode->dwTotalPackets){
		DPF(8,"SendNextPacket: node done, not sending, blowing away node. %x\n",pNode);
		goto exit1;
	}

	if(pNode->pvSPHeader) {
		bReply=TRUE;
	} else {
		bReply=FALSE;
	}	

	if(!bReply){

		pPlayerFrom = PlayerFromID(this,pNode->dwIDFrom);
		pPlayerTo = PlayerFromID(this,pNode->dwIDTo);
	}

	// amount of room in packet for data
	
	if(this->pProtocol){
		dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET2));

	// walk through the buffer, overwriting space in front of next outgoing packet.
	dwBytesSoFar=(pNode->dwSoFarPackets*dwPacketSpace);
	
	pSendData   = pNode->pMessage+dwBytesSoFar;
	pSendPacket = pSendData-sizeof(MSG_PACKET2)-this->dwSPHeaderSize;

	ASSERT(pSendPacket >= pNode->pBuffer);
	ASSERT(pSendPacket < pNode->pMessage+pNode->dwMessageSize);
	
	// set up the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	//
	// Build the header
	//

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET2_DATA);
	pmsg->dwTotalPackets = pNode->dwTotalPackets;
	pmsg->dwMessageSize = pNode->dwMessageSize;  // already has SP header size removed in sending case.

	pmsg->dwDataSize=dwPacketSpace;
	
	// size correction for last packet
	if(dwBytesSoFar+dwPacketSpace > pNode->dwMessageSize){
		pmsg->dwDataSize=pNode->dwMessageSize-dwBytesSoFar;
	}

	dwPacketSize=this->dwSPHeaderSize+sizeof(MSG_PACKET2)+pmsg->dwDataSize;

	pmsg->dwPacketID = (DWORD) pNode->dwSoFarPackets;

	// how many bytes into message does this packet start
	pmsg->dwOffset = (ULONG) (pSendData-pNode->pMessage); 

	pmsg->guidMessage=pNode->guidMessage;

	// we set this to INVALID_TIMER so we can check if we need to set the timeout later.
	pNode->uRetryTimer=INVALID_TIMER;
	
	if(!pNode->dwRetryCount){
		pNode->tmTransmitTime=timeGetTime();
	}	
	
	if (bReply)
	{
		DPF(7,"SendNextPacket, Reply Packet# %x From %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = ReplyPacket(this,pSendPacket,dwPacketSize,pNode->pvSPHeader,0);			   
	}
	else 
	{
		ASSERT(pNode->dwSoFarPackets==0);
		DPF(7,"SendNextPacket, SendPacket Packet# %xFrom %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = SendPacket(this,pSendPacket,dwPacketSize,pPlayerFrom,pPlayerTo,pNode->dwSendFlags&~DPSEND_GUARANTEED,FALSE);
	}

	// Start the retry timer - unless we already got an ACK (which will clear uRetryTimer)
	if(!FAILED(hr)){
		if(pNode->uRetryTimer==INVALID_TIMER){

			PACKETIZE_LOCK();

#if 0			
			pNode->uRetryTimer=timeSetEvent(pNode->dwLatency+pNode->dwLatency/2,
											pNode->dwLatency/4,
											SendTimeOut,
											(ULONG)pNode,
											TIME_ONESHOT);
#endif											

			pNode->uRetryTimer=SetMyTimer(pNode->dwLatency+pNode->dwLatency/2,
										   pNode->dwLatency/4,
										   SendTimeOut,
										   (ULONG_PTR)pNode,
											&pNode->Unique);

			if(pNode->uRetryTimer){
				InsertBefore(&pNode->TimeoutList, &g_PacketizeTimeoutList);
			} else {
				ASSERT(0);
				DEBUG_BREAK();
				PACKETIZE_UNLOCK();
				goto exit1;
			}
											
			PACKETIZE_UNLOCK();
			
		}	
	} else {
		goto exit1;
	}
	return;

exit1:
	BlowAwayPacketNode(this,pNode);
	return;
}

/*
 ** PacketizeAndSendReliable - if you don't want reliable, don't call this!
 *
 *  CALLED BY: 
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending. 
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: like packetize and send, but only dispatches the first
 *               packet, subsequent packets are transmitted by SendNextPacket
 *               when the previous packet was ACKed.
 *
 *               Yes folks, this is async.
 * 
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSendReliable(
	LPDPLAYI_DPLAY  this,
	LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,
	LPBYTE pMessage,
	DWORD  dwMessageSize,
	DWORD  dwFlags,
	LPVOID pvMessageHeader,
	BOOL   bReply
)
{
	UINT  nPackets;		// number of datagrams to send this message
	DWORD dwPacketSize; // size of each packet
	GUID  guid;         // a guid for this message
	
    LPPACKETNODE pNode;	// "send" node for packet

	HRESULT hr;

	if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		return DPERR_UNAVAILABLE;
	}

	if (((dwFlags & DPSEND_GUARANTEED) &&(!(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE))) ||
		(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)
	    ) 
	{
		// SP's reliable, so we don't have to.
		return PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,pvMessageHeader,bReply);
	}

	// turn off guaranteed bit since we do the reliability.
	nPackets = GetNPackets(this,dwMessageSize,dwFlags&~DPSEND_GUARANTEED);

	if(this->pProtocol){
		dwPacketSize=this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	// Create a GUID for this message... (very expensive, but this is rare)
	hr=OS_CreateGuid(&guid);

	if(FAILED(hr)){
		goto error_exit;
	}
	
	// Get a node to describe this send.
	hr=NewPacketnode(this, &pNode, &guid, dwMessageSize-this->dwSPHeaderSize, nPackets, pvMessageHeader);

	if(FAILED(hr)){
		goto error_exit;
	}

	memcpy(pNode->pMessage, pMessage+this->dwSPHeaderSize, dwMessageSize-this->dwSPHeaderSize);

	pNode->dwSoFarPackets=0;

	pNode->bReliable   = TRUE;
	pNode->bReceive    = FALSE;

	// Worse case assumption for latency, since only comes into play
	// for retries on first packet, assume 14.4 modem (aprox) 1800 bytes/sec
	// This will get updated by the first ACK.
	if(dwMessageSize < 500){
		pNode->dwLatency = 20 + dwMessageSize/2;
	} else {
		pNode->dwLatency = 600;  
	}
	
	pNode->dwRetryCount= 0;
	pNode->tmLastReceive=timeGetTime();

	if(!bReply) {
		if(pPlayerTo){
			pNode->dwIDTo=pPlayerTo->dwID;
		} else {
			pNode->dwIDTo=0;
		}
		if(pPlayerFrom){
			pNode->dwIDFrom=pPlayerFrom->dwID;
		} else {
			pNode->dwIDFrom=0;
		}
		pNode->dwSendFlags=dwFlags;
	}	

	// don't need ref for i/f ptr since timers cancelled during shutdown.
	pNode->lpDPlay=this;

	ASSERT(gnDPCSCount);
	SendNextPacket(this, pNode, TRUE);

error_exit:
	return hr;

} // PacketizeAndSendReliable



/*
 ** PacketizeAndSend
 *
 *  CALLED BY: SendDPMessage, HandleXXXMessage
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending.  NULL if we're 
 *				called by HandleXXX
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: packs up the message into sp size chunks, and sends (or replies)
 *				it out.
 *
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply)
{
	UINT nPackets;	
	LPBYTE pBufferIndex;
	DWORD dwPacketSize; // size of each packet
	DWORD dwPacketSpace; // space available in a packet for msgdata
	LPBYTE pSendPacket; // packet we're going to send out
	LPMSG_PACKET pmsg;	
	DWORD dwBytesLeft;
	DWORD iPacket=0;	// index of the current packet
	HRESULT hr = DP_OK;

	nPackets = GetNPackets(this,dwMessageSize,dwFlags);
	
	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSize = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSize = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSize = this->dwSPMaxMessage;		
		}
	}
	
	pSendPacket = DPMEM_ALLOC(dwPacketSize);
	if (!pSendPacket)
	{
		DPF_ERR("could not alloc packet!");
		return E_OUTOFMEMORY;
	}

	// do the one time set up of the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	// stick a guid on this baby, so receiving end knows which message packet
	// goes with
	hr = OS_CreateGuid(&(pmsg->guidMessage));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET);
	pmsg->dwTotalPackets = nPackets;
	pmsg->dwMessageSize = dwMessageSize - this->dwSPHeaderSize;

	// amount of room in packet for data
	// DX5 doesn't expect us to send him messages that are longer than he thinks they can be
	// even though there was an error in the size calculation in DX5.  So we subtract 8 from
	// the actual available space so we can talk to DX5 properly.
	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET))-8/*dx5 compat*/;

	// we start reading out of the buffer after the header
	pBufferIndex = pMessage + this->dwSPHeaderSize;
	dwBytesLeft = dwMessageSize - this->dwSPHeaderSize;

	while (iPacket < nPackets)
	{
		// set up the header info specific to this packet 
		if (dwBytesLeft >= dwPacketSpace) pmsg->dwDataSize = dwPacketSpace;
		else pmsg->dwDataSize = dwBytesLeft;

		pmsg->dwPacketID = (DWORD) iPacket;

		// how many bytes into message does this packet go
		// on the receiving side, we don't have the header, so cruise that here...
		pmsg->dwOffset = (ULONG)(pBufferIndex - pMessage - this->dwSPHeaderSize); 

		// copy the data into the packet
		memcpy(pSendPacket + this->dwSPHeaderSize + sizeof(MSG_PACKET),pBufferIndex,
				pmsg->dwDataSize);

		if (bReply)
		{
			hr = ReplyPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pvMessageHeader,0);			   
		}
		else 
		{
			hr = SendPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pPlayerFrom,pPlayerTo,dwFlags,bReply);
		}
		if (FAILED(hr))
		{
			DPF(0,"could not send packet! hr = 0x%08lx\n",hr);
			goto ERROR_EXIT;

		}
		pBufferIndex += pmsg->dwDataSize;
		dwBytesLeft -= pmsg->dwDataSize;
		iPacket++;
	}


ERROR_EXIT:

	DPMEM_FREE(pSendPacket);

	return hr;

} // PacketizeAndSend


// SendPacketizeACK is always called from HandleMessage, therefore it
// always uses ReplyPacket to send the ACK.
//
// side-effect changes the dwCmdToken of the message.-also requires header space before pMsg.
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pMsg)
{
	SET_MESSAGE_HDR(pMsg);
	SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_PACKET2_ACK);
	ReplyPacket(this, ((LPBYTE)pMsg)-this->dwSPHeaderSize, sizeof(MSG_PACKET2_ACK)+this->dwSPHeaderSize, pNode->pvSPHeader, DPSP_MSG_VERSION);	
}

// Note, tick runs in the MM timer thread, so it can safely take
// the DPLAY lock.

void CALLBACK PacketizeTick( UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2 )
{
	LPDPLAYI_DPLAY this = (LPDPLAYI_DPLAY)(dwUser);
	
	LPPACKETNODE pNode, pLastNode=NULL;
	LPPACKETNODE pFreeNodes=NULL;

	UINT tmCurrentTime;

	tmCurrentTime=timeGetTime();

	ENTER_DPLAY();

		DPF(8,"PACKETIZE TICK");
		
		if(this->uPacketTickEvent==uID){
		
			this->uPacketTickEvent=0;
			// Scan the list looking for completed receives that have been around for 1 minute
			// or more.  If they have been, move them to a list to be blown away.

			pLastNode=(LPPACKETNODE)&this->pPacketList; //tricky...
			pNode=this->pPacketList;

			while(pNode){
				if(pNode->bReliable && pNode->bReceive){
					if(tmCurrentTime-pNode->tmLastReceive > PACKETIZE_RECEIVE_TIMEOUT){
						// remove this node from the list.
						pLastNode->pNextPacketnode=pNode->pNextPacketnode;
						// put it on the list to be freed.
						pNode->pNextPacketnode=pFreeNodes;
						pFreeNodes=pNode;
						// skip to the next node.
						pNode=pLastNode->pNextPacketnode;
						this->nPacketsTimingOut -= 1;
						ASSERT(!(this->nPacketsTimingOut&0x80000000));
						continue;
					}
				}
				pLastNode=pNode;
				pNode=pNode->pNextPacketnode;
			}

			if(this->nPacketsTimingOut){	
				this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
			}
		}	

	LEAVE_DPLAY();

	// we free the nodes after to reduce serialization.
	while(pFreeNodes){
		pNode=pFreeNodes->pNextPacketnode;
		FreePacketNode(pFreeNodes);
		pFreeNodes=pNode;
	}
}

// When a player is being deleted this removes sends to that player from the message queue.
VOID DeletePlayerPackets(LPDPLAYI_DPLAY this, UINT idPlayer)
{
	LPPACKETNODE pNode;

	ENTER_DPLAY();

	DPF(8,"==>Deleting player packets for playerid:x%x",idPlayer);

		pNode=this->pPacketList;

		while(pNode){
			// only delete sending nodes, since receive nodes req'd to ACK remote retries.
			if(!pNode->bReceive && pNode->dwIDTo==idPlayer){
					pNode->dwRetryCount=MAX_PACKETIZE_RETRY; //let next timeout deal with it.
			}
			pNode=pNode->pNextPacketnode;
		}

	LEAVE_DPLAY();
	
}

// Can only be called with DPLAY LOCK held.
VOID StartPacketizeTicker(LPDPLAYI_DPLAY this)
{
	this->nPacketsTimingOut += 1;
	if(this->nPacketsTimingOut == 1){
		// First one, start up the ticker. - note ok with lock since this must be first call.
		this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\pending.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pending.c
 *  Content:	manage commands received while we're waiting for the
 *				nametable, or while we've dropped our lock during a 
 *				guaranteed send.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	6/3/96		andyco	created it.
 *	7/10/96		andyco	updated w/ pendingnodes, etc.
 *	2/1/97		andyco	modified pending so we can use it when we drop the 
 *						lock for guaranteed sends
 *	2/18/97		andyco	push pending nodes onto back (end) of Q
 *  3/17/97     sohailm push pending shouldn't copy the sp header if it is
 *                      DPSP_HEADER_LOCALMSG
 *	6/18/97		andyco	checkpending called playerfromid, and then checked for
 *						!NULL.  But, if we're the namesrvr, it could return
 *						NAMETABLE_PENDING. So, we have to call VALID_PLAYER or
 *						VALID_GROUP instead.
 *  7/28/97		sohailm	Updated pending code to enable sends in pending mode.
 *	8/29/97		sohailm	Copy sp header correctly for local messages in pushpending (bug 43571)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *               	    constant time instead of O(n) where n is number
 *                 		of messages in queue.
 *  6/26/00     aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *                     B#8757 WinSE - stress,added lock on QueueMessageNodeOnReceiveList
***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"PushPendingCommand"

// we got a command.
// we don't have the nametable yet, so add this command to the
// pending list...
HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPPENDINGNODE pmsg=NULL;
	LPVOID pReceiveCopy=NULL; // we will copy pReceiveBuffer here (SP reuses buffer)
	LPVOID pHeaderCopy=NULL; // alloc'ed if needed
	HRESULT hr;
	
	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);

	if (!pReceiveBuffer) return DP_OK;

	// get the pending node
	pmsg = DPMEM_ALLOC(sizeof(PENDINGNODE));
	if (!pmsg)
	{
		DPF_ERR("could not alloc new pending node - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy over the message
	pReceiveCopy = DPMEM_ALLOC(dwMessageSize);
	if (!pReceiveCopy)
	{
		DPF_ERR("could not alloc pending copy buffer - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	memcpy(pReceiveCopy,pReceiveBuffer,dwMessageSize);

	// copy over the header, if needed
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader))
	{
		pHeaderCopy = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pHeaderCopy)
		{			
			DPF_ERR("could not alloc pending copy header buffer - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pHeaderCopy,pvSPHeader,this->dwSPHeaderSize);
	}
	else 
	{
		pHeaderCopy = pvSPHeader;
	}

	// store a copy of the command
	pmsg->pMessage = pReceiveCopy;
	pmsg->dwMessageSize = dwMessageSize;
	pmsg->pHeader = pHeaderCopy;
	pmsg->dwSendFlags = dwSendFlags; // for security code.  e.g. DPSEND_ENCRYPTED
	
	// stick pmsg on the back of the list
	if(this->pMessagesPending){
		this->pLastPendingMessage->pNextNode=pmsg;
		this->pLastPendingMessage=pmsg;
	} else {
		this->pMessagesPending=pmsg;
		this->pLastPendingMessage=pmsg;
	}

	// bump the pending count
	this->nMessagesPending++;

	// success
	return DP_OK;	

ERROR_EXIT:
	if (pmsg) DPMEM_FREE(pmsg);
	if (pReceiveCopy) DPMEM_FREE(pReceiveCopy);
	if (VALID_SPHEADER(pHeaderCopy)) DPMEM_FREE(pHeaderCopy);

	// failure
	return hr;

} // PushPendingCommand

#undef DPF_MODNAME
#define DPF_MODNAME	"ExecutePendingCommands"

// see if our pending message is a create that we got w/ the name
// table (i.e. filter redundant creates, since they would hose our
// unpack code...
HRESULT CheckPendingMessage(LPDPLAYI_DPLAY this,LPPENDINGNODE pmsg)
{
	DWORD dwCommand;

    // extract command
	if ((pmsg->dwMessageSize < sizeof(DWORD)) || (IS_PLAYER_MESSAGE(pmsg->pMessage)))
	{
		dwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
	    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pmsg->pMessage));
	}
	
	switch (dwCommand)
	{

		case DPSP_MSG_CREATEPLAYER:
		case DPSP_MSG_CREATEPLAYERVERIFY:
		{
			DWORD dwPlayerID;
			LPDPLAYI_PLAYER pPlayer;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pPlayer = PlayerFromID(this,dwPlayerID);
	        if (VALID_DPLAY_PLAYER(pPlayer))
	        {
	        	switch(dwCommand){
	        		case DPSP_MSG_CREATEPLAYER:
						DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
						break;
					case DPSP_MSG_CREATEPLAYERVERIFY:
						DPF(1,"got redundant create verfiy message in pending list id = %d - discarding",dwPlayerID);
						break;
	        	}		
				return E_FAIL; // squash it
			}
			
			break;
		}		
		case DPSP_MSG_CREATEGROUP:
		{
			DWORD dwPlayerID;
			LPDPLAYI_GROUP pGroup;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pGroup = GroupFromID(this,dwPlayerID);
	        if (VALID_DPLAY_GROUP(pGroup))
	        {
				DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
				return E_FAIL; // squash it
			}

			break;
		}		

		default:
			// other messages will be benign (e.g. deletes won't delete twice, etc.)
			// let it through
			break;

	} // switch

	return DP_OK;

} // CheckPendingMessage

// run through the list of pending commands
// call handler.c w/ q'ed up commands
// caller expects this function to clear DPLAYI_DPLAY_PENDING flag
// while executing pending commands, all new messages go on the pending queue.
HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this)	
{
	LPPENDINGNODE pmsg,pmsgDelete;
	HRESULT hr;
	DWORD nMessagesPending;

	if(!(this->dwFlags & DPLAYI_DPLAY_PENDING)){
		return DP_OK;
	}

	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);
	ASSERT(this->pSysPlayer);
	
    if (this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING)
    {
		// we get here when we try to flush the pending queue after completing a 
		// reliable send in execute pending mode.
        DPF(7,"We are already in execute pending mode - not flushing the pending queue");
        return DP_OK;
    }

	if (this->nMessagesPending) 
	{
		DPF(7,"STARTING -- EXECUTING PENDING LIST nCommands = %d\n",this->nMessagesPending);
		DPF(7,"	NOTE - ERROR MESSAGES GENERATED WHILE EXECUTING PENDING MAY BE BENIGN");
	}
	else 
	{
		ASSERT(NULL == this->pMessagesPending);
		DPF(7,"Leaving pending mode, no messages had been queued");
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
		return DP_OK;
	}

	// mark that we're exec'ing the pending list, so player messages don't get copied again
	this->dwFlags |= DPLAYI_DPLAY_EXECUTINGPENDING;
	
	while (this->nMessagesPending)
	{
		// take the pending queue out of circulation
		pmsg = this->pMessagesPending;
		nMessagesPending = this->nMessagesPending;
		this->pMessagesPending = NULL;
		this->pLastPendingMessage = NULL;
		this->nMessagesPending = 0;

		while (pmsg)
		{
			nMessagesPending--;

			// checkpending looks for dup messages
			hr = CheckPendingMessage(this,pmsg);
			if (SUCCEEDED(hr))
			{
				// drop the lock since InternalHandleMessage will take it again
				LEAVE_DPLAY();

				hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,pmsg->pMessage,
					pmsg->dwMessageSize,pmsg->pHeader,pmsg->dwSendFlags);

				ENTER_DPLAY();

				if (FAILED(hr))
				{
					// todo - do we care about hresult here?
					// this can fail e.g. due to commands we q'ed being processed by
					// namesrvr b4 it send us the nametable...
					ASSERT(FALSE);
					// keep going...
				}
			}

			pmsgDelete = pmsg;
			pmsg = pmsg->pNextNode;  // store this now so we don't blow it away
			
			// clean up pmsgDelete
			if (pmsgDelete->pMessage) DPMEM_FREE(pmsgDelete->pMessage);
			if (VALID_SPHEADER(pmsgDelete->pHeader)) DPMEM_FREE(pmsgDelete->pHeader);
			DPMEM_FREE(pmsgDelete);
		}

		ASSERT(0 == nMessagesPending);

		// messages might have come into the pending queue when we dropped the lock
		// make sure they are all processed before exiting the loop
		DPF(7,"%d messages were pushed on the pending queue in execute pending mode",this->nMessagesPending);
	}

	ASSERT(0  == this->nMessagesPending);
	
	DPF(7,"FINISHED -- EXECUTING PENDING LIST - ERRORS NO LONGER BENIGN");
	
	// reset pending flags
	this->dwFlags &= ~(DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_PENDING);
	
	return DP_OK;

} // ExecutePendingCommands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\perf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perf.c
 *  Content:	uses a memory mapped file to send dp_perfdata to directx control
 *				panel.  see dpcpl.h and MANROOT\dxcpl\dplay.c
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/20/96	andyco	created it
 *
 ***************************************************************************/

#include "dplaypr.h"
#include "dpcpl.h"

#define DPF_MODNAME "performance thread"

// how often we send updates to cpl
#define PERF_INTERVAL 1000
// how long we wait before deciding cpl has gone away
#define PERF_TIMEOUT 5000

BOOL gbInitMapping; // is the mapping done?
LPDP_PERFDATA gpPerfData; // out global perfdata
HANDLE ghFile;  // handle to mapped file
HANDLE ghEvent; // event to notify cpl that there's new data
HANDLE ghMutex; // used to sync access to the mapped file
HANDLE ghAckEvent; // set by the control panel when it has processed our update

void FiniMappingStuff(LPDPLAYI_DPLAY this)
{
    if (ghFile) CloseHandle(ghFile),ghFile=NULL;
    if (ghEvent) CloseHandle(ghEvent),ghEvent=NULL;
    if (gpPerfData) UnmapViewOfFile(gpPerfData),gpPerfData = NULL;
    if (ghMutex) CloseHandle(ghMutex),ghMutex = NULL;
    if (ghAckEvent) CloseHandle(ghAckEvent),ghAckEvent=NULL;
    if (this->pPerfData) DPMEM_FREE(this->pPerfData),this->pPerfData = NULL;
	gbInitMapping = FALSE;
	
    return ;
	
} // FiniMappingStuff

HRESULT InitMappingStuff(LPDPLAYI_DPLAY this)
{
    // Create the file mapping
    ghFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
		PAGE_READWRITE,	0, FILE_MAP_SIZE,FILE_MAP_NAME);

    if (NULL != ghFile && GetLastError() != ERROR_ALREADY_EXISTS)
    {
		// this is ok - we'll check again later
		DPF(9,"ack - file mapping didn't exist!");
		goto ERROR_EXIT;
    }

    gpPerfData = MapViewOfFile(ghFile, FILE_MAP_WRITE, 0, 0, 0);
    if (!gpPerfData)
    {
    	DPF_ERR("ack - could not map file");
    	goto ERROR_EXIT;
    }

    ghEvent = CreateEventA(NULL,FALSE,TRUE,EVENT_NAME);
    if (!ghEvent)
    {
    	DPF_ERR("could not create event!");
		goto ERROR_EXIT;
    }

    ghAckEvent = CreateEventA(NULL,FALSE,TRUE,ACK_EVENT_NAME);
    if (!ghAckEvent)
    {
    	DPF_ERR("could not create ack event!");
		goto ERROR_EXIT;
    }

    // used to sync access to the shared memory
    ghMutex = CreateMutexA( NULL, FALSE, MUTEX_NAME );
    if (!ghMutex)
    {
    	DPF_ERR("could not create Mutex!");
		goto ERROR_EXIT;
    }

    // alloc the perf data
    this->pPerfData = DPMEM_ALLOC(sizeof(DP_PERFDATA));
    if (!this->pPerfData)
    {
    	DPF_ERR("could not alloc perf data - out of memory!");
		goto ERROR_EXIT;
    }

    // set up the constant value stuff
    this->pPerfData->dwProcessID = GetCurrentProcessId();

    // get the exe name
   	if (!GetModuleFileNameA(NULL,this->pPerfData->pszFileName,MAX_NAME))
   	{
   		ASSERT(FALSE);
   	}

	gbInitMapping = TRUE;

    return S_OK;

ERROR_EXIT:
	FiniMappingStuff(this);
    return E_FAIL;

}  // InitMappingStuff

void ResetPerfData(LPDPLAYI_DPLAY this)
{
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS = 0;
		this->pPerfData->nReceiveBPS= 0;
		this->pPerfData->nSendPPS= 0;
		this->pPerfData->nReceivePPS= 0;
		this->pPerfData->nSendErrors= 0;
		this->pPerfData->bHost = FALSE;
	}
	
}  // ResetPerfData

void DoUpdateCPL(LPDPLAYI_DPLAY this)
{
	DWORD dwRet;

	ASSERT(this->pSysPlayer);

	// send a message to the dxcpl
	if (!gbInitMapping)
	{
		InitMappingStuff(this);
	}

	if (gbInitMapping)
	{
		ASSERT(gpPerfData);
		// take the lock
	    WaitForSingleObject( ghMutex, INFINITE );
		// copy local info to the shared perf data
		memcpy(gpPerfData,this->pPerfData,sizeof(DP_PERFDATA));
		// update the session name (in case it was changed)...
		WideToAnsi(gpPerfData->pszSessionName,this->lpsdDesc->lpszSessionName,MAX_NAME);
		// host?
		if (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) gpPerfData->bHost = TRUE;
		// nplayers
		gpPerfData->nPlayers = this->lpsdDesc->dwCurrentPlayers;
        // sp name
        ASSERT(this->pspNode);
	   	ASSERT(this->pspNode->lpszPath);
   		WideToAnsi(gpPerfData->pszSPName,this->pspNode->lpszName,MAX_NAME);

		// tell the cpl to process update
		SetEvent(ghEvent);
		
		LEAVE_DPLAY(); // so app isn't blocked while cpl processes data
		
		// wait for dxcpl to finish w/ it
		dwRet = WaitForSingleObject(ghAckEvent,PERF_TIMEOUT);

		ENTER_DPLAY();
		
		ReleaseMutex( ghMutex );

		if (WAIT_OBJECT_0 != dwRet)
		{
			// rut ro, cpl might have split
			// reset everything...
			DPF_ERR(" no response from control panel - resetting...");
			FiniMappingStuff(this);
		}
		// reset counters		
		ResetPerfData(this);
	}
	return ;

}//  DoUpdateCPL		

DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this)
{
	
	DWORD dwRet;
	HRESULT hr;
		
	DPF(1,"starting perf thread proc");
	
 	while (1)
 	{
		dwRet = WaitForSingleObject(this->hPerfEvent,PERF_INTERVAL);
		if (WAIT_OBJECT_0 == dwRet)
		{
			// if it's wait_object_0, someone set our event
			// dplay must be closing.  scram.
			goto CLEANUP_EXIT;
		}

		ENTER_DPLAY();

		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || !(VALID_DPLAY_PLAYER(this->pSysPlayer))
			|| (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_DPLAY();
			goto CLEANUP_EXIT;
		}

		DoUpdateCPL(this);
		
		LEAVE_DPLAY();
	}	

CLEANUP_EXIT:
	FiniMappingStuff(this);
	DPF(1,"perf thread exiting");
	return 0;
	
} // PerfThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\sgl.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sgl.c
 *  Content:	functions for manipulating scatter gather lists.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 12/18/97   aarono    Original
 ***************************************************************************/

#include "dplaypr.h"

void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	ASSERT(psp->cBuffers < MAX_SG);
	
	memmove(&psp->Buffers[1],&psp->Buffers[0],psp->cBuffers*sizeof(SGBUFFER));
	memmove(&psp->BufFree[1],&psp->BufFree[0],psp->cBuffers*sizeof(BUFFERFREE));
	psp->Buffers[0].pData=pData;
	psp->Buffers[0].len=len;
	psp->BufFree[0].fnFree=fnFree;
	psp->BufFree[0].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	UINT i = psp->cBuffers;

	ASSERT(psp->cBuffers < MAX_SG);
	
	
	psp->Buffers[i].pData=pData;
	psp->Buffers[i].len=len;
	psp->BufFree[i].fnFree=fnFree;
	psp->BufFree[i].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void FreeMessageBuffers(LPSENDPARMS psp)
{
	UINT i;
	for(i=0;i<psp->cBuffers;i++){
		if(psp->BufFree[i].fnFree){
			(*psp->BufFree[i].fnFree)(psp->BufFree[i].lpvContext,psp->Buffers[i].pData);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\sendparm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sendparm.c
 *  Content:	management of send parameter structure
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/08/98  aarono    Original
 *  02/13/98  aarono    Fixed bugs found in async testing
 *  06/02/98  aarono    fix psp completion for invalid player
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98   aarono    fix group SendEx ASYNC to use unique Header
 ***************************************************************************/

#include "dplaypr.h"
#include "mcontext.h"

// Release all memory/resources associated with a send and then the send parms themselves
VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bFreeParms)
{
	PGROUPHEADER pGroupHeader,pGroupHeaderNext;
	FreeMessageBuffers(psp);
	if(psp->hContext){
		ReleaseContextList(this, psp->hContext);	
	}
	pGroupHeader=psp->pGroupHeaders;
	while(pGroupHeader){
		ASSERT(psp->pGroupTo);
		pGroupHeaderNext=pGroupHeader->pNext;
		this->lpPlayerMsgPool->Release(this->lpPlayerMsgPool,pGroupHeader);
		pGroupHeader=pGroupHeaderNext;
	}
	if(bFreeParms){
		FreeSendParms(psp);
	}	
}

//
// Send Parm init/deinit.
//

BOOL SendInitAlloc(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	InitializeCriticalSection(&psp->cs);
	return TRUE;
}

VOID SendInit(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	psp->RefCount=1;
	psp->pGroupHeaders=NULL;
}

VOID SendFini(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	DeleteCriticalSection(&psp->cs);
}

//
// Management of Context List
//

// initialize context list and info on a psp.
HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize)
{
	psp->hContext=AllocateContextList(this,psp,nInitSize);
	if(!psp->hContext){
		return DPERR_OUTOFMEMORY;
	}
	
	*psp->lpdwMsgID=(DWORD_PTR)psp->hContext;
	
	psp->iContext=0;
	psp->nContext=nInitSize;
	return DP_OK;
}

// Note, this only works for context lists with an initial size > 1
UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext)
{
    UINT    n;
	PAPVOID papvList;
	UINT    nListEntries;

	PAPVOID papvNewList;
	UINT    nNewListEntries;

	EnterCriticalSection(&psp->cs);

	if(psp->iContext == psp->nContext){

			nNewListEntries=psp->iContext+4;
			// Need to grow the list
			// Get a new list
			papvNewList=AllocContextList(this,nNewListEntries);
			if(!papvNewList){
				return 0;
			}

			// transcribe the old list into the new list.
			ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
			if(nListEntries){
				memcpy(papvNewList,papvList,nListEntries*sizeof(PVOID));
				// free the old list
				FreeContextList(this, papvList, nListEntries);
			}	


			// setup the new list in the psp
			WriteContextList(this, psp->hContext, papvNewList, nNewListEntries);
			psp->nContext   = nNewListEntries;
	}

	// Normal operation, set an entry.
	ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
	(*papvList)[psp->iContext]=pvContext;
	
	n=psp->iContext++;

	LeaveCriticalSection(&psp->cs);
	
	return n;
}

UINT pspAddRefNZ(PSENDPARMS psp) // this one won't add to a zero refcount.
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	if(newCount==1){
		newCount=--psp->RefCount;
	}
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

UINT pspAddRef(PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	ASSERT(psp->RefCount != 0);
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

#ifdef DEBUG
UINT nMessagesQueued=0;
#endif

UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount = --psp->RefCount;
	if(newCount&0x80000000){
		ASSERT(0); 
	}
	LeaveCriticalSection(&psp->cs);
	if(!newCount){
		// ref 0, no-one has another ref do completion message (if req'd), then free this baby
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags&DPSEND_ASYNC)){
			psp->dwSendCompletionTime=timeGetTime()-psp->dwSendTime;
			FreeSend(this,psp,FALSE); // must do here to avoid race with receiveQ
	 		#ifdef DEBUG
			nMessagesQueued++;
			#endif
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if (VALID_DPLAY_PLAYER(psp->pPlayerFrom)) {
				Delete(&psp->PendingList);
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				DPF(9,"DEC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
				QueueSendCompletion(this, psp);
			}else{
				// This happens when client doesn't close players gracefully.
				DPF(0,"Got completion for blown away player?\n");
				FreeSendParms(psp);
			}
		} else {
			FreeSend(this,psp,TRUE);
		}
	}
	return newCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\sources.inc ===
TARGETNAME=dplayx
TARGETTYPE=DYNLINK
UMTYPE=windows

USE_MAPSYM=1

INCLUDES=\
	$(DXROOT)\inc;\
	 ..\..\..\inc; \
	 ..\..\misc; \
	 ..\; \
	 ..\..\..\dvoice\inc; \
	 ..\..\dplobby; \
	 ..\..\common; \

TARGETPATH=obj

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\gdi32.lib     \
           $(SDK_LIB_PATH)\libc.lib    \
           $(SDK_LIB_PATH)\rpcrt4.lib \
           $(SDK_LIB_PATH)\user32.lib    \
           $(SDK_LIB_PATH)\kernel32.lib  \
           $(SDK_LIB_PATH)\uuid.lib  \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\version.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\ole32.lib

DLLENTRY=DllMain

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32

LINKER_FLAGS=-SECTION:share,RWS

LINKLIBS= \
	 ..\..\dplobby\$(PLAT_DIR)\$(_OBJ_DIR)\*\dplobby.lib \
	 ..\..\protocol\$(PLAT_DIR)\$(_OBJ_DIR)\*\protocol.lib

SOURCES= \
	..\loopbksp.c \
	..\dpdvtran.c \
	..\apphack.c \
	..\connect.c \
	..\perf.c \
	..\dpthread.c \
	..\paketize.c \
	..\api.c \
	..\dpos.c \
	..\iplaya.c \
	..\iplay1.c \
	..\dpunk.c \
	..\iplay.c \
	..\enum.c \
	..\dllmain.c \
	..\namesrv.c \
	..\handler.c \
	..\pack.c \
	..\sysmess.c \
	..\pending.c \
	..\sphelp.c \
	..\do.c \
	..\dpmem.c \
	..\classfac.c \
	..\dplay.rc \
	..\dpsecure.c \
	..\dpsecos.c \
	..\superpac.c \
	..\sendparm.c \
	..\sgl.c \
	..\mcontext.c \
	..\fpm.c \
	..\msgmem.c \
	memalloc.c \
	newdpf.c \
	dputils.c \
	..\dvretro.c

DLLDEF=..\dplayx.def

NTTARGETFILE0=MISC

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX8"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\handler.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       handler.c
 *  Content:	handles messages received by sp. 
 *
 *		function prefixes indicate which players execute code
 *			NS_	- executes on name server only
 *			SP_ - executed by sysplayer only
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/1/96		andyco	created it
 *	2/14/96		andyco	added user message support
 *	3/1/96		andyco	added user system messages
 *	4/12/96		andyco	added DPlay_xxx for sp's to call 
 *	4/25/96		andyco	added spblob space at end of msg's
 *	5/20/96		andyco	idirectplay2
 *	5/29/96		andyco	combined builbuildaddplayer and buildaddgroup into build add
 *	6/6/96		andyco	added namechanged,datachanged
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/22/96		andyco	check guid + pw at server on enumsessoins
 *	6/22/96		andyco	check max players b4 giving out new player id
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/1/96		andyco	turned on xxxPlayerxxGroup messages.  these weren't
 *						being generated, and left us w/ a messagenode w/ a
 *						NULL message
 *	7/3/96		andyco	setting names in buildxxxmessage was not properly 
 *						setting the pointers.  Fixes RAID # 2200.
 *  7/8/96      ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                      to 'dpnName' to match DPLAY.H
 *                      Change DPSESSION_MIGRATENAMESERVER to DPSESSION_MIGRATEHOST
 *                      Change DPSYS_NAMESERVER to DPSYS_HOST
 *	7/10/96		andyco	turned on add_forward support for pending...
 *	7/10/96		kipo	renamed system messages
 *  7/30/96     kipo    player event is a handle now.
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						handle YOUAREDEAD and session lost.
 *	8/8/96		andyco	added support for dpsession_nomessageid
 *  8/12/96		andyco	builddelete was pulling player off stack (unit'ed). duh.
 *	9/1/96		andyco	throw away player-player mess's from invalid players
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 * 10/11/96     sohailm added BuildSessionDescMessage() and SP_HandleSessionDescChanged()
 *                      added logic to handle DPSP_MSG_SESSIONDESCCHANGED message.
 * 10/12/96		andyco	don't count sysgroup in enumplayersreply
 * 11/12/96		andyco	support for server players - updatelist
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 01/16/97     sohailm name server doesn't respond to new id requests if session is
 *                      not allowing players (#4574)
 * 1/15/96		andyco	fixed handling of incoming messages to groups
 * 1/24/97		andyco	raid 4728 - don't crash if handle message gets a null message.
 * 1/28/97		andyco	transfer groups to nameserver when sysplayer owning group dies
 * 1/30/97      sohailm don't use size of message to identify version (#5504).
 *	2/1/97		andyco	don't memcpy player messages if we are in pending mode - 
 *						use the copy made by pending.c
 * 2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 * 2/26/97      sohailm update cached session descs on subsequent enumsessions (5838)
 *	3/5/97		andyco	timestamp enumsessions reply
 *	3/10/97		andyco	toggle pending mode when we have multiple local players.
 *						drop player mgmt messages when session is closed.
 * 3/12/97		myronth	Work around for global session list (hack)
 * 3/12/97      sohailm Integrated security into directplay
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 * 3/24/97      sohailm Updated EnumSessions to do the filtering on the server.
 *                      Added functionality for DPSESSION_PRIVATE and DPENUMSESSIONS_PASSWORDREQUIRED
 *                      Open now checks for a password and availability of the session
 * 3/25/97		kipo	treat zero-length password strings just like NULL password
 *						strings for DX3 compatability.
 * 3/30/97      sohailm Don't put pingreplys on the pending list.
 *                      Message signatures are not verified in execute pending mode anymore.
 * 4/04/97      sohailm Let pings through in pending mode, but only after downloading the nametable
 * 4/11/97		andyco	added domulticast
 * 4/14/97      sohailm Added support to handle encrypted messages.
 *	4/20/97		andyco	group in group 
 * 4/24/97      sohailm Now we deliver secure player-player messages as DPSYS_SECUREMESSAGE 
 *                      system messages.
 *	5/8/97		andyco	fixed 5893 - incorrectly homing on forwardaddplayer.  changed
 *						NS_HandleEnumPlayers to pack on client_server. removed updatelist.
 *	5/8/97		myronth	Build StartSession system message
 * 05/12/97     sohailm Now we send the entire DPSECURITYDESC in PLAYERIDREPLY.
 *                      Added support to process DPSP_MSG_KEYEXCHANGE.
 *	5/17/97		myronth Build and handle SendChatMessage system messages
 *	5/17/97		kipo	Make sure the ghReplyProcessed is reset
 *	5/18/97		andyco	add validatedplay on debug builds
 *  5/18/97     sohailm BuildSecureSystem() was not reporting the correct message size (8647).
 *	5/19/97		andyco	put bandaid on SP_HandlePlayerMgmtMessage
 *  5/21/97     sohailm Added InternalHandleMessage().
 *                      Now we pass DPSEND_SIGNED and DPSEND_ENCRYPTED in the secure player message
 *                      flags instead of DPSECURE_SIGNED and DPSECURE_ENCRYPTED.
 *	5/21/97		myronth	Change to correct DPMSG_CHAT format	(#8642)
 *	5/23/97		andyco	session desc goes w/ nametable.  added dplayi_dplay_handlemulticast
 *						so we correctly  locally process multicast forwards
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *	5/29/97		andyco	removed EXECUTING_PENDING optimization - too much grief
 *	5/30/97		kipo	added DPPLAYER_LOCAL
 *  6/09/97     sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 *  6/10/97     kipo	Put ping and ping reply messages on pending queue.
 *  6/16/97     sohailm Updated calls to HandleAuthenticationReply() to take message size.
 *  6/23/97     sohailm Updated InternalHandleMessage() to check the flags on secure messages.
 *	7/30/97		myronth	Added use of dwReserved fields in StartSession message for
 *						standard lobby messaging to work correctly
 *  7/31/97		sohailm	Added peer-peer message security using multicast.
 *   8/4/97		andyco	added support for async add forward
 *	8/29/97		sohailm GPF in NS_DoAsyncAddForward when modem sp is loaded (bug #12459).
 *	10/21/97	myronth	Added support for hidden group flag
 *	10/29/97	myronth	Added BuildGroupOwnerChangedMessage and case statement for it
 *	11/5/97		myronth	Removed bogus (also unneeded) prototype
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/5/97		andyco	voice stuff
 *	12/29/97	myronth	Nametable corruption related fix -- don't queue msgs
 *						for remote stuff which doesn't affect the nametable
 *	12/30/97	sohailm	DPSYSMSG_SESSIONLOST does not cause player event to be set (#16141)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		myronth	Delete remote players/groups on sessionlost (#15255)
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  3/19/98     aarono  Added prenotification of pending DELETEPLAYER messages
 *                      so the protocol can bail on ongoing sends to that player
 *	3/23/98     aarono  Now ADDFORWARD is spoofed from ADDFORWARDREQ
 *  3/31/98     aarono  backout ADDFORWARD spoof
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/6/98      aarono  Fix for handling large loopback messages with protocol
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *              	    constant time instead of O(n) where n is number
 *                	    of messages in queue.
 *  8/02/99		aarono  removed old voice support
 *  8/02/99		rodtoll voice support - added temporary voice message hook
 *  8/04/99     aarono  fixed voice group remove notify, added MIGRATION notify
 *  8/05/99     aarono  Moved voice over to DPMSG_VOICE
 *  8/10/99		rodtoll	Modified notify calls to release lock to prevent deadlocks
 *  9/09/99		rodtoll	Updated calls into voice message handler so they happen
 *						even if no client is active yet.  (For new retro launch procedure)
 * 11/02/99		rodtoll Fixes to support Bueg#11677 - Can't use lobby clients that don't hang around
 * 11/30/99     aarono  Fix Multicast Server Send with Protocol
 * 12/09/99		rodtoll	DoProtocolMulticast didn't have a return hr, added it.  
 * 02/08/00		aarono  Mill Bug 130398 leaking in SendAddForwardReply error case.
 * 04/07/00     rodtoll Fixed Bug #32179 - Registering > 1 interface
 * 04/07/00     aarono  Mill Bug 143823: Trap in HandleSessionLost fix bad assumption
 *                       about lock not being dropped in NukeXXX call. (not fixed in Mill/just DX8)
 * 06/26/00     aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 * 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
 *
 ****************************************************************************/

// todo - send fail message on max players

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"

// #define this on to make DIE_PIGGY DEBUG_BREAK();
#undef DIE_PIG
  
// globals to hold buffer for enum players and new player id replies
LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;
LPVOID gpvEnumPlayersHeader;
BOOL gbWaitingForReply=FALSE;
BOOL gbWaitingForEnumReply=FALSE;

#undef DPF_MODNAME
#define DPF_MODNAME	"DoReply"

// called by PacketizeAndSend and ns_handlexxx	
HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion)
{
	DPSP_REPLYDATA rd;
	HRESULT hr;

	if(!dwReplyToVersion){

		if (!this->pSysPlayer)
		{
			DPF(1,"Reply - session not currently open - failing");
			return E_FAIL;
		}
		ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST));
	} else {
		// doing reply for reliability (ACK) 
	}

	// do we need to packetize for reliability?
	if(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE) // quick test
	{
		DWORD dwCommand;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pSendBuffer+this->dwSPHeaderSize));

		if(NeedsReliablePacketize(this, dwCommand, dwReplyToVersion, DPSEND_GUARANTEED)){
			DPF(3,"reply :: message needs reliable delivery - packetizing with reliablility");
			hr = PacketizeAndSendReliable(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
				pvMessageHeader,TRUE);
			return hr;
		}
	}

//	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)); 
	
	// do we need to packetize for size?
	if (dwMessageSize > ((this->pProtocol)?(this->pProtocol->m_dwSPMaxGuaranteed):(this->dwSPMaxMessageGuaranteed)))
	{
		DPF(3,"reply :: message too big - packetizing");
		hr = PacketizeAndSend(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
			pvMessageHeader,TRUE);
		return hr;
	}

    // call sp
    if (this->pcbSPCallbacks->Reply) 
    {
		rd.lpSPMessageHeader = pvMessageHeader;
		rd.lpMessage = pSendBuffer;
		rd.dwMessageSize = dwMessageSize;
		if(this->pSysPlayer){ 
	        rd.idNameServer = this->pSysPlayer->dwID;
	    } else {
			// we need to reply before we know the nameserver for ACKs on reliability.
	    	rd.idNameServer = 0;
	    }
    	rd.lpISP = this->pISP;

	 	hr = CALLSP(this->pcbSPCallbacks->Reply,&rd);    	
    }
	else 
	{
		hr = E_FAIL;
		ASSERT(FALSE); // no callback?
	}

	if (DPERR_SESSIONLOST == hr)
	{
		DPF_ERR(" got session lost back from SP ");
		hr = HandleSessionLost(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hr;

} // DoReply

// When running the directplay protocol, we can't just send the message addressed from 
// a remote player.  This is because the protocol's internal structures for sending to/from
// that player don't exist on this machine.  Instead we wrap the message in a system message
// DPSP_MSG_MULTICASTDELIVER and crack it on the receiver.
HRESULT DoProtocolMulticast(LPDPLAYI_DPLAY this,LPMSG_ASK4MULTICAST pmcast,DWORD dwBufferSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPBYTE pmsg; // multicast message + header
	HRESULT hr;
	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_GROUP pGroupTo;
	DWORD dwCommand = 0;
	DWORD dwVersion;
	DWORD dwMessageSize;
	LPBYTE pbForward;
	DWORD dwForwardSize;

	// SECURITY - verify message bounds

	if((dwBufferSize < sizeof(MSG_ASK4MULTICAST)) || (pmcast->dwMessageOffset >= dwBufferSize)){
		DPF(1,"SECURITY WARN: Invalid multicast message request\n");
		return DPERR_GENERIC;
	}

	pmsg = (LPBYTE)pmcast + pmcast->dwMessageOffset;

	DPF(4,"multicast server routing from player id = %d to group id = %d\n",
		pmcast->idPlayerFrom,pmcast->idGroupTo);
	
	// the embedded message is the size of the total message - the size of the ask4mcast header
	dwMessageSize = dwBufferSize - pmcast->dwMessageOffset;
    hr = GetMessageCommand(this, (LPBYTE)pmsg, dwMessageSize, &dwCommand, &dwVersion);

	pPlayerFrom = PlayerFromID(this,pmcast->idPlayerFrom);
	if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
	{
		DPF(0,"bad player from id = %d\n",pmcast->idPlayerFrom);
		return DPERR_INVALIDPLAYER;
	}
	pGroupTo = GroupFromID(this,pmcast->idGroupTo);
	if (!VALID_DPLAY_GROUP(pGroupTo)) 
	{
		DPF(0,"bad groupto id = %d\n",pmcast->idGroupTo);
		return DPERR_INVALIDGROUP;
	}

	if (DPSP_MSG_CREATEPLAYER == dwCommand)
	{
		// this is a SUPER-HACK!
		// but, it's the only way to get the pvSPHeader through to unpack player without
		// gutting dplay.
		// this makes sure player gets created locally w/ correct header
		// below, this createplayer message will come back to our sysplayer, who
		// will find the player already in the list, and ignore it. sigh. 
		// but, it works...andyco 4/11/97.
		LPMSG_PLAYERMGMTMESSAGE pmgmt=(LPMSG_PLAYERMGMTMESSAGE)pmsg;
		
		if((dwMessageSize < sizeof(MSG_PLAYERMGMTMESSAGE))||
			(pmgmt->dwCreateOffset >= dwMessageSize))
		{
			DPF(1,"SECURITY WARN: Improperly formated createplayer message in MULTICAST wrapper\n");
			return DPERR_GENERIC;
		}
		
		UnpackPlayerAndGroupList(this,(LPBYTE) pmsg + pmgmt->dwCreateOffset,
			dwMessageSize-pmgmt->dwCreateOffset,1,0,pvSPHeader);
	}

	// change the message to MULTICASTDELIVERY
	SET_MESSAGE_COMMAND(pmcast,DPSP_MSG_MULTICASTDELIVERY);
	
	// sp header?
	if (this->dwSPHeaderSize)
	{
		// need to add space at the beginning for sp header		
		dwForwardSize = dwBufferSize + this->dwSPHeaderSize;
		pbForward = DPMEM_ALLOC(dwForwardSize);
		if (!pbForward)
		{
			DPF_ERR("could not send multicast - out of memory");
			return DPERR_OUTOFMEMORY;	
		}	 
		memcpy(pbForward + this->dwSPHeaderSize,(LPBYTE)pmcast,dwBufferSize);

		// put us in "multicast" mode.  when this message comes back to our sp, it will 
		// come in as if it were generated locally.  so, in this mode we know we need 
		// to process the message
		this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
		hr = SendGroupMessage(this,this->pSysPlayer,pGroupTo,dwSendFlags|DPSEND_ASYNC,pbForward,dwForwardSize,FALSE);
		this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
					
		DPMEM_FREE(pbForward);
	}
	else 
	{
		// no need for header - send out received message
		this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
		hr = SendGroupMessage(this,this->pSysPlayer,pGroupTo,dwSendFlags|DPSEND_ASYNC,pmsg,dwMessageSize,FALSE);
		this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
	}

	if (FAILED(hr))
	{
		DPF(0,"multicast server - could not route from player id = %d to group id = %d hr = 0x%08lx\n",
			pmcast->idPlayerFrom,pmcast->idGroupTo,hr);
	}
	
	return hr;	
	
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"
// a client wants us to send a multicast for them
HRESULT DoMulticast(LPDPLAYI_DPLAY this,LPMSG_ASK4MULTICAST pmcast,DWORD dwBufferSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPBYTE pmsg; // multicast message + header
	HRESULT hr;
	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_GROUP pGroupTo;
	DWORD dwCommand = 0;
	DWORD dwVersion;
	DWORD dwMessageSize;
	
	ASSERT(this->pSysPlayer);
	ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(this->lpsdDesc);
	ASSERT(this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER);

	if(this->dwFlags & DPLAYI_DPLAY_PROTOCOL){
		return DoProtocolMulticast(	this, pmcast, dwBufferSize, pvSPHeader, dwSendFlags);
	}

	// SECURITY

	if(dwBufferSize < sizeof(MSG_ASK4MULTICAST) || pmcast->dwMessageOffset >= dwBufferSize)
	{
		DPF(1,"SECURITY WARN: Invalid Multicast message request\n");
		return DPERR_GENERIC;
	}
	
	pmsg = (LPBYTE)pmcast + pmcast->dwMessageOffset;

	DPF(4,"multicast server routing from player id = %d to group id = %d\n",
		pmcast->idPlayerFrom,pmcast->idGroupTo);
	
	// the embedded message is the size of the total message - the size of the ask4mcast header
	dwMessageSize = dwBufferSize - pmcast->dwMessageOffset;
    hr = GetMessageCommand(this, (LPBYTE)pmsg, dwMessageSize, &dwCommand, &dwVersion);
	ASSERT(SUCCEEDED(hr)); // this should not fail

	if (DPSP_MSG_PLAYERMESSAGE == dwCommand)	
	{
		// need to drop the locks here - send expects to be able to go into pending
		// mode...
		LEAVE_DPLAY();
		
		// call send - it will push the bits through the wire for us
		hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pmcast->idPlayerFrom,
			pmcast->idGroupTo,dwSendFlags,pmsg,dwMessageSize);
		
		ENTER_DPLAY();
	}
	else // it's a system message
	{
		LPBYTE pbForward;
		DWORD dwForwardSize;

		// multicast system messages must be signed in a secure session
		if (SECURE_SERVER(this))
		{
			if (!(dwSendFlags & DPSEND_SIGNED))
			{
				DPF_ERR("Warning! unsecure multicast message arrived - dropping message");
				return DPERR_GENERIC;
			}
		}

		pPlayerFrom = PlayerFromID(this,pmcast->idPlayerFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF(0,"bad player from id = %d\n",pmcast->idPlayerFrom);
			return DPERR_INVALIDPLAYER;
		}
		pGroupTo = GroupFromID(this,pmcast->idGroupTo);
		if (!VALID_DPLAY_GROUP(pGroupTo)) 
		{
			DPF(0,"bad groupto id = %d\n",pmcast->idGroupTo);
			return DPERR_INVALIDGROUP;
		}
    
		if (DPSP_MSG_CREATEPLAYER == dwCommand)
		{
			// this is a SUPER-HACK!
			// but, it's the only way to get the pvSPHeader through to unpack player without
			// gutting dplay.
			// this makes sure player gets created locally w/ correct header
			// below, this createplayer message will come back to our sysplayer, who
			// will find the player already in the list, and ignore it. sigh. 
			// but, it works...andyco 4/11/97.
			LPMSG_PLAYERMGMTMESSAGE pmgmt=(LPMSG_PLAYERMGMTMESSAGE)pmsg;
			
			if((dwMessageSize < sizeof(MSG_PLAYERMGMTMESSAGE))||
				(pmgmt->dwCreateOffset >= dwMessageSize))
			{
				DPF(1,"SECURITY WARN: Improperly formated createplayer message in MULTICAST wrapper\n");
				return DPERR_GENERIC;
			}
			
			UnpackPlayerAndGroupList(this,(LPBYTE) pmsg + pmgmt->dwCreateOffset,
				dwMessageSize-pmgmt->dwCreateOffset,1,0,pvSPHeader);
		}
		
		// sp header?
		if (this->dwSPHeaderSize)
		{
			// need to add space at the beginning for sp header		
			dwForwardSize = dwMessageSize + this->dwSPHeaderSize;
			pbForward = DPMEM_ALLOC(dwForwardSize);
			if (!pbForward)
			{
				DPF_ERR("could not send multicast - out of memory");
				return DPERR_OUTOFMEMORY;	
			}	 
			memcpy(pbForward + this->dwSPHeaderSize,(LPBYTE)pmsg,dwMessageSize);
			
			// put us in "multicast" mode.  when this message comes back to our sp, it will 
			// come in as if it were generated locally.  so, in this mode we know we need 
			// to process the message
			this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pbForward,dwForwardSize,FALSE);
			this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
						
			DPMEM_FREE(pbForward);
		}
		else 
		{
			// no need for header - send out received message
			this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pmsg,dwMessageSize,FALSE);
			this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
		}
		
	} // fPlayerMessage
		
	if (FAILED(hr))
	{
		DPF(0,"multicast server - could not route from player id = %d to group id = %d hr = 0x%08lx\n",
			pmcast->idPlayerFrom,pmcast->idGroupTo,hr);
	}
	
	return hr;	
	
} // DoMulticast

//
// put a session lost message in players message q 
// called by HandleSessionLost
HRESULT QSessionLost(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPMESSAGENODE pmsn; // we'll add this node to iplay's list of nodes		
	LPDPMSG_GENERIC pmsg;	
	
	// alloc the messagenode 
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc space for session lost message node");
		return E_OUTOFMEMORY;
	}
	// alloc the actual message	
	pmsg = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pmsg)
	{
		DPF_ERR("could not alloc space for session lost message");
		return E_OUTOFMEMORY;
	}

	// set up the message	
	pmsg->dwType = DPSYS_SESSIONLOST;

	// set up the messagenode
	pmsn->idTo = pPlayer->dwID; 
	pmsn->pMessage = pmsg;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	this->nMessages++;

	// stick this bad news on the front of the list
	pmsn->pNextMessage = this->pMessageList;
	this->pMessageList = pmsn;
	if(!this->pLastMessage){
		this->pLastMessage=pmsn;
	}
	
	ASSERT(pPlayer);

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	return DP_OK;
		
}  // QSessionLost

// 
// we got either a DPSP_MSG_YOUAREDEAD off the wire, 
// or a DPERR_SESSIONLOST from a send or reply
// put a session lost message in all local players q's, print a useful
// debug message
//
HRESULT HandleSessionLost(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer, pNextPlayer;
	LPDPLAYI_GROUP	pGroup, pNextGroup;
	HRESULT hr;

	if (!this->lpsdDesc)
	{
		DPF_ERR("handlesession lost - no session");
		return DP_OK;
	}

	// Notify voice system
	// Leave locks to prevent deadlock
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();

		DVoiceNotify( this, DVEVENT_STOPSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );		
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}
	
	DPF(0,"\n\n");
	DPF(0," DPLAY SESSION HAS BEEN LOST.  ALL ATTEMPTS TO SEND TO REMOTE PLAYERS");
	DPF(0," WILL FAIL.  THIS CAN BE CAUSED BY E.G. MODEM DROPPING, OR NETWORK CONNECTION");
	DPF(0," TIMING OUT.  HAVE A NICE DAY\n\n");
	
	this->dwFlags |= DPLAYI_DPLAY_SESSIONLOST;
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = QSessionLost(this,pPlayer);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayer->pNextPlayer;
	}

	// Now walk the list of players and delete all of the remote players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// If the player is a non-system player & they are remote, delete them
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			NukeNameTableItem(this, pPlayer);
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	// Now walk the list of groups and delete all of the remote groups

ScanGroups:

	pGroup = this->pGroups;
	while(pGroup)
	{
		// Save the next group
		pNextGroup = pGroup->pNextGroup;

		// If the group is remote, delete it
		if (!(pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, (LPDPLAYI_PLAYER)pGroup);
			// Nuke might drop lock, need to go back to beginning and re-scan
			goto ScanGroups;
		}

		// Move to the next group
		pGroup = pNextGroup;
	}

ScanPlayers:
	// Now walk the list of players and delete all of the remote system players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// Now delete the remaining remote system players
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, pPlayer);
			// Nuke might drop lock, need to go back to beginning and re-scan
			goto ScanPlayers;
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	return DP_OK;

} // HandleSessionLost	

// figure out how many groupws w/ shortucts there are in the nametable
DWORD CountShortcuts(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_GROUP pGroup = this->pGroups;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bShortcut;
	DWORD count = 0;  // # of groups w/ subgroups
	 	
	while (pGroup)
	{
		bShortcut = FALSE;
		pSubgroup = pGroup->pSubgroups;
		
		while (pSubgroup && !bShortcut)
		{
			if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// got one ! go onto next group...
				bShortcut = TRUE;
				count++;
			}
			else
			{
				pSubgroup = pSubgroup->pNextSubgroup;				
			}
		} // pSubgroup
		
		pGroup = pGroup->pNextGroup;
	} // pGroup
	
	DPF(3,"found %d groups w/ shortcuts in nametable",count);
	return count;
	
} // CountShortcuts

/*
 **  NS_HandleEnumPlayers	   
 *
 *  CALLED BY: handlmessage
 *
 *  PARAMETERS:  pvSPHeader - header from SP
 *				dpidFrom - security id from requestor
 *				dwVersion - version of requestor
 *
 *  DESCRIPTION:  checks security if necessary. if dwVersion >= DX5, and it's 
 *					not client server, superpacs nametable, else it just packs nametable
 *					and sends it to requestor.
 *
 */
HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion)
{
    HRESULT hr=DP_OK;
    MSG_ENUMPLAYERSREPLY epm;
    LPBYTE pBuffer=NULL,pBufferIndex;
	DWORD dwMessageSize;
    BOOL fSuperPac;
	UINT nNameLength,nPasswordLength;
	
	if (dwVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)) fSuperPac = TRUE;
	else fSuperPac = FALSE;
	
	ASSERT(this);
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);
	
	// call pack w/ null buffer to figure out how big
	if (fSuperPac)
	{
		hr =  SuperPackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
	else 
	{
		hr =  PackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
    if (FAILED(hr)) 
    {
    	ASSERT(FALSE);
		return hr;
    }

	// session name goes w/ nametable
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
#ifdef SEND_PASSWORD	
	// todo - Sohail - need to encrypt this message before we can send
	// password.  for now, we just don't send it
	nPasswordLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
#else 
	nPasswordLength =  0;	
#endif 
	
	// message size + blob size + session name
	dwMessageSize += GET_MESSAGE_SIZE(this,MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

	DPF(2,"sending nametable - total size = %d\n",dwMessageSize);

    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
    	DPF_ERR("could not send player list - out of memory");
        return E_OUTOFMEMORY;
    }

    // epm is the message we want the sp to send
	SET_MESSAGE_HDR(&epm);

	if (fSuperPac)
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_SUPERENUMPLAYERSREPLY);		
		epm.nShortcuts = CountShortcuts(this);
	}
	else 
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_ENUMPLAYERSREPLY);
	}

	if (CLIENT_SERVER(this))
	{
		// pack will only give out app server + sysplayer
		if (this->pServerPlayer) epm.nPlayers =  2;  // nameserver + server player
		else epm.nPlayers =  1; // nameserver only
		epm.nGroups = 0;
	}
	else 
	{
	    epm.nPlayers =  this->nPlayers;
		epm.nGroups = this->nGroups;
		// if we have a sysgroup, we don't send that one...
		if (this->pSysGroup)
		{
			epm.nGroups--;
		}
	}		
	
	// put the session desc offset on
	epm.dwDescOffset = sizeof(MSG_ENUMPLAYERSREPLY);
	// name offsets
	if (nNameLength) epm.dwNameOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2);
	else epm.dwNameOffset = 0;
	// password offsets
	if (nPasswordLength) epm.dwPasswordOffset = sizeof(MSG_ENUMPLAYERSREPLY) 
		+ sizeof(DPSESSIONDESC2) + nNameLength;
	else epm.dwPasswordOffset = 0;

	// the packed structures follow the session name
	epm.dwPackedOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

    // copy the fixed message into  the buffer
    memcpy(pBuffer + this->dwSPHeaderSize,(LPBYTE)&epm,sizeof(MSG_ENUMPLAYERSREPLY));

	// now, pack up the variable size stuff
	pBufferIndex = (LPBYTE)pBuffer + this->dwSPHeaderSize + sizeof(MSG_ENUMPLAYERSREPLY);
	
	// put the session desc on
	memcpy(pBufferIndex,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// set string pointers to NULL - they must be set at client
	((LPDPSESSIONDESC2)pBufferIndex)->lpszPassword = NULL;
	((LPDPSESSIONDESC2)pBufferIndex)->lpszSessionName = NULL;

	pBufferIndex += sizeof(DPSESSIONDESC2);
	
	// next, name
	if (nNameLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		pBufferIndex += nNameLength;
	}

	// next, password
	if (nPasswordLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszPassword,nPasswordLength);
		pBufferIndex += nPasswordLength;
	}

	// pack the players behind the password
	if (fSuperPac)
	{
		hr = SuperPackPlayerAndGroupList( this, pBufferIndex ,&dwMessageSize) ;
	}
	else 
	{
		hr = PackPlayerAndGroupList( this, pBufferIndex, &dwMessageSize) ;
	}			
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // if session is secure, use send
    if (this->lpsdDesc && (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
            ASSERT(FALSE);  // should never happen because we just verified the sig
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);
    }
    else
    {
    	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);
    }

	DPMEM_FREE(pBuffer);
    return hr;

} // handle enum players

// sends an error response to an addforward message
HRESULT NS_SendAddForwardReply(LPDPLAYI_DPLAY this, HRESULT hResult, LPVOID pvSPHeader, DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
    LPMSG_ADDFORWARDREPLY pReply;

    // 
    // Calculate buffer size needed for response
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDREPLY);
    //
    // Allocate memory for the buffer
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pReply = (LPMSG_ADDFORWARDREPLY) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply, DPSP_MSG_ADDFORWARDREPLY);
    pReply->hResult = hResult;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			hr = DPERR_INVALIDPLAYER;
			goto err_exit;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_SYSMESS,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader, dwVersion);
	}

err_exit:
    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

    return hr;
} // NS_SendAddForwardReply

// this function verifies if the client can join the session
// also verifies TickCount on session, some work here is for interop with previous beta versions of DX6
HRESULT NS_IsOKToJoin(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwBufferSize, DWORD dwJoinerVersion)
{
	DWORD *pTickCount;
	BOOL  fCheckTickCount=TRUE;
	LPMSG_PLAYERMGMTMESSAGE pMsg;

	// SECURITY: Validate input buffer before processing START

	if(dwBufferSize < sizeof(MSG_PLAYERMGMTMESSAGE))
	{
		DPF(1,"SECURITY WARN: buffer on player management message too small\n");
		return DPERR_NONEWPLAYERS;
	}

	pMsg = (LPMSG_PLAYERMGMTMESSAGE)(pReceiveBuffer);

	if(pMsg->dwPasswordOffset){
		if(pMsg->dwPasswordOffset > (DWORD)(dwBufferSize-2))
		{	
			DPF(1,"SECURITY WARN: invalid password offset on player management message\n");
			return DPERR_NONEWPLAYERS;
		}
	}
	
	// SECURITY: Validation END

    // if session has a password and it is not a zero-length string
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        LPWSTR lpszPassword;
        DWORD cbSessionPassword;

		DPF(5,"Verifying Password\n");

        if (!pMsg->dwPasswordOffset)
        {
            DPF(0, "nameserver denying access - no password specified");
            return DPERR_INVALIDPASSWORD;
        }

		//count bytes in the session password (NULL included in count)
		cbSessionPassword = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);

		ASSERT(cbSessionPassword >= 2);

		// Force NULL termination of input password
		pReceiveBuffer[pMsg->dwPasswordOffset+cbSessionPassword-1]=0;
		pReceiveBuffer[pMsg->dwPasswordOffset+cbSessionPassword-2]=0;

		lpszPassword = (WCHAR *)&pReceiveBuffer[pMsg->dwPasswordOffset];
				
        // match passwords
        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
        {
            DPF(0, "nameserver denying access - password doesn't match");
            return DPERR_INVALIDPASSWORD;
	    }
	    // tick count after password
	    pTickCount=(PUINT)(lpszPassword+WSTRLEN(lpszPassword));

		DPF(5,"pPassword = %x, pTickCount= %x\n",lpszPassword, pTickCount);
	    
    } else {
    	// expect NULL password followed by TickCount
    	if(((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset){
	    	pTickCount=(PUINT)(pReceiveBuffer + dwBufferSize - 4);
			DPF(5,"Didn't verify password, pTickCount= %x\n", pTickCount);
	    } else {
	    	fCheckTickCount=FALSE;
	    }

    }

	if(fCheckTickCount && dwJoinerVersion >= DPSP_MSG_DX6VERSION){
		// only verify DX6 or later and only if the buffer is big enough to have the tickcount.
		if(pReceiveBuffer+dwBufferSize >= (PUCHAR)(pTickCount+1)){
			if(this->lpsdDesc->dwReserved1 != *pTickCount){
				DPF(0,"Client trying to join old session, returning DPERR_NONEWPLAYERS\n");
				return DPERR_NONEWPLAYERS;
			}
		}
	}

    // verify permissions based on player flags
    if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
    {
	    DPF(0,"nameserver denying access - session is not allowing join");
	    return DPERR_NONEWPLAYERS;
    }

    if (this->lpsdDesc->dwMaxPlayers && 
        (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers))
    {
        DPF(0,"nameserver denying access - session maxed out");
        return DPERR_NONEWPLAYERS;
    }

    return DP_OK;

} // IsOKToJoin

HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList,pnodePrev = NULL;
	
	// first, find the node
	while (pnodeSearch && !bFound)
	{
		if (pnodeSearch == pnodeFind) bFound = TRUE;
		else 
		{
			pnodePrev = pnodeSearch;
			pnodeSearch = pnodeSearch->pNextNode;
		}
	}
	
	if (!bFound)	
	{
		ASSERT(bFound); // false!
		// BUMMER! this is badbadbad
		return E_FAIL; // good ol' E_FAIL
	}
	
	// remove node from list
	if (pnodePrev) 
	{
		// remove from middle
		pnodePrev->pNextNode = pnodeSearch->pNextNode; 
	}
	else
	{
		// remove from head
		ASSERT(this->pAddForwardList == pnodeSearch);
		this->pAddForwardList = this->pAddForwardList->pNextNode;
	} 
	
	// free up the node
	if (VALID_SPHEADER(pnodeSearch->pvSPHeader)) DPMEM_FREE(pnodeSearch->pvSPHeader);
	DPMEM_FREE(pnodeSearch);
	
	return DP_OK;
		
} // FreeAddForwardNode

BOOL IsAddForwardNodeOnList(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList;
	
	while(pnodeSearch){
		if(pnodeSearch == pnodeFind){
			return TRUE;
		}
		pnodeSearch=pnodeSearch->pNextNode;
	}
	return FALSE;
}

// start up an async add forward
HRESULT NS_DoAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPVOID pvSPHeader,
	 DPID dpidFrom,DWORD dwVersion)
{
	HRESULT hr;
	LPADDFORWARDNODE pnode;
	DWORD dwTimeout; // how long we wait before giving up on ack's
	DWORD dwPlayerID;
	
	pnode = DPMEM_ALLOC(sizeof(ADDFORWARDNODE));
	if (!pnode)
	{
		DPF_ERR("could not start async add forward - out of memory!!");
		return DPERR_OUTOFMEMORY;
	}
	
	// store the spheader for when we eventually send the nametable
	if (this->dwSPHeaderSize)
	{
		pnode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pnode->pvSPHeader)
		{
			DPF_ERR("could not start async add forward - out of memory!!");
			DPMEM_FREE(pnode);
			return DPERR_OUTOFMEMORY;
		}
		if (pvSPHeader)
		{
			memcpy(pnode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		}
	}
				
	// stick new node on the front of the list
	pnode->pNextNode = this->pAddForwardList;
	this->pAddForwardList = pnode;

	dwPlayerID=pPlayer->dwID;
	
	pnode->dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	pnode->dpidFrom = dpidFrom;
	pnode->dwVersion = dwVersion;

	if(pPlayer->dwIDSysPlayer == dwPlayerID){
		DPF(6,"Player x%x doesn't have nametable, sends will fail idFrom=%x.\n",pPlayer->dwID, dpidFrom);
		pPlayer->dwFlags |= DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE;
	}	
	
	hr = SendAsyncAddForward(this,pPlayer,pnode);
	if (FAILED(hr))	
	{
		ASSERT(FALSE);
	}

	// pnode could be invalid (may have already got ACKs and cleared it out),
	// so we need to make sure it is still in the nodelist (i.e. valid).

	if(!IsAddForwardNodeOnList(this,pnode)){
		goto EXIT;
	}
	
	// if we don't need any ack's, send the nametable...
	if (0 == pnode->nAcksReq)
	{
		pPlayer=PlayerFromID(this,dwPlayerID);
		if (pPlayer == NULL)
		{
			goto EXIT;
		}
		
		if(pPlayer->dwIDSysPlayer == dwPlayerID){
			pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
		}	
		
	    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
		hr = FreeAddForwardNode(this,pnode);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	else 
	{
		// get the worker thread to keep on eye on this node.  so, if a client doesn't ack, eventually
		// we give up and just send the new client the nametable...

		// we multiply GetDefaultTimeout * the number of req's we sent, since we have to wait
		// for a reply from each of them 
		dwTimeout = DP_NAMETABLE_SCALE * GetDefaultTimeout(this,TRUE);
		if(dwTimeout > 15000){
			dwTimeout = 15000;
		}
		DPF(3,"waiting for add forward.  nAcksReq = %d, timeout = %d\n",pnode->nAcksReq,dwTimeout);
		// after this tick count, we give up + send the nametable
		pnode->dwGiveUpTickCount = GetTickCount() + dwTimeout; 

		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	
EXIT:			
	return DP_OK;
	
} // NS_DoAsyncAddForward

// a player is going to join the game.  they want the name server to tell the world they exist
// so they will be able to process any messages that occur between when we package the nametable
// and they receive it
HRESULT NS_HandleAddForwardRequest(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwBufferSize,
	LPVOID pvSPHeader, DPID dpidFrom)
{
	HRESULT hr;
    DWORD dwVersion;
    LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayer = NULL; // our version of new player
	DPID id;
		
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    if (dwVersion >= DPSP_MSG_DX5VERSION)
    {
        // verify client can join the session
        hr = NS_IsOKToJoin(this, pReceiveBuffer, dwBufferSize, dwVersion);
        if (FAILED(hr))
        {
        	if (this->dwPlayerReservations > 0)
        		this->dwPlayerReservations--;
			goto ERROR_EXIT;
        }
    } // dwVersion 

	// SECURITY - new parameter validation START

	// verify buffer is large enough to be a system message.

	if(dwBufferSize < sizeof(MSG_PLAYERMGMTMESSAGE)){
		DPF(1,"SECURITY WARN: invalid size on player management message\n");
		hr = E_FAIL;
		goto ERROR_EXIT;
	}

	if(pmsg->dwCreateOffset > dwBufferSize){
		DPF(1,"SECURITY WARN: invalid createOffset in AddForward request\n");
		hr = E_FAIL;
		goto ERROR_EXIT;
	}

	// SECURITY - new parameter validation END


	// reset the command to create player 
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_CREATEPLAYER);

	// get the new player out of the message  - note we can't let sendsystemmessage do this
	// for us, since we can't get the correct sp header if we do it that way
	hr=UnpackPlayerAndGroupList(this,pReceiveBuffer+pmsg->dwCreateOffset,dwBufferSize-pmsg->dwCreateOffset,1,0,pvSPHeader);
	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	// tell the world about the new player		
	// note - we can't just forward the message we received, since the player would be "homed" wrong
	// instead, we pack up our version of the player, which has the correct net address set
	// and send that to the world
	id = pmsg->dwPlayerID;
	pPlayer = PlayerFromID(this,id);
	if (!VALID_DPLAY_PLAYER(pPlayer))
	{
		ASSERT(FALSE);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}

	// if all clients in the game can handle the async addforward, do that
	// 
	if (this->dwMinVersion >= DPSP_MSG_ASYNCADDFORWARD)
	{
		hr = NS_DoAsyncAddForward(this,pPlayer,pvSPHeader,dpidFrom, dwVersion);
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
	}
	else
	{
		// else we have to do it the old way
		// there is a race condition which could cause simultaneous joins bugs...
		hr = SendCreateMessage( this, pPlayer,TRUE, NULL);	
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
		
	    // from DPSP_MSG_AUTONAMETABLE onwards, nameserver will automatically respond with the nametable if client
	    // is dx5 or greater
	    if (dwVersion >= DPSP_MSG_AUTONAMETABLE)
	    {
	        hr = NS_HandleEnumPlayers(this, pvSPHeader, dpidFrom,dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	    }
		
	}

	return DP_OK;

ERROR_EXIT:

	DPF_ERRVAL("could not process add forward - hr = 0x%08lx\n",hr);

    hr = NS_SendAddForwardReply(this,hr,pvSPHeader,dpidFrom, dwVersion);
    if (FAILED(hr))
    {
       // if this happens, client won't get a response and will timeout
	    DPF(0, "Couldn't send access denied message: hr = 0x%08x", hr);
    }

    // remove id from nametable
    if(pPlayer){
    	NukeNameTableItem(this, pPlayer);
    } else {
	    hr = FreeNameTableEntry(this, ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	}    
    if (FAILED(hr))
    {
	    DPF(0, "Couldn't delete nametable entry for %d: hr = 0x%08x",
            ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID, hr);
    }
	
	return hr;
	
} // NS_HandleAddForwardRequest

// we got an addforward from the nameserver.  send an ack, then unpack the player
HRESULT  SP_HandleAddForward(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer, DWORD dwMessageSize,
	LPVOID pvSPHeader,DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
	LPMSG_ADDFORWARDACK pAck;
	LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;

	// SECURITY
	if(dwMessageSize < sizeof(MSG_PLAYERMGMTMESSAGE)){
		DPF(1,"SECURITY WARN: ADDFORWARD invalid message size");
		return DPERR_GENERIC;
	}

    DPF(2,"got add forward announcment for id = %d",pmsg->dwPlayerID); 
	
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDACK);
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for addforward ack - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pAck = (LPMSG_ADDFORWARDACK) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pAck);
    SET_MESSAGE_COMMAND(pAck, DPSP_MSG_ADDFORWARDACK);
    pAck->dwID = pmsg->dwPlayerID;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_GUARANTEED | DPSEND_ASYNC,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader,dwVersion);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

	// finally, unpack the new player by resetting DPMSG_ADDFORWARD to DPMSG_CREATEPLAYER
	// and calling handleplayermgmt
    SET_MESSAGE_COMMAND(pmsg, DPSP_MSG_CREATEPLAYER);
	hr = SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwMessageSize,pvSPHeader);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;
	
} // SP_HandleAddForward

// we got an ack for one of our addforwad's
HRESULT NS_HandleAddForwardACK(LPDPLAYI_DPLAY this,LPMSG_ADDFORWARDACK pAck, DWORD dwMessageSize)
{
	HRESULT hr;
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	LPDPLAYI_PLAYER pPlayer;

	// SECURITY
	if(dwMessageSize < sizeof(MSG_ADDFORWARDACK))
	{
		DPF(1,"SECURITY WARN: Invalid addforward ACK");
		return DPERR_GENERIC;
	}
	
	// first, find the node
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pAck->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	if (!bFound)	
	{
		// it's possible we gave up waiting on this ack, and just sent the nametable.
		return DP_OK;
	}

	// bump the ack count
	pnode->nAcksRecv++;

    DPF(2,"got add forward ack # %d of %d required for player id = %d",pnode->nAcksRecv,pnode->nAcksReq,pAck->dwID); 
	
	if (pnode->nAcksRecv != pnode->nAcksReq) return DP_OK;
	
	// else, we got 'em all!!
	// send the nametable, and free up the node
	pPlayer=PlayerFromID(this, pnode->dwIDSysPlayer);
	if(pPlayer){
		pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
	}
    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	hr = FreeAddForwardNode(this,pnode);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;	
		
	
} // NS_HandleAddForwardACK

HRESULT NS_HandleEnumSessions(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,LPBYTE pReceiveBuffer, DWORD dwBufferSize, DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_ENUMSESSIONSREPLY perm; 
    LPMSG_ENUMSESSIONS pEnumRequest = (LPMSG_ENUMSESSIONS)pReceiveBuffer;
    DWORD dwMessageSize;
	LPBYTE pIndex;
	UINT nNameLength;
	LPBYTE pBuffer;
    DWORD dwVersion;
    LPWSTR lpszPassword;

	ASSERT(this);
	ASSERT(this->lpsdDesc);
    ASSERT(pReceiveBuffer);

	//
	// SECURITY: New Parameter Validation START
	//
	if(dwBufferSize < sizeof(MSG_ENUMSESSIONS)){
		DPF(1,"SECURITY WARN: invalid enumsessions received, buffer too small\n");
		return FALSE;
	}

	// password if present must be NULL terminated, DBCS, may just be NULL
	if(pEnumRequest->dwPasswordOffset){
		if(pEnumRequest->dwPasswordOffset > (DWORD)(dwBufferSize-2)){
			DPF(1,"SECURITY WARN: invalid password offset in EnumSession request.\n");		
		}
		// we just guarantee we will hit a NULL while checking the password by zeroing out
		// the last 2 bytes of the message buffer (a UNICODE NULL).
		pReceiveBuffer[dwBufferSize-1] = 0;
		pReceiveBuffer[dwBufferSize-2] = 0;
	}
	// SECURITY: New Parameter Vaidation END
	

	// check if they specified a guid
	if (!IsEqualGUID(&(pEnumRequest->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(pEnumRequest->guidApplication),&(this->lpsdDesc->guidApplication))) 
		{
            DPF(2, "nameserver not responding - guid doesn't match");
			return FALSE;
		}
	}

    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

	// make sure the password on the received buffer matches our password
	// only check if they have a password, and it's not just the null terminator
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        //
        // we verify the password, if client is DX3 or 
        // client is DX5 or later, but didn't request passworded sessions or
        // session is private 
        // 
        if ((DPSP_MSG_DX3VERSION == dwVersion) || 
            !(pEnumRequest->dwFlags & DPENUMSESSIONS_PASSWORDREQUIRED) || 
            (this->lpsdDesc->dwFlags & DPSESSION_PRIVATE)) 
        {   
	        // if no password is specified
            if (0 == pEnumRequest->dwPasswordOffset)
            {
                DPF(2, "nameserver not responding - no password specified");
                return FALSE;
            }

            // point to the password in the request
            lpszPassword = (LPWSTR)((LPBYTE)pEnumRequest + pEnumRequest->dwPasswordOffset);

            // if password doesn't match
	        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
            {
                DPF(2, "nameserver not responding - password doesn't match");
                return FALSE;
	        }
        }
    }

    // if DPENUMSESSIONS_ALL flag is specified ignore the following checks.
    // look for the flags only if the client is DX5 or greater
    if ((dwVersion >= DPSP_MSG_DX5VERSION) && !(pEnumRequest->dwFlags & DPENUMSESSIONS_ALL))
    {
	    // don't reply if session is maxed out
	    if ((this->lpsdDesc->dwMaxPlayers) && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
        {
            DPF(2, "nameserver not responding - session maxed out");
            return FALSE;
	    }
	    
	    // don't reply if session is not allowing new players
	    if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing new players");
            return FALSE;
        }
	    
        // don't reply if if session is not allowing join
        if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing join");
            return FALSE;
        }
    }

	if (dwVersion < DPSP_MSG_DX6VERSION)
	{
		// if we're running the protocol, do not respond to pre-DX6 people
		if (this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)
		{
            DPF(2, "nameserver not responding - protocol prevents < DX6");
            return FALSE;
		}
	}
	
    // now send the enumsessions reply
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  nNameLength ;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	perm = (LPMSG_ENUMSESSIONSREPLY)(pBuffer + this->dwSPHeaderSize);

	// perm is the buffer we want the sp to send
	SET_MESSAGE_HDR(perm);
    SET_MESSAGE_COMMAND(perm,DPSP_MSG_ENUMSESSIONSREPLY);

    // if we receive an unsecure enumsessions request and the session is secure
    // we respond with only the public information in the session desc
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && 
        !(dwSendFlags & DPSEND_SIGNED))
    {
        perm->dpDesc.dwSize = this->lpsdDesc->dwSize;
        perm->dpDesc.dwFlags = DPSESSION_SECURESERVER;
        perm->dpDesc.guidInstance = this->lpsdDesc->guidInstance;
        perm->dpDesc.guidApplication = this->lpsdDesc->guidApplication;
        perm->dpDesc.dwReserved1 = this->lpsdDesc->dwReserved1;
    }
    else
    {
        // ok to send the entire session desc
        perm->dpDesc =  *(this->lpsdDesc);
    }

	// pack strings on end
	pIndex = (LPBYTE)perm+sizeof(MSG_ENUMSESSIONSREPLY);
	if (nNameLength) 
	{
		memcpy(pIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		perm->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	perm->dpDesc.lpszPassword = NULL;
	perm->dpDesc.lpszSessionName = NULL;

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

	DPMEM_FREE(pBuffer);

    return hr;

} // NS_HandleEnumSessions



HRESULT NS_SendIDRequestErrorReply(LPDPLAYI_DPLAY this, LPVOID pvSPHeader,
		HRESULT hrError, DWORD dwVersion)
{
	LPBYTE					pBuffer = NULL;
	LPMSG_PLAYERIDREPLY		prm = NULL;
	DWORD					dwMessageSize;
	HRESULT					hr;


	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return DPERR_OUTOFMEMORY;
	}

	// Setup the header
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm, DPSP_MSG_REQUESTPLAYERREPLY);
	prm->hr = hrError;

	// Send the reply
	hr = DoReply(this, pBuffer, dwMessageSize, pvSPHeader, dwVersion);

	// Free the buffer
	DPMEM_FREE(pBuffer);

	return hr;

} // NS_SendIDRequestErrorReply



HRESULT NS_HandleRequestPlayerID(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DWORD dwCommand, DWORD dwFlags, 
                                 BOOL fCheckPlayerFlags, DWORD dwVersion)
{
    HRESULT hr = DP_OK;
 	DWORD dwMessageSize, dwSSPIProviderSize=0, dwCAPIProviderSize=0, dwID=0;
	LPBYTE pBuffer;
    BOOL fSendSecurityDesc=FALSE;
    LPMSG_PLAYERIDREPLY prm;

	ASSERT(this);
	ASSERT(this->lpsdDesc);

	// if it's a player id, check dwmax players
	if (DPSP_MSG_REQUESTPLAYERID == dwCommand)
	{
        if (fCheckPlayerFlags)
        {
            // verify permissions based on player flags
            if ((this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
                ((dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
                 (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)))
            {
			    DPF(1,"not giving out new id - session is not allowing new players");
				
				// If the client is DX6 or greater, we want to send an
				// error back to them.  If it's pre-DX6, we will just fail
				// and let the client timeout so we preserve backward compatibility
				if(dwVersion >= DPSP_MSG_DX6VERSION)
				{
					hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
				}
			    return hr;
            }
        }

		// a-josbor: be sure to count reservations, too!
        if (this->lpsdDesc->dwMaxPlayers && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
		{
			DPF(1,"not giving out new id - too many players");

			// If the client is DX6 or greater, we want to send an
			// error back to them.  If it's pre-DX6, we will just fail
			// and let the client timeout so we preserve backward compatibility
			if(dwVersion >= DPSP_MSG_DX6VERSION)
			{
				hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
			}
			return hr;
		}
	}

    // if session is secure and request is for system player id, send security package name
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        fSendSecurityDesc = TRUE;
    }

    if (fSendSecurityDesc)
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
        dwSSPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszSSPIProvider);
        dwCAPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszCAPIProvider);
        dwMessageSize += dwSSPIProviderSize + dwCAPIProviderSize;
    }
    else
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
    }

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

    // get a new id
    hr = NS_AllocNameTableEntry(this,&dwID);
	if (FAILED(hr)) 
	{
		DPF_ERR("namesrvr- could not alloc new player id");
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // prm is the buffer we want the sp to send
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm,DPSP_MSG_REQUESTPLAYERREPLY);
    prm->dwID = dwID;

    // setup the message
    if (fSendSecurityDesc)
    {
		// copy the current security descrption into the message buffer
		memcpy(&prm->dpSecDesc, this->pSecurityDesc, sizeof(DPSECURITYDESC));

		// setup offsets to provider strings
		if (this->pSecurityDesc->lpszSSPIProvider)
		{
	        prm->dwSSPIProviderOffset = sizeof(MSG_PLAYERIDREPLY);
		    // copy strings at the end of the message
            memcpy((LPBYTE)prm+prm->dwSSPIProviderOffset, 
                this->pSecurityDesc->lpszSSPIProvider, dwSSPIProviderSize);
		}
	
		if (this->pSecurityDesc->lpszCAPIProvider)
		{
			prm->dwCAPIProviderOffset = sizeof(MSG_PLAYERIDREPLY) + dwSSPIProviderSize;
            memcpy((LPBYTE)prm+prm->dwCAPIProviderOffset, 
                this->pSecurityDesc->lpszCAPIProvider, dwCAPIProviderSize);
		}

    }

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

//	a-josbor: we successfully handed out a player id. Increment the reservation count now
//	to avoid letting too many players in under race conditions
	if (!FAILED(hr))
	{
		this->dwPlayerReservations++;
		this->dwLastReservationTime = GetTickCount();
	}
	
	DPMEM_FREE(pBuffer);
    return hr;

}// NS_HandleRequestPlayerID


#undef DPF_MODNAME
#define DPF_MODNAME	"TransferGroupsToNameServer"

// a system player has been deleted
// make any groups owned by that system player be owned by the nameserver
HRESULT TransferGroupsToNameServer(LPDPLAYI_DPLAY this,DPID idSysPlayer)
{
	LPDPLAYI_GROUP lpGroup;

	if (!this->pNameServer)	return E_FAIL;
	
	lpGroup = this->pGroups;
	
	while (lpGroup)
	{
		if (lpGroup->dwIDSysPlayer == idSysPlayer)
		{
			ASSERT(this->pNameServer);

			// idSysPlayer is history
			// make group owned by name server
			DPF(2,"transferring ownership of group id = %d from sysplayer id = %d to nameserver id = %d\n",
				lpGroup->dwID,idSysPlayer,this->pNameServer->dwID);
				
			lpGroup->dwIDSysPlayer = this->pNameServer->dwID;
		}
		lpGroup = lpGroup->pNextGroup;
	}

	return DP_OK;
	
} // TransferGroupsToNameServer

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_HandlePlayerMgmt"

// we got a system message off the wire
// put a message in the q fo all local players 
HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize)
{
	HRESULT hr;
	LPDPLAYI_PLAYER	pPlayer;
	
	pPlayer = this->pPlayers; 
	
	while (pPlayer)
	{
		// only distribute it to local non-system players
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,FALSE,0);
			if (FAILED(hr))
			{
				DPF_ERRVAL("could not handle player system message hr = 0x%08lx\n",hr);
			}
		}
		pPlayer = pPlayer->pNextPlayer;
	}
	
	return DP_OK;
			
} // DistributeSystemMessage

// tell pvSPHeader to go away
void SendDiePiggy(LPDPLAYI_DPLAY this,LPVOID pvSPHeader)
{
	LPMSG_SYSMESSAGE pmsg;
	LPBYTE pBuffer;
	DWORD dwMessageSize;
	
    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
	    DPF_ERR("could not send die piggy - out of memory");
	    return;
    }

    // pmsg follows sp blob
    pmsg = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

    // build a message to send to the sp
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_DIEPIGGY);
	
	DoReply(this,pBuffer,dwMessageSize,pvSPHeader,0);
	
	return ;
	
} // SendDiePiggy

/*
 ** SP_HandlePlayerMgmt
 *
 *  CALLED BY:	DPlay_HandleSPMessage
 *
 *  PARAMETERS:
 *				pPlayer - player that received the message (sysplayer)
 *				pReceiveBuffer - message that was received
 *
 *  DESCRIPTION:
 *				our sysplayer got a state changed message off the wire. process it,
 *				and tell all local players
 *
 *  RETURNS: corresponding idirectplay hr
 *
 */

HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) 
{
    HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	DWORD dwCmd;
	BOOL bDistribute = TRUE; // when deleting a player or group, we need to
							// build the player message b4 it's gone.  this flag
							// tells us not to do it twice
			 
	if (!pPlayer)
	{
		DPF_ERR("got system message, but don't have a system player ACK ACK ACK");

#ifdef DIE_PIG
		DPF_ERRVAL("sending DIE PIGGY.  sayonara sucker pvSPHeader = 0x%08lx",pvSPHeader);
		SendDiePiggy(gpObjectList,pvSPHeader);
		DEBUG_BREAK();
#endif 		

		ASSERT(FALSE);
		return E_FAIL;
	}
	
	if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)){
		DPF(0,"Player %x is a sysplayer that is going away, rejecting system message\n",pPlayer);
		return E_FAIL;
	}
	
	this = pPlayer->lpDP;

	// SECURITY - we know its ok to examine the command field since it was already
	//            examined in order to get dispatched to here.

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	dwCmd = GET_MESSAGE_COMMAND(pmsg);

	// if it's remote or we're not handling a multicast, we don't need to process the message
	if ((DPSP_HEADER_LOCALMSG != pvSPHeader) || (this->dwFlags & DPLAYI_DPLAY_HANDLEMULTICAST))
	{
		// We want the default hresult to be DPERR_GENERIC so that we don't send
		// the message unless the processing is successful.
		hr = DPERR_GENERIC;
		
		switch (dwCmd)
		{
			case DPSP_MSG_DELETEPLAYER: 
			{
				BOOL bNameSrvr=FALSE; // used to indicate name srvr going away 
				BOOL bSysPlayer=FALSE; // set to TRUE if we're nuking a system player
				LPDPLAYI_PLAYER pDeletedPlayer;
				DPID idSysPlayer;  // the id of the deleted system player

				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwGroupID)){
					DPF(1,"SECURITY WARN: DELETEPLAYERMESSAGE not big enough\n");
					return DPERR_GENERIC;
				}

				DPF(4, "Got DPSP_MSG_DELETEPLAYER for %d.", pmsg->dwPlayerID);
				
				pDeletedPlayer = PlayerFromID(this,pmsg->dwPlayerID);
		        if (!VALID_DPLAY_PLAYER(pDeletedPlayer)) 
		        {
					DPF_ERR("bad player id!!");
//					ASSERT(FALSE);
					return DPERR_INVALIDPARAMS; // bail!
		        }				

				#define DPLAYI_PLAYER_LOCALAPPSERVER (DPLAYI_PLAYER_APPSERVER|DPLAYI_PLAYER_PLAYERLOCAL)
				// seems like a remote is trying to delete the app server.
				if((pDeletedPlayer->dwFlags & DPLAYI_PLAYER_LOCALAPPSERVER)==DPLAYI_PLAYER_LOCALAPPSERVER)
				{
					DPF_ERR("remote trying to delete local appserver player, not allowed!!!!\n");
					return DPERR_INVALIDPARAMS;
				}
				#undef DPLAYI_PLAYER_LOCALAPPSERVER

				if (DPLAYI_PLAYER_SYSPLAYER & pDeletedPlayer->dwFlags) 
				{
					// if it's the name srvr, we want to deal w/ it after we delete
					// it from the table
					if (DPLAYI_PLAYER_NAMESRVR & pDeletedPlayer->dwFlags) bNameSrvr = TRUE;
					bSysPlayer = TRUE;				
					idSysPlayer = pDeletedPlayer->dwID; // we may need this below to take ownership of its groups		
				}
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;
				
				hr = InternalDestroyPlayer(this,pDeletedPlayer,FALSE,TRUE);	
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				
				// if a sysplayer was nuked, and there was no DX3 in the game, we can reassign
				// the sysplayers group to the current name server.  if there is dx3 in the game,
				// we don't know the id of the new name server yet
				if (bSysPlayer & !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
				{
					TransferGroupsToNameServer(this,idSysPlayer);
				}

				
				break;
			} // case dpsp_msg_deleteplayer

			case DPSP_MSG_CREATEPLAYER:
			case DPSP_MSG_CREATEPLAYERVERIFY:
			{
				LPDPLAYI_PLAYER pNewPlayer;
				LPMSG_PLAYERMGMTMESSAGE pmgmt=(LPMSG_PLAYERMGMTMESSAGE)pmsg;
				
				// Need to set the hresult to DP_OK so we send the message
				hr = DP_OK;

				if(dwMessageSize < sizeof(MSG_PLAYERMGMTMESSAGE))
				{
					DPF(1,"SECURITY WARN: Invalid createplayer or verify message\n");
					hr=DPERR_GENERIC;
					break;
				}

				SET_MESSAGE_COMMAND_ONLY(pmsg,DPSP_MSG_CREATEPLAYER);
				// make sure player's not already in our nametable
				// this will happen e.g. on an addforward
				pNewPlayer = PlayerFromID(this,pmsg->dwPlayerID);
				if (!VALID_DPLAY_PLAYER(pNewPlayer))
				{
					if(pmgmt->dwCreateOffset >= dwMessageSize){
						DPF(1,"SECURITY WARN: Invalid CreatePlayer message\n");
						hr=DPERR_GENERIC;
						break;
					}
					// get the new player out of the message 
					hr = UnpackPlayerAndGroupList(this,pReceiveBuffer + 
						pmgmt->dwCreateOffset,dwMessageSize-pmgmt->dwCreateOffset,1,0,pvSPHeader);

					// if this is the nameserver, clear the nonameserver flag
					pNewPlayer = PlayerFromID(this,pmsg->dwPlayerID);
					if(VALID_DPLAY_PLAYER(pNewPlayer) && pNewPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR){
						this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
						LEAVE_DPLAY();

						DVoiceNotify(this,DVEVENT_MIGRATEHOST,PlayerIDFromSysPlayerID(this,pmsg->dwPlayerID),0,DVTRANSPORT_OBJECTTYPE_BOTH );						
						
						ENTER_ALL();
						
						TRY 
						{
						
							hr = VALID_DPLAY_PTR( this );
							
							if (FAILED(hr))	{
								LEAVE_SERVICE();
								return hr;
						    }
						    
						} 
						EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
					        DPF_ERR( "Exception encountered validating parameters" );
					        LEAVE_SERVICE();
					        return DPERR_INVALIDPARAMS;
						}
						
						LEAVE_SERVICE();
					}

					// Only DoCreateVerify if we aren't the nameserver (not necessary in this case), see DoCreateVerify for details.
					// We also only do it when being notified of non-sysplayer creation.
					pNewPlayer=PlayerFromID(this,pmsg->dwPlayerID);
					if(  VALID_DPLAY_PLAYER(pNewPlayer) &&
						!(pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
						!(this->pSysPlayer && (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)) && 
						(dwCmd == DPSP_MSG_CREATEPLAYER)){
						// Have DPLAY() lock
						DoCreateVerify(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
					}
					// Note: we are going to distribute the creation message because this guy was NOT
					//      in the original nametable download (regardless of Verify or Create Message).
				} else {
					if(!(this->dwFlags & DPLAYI_DPLAY_HANDLEMULTICAST)){
						bDistribute=FALSE;
					}	
				}
				break;
			}
				
			case DPSP_MSG_DELETEGROUP:
			{
				LPDPLAYI_GROUP pGroup;

				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE,dwCreateOffset)){
					DPF(1,"SECURITY WARN: delete player message too small\n");
					return DPERR_GENERIC;
				}
				
		        pGroup = GroupFromID(this,pmsg->dwGroupID);
		        if (!VALID_DPLAY_GROUP(pGroup)) 
		        {
					DPF_ERR("could not delete group - invalid group id");
		            return DPERR_INVALIDGROUP;
		        }
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;

				hr = InternalDestroyGroup(this,pGroup,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}

				break;
			}

			case DPSP_MSG_CREATEGROUP: 
			{
				LPMSG_PLAYERMGMTMESSAGE pmgmt = (LPMSG_PLAYERMGMTMESSAGE)pmsg;
				if(dwMessageSize < sizeof(MSG_PLAYERMGMTMESSAGE) || pmgmt->dwCreateOffset >= dwMessageSize)
				{
					DPF(1,"SECURITY WARN: Invalid creategroup message\n");
					hr=DPERR_GENERIC;
					break;
				}

				// get the new group out of the message 
				hr = UnpackPlayerAndGroupList(this,pReceiveBuffer +
					pmgmt->dwCreateOffset,dwMessageSize-pmgmt->dwCreateOffset,0,1,pvSPHeader);
				break;
			}

			case DPSP_MSG_ADDPLAYERTOGROUP:
				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwCreateOffset)){
					DPF(1,"SECURITY WARN: ADDPLAYER TO GROUP MESSAGE TOO SMALL\n");
					hr=DPERR_GENERIC;
					break;
				}
				hr = InternalAddPlayerToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwCreateOffset)){
					DPF(1,"SECURITY WARN: DELETE PLAYER FROM GROUP MESSAGE TOO SMALL\n");
					hr=DPERR_GENERIC;
					break;
				}
				hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_PLAYERDATACHANGED: 
			case DPSP_MSG_GROUPDATACHANGED:
			case DPSP_MSG_PLAYERNAMECHANGED:
			case DPSP_MSG_GROUPNAMECHANGED:

				hr = SP_HandleDataChanged(this,pReceiveBuffer,dwMessageSize);
				break;
			
			case DPSP_MSG_SESSIONDESCCHANGED:

				hr = SP_HandleSessionDescChanged(this,pReceiveBuffer,dwMessageSize);
				break;

			case DPSP_MSG_ADDSHORTCUTTOGROUP:
				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwCreateOffset)){
					DPF(1,"SECURITY WARN: DELETE PLAYER FROM GROUP MESSAGE TOO SMALL\n");
					hr=DPERR_GENERIC;
					break;
				}
				hr = InternalAddGroupToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,DPGROUP_SHORTCUT,FALSE);
				break;

			case DPSP_MSG_DELETEGROUPFROMGROUP:
				if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwCreateOffset)){
					DPF(1,"SECURITY WARN: DELETE PLAYER FROM GROUP MESSAGE TOO SMALL\n");
					hr=DPERR_GENERIC;
					break;
				}
				hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;

			default:
				ASSERT(FALSE);
				DPF(0,"SP_Playermess: received unrecognized message - msg = %d\n",dwCmd);
		} // switch
	} // DPSP_HEADER_LOCALMSG

	// dplay has processed the system message - tell all local players about it
	if (bDistribute && SUCCEEDED(hr))
	{
		hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	return DP_OK;
} // SP_HandlePlayerMgmt

// construct player or group flags
DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer)
{
	DWORD	dwFlags;

	dwFlags = 0;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		dwFlags |= DPPLAYER_SERVERPLAYER;
	}

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
	{
		dwFlags |= DPPLAYER_SPECTATOR;
	}

	// player or group was created locally
	if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		dwFlags |= DPPLAYER_LOCAL;
	}

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
	{
		dwFlags |= DPGROUP_STAGINGAREA;
	}

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
	{
		dwFlags |= DPGROUP_HIDDEN;
	}

	return (dwFlags);
} // GetPlayerFlags

#undef DPF_MODNAME
#define DPF_MODNAME	"MESSAGE BUILDER"

/*
 ** BuildAddMessage
 *
 *  CALLED BY: BuildPlayerSystemMessage
 *
 *  PARAMETERS:
 *		pPlayerSrc - the player that received this message
 *		pReceiveBuffer - the message that was received
 *		ppMessageBuffer - buffer going out to the user
 *		pdwMessagesize - size of ppMessageBuffer
 *		fPlayer - is this an addplayer or addgroup.  
 *
 *  DESCRIPTION: builds a player system message. converts dplay internal 
 *		message format to user readable format (see dplay.h). called before 
 *		putting a message in the apps message queue.
 *
 *  RETURNS: DP_OK, ppMessagebuffer,pdwMessagesize, or E_OUTOFMEMORY
 *
 */

HRESULT BuildAddMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	LPDPLAYI_PLAYER pPlayer; // the player being created
	LPDPLAYI_GROUP pGroup; // used to verify group
	DPMSG_CREATEPLAYERORGROUP dpmsg; // the message being built
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes
	HRESULT hr;
	
	memset(&dpmsg,0,sizeof(dpmsg));

	if (fPlayer)
	{
	    pPlayer = PlayerFromID(this,
	    	((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_PLAYER(pPlayer)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		pGroup = GroupFromID(this,
			((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_GROUP(pGroup)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		// cast to pPlayer since we only care about common fields
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	ASSERT(pPlayer);

	// don't generate player message if it's a sysplayer
	// not really an error, but we use this to make sure user doesn't 
	// see messages they shouldn't get...
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) return E_FAIL;

	// make sure user doesn't get self - create message
	if (pPlayer->dwID == pPlayerSrc->dwID) return E_FAIL; 
	
	// build the message
	dpmsg.dwType = DPSYS_CREATEPLAYERORGROUP;
	dpmsg.dpId = pPlayer->dwID;
	dpmsg.dwCurrentPlayers = this->lpsdDesc->dwCurrentPlayers;
	dpmsg.dwDataSize = pPlayer->dwPlayerDataSize;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName) ;
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName) ;

	// alloc the user message
	*pdwMessageSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + iShortStrLen + iLongStrLen +
		pPlayer->dwPlayerDataSize;

	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}
	
	// now , build the buffer

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	pBufferIndex = (LPBYTE) *ppMessageBuffer + sizeof(dpmsg);
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}

	// copy the player blob into the buffer. set the blob pointer
	if (pPlayer->dwPlayerDataSize)
	{
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		dpmsg.lpData = pBufferIndex;
	}
	else 
	{
		dpmsg.lpData = NULL;
	}

	// copy over the message portion
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL ||\
	    (this->fLoadRetrofit) )
	{
		// Leave locks to prevent the deadlock
		LEAVE_DPLAY();	

		if( dpmsg.dwPlayerType == DPPLAYERTYPE_PLAYER )
		{
			DVoiceNotify( this, DVEVENT_ADDPLAYER, dpmsg.dpId, 0,DVTRANSPORT_OBJECTTYPE_BOTH );
		}	
		else
		{
			DVoiceNotify( this, DVEVENT_CREATEGROUP, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
	
		LEAVE_SERVICE();
	}
	
	// all done...
	return DP_OK;

} // BuildAddMessage

// see BuildAddMessage comments
HRESULT BuildDeleteMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_DESTROYPLAYERORGROUP dpmsg;
	LPDPLAYI_PLAYER pPlayer;
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes
	HRESULT hr;

	if (fPlayer) 
	{
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;		
		// don't send to self...
		// a-josbor- in order to support the NAMESERVER being able to delete
		//	any player, we must allow the delete message to be delivered to
		//	"self"
	//	if (dpmsg.dpId == pPlayerSrc->dwID) return E_FAIL;

        pPlayer = PlayerFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_PLAYER(pPlayer)) 
        {
		
			// e.g. we've gotten two deletes. this can happen e.g.
			// w/ keep alive threads on two systems simultaneously
			// detecting someone's gone
        	return DPERR_INVALIDPARAMS;
        }

		if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		{
			// not really an error, just don't tell users about
			// sysplayer stuff
			return E_FAIL;
		}

		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	} // fPlayer
	else 
	{	
		LPDPLAYI_GROUP pGroup;

		// group
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;	
		
		pGroup = GroupFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_GROUP(pGroup)) 
        {
			// should never happen
			ASSERT(FALSE);		
        	return DPERR_INVALIDPARAMS;
        }
		// cast to player for what we need
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwType = DPSYS_DESTROYPLAYERORGROUP;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpnName.dwFlags = 0;
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	// calc message size
	*pdwMessageSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pPlayer->dwPlayerLocalDataSize
						+ pPlayer->dwPlayerDataSize
						+ iShortStrLen + iLongStrLen;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	pBufferIndex = (LPBYTE)(*ppMessageBuffer) + sizeof(dpmsg);

	// copy the local player data
	dpmsg.dwLocalDataSize = pPlayer->dwPlayerLocalDataSize;
	if (dpmsg.dwLocalDataSize)
	{
		dpmsg.lpLocalData = pBufferIndex;
		memcpy(dpmsg.lpLocalData,pPlayer->pvPlayerLocalData,pPlayer->dwPlayerLocalDataSize);
		pBufferIndex += dpmsg.dwLocalDataSize;
	}
	else 
	{
		dpmsg.lpLocalData = NULL;
	}
	
	// copy the Player data
	dpmsg.dwRemoteDataSize = pPlayer->dwPlayerDataSize;
	if (dpmsg.dwRemoteDataSize)
	{
		dpmsg.lpRemoteData = pBufferIndex;
		memcpy(dpmsg.lpRemoteData,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += dpmsg.dwRemoteDataSize;
	}
	else 
	{
		dpmsg.lpRemoteData = NULL;
	}

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}
	
	// put the sys message into the buffer
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		// Have to let go of the lock so that the notification
		// can proceed.
		LEAVE_DPLAY();
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}

		// rodtoll: prevent deadlock, always drop locks before calling DVoiceNotify
		LEAVE_ALL();
		
		if( dpmsg.dwPlayerType == DPPLAYERTYPE_PLAYER )
		{
			DVoiceNotify( this, DVEVENT_REMOVEPLAYER, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}	
		else
		{
			DVoiceNotify( this, DVEVENT_DELETEGROUP, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}

		ENTER_ALL();

		LEAVE_SERVICE();
	}
	
	return DP_OK;

} // BuildDeleteMessage	

// see BuildAddPlayerMessage comments
// fAdd - True - add to group, false, delete from group
HRESULT BuildPlayerGroupMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,DWORD dwType)
{
	HRESULT hr;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_GROUPADD dpmsg; // add or delete mesage

	dpmsg.dpIdPlayer = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;
	dpmsg.dpIdGroup = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;	

	// set up dpmsg
	dpmsg.dwType = dwType;

	*pdwMessageSize = sizeof(dpmsg);
	
	// alloc the user message
	*ppMessageBuffer = NULL;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();	

		// Have to leave the locks to prevent deadlock
		if( dwType == DPSYS_ADDPLAYERTOGROUP )
		{
			DVoiceNotify( this, DVEVENT_ADDPLAYERTOGROUP, dpmsg.dpIdGroup, dpmsg.dpIdPlayer, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		else if( dwType == DPSYS_DELETEPLAYERFROMGROUP )
		{
			DVoiceNotify( this, DVEVENT_REMOVEPLAYERFROMGROUP, dpmsg.dpIdGroup, dpmsg.dpIdPlayer, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}	
	
	memcpy(*ppMessageBuffer,&dpmsg,*pdwMessageSize);
	return DP_OK;

	
} // BuildPlayerGroupMessage

// see BuildAddMessage comments
HRESULT BuildDataChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPDATA msg;
	LPVOID pvData;
	DWORD dwDataSize;
	DWORD dwID;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;
	
	// see who it's from
	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;

	// find the data + size
	pvData = pReceiveBuffer + ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataOffset;
	dwDataSize = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataSize;

	// alloc the user message
	*pdwMessageSize = sizeof(msg) + dwDataSize;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_SETPLAYERORGROUPDATA;
	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	msg.dpId = dwID;
	msg.dwDataSize = dwDataSize;
	if (dwDataSize) msg.lpData = (LPBYTE)*ppMessageBuffer + sizeof(msg);
	else msg.lpData = (LPBYTE)NULL;

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));
	// copy the data
	if (dwDataSize)
	{
		memcpy((LPBYTE)*ppMessageBuffer + sizeof(msg),pvData,dwDataSize);
	}

	return DP_OK;
} // BuildDataChanged

// see BuildAddMessage comments
HRESULT BuildNameChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPNAME msg;
	UINT nShortLength,nLongLength;
	LPWSTR pszShortName,pszLongName;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	msg.dpId = ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwPlayerID;

	msg.dpnName.dwSize = sizeof(msg.dpnName);
	msg.dwType = DPSYS_SETPLAYERORGROUPNAME;

	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset)
	{
		pszShortName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset);
		nShortLength = WSTRLEN_BYTES(pszShortName);		
	}
	else 
	{
		nShortLength = 0;
		pszShortName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset)
	{
		pszLongName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset);
		nLongLength = WSTRLEN_BYTES(pszLongName);				
	}
	else 
	{
		nLongLength = 0;
		pszLongName = (LPWSTR)NULL;
	}

	
	*pdwMessageSize = sizeof(msg) + nShortLength + nLongLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy the strings into the buffer, behind where msg will go
	// short name follows message
	if (nShortLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszShortName,nShortLength);
		msg.dpnName.lpszShortName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpnName.lpszShortName = (LPWSTR)NULL;
	}
	// long name follows short name
	if (nLongLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nShortLength,pszLongName,nLongLength);

		msg.dpnName.lpszLongName = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nShortLength);
	} 
	else 
	{
		msg.dpnName.lpszLongName = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameChanged

// see BuildAddMessage comments
HRESULT BuildNameServerMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	HRESULT hr;
	DPMSG_GENERIC msg;
	LPDPLAYI_DPLAY this=pPlayerSrc->lpDP;
	
	*pdwMessageSize = sizeof(msg);
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_HOST;

	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		// Left locks
		LEAVE_DPLAY();

		DVoiceNotify(this,DVEVENT_MIGRATEHOST,pPlayerSrc->dwID,0, DVTRANSPORT_OBJECTTYPE_BOTH);
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameServerMessage

// see BuildAddMessage comments
HRESULT BuildSessionDescMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	DPMSG_SETSESSIONDESC msg;
	UINT nPasswordLength,nSessionNameLength;
	LPWSTR pszSessionName,pszPassword;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset)
	{
		pszSessionName = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset);
		nSessionNameLength = WSTRLEN_BYTES(pszSessionName);		
	}
	else 
	{
		nSessionNameLength = 0;
		pszSessionName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset)
	{
		pszPassword = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset);
		nPasswordLength = WSTRLEN_BYTES(pszPassword);				
	}
	else 
	{
		nPasswordLength = 0;
		pszPassword = (LPWSTR)NULL;
	}
	
	*pdwMessageSize = sizeof(msg) + nSessionNameLength + nPasswordLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

    // prepare the message 

	msg.dwType = DPSYS_SETSESSIONDESC;
    // copy the session desc 
    memcpy(&(msg.dpDesc), &((LPMSG_SESSIONDESC)pReceiveBuffer)->dpDesc, sizeof(DPSESSIONDESC2));

	// copy the strings into the buffer, behind where msg will go
	// session name follows message
	if (nSessionNameLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszSessionName,nSessionNameLength);
		msg.dpDesc.lpszSessionName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpDesc.lpszSessionName = (LPWSTR)NULL;
	}
	// password follows session name
	if (nPasswordLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nSessionNameLength,pszPassword,nPasswordLength);
		msg.dpDesc.lpszPassword = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nSessionNameLength);
	} 
	else 
	{
		msg.dpDesc.lpszPassword = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildSessionDescMessage

// see BuildAddMessage comments
HRESULT BuildSecureSystemMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize, DWORD dwSendFlags)
{	
    LPDPMSG_SECUREMESSAGE pSecureMessage;
    LPMSG_PLAYERMESSAGE pPlayerMessage=(LPMSG_PLAYERMESSAGE)pReceiveBuffer;
    DWORD dwPlayerMessageSize;
    LPDPLAYI_DPLAY this;

    ASSERT(pdwMessageSize);
    ASSERT(ppMessageBuffer);

    this = pPlayerSrc->lpDP;

	// naked?
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// if we're not naked, player to == player from is not allowed
		if (pPlayerSrc->dwID == pPlayerMessage->idFrom)		
		{
			DPF(7,"not delivering message w/ to == from");
			return DPERR_GENERIC;
		}
		// subtract off the size of the to and from
		*pdwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
	}

    // Remember the player message size so we can copy the correct portion of the 
    // player message from the receive buffer.
    dwPlayerMessageSize = *pdwMessageSize;

    // allocate memory for entire player message + secure msg struct
	*pdwMessageSize += sizeof(DPMSG_SECUREMESSAGE);
	
	// alloc memory for the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return DPERR_OUTOFMEMORY;
	}

    // use the buffer as a secure message
    pSecureMessage = (LPDPMSG_SECUREMESSAGE)*ppMessageBuffer;

    // fill the message type
    pSecureMessage->dwType = DPSYS_SECUREMESSAGE;
    // fill the flags
    if (dwSendFlags & DPSEND_SIGNED)
    {
        pSecureMessage->dwFlags |= DPSEND_SIGNED;
    }
    if (dwSendFlags & DPSEND_ENCRYPTED)
    {
        pSecureMessage->dwFlags |= DPSEND_ENCRYPTED;
    }
    // fill the player from id
    pSecureMessage->dpIdFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;
    // point to the actual player-player message
    pSecureMessage->lpData = (LPBYTE)pSecureMessage+sizeof(DPMSG_SECUREMESSAGE);
    // fill the message size
    pSecureMessage->dwDataSize = dwPlayerMessageSize;
    // copy the message
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// copy message without ids
		memcpy(pSecureMessage->lpData,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),
            dwPlayerMessageSize);
	}
	else 
	{
		// copy naked message into pMessageBuffer
		memcpy(pSecureMessage->lpData,pReceiveBuffer,dwPlayerMessageSize);
	}	

	return DP_OK;

} // BuildSecureSystemMessage

// see BuildAddMessage comments
HRESULT BuildStartSessionMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	LPDPMSG_STARTSESSION	lpmsg;
	LPMSG_STARTSESSION		lpmsgIn = (LPMSG_STARTSESSION)pReceiveBuffer;
	DWORD					dwConnSize;
	DWORD					dwSize;
	LPBYTE					lpByte = NULL, lpByte2 = NULL;
	LPDPLCONNECTION			lpConn = NULL;
	LPDPSESSIONDESC2		lpsd = NULL;
	HRESULT					hr;


	// calc the size
	dwConnSize = *pdwMessageSize - sizeof(DPSP_MSG_STARTSESSION);
	dwSize = sizeof(DPMSG_STARTSESSION) + dwConnSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_STARTSESSION;

	// copy the message
	lpByte = (LPBYTE)lpmsg + sizeof(DPMSG_STARTSESSION);
	lpByte2 = (LPBYTE)lpmsgIn + lpmsgIn->dwConnOffset;
	memcpy(lpByte, lpByte2, dwConnSize);

	// fix the DPLCONNECTION pointer
	lpmsg->lpConn = lpConn = (LPDPLCONNECTION)lpByte;

	// Stick the dplay object's pointer in one of the reserved
	// fields in the SessionDesc so we can forward lobby messages back
	// to the server on that object.  NOTE: The following code relies on the
	// packing code for the DPLCONNECTION structure to remain unchanged.  If
	// the packing changes, this offset calculation may not work correctly.
	lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
	lpsd->dwReserved1 = (DWORD_PTR)(pPlayerSrc->lpDP);
	lpsd->dwReserved2 = pPlayerSrc->dwID;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	// Notify voice system, if it's there
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();

		DVoiceNotify( this, DVEVENT_STARTSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}		

	return DP_OK;

} // BuildStartSessionMessage

// see BuildAddMessage comments
HRESULT BuildChatMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_CHAT		lpmsg;
	LPMSG_CHAT			lpmsgIn = (LPMSG_CHAT)pReceiveBuffer;
	DWORD				dwStringSize, dwSize;
	LPWSTR				lpwszMessageIn = NULL, lpwszMessage = NULL;
	LPDPLAYI_PLAYER		lpPlayer = NULL;
	LPDPLAYI_GROUP		lpGroup = NULL;
	

	// If from == to, then fail building this message because we
	// don't want to send a chat message to ourself.  Normally, the
	// DistributeGroupMessage function would catch this, but since
	// this is a system message, it won't because idFrom will be zero
	if(lpmsgIn->dwIDFrom == pPlayerSrc->dwID)
		return DPERR_GENERIC;

	// calc the size of the message
	lpwszMessageIn = (LPWSTR)((LPBYTE)lpmsgIn + lpmsgIn->dwMessageOffset);
	dwStringSize = WSTRLEN_BYTES(lpwszMessageIn);
	dwSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + dwStringSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_CHAT;
	lpmsg->idFromPlayer = lpmsgIn->dwIDFrom;
	lpmsg->lpChat = (LPDPCHAT)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT));
	lpmsg->lpChat->dwSize = sizeof(DPCHAT);
	lpmsg->lpChat->dwFlags = lpmsgIn->dwFlags;

	// Determine if the message was sent to a group or a player and
	// set the appropriate idToXXXXX field in the message
	if(lpmsgIn->dwIDTo != DPID_ALLPLAYERS)
	{
		lpPlayer = PlayerFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
		if(VALID_DPLAY_PLAYER(lpPlayer))
		{
			lpmsg->idToPlayer = lpmsgIn->dwIDTo;
		}
		else
		{
			lpGroup = GroupFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
			if(VALID_DPLAY_GROUP(lpGroup))
			{
				lpmsg->idToGroup = lpmsgIn->dwIDTo;
			}
			else
			{
				DPF_ERRVAL("Received chat message for unknown player or group, ID = %lu", lpmsgIn->dwIDTo);
				ASSERT(FALSE);
				// I guess we'll treat it as a broadcast message
			}
		}
	}

	// copy the message
	lpwszMessage = (LPWSTR)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT)
					+ sizeof(DPCHAT));
	memcpy(lpwszMessage, lpwszMessageIn, dwStringSize);

	// fix the DPCHAT string pointer
	lpmsg->lpChat->lpszMessage = lpwszMessage;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildChatMessage

// see BuildAddMessage comments
HRESULT BuildGroupOwnerChangedMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_SETGROUPOWNER		lpmsg = NULL;
	LPMSG_GROUPOWNERCHANGED		lpmsgIn = (LPMSG_GROUPOWNERCHANGED)pReceiveBuffer;
	

	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(sizeof(DPMSG_SETGROUPOWNER));
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_SETGROUPOWNER;
	lpmsg->idGroup = lpmsgIn->dwIDGroup;
	lpmsg->idNewOwner = lpmsgIn->dwIDNewOwner;
	lpmsg->idOldOwner = lpmsgIn->dwIDOldOwner;

	// Set the output pointers
	*pdwMessageSize = sizeof(DPMSG_SETGROUPOWNER);
	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildGroupOwnerChangedMessage


// sets up a dplay system message suitable for passing back to a player
/*
 ** BuildPlayerSystemMessage
 *
 *  CALLED BY:	HandlePlayerMessage
 *
 *  PARAMETERS:
 *				pPlayer	- the player that received the message
 *				pReceiveBuffer - the buffer that came off the wire
 *				ppMessageBuffer - the destination for the built message (return)
 *				pdwMessageSize - the size of the built message (return)
 *
 *  DESCRIPTION:
 *				Builds a system message (from dplay.h) corresponding to dplays
 *				internal message (from dpmess.h)
 *
 *  RETURNS: the BuildXXX rval
 *
 */
HRESULT BuildPlayerSystemMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer, DWORD * pdwMessageSize) 
{
	DWORD dwCmd;
	HRESULT hr = DP_OK;

	dwCmd  = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);

	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPDATACHANGED:
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;
			
		case DPSP_MSG_PLAYERNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;

		case DPSP_MSG_CREATEPLAYER: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_CREATEGROUP: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;			

		case DPSP_MSG_DELETEPLAYER:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;


		case DPSP_MSG_DELETEGROUP:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			
			break;

		case DPSP_MSG_ADDPLAYERTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDPLAYERTOGROUP);
			break;

		case DPSP_MSG_DELETEPLAYERFROMGROUP:			
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEPLAYERFROMGROUP);
			break;

		case DPSP_MSG_NAMESERVER:
			hr = BuildNameServerMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

        case DPSP_MSG_SESSIONDESCCHANGED:
            hr = BuildSessionDescMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
                    pdwMessageSize);
            break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDGROUPTOGROUP);
			break;
			
		case DPSP_MSG_DELETEGROUPFROMGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEGROUPFROMGROUP);
			break;
			
		case DPSP_MSG_STARTSESSION:
			hr = BuildStartSessionMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;
			
		case DPSP_MSG_CHAT:
			hr = BuildChatMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

		case DPSP_MSG_GROUPOWNERCHANGED:
			hr = BuildGroupOwnerChangedMessage(pPlayer,pReceiveBuffer,
					ppMessageBuffer,pdwMessageSize);
			break;

		default:
			ASSERT(FALSE);
			DPF_ERR("BUILD MESS: received unrecognized message");
			return E_UNEXPECTED;

	}
	return hr;	
} // BuildPlayerSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"

// this function forwards a player message to the destination player indicated in the message
HRESULT NS_ForwardPlayerMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize,
        DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_PLAYERMESSAGE pPlayerMsg = (LPMSG_PLAYERMESSAGE) pReceiveBuffer;
    LPBYTE pMsg;

    ASSERT(pPlayerMsg);

    // extract the message
    pMsg = (LPBYTE)pPlayerMsg + sizeof(MSG_PLAYERMESSAGE);
    dwMessageSize -= sizeof(MSG_PLAYERMESSAGE);

	DPF(7,"Forwarding player message from id %d to id %d",pPlayerMsg->idFrom, pPlayerMsg->idTo);

	if (dwSendFlags & DPSEND_GUARANTEED)
	{
		// Put us in pending mode, so messages don't get delivered out of 
		// order. A message coming off the wire can get the dplay lock in the
		// window between the time we drop it and DP_Send takes the lock.
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}

    LEAVE_DPLAY();

	// call send - it will push the bits through the wire for us
	hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pPlayerMsg->idFrom,
		pPlayerMsg->idTo, dwSendFlags, pMsg,dwMessageSize);

    ENTER_DPLAY();

    return hr;
} // NS_ForwardPlayerMessage

// a player has received a message. this can be either 1. a system message
// (e.g. new player announcment) or 2. a player-player message
// we package it up in the public dplay format, and put it on the message q
// fPlayerMessage is TRUE if it's player-player
HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage, DWORD dwSendFlags) 
{
	HRESULT hr=DP_OK;
	LPDPLAYI_DPLAY this;
	LPMESSAGENODE pmsn=NULL; // we'll add this node to iplay's list of nodes
	LPMSG_PLAYERMESSAGE pmsg; // message cast from received buffer
	LPBYTE pMessageBuffer=NULL; // buffer we copy message into for storage

	this = pPlayer->lpDP;

    // in a secure session, player messages are routed through the server
    // so forward the message to the appropriate destination player
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this))
    {
        // forward all remote player messages
        if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
        {
			// currently we don't have a way of knowing if a received message was sent reliably.
			// but since we know that all secure messages are sent guaranteed, we can forward
			// this message reliably.
			dwSendFlags |= DPSEND_GUARANTEED;

            hr = NS_ForwardPlayerMessage(this, pReceiveBuffer, dwMessageSize, dwSendFlags);
            return hr;
        }
    }

	// alloc a message node
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
    if (!pmsn) 
    {
    	DPF_ERR("could not handle player message - out of memory");
        return E_OUTOFMEMORY;
    }

	pmsg = (LPMSG_PLAYERMESSAGE)pReceiveBuffer;

	if (fPlayerMessage)
    {   // its a player - player message
		
        if (dwSendFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED))
        {
    	    // it's a secure message - convert it to the dplay system message format
		    hr = BuildSecureSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize,dwSendFlags);
		    if (FAILED(hr)) 
		    {
			    // its ok to fail this.  we fail when trying to distribute sysplayer
			    // announcments to players.
			    DPMEM_FREE(pmsn);
			    return DP_OK;
		    }            
		    pmsn->idFrom = 0; // system message

			DPF(5,"PlayerID %d received secure player message (Flags=0x%08x) from playerID %d size = %d\n",pPlayer->dwID,
						dwSendFlags, pmsg->idFrom,dwMessageSize);
        }
        else // unsecure player-player message
        {
		    // naked?
		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // if we're not naked, player to == player from is not allowed
			    if (pPlayer->dwID == pmsg->idFrom)		
			    {
				    DPF(7,"not delivering message w/ to == from");
				    DPMEM_FREE(pmsn);
				    return E_FAIL;
			    }
			    // subtract off the size of the to and from
			    dwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
		    }

		    // need to make a copy of the off the wire message
		    pMessageBuffer = DPMEM_ALLOC(dwMessageSize);
	        if (!pMessageBuffer) 
	        {
	    	    DPF_ERR("could not handle player message - out of memory");
			    DPMEM_FREE(pmsn);
	            return E_OUTOFMEMORY;
	        }

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // copy message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),dwMessageSize);
		    }
		    else 
		    {
			    // copy naked message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer,dwMessageSize);
		    }	

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    pmsn->idFrom = pmsg->idFrom;						
		    }
		    else 
		    {
			    pmsn->idFrom = DPID_UNKNOWN;
		    }

#if 0
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - %s,%s\n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize,pMessageBuffer,pMessageBuffer+strlen(pMessageBuffer));
#endif						
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - \n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize);

        } // DPSEND_SIGNED || DPSEND_ENCRYPTED
	}
	else 
	{
    	// it's a system message - convert it to the dplay system message format
		hr = BuildPlayerSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize);
		if (FAILED(hr)) 
		{
			// its ok to fail this.  we fail when trying to distribute sysplayer
			// announcments to players.
			DPMEM_FREE(pmsn);
			return DP_OK;
		}
		pmsn->idFrom = 0;
	}

	DPF(7,"Putting message in apps queue");

	pmsn->idTo = pPlayer->dwID; 		
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pMessageBuffer;
	pmsn->dwMessageSize = dwMessageSize;

	if (!pmsn->pMessage)
	{
		ASSERT(FALSE);
		DPMEM_FREE(pmsn); // ack ! this should never fail!
		return E_FAIL;
	}

	this->nMessages++;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	// all done...
	return hr;
} // HandlePlayerMessage

// we got a message addressed to a group.
// distribute it to all local players in that group
HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwSendFlags)
{
	LPDPLAYI_GROUPNODE pGroupnode;
	UINT nPlayers;
	HRESULT hr;

	ASSERT(this->pSysPlayer);

	// how many players are we looking for
	pGroupnode = FindPlayerInGroupList(pGroupTo->pSysPlayerGroupnodes,this->pSysPlayer->dwID);
	if (!pGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = pGroupnode->nPlayers;

	// walk the list of groupnodes, looking for nPlayers local players to give
	// the message to
	pGroupnode = pGroupTo->pGroupnodes;
	while ((nPlayers > 0) && (pGroupnode))
	{
		if (pGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			hr =  HandlePlayerMessage(pGroupnode->pPlayer,pReceiveBuffer,dwMessageSize,fPlayerMessage,dwSendFlags);
			nPlayers--;
		} // local
		
		pGroupnode = pGroupnode->pNextGroupnode;
	} // while
	
	ASSERT(0 == nPlayers);
	return DP_OK;
	
} // DistributeGroupMessage


// called by HandleEnumSessionsReply returns TRUE if pDesc1 and pDesc2
// are the same session
BOOL IsEqualSessionDesc(LPDPSESSIONDESC2 pDesc1,LPDPSESSIONDESC2 pDesc2) 
{
	if (IsEqualGUID(&(pDesc1->guidInstance),&(pDesc2->guidInstance)))
		return TRUE;

	return FALSE;
} // IsEqualSessionDesc

// this client called enum sessions.  the sp got a reply, we add that 
// to the list of known sessions
HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD cbBuffer, LPVOID pvSPHeader) 
{
    LPMSG_ENUMSESSIONSREPLY pem;
	LPSESSIONLIST pNewNode=NULL, pExistingNode=NULL;
	LPWSTR lpsz;

	pem = (LPMSG_ENUMSESSIONSREPLY) pReceiveBuffer;

	// SECURITY - add validation of input buffer.
	if(cbBuffer < sizeof(MSG_ENUMSESSIONSREPLY)){
		DPF(1,"SECURITY WARN: EnumSessionsReply, bogus reply\n");
		return E_FAIL;
	}
	if(pem->dwNameOffset && pem->dwNameOffset > cbBuffer-sizeof(WCHAR)){
		DPF(1,"SECURITY WARN: EnumSessionsReply, bogus reply - invalid name offset\n");
		return E_FAIL;
	}

	// force NULL termination on string
	if(pem->dwNameOffset){
		pReceiveBuffer[cbBuffer-1]=0;
		pReceiveBuffer[cbBuffer-2]=0;
	}	
	
	// SECURIY - end

	// alloc a new session node
	pNewNode = DPMEM_ALLOC(sizeof(SESSIONLIST));
    if (!pNewNode) 
    {
    	DPF_ERR("could not enum reply - out of memory");
        return E_OUTOFMEMORY;
    }

	// copy the description from the receive buffer to the session node
	memcpy(&(pNewNode->dpDesc),&(pem->dpDesc),sizeof(DPSESSIONDESC2));

    // remember the version of the message
    pNewNode->dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    // remember the sp header for the session
	if ((this->dwSPHeaderSize) && (pvSPHeader))
	{
		// store the blob
		pNewNode->pvSPMessageData = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNewNode->pvSPMessageData)
		{
            DPMEM_FREE(pNewNode);
			DPF_ERR("could not alloc sp blob");
			return E_OUTOFMEMORY;
		}

		// copy the last this->dwSPHeaderSize bytes off the end of the buffer
		memcpy(pNewNode->pvSPMessageData,pvSPHeader,this->dwSPHeaderSize);
	}

	// unpack strings
	if (pem->dwNameOffset)
	{
		GetString(&lpsz,(WCHAR *)(pReceiveBuffer + pem->dwNameOffset));
		pNewNode->dpDesc.lpszSessionName = lpsz;
	}

	// see if this session is in the list
	pExistingNode = this->pSessionList;
	while (pExistingNode)
	{
		if ( IsEqualSessionDesc(&(pExistingNode->dpDesc),&(pem->dpDesc)))
		{
			// it's in the list already, so just update the node
            break;
		}
		pExistingNode = pExistingNode->pNextSession;
	}

    if (!pExistingNode)
    {
    	if (pNewNode->dpDesc.lpszSessionName != NULL)
    	{
	    	DPF(4, "Got reply from new session \"%ls\" (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
				pNewNode->dpDesc.lpszSessionName,
				pNewNode->dpDesc.guidApplication.Data1,
				pNewNode->dpDesc.guidApplication.Data2,
				pNewNode->dpDesc.guidApplication.Data3,
				pNewNode->dpDesc.guidApplication.Data4[0],
				pNewNode->dpDesc.guidApplication.Data4[1],
				pNewNode->dpDesc.guidApplication.Data4[2],
				pNewNode->dpDesc.guidApplication.Data4[3],
				pNewNode->dpDesc.guidApplication.Data4[4],
				pNewNode->dpDesc.guidApplication.Data4[5],
				pNewNode->dpDesc.guidApplication.Data4[6],
				pNewNode->dpDesc.guidApplication.Data4[7],
				pNewNode->dpDesc.guidInstance.Data1,
				pNewNode->dpDesc.guidInstance.Data2,
				pNewNode->dpDesc.guidInstance.Data3,
				pNewNode->dpDesc.guidInstance.Data4[0],
				pNewNode->dpDesc.guidInstance.Data4[1],
				pNewNode->dpDesc.guidInstance.Data4[2],
				pNewNode->dpDesc.guidInstance.Data4[3],
				pNewNode->dpDesc.guidInstance.Data4[4],
				pNewNode->dpDesc.guidInstance.Data4[5],
				pNewNode->dpDesc.guidInstance.Data4[6],
				pNewNode->dpDesc.guidInstance.Data4[7]);
    	}
    	else
    	{
	    	DPF(4, "Got reply from new unnamed session (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
				pNewNode->dpDesc.guidApplication.Data1,
				pNewNode->dpDesc.guidApplication.Data2,
				pNewNode->dpDesc.guidApplication.Data3,
				pNewNode->dpDesc.guidApplication.Data4[0],
				pNewNode->dpDesc.guidApplication.Data4[1],
				pNewNode->dpDesc.guidApplication.Data4[2],
				pNewNode->dpDesc.guidApplication.Data4[3],
				pNewNode->dpDesc.guidApplication.Data4[4],
				pNewNode->dpDesc.guidApplication.Data4[5],
				pNewNode->dpDesc.guidApplication.Data4[6],
				pNewNode->dpDesc.guidApplication.Data4[7],
				pNewNode->dpDesc.guidInstance.Data1,
				pNewNode->dpDesc.guidInstance.Data2,
				pNewNode->dpDesc.guidInstance.Data3,
				pNewNode->dpDesc.guidInstance.Data4[0],
				pNewNode->dpDesc.guidInstance.Data4[1],
				pNewNode->dpDesc.guidInstance.Data4[2],
				pNewNode->dpDesc.guidInstance.Data4[3],
				pNewNode->dpDesc.guidInstance.Data4[4],
				pNewNode->dpDesc.guidInstance.Data4[5],
				pNewNode->dpDesc.guidInstance.Data4[6],
				pNewNode->dpDesc.guidInstance.Data4[7]);
    	}
    
	    // put the new session list on the front of the list
	    pNewNode->pNextSession = this->pSessionList;
	    this->pSessionList = pNewNode;
		// timestamp it
		pNewNode->dwLastReply = GetTickCount();
    }
    else
    {
    	if (pNewNode->dpDesc.lpszSessionName != NULL)
    	{
	    	DPF(4, "Got reply from existing session \"%ls\" (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
				pNewNode->dpDesc.lpszSessionName,
				pNewNode->dpDesc.guidApplication.Data1,
				pNewNode->dpDesc.guidApplication.Data2,
				pNewNode->dpDesc.guidApplication.Data3,
				pNewNode->dpDesc.guidApplication.Data4[0],
				pNewNode->dpDesc.guidApplication.Data4[1],
				pNewNode->dpDesc.guidApplication.Data4[2],
				pNewNode->dpDesc.guidApplication.Data4[3],
				pNewNode->dpDesc.guidApplication.Data4[4],
				pNewNode->dpDesc.guidApplication.Data4[5],
				pNewNode->dpDesc.guidApplication.Data4[6],
				pNewNode->dpDesc.guidApplication.Data4[7],
				pNewNode->dpDesc.guidInstance.Data1,
				pNewNode->dpDesc.guidInstance.Data2,
				pNewNode->dpDesc.guidInstance.Data3,
				pNewNode->dpDesc.guidInstance.Data4[0],
				pNewNode->dpDesc.guidInstance.Data4[1],
				pNewNode->dpDesc.guidInstance.Data4[2],
				pNewNode->dpDesc.guidInstance.Data4[3],
				pNewNode->dpDesc.guidInstance.Data4[4],
				pNewNode->dpDesc.guidInstance.Data4[5],
				pNewNode->dpDesc.guidInstance.Data4[6],
				pNewNode->dpDesc.guidInstance.Data4[7]);
    	}
    	else
    	{
	    	DPF(4, "Got reply from existing unnamed session (app = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, instance = {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}).",
				pNewNode->dpDesc.guidApplication.Data1,
				pNewNode->dpDesc.guidApplication.Data2,
				pNewNode->dpDesc.guidApplication.Data3,
				pNewNode->dpDesc.guidApplication.Data4[0],
				pNewNode->dpDesc.guidApplication.Data4[1],
				pNewNode->dpDesc.guidApplication.Data4[2],
				pNewNode->dpDesc.guidApplication.Data4[3],
				pNewNode->dpDesc.guidApplication.Data4[4],
				pNewNode->dpDesc.guidApplication.Data4[5],
				pNewNode->dpDesc.guidApplication.Data4[6],
				pNewNode->dpDesc.guidApplication.Data4[7],
				pNewNode->dpDesc.guidInstance.Data1,
				pNewNode->dpDesc.guidInstance.Data2,
				pNewNode->dpDesc.guidInstance.Data3,
				pNewNode->dpDesc.guidInstance.Data4[0],
				pNewNode->dpDesc.guidInstance.Data4[1],
				pNewNode->dpDesc.guidInstance.Data4[2],
				pNewNode->dpDesc.guidInstance.Data4[3],
				pNewNode->dpDesc.guidInstance.Data4[4],
				pNewNode->dpDesc.guidInstance.Data4[5],
				pNewNode->dpDesc.guidInstance.Data4[6],
				pNewNode->dpDesc.guidInstance.Data4[7]);
   		}
    
		// HACKHACK -- myronth -- 3/12/97
		// If the lobby owns this object, don't copy in the new address
		// because it is bogus.  We can remove this if/else after AndyCo
		// gets rid of the global session list.
		if(!IS_LOBBY_OWNED(this))
		{
			// preserve link to the next node in the session list
			pNewNode->pNextSession = pExistingNode->pNextSession;

			// cleanup old strings
			if (pExistingNode->dpDesc.lpszSessionName)
			{
				DPMEM_FREE(pExistingNode->dpDesc.lpszSessionName);
			}

			// cleanup old sp header
			if (pExistingNode->pvSPMessageData)
			{
				DPMEM_FREE(pExistingNode->pvSPMessageData);
			}

			// update the existing node
			memcpy(pExistingNode, pNewNode, sizeof(SESSIONLIST));
		}
		else
		{
			// Free the new SessionName string
			if(pNewNode->dpDesc.lpszSessionName)
				DPMEM_FREE(pNewNode->dpDesc.lpszSessionName);
		}
		// ENDHACKHACK!!!! -- myronth

		// timestamp it
		pExistingNode->dwLastReply = GetTickCount();
		
        // get rid of the new node
        DPMEM_FREE(pNewNode);
    }

	return DP_OK;

} // HandleEnumSessionsReply


// either the player name or player data has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
	BOOL fPlayer = FALSE;
	DWORD dwID;

	dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);

	// SECURITY, make sure the buffer is big enough to contain the dwPlayerID field
	if(dwMessageSize < offsetof(MSG_PLAYERDATA,dwDataSize)){
		DPF(1,"SECURITY WARN: SPDATACHANGED, invalid length\n");
		return DPERR_GENERIC;
	}

	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;	
	
	
	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			fPlayer=TRUE;
			// fall through
		case DPSP_MSG_GROUPDATACHANGED:
		{
			LPVOID pvData;
			DWORD  dwDataSize;
			LPMSG_PLAYERDATA pmsg=(LPMSG_PLAYERDATA)pReceiveBuffer;

			// SECURITY - verify format of message
			if( dwMessageSize < sizeof(MSG_PLAYERDATA) || 
			    pmsg->dwDataSize > dwMessageSize-sizeof(MSG_PLAYERDATA) ||  
			    pmsg->dwDataOffset < sizeof(MSG_PLAYERDATA) ||
			    pmsg->dwDataOffset + pmsg->dwDataSize > dwMessageSize )
			{
				DPF(1,"SECURITY WARN: PLAYER/GROUP DATA CHANGED, BAD FIELDS\n");
				return DPERR_GENERIC;
			}

			dwDataSize = pmsg->dwDataSize;
			pvData = pReceiveBuffer + pmsg->dwDataOffset;
			// get dplay to set the data
			hr = InternalSetData((IDirectPlay *)this->pInterfaces,dwID,pvData,dwDataSize,
					0,fPlayer,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetData returned error! hr = 0x%08x", hr);
			}
					
			break;
		}
		
		case DPSP_MSG_PLAYERNAMECHANGED:
			fPlayer = TRUE;
		case DPSP_MSG_GROUPNAMECHANGED:
		{
			DPNAME PlayerName;
			LPWSTR pszShortName,pszLongName;
			LPMSG_PLAYERNAME pmsg=(LPMSG_PLAYERNAME)pReceiveBuffer;
			
			PlayerName.dwSize = sizeof(DPNAME);

			if(dwMessageSize < sizeof(MSG_PLAYERNAME) ||
				pmsg->dwShortOffset > dwMessageSize-sizeof(WCHAR) ||
				pmsg->dwLongOffset  > dwMessageSize-sizeof(WCHAR)) 
			{
				DPF(1,"SECURITY WARN: PLAYER/GROUP NAME CHANGED, BAD FIELDS\n");
				return DPERR_GENERIC;
			}

			// Force NULL termination of names
			if(pmsg->dwShortOffset || pmsg->dwLongOffset){
				pReceiveBuffer[dwMessageSize-1]=0;
				pReceiveBuffer[dwMessageSize-2]=0;
			}	

			if (pmsg->dwShortOffset)
			{
				pszShortName = (LPWSTR)(pReceiveBuffer + pmsg->dwShortOffset);
			}
			else 
			{
				pszShortName = (LPWSTR)NULL;
			}
			
			if (pmsg->dwLongOffset)
			{
				pszLongName = (LPWSTR)(pReceiveBuffer + pmsg->dwLongOffset);
			}
			else 
			{
				pszLongName = (LPWSTR)NULL;
			}

			PlayerName.lpszShortName = pszShortName;
			PlayerName.lpszLongName = pszLongName;			
			
			// get dplay to set the name
			hr = InternalSetName((IDirectPlay *)this->pInterfaces,dwID,&PlayerName,
				fPlayer,0,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetname returned error! hr = 0x%08x", hr);
			}

			break;
			
		}
					
		default:
			ASSERT(FALSE);			
			break;

	}

	return hr;

}  // HandlePlayerData

// session desc has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
    LPDPSESSIONDESC2 lpsdDesc;
    LPMSG_SESSIONDESC pmsg=(LPMSG_SESSIONDESC)pReceiveBuffer;

    dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
	
    if (DPSP_MSG_SESSIONDESCCHANGED != dwCmd)
    {
        ASSERT(FALSE);
    }

	// SECURITY - validate the buffer
	if( dwMessageSize < sizeof(MSG_SESSIONDESC) || 
		pmsg->dwSessionNameOffset > dwMessageSize - sizeof(WCHAR) ||
		pmsg->dwPasswordOffset > dwMessageSize - sizeof(WCHAR)
		)
	{
		DPF(1,"SECURITY WARN: HandleSessDescChange, invalid buffer\n");
	}
	if(pmsg->dwSessionNameOffset || pmsg->dwPasswordOffset){
		// ensure buffers at least have NULL termination
		pReceiveBuffer[dwMessageSize-1]=0;
		pReceiveBuffer[dwMessageSize-2]=0;
	}	

    // fix up pointers in session desc on buffer to point to the strings 
    // on the buffer
    lpsdDesc = (LPDPSESSIONDESC2)(&pmsg->dpDesc);

    if (pmsg->dwSessionNameOffset)
	{
		lpsdDesc->lpszSessionName = (LPWSTR)(pReceiveBuffer + pmsg->dwSessionNameOffset);
	}
	else 
	{
		lpsdDesc->lpszSessionName = (LPWSTR)NULL;
	}
	
	if (pmsg->dwPasswordOffset)
	{
		lpsdDesc->lpszPassword = (LPWSTR)(pReceiveBuffer + pmsg->dwPasswordOffset);
	}
	else 
	{
		lpsdDesc->lpszPassword = (LPWSTR)NULL;
	}
		
	// get dplay to set the session desc
	hr = InternalSetSessionDesc((IDirectPlay *)this->pInterfaces,lpsdDesc, 0, FALSE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	return hr;

}  // HandleSessionDescChanged


HRESULT HandleChatMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer,
			DWORD dwMessageSize)
{
	LPMSG_CHAT			lpmsg = (LPMSG_CHAT)pReceiveBuffer;
	BOOL				bToGroup = FALSE; // message is to a group	?
	DWORD				dwIDFrom, dwIDTo;
	LPDPLAYI_PLAYER		pPlayer;
	LPDPLAYI_GROUP		pGroup;
	HRESULT				hr=DP_OK;
	
	// SECURITY, length was already verified in InternalHandleMessage, verify fields
	if(lpmsg->dwMessageOffset < sizeof(MSG_CHAT) || lpmsg->dwMessageOffset > dwMessageSize-sizeof(WCHAR) ){
		DPF(1,"SECURITY WARN: invalid offsets in chat message");
		hr=DPERR_GENERIC;
		return hr;
	}
	// Force NULL termination on message.
	pReceiveBuffer[dwMessageSize-2]=0;
	pReceiveBuffer[dwMessageSize-1]=0;

	// make sure it's from a valid player					
	dwIDFrom = lpmsg->dwIDFrom;
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		DPF_ERR("-------received player message FROM invalid player id!!");
		return DPERR_INVALIDPLAYER;
	}

	// see who the message is for
	dwIDTo = lpmsg->dwIDTo;
	pPlayer = PlayerFromID(this,dwIDTo);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		// see if it's to a group
		pGroup = GroupFromID(this,dwIDTo);
		if (!VALID_DPLAY_GROUP(pGroup))
		{
			DPF_ERR("got message for bad player / group");
			return DPERR_INVALIDPLAYER;
		}
		bToGroup = TRUE;
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		// ignore it					
	}
	else 
	{
		if (bToGroup)
		{
			// Send the message to the group
			hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
					dwMessageSize, FALSE, 0);						
		} 
		else 
		{
			// Send the message directly to the player
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
					FALSE, 0);
		}
	}

	return hr;

}  // HandleChatMessage


// we got a message w/ no to / from data
// pick the 1st local non-sysplayer off the player list, 
// to deliver it to
LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	BOOL bFound=FALSE;
	
	pPlayer = this->pPlayers;
	
	while (pPlayer && !bFound)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			bFound = TRUE;
			DPF(4,"found local player id = %d to deliver naked message to",pPlayer->dwID);
		}
		else 
		{
			pPlayer = pPlayer->pNextPlayer;
		}
	}
	
	if (!bFound)
	{
		pPlayer = NULL;
		DPF(1,"no local player found to take delivery of naked message");
	}
	
	return pPlayer;		
} // GetRandomLocalPlayer

/*
 ** PutOnPendingList
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		dwCommand - message type
 *
 *  DESCRIPTION:
 *		Determines if specified message needs to be put on the pending list.
 *
 *  RETURNS: TRUE if message belongs on the pending list, FALSE otherwise.
 *
 */
BOOL PutOnPendingList(LPDPLAYI_DPLAY this, DWORD dwCommand)
{
      switch (dwCommand) {

		// let addforwardreply through - we might have been denied access
		case DPSP_MSG_ADDFORWARDREPLY:
		// let DPSP_MSG_ENUMPLAYERSREPLY through - we need this to get out of pending mode...
		case DPSP_MSG_ENUMPLAYERSREPLY:
		// let packets through also - they may be packetized enumplayersreplys
		case DPSP_MSG_PACKET:
		// let packet data through, if they need to pend they will pend when assembled.
		case DPSP_MSG_PACKET2_DATA:
		// let ACKs through for PACKET2 Data otherwise our send won't complete.
		case DPSP_MSG_PACKET2_ACK:
		// another version of enumplayersreply
		case DPSP_MSG_SUPERENUMPLAYERSREPLY:
		// pend other messages while waiting for player replay.
		case DPSP_MSG_REQUESTPLAYERREPLY:
		// allow challenge messages to pass through during logon
		case DPSP_MSG_CHALLENGE:
		// allow the access granted message to pass through during logon
		case DPSP_MSG_ACCESSGRANTED:
		// allow the logon denied message to pass through during logon
		case DPSP_MSG_LOGONDENIED:
		// allow the authentication error message to pass through during logon
		case DPSP_MSG_AUTHERROR:
		// allow the key exchange reply to pass through during logon
		case DPSP_MSG_KEYEXCHANGEREPLY:
            return FALSE;
			
        // put all other messages on the pending list
        default:
            return TRUE;
        }
}  // PutOnPendingList

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageCommand"

/*
 ** GetMessageCommand
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pdwCommand - pointer to dwCommand to be filled in by this function
 *      pdwVersion - pointer to dwVersion to be filled in by this function
 *
 *  DESCRIPTION:
 *
 *		Extracts the command and version information from the incoming message
 *
 *
 *  RETURNS: DP_OK, DPERR_INVALIDPARAMS, DPERR_UNSUPPORTED
 *
 */

HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion)
{
    ASSERT(pdwCommand && pdwVersion);

    // initialize in case we fail
    *pdwCommand = *pdwVersion = 0;

    // extract command
	if ( (dwMessageSize < sizeof(DWORD)) || IS_PLAYER_MESSAGE(pReceiveBuffer))
	{
		*pdwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
		if (dwMessageSize < sizeof(MSG_SYSMESSAGE))
		{
			DPF(0,"message size too small - %d bytes\n",dwMessageSize);
			return DPERR_INVALIDPARAMS;
		}
		
	    *pdwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
		*pdwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);
		if (*pdwVersion < 1)
		{
			// version 1 is where we implemented on the wire versioning and extensibility
			// any pre version 1 (EUBETA 1 and prior of dplay3) bits are out of luck
			DPF_ERR("Encountered unsupported version of DirectPlay - not responding");
			return DPERR_UNSUPPORTED;
		}
	}

    return DP_OK;
} // GetMessageCommand

#ifdef DEBUG
void ValidateDplay(LPDPLAYI_DPLAY gpThisList)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerCheck;
	LPDPLAYI_GROUP pGroup,pGroupCheck;
	LPDPLAYI_DPLAY this = gpThisList;
	
	while (this)
	{
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			pPlayerCheck = PlayerFromID(this,pPlayer->dwID);
			if (!VALID_DPLAY_PLAYER(pPlayerCheck))
			{
				DPF_ERR("found invalid player in player list");
				ASSERT(FALSE);
			}
			pPlayer = pPlayer->pNextPlayer;
		}

		pGroup = this->pGroups;
		while (pGroup)
		{
			pGroupCheck = GroupFromID(this,pGroup->dwID);
			if (!VALID_DPLAY_GROUP(pGroupCheck))
			{
				DPF_ERR("found invalid group in group list");			
				ASSERT(FALSE);
			}
			pGroup = pGroup->pNextGroup;
		}

		this = this->pNextObject;
	} // this

} // ValidateDplay
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalHandleMessage"


//	a-josbor: a little routine for updating chatter count
VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_PLAYER pSysPlayer;
		
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (VALID_DPLAY_PLAYER(pPlayer) && !(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		// get the sys player for this player.  It's the only
		//	one who gets pinged
		pSysPlayer = PlayerFromID(this, pPlayer->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer))
		{
			pSysPlayer->dwChatterCount++;
			DPF(9,"++Chatter for Player %d == %d\n", pPlayer->dwIDSysPlayer, pSysPlayer->dwChatterCount);
		}
	}
}
/*
 ** InternalHandleMessage
 *
 *  CALLED BY: DP_SP_HandleMessage and other internal dplay functions.
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *      dwSendFlags - flags that were passed to SP_Send (e.g. DPSEND_ENCRYPTED).  used
 *					by security code to process messages that are delivered locally w/o
 *					needing to route them through the nameserver
 *
 *  DESCRIPTION:
 *
 *		This function routes a message to the appropriate handler.
 *
 *
 *  RETURNS: handler return
 *
 */

HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwSendFlags)
{
    HRESULT hr=DP_OK;
    DWORD dwCommand;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	DWORD dwIDTo,dwIDFrom; 
	LPDPLAYI_DPLAY this;
	DWORD dwVersion; // version of the message we received
    DPID dpidFrom=0;
	
    ENTER_DPLAY();
	
#ifdef DEBUG	
	// make sure dplay is a happy place
	ValidateDplay(gpObjectList);
#endif // DEBUG
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		// see if dplay is closed?
		if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		{
            LEAVE_DPLAY();
 			DPF(5,"dplay closed - ignoring messages");
            return DP_OK;
		}

		if (!VALID_STRING_PTR(pReceiveBuffer,dwMessageSize)) 
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid buffer!");
            return DPERR_INVALIDPARAMS;
		}

		if ((DPSP_HEADER_LOCALMSG != pvSPHeader) && 
            (pvSPHeader) && (!VALID_STRING_PTR(pvSPHeader,this->dwSPHeaderSize)))
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid header!");
            return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

    // Get the command and version information from the message
    hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
        LEAVE_DPLAY();
        return hr;
    }

    // if it is a secure message
    if ((DPSP_MSG_SIGNED == dwCommand))
    {
        LPMSG_SECURE pSecureMsg = (LPMSG_SECURE)pReceiveBuffer;

        // Verify the secure message:
        // if signed, verify the signature
        // if encrypted, decrypt the message in place
        hr = VerifyMessage(this, pReceiveBuffer, dwMessageSize);
        if (FAILED(hr))
        {
            DPF(0,"Secure message verification failed - dropping message: hr=0x%08x",hr);
            LEAVE_DPLAY();
            return DP_OK;
        }

        // Message was OK
        if (DPSP_MSG_SIGNED == dwCommand) 
        {
            dwSendFlags |= DPSEND_SIGNED;
        }

		if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
        {
            dwSendFlags |= DPSEND_ENCRYPTED;
        }

        dpidFrom = pSecureMsg->dwIDFrom;

        // point to the embedded message (excluding the sp header)
        pReceiveBuffer = (LPBYTE)pSecureMsg+ pSecureMsg->dwDataOffset + this->dwSPHeaderSize;
        dwMessageSize = pSecureMsg->dwDataSize - this->dwSPHeaderSize;
        // Get the command and version information for this message
        hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }

    // regulate messages, if session is secure
    if (SECURE_SERVER(this))
    {
        if (dwSendFlags & DPSEND_PENDING)
        {
			// message is from the pending queue

			ASSERT(this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING);
			// safe to process...
        }
        else
        {
            // message just came off the wire

			// make sure it is ok to process this message
            if ((DPSP_HEADER_LOCALMSG != pvSPHeader) &&
                !(dwSendFlags & (DPSEND_SIGNED|DPSEND_ENCRYPTED)) &&
                !PermitMessage(dwCommand,dwVersion))
            {
                // no
                DPF(1,"ignoring unsigned message dwCommand=%d dwVersion=%d",dwCommand,dwVersion);
                LEAVE_DPLAY();
                return DP_OK;
            }
        }
    }

    // If we are in pending mode (waiting for the nametable or waiting for a guaranteed 
    // send to complete), allow only certain messages to be processed immediately - all 
    // others go on the pending list
	if ((this->dwFlags & DPLAYI_DPLAY_PENDING) && !(dwSendFlags & DPSEND_PENDING))
    {
        if (PutOnPendingList(this, dwCommand))
	    {
	    	if(this->pProtocol){
		    	// Before we pend this command we need to tell the protocol if a player
		    	// has been deleted.  We want to stop any ongoing sends now.
		    	if(dwCommand == DPSP_MSG_DELETEPLAYER){
		    		LPMSG_PLAYERMGMTMESSAGE pmsg=(LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
		    		if(dwMessageSize < offsetof(MSG_PLAYERMGMTMESSAGE, dwPasswordOffset)){
		    			DPF(1,"SECURITY WARN: Invalid DeletePlayer received, ignoring\n");
		    			hr=DPERR_GENERIC;
		    			return hr;
		    		}
		    		if(PlayerFromID(this,pmsg->dwPlayerID))
		    		{
			    		ProtocolPreNotifyDeletePlayer(this, pmsg->dwPlayerID);
			    	} else {
			    		DPF(1,"pending deleteplayer message for id %x, not valid player\n",pmsg->dwPlayerID);
			    	}
		    	}
	    	}
	    	// Pend the command.
			dwSendFlags |= DPSEND_PENDING;
			DPF(7,"Pushing message [%d] on the pending queue",dwCommand);
		    hr =  PushPendingCommand(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
		    LEAVE_DPLAY();
		    return hr;
	    }
    }
	
	// if we reach here pending stuff is done, so clear the flag
	dwSendFlags &= ~DPSEND_PENDING;

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nReceiveBPS += dwMessageSize;
		this->pPerfData->nReceivePPS++;
	}
	
	DPF(8,"handler - received command %d, version %d\n",dwCommand,dwVersion);


	// a-josbor: unfortunately, not all messages have a dwFrom field,
	//	so we need to case out all the ones that do, and increment
	//	the chatter count for the sending player.  NOTE! this means
	//	that you should add this call to any new message types that
	//	come along and have a dwFrom field.
    switch (dwCommand)											 
    {
		// these messages should only go to namesrvr
        case DPSP_MSG_ENUMSESSIONS:															
                
                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR)) 
				{
					DPF(1,"namesrvr - got enumsessions request");
					hr = NS_HandleEnumSessions(this,pvSPHeader,pReceiveBuffer,dwMessageSize,dwSendFlags);
				}
	                
                break;
        
        case DPSP_MSG_ENUMPLAYER:

                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got enumplayers request from system version %d",dwVersion);
					hr = NS_HandleEnumPlayers(this,pvSPHeader,dpidFrom,dwVersion);
                }

                break;

	   	case DPSP_MSG_REQUESTGROUPID:
        case DPSP_MSG_REQUESTPLAYERID: 
				
				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
                    DWORD dwFlags=0;
                    BOOL fCheckPlayerFlags = FALSE;

					DPF(1,"namesrvr - got newplayerid request");

                    // look for flags if version is later than DX3
                    if (DPSP_MSG_DX3VERSION != dwVersion)
                    {
                    	if(dwMessageSize < sizeof(MSG_REQUESTPLAYERID)){
                    		DPF(1,"SECURITY WARN: Invalid player id request, no flags field");
                    		break;
                    	}
                        dwFlags = ((LPMSG_REQUESTPLAYERID)pReceiveBuffer)->dwFlags;
                        fCheckPlayerFlags = TRUE;
                    }
					hr = NS_HandleRequestPlayerID(this,pvSPHeader,dwCommand, dwFlags, 
                        fCheckPlayerFlags,dwVersion);
				}
				
				break;

		case DPSP_MSG_ADDFORWARDREQUEST:

				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got forward add player request");
					hr = NS_HandleAddForwardRequest(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dpidFrom);
				}
				else 
				{
					ASSERT(FALSE); // only namesrvr should get this!
				}
				
				break;

		// handle reply from nameserver
		case DPSP_MSG_ENUMSESSIONSREPLY :

				DPF(1,"got enumsessions reply");
				hr = HandleEnumSessionsReply(this,pReceiveBuffer,dwMessageSize,pvSPHeader);

				break;

		case DPSP_MSG_REQUESTPLAYERREPLY: 
		case DPSP_MSG_SUPERENUMPLAYERSREPLY:				
		case DPSP_MSG_ENUMPLAYERSREPLY:
        case DPSP_MSG_ADDFORWARDREPLY:

				hr = HandleReply(this, pReceiveBuffer, dwMessageSize, dwCommand, pvSPHeader);
                break;

		case DPSP_MSG_PLAYERDATACHANGED: 
		case DPSP_MSG_GROUPDATACHANGED:
		case DPSP_MSG_PLAYERNAMECHANGED:
		case DPSP_MSG_GROUPNAMECHANGED:
		case DPSP_MSG_SESSIONDESCCHANGED:		
		case DPSP_MSG_CREATEPLAYER:
		case DPSP_MSG_DELETEPLAYER:
		case DPSP_MSG_ADDPLAYERTOGROUP:
 		case DPSP_MSG_DELETEPLAYERFROMGROUP:
		case DPSP_MSG_CREATEGROUP:
		case DPSP_MSG_DELETEGROUP:
		case DPSP_MSG_NAMESERVER:
		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:
		case DPSP_MSG_CREATEPLAYERVERIFY:

				if (!this->lpsdDesc)
				{
					DPF(4,"received player mgmt message - no session open - ignoring");
					break;
				}
								
				hr =  SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwMessageSize,pvSPHeader);
				break;

		case DPSP_MSG_MULTICASTDELIVERY:
				{
					// transmogrify this into a player-group message
					// we currently have
					//   play xx xx xx xx 
					//	DPID  idGroupTo;
					//	DPID  idPlayerFrom;
					//	DWORD dwMessageOffset;
					// we need 
					//  DPID  idFrom
					//  DPID  idTo
					//  CHAR  Message[]
					//  we will do this by going to dwMessageOffset, and working backwards
					//  to build the correct header and then re-indicating...
					LPMSG_PLAYERMESSAGE pPlayerMessage;
					LPMSG_MULTICASTDELIVERY pMulticastDelivery;
					DWORD  dwPlayerMessageSize;
					DPID  idGroupTo;
					DPID  idPlayerFrom;
					
					DWORD dwMessageOffset;
					DWORD dwMulticastCommand=DPSP_MSG_PLAYERMESSAGE;

					pMulticastDelivery = (LPMSG_MULTICASTDELIVERY)pReceiveBuffer;

					// SECURITY - verify message.
					if(dwMessageSize < sizeof(MSG_ASK4MULTICAST)){
						DPF(1,"SECURITY WARN: Invalid Multicast Delivery message");
						break;
					}

					idGroupTo		   = pMulticastDelivery->idGroupTo;
					idPlayerFrom	   = pMulticastDelivery->idPlayerFrom;
					dwMessageOffset    = pMulticastDelivery->dwMessageOffset;

					// SECURITY - offset must be past base message and be at least 1 byte
					if(dwMessageOffset < sizeof(MSG_ASK4MULTICAST) || dwMessageOffset+1 < dwMessageSize){
						DPF(1,"SECURITY WARN: Invalid contained Multicast Delivery message, must be at least 1 byte");
						break;
					}

					hr=GetMessageCommand(this, pReceiveBuffer+dwMessageOffset, dwMessageSize-dwMessageOffset, &dwMulticastCommand, &dwVersion);

					if(dwMulticastCommand==DPSP_MSG_PLAYERMESSAGE){
						// Its a player message, make it look like one, prepend From/To
						pPlayerMessage         = (LPMSG_PLAYERMESSAGE)(pReceiveBuffer+dwMessageOffset-sizeof(MSG_PLAYERMESSAGE));
						pPlayerMessage->idFrom = idPlayerFrom;
						pPlayerMessage->idTo   = idGroupTo;
						dwPlayerMessageSize    = dwMessageSize - dwMessageOffset + sizeof(MSG_PLAYERMESSAGE);
						hr=InternalHandleMessage(pISP,(PCHAR)pPlayerMessage,dwPlayerMessageSize,pvSPHeader,dwSendFlags);
					} else {
						// Its a system message already, just pass it on.
						hr=InternalHandleMessage(pISP,pReceiveBuffer+dwMessageOffset, dwMessageSize-dwMessageOffset, pvSPHeader, dwSendFlags);
					}
				}
				break;

		case DPSP_MSG_PLAYERWRAPPER:

				DPF(2,"got wrapped player message...");

				// SECURITY - don't need to verify here, wrapper must be good, or we wouldn't be here.
				
				// strip off the wrapper
			   	pReceiveBuffer += sizeof(MSG_SYSMESSAGE);
				dwMessageSize -= sizeof(MSG_SYSMESSAGE);
				// fall through...
				
		case DPSP_MSG_PLAYERMESSAGE:
			{
				BOOL bToGroup = FALSE; // message is to a group	?
				
				if (!this->lpsdDesc)
				{
					DPF_ERR("player - player message thrown away - session closed");
					break;
				}

				
				if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
				{
					// SECURITY: make sure we really have enough buffer.
					if(dwMessageSize < sizeof(MSG_PLAYERMESSAGE)+1){
						DPF(1,"SECURITY WARN: Received player message that is too small to have too/from id's and data");
						break;
					}
				
					// a-josbor: increment our chatter count
					// note, we can only do this if we have a from id
					dwIDFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;

					// make sure it's from a valid player					
					pPlayer = PlayerFromID(this,dwIDFrom);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF(0,"----received player message FROM invalid player id = %d!!",dwIDFrom);
						break;
			        }
			        
					UpdateChatterCount(this, dwIDFrom);

					// see who the message is for
					dwIDTo = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idTo;
					pPlayer = PlayerFromID(this,dwIDTo);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
			        	// see if it's to a group
						pGroup = GroupFromID(this,dwIDTo);
						if (!VALID_DPLAY_GROUP(pGroup))
						{
							DPF(0,"----received player message TO invalid id = %d!!",dwIDFrom);
							break;
						}
						bToGroup = TRUE;
						pPlayer = (LPDPLAYI_PLAYER)pGroup;
					}
				}
				else 
				{	// message is raw

					if (dwSendFlags & DPSEND_SIGNED)
					{
						ASSERT(FALSE);
						DPF_ERR("A signed player message arrived raw - dropping message");
						hr = DPERR_UNSUPPORTED;
						break;
					}

					pPlayer = GetRandomLocalPlayer(this);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF_ERR("could not find local player to deliver naked message to");
						break;
			        }
				}
				if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
				{
					// ignore it					
				}
				else 
				{
					if (bToGroup)
					{
						hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
							dwMessageSize,TRUE,dwSendFlags);						
					} 
					else 
					{
						hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
							TRUE,dwSendFlags);
					}
				}
			
			}  // DPSP_MSG_PLAYERMESSAGE:

			break;
				
		case DPSP_MSG_PACKET:

				if (!this->lpsdDesc)
				{
					DPF_ERR("packet thrown away - session closed");
					break;
				}
		
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;

		case DPSP_MSG_PACKET2_DATA:
		case DPSP_MSG_PACKET2_ACK:
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;
	
		case DPSP_MSG_PING:
		case DPSP_MSG_PINGREPLY:
	
				if (!this->lpsdDesc)
				{
					DPF_ERR("ping thrown away - session closed");
					break;
				}

				if(dwMessageSize < sizeof(MSG_PING)){
					DPF(1,"SECURITY WARN: received invalid PING message");
					break;
				}
				// a-josbor: update our chatter count
				dwIDFrom = ((LPMSG_PING)pReceiveBuffer)->dwIDFrom;
				UpdateChatterCount(this, dwIDFrom);

				hr = HandlePing(this,pReceiveBuffer,pvSPHeader);
				break;
				
		case DPSP_MSG_YOUAREDEAD:
				
				// as of DX5a, this message is no longer being sent.  there was
				// a race condition that could cause all players in the session 
				// to be disconnected.  
				DPF_ERR("UH OH, SOMEONE IN THE GAME THINKS I'M DEAD");
			
				// ISSUE: should we do this regardless of whether we think
				// we're the host (consider if the game has become fragmented...)
				if (!IAM_NAMESERVER(this))hr = HandleSessionLost(this);
			
				break;

            // @@@@@@@@@@@@@@@@@@@@@@@@ SECURITY @@@@@@@@@@@@@@@@@@@@@@
            //
            // Client side messages
            //
        case DPSP_MSG_CHALLENGE:
            this->LoginState = DPLOGIN_PROGRESS;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_ACCESSGRANTED:
            //
            // Receive server's OK on our authentication request
            //
            this->LoginState = DPLOGIN_ACCESSGRANTED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_LOGONDENIED:
            this->LoginState = DPLOGIN_LOGONDENIED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_AUTHERROR:
            this->LoginState = DPLOGIN_ERROR;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed 
			return hr;
            break;

		case DPSP_MSG_KEYEXCHANGEREPLY:
            this->LoginState = DPLOGIN_KEYEXCHANGE;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
            return hr;
			break;

            //
            // Server side messages
            //
        case DPSP_MSG_NEGOTIATE:
            hr = SendAuthenticationResponse(this, (LPMSG_AUTHENTICATION)pReceiveBuffer, dwMessageSize, pvSPHeader);
            break;

        case DPSP_MSG_CHALLENGERESPONSE:
            hr = SendAuthenticationResponse (this, (LPMSG_AUTHENTICATION)pReceiveBuffer, dwMessageSize, pvSPHeader);
            break;

		case DPSP_MSG_KEYEXCHANGE:
			hr = SendKeyExchangeReply(this, (LPMSG_KEYEXCHANGE)pReceiveBuffer, dwMessageSize, dpidFrom, pvSPHeader);
			break;

        // @@@@@@@@@@@@@@@@@@@@@@@@ END SECURITY @@@@@@@@@@@@@@@@@@@@@@
		
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			dwSendFlags |= DPSEND_GUARANTEED;

			// a-josbor: update our chatter count
			if(dwMessageSize < sizeof(MSG_ASK4MULTICAST)){
				DPF(1,"SECURITY WARN: ASK4MULTICASTGUARANTEED, message too short");
				break;
			}
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
		
		case DPSP_MSG_ASK4MULTICAST:

			if(dwMessageSize < sizeof(MSG_ASK4MULTICAST)){
				DPF(1,"SECURITY WARN: ASK4MULTICAST, message too short");
				break;
			}
			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
			
		case DPSP_MSG_CHAT:

			if(dwMessageSize < sizeof(MSG_CHAT)){
				DPF(1,"SECURITY WARN: MSG_CHAT, message too short");
				break;
			}
			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_CHAT)pReceiveBuffer)->dwIDFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = HandleChatMessage(this, pReceiveBuffer, dwMessageSize);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}
			break;

		case DPSP_MSG_DIEPIGGY:
		
			DPF_ERR("  THIS IS ONE DEAD PIGGY.  CALL ANDYCO x62693 ");
#ifdef DIE_PIG			
			DEBUG_BREAK();
#endif 
			
			break;
			
		case DPSP_MSG_ADDFORWARD:
			if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
				DPLAYI_PLAYER_NAMESRVR))
			{
				DPF(1, "Hey! I got an ADDFORWARD, but I'm the NameServer!  Something's wrong...");
			}

			hr = SP_HandleAddForward(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dpidFrom,dwVersion);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;
			
		case DPSP_MSG_ADDFORWARDACK:
			hr = NS_HandleAddForwardACK(this,(LPMSG_ADDFORWARDACK)pReceiveBuffer,dwMessageSize);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

		case DPSP_MSG_IAMNAMESERVER:
			hr = NS_HandleIAmNameServer(this, (LPMSG_IAMNAMESERVER)pReceiveBuffer, dwMessageSize, pvSPHeader);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

		case DPSP_MSG_VOICE:
			hr=HandleVoiceMessage(this, pReceiveBuffer, dwMessageSize, dwSendFlags);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}
			break;

        default:																   
                DPF(1,"received unrecognized command - %d\n",dwCommand);
                break;
    }
	
    LEAVE_DPLAY();
	// always return DP_OK here, since the sp shouldn't be handling our internal
	// errors
    return DP_OK;

} // InternalHandleMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_HandleMessage"

/*
 ** DP_SP_HandleMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		when an sp receives a message, it calls this fn. this is where dplay receives data.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;

    ENTER_DPLAY();
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if we're closing, don't handle any messages.  Fail silently
	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
	{
		DPF(8,"In HandleMessage after call to Close.  Ignoring...");
		LEAVE_DPLAY();
		return DP_OK;
	}
		
	if(this->pProtocol){
		LEAVE_DPLAY();
		// Protocol might want this, check, returns DPERR_NOTHANDLED if not wanted.
		hr=DP_SP_ProtocolHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader);
	} else {
		// no protocol, force InternalHandleMessage.
		hr=DPERR_NOTHANDLED;
		LEAVE_DPLAY();
	}

	if(hr==DPERR_NOTHANDLED){
		// Protocol didn't consume the receive, tell regular handler.
		hr=InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);
	}
	
	return hr;

} // DP_SP_HandleMessage

/*
 ** DP_SP_HandleNonProtocolMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		We are sending a message to ourselves, so don't let the protocol crack it.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	return InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);

} // DP_SP_HandleNonProtocolMessage

VOID QueueMessageNodeOnReceiveList(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn, LPDPLAYI_PLAYER pPlayer)
{
	ENTER_DPLAY();
	
	this->nMessages++;

	pmsn->pNextMessage=NULL;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}
	
	// if player has event, trigger it-- ISSUE:need refcount on player!
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	LEAVE_DPLAY();
	
}

VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{

	psp->msn.pMessage = (LPVOID)&psp->dwType;
	psp->msn.dwMessageSize = sizeof(DPMSG_SENDCOMPLETE);
	psp->msn.idFrom = DPID_SYSMSG;
	psp->msn.idTo = psp->idFrom;
	psp->dwType=DPSYS_SENDCOMPLETE;
	QueueMessageNodeOnReceiveList(this, &psp->msn, psp->pPlayerFrom);
}

/*
 ** DP_SP_SendComplete
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP             - direct play int pointer
 *      lpDPContext      - context we gave for the send
 *      CompletionStatus - status of the send
 *
 *  DESCRIPTION:
 *
 *		When an asynchronous message is completely sent, the SP calls us back to notify us.
 *
 *
 *  RETURNS: none.
 *
 */

VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus)
{
	PSENDPARMS psp;

	LPDPLAYI_DPLAY this;

    ENTER_DPLAY();

	this = DPLAY_FROM_INT(pISP);

	psp=pspFromContext(this, lpDPContext,FALSE); 	
									//		|
									// Completion has a refcount, don't need another.

	ASSERT(psp);

	if(psp) {

		EnterCriticalSection(&psp->cs);
		
		psp->nComplete++;
		
		// Status set to DP_OK in Send call, if we get a different status, update it.
		// Note, the last non-ok status is the one returned.
		// Group sends are always ok unless out of memory!
		if((CompletionStatus != DP_OK) && ((!psp->pGroupTo)||(psp->pGroupTo && CompletionStatus==DPERR_NOMEMORY)) ){
			psp->hr=CompletionStatus;
		}
		
		LeaveCriticalSection(&psp->cs);
		
		pspDecRef(this, psp); // if ref hits zero, posts completion to application.

	} else {
		DPF(0,"ERROR:completion of already reassigned context?\n");
		ASSERT(0);
	}
	
	LEAVE_DPLAY();
	
	return;
} // DP_SP_HandleMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\superpac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SuperPack.c
 *  Content:	SuperPacks / unSuperPacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  4/16/97		andyco	created it
 *  6/22/97     sohailm updated to use pClientInfo.
 *  8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 ***************************************************************************/

 /**************************************************************************
 *
 * SuperPacked player format :                                            
 *
 *	fixed fields
 *		dwFixedSize - size of fixed struct
 *		dwFlags - player or group flags (DPLAYI_
 *		DPID - the id of the player or group
 *		dwMask - bitfield indicating which optional fields are present
 *	
 *	optional fields
 *		dwVersion - version of player - present if dwFlags & DPLAYI_PLAYER_SYSPLAYER
 *		idSysPlayer - present if ! (dwFlags & DPLAYI_PLAYER_SYSPLAYER)
 *		dwSPDataSize 
 *		pvSPData 
 *		dwPlayerDataSize
 *		pvPlayerData
 *		pszShortName
 *		pszLongName
 *		dwNPlayers - # players in a group
 *		dwNGroupGroups - the number of contained groups in a group
 *
 *	after all the packed players and groups comes a list of linked groups 
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"SuperSuperPack! -- "

// offsets within mask of fields
#define SHORTSTR 	0 // 1 bit - string or not
#define LONGSTR 	1 // 1 bit - string or not
#define	SPDATA		2 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	PLAYERDATA	4 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define NPLAYERS	6 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	IDPARENT	8 // 1 bit - present or not
#define SHORTCUTS	9 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size

// constants used to define whether we've written a value into our buffer using a 
// byte, word, or dword
#define SIZE_BYTE	1
#define SIZE_WORD	2
#define SIZE_DWORD	3

// used to determine if the size fits in byte, word or dword
#define BYTE_MASK 0xFFFFFF00
#define WORD_MASK 0xFFFF0000

// extract dwBits bits from the dword dwMask, from loc'n dwOffset
DWORD GetMaskValue(DWORD dwMask,DWORD dwOffset,DWORD dwBits)
{
	DWORD rval;
	
	// shift it right to shift off right most bits
	rval = dwMask >> dwOffset;
	
	// shift it left to shift off left most bits
	rval = rval << (32 - dwBits);
	
	// shitf it back to right align rval
	rval = rval >> (32 - dwBits);	

	return rval;
		
} // GetMaskValue

HRESULT GetSize(LPBYTE * ppBufferIndex,DWORD *pdwBufferSize,DWORD dwMaskValue,DWORD *prval)
{

	switch (dwMaskValue)
	{
		// trim any extra bits, and advance ppBufferIndex as necessary
		case SIZE_BYTE:
			if(!*pdwBufferSize){goto error_exit;}
			*prval = *((BYTE *)(*ppBufferIndex));			
			*ppBufferIndex += sizeof(BYTE);
			*pdwBufferSize -= sizeof(BYTE);
			break;
		case SIZE_WORD:
			if(*pdwBufferSize < sizeof(WORD)){goto error_exit;}
			*prval = *((WORD *)(*ppBufferIndex));			
			*ppBufferIndex += sizeof(WORD);			
			*pdwBufferSize -= sizeof(WORD);
			break;
		case SIZE_DWORD:
			if(*pdwBufferSize < sizeof(DWORD)){goto error_exit;}
			*prval = *((DWORD *)(*ppBufferIndex));			
			*ppBufferIndex += sizeof(DWORD);			
			*pdwBufferSize -= sizeof(DWORD);
			break;
		default:
			ASSERT(FALSE);
			break;
	}	
	
	return DP_OK;

error_exit:
	return DPERR_GENERIC;
	
} // GetSize

/*
 ** UnSuperpackPlayer
 *
 *  CALLED BY: UnSuperpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *      bVerifyOnly - only verify buffer is reasonable (SECURITY ADDITION)
 *		ppBuffer - set to end of packed player in buffer
 *
 *  DESCRIPTION: UnSuperpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnSuperpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked, DWORD cbBuffer,
	LPVOID pvSPHeader,BOOL bPlayer,BOOL bVerifyOnly, LPBYTE * ppBuffer)
{
    LPWSTR lpszShortName, lpszLongName;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex;
    LPBYTE pBufferEnd;
	HRESULT hr;
	DWORD dwMaskValue;
	DWORD dwPlayerDataSize=0,dwSPDataSize=0;
	DWORD dwVersion,dwIDSysPlayer;
	BOOL fSizeOnly = FALSE;
	DPID idParent = 0;
	DWORD cbBufferRemaining;

	cbBufferRemaining = cbBuffer;

	if(pSuperPacked->dwFixedSize > cbBuffer || pSuperPacked->dwFixedSize < sizeof(DPLAYI_SUPERPACKEDPLAYER)){
		DPF(1,"SECURITY WARN: Superpacked player w/invalid dwFixedSize field\n");
		return DPERR_GENERIC;
	}
	
	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	cbBufferRemaining -= pSuperPacked->dwFixedSize;
	
	if (pSuperPacked->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// system player - get version
		hr=GetSize(&pBufferIndex,&cbBufferRemaining,SIZE_DWORD,&dwVersion);
		if(FAILED(hr)){DPF(1,"SECURITY WARN: Corrupt superpackedplayer Version\n");goto error_exit;}
		dwIDSysPlayer = pSuperPacked->dwID;
	}
	else 
	{
		// non system player - get system player
		hr=GetSize(&pBufferIndex,&cbBufferRemaining,SIZE_DWORD,&dwIDSysPlayer);
		if(FAILED(hr)){DPF(1,"SECURITY WARN: Corrupt superpackedplayer SystemPlayerid\n");goto error_exit;}
		dwVersion = 0; // todo - do we need version on non-sysplayer?
	}
	
	if (this->pSysPlayer && (this->pSysPlayer->dwID == dwIDSysPlayer))
	{
		// skip this player - it's our own system player
		fSizeOnly = TRUE; 
	}

	// short name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTSTR,1);
	if (dwMaskValue)
	{
		DWORD cbShortName;
		if(!cbBufferRemaining){
			DPF(1,"SECURITY WARN: Corrupt SuperPackedPlayer ShortName\n"); hr=DPERR_GENERIC; goto error_exit;
		}
		lpszShortName = (WCHAR *)(pBufferIndex);
		cbShortName = WSTRNLEN_BYTES(lpszShortName,cbBufferRemaining,TRUE);
		cbBufferRemaining -= cbShortName;
		pBufferIndex += cbShortName;
	}
	else lpszShortName = NULL;

	// long name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,LONGSTR,1);
	if (dwMaskValue)
	{
		DWORD cbLongName;
		if(!cbBufferRemaining){
			DPF(1,"SECURITY WARN: Corrupt SuperPackedPlayer LongName\n"); hr=DPERR_GENERIC; goto error_exit;
		}
		lpszLongName = (WCHAR *)(pBufferIndex);
		cbLongName = WSTRNLEN_BYTES(lpszLongName,cbBufferRemaining,TRUE);
		cbBufferRemaining -= cbLongName;
		pBufferIndex += cbLongName;
	}
	else lpszLongName = NULL;

	memset(&PlayerName,0,sizeof(DPNAME));
	PlayerName.dwSize = sizeof(DPNAME);
	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;

	// player data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,PLAYERDATA,2);
	if (dwMaskValue)
	{
		hr = GetSize(&pBufferIndex,&cbBufferRemaining,dwMaskValue,&dwPlayerDataSize);
		if(FAILED(hr)||dwPlayerDataSize>cbBufferRemaining)
			{DPF(1,"SECURITY WARN: Corrupt superpackedplayer PlayerData\n");goto error_exit;}
		pvPlayerData = pBufferIndex;
		cbBufferRemaining -= dwPlayerDataSize;
		pBufferIndex += dwPlayerDataSize;
	}
	else pvPlayerData = NULL;

	// sp data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SPDATA,2);
	if (dwMaskValue)
	{
		hr = GetSize(&pBufferIndex,&cbBufferRemaining,dwMaskValue,&dwSPDataSize);
		if(FAILED(hr)||dwSPDataSize>cbBufferRemaining)
			{DPF(1,"SECURITY WARN: Corrupt superpackedplayer SPData\n");goto error_exit;}
		pvSPData = pBufferIndex;
		cbBufferRemaining -= dwSPDataSize;
		pBufferIndex += dwSPDataSize;
	}
	else pvSPData = NULL;

	// player is not local
	pSuperPacked->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	// id Parent?
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,IDPARENT,1);
	if (dwMaskValue)
	{
		ASSERT(!bPlayer);
		hr = GetSize(&pBufferIndex, &cbBufferRemaining, SIZE_DWORD, &idParent);
		if(FAILED(hr))
			{DPF(1,"SECURITY WARN: Corrupt superpackedplayer(group) idParent\n");goto error_exit;}
	}

	// if it's a player, this is the end of the packed buffer
	*ppBuffer = pBufferIndex;	
	
	if (fSizeOnly)
	{
		ASSERT(bPlayer); // only should happen w/ our own sysplayer
		return DP_OK;
	}

	if(bVerifyOnly && !bPlayer){
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList = (LPDWORD)pBufferIndex;
		DWORD dwPlayerID;
		
		dwMaskValue = GetMaskValue(pSuperPacked->dwMask,NPLAYERS,2);
		// just to verify
		if (dwMaskValue)
		{
			hr = GetSize(&pBufferIndex,&cbBufferRemaining,dwMaskValue,&nPlayers);
			if(FAILED(hr)){
				DPF(1,"SECURITY WARN: Corrupt superpackedplayer(group) nPlayers\n");
				goto error_exit;
			}
		}
		else nPlayers = 0;

		if(cbBufferRemaining < nPlayers * sizeof(dwPlayerID)){
			DPF(1,"SECURITY WARN: Corrupt superpackedplayer (group) not enough players in message\n");
			goto error_exit;
		}

		return DP_OK;
		
	}

	if(bVerifyOnly){
		return DP_OK;
	}

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,NULL,0);
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,idParent,0);
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = dwIDSysPlayer;
	pNewPlayer->dwVersion = dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}

	if (dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = dwSPDataSize;
	
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pSuperPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the phContext from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,dwSPDataSize,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader,dwSPDataSize);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on UnSuperpack
	}

	// if it's a group, UnSuperpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList = (LPDWORD)pBufferIndex;
		DWORD dwPlayerID;

		if (idParent)
		{
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,idParent,
				pNewPlayer->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}
		
		dwMaskValue = GetMaskValue(pSuperPacked->dwMask,NPLAYERS,2);
		if (dwMaskValue)
		{
			hr=GetSize(&pBufferIndex,&cbBufferRemaining,dwMaskValue,&nPlayers);
			if(FAILED(hr)){
				// note, this should never happen, as the buffer should have been verified earlier.
				DPF(1,"SECURITY WARN: bad buffer in unsuperpackplayer?\n");
			}
			pdwIDList = (LPDWORD)pBufferIndex;
		}
		else nPlayers = 0;

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pSuperPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		*ppBuffer = (LPBYTE)pdwIDList;	
	// all done!
	} // !bPlayer

error_exit:
	return hr;

}// UnSuperpackPlayer

HRESULT UnSuperpackShortcuts(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked, DWORD cbBuffer, 
	BOOL bVerifyOnly, LPBYTE * ppBuffer)
{
    LPBYTE pBufferIndex;
	HRESULT hr;
	DWORD dwMaskValue;
	LPDWORD pdwBufferIndex;
	DWORD nShortcuts = 0;
	DWORD i;
	DPID idShortcut;
	DWORD cbBufferRemaining;

	cbBufferRemaining = cbBuffer;

	if(pSuperPacked->dwFixedSize > cbBuffer || pSuperPacked->dwFixedSize < sizeof(DPLAYI_SUPERPACKEDPLAYER)){
		DPF(1,"SECURITY WARN: Superpacked shortcuts w/invalid dwFixedSize field\n");
		return DPERR_GENERIC;
	}

	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	cbBufferRemaining -= pSuperPacked->dwFixedSize;

	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTCUTS,2);
	
	if (dwMaskValue)
	{
		hr = GetSize(&pBufferIndex,&cbBufferRemaining,dwMaskValue,&nShortcuts);
		if(FAILED(hr)){
			DPF(1,"SECURITY WARN: Corrupt superpackedplayer(group) nShortcuts\n");
			return hr;
		}
	} 
	ASSERT(nShortcuts > 0);

	if(bVerifyOnly){
		if(cbBufferRemaining < nShortcuts * sizeof(idShortcut)){
			DPF(1,"SECURITY WARN: Corrupt superpackedplayer (group) not enough shortcuts in message\n");
			return hr;
		}
		return DP_OK;
	}
	
	pdwBufferIndex = (LPDWORD)pBufferIndex;
	for (i=0;i<nShortcuts ;i++ )
	{
		idShortcut = *pdwBufferIndex++;
		hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces, 
			pSuperPacked->dwID, idShortcut,DPGROUP_SHORTCUT,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	// remember where we are
	*ppBuffer = (LPBYTE)pdwBufferIndex;
	
	return DP_OK;
	
} // UnSuperpackShortcuts

/*
 ** VerifySuperPackedPlayerAndGroupList
 *
 *  CALLED BY: UnSuperpackPlayerAndGroupList
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *      dwBufferSize - size of the buffer
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *      nShortCuts - # of shortcuts in the list
 *
 *  DESCRIPTION:
 *      SECURITY addition.  Before accepting a playerlist from the wire, we need to 
 *      verify that the contents are not corrupted and won't lead us to touching memory
 *      that is not ours.  
 *
 *  RETURNS:
 *
 */

HRESULT VerifySuperPackedPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD dwBufferSize,
UINT nPlayers,UINT nGroups, UINT nShortcuts)
{
    HRESULT hr=DP_OK;
	LPDPLAYI_SUPERPACKEDPLAYER pPacked;
	
	LPBYTE pBufferIndex = pBuffer;
	LPBYTE pBufferEnd   = pBuffer+dwBufferSize;
	INT    cbRemaining  = dwBufferSize;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		// don't UnSuperpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		hr = UnSuperpackPlayer(this,pPacked,cbRemaining,NULL,TRUE,TRUE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifySuperpackPlayerAndGroupList, error in player list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}

		nPlayers --;
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackPlayer(this,pPacked,cbRemaining,NULL,FALSE,TRUE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: VerifySuperpackPlayerAndGroupList, error in group list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}
		nGroups --;
   	} 
	
	while (nShortcuts > 0)
	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackShortcuts(this,pPacked,cbRemaining,TRUE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: UnSuperpackPlayerAndGroupList, error in player list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}
		
		nShortcuts--;
	}	

error_exit:
	return hr;
}

/*
 ** UnSuperpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD dwBufferSize,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPDPLAYI_SUPERPACKEDPLAYER pPacked;
	
	LPBYTE pBufferIndex = pBuffer;
	LPBYTE pBufferEnd   = pBuffer+dwBufferSize;
	INT    cbRemaining  = dwBufferSize;

	//
	// SECURITY - need to verify the entire player and group list before attempting
	//            to unpack, otherwise we would need a way to rewind from partial 
	//            unpacking if the unpack failed late in the structure, leaving 
	//            DirectPlay in an indeterminate state.
	//
	hr = VerifySuperPackedPlayerAndGroupList(this,pBuffer,dwBufferSize,nPlayers,nGroups,nShortcuts);
	if( hr != DP_OK ){
		DPF(1,"SECURITY WARN: Player and GroupList unpack check failed, not unpacking\n");
		goto error_exit;
	}	

	// Ok, the buffers are good, actually add the players and groups to our internal tables


	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		// don't UnSuperpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		hr = UnSuperpackPlayer(this,pPacked,cbRemaining,pvSPHeader,TRUE,FALSE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: UnSuperpackPlayerAndGroupList, error in player list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}

		nPlayers --;
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackPlayer(this,pPacked,cbRemaining,pvSPHeader,FALSE,FALSE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: UnSuperpackPlayerAndGroupList, error in group list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}
		nGroups --;
   	} 
	
	while (nShortcuts > 0)
	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackShortcuts(this,pPacked,cbRemaining,FALSE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		cbRemaining = (INT)(pBufferEnd - pBufferIndex);
		if(cbRemaining < 0){
			DPF(1,"SECURITY WARN: UnSuperpackPlayerAndGroupList, error in player list");
			hr=DPERR_GENERIC;
			goto error_exit;
		}
		
		nShortcuts--;
	}	
error_exit:
	return hr;

} // UnSuperpackPlayerAndGroupList

// how mayn bytes to represent dwSize
DWORD ByteSize(DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		return sizeof(BYTE);
	}
	 
	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		return sizeof(WORD);
	}

	return sizeof(DWORD);
	
} // ByteSize

DWORD SuperPackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	
	// space 4 strings + struct + version/sysplayer id
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_SUPERPACKEDPLAYER) + sizeof(DWORD);
		
	// player + sp data need data + 1 
	if (pPlayer->dwPlayerDataSize)
	{
		dwSize += pPlayer->dwPlayerDataSize	+ ByteSize(pPlayer->dwPlayerDataSize);
	}		 

	if (pPlayer->dwSPDataSize)
	{
		dwSize += pPlayer->dwSPDataSize + ByteSize(pPlayer->dwSPDataSize);
	}

	return dwSize;

} // SuperPackedPlayerSize

DWORD SuperPackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	LPDPLAYI_SUBGROUP pSubgroup;
	UINT nShortcuts;

	// space for player stuff, plus space for group list 
	dwSize = SuperPackedPlayerSize((LPDPLAYI_PLAYER)pGroup);
	
	if (pGroup->nPlayers)
	{
		dwSize += pGroup->nPlayers*sizeof(DPID) + ByteSize(pGroup->nPlayers);
	}
	
	if (pGroup->dwIDParent)
	{
		dwSize += sizeof(DPID);
	}
	
	// see if we'll have shortcuts w/ this group
	nShortcuts = 0;
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (nShortcuts)		
	{
		// if there were shortcuts, then this group will have a packed struct, the number of shortcuts
		// and a list of shortcuts at the end
		dwSize += sizeof(DPLAYI_SUPERPACKEDPLAYER)  + ByteSize(nShortcuts) + nShortcuts*sizeof(DPID);
	}
	
	return dwSize;	
} // SuperPackedGroupSize

// returns how big the SuperPacked player structure is for the nPlayers
DWORD SuperPackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
		
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += SuperPackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += SuperPackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
} // SuperPackedBufferSize

// set some bits (dwVal) at some offset (dwOffset) in a mask (pdwMask)
// called by SuperPackPlayer  
void SetMask(LPDWORD pdwMask,DWORD dwOffset,DWORD dwVal)
{
	*pdwMask |= dwVal<<dwOffset;
} // SetMask


// writes the dwSize field into the buffer as a byte, word or dword.
// returns 1,2 or 3 for byte, word or dword
DWORD WriteSize(LPBYTE * ppBuffer,DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		*((BYTE *)*ppBuffer) = (BYTE)dwSize;
		*ppBuffer += sizeof(BYTE);
		return SIZE_BYTE;
	}

	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		*((WORD *)*ppBuffer) = (WORD)dwSize;
		*ppBuffer += sizeof(WORD);
		return SIZE_WORD;
	}

	// needs the whole mccoy
	*((DWORD *)*ppBuffer) = dwSize;
	*ppBuffer += sizeof(DWORD);

	return SIZE_DWORD;
	
} // WriteSize

// constructs a SuperPackedplayer object from pPlayer. stores result in pBuffer
// returns size of SuperPacked player
DWORD SuperPackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	int iStrLen;
	LPBYTE pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	DWORD dwMaskValue;
		
	if (!pBuffer)
	{
		return SuperPackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pPlayer->dwID;
	pSuperPacked->dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS);

	// if it's a sysplayer, set the version
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		*((DWORD *)pBufferIndex) = pPlayer->dwVersion;
	}
	else 
	{						   
		// otherwise, store the sysplayer id
		*((DWORD *)pBufferIndex) = pPlayer->dwIDSysPlayer;
	}
	pBufferIndex += sizeof(DWORD);
	
	// short name	
	if (pPlayer->lpszShortName)	
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszShortName);
		memcpy(pBufferIndex,pPlayer->lpszShortName,iStrLen);
		pBufferIndex += iStrLen;
		// set the mask bit
		SetMask(&(pSuperPacked->dwMask),SHORTSTR,1);
	}
	// next, long name
	if (pPlayer->lpszLongName)
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszLongName);
		memcpy(pBufferIndex,pPlayer->lpszLongName,iStrLen);
		pBufferIndex += iStrLen;
		SetMask(&(pSuperPacked->dwMask),LONGSTR,1);
	}

	// next, player data
	if (pPlayer->pvPlayerData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwPlayerDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),PLAYERDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += pPlayer->dwPlayerDataSize;
	}

	// finally, pack sp data
	if (pPlayer->pvSPData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwSPDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),SPDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;

	}

	if (!bPlayer)
	{
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		// parent id ?
		if (((LPDPLAYI_GROUP)pPlayer)->dwIDParent)
		{
			SetMask(&(pSuperPacked->dwMask),IDPARENT,1);
			*(((DWORD *)pBufferIndex)++) = ((LPDPLAYI_GROUP)pPlayer)->dwIDParent;
		}
		
		// next, any players in group
		if ( ((LPDPLAYI_GROUP)pPlayer)->nPlayers )
		{
			LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;

			// 1st, store the size		
			dwMaskValue = WriteSize(&pBufferIndex,((LPDPLAYI_GROUP)pPlayer)->nPlayers);
			// set the mask bits
			SetMask(&(pSuperPacked->dwMask),NPLAYERS,dwMaskValue);
			// next, write the list of player id's
			while (pGroupnode)
			{
				ASSERT(pGroupnode->pPlayer);
				*(((DWORD *)pBufferIndex)++) = pGroupnode->pPlayer->dwID;
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		} // players
		
		
	} // !bPlayer
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackPlayer

// throw the shortcuts onto the end of the biffer
DWORD SuperPackShortcuts(LPDPLAYI_GROUP pGroup,LPBYTE pBuffer)
{
	LPDPLAYI_SUBGROUP pSubgroup;
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	LPBYTE pBufferIndex;
	LPDWORD pdwBufferIndex;
	DWORD dwMaskValue;
	UINT nShortcuts = 0;  

	// 1st - see if there are any	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (!nShortcuts) return 0;
	
	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pGroup->dwID;
	pSuperPacked->dwFlags = pGroup->dwFlags;

	// stick the number of subgroups in the struct
	dwMaskValue = WriteSize(&pBufferIndex,nShortcuts);
	ASSERT(dwMaskValue>=1);
	SetMask(&(pSuperPacked->dwMask),SHORTCUTS,dwMaskValue);

	// now, add subgroup id's	
	pSubgroup = pGroup->pSubgroups;
	pdwBufferIndex= (LPDWORD)pBufferIndex;
	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			*pdwBufferIndex++ = pSubgroup->pGroup->dwID;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	
	pBufferIndex = (LPBYTE)pdwBufferIndex;
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackShortcuts

					
HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;
	
	if (CLIENT_SERVER(this))
	{
		// we should never get called for client server - that should use regular pack.c
		ASSERT(FALSE); 
		return E_FAIL; // E_DON'T_DO_THAT!
	}

	if (!pBuffer) 
	{
		*pdwBufferSize = SuperPackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
		*pdwBufferSize += SuperPackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += SuperPackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, SuperPack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += SuperPackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}
	
	// finally, superpac shortcuts
	pGroup = this->pGroups;
	while (pGroup)
	{
		pBuffer += SuperPackShortcuts(pGroup,pBuffer);
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// SuperPackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\sphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sphelp.c
 *  Content:	helper functions for sp
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	 6/6/96		andyco	created it
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/24/96		andyco	added IDirectPlaySP to EnumConnectionData
 *	6/25/96		kipo	added support for DPADDRESS and changed GetFlags
 *						to GetPlayerFlags.
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/11/96		andyco	changed guid * to refguid in createaddress.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	8/1/96		andyco	dplay keeps copy of sp's data, instead of pointer
 *	8/15/96		andyco	added local / remote to spdata
 *	1/2/97		myronth	added wrapper for CreateAddress and EnumAddress
 *	2/7/97		andyco	added get/set spdata
 *	2/18/97		kipo	fixed bugs #3285, #4638, and #4639 by checking for
 *						invalid flags correctly
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *  7/28/97		sohailm	address buffer chunks returned by EnumAddress were not
 *                      aligned.
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

// store a chunk o' data w/ a player or group, or w/ the this ptr if lpPlayer is 
// NULL
HRESULT DoSPData(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,
	DWORD dwSourceSize,DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (NULL == lpPlayer)
	{
		pvDest = this->pvSPLocalData;
		dwDestSize = this->dwSPLocalDataSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvSPLocalData;
		dwDestSize = lpPlayer->dwSPLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvSPData;
		dwDestSize = lpPlayer->dwSPDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempSPData;

			ASSERT(pvDest);
			pvTempSPData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempSPData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempSPData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (NULL == lpPlayer)
	{
		this->pvSPLocalData = pvDest;
		this->dwSPLocalDataSize = dwDestSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvSPLocalData = pvDest;
		lpPlayer->dwSPLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvSPData = pvDest;
		lpPlayer->dwSPDataSize = dwDestSize;
	}

	return DP_OK;

} // DoSPData

   
#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

//	 
// sp's can set a blob of data with a player (or group)
HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags & ~DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,lpPlayer,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set player data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData

#ifdef BIGMESSAGEDEFENSE
#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPBigMessageNotification"

void HandleSPBigMessageNotification(LPDPLAYI_DPLAY this, LPDPSP_MSGTOOBIG pBigMessageInfo)
{
	DWORD				dwCommand;
	DWORD				dwVersion;
	DWORD				dwIDFrom = 0;
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a message that's too big!\n");

 	// get the message pointer.  Let's see if we can
	// figure our who sent it and kill them
    hr = GetMessageCommand(this, pBigMessageInfo->pReceiveBuffer, 
    		pBigMessageInfo->dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
    	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		return;
    }

	switch(dwCommand)
	{
		case DPSP_MSG_SIGNED:
		{
			dwIDFrom = ((LPMSG_SECURE)pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;

		case DPSP_MSG_PLAYERMESSAGE:
		{
			if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
			{
				dwIDFrom = ((LPMSG_PLAYERMESSAGE)pBigMessageInfo->pReceiveBuffer)->idFrom;
			}
		}
		break;

		case DPSP_MSG_NEGOTIATE:
		case DPSP_MSG_CHALLENGERESPONSE:
		{
			dwIDFrom = ((LPMSG_AUTHENTICATION) pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		case DPSP_MSG_ASK4MULTICAST:
		{
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pBigMessageInfo->pReceiveBuffer)->idPlayerFrom;
		}
		break;
		default:
		   	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		break;
	}
	
//	if we got a player id, kill them
	if (dwIDFrom != 0)
	{
    	DPF(6,"In HandleSPBigMessageNotification, Identified evil sender as %d!\n", dwIDFrom);

        lpPlayer = PlayerFromID(this,dwIDFrom);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", dwIDFrom);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", dwIDFrom);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPPlayersConnectionLost"

void HandleSPPlayersConnectionLost(LPDPLAYI_DPLAY this, LPDPSP_PLAYERDEAD pBigMessageInfo)
{
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a player's connection was lost!\n");

	if (pBigMessageInfo->dwID != 0)
	{
        lpPlayer = PlayerFromID(this,pBigMessageInfo->dwID);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", pBigMessageInfo->dwID);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", pBigMessageInfo->dwID);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_HandleSPMessage"

HRESULT DPAPI DP_SP_HandleSPWarning(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	DWORD			dwOpcode;

	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	dwOpcode = *((LPDWORD) pReceiveBuffer);
 	// look at the opcode and see if we understand what the SP is trying to tell us
 	switch(dwOpcode)
 	{
 		case DPSPWARN_MESSAGETOOBIG:
 			HandleSPBigMessageNotification(this, (LPDPSP_MSGTOOBIG)pReceiveBuffer);
 		break;

 		case DPSPWARN_PLAYERDEAD:
 			HandleSPPlayersConnectionLost(this, (LPDPSP_PLAYERDEAD) pReceiveBuffer);
 		break;
 		
 		default:
 			DPF(2, "Got a SP notification that we don't understand! %d\n", dwOpcode);
 		break;
 	}


	LEAVE_DPLAY();
	return hr;
} // DP_SP_HandleSPWarning

#endif /* BIGMESSAGEDEFENSE */

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_GetSPPlayerData"
// 
// sp's can get the blob of data previously set w/ player or group
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

		if (dwFlags & ~DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}

		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	if (dwFlags & DPGET_LOCAL)
	{
		*pdwDataSize  = lpPlayer->dwSPLocalDataSize;
		*ppvData = lpPlayer->pvSPLocalData;
	}
	else 
	{
		*pdwDataSize  = lpPlayer->dwSPDataSize;
		*ppvData = lpPlayer->pvSPData;
	}
	
	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

// the sp can get the player (or group) flags (DPLAYI_PLAYER_xxx) with this call...
HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		*pdwFlags = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }
	
	*pdwFlags = lpPlayer->dwFlags;

	LEAVE_DPLAY();
	return DP_OK;
} // DPlay_GetFlags


#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateAddress"

// create address structure
HRESULT InternalCreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpguidSP, sizeof(GUID)))
		{
			DPF_ERR("invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpguidDataType, sizeof(GUID)))
		{
			DPF_ERR("invalid data GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpData, dwDataSize))
		{
			DPF_ERR("passed invalid lpData pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(ADDRESSHEADER) + dwDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create service provider chunk
		// 1st, size
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;
		// next, SP guid
		lpHeader->dpaSPChunk.guidDataType = DPAID_ServiceProvider;
		lpHeader->dpaSPChunk.dwDataSize = sizeof(GUID);
		lpHeader->guidSP = *lpguidSP;

		// create data chunk
		lpHeader->dpaAddressChunk.guidDataType = *lpguidDataType;
		lpHeader->dpaAddressChunk.dwDataSize = dwDataSize;
		memcpy((LPBYTE) lpHeader + sizeof(ADDRESSHEADER), lpData, dwDataSize);		

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateAddress"
HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateAddress(pISP, lpguidSP, lpguidDataType, lpData,
								dwDataSize, lpAddress, lpdwAddressSize);

} // CreateAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateCompoundAddress"

// create address with multiple chunks
HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize, dwTotalDataSize, i;
	LPBYTE			lpb;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpAddressElements, dwAddressElementCount * sizeof(DPCOMPOUNDADDRESSELEMENT)))
		{
			DPF_ERR("invalid address elements pointer");
			return DPERR_INVALIDPARAMS;	
		}

		dwTotalDataSize = 0;
		for (i = 0; i < dwAddressElementCount; i++)
		{
			if (!VALID_READ_PTR(lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize))
			{
				DPF_ERR("passed invalid lpData pointer");
				return DPERR_INVALIDPARAMS;	
			}
			dwTotalDataSize += lpAddressElements[i].dwDataSize;
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(DPADDRESS) + sizeof(DWORD) +
					 sizeof(DPADDRESS) * dwAddressElementCount + dwTotalDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create total size chunk at beginning of address
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;

		// pack all the other chunks
		lpb = (LPBYTE) lpAddress + sizeof(DPADDRESS) + sizeof(DWORD);
		for (i = 0; i < dwAddressElementCount; i++)
		{
			// chunk descriptor
			lpAddress = (LPDPADDRESS) lpb;
			lpAddress->guidDataType = lpAddressElements[i].guidDataType;
			lpAddress->dwDataSize = lpAddressElements[i].dwDataSize;
			lpb += sizeof(DPADDRESS);

			// chunk data
			memcpy(lpb, lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize);
			lpb += lpAddressElements[i].dwDataSize;
		}

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateCompoundAddress"
HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
								   lpAddress, lpdwAddressSize);

} // CreateCompoundAddresses

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalEnumAddress"

// enumerate the chunks in a connection data buffer
HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPADDRESS		lpChunk, lpCopy=NULL;
	DWORD			dwAmountParsed;
	BOOL			bContinue;
	HRESULT         hr;
	
    TRY
    {
		if (!VALIDEX_CODE_PTR(lpEnumCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}

		if (!VALID_READ_PTR(lpAddress, dwAddressSize))
		{
			DPF_ERR("Bad data buffer");
            return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Allocate a buffer big enough to accomodate any address chunk embedded 
	// in the passed in buffer. We are making local copies here to ensure proper 
	// memory alignment of the address chunks.
	lpCopy = DPMEM_ALLOC(dwAddressSize);
	if (!lpCopy)
	{
		DPF_ERR("Failed to copy address buffer (for alignment) - out of memory");
		return DPERR_OUTOFMEMORY;
	}
	
	lpChunk = (LPDPADDRESS) lpAddress;
	dwAmountParsed = 0;
	while (dwAmountParsed < dwAddressSize)
	{
		// don't walk off the end of the buffer reading chunk header
		if ((dwAmountParsed + sizeof(DPADDRESS)) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// don't walk off the end of the buffer reading chunk data
		if ((dwAmountParsed + sizeof(DPADDRESS) + lpChunk->dwDataSize) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// copy address chunk to local buffer
		memcpy(lpCopy, lpChunk, sizeof(DPADDRESS) + lpChunk->dwDataSize);

		// call the callback
		bContinue = (lpEnumCallback)(&lpCopy->guidDataType, lpCopy->dwDataSize,
								   (LPBYTE)lpCopy + sizeof(DPADDRESS), lpContext);

		// callback asked to stop
		if (!bContinue)
		{
			hr = DP_OK;
			goto CLEANUP_EXIT;
		}

		dwAmountParsed += sizeof(DPADDRESS) + lpChunk->dwDataSize;
		lpChunk = (LPDPADDRESS) ((LPBYTE)lpAddress + dwAmountParsed);
	}

	// sucess
	hr = DP_OK;

	// fall through

CLEANUP_EXIT:
	// cleanup allocations
	if (lpCopy) DPMEM_FREE(lpCopy);
	return hr;

} // EnumAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_EnumAddress"
HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalEnumAddress(pISP, lpEnumCallback, lpAddress,
								dwAddressSize, lpContext);

} // EnumAddress


// Registry definitions
#define MRU_KEY_PARENT      HKEY_CURRENT_USER
#define MRU_KEY_TOP         L"Software\\Microsoft\\DirectPlay\\Service Providers"

// Entry linked list node
typedef struct tagENTRYNODE
{
    struct tagENTRYNODE     *lpNext;
    LPVOID                  lpvData;
    DWORD                   dwSize;
} ENTRYNODE, *LPENTRYNODE;

// Entry linked list head
LPENTRYNODE                 g_lpEntryListHead = NULL;

// Local prototypes
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries);
BOOL CALLBACK InternalEnumMRUCallback(LPCVOID, DWORD, LPVOID);
LPENTRYNODE AddEntryNode(LPVOID, DWORD);
LPENTRYNODE RemoveEntryNode(LPENTRYNODE);
void FreeEntryList(void);
int CompareMemory(LPCVOID, LPCVOID, DWORD);
long RegDelAllValues(HKEY);
long OpenMRUKey(LPCWSTR, LPCWSTR, HKEY *, DWORD);
int wstrlen(LPCWSTR);
int wstrcpy(LPWSTR, LPCWSTR);
int wstrcat(LPWSTR, LPCWSTR);


// ---------------------------------------------------------------------------
// EnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext)
{
	LPDPLAYI_DPLAY	this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Call the internal enumeration routine
    return InternalEnumMRUEntries(lpszSection, lpszKey, fnCallback, lpvContext, MAXDWORD);
}


// ---------------------------------------------------------------------------
// AddMRUEntry
// ---------------------------------------------------------------------------
// Description:             Adds a new entry to the MRU list.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPVOID             New data.
//  [in] DWORD              New data size.
//  [in] DWORD              Maximum number of entries to save.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries)
{
    HRESULT                 hr;             // Return code
    HKEY                    hKey;           // Registry key
    LPENTRYNODE             lpNode;         // Generic linked list node
    long                    lResult;        // Return code from registry operations
    char                    szValue[13];    // New value name
    WCHAR                   szWValue[13];   // Unicode version of above name
    DWORD                   dwIndex;        // Current value index
	LPDPLAYI_DPLAY			this;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
		if (!VALID_READ_PTR(lpvData, dwDataSize))
		{
			DPF_ERR("passed invalid lpvData pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

    // Enumerate existing entries, adding each one to the linked list
    FreeEntryList();

    if(FAILED(hr = InternalEnumMRUEntries(lpszSection, lpszKey, InternalEnumMRUCallback, NULL, dwMaxEntries)))
    {
        FreeEntryList();
        return hr;
    }

    // Create the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_WRITE)) != ERROR_SUCCESS)
    {
        FreeEntryList();
        return DPERR_GENERIC;
    }

    // Delete all existing values
    RegDelAllValues(hKey);

    // Search for a match to the passed-in data in the linked list
    lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        if(lpNode->dwSize == dwDataSize && !CompareMemory(lpNode->lpvData, lpvData, dwDataSize))
        {
            // Item appears in the list.  Remove it.
            lpNode = RemoveEntryNode(lpNode);
        }
        else
        {
            lpNode = lpNode->lpNext;
        }
    }

    // Write the new data to the beginning of the list
    dwIndex = 0;

    if(dwMaxEntries)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, (sizeof(szWValue)/sizeof(WCHAR)));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpvData, dwDataSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
    }

    // Write all other entries to the list
    lpNode = g_lpEntryListHead;
    
    while(dwIndex < dwMaxEntries && lpNode)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, (sizeof(szWValue)/sizeof(WCHAR)));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpNode->lpvData, lpNode->dwSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
        lpNode = lpNode->lpNext;
    }

    // Clean up
    RegCloseKey(hKey);
    FreeEntryList();

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
//  [in] DWORD              Maximum count of entries to enumerate.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries)
{
    HKEY                    hKey;           // Registry key
    long                    lResult;        // Return from registry calls
    DWORD                   dwMaxNameSize;  // Maximum size of registry value names
    DWORD                   dwMaxDataSize;  // Maximum size of registry value data
    LPWSTR                  lpszName;       // Value name
    LPBYTE                  lpbData;        // Value data
    DWORD                   dwNameSize;     // Size of this value name
    DWORD                   dwDataSize;     // Size of this value data
    BOOL                    fContinue;      // Continue enumeration
    DWORD                   dwType;         // Type of registry data.  Must be REG_BINARY
    DWORD                   dwIndex;        // Current value index

    TRY
    {
		if (!VALID_READ_STRING_PTR(lpszSection, WSTRLEN_BYTES(lpszSection))) 
		{
		    DPF_ERR( "bad section string pointer" );
		    return DPERR_INVALIDPARAMS;
		}
		if (!VALID_READ_STRING_PTR(lpszKey, WSTRLEN_BYTES(lpszKey))) 
		{
		    DPF_ERR( "bad key string pointer" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALIDEX_CODE_PTR(fnCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }
    
    // Open the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_READ)) != ERROR_SUCCESS)
    {
        // Key doesn't exist.  Nothing to enumerate.
        return DP_OK;
    }

    // Get maximum sizes for names and data
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, &dwMaxDataSize, NULL, NULL)) != ERROR_SUCCESS)
    {
        // No values to enumerate
        RegCloseKey(hKey);
        return DP_OK;
    }

    // Name size does not include the NULL terminator
    dwMaxNameSize++;

    // Nor does it use WCHAR
    dwMaxNameSize *= sizeof(WCHAR);
    
    // Allocate memory
    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    if(!(lpbData = (LPBYTE)DPMEM_ALLOC(dwMaxDataSize)))
    {
        DPMEM_FREE(lpszName);
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    // Enumerate values
    dwIndex = 0;
    fContinue = TRUE;

    while(dwIndex < dwMaxEntries && fContinue)
    {
        // Get value name and data
        dwNameSize = dwMaxNameSize;
        dwDataSize = dwMaxDataSize;

        if((lResult = OS_RegEnumValue(hKey, dwIndex, lpszName, &dwNameSize, NULL, &dwType, lpbData, &dwDataSize)) != ERROR_SUCCESS)
        {
            // No more entries
            break;
        }

        // Validate type.  Must be REG_BINARY
        if(dwType == REG_BINARY)
        {
            // Call callback function
            fContinue = fnCallback(lpbData, dwDataSize, lpvContext);
        }

        // Next value, please
        dwIndex++;
    }

    // Free memory
    DPMEM_FREE(lpszName);
    DPMEM_FREE(lpbData);

    // Close the registry key
    RegCloseKey(hKey);

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUCallback
// ---------------------------------------------------------------------------
// Description:             Callback function for InternalEnumMRUEntries.
//                          Called from AddMRUEntry to create a linked list
//                          of entries.
// Arguments:
//  LPVOID                  Data.
//  DWORD                   Data size.
//  LPVOID                  Context.
// Returns:
//  BOOL                    TRUE to continue enumeration.
BOOL CALLBACK InternalEnumMRUCallback(LPVOID lpvData, DWORD dwDataSize, LPVOID lpvContext)
{
    AddEntryNode(lpvData, dwDataSize);
    return TRUE;
}


// ---------------------------------------------------------------------------
// AddEntryNode
// ---------------------------------------------------------------------------
// Description:             Adds an MRU entry to the linked list
// Arguments:
//  [in] LPVOID             Data.
//  [in] DWORD              Data size.
// Returns:
//  LPENTRYNODE             Pointer to the node in the list, or NULL on 
//                          failure.
LPENTRYNODE AddEntryNode(LPVOID lpvData, DWORD dwDataSize)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    if(g_lpEntryListHead)
    {
        // Seek to the end of the list
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext)
            lpNode = lpNode->lpNext;

        // Allocate memory for the new node
        if(!(lpNode->lpNext = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }

        lpNode = lpNode->lpNext;
    }
    else
    {
        // Allocate memory for the new node
        if(!(lpNode = g_lpEntryListHead = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }
    }

    // Copy the data
    lpNode->lpNext = NULL;
    lpNode->lpvData = lpNode + 1;
    lpNode->dwSize = dwDataSize;
    
    CopyMemory(lpNode->lpvData, lpvData, dwDataSize);

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// RemoveEntryNode
// ---------------------------------------------------------------------------
// Description:             Removes an MRU entry from the linked list.
// Arguments:
//  [in] LPENTRYNODE        Node to remove.
// Returns:
//  LPENTRYNODE             Pointer to the next node in the list, or NULL on
//                          failure.
LPENTRYNODE RemoveEntryNode(LPENTRYNODE lpRemove)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    // Make sure there's really a list
    if(!g_lpEntryListHead)
    {
        return NULL;
    }

    // Is the node to remove the list head?
    if(lpRemove == g_lpEntryListHead)
    {
        // Remove the current list head and replace it
        lpNode = g_lpEntryListHead->lpNext;
        DPMEM_FREE(g_lpEntryListHead);
        g_lpEntryListHead = lpNode;
    }
    else
    {
        // Find the node in the list and remove it
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext && lpNode->lpNext != lpRemove)
            lpNode = lpNode->lpNext;

        if(lpNode->lpNext != lpRemove)
        {
            // Couldn't find the node
            return NULL;
        }

        // Remove the node
        lpNode->lpNext = lpRemove->lpNext;
        DPMEM_FREE(lpRemove);
        lpNode = lpNode->lpNext;
    }

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// FreeEntryList
// ---------------------------------------------------------------------------
// Description:             Frees the entire MRU entry list.
// Arguments:
//  void
// Returns:
//  void
void FreeEntryList(void)
{
    LPENTRYNODE             lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        lpNode = RemoveEntryNode(lpNode);
    }
}


// ---------------------------------------------------------------------------
// CompareMemory
// ---------------------------------------------------------------------------
// Description:             Compares two memory buffers.
// Arguments:
//  [in] LPVOID             First buffer to compare.
//  [in] LPVOID             Second buffer to compare.
//  [in] DWORD              Buffer sizes.  Don't even bother calling this
//                          function if the sizes differ.
// Returns:
//  int                     0 if the buffers compare.
int CompareMemory(LPVOID lpv1, LPVOID lpv2, DWORD dwSize)
{
    if(!dwSize)
    {
        return 0;
    }

    while(dwSize--)
    {
        if(*(LPBYTE)lpv1 != *(LPBYTE)lpv2)
        {
            return *(LPBYTE)lpv1 - *(LPBYTE)lpv2;
        }
    }

    return 0;
}


// ---------------------------------------------------------------------------
// RegDelAllValues
// ---------------------------------------------------------------------------
// Description:             Removes all values from a registry key.
// Arguments:
//  [in] HKEY               Key to clean.
// Returns:
//  long                    Registry error code.
long RegDelAllValues(HKEY hKey)
{
    long                    lResult;            // Registry error code
    DWORD                   dwMaxNameSize;      // Maximum value name size
    LPWSTR                  lpszName;           // Value name
    DWORD                   dwNameSize;         // Value name size

    // Get maximum name size
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, NULL, NULL,NULL)) != ERROR_SUCCESS)
    {
        return lResult;
    }

    // Allocate memory
    dwMaxNameSize++;
    dwMaxNameSize *= sizeof(WCHAR);

    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        return ERROR_OUTOFMEMORY;
    }

    // Enumerate all values
    while(1)
    {
        // Get name
        dwNameSize = dwMaxNameSize;

        if((lResult = OS_RegEnumValue(hKey, 0, lpszName, &dwNameSize, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS)
        {
            break;
        }

        // Delete the value
        OS_RegDeleteValue(hKey, lpszName);
    }

    // Free memory
    DPMEM_FREE(lpszName);

    // Return success
    return ERROR_SUCCESS;
}


// ---------------------------------------------------------------------------
// OpenMRUKey
// ---------------------------------------------------------------------------
// Description:             Opens the MRU registry key.
// Arguments:
//  [in] LPCWSTR            Section name.
//  [in] LPCWSTR            Key name.
//  [out] HKEY *            Pointer to a registry key handle.
//  [in] DWORD              Open flags.
// Returns:
//  long                    Registry error code.
long OpenMRUKey(LPCWSTR lpszSection, LPCWSTR lpszKey, HKEY *lphKey, DWORD dwFlags)
{
    LPWSTR                  lpszFullKey;    // Full key name
    long                    lResult;        // Error code
    DWORD                   dwAction;       // Action returned from RegCreateKeyEx()
    
    // Get the full key name
    if(!(lpszFullKey = (LPWSTR)DPMEM_ALLOC((wstrlen(MRU_KEY_TOP) + 1 + wstrlen(lpszSection) + 1 + wstrlen(lpszKey) + 1) * sizeof(WCHAR))))
    {
        return ERROR_OUTOFMEMORY;
    }

    wstrcpy(lpszFullKey, MRU_KEY_TOP);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszSection);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszKey);

    // Open or create the key
    if(dwFlags == GENERIC_READ)
    {
        lResult = OS_RegOpenKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, KEY_ALL_ACCESS, lphKey);
    }
    else
    {
        lResult = OS_RegCreateKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, lphKey, &dwAction);
    }

    // Free memory
    DPMEM_FREE(lpszFullKey);

    // Return
    return lResult;
}


// ---------------------------------------------------------------------------
// wstrlen, wstrcpy, wstrcat
// ---------------------------------------------------------------------------
// Description:             Unicode string helper functions.
int wstrlen(LPCWSTR lpszString)
{
    int                     nLen = 0;

    while(*lpszString++)
    {
        nLen++;
    }

    return nLen;
}


int wstrcpy(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    int                     nLen = 0;
    
    while(*lpszSrc)
    {
        *lpszDest++ = *lpszSrc++;
        nLen++;
    }

    *lpszDest = 0;

    return nLen;
}


int wstrcat(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    while(*lpszDest)
    {
        lpszDest++;
    }

    return wstrcpy(lpszDest, lpszSrc);
}


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_GetSPData"

// 
// sp's can get the blob of data previously set w/ this IDirectPlay pointer
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (dwFlags != DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}
		
		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	*pdwDataSize  = this->dwSPLocalDataSize;
	*ppvData = this->pvSPLocalData;

	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_SetSPData"

//	 
// sp's can set a blob of data with each idirectplaysp 
HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags != DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,NULL,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set idirectplaysp data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\update.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       update.h
 *  Content:	header for app server update handling
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/31/96	andyco	created
 ***************************************************************************/

#ifndef __DPUPDATE_INCLUDED__
#define __DPUPDATE_INCLUDED__


/*                      */
/* Handy Macro	 		*/
/*                      */

#define UPDATE_SIZE(pPlayer) (pPlayer->pbUpdateIndex - pPlayer->pbUpdateList)

/*                      */
/* Constants	 		*/
/*                      */

// we alloc this much for the updatelist	 
#define DPUPDATE_INITIALNODESIZE			1024

/*                      */
/* Update messages		*/
/*                      */

typedef struct _UPNODE_GENERIC
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
} UPNODE_GENERIC, * LPUPNODE_GENERIC;

typedef struct _UPNODE_MESSAGE
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
	DPID	idFrom;
	DWORD	dwUpdateSize; // total size of this update node
	DWORD	dwMessageOffset; // offset of message from beginning of node
} UPNODE_MESSAGE,* LPUPNODE_MESSAGE;

typedef struct _UPDNODE_CREATEPLAYER
{
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of new player
	DWORD dwFlags; // player flags
	DWORD dwUpdateSize; // total size of this update node
	// short name, long name, data, address follow, if specified
	// by DPUDPATE_FLAGS	
	
}  UPDNODE_CREATEPLAYER, *LPUPDNODE_CREATEPLAYER;

typedef struct _UPDNODE_DESTROYPLAYER
{									
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of deleted player
	DWORD dwUpdateSize; // total size of this update node
}  UPDNODE_DESTROYPLAYER, *LPUPDNODE_DESTROYPLAYER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\sysmess.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sysmess.c
 *  Content:	sends system messages e.g. create/delete player
 *				also sends player to player messages
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	2/15/96		andyco	added player - player messages
 *	3/7/96		andyco	added reliable / unreliable player messages
 *	4/23/96		andyco	added delete player when send returns E_FAIL
 *	6/4/96		andyco	deletes player on dperr_playerlost, not e_fail
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *  6/21/96		kipo	Bug #2081. Need to subtract off header size from
 *						message size in SendDPMessage() before calling
 *						DPlay_HandleSPMessage() for local players.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	7/10/96		andyco	changes for pending - checks on sendsystemmessage 
 *						modified for 2nd local sysplayer. 
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						check for session lost on send to remote players
 *	8/8/96		andyco	added support for dpsession_nomessageid
 * 10/11/96     sohailm added SendSessionDescChanged()
 * 10/12/96		andyco	added optimized groups
 * 11/12/96		andyco	added system group / server player. unified sendtogroup
 *						and broadcast.
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 1/1/97		andyco	happy new year! all sends go to system players - this way
 *						sp's have fewer players to keep track of.
 *	1/28/97		andyco	SendName/DataChanged takes fPropagate flag so we can 
 *						correctly propagate these
 *	2/1/97		andyco	drop the dplay locks and go into pending modes on sends
 *						for guaranteed player / group messags (app messages only). Bug 5290.
 *  3/14/97     sohailm added functions NeedSigning(), InternalSendDPMessage(), 
 *                      BroadCastSystemMessage() and IsBroadCastSystemMessage().
 *                      modified SendDPMessage() to use InternalSendDPMessage() and 
 *                       SignAndSendDPMessage().
 *                      updated SendSystemMessage to route system messages through nameserver when 
 *                      session is secure.                      
 *  3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Added support for passing session password in addforward
 *  4/11/97		andyco	changed SendSystemMessage, and added ask4multicast
 *	4/20/97		andyco	group in group
 *  4/23/97     sohailm The new SendSystemMessage() was not forwarding system messages to local
 *                      players.
 *                      Added support for encrypting ADDFORWARD and SESSIONDESCCHANGED messages.
 *	5/8/97		andyco	changed SendSystemMessage() to deal w/ CLIENT_SERVER. 
 *						removed update list.
 *  5/08/97     sohailm Temporarily disabled encryption of addforward and setsessiondesc messages.
 *  5/12/97     sohailm Enabled encryption of addforward and setsessiondesc messages.
 *                      Updated NeedSecurity() to allow security in the key exchange state.
 *	5/17/97		myronth	Send the SendChatMessage system message
 *	5/17/97		kipo	There was a bug in SendGroupMessage () where it was
 *						always taking the dplay lock after sending a message if
 *						the pending flag was set. This is bad if the pending flag
 *						was already set when we came into SendGroupMessage(),
 *						(i.e. during DP_Close), causing use to not drop the lock.
 *  5/18/97     sohailm Player-Player messages were not secure, when sent from the server.
 *  5/21/97     sohailm NeedSecurity() now fails if dplay is not providing security support.
 *                      Replaced DP_SP_HandleMessage call in InternalSendDPMessage an 
 *                      InternalHandleMessage() call.
 *	6/2/97		andyco	check for no nameserver in client server case in sendsystemmessage
 *  6/23/97     sohailm Now we use SSPI for message signing until client logs in. After which
 *                      signing is done using CAPI.
 *	6/24/97		kipo	distribute group messages from the server to the client
 *						one message at a time (like DX3) in case the client
 *						does not know about the group.
 *	7/30/97		andyco	return hr on sendplayermessage from actual send
 *  8/01/97		sohailm	removed message broadcasting code written for security.
 *						implemented peer-peer security using dplay multicasting code.
 *  8/4/97		andyco	added SendAsyncAddForward
 *	11/19/97	myronth	Fixed uninitialized To player in SendGroupMessage (#10319)
 *	11/24/97	myronth	Fixed SetSessionDesc messages for client/server (#15226)
 *	1/9/97		myronth	Fixed SendChatMessage to groups (#15294, #16353)
 *	1/14/98		sohailm	don't allow sp to optimize groups in CLIENT_SERVER and SECURE_SERVER(#15210)
 *	1/28/98		sohailm keep groups local to the client in CLIENT_SERVER (#16340)
 *  2/3/98      aarono  Fixed Paketize test for RAW mode 
 *  2/18/98     aarono  changed to direct protocol calls
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/2/98      aarono  skip group sends with 0 members
 *                      fix locking for player deletion
 *  6/10/98     aarono  removed dead security code
 *  6/18/98     aarono  fix group SendEx ASYNC to use unique Header
 *  08/05/99    aarono  moved voice over to DPMSG_VOICE
 *  10/14/99    aarono  integrated fixes from NT tree for group sends.
 *  01/18/00    aarono  Millennium B#128337 - use replaceheader for all 
 *                      group ASYNC SendEx.  Winsock doesn't copy data.
 *  06/26/00    aarono  Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *  06/27/00    aarono  105298 order of precedence error in SendCreateMessage, added ()'s
 ***************************************************************************/


#include "dplaypr.h"
#include "dpcpl.h"
#include "dpsecure.h"
#include "dpprot.h"

#undef DPF_MODNAME
#define DPF_MODNAME "NeedsSecurity"

// this function is called just before a message is handed off to the service provider
// here we decide if the outgoing message needs to be sent securely

BOOL NeedsSecurity(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
    LPDPLAYI_PLAYER pPlayerFrom, LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags)
{
    // message doesn't need security if any of the following conditions satisfy

    // dplay is not providing security
    if (!(this->dwFlags & DPLAYI_DPLAY_SECURITY))
    {
        return FALSE;
    }

    // no player yet
    if (!pPlayerFrom)
    {
        return FALSE;
    }

    // message is to a local player
    if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
        return FALSE;
    }

    // if we are a client and are not in a signing state
    if (!IAM_NAMESERVER(this) && !VALID_SIGNING_STATE(this))
    {
        return FALSE;
    }

	// if message is one of the following
    switch (dwCommand) {
    case DPSP_MSG_PLAYERMESSAGE:
	// multicast messages could be player messages
	case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		// security only if requested
        if (!(dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            return FALSE;
        }
        break;

    case DPSP_MSG_PING:
    case DPSP_MSG_PINGREPLY:
        return FALSE;
        break;
    }

    // send message securely
    return TRUE;

} // NeedsSecurity

/*
 ** CheckPacketize
 *
 *  CALLED BY:	InternalSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - send flags
 *
 *  DESCRIPTION: checks if we should packetize the send for reliablilty.
 *
 *  RETURNS: sp return value
 *
 */

BOOL CheckPacketize(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,DWORD fSPHeader) 
{
	DWORD dwSPHeaderSize;
	DWORD dwSign;
	DWORD dwCommand;
	LPDPLAYI_PLAYER pSysPlayerTo;
	DWORD dwVersion;
	
	if((this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && (dwMessageSize >= this->dwSPHeaderSize+sizeof(MSG_SYSMESSAGE))) // quick test
	{
		if(fSPHeader){
			dwSPHeaderSize=this->dwSPHeaderSize;
		} else {
			dwSPHeaderSize=0;
		}
		
		dwSign    = ((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize))->dwHeader;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize));

		// find dplay version at target so we know if it even supports this type of packetize.
		if(pPlayerTo)
		{
			dwVersion=pPlayerTo->dwVersion;
			if(!dwVersion)
			{ 
				pSysPlayerTo=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if(pSysPlayerTo)
				{
					dwVersion=pPlayerTo->dwVersion=pSysPlayerTo->dwVersion;
				} 
				else 
				{
					ASSERT(0);
					dwVersion=DPSP_MSG_VERSION;
				}
			}
		} 
		else 
		{
			// No pPlayerTo, using SP cached nameserver, grab target version from this.
			dwVersion=this->dwServerPlayerVersion;
		}
		
		if((dwSign==MSG_HDR) && NeedsReliablePacketize(this, dwCommand, dwVersion, dwFlags))
		{
			return TRUE;
		}
	}
	return FALSE;
}			
#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessage"

/*
 ** InternalSendDPMessage
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				fReliable - requires reliable send?
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock) 
{
    DPSP_SENDDATA sd;
	HRESULT hr,hr2;
	DWORD dwMax;
 	LPDPLAYI_PLAYER pSysPlayer;
	
	// first, make sure the player isn't on the dead list
	if (pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(pPlayerFrom ? pPlayerFrom->dwID : 0),
		(pPlayerTo ? pPlayerTo->dwID : 0));

	if (dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		if (!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ // don't do reliability on loopback.
			if(CheckPacketize(this,	pPlayerTo,pMessage,dwMessageSize,dwFlags,TRUE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				hr = PacketizeAndSendReliable(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,
					NULL,FALSE);
				return hr;
			}
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (dwMessageSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		hr = PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,
			dwFlags,NULL,FALSE);

		return hr;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += dwMessageSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}
	
    // build the senddata
    sd.dwFlags = dwFlags;
	sd.bSystemMessage = TRUE;

	// to
	if (NULL == pPlayerTo)
	{
		sd.idPlayerTo = 0;		
	}
	else 
	{
		sd.idPlayerTo = pPlayerTo->dwID;					
		if (!(pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
		{
			if (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
			{
				
				// tell sp to send it to this players system player
				// all sends get routed to system players
				// note that the actual player id is embedded in the message,
				// and will be used for delivery at the receiving end.
				//
				// we can't do this if dx3 players in game, since dx3 nameserver
				// migration doesn't update system player id's
				ASSERT(pPlayerTo->dwIDSysPlayer);
				sd.idPlayerTo = pPlayerTo->dwIDSysPlayer;
			}
		}
	}
	
	// from
	if (NULL == pPlayerFrom)
	{
		sd.idPlayerFrom = 0;		
	}
	else 
	{
		// if it's not from a system player, it's not a system message
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sd.bSystemMessage = FALSE;	
		sd.idPlayerFrom = pPlayerFrom->dwID;					
	}

    sd.lpMessage = pMessage;
	sd.dwMessageSize = dwMessageSize;
	sd.lpISP = this->pISP;

	if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		DPF(7,"delivering message locally");

		// call our handler directly, bypassing sp
		hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
			this->dwSPHeaderSize,dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,dwFlags);
	}
	else if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		hr=DPERR_UNAVAILABLE;
	}
    // call sp
    else if (this->pcbSPCallbacks->Send) 
    {

		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			return DPERR_SESSIONLOST;
		}

		if(bDropLock){
			LEAVE_DPLAY();
		}
		DPF(7,"delivering message to service provider");

		if(this->pProtocol){
			hr = ProtocolSend(&sd); // calls sp too.
		} else {
	    	hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
	    }

		if(bDropLock){
			ENTER_DPLAY();
		}
	    
		if (DPERR_SESSIONLOST == hr)
		{
			DPF_ERR(" got session lost back from SP ");
			hr = HandleSessionLost(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sd.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
		    		
					// a-josbor: we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
					//  -seems to be working fine AO 04/03/2001
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    }
	else 
	{
		hr = DPERR_GENERIC;
		ASSERT(FALSE);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) 
	{
		DPF(0,"DP Send - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

#undef DPF_MODNAME
#define DPF_MODNAME "ConcatenateSendBuffer"
/*
 ** ConcatenateSendBuffer
 *
 *  CALLED BY:	
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts a scatter gather array into a contiguous
 *               buffer for use in older DPLAY entry points.
 *
 *  NOTE:        allocates
 *
 *  RETURNS: pointer to new buffer, or NULL if out of memory
 *
 */

PUCHAR ConcatenateSendBuffer(LPDPLAYI_DPLAY this, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD   dwMessageSize;
	PUCHAR  pBuffer;
	UINT    i;
	UINT    offset;

	dwMessageSize=this->dwSPHeaderSize+dwTotalSize;

	pBuffer=MsgAlloc(dwMessageSize);
	if(!pBuffer){
		goto exit;
	}

	// copy the SG buffers into the single buffer.  Leave dwSPHeaderSize bytes empty at front.
	offset=this->dwSPHeaderSize;
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}

exit:
	return pBuffer;
}


#undef DPF_MODNAME
#define DPF_MODNAME "ConvertSendExDataToSendData"

/*
 ** ConvertSendExDataToSendData
 *
 *  CALLED BY:	SendDPMessageEx
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts sendexdata to senddata for use
 *               on old sp's or when looping back a send.
 *               Transcribes the Scatter gather buffers and
 *               leave space for the SP header at the front.
 *
 *  RETURNS: sp return value
 *
 */

HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) 
{
	PUCHAR  pBuffer;
	DWORD   dwMessageSize;

	pBuffer=ConcatenateSendBuffer(this,psed->lpSendBuffers,psed->cBuffers,psed->dwMessageSize);
	
	if(!pBuffer){
		return DPERR_NOMEMORY;
	}

	dwMessageSize=this->dwSPHeaderSize+psed->dwMessageSize;

	// same flags except no new bits.
	psd->dwFlags = psed->dwFlags & ~(DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG);

	psd->idPlayerTo     = psed->idPlayerTo;
	psd->idPlayerFrom   = psed->idPlayerFrom;
	psd->lpMessage      = pBuffer;
	psd->dwMessageSize  = dwMessageSize;
	psd->bSystemMessage = psed->bSystemMessage;
	psd->lpISP          = psed->lpISP;
	
	return DP_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessageEx"

/*
 ** InternalSendDPMessageEx
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *              psp  - send parameters
 *
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock) 
{
	DPSP_SENDDATA   sd;
    DPSP_SENDEXDATA sed;
	HRESULT hr,hr2;
	DWORD dwMax;
	DWORD dwSPMsgID; // storage for message id returned by SP
	PUCHAR pBuffer=NULL;
	DWORD bOldSend=FALSE;
 	LPDPLAYI_PLAYER pSysPlayer;

	ASSERT(psp);
	
	// first, make sure the player isn't on the dead list
	if (psp->pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", psp->pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(psp->pPlayerFrom ? psp->pPlayerFrom->dwID : 0),
		(psp->pPlayerTo ? psp->pPlayerTo->dwID : 0));

	if (psp->dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		// don't do reliability on loopback
		if (!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ 

			if(CheckPacketize(this,	psp->pPlayerTo,psp->Buffers[0].pData,psp->dwTotalSize,psp->dwFlags,FALSE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				
				pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
				if(!pBuffer){
					return DPERR_NOMEMORY;
				}
				hr = PacketizeAndSendReliable(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
				goto EXIT;
			}
			
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (psp->dwTotalSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pBuffer){
			return DPERR_NOMEMORY;
		}
		hr = PacketizeAndSend(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
		goto EXIT;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += psp->dwTotalSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}

	//
    // build the SendExData
    //
    
	sed.lpISP = this->pISP;
    sed.dwFlags = psp->dwFlags;
	sed.bSystemMessage = TRUE;

	// TO ID
	if (NULL == psp->pPlayerTo)	{

		sed.idPlayerTo = 0;		

	} else 	{
	
		sed.idPlayerTo = psp->pPlayerTo->dwID;					
		
		// Route messages through system player on host unless DX3 in game
		// Messages delivered by host use the embedded FromID in the message
		// to notify the receiver who the message was from.

		if (!(psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
		{
				ASSERT(psp->pPlayerTo->dwIDSysPlayer);
				sed.idPlayerTo = psp->pPlayerTo->dwIDSysPlayer;
		}
	}
	
	// FROM ID
	if (NULL == psp->pPlayerFrom){
		sed.idPlayerFrom = 0;		
	}else {
		// if it's not from a system player, it's not a system message
		if (!(psp->pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sed.bSystemMessage = FALSE;	
		sed.idPlayerFrom = psp->pPlayerFrom->dwID;					
	}

	// MESSAGE DATA
    sed.lpSendBuffers = &psp->Buffers[0];
    sed.cBuffers      = psp->cBuffers;
	sed.dwMessageSize = psp->dwTotalSize;

	// OTHER PARAMS
	sed.dwPriority    = psp->dwPriority;
	sed.dwTimeout     = psp->dwTimeout;
	sed.lpDPContext   = (LPVOID)psp->hContext;
	sed.lpdwSPMsgID   = &dwSPMsgID;
	    

	if (psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) {
	
		DPF(7,"delivering message locally");

		// Handle Message doesn't understand sed's, make contiguous.
		hr=ConvertSendExDataToSendData(this, &sed,&sd);
		
		if(!FAILED(hr)){
			pBuffer=sd.lpMessage;
			// call our handler directly, bypassing sp
			hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
				this->dwSPHeaderSize,sd.dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,sd.dwFlags);
		} 

	}
	else if((psp->pPlayerTo) && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE) && (!(psp->dwFlags & DPSEND_ASYNC))){
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",psp->pPlayerTo,psp->pPlayerTo->dwID);
		// don't try to send to a player that doesn't have the nametable.
		hr=DPERR_UNAVAILABLE;
    } else if (this->pcbSPCallbacks->Send) 	{ // call sp
        
		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			hr = DPERR_SESSIONLOST;
			goto EXIT;
		}

		pspAddRef(psp);			// AddRef in anticipation of the send pending, must be added before
								// send, because it could complete in the send call causing the reference
								// count to go to zero.


		DPF(7,"delivering message to service provider");

		if(bDropLock){
			LEAVE_DPLAY();	//icky,icky,icky, get rid of API level lock! - not likely now AO 04/03/2001
		}	

		if(this->pProtocol){
		
			hr = ProtocolSendEx(&sed); // protocol will call SP.
			
		} else if(this->pcbSPCallbacks->SendEx){
		
		    hr = CALLSP(this->pcbSPCallbacks->SendEx,&sed);    	
		    
		} else {

			// No extended send, convert to old method.
			if(!pBuffer){
				hr=ConvertSendExDataToSendData(this, &sed,&sd);
			} else {
				hr=DP_OK;
			}
			if(!FAILED(hr)){
				pBuffer=sd.lpMessage;
				bOldSend=TRUE;
				if(this->pProtocol){
					hr = ProtocolSend(&sd);  // protocol will call SP.
				} else {
				    hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
				}    
			}    
		}
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if(hr == DPERR_PENDING){
                        AddContext(this,psp,(LPVOID)(DWORD_PTR)dwSPMsgID);
		} else if(!(psp->dwFlags & DPSEND_ASYNC) || bOldSend || FAILED(hr)){
			// even in DP_OK case, completion still happens, so we 
			// only pull off the reference in an error case or the SYNC case.
			pspDecRef(this,psp);
		} 

		// error handling
		if (DPERR_SESSIONLOST == hr)
		{
			// Completely lost our connection to the game.
			
			DPF_ERR(" got session lost back from SP ");

			hr = HandleSessionLost(this);
			
			if (FAILED(hr))	{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sed.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
					// a-josbor: we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
					//  -seems to work OK, AO 04/03/2001
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    } else {
		// No Send Handler???
		hr=DPERR_GENERIC; // make prefix happy.
		ASSERT(FALSE);
	}

EXIT:
	// CleanUp
	if(pBuffer){
		MsgFree(NULL, pBuffer);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) {
		DPF(0,"DP SendEx - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

/*
 ** SendDPMessage
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, pMessage+this->dwSPHeaderSize, dwMessageSize, 
            &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

        // do we need to send message securely ?
        if (NeedsSecurity(this, dwCommand, dwVersion, pPlayerFrom, pPlayerTo, dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                dwFlags |= DPSEND_SIGNED;
            }

            // secure messages are sent guaranteed regardless
            dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessage(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPI(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);

			}
			if (FAILED(hr))
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessage(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags, bDropLock);

	return hr; 		
} // SendDPMessage


/*
 ** SendDPMessageEx
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessageEx(LPDPLAYI_DPLAY this,LPSENDPARMS psp, BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, psp->Buffers[0].pData, psp->dwTotalSize,&dwCommand,&dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

		ASSERT(!this->pProtocol);
	
		if (NeedsSecurity(this, dwCommand, dwVersion, psp->pPlayerFrom, psp->pPlayerTo, psp->dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                psp->dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                psp->dwFlags |= DPSEND_SIGNED;
            }
            
            // secure messages are sent guaranteed regardless
            psp->dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessageEx(this, psp, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPIEx(this, psp, bDropLock);

			}
			if (FAILED(hr) && hr != DPERR_PENDING)
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessageEx(this,psp,bDropLock);

	return hr; 		
} // SendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendSystemMessage"

/*
 ** SendSystemMessage
 *
 *  CALLED BY: SendCreateMessage,SendPlayerManagementMessage
 *
 *  PARAMETERS: this - idplay
 *				pSendBuffer,dwBufferSize - buffer to send
 *				fPropagate - do we need to send this message to remote system players (TRUE),
 *					or do we just want to pass it on to our local (non-system) players (FALSE).
 *				fSetTo - do we need to set the id of the player we're sending to ?
 *					Some messages (e.g. playermgmtmessages) need the dest player
 *					to be set in the message.  See DPlay_HandleSPMessage in handler.c.
 *
 *  DESCRIPTION: sends messag to all remote system players (if fLocal is TRUE), and 
 *			to all local players
 *
 *  RETURNS:  DP_OK or failure from sp
 *
 */
HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	DWORD dwFlags, BOOL bIsPlyrMgmtMsg)
{
	HRESULT hr=DP_OK;
   	LPMSG_PLAYERMGMTMESSAGE pmsg = NULL;

	// If this is a lobby-owned object, we are never going to send a system
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	if(bIsPlyrMgmtMsg)
		pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);

	if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
		dwFlags &= ~DPSEND_ASYNC; // force sends on closing to be synchronous
	}

	if (CLIENT_SERVER(this))
	{
		// are we the nameserver?
		if (IAM_NAMESERVER(this))
		{
			ASSERT(this->pSysPlayer);
			// if so, only tell the world about events related to my system player or 
			// the appserver id
			if ((!bIsPlyrMgmtMsg)
				|| (pmsg->dwPlayerID == this->pSysPlayer->dwID) 
				|| (pmsg->dwPlayerID == DPID_SERVERPLAYER) )
			{
				// tell the world (this will also distribute it to our local players)
				if (this->pSysGroup) 
				{
					hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
						pSendBuffer,dwMessageSize,FALSE);
				}
				// there won't be a sytemgroup if e.g. we're creating our system 
				// player - that's ok
			}
			// a-josbor: special case.  If we're deleting a player, we need to inform
			//	that player only
			else if (bIsPlyrMgmtMsg && GET_MESSAGE_COMMAND(pmsg) == DPSP_MSG_DELETEPLAYER)
			{
				LPDPLAYI_PLAYER pPlayer;

				pPlayer = PlayerFromID(this, pmsg->dwPlayerID);
				if (VALID_DPLAY_PLAYER(pPlayer))
				{
					hr = SendDPMessage(this, NULL, pPlayer, pSendBuffer,
						dwMessageSize, dwFlags,FALSE);
				}
			}
		} // IAM_NAMESERVER
		else 
		{
			// i am not the nameserver, tell the nameserver
			if (this->pNameServer)
			{
				if (bIsPlyrMgmtMsg)
				{
					// don't send any group related messages to the nameserver
					// a-josbor: handle these two special cases: commands where we have
					// a valid player in the player field, but it's really a group message.
					// note that we can't just check the groupId field of the player message
					// struct, because we'd be interpreting the structure incorrectly for
					// certain messages (i.e. PLAYERDATACHANGED)
					if ((VALID_DPLAY_PLAYER(PlayerFromID(this,pmsg->dwPlayerID)))	// in other words, not a group
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_ADDPLAYERTOGROUP)
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_DELETEPLAYERFROMGROUP))
					{
						pmsg->dwIDTo = this->pNameServer->dwID;
							
						// send message to nameserver
						hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
							dwMessageSize,dwFlags,FALSE);
					}
				}
				else
				{
					// send message to nameserver
					hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
						dwMessageSize,dwFlags,FALSE);
				}
			}
			else 
			{
			 	// this can happen if e.g. nameserver quits before we do
			}
		} // ! IAM_NAMESERVER

		// finally, distribute the message to all our local players
	    hr =  DistributeSystemMessage(this,pSendBuffer+this->dwSPHeaderSize,
            dwMessageSize-this->dwSPHeaderSize);

	} // CLIENT_SERVER
	else 
	{
		if (this->pSysGroup) 
		{
			hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
				pSendBuffer,dwMessageSize,FALSE);
		}
		else 
		{
			// this will happen e.g. when you are creating your system player
			DPF(5,"no system group - system message not sent");
		}
	} // ! CLIENT_SERVER
		
	return DP_OK;
	
} // SendSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendCreateMessage"

/*
 ** SendCreateMessage
 *
 *  CALLED BY: DP_CreatePlayer, DP_CreateGroup
 *
 *  PARAMETERS:
 *					this - 	dplay object
 *					pPlayer - player or group we're creating
 *					fPlayer - if !0, creating player, else creating group
 *                  lpszSessionPassword - session password, if creating system player, 
 *                                        otherwise NULL
 *
 *  DESCRIPTION:
 *					sets up a createxxx message
 *					packs the player or groupdata into the message, and sends it out
 *
 *  RETURNS:  result from sendsystemmessage, senddpmessage, or E_OUTOFMEMORY.
 *
 */
HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
    LPWSTR lpszSessionPassword)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize, dwPasswordLen=0, dwNoTickCountMessageSize;
	BOOL fPropagate;
	PUINT pTickCount;
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	// if the player we're creating is local, we need to propagate the announcement,
	// i.e. tell the world...
	fPropagate =  (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE:FALSE;
    
	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,fPlayer);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

    DPF(2,"sending new player announcment id = %d fPropagate = %d",msg.dwPlayerID,fPropagate);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    // add password size to message size
    if (lpszSessionPassword)
    {
        dwPasswordLen = WSTRLEN_BYTES(lpszSessionPassword);
        dwMessageSize += dwPasswordLen + sizeof(UINT)/* for TickCount */;
        dwNoTickCountMessageSize = dwMessageSize - sizeof(UINT);
    } else {
		// add extra space to use for TickCount if necessary.  Tickcount is sent in join
		// on the latest versions so we don't join a different session than we enumerated.
		dwNoTickCountMessageSize=dwMessageSize;
		dwMessageSize+=sizeof(UINT)+2; // 2 for NULL password
	}	

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEPLAYER);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEGROUP);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),fPlayer);

	// are we sending the create player announcement for our sysplayer?
	if (fPropagate && (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		this->pSysPlayer && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	{
		LPMSG_SYSMESSAGE pmsg = (LPMSG_SYSMESSAGE)(pSendBuffer + this->dwSPHeaderSize);

        // if nameserver is dx5 or greater, it will require a password in the addforward
        // message. Fill in the password regardless of the nameserver's version, 'cause dx3
        // won't even look at it.
        if (lpszSessionPassword && dwPasswordLen > 2)
        {
            memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 
                lpszSessionPassword, dwPasswordLen);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + dwPasswordLen);
        } else {
        	// Set NULL password so we can put tick count past it.
            memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
        }

		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
			*pTickCount=(DWORD)this->lpsdDesc->dwReserved1;
		}	

        // if nameserver is dx5 or greater, it will respond with the nametable
        // GetNameTable() in iplay.c will block for the nametable download

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(!CLIENT_SERVER(this)){
			SetupForReply(this, DPSP_MSG_SUPERENUMPLAYERSREPLY);
		} else {
			SetupForReply(this, DPSP_MSG_ENUMPLAYERSREPLY);
		}	

		//
		// tell the namesrvr to forward this message...
		// this is to get us into the global nametable - even though we
		// haven't downloaded it yet.  this allows the nametable pending
		// stuff to work, and ensures our name table is kept in sync.
		//
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ADDFORWARDREQUEST);
		hr = SendDPMessage(this,pPlayer,NULL,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE,FALSE);
		if(FAILED(hr)){
			UnSetupForReply(this);
		}
	}
	else 
	{
		DWORD dwExtraFlags;
    	// Set NULL password so we can put tick count past it.
//        memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
//        ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
//        pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
//
//		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
//			*pTickCount=this->lpsdDesc->dwReserved1;
//		}	

		if(this->lpsdDesc && (this->lpsdDesc->dwFlags & (DPSESSION_CLIENTSERVER|DPSESSION_SECURESERVER))){
			dwExtraFlags=0;
		} else {
			dwExtraFlags=DPSEND_SYSMESS;
		}
		
		// it's just a regular system message
		hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

		if(dwExtraFlags){
			// reduce chance of losing first reliable messages due to race
			// between async creation and sending of first message.
			Sleep(100);
		}
	}
	DPMEM_FREE(pSendBuffer);
    
    // done
    return hr;
} // SendCreateMessage 

#undef DPF_MODNAME
#define DPF_MODNAME "SendCreateVerifyMessage"

/*
 ** SendCreateVerifyMessage
 *
 *  CALLED BY:
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:  
 *
 */
HRESULT SendCreateVerifyMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer, DWORD dwMessageType, DWORD dwReplyToVersion, LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize;
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,TRUE);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

    DPF(1,"sending player verify id = %d\n",msg.dwPlayerID);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,dwMessageType);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),TRUE);

	DoReply(this, pSendBuffer,dwMessageSize, pvSPHeader,dwReplyToVersion);
	
	DPMEM_FREE(pSendBuffer);
    
    // done
    return hr;
} // SendCreateVerifyMessage

#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateVerify"
HRESULT DoCreateVerify(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer,DWORD dwMessageSize,	LPVOID pvSPHeader) 
{

	// We just got a player create message for a remote non-system player.  There is a bug in the nametable management
	// that may lead to the remote machine having missed our create player message if we created our local-players around
	// the time he was creating his system player.  To work around this problem, where he wasn't notified of our local player
	// creation, we send him an additional create player message in the form of a DPSP_MSG_CREATEPLAYERVERIFY.  We only
	// send this message if we get the creation within 40 seconds of creating our local player, since it is unlikely that the race
	// occured if the window is beyond this.

	// If we find the person sending us this message is before this fix DPSP_MSG_DX8VERSION2, then we send him a 
	// DPSP_MSG_CREATEPLAYER message.  Otherwise we send DPSP_MSG_CREATEPLAYERVERIFY.  The new message type
	// allows us to avoid getting into a situation where we ping-pong creation messages.  There is no issue with older
	// clients since they will not send an additional CREATE message.

	// If the remote client is pre-dx5, we don't bother, they have so many other problems this is nigling.

	// Have DPLAY lock on way in, but will need both locks to Send, so we drop the DPLAY lock and ENTER_ALL, we
	// drop the SERVICE lock on the way out, so we leave as we entered.

	// AO - 6/26/00 can't send extra create for DX5 because although it won't add the player twice it WILL post
	// the message to the user twice (doh!).
	
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	DWORD dwVersion;
	DWORD dwCommand;
	HRESULT hr=DP_OK;
	LPDPLAYI_PLAYER pPlayer;
	DWORD tNow;

	LEAVE_DPLAY();
	ENTER_ALL();
						
	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return hr;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;

	dwVersion=GET_MESSAGE_VERSION(pmsg);

    if(dwVersion >= DPSP_MSG_DX8VERSION2)
    {
		dwCommand=DPSP_MSG_CREATEPLAYERVERIFY;
    } else {
    	// don't bother with DX3. (or DX5)
    	hr=DP_OK;
    	goto exit;
    }

	// walk player list, inform sender of all our local players if we created any
	// of them in the last 40 seconds. (after 39 days there will also be another
	// 40 second window, but its benign anyway, so no special case req'd).
	tNow=timeGetTime();
	pPlayer=this->pPlayers;

	while(pPlayer){
		// only send for local non-system players.
		if((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
		  !(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
		  (tNow-pPlayer->dwCreateTime < 40000))
		{
			hr=SendCreateVerifyMessage(this,pPlayer,dwCommand,dwVersion,pvSPHeader);
		}
		pPlayer=pPlayer->pNextPlayer;
	}

exit:
	LEAVE_SERVICE();
	return hr;
}

#undef DPF_MODNAME
//
// repackage the pSendBuffer to have a player wrapper
// called in case someone tries to send a message that has our token
// as the first dword.
HRESULT WrapPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pSendBuffer,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock)
{
	HRESULT hr;
	LPMSG_SYSMESSAGE psm;
	LPBYTE pWrapBuffer;
	DWORD dwWrapSize;
	
	// get rid of the header sendplayermessage put on it...
	dwMessageSize -= this->dwSPHeaderSize;
	pSendBuffer += this->dwSPHeaderSize;
	
	dwWrapSize = dwMessageSize +  GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	
	// alloc a new message buffer, wrap it w/ our header and send it out
	pWrapBuffer = DPMEM_ALLOC(dwWrapSize);
	if (!pWrapBuffer)
	{
		DPF_ERR("could not send player-player message OUT OF MEMORY");
		return E_OUTOFMEMORY;
	}

	psm = (LPMSG_SYSMESSAGE)(pWrapBuffer + this->dwSPHeaderSize);
	
	SET_MESSAGE_HDR(psm);
	SET_MESSAGE_COMMAND(psm,DPSP_MSG_PLAYERWRAPPER);

	// set up the buffer,
	memcpy(pWrapBuffer + this->dwSPHeaderSize + sizeof(MSG_SYSMESSAGE),pSendBuffer,
		dwMessageSize);
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pWrapBuffer,dwWrapSize,
		dwFlags, bDropLock);		
		
	DPMEM_FREE(pWrapBuffer);
	
	return hr;
} // WrapPlayerMessage


// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	if(psp->pPlayerTo){
		psm->idTo = psp->pPlayerTo->dwID;
	} else {
		ASSERT(psp->pGroupTo);
		psm->idTo = psp->pGroupTo->dwID;
	}

	InsertSendBufferAtFront(psp,psm,sizeof(MSG_PLAYERMESSAGE),PlayerMessageFreeFn,PlayerMessageFreeContext);

	return DP_OK;
		
	
} // SetupPlayerMessage

HRESULT	ReplacePlayerHeader(LPDPLAYI_DPLAY this,LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	PGROUPHEADER pGroupHeader;
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	ASSERT(psp->pGroupTo);
	psm->idTo = psp->pGroupTo->dwID;

	// link the old header on list to be freed when send is done.
	pGroupHeader=(PGROUPHEADER)psp->Buffers[0].pData;
	pGroupHeader->pNext=psp->pGroupHeaders;
	psp->pGroupHeaders=pGroupHeader;

	psp->Buffers[0].pData=(PUCHAR)psm;
	ASSERT(psp->Buffers[0].len==sizeof(MSG_PLAYERMESSAGE));
	return DP_OK;
}

// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessage(LPDPLAYI_DPLAY this,LPBYTE * ppSendBuffer,DWORD * pdwMessageSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,LPVOID pvBuffer,DWORD dwBufSize)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	ASSERT(pdwMessageSize);
	ASSERT(ppSendBuffer);

	*pdwMessageSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_PLAYERMESSAGE);

	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		*pdwMessageSize -= sizeof(MSG_PLAYERMESSAGE);
		bPutMessageIDs = FALSE;
	}
	
	*ppSendBuffer = DPMEM_ALLOC(*pdwMessageSize);
    if (NULL == *ppSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	if (bPutMessageIDs)
	{
		psm = (	LPMSG_PLAYERMESSAGE ) (*ppSendBuffer +  this->dwSPHeaderSize);
		// not naked - put to + from on 
		psm->idFrom = pPlayerFrom->dwID;
		psm->idTo = pPlayerTo->dwID;

		// copy player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize + sizeof(MSG_PLAYERMESSAGE),(LPBYTE)pvBuffer,dwBufSize);
	}
	else
	{
		// naked!
		// copy just player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize,(LPBYTE)pvBuffer,dwBufSize);
	}
	
	return DP_OK;
		
	
} // SetupPlayerMessage

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize)
{
	HRESULT hr=DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer=NULL;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // should we drop the lock across send?

	hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,pPlayerTo,
		pvBuffer,dwBufSize);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",dwFlags,dwMessageSize,dwBufSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop it
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((dwMessageSize >= sizeof(DWORD)) && 
		(*(DWORD *)(pSendBuffer + this->dwSPHeaderSize) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - repackaging");
		hrSend = WrapPlayerMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,
			dwMessageSize,dwFlags,bDropLock);
	}
	else 
	{
		hrSend = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize,
			dwFlags,bDropLock);		
	}	
	if (FAILED(hrSend) && (hrSend != DPERR_PENDING))	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	return hrSend;

} // SendPlayerMessage	

MSG_SYSMESSAGE COMMAND_WRAPPER={MSG_HDR,DPSP_MSG_PLAYERWRAPPER};

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	HRESULT hr=DP_OK;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // did we drop the lock ?

	hr = SetupPlayerMessageEx(this, psp);
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",psp->dwFlags,psp->dwTotalSize,psp->dwDataSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		psp->pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation -- OPTIMIZATION
	if (psp->dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop lock across send call.
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((psp->Buffers[0].len >= sizeof(DWORD)) && 
		(*(DWORD *)(psp->Buffers[0].pData) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - tacking on wrapping");
	 	InsertSendBufferAtFront(psp,&COMMAND_WRAPPER,sizeof(COMMAND_WRAPPER),NULL,NULL);
	}

	// Directed send usually requires one send to the application, so allocate one
	// context in the context list to begin with.
	InitContextList(this,psp,1);
	
	hrSend = SendDPMessageEx(this,psp,bDropLock);		
	
	if (FAILED(hrSend) && hrSend != DPERR_PENDING)	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hrSend;

} // SendPlayerMessageEx


#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessage"

// call the SP's send to group function
// called by SendGroupMessage
HRESULT SendSPGroupMessage(LPDPLAYI_DPLAY this,DPID idPlayerFrom,DPID idGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize)
{
	DPSP_SENDTOGROUPDATA sd;
	HRESULT hr;

	sd.dwFlags = dwFlags;
	sd.idGroupTo = idGroupTo;
	sd.idPlayerFrom = idPlayerFrom;
	sd.lpMessage = pvBuffer;
	sd.dwMessageSize = dwBufSize;
	sd.lpISP = this->pISP;

    hr = CALLSP(this->pcbSPCallbacks->SendToGroup,&sd);
    
    if (FAILED(hr))
    {
    	DPF(0,"send to group failed! hr = 0x%08lx\n",hr);
    }
    
    return hr;
    
} // SendSPGroupMessage

#undef DPF_MODNAME

#define DPF_MODNAME "SendGroupMessageEx"
HRESULT SendSPGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	DWORD dwSPMsgID;
	DPSP_SENDTOGROUPEXDATA sed;
	HRESULT hr;

	hr=InitContextList(this,psp,1);

	if(FAILED(hr)){
		return hr;
	}

	sed.lpISP          = this->pISP;
	sed.dwFlags        = psp->dwFlags;
	sed.idGroupTo      = psp->idTo;
	sed.idPlayerFrom   = psp->idFrom;
	sed.lpSendBuffers  = &psp->Buffers[0];
	sed.cBuffers       = psp->cBuffers;
	sed.dwMessageSize  = psp->dwTotalSize;
	sed.dwPriority     = psp->dwPriority;
	sed.dwTimeout      = psp->dwTimeout;
	sed.lpDPContext    = psp->hContext;
	sed.lpdwSPMsgID    = &dwSPMsgID;

	pspAddRef(psp);

    hr = CALLSP(this->pcbSPCallbacks->SendToGroupEx,&sed);

	if(hr==DPERR_PENDING){
                AddContext(this,psp,(LPVOID)(DWORD_PTR)dwSPMsgID);
	} else {
		pspDecRef(this, psp);
	}
	return hr;
}
#undef DPF_MODNAME

#define DPF_MODNAME "AskServerToMulticast"
// ask the name server to send our group message for us
HRESULT AskServerToMulticast(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPMSG_ASK4MULTICAST pmsg;
	DWORD dwTotalSize; // pvBuffer + pmsg
	LPBYTE pSendBuffer; // buffer we're going to send out
	HRESULT hr;
	BOOL bDropLock=FALSE; // drop the lock ?
		
	DPF(4,"routing group send via multicast server");

	if (!fPlayerMessage)	
	{
		// don't ship the header on our embedded system message
		ASSERT(dwBufSize > this->dwSPHeaderSize); // better have a header on it! 
		dwBufSize -= this->dwSPHeaderSize;
		pvBuffer = (LPBYTE)pvBuffer + this->dwSPHeaderSize; // point to the system message

		if (SECURE_SERVER(this))
		{
			// we are making the system message secure here because the hook cannot distinguish 
			// between a player and a system message when multicasted. A secure player message 
			// will have this flag set.
			dwFlags |= DPSEND_SIGNED;
		}
	}
	
	dwTotalSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_ASK4MULTICAST);
	
	pSendBuffer = DPMEM_ALLOC(dwTotalSize);
	if (!pSendBuffer)
	{
		DPF_ERR("could not send group message - out of memory");
		return DPERR_OUTOFMEMORY;
		
	}

	pmsg = (LPMSG_ASK4MULTICAST)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);

	if (dwFlags & DPSEND_GUARANTEED)
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICASTGUARANTEED);		
	}
	else 
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICAST);
	}

	// set up the fixed data
	pmsg->idGroupTo = pGroupTo->dwID;
	pmsg->idPlayerFrom = pPlayerFrom->dwID;
	pmsg->dwMessageOffset = sizeof(MSG_ASK4MULTICAST);
	
	// stick the message on the end
	memcpy((LPBYTE)pmsg+sizeof(MSG_ASK4MULTICAST),pvBuffer,dwBufSize);

	// if it's a guaranteed send of a player message, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (fPlayerMessage && (dwFlags & DPSEND_GUARANTEED))
	{
		DPF(6,"guaranteed player message being multicasted - entering pending mode");
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop the lock across send.
	}
	
	// send it to the nameserver
   	hr = SendDPMessage(this,pPlayerFrom,this->pNameServer,(LPBYTE)pSendBuffer,dwTotalSize,dwFlags,bDropLock);			

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;	

} // AskServerToMulticast

#define MAX_FAST_TO_IDS 512

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER	pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeWalker;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	HRESULT hr=DP_OK;
	BOOL bAlloc = FALSE; // did we alloc the send buffer?
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // did we drop the lock?

	DPID FromID;
	DPID ToID;

	UINT iToIDs;
	UINT cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// send it to the multicast server
		hr = AskServerToMulticast(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
			dwBufSize,fPlayerMessage);
		return hr;
	}

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,(LPDPLAYI_PLAYER)pGroupTo,
			pvBuffer,dwBufSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}
		bAlloc = TRUE;
	}
	else 
	{
		pSendBuffer = pvBuffer;
		dwMessageSize = dwBufSize;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// we dropped it
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && 
		!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		FromID = pPlayerFrom->dwID;
		ToID   = pGroupTo->dwID;
		if(bDropLock){
			LEAVE_DPLAY();
		}
		// group is owned by sp,  let them do the send
		hr = SendSPGroupMessage(this,FromID,ToID,dwFlags,pSendBuffer,dwMessageSize);
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
		}

		
		iToIDs = 0;

//		a-josbor:  I'm not sure what this 'fix' is trying to say.  The pGroupTo->nPlayers is a count of all the 
//			regular (non-sys) players in the group.  This is different from the number of system players
//			that proxy all those players.  The count of the system players is really the only thing
//			interesting in post-DX3 games.  However, the code DOES do the right thing (count and send)
//			to only the system players.

			//cToIDs = pGroupTo->nPlayers+1; // sometimes we see a sysgroup with count not set so +1
			// workaround, sometimes count not right...
			lpGroupnodeWalker=lpGroupnode;

			cToIDs=0;
			while(lpGroupnodeWalker){
			   cToIDs++;     
			   lpGroupnodeWalker = lpGroupnodeWalker->pNextGroupnode; 
			}
			if(pGroupTo->nPlayers+1 < cToIDs){
				DPF(0,"WARNING: Group player count bad! (%d < %d) good thing we are working around...\n", pGroupTo->nPlayers+1, cToIDs);
			}
			// end workaround
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
			if(!pdwToIDs){
				hr=DPERR_NOMEMORY;
				goto error_exit;
			}
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])rgdwToIDs;
		}

		iToIDs=0;

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){
		
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (fPlayerMessage)
			{
				LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);

				if(bDX3SetPlayerTo) {
					pmsg->idTo = (*pdwToIDs)[iToIDs];
				} 
			}
			else // it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);
				DWORD dwCommand=GET_MESSAGE_COMMAND(pmsg);

				// If it's a chat message, we don't want to mess with the To player ID
				if(dwCommand != DPSP_MSG_CHAT && dwCommand != DPSP_MSG_VOICE){
					if(bDX3SetPlayerTo) {
						pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
					} 
					else 
					{
//						a-josbor: it's a system message, so just set the to field to 0
//							to avoid garbage on the wire.  The message will be distributed
//							to the system group on all receipient machines.
						pmsg->dwIDTo = 0;
					}	
				}
			}

			pPlayer=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(pPlayer){

			   	hr = SendDPMessage(this,pPlayerFrom,pPlayer,pSendBuffer,dwMessageSize,dwFlags,bDropLock);		
				if (FAILED(hr) && (hr != DPERR_PENDING))	
				{
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
		
		if(pdwToIDs != (DWORD (*)[])rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	if (bAlloc) DPMEM_FREE(pSendBuffer);

	return DP_OK;

error_exit:
	if (bAlloc) DPMEM_FREE(pSendBuffer);
	return hr;
	
} // SendGroupMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessageEx"

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode;
	LPBYTE pSendBuffer=NULL;
	HRESULT hr=DP_OK,hr2;
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // Are we dropping the lock across sends?
	BOOL bReturnPending = FALSE;

	DPID FromID;
	DPID ToID;

	UINT  iToIDs;
	UINT  cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
	BOOL  bIds;
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
	#if 0
		// Makes room for a header, so strip it.
		pSendBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pSendBuffer){
			return DPERR_NOMEMORY;
		}
		// send it to the multicast server
		hr = AskServerToMulticast(this,
								  psp->pPlayerFrom,
								  psp->pGroupTo,
								  psp->dwFlags & ~DPSEND_NOCOPY,
								  pSendBuffer+this->dwSPHeaderSize,
								  psp->dwTotalSize,
								  fPlayerMessage);
	#endif
		// send it to the multicast server
		// Since this fn is only ever called with 1 SG buffer currently, this is more effecient...
		hr = AskServerToMulticast(this,
								  psp->pPlayerFrom,
								  psp->pGroupTo,
								  psp->dwFlags & ~DPSEND_NOCOPY,
								  psp->Buffers[0].pData,
								  psp->Buffers[0].len,
								  fPlayerMessage);
	
		goto EXIT;
	}

	bIds=(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)?(FALSE):(TRUE);

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessageEx(this,psp);
		if(FAILED(hr)){
			goto EXIT;
		}
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((psp->dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// drop lock across send calls.
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		FromID = psp->pPlayerFrom->dwID;
		ToID   = psp->pGroupTo->dwID;
		
		if(bDropLock){
			LEAVE_DPLAY();
		}
		
		// group is owned by sp,  let them do the send
		if(this->pcbSPCallbacks->SendToGroupEx){
			hr=SendSPGroupMessageEx(this,psp);
		} else {
			pSendBuffer=ConcatenateSendBuffer(this,&psp->Buffers[0],psp->cBuffers,psp->dwTotalSize);
			if(!pSendBuffer){
				goto EXIT;
			}
			hr = SendSPGroupMessage(this,
									FromID,
									ToID,
									psp->dwFlags,
									pSendBuffer,
									psp->dwTotalSize+this->dwSPHeaderSize);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}	

		if(bDropLock){
			ENTER_DPLAY();
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = psp->pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
		}


		// AO - Fixing a bug, can't run grouplist without a lock!  so we will copy the id's
		//      into a list.  The maximum size of the list is pGroupTo->nPlayers, so we alloc
		//      a buffer of this size.  If there are less than 128 entries, we get the memory
		//      from the stack, if not, we get the memory from the heap.

		iToIDs = 0;
		cToIDs = psp->pGroupTo->nPlayers+1;
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
			if(!pdwToIDs){
				hr=DPERR_NOMEMORY;
				goto EXIT;
			}
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])rgdwToIDs;
		}

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		if(!cToIDs){
			goto EXIT2;
		}

		// Now we know how big the list will be, we can allocate a context list.
		hr=InitContextList(this,psp,cToIDs);
		if(FAILED(hr)){
			goto EXIT2;
		}
		
		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){


			if(bIds){
				if(fPlayerMessage && (iToIDs > 0) && 
				  (psp->dwFlags & DPSEND_ASYNC)){
					// Need to swap out header so its unique during the call if
					// we are sending async.
					hr=ReplacePlayerHeader(this,psp);
					if(hr!=DP_OK){
						bReturnPending=FALSE;
						DPF(0,"Ran out of memory building unique header for group send\n");
						break;
					}
				}
			
				// if there's a dx3 client in the game, we can't deliver it to a group - 
				// we need to put the correct player id in the message
				if (fPlayerMessage)
				{
					LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(psp->Buffers[0].pData);

					if(bDX3SetPlayerTo) {
						pmsg->idTo = (*pdwToIDs)[iToIDs];
					} else {
						pmsg->idTo = 0;
					}	
				}
			}	
			else if(!fPlayerMessage)// it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(psp->Buffers[0].pData);

				if(bDX3SetPlayerTo) {
					pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
				} else {
					pmsg->dwIDTo = 0;
				}	
			}

			psp->pPlayerTo=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(psp->pPlayerTo){

		   		hr = SendDPMessageEx(this,psp,bDropLock);	// handles adding refs.

				if(hr==DPERR_PENDING){
					bReturnPending=TRUE;				
				} else if(FAILED(hr)) {
					if(hr==DPERR_NOMEMORY){
						bReturnPending=FALSE;
					}
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
EXIT2:		
		if(pdwToIDs != (DWORD (*)[])rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

EXIT:

	if(pSendBuffer){
		MsgFree(NULL,pSendBuffer);
	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr2 = ExecutePendingCommands(this);
		if (FAILED(hr2))
		{
			ASSERT(FALSE);
		}
	}

	if(bReturnPending){
		return DPERR_PENDING;
	} else {	
		return hr;
	}	

} // SendGroupMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendPlayerManagementMessage"

// called by InternalAddPlayerToGroup , InternalDeletePlayerFromGroup, InternalDestroyGroup, InternalDestroyPlayer
// addplayer/addgroup use sendaddmessage
HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup)
{
	DWORD dwMessageSize;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	HRESULT hr;
	LPBYTE pBuffer;
	DWORD dwExtraFlags=0;
//	BOOL bWait=FALSE;

	if(dwCmd & DPSP_MSG_ASYNC){
		dwCmd &= ~DPSP_MSG_ASYNC;
		dwExtraFlags=DPSEND_SYSMESS;
	}


	// alloc + set up message
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE);

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,dwCmd);

	// fill in message specific info
	switch (dwCmd)
	{
		case DPSP_MSG_DELETEPLAYER:
			pmsg->dwPlayerID = idPlayer;
			
			if(this->pSysPlayer && idPlayer==this->pSysPlayer->dwID){
				//dwExtraFlags = 0; // by init
			} else {
//				bWait=TRUE;
				dwExtraFlags = DPSEND_SYSMESS;
			}
			break;
			

		case DPSP_MSG_DELETEGROUP:
			pmsg->dwGroupID = idGroup;
			break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:
		case DPSP_MSG_ADDPLAYERTOGROUP:
		case DPSP_MSG_DELETEPLAYERFROMGROUP:  
			pmsg->dwPlayerID = idPlayer;
			pmsg->dwGroupID = idGroup;
			break;
			
		default:
			ASSERT(FALSE);
			break;			
	}	

	hr = SendSystemMessage(this,pBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

	DPMEM_FREE(pBuffer);

//	if(bWait){
//		Sleep(250);
//	}

	return hr;

} // SendPlayerManagementMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDataChanged"

// the player blob has changed. tell the world.
HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERDATA msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERDATA) + pPlayer->dwPlayerDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERDATACHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPDATACHANGED);
	
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwDataSize = pPlayer->dwPlayerDataSize;
	msg.dwDataOffset = sizeof(msg);
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));
	// copy the new player data into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->pvPlayerData,
		pPlayer->dwPlayerDataSize);

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize, dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendDataChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendNameChanged"

// the players name has changed. tell the world.
HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERNAME msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
	UINT nShortLength,nLongLength; // name length, in bytes

	nShortLength = WSTRLEN_BYTES(pPlayer->lpszShortName);
	nLongLength =  WSTRLEN_BYTES(pPlayer->lpszLongName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERNAME) + nShortLength + nLongLength; 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERNAMECHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPNAMECHANGED);

	msg.dwPlayerID = pPlayer->dwID;

	// copy the short name into the buffer
	if (nShortLength)
	{
		// copy the short name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->lpszShortName,
			nShortLength);
		msg.dwShortOffset = sizeof(msg);
	}
	else 
	{
		msg.dwShortOffset = 0;
	}
	// copy the long name into the send buffer	
	if (nLongLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nShortLength,
			pPlayer->lpszLongName,nLongLength);
		msg.dwLongOffset = sizeof(msg) + nShortLength;
	}
	else 
	{
		msg.dwLongOffset = 0;
	}
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendNameChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendIAmNameServer"

// this idirectplay has become the nameserver.  tell all remote players.
HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this)
{
	LPBYTE pbuf;
	LPMSG_IAMNAMESERVER pmsg;
	HRESULT hr;

	pbuf=DPMEM_ALLOC(GET_MESSAGE_SIZE(this,MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize);

	if(pbuf) {

		pmsg=(LPMSG_IAMNAMESERVER)(pbuf+this->dwSPHeaderSize);

		memset(pmsg,0,sizeof(MSG_IAMNAMESERVER));

	    // build a message to send 
		SET_MESSAGE_HDR(pmsg);
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_IAMNAMESERVER);

		ASSERT(this->pSysPlayer);
		ASSERT(this->pSysPlayer->dwID);

		pmsg->dwIDHost = this->pSysPlayer->dwID;
		pmsg->dwFlags = this->pSysPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS|DPLAYI_PLAYER_PLAYERLOCAL);
		pmsg->dwSPDataSize = this->pSysPlayer->dwSPDataSize;
		memcpy((PCHAR)(pmsg+1),this->pSysPlayer->pvSPData, this->pSysPlayer->dwSPDataSize);

		hr = SendSystemMessage(this,pbuf,this->dwSPHeaderSize+sizeof(MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize,DPSEND_SYSMESS,FALSE);

		DPMEM_FREE(pbuf);

	} else {
		hr=DPERR_OUTOFMEMORY;
	}
	return hr;

} // SendIAmNameServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendMeNameServer"

// this idirectplay has become the nameserver.  tell all local players.
HRESULT SendMeNameServer(LPDPLAYI_DPLAY this)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));

    // build a message to send to our local players
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_NAMESERVER);

	// send it out to our local players 
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	return hr;

} // SendMeNameServer

#undef DPF_MODNAME
#define DPF_MODNAME "SendSessionDescChanged"

// the sessiion desc has changed. tell the world.
HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags)
{
	MSG_SESSIONDESC msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
    UINT nSessionNameLength, nPasswordLength;

    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
    SET_MESSAGE_COMMAND(&msg,DPSP_MSG_SESSIONDESCCHANGED);
    memcpy(&(msg.dpDesc), this->lpsdDesc, sizeof(DPSESSIONDESC2));

    // calculate the size of the send buffer
    nSessionNameLength  = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	nPasswordLength     = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
	// message size + name + password
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SESSIONDESC) 
                    + sizeof(DPSESSIONDESC2) + nSessionNameLength 
                    + nPasswordLength;

    // allocate send buffer
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not session desc changed message - out of memory");
        return E_OUTOFMEMORY;
    }
		
	// copy the session name into the buffer
	if (nSessionNameLength)
	{
		// copy the session name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),this->lpsdDesc->lpszSessionName,
			nSessionNameLength);
		msg.dwSessionNameOffset = sizeof(msg);
	}
	else 
	{
		msg.dwSessionNameOffset = 0;
	}

	// copy the password into the send buffer	
	if (nPasswordLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nSessionNameLength,
			this->lpsdDesc->lpszPassword,nPasswordLength);
		msg.dwPasswordOffset = sizeof(msg) + nSessionNameLength;
	}
	else 
	{
		msg.dwPasswordOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,FALSE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendSessionDescChanged


#undef DPF_MODNAME
#define DPF_MODNAME "SendChatMessage"

// Send a chat message (it's in system message format)
HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer)
{
	MSG_CHAT msg;
	LPBYTE pSendBuffer;
	DWORD dwMsgSize;
	HRESULT hr;
	UINT nMsgLength; // message length, in bytes

	nMsgLength = WSTRLEN_BYTES(lpMsg->lpszMessage);

	// message size + blob size
	dwMsgSize = GET_MESSAGE_SIZE(this,MSG_CHAT) + nMsgLength; 

    pSendBuffer = DPMEM_ALLOC(dwMsgSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send chat message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the player (or group)
	SET_MESSAGE_HDR(&msg);

	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CHAT);

	msg.dwIDFrom = pPlayerFrom->dwID;
	msg.dwIDTo = pPlayerTo->dwID;
	msg.dwFlags = lpMsg->dwFlags;

	// copy the short name into the buffer
	if (nMsgLength)
	{
		// copy the message into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),
			lpMsg->lpszMessage,	nMsgLength);
		msg.dwMessageOffset = sizeof(msg);
	}
	else 
	{
		msg.dwMessageOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// Send to the appropriate player(s)
	if(fPlayer)
	{
		if(dwFlags & DPSEND_GUARANTEE){
			this->dwFlags |= DPLAYI_DPLAY_PENDING;

		}
		hr = SendDPMessage( this, pPlayerFrom, pPlayerTo, pSendBuffer,
				dwMsgSize, dwFlags|DPSEND_ASYNC, (dwFlags&DPSEND_GUARANTEE)?TRUE:FALSE);

		ExecutePendingCommands(this);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this, pPlayerFrom, (LPDPLAYI_GROUP)pPlayerTo,
				dwFlags|DPSEND_ASYNC, pSendBuffer, dwMsgSize, FALSE);
	}
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendChatMessage


// called by SendAsyncAddForward to see if we should send an add forward
// to pPlayer
BOOL IsInAddForwardList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	BOOL bFound = FALSE;
	
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pPlayer->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	return bFound;
	
} // IsInAddForwardList

HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPADDFORWARDNODE pnode)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize;
	LPDPLAYI_GROUPNODE lpGroupnode;
	LPDPLAYI_PLAYER pPlayerTo;
		
	ASSERT(IAM_NAMESERVER(this));
	
	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this)) return DP_OK;

	// no add forward in client server 
	if (CLIENT_SERVER(this)) return DP_OK; 
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,TRUE);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_ADDFORWARD);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),TRUE);

	// now, send it to all system players who are not in the addforwardq
	ASSERT(this->pSysGroup);
	lpGroupnode = this->pSysGroup->pSysPlayerGroupnodes;			
	while (lpGroupnode)
	{
		pPlayerTo = lpGroupnode->pPlayer;
		lpGroupnode = lpGroupnode->pNextGroupnode;
		if (!IsInAddForwardList(this,pPlayerTo) && (pPlayerTo != this->pSysPlayer))
		{
			pnode->nAcksReq++; // we're sending to pPlayerTo, we need an ack from him
			
		   	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,
				DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);		
			if (FAILED(hr)) 
			{
				DPF(0,"SendAddForward : send message failed hr = 0x%08lx\n",hr);	
				pnode->nAcksReq--;
				// keep trying...
			}
		}
	}
   
    DPF(2,"sent add forward announcment id = %d - nAcksRequired = %d",msg.dwPlayerID,pnode->nAcksReq); 
	
	DPMEM_FREE(pSendBuffer);
	
    // done
    return DP_OK;

} // SendAsyncAddForward
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\voice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.c
 *  Content:	direct play voice method support
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  10/21/97	andyco	   	created it
  ***************************************************************************/
		
					
#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "SendVoiceMessage"
HRESULT SendVoiceMessage(LPDPLAYI_DPLAY this,BOOL fOpen,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo)
{
	HRESULT hr = DP_OK;
	LPMSG_VOICE pmsg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
    
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_VOICE);
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }

	// message follows header    
	pmsg = (LPMSG_VOICE)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	if (fOpen) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICEOPEN);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICECLOSE);
	
	pmsg->dwIDTo 	= pPlayerTo->dwID;
	pmsg->dwIDFrom 	= pPlayerFrom->dwID;
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize, DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"SendVoiceMessage : senddpmessage failed hr = 0x%08lx\n",hr);	
		// keep trying...
	}
	
	DPMEM_FREE(pSendBuffer);
		
	return hr;	
		
}  // SendVoiceMessage

HRESULT InternalCloseVoice(LPDPLAYI_DPLAY this,BOOL fPropagate)
{
    HRESULT hr = DP_OK;
	DPSP_CLOSEVOICEDATA cvd;
	LPDPLAYI_PLAYER pVoiceTo,pVoiceFrom;
	
	// make sure voice is open
	if (!this->pVoice)
	{
		DPF_ERR("voice channel not open!");
		return E_FAIL;
	}

	if (fPropagate) 
	{
		// 
		// we generated this message.  we need to tell sp.  
		// call SP if SP supports it 
		//
		if (this->pcbSPCallbacks->CloseVoice)
		{
			cvd.lpISP = this->pISP;
			cvd.dwFlags = 0;
		    hr = CALLSP(this->pcbSPCallbacks->CloseVoice,&cvd);
		    if (FAILED(hr)) 
		    {
				DPF_ERRVAL("SP Close voice call failed!  hr = 0x%08lx\n",hr);
				// keep going
				hr = DP_OK;
		    }
		}
		
		pVoiceTo = PlayerFromID(this,this->pVoice->idVoiceTo);
		if (!VALID_DPLAY_PLAYER(pVoiceTo)) 
		{
			DPF_ERR("could not send voice msg - invalid player to!");
			goto ERROR_EXIT;
		}

		pVoiceFrom = PlayerFromID(this,this->pVoice->idVoiceFrom);
		if (!VALID_DPLAY_PLAYER(pVoiceFrom)) 
		{
			DPF_ERR("could not send voice msg - invalid player From!");
			goto ERROR_EXIT;
		}

		hr = SendVoiceMessage(this, FALSE, pVoiceFrom,pVoiceTo);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
		
	} // fPropagate
	
ERROR_EXIT:
	
	// free up voice
	DPMEM_FREE(this->pVoice);
	this->pVoice = NULL;
	
	return DP_OK;	
}	// InternalCloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_CloseVoice"
HRESULT DPAPI DP_CloseVoice(LPDIRECTPLAY lpDP,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

	ENTER_SERVICE();
    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	hr = InternalCloseVoice( this, TRUE);

	// fall through
CLEANUP_EXIT:
	LEAVE_SERVICE();
    LEAVE_DPLAY();

	return hr;
	
} // DP_CloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_OpenVoice"

HRESULT InternalOpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo = NULL; 
    LPDPLAYI_PLAYER pPlayerTo = NULL,pPlayerFrom = NULL;
	BOOL bToPlayer= FALSE;
	DPSP_OPENVOICEDATA ovd;
	LPDPVOICE pVoice;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto CLEANUP_EXIT;
		}

		// see if it's a player or group
		pPlayerTo = PlayerFromID(this,idTo);
		if (VALID_DPLAY_PLAYER(pPlayerTo)) 
		{		  
			bToPlayer = TRUE;
		}
		else 
		{
			pGroupTo = GroupFromID(this,idTo);
			if (VALID_DPLAY_GROUP(pGroupTo)) 
			{
				bToPlayer = FALSE;
				// cast to player...
				pPlayerTo = (LPDPLAYI_PLAYER)pGroupTo;
				// voice not supported to groups for DX6
				DPF_ERR("voice not supported to groups yet - FAILING OPEN VOICE");
				hr = E_NOTIMPL;
				goto CLEANUP_EXIT;
			}
			else 
			{
				// bogus id! - player may have been deleted...
				DPF_ERR("bad player to");
				hr = DPERR_INVALIDPARAMS;
				goto CLEANUP_EXIT;
			}// not player or group
		} // group

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	// make sure they called Open w/ DPOPEN_VOICE
	if (!(this->dwFlags & DPLAYI_DPLAY_VOICE))
	{
		DPF_ERR("must call IDirectPlayX->Open w/ DPOPEN_VOICE to use OpenVoice!");
		hr = DPERR_UNAVAILABLE;
		goto CLEANUP_EXIT;
	}
	
	// can only have one voice 
	if (this->pVoice)
	{
		DPF_ERR("voice channel already open!");
		hr = DPERR_ALREADYINITIALIZED;
		goto CLEANUP_EXIT;
	}

	// make sure SP supports it 
	if (! (this->pcbSPCallbacks->OpenVoice) )
	{
		DPF_ERR("voice not supported by SP");
		hr = DPERR_UNSUPPORTED;
		goto CLEANUP_EXIT;
	}

	// if we're originating - make sure to + from are ok w/ voice
	if (fPropagate)	
	{
		// no voice open to local players
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
		{
			DPF_ERR("voice not supported to local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
		
		// no voice open from non-local players
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("voice not supported from non-local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}

		// make sure player to can accept calls	
		if (!pPlayerTo->dwFlags & DPLAYI_PLAYER_HASVOICE)
		{
			DPF_ERR("remote system does not support voice");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
	}
	
	// go get us a dpvoice
	pVoice = DPMEM_ALLOC(sizeof(DPVOICE));
	if (!pVoice)
	{
		DPF_ERR("could not alloc internal voice struct! out of memory");
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	pVoice->idVoiceTo = idTo;
	pVoice->idVoiceFrom = idFrom;

		
	if (fPropagate)	
	{
		// set up voice data
		ovd.idTo = idTo;
		ovd.idFrom = idFrom;
		ovd.bToPlayer = bToPlayer;
		ovd.lpISP = this->pISP;

		// tell SP to start it up
	    hr = CALLSP(this->pcbSPCallbacks->OpenVoice,&ovd);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SP Open voice call failed!  hr = 0x%08lx\n",hr);
			// clean up the DPVOICE
			DPMEM_FREE(pVoice);
			goto CLEANUP_EXIT;
	    }

		hr = SendVoiceMessage(this, TRUE, pPlayerFrom,pPlayerTo ); 
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
	}

	// open succeeded - store dpvoice	
	this->pVoice = pVoice;

	// fall through
CLEANUP_EXIT:

	return hr;
    
	
} // InternalOpenVoice

HRESULT DPAPI DP_OpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	ENTER_SERVICE();
	
	hr =  InternalOpenVoice(lpDP, idFrom,idTo,dwFlags,TRUE);
	
	LEAVE_DPLAY();
	LEAVE_SERVICE();
	
	return hr;	
} // DP_OpenVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLAYSVR"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\dphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.c
 *  Content:    allows the dplay winsock sp's to all share a single
 *      	server socket
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18-jul-96  andyco  initial implementation
 *   25-jul-96	andyco	ddhelp now watches dplay procs so it can remove
 *						them from our list when they go away
 *   3-sep-96	andyco	don't get stale ip's - pick up a default ip whenever
 *						we add a servernode. bug 3716.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *						it in dphelps receive thread before forwarding requests
 *   21-jan-97	kipo	use LoadLibrary on "wsock32.dll" instead of statically
 *						linking to it so DDHELP will still run even when Winsock
 *						is not around. This lets DDRAW and DSOUND work. Fixes
 *						bug #68596.
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *   01-jan-2000 aarono aaded support for rsip
 *
 ***************************************************************************/
/*============================================================================
*                                                                             
*  Why this file exists :                                                     
*                                                                             
*   when you want to find a dplay game, you send a message to a well      
*   known port (an enumrequest).                                          
*                                                                             
*   if a game is being hosted on that system, it will listen on that      
*   port, and respond to the message.                                     
*                                                                             
*   BUT, only one process can listen on a given socket.                  
*                                                                             
*   So, we let ddhelp.exe listen on that socket, and forward enumrequests 
*   to all games registered as being hosted on this system.
*	
*   see also : \%MANROOT%\dplay\wsock\dpsp.h
*                                                                             
*****************************************************************************/

// todo - should we return error codes on AddServer xproc to our caller?

#include "dphelp.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DPHELP"

/*
 *  GLOBALS
 */ 
SOCKET gsDatagramListener = INVALID_SOCKET; // we listen for datagrams on this socket
SOCKET gsForwardSocket = INVALID_SOCKET;
SOCKET gsStreamListener;					// we listen for tcp connections on this socket
LPSPNODE gNodeList;
BOOL gbInit=FALSE,gbIPStarted=FALSE;
HANDLE ghDatagramReceiveThread,ghStreamReceiveThread;
BOOL gbReceiveShutdown;						// receive thread will exit when TRUE

// pointers to Winsock routines returned from GetProcAddress
cb_accept			g_accept;
cb_bind				g_bind;
cb_closesocket		g_closesocket;
cb_gethostbyname	g_gethostbyname;
cb_gethostname		g_gethostname;
cb_getpeername		g_getpeername;
cb_getsockname		g_getsockname;
cb_inet_ntoa		g_inet_ntoa;
cb_recvfrom			g_recvfrom;
cb_recv				g_recv;
cb_select			g_select;
cb_send				g_send;
cb_sendto			g_sendto;
cb_setsockopt		g_setsockopt;
cb_shutdown			g_shutdown;
cb_socket			g_socket;
cb_WSAFDIsSet		g_WSAFDIsSet;
cb_WSAGetLastError	g_WSAGetLastError;
cb_WSAStartup		g_WSAStartup;
cb_listen			g_listen;
cb_htons			g_htons;
cb_ntohs			g_ntohs;
cb_inet_addr		g_inet_addr;
cb_htonl            g_htonl;

#ifdef DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintAddr"

// helper function called from DEBUGPRINTADDR macro
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
    SOCKADDR_IN * pin = (SOCKADDR_IN *)psockaddr;

     DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
     	g_inet_ntoa(pin->sin_addr),g_htons(pin->sin_port));

} // DebugPrintAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintSocket"

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	g_getsockname(*pSock,&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}

#endif // debug

// this is called every time we add a new server node to our list...
HRESULT GetDefaultHostAddr(DWORD * puHostAddr)
{

//	a-josbor: we used to get the first interface and use that, but WebTV taught
//		us that that can be dangerous.  So we just use the loopback address.
//		It's guaranteed to be there.  Or so they say...

    *puHostAddr = 0x0100007f;	// loopback	127.0.0.1 (<bleeping> little-endian)
	
    return DP_OK;
	
} // GetDefaultHostAddr

// the functions DPlayHelp_xxx are called from dphelp.c

//
// add a new node to our list of servers which want to have enum 
// requests forwarded to them...
HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd)
{
    LPSPNODE pNode;
    BOOL bFoundIt=FALSE;
    HRESULT hr;
	
    if (!gbInit) 
    {
		hr = DPlayHelp_Init();
		if (FAILED(hr))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (hr);
		}
    }

    // see if we're already watching this process
	// if we are, we won't start a watcher thread (below)
    pNode = gNodeList;

    // search the list 
    while (pNode && !bFoundIt)
    {
		if (pNode->pid == phd->pid) bFoundIt = TRUE;
		pNode = pNode->pNextNode;
    }

	//
	// now, build a new server node
    pNode = MemAlloc(sizeof(SPNODE));
    if (!pNode)
    {
        DPF_ERR("could not add new server node OUT OF MEMORY");
        return (DPERR_OUTOFMEMORY);
    }
    
    pNode->pid = phd->pid;
    // build the sockaddr
    // dwReserved1 of the phd is the port that the server is listening on
    pNode->sockaddr.sin_family =  AF_INET;
    
    // find the default ip to use w/ this host
    hr = GetDefaultHostAddr(&(pNode->sockaddr.sin_addr.s_addr));
	if (FAILED(hr))
    {
        DPF_ERR("could not get host IP address");
		MemFree(pNode);
        return (DPERR_UNAVAILABLE);
    }
    
    pNode->sockaddr.sin_port = phd->port;

    DPF(5,"dphelp :: adding new server node : pid = %d, port = %d\n",phd->pid,g_htons(phd->port));

    // link our new node onto the beginning of the list
    pNode->pNextNode = gNodeList;
    gNodeList = pNode;

	// see if we need to start our watcher thread    
    if (!bFoundIt)
    {
		//
	    // set up a thread to keep on eye on this process.
	    // we'll let the thread notify us when the process goes away
	    WatchNewPid(phd);
    }

    return (DP_OK);

} // DPlayHelp_AddServer

//
// delete the server node from proc pid from our list
// called by "ThreadProc" from DPHELP.c when the process that
// goes away, or from the client side when a session goes away.
//
// if bFreeAll is TRUE, we delete all server nodes for process
// phd->pid.  otherwise, we just delete the first server node whose
// port matches phd->port
//
BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL bFreeAll)
{
    BOOL bFoundIt = FALSE;
    LPSPNODE pNode,pNodePrev,pNodeNext;

    pNode = gNodeList;
    pNodePrev = NULL;
	pNodeNext = NULL;
	
    // search the whole list
    while (pNode && !bFoundIt)
    {
		// if we have the right pid, and it's either FreeAll or the right port - cruise it!
		if ((pNode->pid == phd->pid) &&  (bFreeAll || (pNode->sockaddr.sin_port == phd->port)) )
		{
		    // remove it from the list
		    if (pNodePrev) pNodePrev->pNextNode = pNode->pNextNode;
		    else gNodeList = pNode->pNextNode;
			
		    if (bFreeAll) 
		    {
				// pick up the next one b4 we free pNode
				pNodeNext = pNode->pNextNode;
		    }
			else 
			{
				// mark us as done
				bFoundIt = TRUE;
				pNodeNext = NULL;
			}

		    DPF(5,"dphelp :: deleting server node : pid = %d\n",pNode->pid);
		    // free up the node
		    MemFree(pNode);

			pNode = pNodeNext;
			// pNodePrev doesn't change here...
		}
		else 
		{
		    // just get the next one
		    pNodePrev = pNode;
		    pNode = pNode->pNextNode;
		}
    }


    return FALSE;

} // DPlayHelp_DeleteServer 

//
// poke an ip addr into a message blob 
// code stolen from \orange\dplay\wsock\winsock.c
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
    LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
    LPMESSAGEHEADER phead;

    phead = (LPMESSAGEHEADER)pmsg;

    paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
    // poke the new ip addr into the message header
    if(paddrDest->sin_addr.s_addr==0){ // don't rehome already homed messages
	    paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}    

    return;
	
} // IP_SetAddr

//
// we get a message.  presumably its an enumrequest. forward it to all registered clients.
// we "home" the message (store the received ip addr w/ it) here, 'cause otherwise the clients
// would all think it came from us.  we change the token to srvr_token so the clients know it
// came from us (so they don't home it again)
void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr)
{
    LPSPNODE pNode = gNodeList;
    UINT addrlen = sizeof(SOCKADDR_IN);
    UINT err;
	
    ASSERT(VALID_SP_MESSAGE(pBuffer));

    // reset the old token
    *( (DWORD *)pBuffer) &= ~TOKEN_MASK;
    // set the new token
    *( (DWORD *)pBuffer) |= HELPER_TOKEN;

    // home it
    IP_SetAddr((LPVOID)pBuffer,psockaddr);
    
    // now, forward the message to all registered servers
    while (pNode)
    {
		DEBUGPRINTADDR(7,"dplay helper  :: forwarding enum request to",(SOCKADDR *)&(pNode->sockaddr));
		// send out the enum message
        err = g_sendto(gsForwardSocket,pBuffer,dwBufferSize,0,(LPSOCKADDR)&(pNode->sockaddr),
    		addrlen);
        if (SOCKET_ERROR == err) 
        {
    	    err = g_WSAGetLastError();
	    	DPF(0,"dphelp : send failed err = %d\n",err);
        }

        pNode = pNode->pNextNode;
    }

    return ;

} // HandleIncomingMessage

//
// BUF_SIZE is our initial guess at a receive buffer size
// if we get an enum request bigger than this, we'll realloc our
// buffer, and receive successfully if they send again
// (the only way this could happen is if they have password > ~ 1000
// bytes).
#define BUF_SIZE 1024

//
// listen on our socket for enum requests
DWORD WINAPI ListenThreadProc(LPVOID pvUnused)
{
    UINT err;
    LPBYTE pBuffer=NULL;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
    DWORD dwBufSize = BUF_SIZE;

    DPF(2,"dphelp :: starting udp listen thread ");

    pBuffer = MemAlloc(BUF_SIZE);
    if (!pBuffer)
    {
        DPF_ERR("could not alloc dgram receive buffer");
        ExitThread(0);
        return 0;
    }
    while (1)
    {
        err = g_recvfrom(gsDatagramListener,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if (SOCKET_ERROR == err) 
        {
            err = g_WSAGetLastError();
            if (WSAEMSGSIZE == err)
            {
                LPBYTE pNewBuffer;

                // buffer too small!
                if(dwBufSize < 16384)
                {
	                dwBufSize *= 2;	

		    	    DPF(9,"\n udp recv thread - resizing buffer newsize = %d\n",dwBufSize);
	                pNewBuffer = MemReAlloc(pBuffer,dwBufSize);
	                if (!pNewBuffer)
	                {
	                    DPF_ERR("could not realloc dgram receive buffer");
	                    goto ERROR_EXIT;
	                }
	                pBuffer = pNewBuffer;
	                // we can't do anything with this message, since it was truncated...
                } else {
                	DPF(4,"SECURITY WARN: very large enum request received > 16K");
	            }
            } // WSAEMSGSIZE
            else 
            {
		#ifdef DEBUG
            	if (WSAEINTR != err) 
		        {
				    // WSAEINTR is what winsock uses to break a blocking socket out of 
				    // its wait.  it means someone killed this socket.
				    // if it's not that, then it's a real error.
		            DPF(0,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);
            	}
				else
				{
				    DPF(9,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);				
				}
		#endif // DEBUG 

                // we bail on errors other than WSAEMSGSIZE
                goto ERROR_EXIT;
            }
        } // SOCKET_ERROR
        else if ((err >= sizeof(DWORD)) &&  VALID_SP_MESSAGE(pBuffer))
        {
            // now, if we succeeded, err is the # of bytes read
	    	DEBUGPRINTADDR(9,"dplay helper  :: received enum request from ",(SOCKADDR *)&sockaddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pBuffer,err,(SOCKADDR_IN *)&sockaddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
        }
        else 
        {
            ASSERT(FALSE);
            // ?
        }
    } // 1

ERROR_EXIT:
    DPF(2,"UDP Listen thread exiting");
    if (pBuffer) MemFree(pBuffer);
    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

// startup winsock and find the default ip addr for this machine
HRESULT  StartupIP()
{
    UINT err;
    WSADATA wsaData;
	HINSTANCE hWinsock;

	// load winsock library
    hWinsock = LoadLibrary("wsock32.dll");
	if (!hWinsock) 
	{
		DPF(0,"Could not load wsock32.dll\n");
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need

    g_accept = (cb_accept) GetProcAddress(hWinsock, "accept");
	if (!g_accept)
		goto GETPROCADDRESSFAILED;

    g_bind = (cb_bind) GetProcAddress(hWinsock, "bind");
	if (!g_bind)
		goto GETPROCADDRESSFAILED;
		
    g_closesocket = (cb_closesocket) GetProcAddress(hWinsock, "closesocket");
	if (!g_closesocket)
		goto GETPROCADDRESSFAILED;

    g_gethostbyname = (cb_gethostbyname) GetProcAddress(hWinsock, "gethostbyname");
	if (!g_gethostbyname)
		goto GETPROCADDRESSFAILED;
		
    g_gethostname = (cb_gethostname) GetProcAddress(hWinsock, "gethostname");
	if (!g_gethostname)
		goto GETPROCADDRESSFAILED;

    g_getpeername = (cb_getpeername) GetProcAddress(hWinsock, "getpeername");
	if (!g_getpeername)
		goto GETPROCADDRESSFAILED;

    g_getsockname = (cb_getsockname) GetProcAddress(hWinsock, "getsockname");
	if (!g_getsockname)
		goto GETPROCADDRESSFAILED;

    g_htons = (cb_htons) GetProcAddress(hWinsock, "htons");
	if (!g_htons)
		goto GETPROCADDRESSFAILED;
		
    g_inet_ntoa = (cb_inet_ntoa) GetProcAddress(hWinsock, "inet_ntoa");
	if (!g_inet_ntoa)
		goto GETPROCADDRESSFAILED;

    g_listen = (cb_listen) GetProcAddress(hWinsock, "listen");
	if (!g_listen)
		goto GETPROCADDRESSFAILED;
		
    g_recv = (cb_recv) GetProcAddress(hWinsock, "recv");
	if (!g_recv)
		goto GETPROCADDRESSFAILED;

    g_recvfrom = (cb_recvfrom) GetProcAddress(hWinsock, "recvfrom");
	if (!g_recvfrom)
		goto GETPROCADDRESSFAILED;

    g_select = (cb_select) GetProcAddress(hWinsock, "select");
	if (!g_select)
		goto GETPROCADDRESSFAILED;

    g_send = (cb_send) GetProcAddress(hWinsock, "send");
	if (!g_send)
		goto GETPROCADDRESSFAILED;

    g_sendto = (cb_sendto) GetProcAddress(hWinsock, "sendto");
	if (!g_sendto)
		goto GETPROCADDRESSFAILED;

    g_setsockopt = (cb_setsockopt) GetProcAddress(hWinsock, "setsockopt");
	if (!g_setsockopt)
		goto GETPROCADDRESSFAILED;

    g_shutdown = (cb_shutdown) GetProcAddress(hWinsock, "shutdown");
	if (!g_shutdown)
		goto GETPROCADDRESSFAILED;

    g_socket = (cb_socket) GetProcAddress(hWinsock, "socket");
	if (!g_socket)
		goto GETPROCADDRESSFAILED;

    g_ntohs = (cb_ntohs) GetProcAddress(hWinsock, "ntohs");
	if (!g_ntohs)
		goto GETPROCADDRESSFAILED;
		
    g_htonl = (cb_htonl) GetProcAddress(hWinsock, "htonl");
	if (!g_htonl)
		goto GETPROCADDRESSFAILED;
		
    g_inet_addr = (cb_inet_addr) GetProcAddress(hWinsock, "inet_addr");
	if (!g_inet_addr)
		goto GETPROCADDRESSFAILED;

    g_WSAFDIsSet = (cb_WSAFDIsSet) GetProcAddress(hWinsock, "__WSAFDIsSet");
	if (!g_WSAFDIsSet)
		goto GETPROCADDRESSFAILED;
		
	g_WSAGetLastError = (cb_WSAGetLastError) GetProcAddress(hWinsock, "WSAGetLastError");
	if (!g_WSAGetLastError)
		goto GETPROCADDRESSFAILED;

    g_WSAStartup = (cb_WSAStartup) GetProcAddress(hWinsock, "WSAStartup");
	if (!g_WSAStartup)
		goto GETPROCADDRESSFAILED;

	// start up sockets, asking for version 1.1
    err = g_WSAStartup(MAKEWORD(1,1), &wsaData);
    if (err) 
    {
        DPF(0,"dphelp :: could not start winsock err = %d\n",err);
        goto WSASTARTUPFAILED;
    }
    DPF(3,"dphelp :: started up winsock succesfully");
    
	gbIPStarted=TRUE;
	
    return DP_OK;

GETPROCADDRESSFAILED:
	DPF(0,"Could not find required Winsock entry point");
WSASTARTUPFAILED:
	FreeLibrary(hWinsock);
LOADLIBRARYFAILED:
	return DPERR_UNAVAILABLE;
} // StartupIP

// helper function to create the socket we listen on
HRESULT GetSocket(SOCKET * psock,DWORD type,PORT port,BOOL bBroadcast,BOOL bListen)
{
    SOCKADDR_IN sockaddr;
    UINT err;
    SOCKET sNew;

    sNew = g_socket( AF_INET, type, 0);
    if (INVALID_SOCKET == sNew) 
    {
        goto ERROR_EXIT;
    }

    // set up the sockaddr to bind to
    sockaddr.sin_family         = PF_INET;
    sockaddr.sin_addr.s_addr    = INADDR_ANY;
    sockaddr.sin_port           = port;

    // do the bind
    if( SOCKET_ERROR == g_bind( sNew, (LPSOCKADDR)&sockaddr, sizeof(sockaddr) ) )
    {
        goto ERROR_EXIT;
    }

    if (bBroadcast)
    {
		BOOL bTrue = TRUE;

        if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
	    	sizeof(bTrue) ) )
		{
            err = g_WSAGetLastError();
		    DPF(0," dphelp - create - could not set broadcast err = %d\n",err);
		    // not really tragic, since for AF_INET it's not required to set broadcast 
		    // b4 receiving w/ MS winsock...
		}
    }

    if (bListen)
    {
	    LINGER Linger;
	    
	    // set up socket w/ max listening connections
	    err = g_listen(sNew,LISTEN_BACKLOG);
	    if (SOCKET_ERROR == err) 
	    {
	        err = g_WSAGetLastError();
	        DPF(0,"init listen socket / listen error - err = %d\n",err);
	        goto ERROR_EXIT;
	    }

		// set for hard disconnect
		Linger.l_onoff=1;
		Linger.l_linger=0;
	    
	    if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_LINGER,
			(char FAR *)&Linger,sizeof(Linger) ) )
	    {
	        err = g_WSAGetLastError();
			DPF(0,"Failed to set linger option on the socket = %d\n",err);
	    }    
    }

    // success!
    *psock = sNew;
    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    err = g_WSAGetLastError();
    DPF(0,"dphelp - could not get helper socket :: err = %d\n",err);
    if (INVALID_SOCKET != sNew)
    {
        g_closesocket(sNew);
    } 
    return E_FAIL;

}   // GetSocket

void CloseSocket(SOCKET * psSocket)
{
    UINT err;

    if (INVALID_SOCKET != *psSocket)
    {
    	if (SOCKET_ERROR == g_closesocket(*psSocket)) 
    	{
            err = g_WSAGetLastError();
    	    DPF(1,"dphelp : killsocket - socket close err = %d\n",err);
		}
	
		*psSocket = INVALID_SOCKET;
    }
    
    return ;

} // CloseSocket

HRESULT DPlayHelp_Init()
{
    DWORD dwThreadID;
    HRESULT hr;

    // start winsock, and get the default ip addr for this system
    if(!gbIPStarted){
	    hr = StartupIP();
	    if (FAILED(hr))
	    {
	        return hr; // StartupIP will have printed an error
	    }
	}

    // get the listen socket
    hr = GetSocket(&gsDatagramListener,SOCK_DGRAM,SERVER_DGRAM_PORT,TRUE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get the forward socket
    hr = GetSocket(&gsForwardSocket,SOCK_DGRAM,0,FALSE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get us a enum sessions stream listener
	hr = GetSocket(&gsStreamListener,SOCK_STREAM,SERVER_STREAM_PORT,FALSE,TRUE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
	

    ghDatagramReceiveThread = CreateThread(NULL,0,ListenThreadProc,NULL,0,&dwThreadID);
    if (!ghDatagramReceiveThread)
    {
        DPF_ERR("could not create udp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    ghStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,NULL,0,&dwThreadID);
    if (!ghStreamReceiveThread)
    {
        DPF_ERR("could not create tcp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
    

    DPF(5,"DPLAYHELP : init succeeded");
    gbInit = TRUE;
    return DP_OK;

ERROR_EXIT:
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);
    CloseSocket(&gsStreamListener);

    return hr;

} // DPlayHelp_Init 

void DPlayHelp_FreeServerList()
{
    LPSPNODE pNodeKill,pNodeNext;

    pNodeNext = gNodeList;

    // search the whole list
    while (pNodeNext)
    {
		// kill this node
		pNodeKill = pNodeNext;
		// but first, remember what's next
		pNodeNext = pNodeKill->pNextNode;
		// free up the node
		MemFree(pNodeKill);
    }
	
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);

	// close stream receive
	RemoveSocketFromList(gsStreamListener);
	gbReceiveShutdown = TRUE;
	
	// drop the lock so the threads can exit - they might be waiting on
	// the lock for cleanup
	LEAVE_DPLAYSVR();
		
    // wait for the threads to go away
   	if (ghDatagramReceiveThread) 
   		WaitForSingleObject(ghDatagramReceiveThread, INFINITE);
    if (ghStreamReceiveThread) 
    	WaitForSingleObject(ghStreamReceiveThread, INFINITE);
    
    ENTER_DPLAYSVR();
    
    if (ghDatagramReceiveThread)
    {
    	DPF(5,"datagram receive thread exited!");
	    CloseHandle(ghDatagramReceiveThread);
	    ghDatagramReceiveThread = NULL;
    }
    if (ghStreamReceiveThread)
    {
	    DPF(5,"stream receive thread exited!");
	    CloseHandle(ghStreamReceiveThread);
	    ghStreamReceiveThread = NULL;
    }


    return ;
    
} // DPlayHelp_FreeServerList



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\dplaysvr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.h
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share 
 *				a single winsock port
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp 
 *	1/29/98		sohailm	added macros for critical section
 *  1/12/99     aarono  added support for rsip
 *
 ***************************************************************************/
#ifndef __DPLAYSVR_INCLUDED__
#define __DPLAYSVR_INCLUDED__

// need this for hresult
#include "ole2.h"

#define USE_RSIP 0
#define USE_NATHELP 1

// crit section
extern CRITICAL_SECTION gcsCritSection;	// defined in dphelp.c
#define INIT_DPLAYSVR_CSECT() InitializeCriticalSection(&gcsCritSection);
#define FINI_DPLAYSVR_CSECT() DeleteCriticalSection(&gcsCritSection);

#ifdef DEBUG
extern int gnCSCount; // count of dplaysvr lock
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection),gnCSCount++;
#define LEAVE_DPLAYSVR() gnCSCount--;ASSERT(gnCSCount>=0);LeaveCriticalSection(&gcsCritSection);
#else 
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection);
#define LEAVE_DPLAYSVR() LeaveCriticalSection(&gcsCritSection);
#endif

/*
 * named objects
 */
#define DPHELP_EVENT_NAME			"__DPHelpEvent__"
#define DPHELP_ACK_EVENT_NAME		"__DPHelpAckEvent__"
#define DPHELP_STARTUP_EVENT_NAME	"__DPHelpStartupEvent__"
#define DPHELP_SHARED_NAME			"__DPHelpShared__"
#define DPHELP_MUTEX_NAME			"__DPHelpMutex__"

/*
 * requests 
 */
#define DPHELPREQ_SUICIDE			1
#define DPHELPREQ_DPLAYADDSERVER	2
#define DPHELPREQ_DPLAYDELETESERVER	3
#define DPHELPREQ_RETURNHELPERPID 	4

/*
 * communication data
 */
typedef struct DPHELPDATA
{
    int			req;
    DWORD		pid;
	USHORT		port;
    HRESULT		hr;
} DPHELPDATA, *LPDPHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\dplaysvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.c
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share
 *				a single winsock port
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *  1/12/2000   aarono  added support for rsip
 * 11/29/2000   aarono  B#228292: prefix bug initialize path in WinMain()
 *
 ***************************************************************************/

#ifdef WINNT
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"
#if USE_RSIP
#include "rsip.h"
#elif USE_NATHELP
#include "dpnathlp.h"
#endif

#if USE_RSIP
BOOL				bRsip;
#endif

#if USE_NATHELP
extern BOOL natGetCapsUpdate(VOID);
extern BOOL natInit(VOID);
extern VOID natFini(VOID);
extern HRESULT natRegisterUDPPort(DWORD port);
extern IDirectPlayNATHelp *g_pINatHelp;
#endif

HANDLE 				hInstApp;
BOOL		   		bNoCallbacks;
CRITICAL_SECTION    gcsCritSection;	// the crit section we take in winmain
                                	// this is a global so dphelp can take it before
                                	// forwarding enum requests that come in on its
                                	// receive thread (manbugs 3907)
int					gnCSCount;		// dplaysvr lock count

/*
 * Externs
 */
extern RECEIVELIST 	gReceiveList;
extern FDS			gReadfds;


// we watch every dplay process so when it exits we
// make sure it cleaned up...
typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList; 	// list of all processes that are registered
									// with us



//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;
PACL					g_pEveryoneACL = NULL;





/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
DWORD WINAPI ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    PROCESSDATA		pd;
	DPHELPDATA		hd;
	
    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 2, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                            FALSE, ppd->pid );
    if( hproc == NULL )
    {
        DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
        ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
        DPF( 1, "Wait for process %08lx failed", ppd->pid );
        CloseHandle( hproc );
        ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    ENTER_DPLAYSVR();
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr == ppd )
        {
            if( prev == NULL )
            {
                lpProcessList = curr->link;
            }
            else
            {
                prev->link = curr->link;
            }
            DPF( 2, "PID %08lx removed from list", ppd->pid );
            MemFree( curr );
            break;
        }
        prev = curr;
        curr = curr->link;
    }

    if( bNoCallbacks )
    {
		DPF( 1, "No callbacks allowed: leaving thread early" );
		LEAVE_DPLAYSVR();
		CloseHandle( hproc );
		ExitThread( 0 );
    }


	// clean up!

	memset(&hd,0,sizeof(hd));
	hd.pid = pd.pid;
	DPlayHelp_DeleteServer(&hd,TRUE);
	
    LEAVE_DPLAYSVR();
    CloseHandle( hproc );

    ExitThread( 0 );
	
	return 0;

} /* ThreadProc */

/*
 * MainWndProc
 */
LONG_PTR __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
            if( lParam == FALSE )
            {
                DPF( 3, "WM_ENDSESSION" );
                ENTER_DPLAYSVR();
                DPF( 1, "Setting NO CALLBACKS" );
                bNoCallbacks = TRUE;
                LEAVE_DPLAYSVR();
            }
            else
            {
                DPF( 3, "User logging off" );
            }

            break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DPlayHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
        DPF( 1, "RegisterClass FAILED!" );
        ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
        DPF( 1, "No monitor window!" );
        ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    DPF( 1, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by by DPlayHelp_AddServer when we get a new process attached.
// we wait for the process to go away, and then make sure it cleaned
// all its registered servers up.
//
void WatchNewPid(LPDPHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    DWORD		tid;

    DPF( 1, "watching new pid" );

    ENTER_DPLAYSVR();
	
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
        if( ppd->pid == phd->pid )
        {
            DPF( 2, "Have thread for process %08lx already", phd->pid );
			found = TRUE;
            break;
        }
        ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
        DPF( 2, "Allocating new thread for process %08lx",phd->pid );
        ppd = MemAlloc( sizeof( PROCESSDATA ) );
        if( ppd != NULL )
        {
            HANDLE	h;

            ppd->link = lpProcessList;
            lpProcessList = ppd;
            ppd->pid = phd->pid;
            h = CreateThread(NULL,
                         0,
                         (LPTHREAD_START_ROUTINE) ThreadProc,
                         (LPVOID)ppd,
                         0,
                         (LPDWORD)&tid);
            if( h != NULL )
            {
                DPF( 2, "Thread %08lx created",tid);
                CloseHandle( h );
            }
            else
            {
                #ifdef DEBUG
                    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
                    DebugBreak(); //_asm int 3;
                #endif
            }
        }
        else
        {
            #ifdef DEBUG
                DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
                DebugBreak(); //_asm int 3;
            #endif
        }
    }
    LEAVE_DPLAYSVR();
	
} // WatchNewPid

typedef DWORD (WINAPI *PFNREGISTERSERVICE)(DWORD,DWORD);
// nt's winbase.h doesn't have these constants - we need them
// so we can compile.  taken from \proj\dev\inc\winbase.h
#ifndef RSP_UNREGISTER_SERVICE
#define RSP_UNREGISTER_SERVICE  0x00000000
#endif
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

// on Win95, we want to call RegisterServiceProcess
// but, it's not available on NT, so we can't import it directly
// here we try to find it dynamically in kernel32.  if we find it,
// we call it, otherwise we assume we're on NT and it's not avaible
void MakeMeService()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not register service process - expected on NT");
		FreeLibrary(hLib);
		return ;
	}
	
    pfnRegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
	FreeLibrary(hLib);
	
	return ;
} // MakeMeService	

// on Win95, we want to call RegisterServiceProcess to Unregister
// (see MakeMeService)
void StopServiceProcess()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not unregister service process - not avail - not tragic");
		FreeLibrary(hLib);
		return ;
	}
	
	// unregistered!
    pfnRegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
	FreeLibrary(hLib);
	
	return ;

} // StopServiceProcess


//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPF(0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPF(0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPF(0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPF(0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPF(0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_abSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPF(0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_abSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                        LPSTR lpCmdLine, int nCmdShow)
{
    DWORD			tid;
    DWORD			rc;
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
    HANDLE			hstartevent;
    HANDLE			hstartupevent;
    HANDLE			hmutex;
    HANDLE			hackevent;
    LPDPHELPDATA	phd;
    HANDLE			hsharedmem;
    HANDLE			h;
    char			szSystemDir[MAX_PATH*sizeof(WCHAR)];

	DWORD			tWait;

    #if (USE_RSIP || USE_NATHELP)
   	DWORD tLast;
   	DWORD tNow;
   	#define RSIP_RENEW_TEST_INTERVAL 60000
	#endif

	
    DPFINIT();
    DPF( 2, "*** dplaysvr STARTED, PID=%08lx ***", GetCurrentProcessId() );
	
	if( !MemInit() )
	{
		DPF( 1, "Could not init memory manager" );
		return 0;
	}

	
   /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    memset(szSystemDir, 0, sizeof(WCHAR));  
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}


	// try to register ourselves as a service so user can't see us
	// in task list
	MakeMeService();

#if 0	

// andyco - not sure if we need this...

    /*
     * We must guarantee that DPHELP unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and DPHELP needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"dplaysvr could not set itself to shutdown last!");
    }

#endif


    hInstApp = hInstance;

    /*
     * create startup event
     */
	if (fUseGlobalNamespace)
	{
		hstartupevent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		hstartupevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
    if( hstartupevent == NULL )
    {
        DPF( 1, "Could not create startup event!" );
        return 0;
    }


    /*
     * create shared memory area
     */
	if (fUseGlobalNamespace)
	{
		hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
									PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
									"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
									PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
									DPHELP_SHARED_NAME );
	}
    if( hsharedmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
	if (fUseGlobalNamespace)
	{
		hmutex = CreateMutex( DNGetNullDacl(), FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = CreateMutex( NULL, FALSE, DPHELP_MUTEX_NAME );
	}
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex " DPHELP_MUTEX_NAME );
        CloseHandle( hsharedmem );
        return 0;
    }

    /*
     * create events
     */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}   
    if( hstartevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        return 0;
    }

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
    if( hackevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_ACK_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE) WindowThreadProc,
                 NULL,
                 0,
                 (LPDWORD)&tid );
    if( h == NULL )
    {
        DPF( 1, "Create of WindowThreadProc FAILED!" );
        CloseHandle( hackevent );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    INIT_DPLAYSVR_CSECT();




	if (!gbIPStarted) 
    {
		rc = StartupIP();
		if (FAILED(rc))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (rc);
		}
    }

	#if USE_RSIP

	bRsip=rsipInit();
	if(bRsip){
		rsipListenPort(FALSE, SERVER_DGRAM_PORT, NULL, NULL);
	}
	#endif

    #if USE_NATHELP
    natInit();
    if(g_pINatHelp){
        natRegisterUDPPort(SERVER_DGRAM_PORT);
    }
    #endif
	
    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

	tLast=tNow=timeGetTime();

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {

	wait:
		tWait=(tLast+RSIP_RENEW_TEST_INTERVAL)-tNow;
		if((int)tWait < 0){
			tWait=0;
		}
		ASSERT(!(tWait &0x80000000));
    	
        /*
         * wait to be notified of a request
         */
        DPF( 1, "Waiting for next request" );
        rc = WaitForSingleObject( hstartevent, tWait );

		#if (USE_RSIP || USE_NATHELP)
			tNow=timeGetTime();
			if(rc==WAIT_TIMEOUT)
			{
				tLast=tNow;
				#if USE_RSIP
				if(bRsip) {rsipPortExtend(tNow);}
				#elif USE_NATHELP
				if(g_pINatHelp){natGetCapsUpdate();}
				#endif
				goto wait;
			}
		#endif

        if( rc == WAIT_FAILED )
        {
            DPF( 1, "Wait FAILED!!!" );
            continue;
        }

        ENTER_DPLAYSVR();
        phd = (LPDPHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if( phd == NULL )
        {
            DPF( 1, "Could not create view of file!" );
            LEAVE_DPLAYSVR();
            continue;
        }

        /*
         * find out what we need to do
         */
        switch( phd->req )
        {
        case DPHELPREQ_SUICIDE:
            DPF( 1, "DPHELPREQ_SUICIDE" );


			#if USE_RSIP
			if(bRsip){
				rsipFini();
			}	
			#endif
			#if USE_NATHELP
			if(g_pINatHelp){
			    natFini();
			}
			#endif
			DPlayHelp_FreeServerList();
			
            SetEvent( hackevent );
            CloseHandle( hmutex );
            UnmapViewOfFile( phd );
            CloseHandle( hsharedmem );
            CloseHandle( hstartevent );
            if (gReceiveList.pConnection)
            {
            	MemFree(gReceiveList.pConnection);
            }
            if (gReadfds.pfdbigset)
            {
            	MemFree(gReadfds.pfdbigset);
            }
            FINI_DPLAYSVR_CSECT();
            
			// This should be done after functions that use a Dacl will no longer be
			// called (CreateMutex, CreateFile, etc).
			if (g_pEveryoneACL)
			{
				HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
				g_pEveryoneACL = NULL;
				g_psa = NULL;
				g_fDaclInited = FALSE;
			}

            #ifdef DEBUG
            	MemState();
            #endif
            DPF( 3, "Good Night Gracie" );
            TerminateProcess( GetCurrentProcess(), 0 );
            break;

		case DPHELPREQ_RETURNHELPERPID:

		    DPF( 2, "DDHELPREQ_RETURNHELPERPID" );
		    phd->pid = GetCurrentProcessId();
	    	break;
			

        case DPHELPREQ_DPLAYADDSERVER:

		    DPF( 2, "DPHELPREQ_DPLAYADDSERVER" );
            phd->hr = DPlayHelp_AddServer(phd);
            #if USE_RSIP
            if(!bRsip){
				bRsip=rsipInit();
				if(bRsip){
					rsipListenPort(FALSE, SERVER_DGRAM_PORT, NULL, NULL);
				}
            }
            #endif
            #if USE_NATHELP
            if(!g_pINatHelp){
                natInit();
                if(g_pINatHelp){
                    natRegisterUDPPort(SERVER_DGRAM_PORT);
                }
            }
            #endif
            break;

        case DPHELPREQ_DPLAYDELETESERVER:

		    DPF( 2, "DPHELPREQ_DPLAYDELETESERVER" );
            DPlayHelp_DeleteServer(phd,FALSE);
            break;

        default:
            DPF( 1, "helper - Unknown Request???" );
            break;
        }

        /*
         * let caller know we've got the news
         */
        UnmapViewOfFile( phd );
        SetEvent( hackevent );
        LEAVE_DPLAYSVR();
    }
	
	StopServiceProcess();

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\reliable.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reliable.c
 *  Content:    stream communication related routines
 *  History:
 *   Date   	By  	Reason
 *   ====   	==  	======
 *   01-29-98  	sohailm	initial implementation
 *   02-15-98  a-peterz	Remove unused SetMessageHeader
 *   02-10-00  aarono   only allow one enum per socket then turf it.
 *
 ***************************************************************************/
#include "dphelp.h"

/*
 * Globals
 */
FDS	gReadfds;							// fd set to receive data
RECEIVELIST gReceiveList;				// list of connections + listener

/*
 * Externs
 */
extern SOCKET gsStreamListener;			// we listen for tcp connections on this socket
extern gbReceiveShutdown;				// receive thread will exit when TRUE
extern LPSPNODE gNodeList;

#undef DPF_MODNAME
#define DPF_MODNAME	"MakeBufferSpace"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPLAYSVR();
	
	if (!*ppBuffer)
	{
		DPF(9, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPLAYSVR();
    return hr;    
    
}  // MakeBufferSpace

#undef DPF_MODNAME
#define DPF_MODNAME	"AddSocketToReceiveList"

HRESULT AddSocketToReceiveList(SOCKET sSocket)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection;
    
    ENTER_DPLAYSVR();
	
    // look for an empty slot 
    while ( (i < gReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == gReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    if (!bFoundSlot)
    {
		DWORD dwCurrentSize,dwNewSize;
		
		// allocate space for list of connections
		dwCurrentSize = gReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(gReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = gReceiveList.nConnections + 1; 
        	i < gReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	gReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = gReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (gReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + gReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(gReadfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        gReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		gReadfds.dwArraySize = gReceiveList.nConnections;
        
    } // !bFoundSlot

	// Initialize new connection 
	pNewConnection = &(gReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
	// allocate a default receive buffer
	pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	if (NULL == pNewConnection->pDefaultBuffer)
	{
        DPF_ERR("could not alloc default receive buffer - out of memory");        
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	// receive buffer initially points to our default buffer
	pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
	// remember the address we are connected to
	err = g_getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
	if (SOCKET_ERROR == err) 
	{
		err = g_WSAGetLastError();
		DPF(1,"could not getpeername err = %d\n",err);
	}

	DPF(9, "Added new socket at index %d", iNewSlot);

CLEANUP_EXIT:
    
	LEAVE_DPLAYSVR();
    return hr;
    
}  // AddSocketToReceiveList

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out

		    if( SOCKET_ERROR == g_setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
		                    sizeof(Linger) ) )
		    {
		        err = g_WSAGetLastError();
				DPF(0,"killsocket - stream setopt err = %d\n",err);
		    }
		}			
		#if 0
		// DON'T DO SHUTDOWN!  It leads to TIME_WAIT on sockets.
		
		if (SOCKET_ERROR == g_shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = g_WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
		#endif
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
    }

	return DP_OK;
	
}// KillSocket

void FreeConnection(LPCONNECTION pConnection)
{
	DEBUGPRINTSOCK(5,"Freeing connection - ",&pConnection->socket);

	// Kill them all hard so they don't wind up in TIME_WAIT state.
	KillSocket(pConnection->socket,TRUE,TRUE);

	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveSocketFromList"

void RemoveSocketFromList(SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;

    ENTER_DPLAYSVR();
    
    // look for the corresponding connection
    while ( (i < gReceiveList.nConnections) && !bFound)
    {
    	if (gReceiveList.pConnection[i].socket == socket)
    	{
    		bFound = TRUE;
			FreeConnection(&gReceiveList.pConnection[i]);
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPLAYSVR();
	
	return ;	
}


#undef DPF_MODNAME
#define DPF_MODNAME	"EmptyConnectionList"

void EmptyConnectionList(void)
{
	UINT i;
	
	DPF(5, "Emptying connection list");
	
	ENTER_DPLAYSVR();
	
	for (i=0;i<gReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
		{
			FreeConnection(&(gReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPLAYSVR();
	
	return ;
	
}  // EmptyConnectionList

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceive"

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		pull the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = g_recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

   	DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);

	DPF(5, "received %d bytes", dwBytesReceived);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
		hr = DP_OK;
		DPF(5,"Remote side has shutdown connection gracefully");
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = g_WSAGetLastError();
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		if (VALID_DPLAYSVR_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size
			 // SECURITY: limit message size for enum.
			 if(dwMessageSize > 8192)
			 {
			 	hr=E_UNEXPECTED;
			 	goto CLEANUP_EXIT;
			 }
		}
		else 
		{
			DPF(2,"got invalid message");
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive the rest of the message (after token)
		if (dwMessageSize)
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// received a complete message - process it

		if (TOKEN == SP_MESSAGE_TOKEN(pConnection->pBuffer))
		{						
	    	DEBUGPRINTADDR(9,"dplay helper  :: received reliable enum request from ",(SOCKADDR *)&pConnection->sockAddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pConnection->pBuffer, pConnection->dwTotalMessageSize,
				(SOCKADDR_IN *)&pConnection->sockAddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
		}
			
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;

		// new... only allow one enum per socket, then turf it.... AO 2/10/2000
		//goto CLEANUP_EXIT;
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromList(pConnection->socket);
	return hr;
	 	
} // StreamReceive

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceiveThreadProc"

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	INT_PTR rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
    SOCKADDR sockaddr; // socket we receive from
    INT addrlen=sizeof(sockaddr);
	SOCKET sSocket;
	BOOL bTrue = TRUE;

	// add listener socket to receive list
	// listener socket should be the first socket in the receive list
	hr = AddSocketToReceiveList(gsStreamListener);
	if (FAILED(hr))
	{
		DPF(0, "Failed to add TCP listener to receive list");
		return hr;
	}
	
    while (1)
    {
		ENTER_DPLAYSVR();

		ASSERT(gReadfds.pfdbigset);
		
    	// add all sockets in our recv list to readfds
		FD_ZERO(gReadfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < gReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(gReceiveList.pConnection[i].socket,&gReadfds);
				nSelected++;
        	}
		}

		LEAVE_DPLAYSVR();

		if (0 == nSelected)		
		{
			if (gbReceiveShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing listener socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
		
		// now, we wait for something to happen w/ our socket set
		rval = g_select(0,(fd_set *)(gReadfds.pfdbigset),NULL,NULL,NULL);
        if (SOCKET_ERROR == rval)
        {
 	      	err = g_WSAGetLastError();
	    	if (WSAEINTR != err) 
	        {
			    // WSAEINTR is what winsock uses to break a blocking socket out of 
			    // its wait.  it means someone killed this socket.
			    // if it's not that, then it's a real error.
	            DPF(0,"\n select error = %d socket - trying again",err);
	    	}
			else
			{
			    DPF(9,"\n select error = %d socket - trying again",err);				
			}
            rval = 0;
        }

		// shut 'em down?
        if (gbReceiveShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPLAYSVR();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= gReceiveList.nConnections)
			{
				rval = 0; // just to be safe, reset
			}
            
            if (gReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (g_WSAFDIsSet(gReceiveList.pConnection[i].socket,(fd_set *)gReadfds.pfdbigset))
                {
                	if (0==i)
                	// we got a new connection
                	{
					    // accept any incoming connection
					    sSocket = g_accept(gReceiveList.pConnection[i].socket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = g_WSAGetLastError();
				            DPF(0,"\n stream accept error - err = %d socket = %d BAILING",err,(DWORD)sSocket);
				            DPF(0, "\n !!! stream accept thread is going away - won't get reliable enum sessions anymore !!!");
				            ASSERT(FALSE);
				            LEAVE_DPLAYSVR();
							goto CLEANUP_EXIT;
					    }
					    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);

						// Turn on KEEPALIVE for the socket.

						if (SOCKET_ERROR == g_setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
						{
								err = g_WSAGetLastError();
								DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
						}

						// add the new socket to our receive list
						hr = AddSocketToReceiveList(sSocket);
						if (FAILED(hr))
						{
							ASSERT(FALSE);
						}			
                	}
                	else
                	// socket has new data
                	{
						DPF(9, "Receiving on socket %d from ReceiveList", i);

    	            	// got one! this socket has something going on...
						hr = StreamReceive(&(gReceiveList.pConnection[i]));
            	        if (FAILED(hr))
                	    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
                    	}
                	}
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPLAYSVR();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList();
	DPF(5, "Stream receive thread exiting");
	    
    return 0;
    
} // ReceiveThreadProc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\registry.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.c
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  ???
 *  12/28/99    aarono  added query for required key for Win95 rsip support
 *  04/19/01    vanceo  added nathelp DLL retrieval and copied to dplaysvr
 *
 ***************************************************************************/

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"


#define REGISTRY_NAMELEN	512
// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

#define SZ_SP_KEY		"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_GUID			"Guid"
#define SZ_FLAGS		"dwFlags"

#define SZ_GATEWAY		"Gateway"
#define SZ_NATHELP		"NATHelp"

#undef DPF_MODNAME
#define DPF_MODNAME "FindApplicationInRegistry"

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;
    
    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++; 
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		} 
		else 
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPSTR lpStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr) 
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString

BOOL FindSPInRegistry(LPGUID lpguid, LPSTR lpszSPName, DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPSPs, hkeySP;
	DWORD	dwIndex = 0;
	CHAR	szGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidSP;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering FindSPInRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpszSPName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_SP_KEY, 0,
							KEY_READ, &hkeyDPSPs);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay service provider registry key!");
		return FALSE;
	}

	// Walk the list of sps in the registry, looking for
	// the sp with the right GUID
	while(!bFound)
	{
		// Open the next SP key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = RegEnumKeyExA(hkeyDPSPs, dwIndex++, lpszSPName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more SPs, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the SP key		
		lReturn = RegOpenKeyExA(hkeyDPSPs, lpszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open sp key!");
			continue;
		}

		// Get the GUID of the SP
		lReturn = RegQueryValueExA(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)szGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(szGuidStr, &guidSP);
		if(IsEqualGUID(&guidSP, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the SPs key
	RegCloseKey(hkeyDPSPs);

	if(bFound)
		*lphkey = hkeySP;

	return bFound;


} // FindSPInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "GetKeyValue"
BOOL GetKeyValue(HKEY hkeyApp, LPSTR lpszKey, DWORD dwType, LPBYTE * lplpValue)
{
	DWORD	dwSize;
	LPBYTE	lpTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering GetKeyValue");
	DPF(8, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpszKey, lplpValue);

	ASSERT(lplpValue);

	// Get the size of the buffer for the Path
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType, NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 1, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 1)
		return FALSE;

	ENTER_DPLAYSVR();
	
	// Alloc the buffer for the Path
	lpTemp = MemAlloc(dwSize);

	LEAVE_DPLAYSVR();
	
	if(!lpTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType,
							(LPBYTE)lpTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		MemFree(lpTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpValue = lpTemp;
	return TRUE;

} // GetKeyValue


#undef DPF_MODNAME
#define DPF_MODNAME "GetFlagsFromRegistry"
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetFlagsFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x", lpguidSP, lpdwFlags);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the App Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the port value.
	if(!GetKeyValue(hkeySP, SZ_FLAGS, REG_BINARY, &lpValue))
	{
		DPF_ERR("Unable to get flags value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	*lpdwFlags = *(LPDWORD)lpValue;

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetFlagsFromRegistry


#if USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetGatewayFromRegistry"
HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetGatewayFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszGateway, cbszGateway);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the SP Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_GATEWAY, REG_SZ, &lpValue))
	{
		DPF_ERR("Unable to get key value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszGateway){
		DPF_ERR("Not enough room for gateway address");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszGateway, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetGatewayFromRegistry


#elif USE_NATHELP // !  USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetNATHelpDLLFromRegistry"
HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetNATHelpDLLFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszNATHelpDLL, cbszNATHelpDLL);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the SP Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the NAT Help value.
	if(!GetKeyValue(hkeySP, SZ_NATHELP, REG_SZ, &lpValue))
	{
		DPF(1, "Unable to get NATHelp key value from registry.");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszNATHelpDLL){
		DPF_ERR("Not enough room for NATHelp DLL path");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszNATHelpDLL, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetNATHelpDLLFromRegistry

#endif // USE_NATHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\dphelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.h
 *  Content:	header for dphelp.c
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-jul-96	andyco	initial implementation
 *   25-jul-96	andyco	added watchnewpid
 *	 23-jan-97	kipo	prototypes for winsock calls
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *   12-jan-2000 aarono added support for rsip
 *
 ***************************************************************************/

#ifndef __DPHELP_INCLUDED__
#define __DPHELP_INCLUDED__

#include "windows.h"
#include "dplaysvr.h"
#include "newdpf.h"
#include "winsock.h"
// we include dpsp.h since we'll be poking bits (sockaddr's)
// into dpsp's header
#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 	60

typedef struct _SPNODE * LPSPNODE;

typedef struct _SPNODE
{
	SOCKADDR_IN sockaddr;  // socket addr of server
	DWORD pid;
	LPSPNODE  pNextNode;
} SPNODE;

// protos

// from dphelp.c
extern HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd);
extern BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL fFreeAll);
extern HRESULT DPlayHelp_Init();
extern HRESULT  StartupIP();
extern void DPlayHelp_FreeServerList();
extern DWORD WINAPI StreamAcceptThreadProc(LPVOID pvCast);
extern DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast);
extern void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr);

// from help.c
extern void WatchNewPid(LPDPHELPDATA phd);

// from reliable.c
void RemoveSocketFromList(SOCKET socket);


//prototypes for winsock calls
typedef int (PASCAL FAR * cb_accept)(SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen);
extern cb_accept	g_accept;

typedef int (PASCAL FAR * cb_bind)(SOCKET s, const struct sockaddr FAR *addr, int namelen);
extern	cb_bind	g_bind;

typedef int (PASCAL FAR * cb_closesocket)(SOCKET s);
extern	cb_closesocket	g_closesocket;

typedef struct hostent FAR * (PASCAL FAR * cb_gethostbyname)(const char FAR * name);
extern	cb_gethostbyname	g_gethostbyname;

typedef int (PASCAL FAR * cb_gethostname)(char FAR * name, int namelen);
extern	cb_gethostname	g_gethostname;

typedef int (PASCAL FAR * cb_getpeername)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getpeername	g_getpeername;

typedef int (PASCAL FAR * cb_getsockname)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getsockname	g_getsockname;

typedef u_short (PASCAL FAR * cb_htons)(u_short hostshort);
extern	cb_htons		g_htons;

typedef char FAR * (PASCAL FAR * cb_inet_ntoa)(struct in_addr in);
extern	cb_inet_ntoa	g_inet_ntoa;

typedef int (PASCAL FAR * cb_listen)(
    SOCKET s,
    int backlog
    );
extern cb_listen		g_listen;

typedef int (PASCAL FAR * cb_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );
extern cb_recv		g_recv;

typedef int (PASCAL FAR * cb_recvfrom)(SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);
extern	cb_recvfrom	g_recvfrom;

typedef SOCKET (PASCAL FAR * cb_select)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR * timeout
    );
extern cb_select	g_select;

typedef int (PASCAL FAR * cb_send)(SOCKET s, const char FAR * buf, int len, int flags);
extern	cb_send		g_send;

typedef int (PASCAL FAR * cb_sendto)(SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);
extern	cb_sendto	g_sendto;

typedef int (PASCAL FAR * cb_setsockopt)(SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);
extern	cb_setsockopt	g_setsockopt;

typedef int (PASCAL FAR * cb_shutdown)(SOCKET s, int how);
extern cb_shutdown	g_shutdown;

typedef SOCKET (PASCAL FAR * cb_socket)(int af, int type, int protocol);
extern	cb_socket	g_socket;

typedef int (PASCAL FAR * cb_WSAFDIsSet)(SOCKET, fd_set FAR *);
extern 	cb_WSAFDIsSet	g_WSAFDIsSet;

typedef int (PASCAL FAR * cb_WSAGetLastError)(void);
extern	cb_WSAGetLastError	g_WSAGetLastError;

typedef int (PASCAL FAR * cb_WSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
extern	cb_WSAStartup	g_WSAStartup;

typedef unsigned short (PASCAL FAR * cb_ntohs)(unsigned short netshort);
extern	cb_ntohs			g_ntohs;

typedef unsigned long (PASCAL FAR * cb_htonl)(unsigned long hostlong);
extern	cb_htonl            g_htonl;

typedef unsigned long (PASCAL FAR * cb_inet_addr)(const char *cp);
extern	cb_inet_addr			g_inet_addr;

extern BOOL gbInit,gbIPStarted;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\nathelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nathelp.c
 *  Content:   usage for nat helper DLL
 *
 *  History:
 *  Date			By		Reason
 *  ====			==		======
 *  02/22/2001		aarono	Original
 *  04/16/2001		vanceo	Use one of the split DirectPlayNATHelp interfaces only.
 *
 *  Notes:
 *   
 ***************************************************************************/
#define INITGUID


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include <initguid.h>
#include "dpsp.h"
#include "mmsystem.h"
#include "dphelp.h"

#if USE_NATHELP
#include "dpnathlp.h"


extern HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL);


HMODULE				g_hNatHelp = NULL;		// module handle for dpnhxxx.dll
DPNHHANDLE          g_hNatHelpUDP = 0;
IDirectPlayNATHelp	*g_pINatHelp=NULL;		// interface pointer for IDirectPlayNATHelp object
DPNHCAPS            g_NatHelpCaps;

BOOL natGetCapsUpdate(VOID)
{
	HRESULT hr;
	//
	// Get Nat Capabilities - may block for a second.
	//
	
	memset(&g_NatHelpCaps,0,sizeof(DPNHCAPS));
	g_NatHelpCaps.dwSize=sizeof(DPNHCAPS);
	hr=IDirectPlayNATHelp_GetCaps(g_pINatHelp, &g_NatHelpCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
	
	if(FAILED(hr))
	{
		DPF(0,"NatHelp failed to GetCaps, hr=%x\n",hr);
		return FALSE;
	}	

	if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
	{
		DPF(1,"NAT Help reports addresses changed.");
	}

	return TRUE;

}

/*=============================================================================

	natInit	- Initialize nat helper i/f
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL natInit(VOID)
{
	HRESULT hr;
	char szNATHelpPath[256];
	PFN_DIRECTPLAYNATHELPCREATE pfnNatHelpCreate = NULL;
	char *apszNATHelps[3];
	HMODULE ahNatHelps[3];
	IDirectPlayNATHelp *apINatHelps[3];
	DPNHCAPS adpnhcNatHelpCaps[3];
	DWORD dwNumNatHelps = 0;
	DWORD dwCurrentNatHelp;


	memset(ahNatHelps, 0, sizeof(ahNatHelps));
	memset(apINatHelps, 0, sizeof(apINatHelps));

	//
	// See if there's a registry setting.
	//
	hr = GetNATHelpDLLFromRegistry((LPGUID) (&DPSPGUID_TCPIP), szNATHelpPath, 256);
	if (hr == S_OK)
	{
		DPF(1, "Got NAT Help DLL \"%s\" from registry.\n", szNATHelpPath);
		apszNATHelps[dwNumNatHelps++] = szNATHelpPath;
	}
	else
	{
		DPF(4, "Couldn't get NAT Help DLL from registry, hr=%x.\n", hr);
	}

	//
	// Add the default entries if the registry didn't already specify them.
	//
	if (_strnicmp(szNATHelpPath + strlen(szNATHelpPath) - strlen("dpnhupnp.dll"), "dpnhupnp.dll", strlen("dpnhupnp.dll")) != 0)
	{
		apszNATHelps[dwNumNatHelps++] = "dpnhupnp.dll";
	}
	if (_strnicmp(szNATHelpPath + strlen(szNATHelpPath) - strlen("dpnhpast.dll"), "dpnhpast.dll", strlen("dpnhpast.dll")) != 0)
	{
		apszNATHelps[dwNumNatHelps++] = "dpnhpast.dll";
	}

	//
	// Loop through the registry specified and default NAT Helpers and attempt
	// to load them.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		g_hNatHelp = LoadLibrary(apszNATHelps[dwCurrentNatHelp]);
		if (g_hNatHelp != NULL)
		{
			pfnNatHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(g_hNatHelp,
																		"DirectPlayNATHelpCreate");
			if (pfnNatHelpCreate != NULL)
			{
				hr = pfnNatHelpCreate(&IID_IDirectPlayNATHelp, (void **) (&g_pINatHelp));
				if (hr == DP_OK)
				{
					//
					// Initialize the NAT Helper interface.
					//		
					hr = IDirectPlayNATHelp_Initialize(g_pINatHelp, 0);
					if (hr == DP_OK)
					{
						//
						// Get the capabilities.  If it succeeds, remember the information and move on.
						//
						if (natGetCapsUpdate())
						{
							DPF(3, "Successfully retrieved caps for NAT Help \"%s\", flags = 0x%x.",
								apszNATHelps[dwCurrentNatHelp], g_NatHelpCaps.dwFlags);
							ahNatHelps[dwCurrentNatHelp] = g_hNatHelp;
							g_hNatHelp = NULL;
							apINatHelps[dwCurrentNatHelp] = g_pINatHelp;
							g_pINatHelp = NULL;
							memcpy(&adpnhcNatHelpCaps[dwCurrentNatHelp], &g_NatHelpCaps, sizeof(DPNHCAPS));
							continue;
						}
						else
						{
							DPF(0, "Couldn't get NAT Help \"%s\" caps, hr=%x!", apszNATHelps[dwCurrentNatHelp], hr);
						}
						
						IDirectPlayNATHelp_Close(g_pINatHelp, 0);
					}
					else
					{
						DPF(0, "NAT Help \"%s\" failed to initialize, hr=%x!", apszNATHelps[dwCurrentNatHelp], hr);
					}
					
					IDirectPlayNATHelp_Release(g_pINatHelp);
					g_pINatHelp = NULL;
				}
				else
				{
					DPF(0, "Couldn't create NAT Help \"%s\" interface, hr = %x!", apszNATHelps[dwCurrentNatHelp], hr);
				}
			}
			else
			{
				DPF(0, "Couldn't get NAT Help DLL \"%s\" entry point!", apszNATHelps[dwCurrentNatHelp]);
			}
			
			FreeLibrary(g_hNatHelp);
			g_hNatHelp = NULL;
		}
		else
		{
			DPF(0, "Couldn't load NAT Help DLL \"%s\"!", apszNATHelps[dwCurrentNatHelp]);
		}
	}


	//
	// Now go through and pick the first helper that detected a NAT.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		if ((apINatHelps[dwCurrentNatHelp] != NULL) &&
			(adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags & DPNHCAPSFLAG_GATEWAYPRESENT))
		{
			DPF(2, "Gateway detected by NAT Help \"%s\", flags = 0x%x.",
				apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
			g_hNatHelp = ahNatHelps[dwCurrentNatHelp];
			ahNatHelps[dwCurrentNatHelp] = NULL;
			g_pINatHelp = apINatHelps[dwCurrentNatHelp];
			apINatHelps[dwCurrentNatHelp] = NULL;
			memcpy(&g_NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
			break;
		}
	}

	//
	// If we didn't get a helper that way, pick the first one that detected a firewall.
	//
	if (g_pINatHelp != NULL)
	{
		for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
		{
			if ((apINatHelps[dwCurrentNatHelp] != NULL) &&
				(adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags & DPNHCAPSFLAG_LOCALFIREWALLPRESENT))
			{
				DPF(2, "Firewall detected by NAT Help \"%s\", flags = 0x%x.",
					apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
				g_hNatHelp = ahNatHelps[dwCurrentNatHelp];
				ahNatHelps[dwCurrentNatHelp] = NULL;
				g_pINatHelp = apINatHelps[dwCurrentNatHelp];
				apINatHelps[dwCurrentNatHelp] = NULL;
				memcpy(&g_NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
				break;
			}
		}
	}

	//
	// Now go through and release all the other NAT helpers, or pick the first one that
	// successfully loaded if we didn't pick one already.
	//
	for(dwCurrentNatHelp = 0; dwCurrentNatHelp < dwNumNatHelps; dwCurrentNatHelp++)
	{
		if (apINatHelps[dwCurrentNatHelp] != NULL)
		{
			if (g_pINatHelp == NULL)
			{
				DPF(2, "Using first loaded NAT Help \"%s\", flags = 0x%x.",
					apszNATHelps[dwCurrentNatHelp], adpnhcNatHelpCaps[dwCurrentNatHelp].dwFlags);
				g_hNatHelp = ahNatHelps[dwCurrentNatHelp];
				ahNatHelps[dwCurrentNatHelp] = NULL;
				g_pINatHelp = apINatHelps[dwCurrentNatHelp];
				apINatHelps[dwCurrentNatHelp] = NULL;
				memcpy(&g_NatHelpCaps, &adpnhcNatHelpCaps[dwCurrentNatHelp], sizeof(DPNHCAPS));
			}
			else
			{
				IDirectPlayNATHelp_Close(apINatHelps[dwCurrentNatHelp], 0);
				IDirectPlayNATHelp_Release(apINatHelps[dwCurrentNatHelp]);
				apINatHelps[dwCurrentNatHelp] = NULL;
				FreeLibrary(ahNatHelps[dwCurrentNatHelp]);
				ahNatHelps[dwCurrentNatHelp] = NULL;
			}
		}
	}

	if (g_pINatHelp == NULL)
	{
		DPF(1, "No NAT Help loaded.");
		g_NatHelpCaps.dwRecommendedGetCapsInterval = INFINITE;
		return FALSE;
	}

#ifdef DEBUG
	if (! (g_NatHelpCaps.dwFlags & DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE))
	{
		DPF(1, "NAT Help loaded, no NAT/firewall detected, or it doesn't currently have a public address (flags = 0x%x).",
			g_NatHelpCaps.dwFlags);
	}
#endif // DEBUG

	return TRUE;
}

/*=============================================================================

	natFini - Shut down NATHELP support
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natFini(VOID)
{

	// natDeregisterPorts(pgd); - vance says we don't need to do this.
	if(g_pINatHelp)
	{
        IDirectPlayNATHelp_Close(g_pINatHelp, 0);
	    g_hNatHelpUDP = 0;
		IDirectPlayNATHelp_Release(g_pINatHelp);
		g_pINatHelp=NULL;
	}	

	if(g_hNatHelp)
	{
		FreeLibrary(g_hNatHelp);
		g_hNatHelp=NULL;
	}
		
}

/*=============================================================================

	natRegisterUDPPort - Get a port mapping.
	
	
    Description:

        Map the shared port

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
HRESULT natRegisterUDPPort(WORD port)
{
	SOCKADDR_IN 	sockaddr_in, sockaddr_inpublic;
	DWORD			dwFlags, dwSize;
	DPNHHANDLE		hPortMapping;
	HRESULT 		hr;


    if (!g_hNatHelpUDP)
    {	
    	memset(&sockaddr_in , 0 ,sizeof(sockaddr_in));
    	sockaddr_in.sin_family          = AF_INET;
    	sockaddr_in.sin_addr.S_un.S_addr= INADDR_ANY;
    	sockaddr_in.sin_port            = port;	// port is already in network byte order

    	dwFlags = DPNHREGISTERPORTS_SHAREDPORTS|DPNHREGISTERPORTS_FIXEDPORTS;

    	hr = IDirectPlayNATHelp_RegisterPorts(g_pINatHelp, (SOCKADDR *)&sockaddr_in, sizeof(sockaddr_in), 1, 15*60000, &hPortMapping, dwFlags);
    	if (hr != DPNH_OK)
    	{
    		DPF(0,"NATHelp_RegisterPorts failed, hr=%x",hr);
    		hr = DPERR_GENERIC;
    	}
    	else
    	{
	    	dwSize=sizeof(sockaddr_inpublic);
	    	hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pINatHelp, hPortMapping, (SOCKADDR *)&sockaddr_inpublic, &dwSize, NULL, NULL, 0);
	    	switch (hr)
	    	{
	    		case DPNH_OK:
	    		{
			    	DEBUGPRINTADDR(2, "NATHelp successfully mapped port to ", (SOCKADDR *)&sockaddr_inpublic);
		    		
			   		g_hNatHelpUDP = hPortMapping;
			   		
		    		//hr = DP_OK;
	  				break;
	    		}
	    		
	    		case DPNHERR_PORTUNAVAILABLE:
	    		{
		      		DPF(0, "NATHelp reported port %u is unavailable!",
		      			MAKEWORD(HIBYTE(port), LOBYTE(port)));
		    		
		    		hr = IDirectPlayNATHelp_DeregisterPorts(g_pINatHelp, hPortMapping, 0);
		    		if (hr != DP_OK)
		    		{
		    			DPF(0,"NATHelp_DeregisterPorts PAST returned 0x%lx\n",hr);
		    		}

		    		hr = DPNHERR_PORTUNAVAILABLE;
	  				break;
	    		}

	    		default:
	    		{
			    	DPF(1, "NATHelp couldn't map port %u, (err = 0x%lx).",
			    		MAKEWORD(HIBYTE(port), LOBYTE(port)),
			    		hr);
			    	
				   	g_hNatHelpUDP = hPortMapping;
				   	
				   	hr = DPERR_GENERIC;
				   	break;
	    		}
	    	}
    	}
    }
    else
    {
    	DPF(1, "Already registered port with NAT Help, not registering %u.",
    		MAKEWORD(HIBYTE(port), LOBYTE(port)));
	    hr = DP_OK;
    }
    
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\killsvr\sources.inc ===
TARGETNAME=killsvr
TARGETTYPE=PROGRAM

TARGETPATH=.\obj$(BUILD_ALT_DIR)

USE_MAPSYM=1

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	     $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	     $(BASEDIR)\public\sdk\lib\*\user32.lib \


UMTYPE=console
UMENTRY=main

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\;\

SOURCES= \
	..\killsvr.c \


#NTTARGETFILE0=MISC

#C_DEFINES=$(C_DEFINES) -DNO_DPF_HWND -DMSBUILD -DNEW_DPF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\sources.inc ===
TARGETNAME=dplaysvr
TARGETTYPE=PROGRAM

TARGETPATH=.\obj$(BUILD_ALT_DIR)

USE_MAPSYM=1

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
             $(BASEDIR)\public\sdk\lib\*\WINMM.LIB\
	     $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	     $(BASEDIR)\public\sdk\lib\*\user32.lib \
	     $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	     $(BASEDIR)\public\sdk\lib\*\comdlg32.lib \
		 $(BASEDIR)\public\sdk\lib\*\gdi32.lib

UMTYPE=windows
UMENTRY=winmain

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\wsock;\
	..\..\misc;\
	..\..\dplay;\
	..\..\common; \
	..\..\..\dpnathlp\inc; \
	..\..\..\dplobby\dplobby; \
	..\..\nmvoice;

SOURCES= \
	..\dplaysvr.c \
	..\nathelp.c \
	..\dphelp.c \
    ..\reliable.c \
    ..\registry.c \
    ..\dplaysvr.rc \
	memalloc.c \
	newdpf.c

NTTARGETFILE0=MISC

C_DEFINES=$(C_DEFINES) -DNO_DPF_HWND -DMSBUILD -DNEW_DPF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplaysvr\killsvr\killsvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   killsvr.c
 *  Content:	kill dplay.exe
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   24-jun-95	craige	kill all attached processes
 *	 2-feb-97	andyco	ported for dplaysvr.exe
 *	 7-jul-97	kipo	added non-console support
 *
 ***************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "dplaysvr.h"

// only do printf's when built as a console app

#ifdef NOCONSOLE
#pragma warning(disable:4002)
#define printf()
#endif


//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;
PACL					g_pEveryoneACL = NULL;



//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPF(0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPF(0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPF(0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPF(0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPF(0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_abSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPF(0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_abSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	LPDPHELPDATA	phd;
	HANDLE			hmem;
	HANDLE			hmutex;
	HANDLE			hackevent;
	HANDLE			hstartevent;
	BOOL			rc;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			/*
			printf("Running on NT version %u.%u.%u, using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			*/
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			/*
			printf("Running on 9x version %u.%u.%u, not using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			*/
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		//printf("Could not determine OS version, assuming global namespace not needed.\n");
		fUseGlobalNamespace = FALSE;
	}


	/*
	 * get events start/ack events
	 */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}
	printf( "hstartevent = %08lx\n", hstartevent );
	if( hstartevent == NULL )
	{
		return FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
	printf( "hackevent = %08lx\n", hackevent );
	if( hackevent == NULL )
	{
		CloseHandle( hstartevent );
		return FALSE;
	}

	/*
	 * create shared memory area
	 */
	if (fUseGlobalNamespace)
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								DPHELP_SHARED_NAME );
	}
	printf( "hmem = %08lx\n", hmem );
	if( hmem == NULL )
	{
		printf( "Could not create file mapping!\n" );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	printf( "phd = %08lx\n", phd );
	if( phd == NULL )
	{
		printf( "Could not create view of file!\n" );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	/*
	 * wait for access to the shared memory
	 */
	if (fUseGlobalNamespace)
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
	}
	printf( "hmutex = %08lx\n", hmutex );
	if( hmutex == NULL )
	{
		printf( "Could not create mutex!\n" );
		UnmapViewOfFile( phd );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}
	WaitForSingleObject( hmutex, INFINITE );

	/*
	 * wake up DPHELP with our request
	 */
	memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
	printf( "waking up DPHELP\n" );
	if( SetEvent( hstartevent ) )
	{
		printf( "Waiting for response\n" );
		WaitForSingleObject( hackevent, INFINITE );
		memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
		rc = TRUE;
		printf( "got response\n" );
	}
	else
	{
		printf("Could not signal event to notify DPHELP!\n" );
		rc = FALSE;
	}

	/*
	 * done with things
	 */
	ReleaseMutex( hmutex );
	CloseHandle( hmutex );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	return rc;

} /* sendRequest */


// if the main entry point is called "WinMain" we will be built
// as a windows app
#ifdef NOCONSOLE

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow)

#else

// if the main entry point is called "main" we will be built
// as a console app

int __cdecl main( int argc, char *argv[] )

#endif
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	HANDLE			h;
	DPHELPDATA		hd;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			printf("Running on NT version %u.%u.%u, using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			printf("Running on 9x version %u.%u.%u, not using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		printf("Could not determine OS version, assuming global namespace not needed.\n");
		fUseGlobalNamespace = FALSE;
	}

	if (fUseGlobalNamespace)
	{
		h = OpenEvent( SYNCHRONIZE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
	if( h == NULL )
	{
		printf( "Helper not running\n" );
		return 0;
	}

	printf( "*** SUICIDE ***\n" );
	hd.req = DPHELPREQ_SUICIDE;
	sendRequest( &hd );

	// This should be done after functions that use a Dacl will no longer be
	// called (CreateMutex, CreateFile, etc).
	if (g_pEveryoneACL)
	{
		HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
		g_pEveryoneACL = NULL;
		g_psa = NULL;
		g_fDaclInited = FALSE;
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLobby"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\context.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       context.c
 *  Content:	Internal methods for context (handle) management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	1/18/97		myronth	Created it
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
						this includes removing this file from the build
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetNewContextID"
HRESULT PRV_GetNewContextID(LPDPLOBBYI_DPLOBJECT this, LPDWORD lpdwContext)
{

	DPF(7, "Entering PRV_GetNewContextID");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpdwContext);

	ASSERT(this);
	ASSERT(lpdwContext);

	// Get the current context ID and increment the counter
	if(this->bContextWrap)
	{
		// REVIEW!!!! -- We need to deal with the wrap case, but for
		// now just ASSERT if we hit it (it's pretty unlikely)
		ASSERT(FALSE);
		return DPERR_GENERIC;
	}
	else
	{
		*lpdwContext = this->dwContextCurrent++;
		return DP_OK;
	}
	
} // PRV_GetNewContextID



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindContextNode"
LPDPLOBBYI_CONTEXTNODE PRV_FindContextNode(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_FindContextNode");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Walk the list of context nodes, looking for the right ID
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		if(lpCN->dwContext == dwContext)
			return lpCN;
		else
			lpCN = lpCN->lpNext;
	}

	// We didn't find it
	return NULL;

} // PRV_FindContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetAsyncDataFromContext"
LPDPASYNCDATA PRV_GetAsyncDataFromContext(LPDPLOBBYI_DPLOBJECT this,
											DWORD dwContext)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN;


	DPF(7, "Entering PRV_GetAsyncDataFromContext");
	DPF(9, "Parameters: 0x%08x, %d", this, dwContext);

	ASSERT(this);

	// Find the node and pull out the AsyncData object
	lpCN = PRV_FindContextNode(this, dwContext);
	if(lpCN)
		return lpCN->lpAD;
	else
		return NULL;

} // PRV_GetAsyncDataFromContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddContextNode"
HRESULT PRV_AddContextNode(LPDPLOBBYI_DPLOBJECT this, LPDPASYNCDATA lpAD,
							LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	HRESULT					hr = DP_OK;
	DWORD					dwContext;
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;


	DPF(7, "Entering PRV_AddContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, lpAD, lplpCN);

	ASSERT(this);
	ASSERT(lpAD);
	ASSERT(lplpCN);

	// Allocate memory for the new node
	lpCN = DPMEM_ALLOC(sizeof(DPLOBBYI_CONTEXTNODE));
	if(!lpCN)
	{
		DPF_ERR("Unable to allocate memory for context node");
		return DPERR_OUTOFMEMORY;
	}

	// Get a new context ID
	hr = PRV_GetNewContextID(this, &dwContext);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to get new context ID");
		return DPERR_GENERIC;
	}

	// Fill in the structure
	lpCN->dwContext = dwContext;
	lpCN->lpAD = lpAD;

	// Fill in the output parameter
	*lplpCN = lpCN;

	// Add the node to the end of the list
	this->ContextHead.lpPrev->lpNext = lpCN;
	lpCN->lpPrev = this->ContextHead.lpPrev;
	this->ContextHead.lpPrev = lpCN;
	lpCN->lpNext = &(this->ContextHead);

	return DP_OK;

} // PRV_AddContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteContextNode"
HRESULT PRV_DeleteContextNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_CONTEXTNODE lpCN)
{
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DeleteContextNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);

	// Remove the node from the list
	lpCN->lpPrev->lpNext = lpCN->lpNext;
	lpCN->lpNext->lpPrev = lpCN->lpPrev;

	// And delete the node
	DPMEM_FREE(lpCN);
	return DP_OK;

} // PRV_DeleteContextNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpContextList"
void PRV_CleanUpContextList(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN, lpCNNext;


	DPF(7, "Entering PRV_CleanUpContextList");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// Walk the list, cleaning up the nodes
	lpCN = this->ContextHead.lpNext;
	while(lpCN != &(this->ContextHead))
	{
		lpCNNext = lpCN->lpNext;
		PRV_DeleteContextNode(this, lpCN);
		lpCN = lpCNNext;
	}

} // PRV_CleanUpContextList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndLinkAsyncDataContext"
HRESULT PRV_CreateAndLinkAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE * lplpCN)
{
	LPDPLOBBYI_CONTEXTNODE	lpCN = NULL;
	LPDPASYNCDATA			lpAD = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lplpCN);

	ASSERT(this);
	ASSERT(lplpCN);

	// Create the AsyncData object
	hr = CreateAsyncData(&lpAD);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to create DPAsyncData object");
		return hr;
	}

	// Add a new context node and link it in
	hr = PRV_AddContextNode(this, lpAD, &lpCN);
	if(FAILED(hr))
	{
		lpAD->lpVtbl->Release(lpAD);
		return hr;
	}

	// Fill in the output vars
	*lplpCN = lpCN;

	return DP_OK;

} // PRV_CreateAndLinkAsyncDataContext



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnlinkAndReleaseAsyncDataContext"
void PRV_UnlinkAndReleaseAsyncDataContext(LPDPLOBBYI_DPLOBJECT this,
									LPDPLOBBYI_CONTEXTNODE lpCN)
{
	LPDPASYNCDATA			lpAD = NULL;


	DPF(7, "Entering PRV_CreateAndLinkAsyncDataContext");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpCN);

	ASSERT(this);
	ASSERT(lpCN);

	// Release the AsyncData pointer
	lpCN->lpAD->lpVtbl->Release(lpCN->lpAD);

	// Remove the context node
	PRV_DeleteContextNode(this, lpCN);

} // PRV_UnlinkAndReleaseAsyncDataContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\create.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       create.c
 *  Content:	DirectPlayLobby creation code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		myronth	Added Time Bomb
 *	8/23/96		kipo	removed time bomb
 *	10/23/96	myronth	Added client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	11/20/96	myronth	Added DPLC_A_LogonServer
 *	1/2/97		myronth	Changed vtbl entries for CreateAddress & EnumAddress
 *	1/2/97		myronth	Cleaned up creation code by adding PRV_LobbyCreate
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added AllocateLobbyObject, removed response methods
 *						for Open and Close since they are synchronous
 *	3/17/97		myronth	Removed unnecessary Enum functions from IDPLobbySP
 *	3/21/97		myronth	Removed unnecessary Get/Set response functions
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, changed IDPLobbySP interface methods
 *	5/8/97		myronth	Added subgroup methods & StartSession to IDPLobbySP
 *	5/17/97		myronth	Added SendChatMessage to IDPLobbySP
 *	6/25/97		kipo	remove time bomb for DX5
 *	10/3/97		myronth	Added CreateCompoundAddress and EnumAddress to
 *						IDPLobbySP (12648)
 *	10/29/97	myronth	Added SetGroupOwner to IDPLobbySP
 *	11/24/97	kipo	Added time bomb for DX6
 *	12/2/97		myronth	Added Register/UnregisterApplication methods
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 ***************************************************************************/
#include "dplobpr.h"
#include "verinfo.h"

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
UINT		gnSPCount;		// Running sp count


//
// The one copy of the direct play callbacks (this is the vtbl!)
//
DIRECTPLAYLOBBYCALLBACKS dplCallbacks =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

DIRECTPLAYLOBBYCALLBACKSA dplCallbacksA =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
};  				

// IDirectPlayLobby2 interface
DIRECTPLAYLOBBYCALLBACKS2 dplCallbacks2 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				

DIRECTPLAYLOBBYCALLBACKS2A dplCallbacks2A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress
};  				
  
// IDirectPlayLobby3 interface
DIRECTPLAYLOBBYCALLBACKS3 dplCallbacks3 =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_EnumLocalApplications,
	(LPVOID)DPL_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2 methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_ConnectEx,
	(LPVOID)DPL_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				

DIRECTPLAYLOBBYCALLBACKS3A dplCallbacks3A =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPL_A_Connect,
	(LPVOID)DPL_CreateAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPL_EnumAddressTypes,
	(LPVOID)DPL_A_EnumLocalApplications,
	(LPVOID)DPL_A_GetConnectionSettings,
	(LPVOID)DPL_ReceiveLobbyMessage,
	(LPVOID)DPL_A_RunApplication,
	(LPVOID)DPL_SendLobbyMessage,
	(LPVOID)DPL_A_SetConnectionSettings,
	(LPVOID)DPL_SetLobbyMessageEvent,
    /*** IDirectPlayLobby2A methods ***/
	(LPVOID)DPL_CreateCompoundAddress,
    /*** IDirectPlayLobby3 methods ***/
	(LPVOID)DPL_A_ConnectEx,
	(LPVOID)DPL_A_RegisterApplication,
	(LPVOID)DPL_UnregisterApplication,
	(LPVOID)DPL_WaitForConnectionSettings
};  				
  
DIRECTPLAYLOBBYSPCALLBACKS dplCallbacksSP =
{
	(LPVOID)DPL_QueryInterface,
	(LPVOID)DPL_AddRef,
	(LPVOID)DPL_Release,
	(LPVOID)DPLP_AddGroupToGroup,
	(LPVOID)DPLP_AddPlayerToGroup,
	(LPVOID)DPLP_CreateGroup,
	(LPVOID)DPLP_CreateGroupInGroup,
	(LPVOID)DPLP_DeleteGroupFromGroup,
	(LPVOID)DPLP_DeletePlayerFromGroup,
	(LPVOID)DPLP_DestroyGroup,
	(LPVOID)DPLP_EnumSessionsResponse,
	(LPVOID)DPLP_GetSPDataPointer,
	(LPVOID)DPLP_HandleMessage,
	(LPVOID)DPLP_SendChatMessage,
	(LPVOID)DPLP_SetGroupName,
	(LPVOID)DPLP_SetPlayerName,
	(LPVOID)DPLP_SetSessionDesc,
	(LPVOID)DPLP_SetSPDataPointer,
	(LPVOID)DPLP_StartSession,
    /*** Methods added for DX6 ***/
	(LPVOID)DPL_CreateCompoundAddress,
	(LPVOID)DPL_EnumAddress,
	(LPVOID)DPLP_SetGroupOwner,
};  				

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AllocateLobbyObject"
HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY lpDPObject,
							LPDPLOBBYI_DPLOBJECT * lpthis)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;


	DPF(7, "Entering PRV_AllocateLobbyObject");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPObject, lpthis);

	// Allocate memory for our lobby object
    this = DPMEM_ALLOC(sizeof(DPLOBBYI_DPLOBJECT));
    if(!this) 
    {
    	DPF_ERR("Unable to allocate memory for lobby object");
        return DPERR_OUTOFMEMORY;
    }

	// Initialize the ref count
	this->dwRefCnt = 0;
	this->dwSize = sizeof(DPLOBBYI_DPLOBJECT);

	// Store the back pointer
	this->lpDPlayObject = lpDPObject;

	// Set the output pointer
	*lpthis = this;

	gnObjects++;

	return DP_OK;

} // PRV_AllocateLobbyObject



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LobbyCreate"
HRESULT WINAPI PRV_LobbyCreate(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
				IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_INTERFACE	lpInterface = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_LobbyCreate");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, bAnsi);
	
	// Must be NULL for this release
	if( lpGUID )
	{
		if( !VALID_READ_PTR(lpGUID, sizeof(GUID)) )
			return DPERR_INVALIDPARAMS;

		if(!IsEqualGUID(lpGUID, &GUID_NULL))
			return DPERR_INVALIDPARAMS;
	}

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
	if( lpSPData )
	{
		// Must be NULL for this release
		return DPERR_INVALIDPARAMS;
	}

	if( dwSize )
	{
		// Must be zero for this release
		return DPERR_INVALIDPARAMS;
	}


    TRY
    {
        *lplpDPL = NULL;
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

#ifndef DX_FINAL_RELEASE

#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return DPERR_GENERIC;
	}

#endif

	// Allocate the lobby object
	hr = PRV_AllocateLobbyObject(NULL, &this);
	if(FAILED(hr))
		return hr;

	// Get the Unicode interface
	hr = PRV_GetInterface(this, &lpInterface, (bAnsi ? &dplCallbacksA : &dplCallbacks));
	if(FAILED(hr))
	{
		DPMEM_FREE(this);
    	DPF_ERR("Unable to allocate memory for lobby interface structure");
        return hr;
	}

	*lplpDPL = (LPDIRECTPLAYLOBBY)lpInterface;

    return DP_OK;

} // PRV_LobbyCreate

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateW"
HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( g_hRedirect != NULL )
    {
        return (*pfnDirectPlayLobbyCreateW)(lpGUID,lplpDPL,pUnkOuter,lpSPData,dwSize);
    }
#endif		

    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, FALSE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateW


#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayLobbyCreateA"
HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID lpGUID, LPDIRECTPLAYLOBBY *lplpDPL,
							IUnknown *pUnkOuter, LPVOID lpSPData, DWORD dwSize)
{
	HRESULT		hr = DP_OK;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( g_hRedirect != NULL )
    {
        return (*pfnDirectPlayLobbyCreateA)(lpGUID,lplpDPL,pUnkOuter,lpSPData,dwSize);
    }
#endif		

    ENTER_DPLOBBY();
    
	// Call the private create function
	hr = PRV_LobbyCreate(lpGUID, lplpDPL, pUnkOuter, lpSPData, dwSize, TRUE);

    LEAVE_DPLOBBY();

    return hr;

} // DirectPlayLobbyCreateA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplobby.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.h
 *  Content:    DirectPlayLobby include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	4/13/96		myronth	Created it
 *	6/20/96		myronth	Cleaned it up
 *	6/24/96		myronth	More cleanup
 *	7/1/96		myronth	Changed DPLERR_ to DPERR_
 *  7/9/96      ajayj   Cleaned up formatting to match dplay.h
 *  7/15/96     ajayj   Added DPADDRESS chunk tags for dplaunch
 *                      sample app.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  8/1/96      sohailm Added IDirectPlayLobby interface macros
 *  8/10/96     sohailm Bug#2227: declared pointers in callbacks as const.
 *  8/15/96     sohailm Added type definition for LPCDPLCONNECTION
 *                      Changed LPGUIDs to REFGUIDs in IDirectPlayLobby interface 
 *                      Made function parameters constant where appropriate
 *	8/16/96		andyco	took out some const and ref stuff for ship
 *	8/16/96		myronth	Added SetConnectionSettings & Connect methods
 *  8/21/96     ajayj   replace tabs with spaces
 *	8/21/96		kipo	Added DPCOMPORTADDRESS structure
 *	9/5/96		myronth	Wrapped DPLCAPS with MSINTERNAL
 *	10/23/96	myronth	Added first cut of client/server methods
 *	10/25/96	myronth	Added DX5 methods
 *	12/13/96	myronth	Changed DPLAD_SYSTEM to DPLMSG_SYSTEM
 *	1/30/97		myronth	Added MSINTERNAL's to DX5 stuff for meltdown
 *	2/12/97		myronth	Removed meltdown changes
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	3/5/97		andyco	added DPAID_TotalSize
 *	3/12/97		myronth	Added DPAID_LobbyProvider chunk
 *	3/17/97		kipo	Added data structures for CreateCompoundAddress() and
 *						added guids for Unicode phone numbers and IP addresses
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/11/97		myronth	Added CLSID_DirectPlayLobby clsid
 *	5/8/97		myronth	Moved DPLCONNECTION structure definition to dplay.h
 *  5/21/97		ajayj	Added structures and definitions for standard lobby 
 *						messages
 *  5/23/97		ajayj	Added DPLDATA_PLAYERGUID structure
 *  5/30/97		ajayj	Added DPLPROPERTY_MessagesSupported GUID
 *	6/7/97		myronth	Fixed CreateCompoundAddress macros
 *	6/6/97		kipo	Added "FAR" to all structures
 *	8/19/97		myronth	Added DPLMSG_NEWSESSIONHOST structure
 *	11/13/97	myronth	Added guidInstance to lobby system messages (#10944)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/29/98		sohailm	Added DPAID_INetPort.
 *	2/11/98		a-peterz Clarify that DPAID_INetPort value is a word (#18210)
 *	4/15/98		a-peterz Fix IDirectPlayLobby_CreateCompoundAddress C++ version
 *  10/22/99	aarono  added support for application flags
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLOBBY_INCLUDED__
#define __DPLOBBY_INCLUDED__

#include "dplay.h"

/* avoid warnings at Level 4 */
#pragma warning(disable:4201)

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * GUIDS used by DirectPlay objects
 */

/* {AF465C71-9588-11cf-A020-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {26C66A70-B367-11cf-A024-00AA006157AC} */
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
/* {0194C220-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {1BB4AF80-A303-11d0-9C4F-00A0C905425E} */
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
/* {2DB72490-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2DB72491-652C-11d1-A7A8-0000F803ABFC} */
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
/* {2FE8F810-B2A5-11d0-A787-0000F803ABFC} */
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);


/****************************************************************************
 *
 * IDirectPlayLobby Structures
 *
 * Various structures used to invoke DirectPlayLobby.
 *
 ****************************************************************************/

typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBY;
typedef struct IDirectPlayLobby     FAR *LPDIRECTPLAYLOBBYA;
typedef struct IDirectPlayLobby     IDirectPlayLobbyA;

typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2;
typedef struct IDirectPlayLobby2    FAR *LPDIRECTPLAYLOBBY2A;
typedef struct IDirectPlayLobby2    IDirectPlayLobby2A;

typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3;
typedef struct IDirectPlayLobby3    FAR *LPDIRECTPLAYLOBBY3A;
typedef struct IDirectPlayLobby3    IDirectPlayLobby3A;


/*
 * DPLAPPINFO
 * Used to hold information about a registered DirectPlay
 * application
 */
typedef struct DPLAPPINFO
{
    DWORD       dwSize;             // Size of this structure
    GUID        guidApplication;    // GUID of the Application
    union
    {
        LPSTR   lpszAppNameA;       // Pointer to the Application Name
        LPWSTR  lpszAppName;
    };

} DPLAPPINFO, FAR *LPDPLAPPINFO;

/*
 * LPCDPLAPPINFO
 * A constant pointer to DPLAPPINFO
 */
typedef const DPLAPPINFO FAR *LPCDPLAPPINFO;

/*
 * DPCOMPOUNDADDRESSELEMENT
 *
 * An array of these is passed to CreateCompoundAddresses()
 */
typedef struct DPCOMPOUNDADDRESSELEMENT
{
    GUID                guidDataType;
    DWORD               dwDataSize;
	LPVOID				lpData;
} DPCOMPOUNDADDRESSELEMENT, FAR *LPDPCOMPOUNDADDRESSELEMENT;

/*
 * LPCDPCOMPOUNDADDRESSELEMENT
 * A constant pointer to DPCOMPOUNDADDRESSELEMENT
 */
typedef const DPCOMPOUNDADDRESSELEMENT FAR *LPCDPCOMPOUNDADDRESSELEMENT;

/*
 * LPDPAPPLICATIONDESC
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
} DPAPPLICATIONDESC, *LPDPAPPLICATIONDESC;

/*
 * LPDPAPPLICATIONDESC2
 * Used to register a DirectPlay application
 */
typedef struct DPAPPLICATIONDESC2
{
    DWORD       dwSize;
    DWORD       dwFlags;
    union
    {
        LPSTR       lpszApplicationNameA;
        LPWSTR      lpszApplicationName;
    };
    GUID        guidApplication;
    union
    {
        LPSTR       lpszFilenameA;
        LPWSTR      lpszFilename;
    };
    union
    {
        LPSTR       lpszCommandLineA;
        LPWSTR      lpszCommandLine;
    };
    union
    {
        LPSTR       lpszPathA;
        LPWSTR      lpszPath;
    };
    union
    {
        LPSTR       lpszCurrentDirectoryA;
        LPWSTR      lpszCurrentDirectory;
    };
    LPSTR       lpszDescriptionA;
    LPWSTR      lpszDescriptionW;
    union
    {
    	LPSTR		lpszAppLauncherNameA;
    	LPWSTR      lpszAppLauncherName;
    };
} DPAPPLICATIONDESC2, *LPDPAPPLICATIONDESC2;


/****************************************************************************
 *
 * Enumeration Method Callback Prototypes
 *
 ****************************************************************************/

/*
 * Callback for EnumAddress()
 */
typedef BOOL (FAR PASCAL *LPDPENUMADDRESSCALLBACK)(
    REFGUID         guidDataType,
    DWORD           dwDataSize,
    LPCVOID         lpData,
    LPVOID          lpContext);

/*
 * Callback for EnumAddressTypes()
 */
typedef BOOL (FAR PASCAL *LPDPLENUMADDRESSTYPESCALLBACK)(
    REFGUID         guidDataType,
    LPVOID          lpContext,
    DWORD           dwFlags);

/*
 * Callback for EnumLocalApplications()
 */
typedef BOOL (FAR PASCAL * LPDPLENUMLOCALAPPLICATIONSCALLBACK)(
    LPCDPLAPPINFO   lpAppInfo,
    LPVOID          lpContext,
    DWORD           dwFlags);


/****************************************************************************
 *
 * DirectPlayLobby API Prototypes
 *
 ****************************************************************************/
#ifdef UNICODE
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateW
#else
#define DirectPlayLobbyCreate   DirectPlayLobbyCreateA
#endif /* UNICODE */

extern HRESULT WINAPI DirectPlayLobbyCreateW(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern HRESULT WINAPI DirectPlayLobbyCreateA(LPGUID, LPDIRECTPLAYLOBBYA *, IUnknown *, LPVOID, DWORD );


/****************************************************************************
 *
 * IDirectPlayLobby (and IDirectPlayLobbyA) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby
DECLARE_INTERFACE_( IDirectPlayLobby, IUnknown )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

};

/****************************************************************************
 *
 * IDirectPlayLobby2 (and IDirectPlayLobby2A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby2
DECLARE_INTERFACE_( IDirectPlayLobby2, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby3 (and IDirectPlayLobby3A) Interface
 *
 ****************************************************************************/
#undef INTERFACE
#define INTERFACE IDirectPlayLobby3
DECLARE_INTERFACE_( IDirectPlayLobby3, IDirectPlayLobby )
{
    /*  IUnknown Methods	*/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectPlayLobby Methods	*/
    STDMETHOD(Connect)              (THIS_ DWORD, LPDIRECTPLAY2 *, IUnknown FAR *) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID, REFGUID, LPCVOID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK, LPCVOID, DWORD, LPVOID) PURE;
    STDMETHOD(EnumAddressTypes)     (THIS_ LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD) PURE;
    STDMETHOD(EnumLocalApplications)(THIS_ LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(GetConnectionSettings)(THIS_ DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(ReceiveLobbyMessage)  (THIS_ DWORD, DWORD, LPDWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(RunApplication)       (THIS_ DWORD, LPDWORD, LPDPLCONNECTION, HANDLE) PURE;
    STDMETHOD(SendLobbyMessage)     (THIS_ DWORD, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetConnectionSettings)(THIS_ DWORD, DWORD, LPDPLCONNECTION) PURE;
    STDMETHOD(SetLobbyMessageEvent) (THIS_ DWORD, DWORD, HANDLE) PURE;

    /*  IDirectPlayLobby2 Methods	*/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;

    /*  IDirectPlayLobby3 Methods	*/
    STDMETHOD(ConnectEx)            (THIS_ DWORD, REFIID, LPVOID *, IUnknown FAR *) PURE;
    STDMETHOD(RegisterApplication)  (THIS_ DWORD, LPVOID) PURE;
    STDMETHOD(UnregisterApplication)(THIS_ DWORD, REFGUID) PURE;
    STDMETHOD(WaitForConnectionSettings)(THIS_ DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayLobby interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IDirectPlayLobby_Release(p)                         (p)->lpVtbl->Release(p)
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->lpVtbl->Connect(p,a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->lpVtbl->ConnectEx(p,a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->lpVtbl->CreateAddress(p,a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->lpVtbl->CreateCompoundAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->lpVtbl->EnumAddress(p,a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->lpVtbl->EnumAddressTypes(p,a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->lpVtbl->EnumLocalApplications(p,a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->lpVtbl->GetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->lpVtbl->ReceiveLobbyMessage(p,a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->lpVtbl->RegisterApplication(p,a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->lpVtbl->RunApplication(p,a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->lpVtbl->SendLobbyMessage(p,a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->lpVtbl->SetConnectionSettings(p,a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->lpVtbl->SetLobbyMessageEvent(p,a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->lpVtbl->UnregisterApplication(p,a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->lpVtbl->WaitForConnectionSettings(p,a)

#else /* C++ */

#define IDirectPlayLobby_QueryInterface(p,a,b)              (p)->QueryInterface(a,b)
#define IDirectPlayLobby_AddRef(p)                          (p)->AddRef()
#define IDirectPlayLobby_Release(p)                         (p)->Release()
#define IDirectPlayLobby_Connect(p,a,b,c)                   (p)->Connect(a,b,c)
#define IDirectPlayLobby_ConnectEx(p,a,b,c,d)               (p)->ConnectEx(a,b,c,d)
#define IDirectPlayLobby_CreateAddress(p,a,b,c,d,e,f)       (p)->CreateAddress(a,b,c,d,e,f)
#define IDirectPlayLobby_CreateCompoundAddress(p,a,b,c,d)   (p)->CreateCompoundAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddress(p,a,b,c,d)             (p)->EnumAddress(a,b,c,d)
#define IDirectPlayLobby_EnumAddressTypes(p,a,b,c,d)        (p)->EnumAddressTypes(a,b,c,d)
#define IDirectPlayLobby_EnumLocalApplications(p,a,b,c)     (p)->EnumLocalApplications(a,b,c)
#define IDirectPlayLobby_GetConnectionSettings(p,a,b,c)     (p)->GetConnectionSettings(a,b,c)
#define IDirectPlayLobby_ReceiveLobbyMessage(p,a,b,c,d,e)   (p)->ReceiveLobbyMessage(a,b,c,d,e)
#define IDirectPlayLobby_RegisterApplication(p,a,b)         (p)->RegisterApplication(a,b)
#define IDirectPlayLobby_RunApplication(p,a,b,c,d)          (p)->RunApplication(a,b,c,d)
#define IDirectPlayLobby_SendLobbyMessage(p,a,b,c,d)        (p)->SendLobbyMessage(a,b,c,d)
#define IDirectPlayLobby_SetConnectionSettings(p,a,b,c)		(p)->SetConnectionSettings(a,b,c)
#define IDirectPlayLobby_SetLobbyMessageEvent(p,a,b,c)	    (p)->SetLobbyMessageEvent(a,b,c)
#define IDirectPlayLobby_UnregisterApplication(p,a,b)       (p)->UnregisterApplication(a,b)
#define IDirectPlayLobby_WaitForConnectionSettings(p,a)     (p)->WaitForConnectionSettings(a)

#endif

/****************************************************************************
 *
 * DirectPlayLobby Flags
 *
 ****************************************************************************/

/*
 *	This flag is used by IDirectPlayLobby->WaitForConnectionSettings to
 *	cancel a current wait that is in progress.
 */
#define DPLWAIT_CANCEL                  0x00000001


/*
 *	This is a message flag used by ReceiveLobbyMessage.  It can be
 *	returned in the dwMessageFlags parameter to indicate a message from
 *	the system.
 */
#define DPLMSG_SYSTEM					0x00000001

/*
 *	This is a message flag used by ReceiveLobbyMessage and SendLobbyMessage.
 *  It is used to indicate that the message is a standard lobby message.
 *  DPLMSG_SETPROPERTY, DPLMSG_SETPROPERTYRESPONSE, DPLMSG_GETPROPERTY,
 *	DPLMSG_GETPROPERTYRESPONSE
 */
#define DPLMSG_STANDARD					0x00000002

/*
 *  Lobbyable Application registration flags
 */

/*
 *  Applications registered with this flag will not show up when
 *  applications are enumerated in the lobby.  This application
 *  will only be able to be launched by a lobby client that already
 *  knows about the application.
 */
#define DPLAPP_NOENUM					0x80000000

/*
 *  Applications registered with this flag want voice to automatically
 *  be enabled for their application.  All players will be launched into
 *  an 'n'-way voice conference when the application is started.  The 
 *  user will be able to enable this flag for existing non-voice 
 *  directplay applications.
 */
#define DPLAPP_AUTOVOICE				0x00000001 

/*
 * Applications that do their own voice conferencing should register with
 * this flag to avoid allowing the user to enable other voice chat 
 * capabilites during the same session.  This is to avoid users forcing
 * the DPLAPP_AUTOVOICE flag for the application.
 */
#define DPLAPP_SELFVOICE				0x00000002 

/****************************************************************************
 *
 * DirectPlayLobby messages and message data structures
 *
 * All system messages have a dwMessageFlags value of DPLMSG_SYSTEM returned
 * from a call to ReceiveLobbyMessage.
 *
 * All standard messages have a dwMessageFlags value of DPLMSG_STANDARD returned
 * from a call to ReceiveLobbyMessage.
 *
 ****************************************************************************/

/*
 * DPLMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct _DPLMSG_GENERIC
{
    DWORD       dwType;         // Message type
} DPLMSG_GENERIC, FAR *LPDPLMSG_GENERIC;

/*
 * DPLMSG_SYSTEMMESSAGE
 * Generic message format for all system messages --
 * DPLSYS_CONNECTIONSETTINGSREAD, DPLSYS_DPLYCONNECTSUCCEEDED,
 * DPLSYS_DPLAYCONNECTFAILED, DPLSYS_APPTERMINATED, DPLSYS_NEWCONNECTIONSETTINGS
 */
typedef struct _DPLMSG_SYSTEMMESSAGE
{
    DWORD       dwType;         // Message type
    GUID        guidInstance;   // Instance GUID of the dplay session the message corresponds to
} DPLMSG_SYSTEMMESSAGE, FAR *LPDPLMSG_SYSTEMMESSAGE;

/*
 *  DPLMSG_SETPROPERTY
 *  Standard message sent by an application to a lobby to set a
 *  property
 */
typedef struct _DPLMSG_SETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID (DPL_NOCONFIRMATION if no confirmation desired)
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_SETPROPERTY, FAR *LPDPLMSG_SETPROPERTY;

#define	DPL_NOCONFIRMATION			0

/*
 *  DPLMSG_SETPROPERTYRESPONSE
 *  Standard message returned by a lobby to confirm a 
 *  DPLMSG_SETPROPERTY message.
 */
typedef struct _DPLMSG_SETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
} DPLMSG_SETPROPERTYRESPONSE, FAR *LPDPLMSG_SETPROPERTYRESPONSE;

/*
 *  DPLMSG_GETPROPERTY
 *  Standard message sent by an application to a lobby to request
 *	the current value of a property
 */
typedef struct _DPLMSG_GETPROPERTY
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
} DPLMSG_GETPROPERTY, FAR *LPDPLMSG_GETPROPERTY;

/*
 *  DPLMSG_GETPROPERTYRESPONSE
 *  Standard message returned by a lobby in response to a
 *	DPLMSG_GETPROPERTY message.
 */
typedef struct _DPLMSG_GETPROPERTYRESPONSE
{
	DWORD	dwType;				// Message type
	DWORD	dwRequestID;		// Request ID
	GUID	guidPlayer;			// Player GUID
	GUID	guidPropertyTag;	// Property GUID
	HRESULT	hr;					// Return Code
	DWORD	dwDataSize;			// Size of data
	DWORD	dwPropertyData[1];	// Buffer containing data
} DPLMSG_GETPROPERTYRESPONSE, FAR *LPDPLMSG_GETPROPERTYRESPONSE;

/*
 *  DPLMSG_NEWSESSIONHOST
 *  Standard message returned by a lobby in response to a
 *	the session host migrating to a new client
 */
typedef struct _DPLMSG_NEWSESSIONHOST
{
    DWORD   dwType;             // Message type
    GUID    guidInstance;       // GUID Instance of the session
} DPLMSG_NEWSESSIONHOST, FAR *LPDPLMSG_NEWSESSIONHOST;


/******************************************
 *
 *	DirectPlay Lobby message dwType values
 *
 *****************************************/

/*
 *  The application has read the connection settings.
 *  It is now O.K. for the lobby client to release
 *  its IDirectPlayLobby interface.
 */
#define DPLSYS_CONNECTIONSETTINGSREAD   0x00000001

/*
 *  The application's call to DirectPlayConnect failed
 */
#define DPLSYS_DPLAYCONNECTFAILED       0x00000002

/*
 *  The application has created a DirectPlay session.
 */
#define DPLSYS_DPLAYCONNECTSUCCEEDED    0x00000003

/*
 *  The application has terminated.
 */
#define DPLSYS_APPTERMINATED            0x00000004

/*
 *  The message is a DPLMSG_SETPROPERTY message.
 */
#define DPLSYS_SETPROPERTY				0x00000005

/*
 *  The message is a DPLMSG_SETPROPERTYRESPONSE message.
 */
#define DPLSYS_SETPROPERTYRESPONSE		0x00000006

/*
 *  The message is a DPLMSG_GETPROPERTY message.
 */
#define DPLSYS_GETPROPERTY				0x00000007

/*
 *  The message is a DPLMSG_GETPROPERTYRESPONSE message.
 */
#define DPLSYS_GETPROPERTYRESPONSE		0x00000008

/*
 *  The message is a DPLMSG_NEWSESSIONHOST message.
 */
#define DPLSYS_NEWSESSIONHOST           0x00000009

/*
 *  New connection settings are available.
 */
#define DPLSYS_NEWCONNECTIONSETTINGS    0x0000000A

/*
 *  The Lobby Client has released the DirectPlayLobby Interface
 */
#define DPLSYS_LOBBYCLIENTRELEASE		0x0000000B

/****************************************************************************
 *
 * DirectPlay defined property GUIDs and associated data structures
 *
 ****************************************************************************/

/*
 * DPLPROPERTY_MessagesSupported
 *
 * Request whether the lobby supports standard.  Lobby with respond with either
 * TRUE or FALSE or may not respond at all.
 * 
 * Property data is a single BOOL with TRUE or FALSE
 */
// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_LobbyGuid
 *
 * Request the GUID that identifies the lobby software that the application
 * is communicating with.
 *
 * Property data is a single GUID.
 */
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLPROPERTY_PlayerGuid
 *
 * Request the GUID that identifies the player on this machine for sending
 * property data back to the lobby.
 *
 * Property data is the DPLDATA_PLAYERDATA structure
 */
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERGUID
 *
 * Data structure to hold the GUID of the player and player creation flags
 * from the lobby.
 */
typedef struct _DPLDATA_PLAYERGUID
{
	GUID	guidPlayer;
	DWORD	dwPlayerFlags;
} DPLDATA_PLAYERGUID, FAR *LPDPLDATA_PLAYERGUID;

/*
 * DPLPROPERTY_PlayerScore
 *
 * Used to send an array of long integers to the lobby indicating the 
 * score of a player.
 *
 * Property data is the DPLDATA_PLAYERSCORE structure.
 */
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);

/*
 * DPLDATA_PLAYERSCORE
 *
 * Data structure to hold an array of long integers representing a player score.
 * Application must allocate enough memory to hold all the scores.
 */
typedef struct _DPLDATA_PLAYERSCORE
{
	DWORD	dwScoreCount;
	LONG	Score[1];
} DPLDATA_PLAYERSCORE, FAR *LPDPLDATA_PLAYERSCORE;

/****************************************************************************
 *
 * DirectPlay Address ID's
 *
 ****************************************************************************/

/* DirectPlay Address
 *
 * A DirectPlay address consists of multiple chunks of data, each tagged
 * with a GUID signifying the type of data in the chunk. The chunk also
 * has a length so that unknown chunk types can be skipped.
 *
 * The EnumAddress() function is used to parse these address data chunks.
 */

/*
 * DPADDRESS
 *
 * Header for block of address data elements
 */
typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS;

typedef DPADDRESS FAR *LPDPADDRESS;

/*
 * DPAID_TotalSize
 *
 * Chunk is a DWORD containing size of entire DPADDRESS structure
 */

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * DPAID_ServiceProvider
 *
 * Chunk is a GUID describing the service provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_LobbyProvider
 *
 * Chunk is a GUID describing the lobby provider that created the chunk.
 * All addresses must contain this chunk.
 */

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

/*
 * DPAID_Phone and DPAID_PhoneW
 *
 * Chunk is a string containing a phone number (i.e. "1-800-555-1212")
 * in ANSI or UNICODE format
 */

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Modem and DPAID_ModemW
 *
 * Chunk is a string containing a modem name registered with TAPI
 * in ANSI or UNICODE format
 */

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_Inet and DPAID_InetW
 *
 * Chunk is a string containing a TCP/IP host name or an IP address
 * (i.e. "dplay.microsoft.com" or "137.55.100.173") in ANSI or UNICODE format
 */

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * DPAID_InetPort
 *
 * Chunk is the port number used for creating the apps TCP and UDP sockets.
 * WORD value (i.e. 47624).
 */
 
// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

#ifdef BIGMESSAGEDEFENSE
//@@BEGIN_MSINTERNAL
/*
 * DPAID_MaxMessageSize
 *
 * Tells DPLAY what the maximum allowed message size is.  Enables SPs to
 *	combat Denial of Service attacks
 */
 
 // this terrible hack is needed so the SP can work with the Elmer build.
 // it can be removed when the MSINTERNAL stuff is removed
 #define MAXMSGSIZEGUIDDEFINED

// {F5D09980-F0C4-11d1-8326-006097B01411}
DEFINE_GUID(DPAID_MaxMessageSize, 
0xf5d09980, 0xf0c4, 0x11d1, 0x83, 0x26, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
//@@END_MSINTERNAL
#endif

/*
 * DPCOMPORTADDRESS
 *
 * Used to specify com port settings. The constants that define baud rate,
 * stop bits and parity are defined in WINBASE.H. The constants for flow
 * control are given below.
 */

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

typedef struct _DPCOMPORTADDRESS
{
    DWORD   dwComPort;                  // COM port to use (1-4)
    DWORD   dwBaudRate;                 // baud rate (100-256k)
    DWORD   dwStopBits;                 // no. stop bits (1-2)
    DWORD   dwParity;                   // parity (none, odd, even, mark)
    DWORD   dwFlowControl;              // flow control (none, xon/xoff, rts, dtr)
} DPCOMPORTADDRESS;

typedef DPCOMPORTADDRESS FAR *LPDPCOMPORTADDRESS;

/*
 * DPAID_ComPort
 *
 * Chunk contains a DPCOMPORTADDRESS structure defining the serial port.
 */

// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * 	dplobby 1.0 obsolete definitions
 *	Included for compatibility only.
 *
 ****************************************************************************/
#define DPLAD_SYSTEM          DPLMSG_SYSTEM


#ifdef __cplusplus
};
#endif /* __cplusplus */

#pragma warning(default:4201)

#endif /* __DPLOBBY_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplgame.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplgame.c
 *  Content:	Methods for game management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	10/23/96	myronth	added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	4/3/97		myronth	#ifdef'd out DPLC_StartGame (Nov. spec related)
 *	5/8/97		myronth	Purged dead code
 *	5/22/97		myronth Changed error code processing of RunApplication which
 *						was calling the wrong cleanup function (#8871)
 *	6/4/97		myronth	Fixed handle leak (#9458)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and fixed
 *						additional backslash on current directory bug (#10592)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/26/98		myronth	Added OS_CompareString function for Win95
 *	7/07/98		kipo	Define and use PROCESSENTRY32A to avoid passing
 *						Unicode data structures to Win95 functions expecting ANSI
 *  7/09/99     aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *  7/12/00     aarono  fix GUIDs for IPC to be fully significant, otherwise won't IPC.
 *
 ***************************************************************************/
#include "dplobpr.h"
#include <tchar.h>
#include <tlhelp32.h>
#include <winperf.h>

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindGameInRegistry"
BOOL PRV_FindGameInRegistry(LPGUID lpguid, LPWSTR lpwszAppName,
							DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPApps, hkeyApp;
	DWORD	dwIndex = 0;
	WCHAR	wszGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidApp;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering PRV_FindGameInRegistry");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpwszAppName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay Applications registry key!");
		return FALSE;
	}

	// Walk the list of DPlay games in the registry, looking for
	// the app with the right GUID
	while(!bFound)
	{
		// Open the next application key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, lpwszAppName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more apps, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the application key		
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, lpwszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// Get the GUID of the Game
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
									(LPBYTE)wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeyApp);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(wszGuidStr, &guidApp);
		if(IsEqualGUID(&guidApp, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the App key
		RegCloseKey(hkeyApp);
	}

	// Close the DPApps key
	RegCloseKey(hkeyDPApps);

	if(bFound)
		*lphkey = hkeyApp;

	return bFound;


} // PRV_FindGameInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetKeyStringValue"
BOOL PRV_GetKeyStringValue(HKEY hkeyApp, LPWSTR lpwszKey, LPWSTR * lplpwszValue)
{
	DWORD	dwType = REG_SZ;
	DWORD	dwSize=0;
	LPWSTR	lpwszTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering PRV_GetKeyStringValue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpwszKey, lplpwszValue);

	ASSERT(lplpwszValue);

	// Get the size of the buffer for the Path
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
								NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 2, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 2)
		return FALSE;

	// Alloc the buffer for the Path
	lpwszTemp = DPMEM_ALLOC(dwSize);
	if(!lpwszTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = OS_RegQueryValueEx(hkeyApp, lpwszKey, NULL, &dwType,
							(LPBYTE)lpwszTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPMEM_FREE(lpwszTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpwszValue = lpwszTemp;
	return TRUE;

} // PRV_GetKeyStringValue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeConnectInfo"
BOOL PRV_FreeConnectInfo(LPCONNECTINFO lpci)
{
	DPF(7, "Entering PRV_FreeConnectInfo");
	DPF(9, "Parameters: 0x%08x", lpci);

	if(!lpci)
		return TRUE;

	if(lpci->lpszName)
		DPMEM_FREE(lpci->lpszName);
	if(lpci->lpszPath)
		DPMEM_FREE(lpci->lpszPath);
	if(lpci->lpszFile)
		DPMEM_FREE(lpci->lpszFile);
	if(lpci->lpszCommandLine)
		DPMEM_FREE(lpci->lpszCommandLine);
	if(lpci->lpszCurrentDir)
		DPMEM_FREE(lpci->lpszCurrentDir);
	if(lpci->lpszAppLauncherName)
		DPMEM_FREE(lpci->lpszAppLauncherName);


	return TRUE;

} // PRV_FreeConnectInfo



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectInfoFromRegistry"
BOOL PRV_GetConnectInfoFromRegistry(LPCONNECTINFO lpci)
{
	LPWSTR	lpwszAppName;
	HKEY	hkeyApp = NULL;
	LPWSTR	lpwszTemp;
	DWORD	dwSize = 0;
	DWORD	dwError;
	GUID	guidApp;
	BOOL	bReturn;


	DPF(7, "Entering PRV_GetConnectInfoFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpci);

	// Clear our ConnectInfo structure since we will be overwriting
	// whatever is in it, and we are making assumptions that the
	// string pointers are NULL to start with.  However, we need
	// the Application guid, so save it off
	guidApp = lpci->guidApplication;
	memset(lpci, 0, sizeof(CONNECTINFO));
	lpci->guidApplication = guidApp;

	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return FALSE;
	}
	
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(&(lpci->guidApplication), lpwszAppName,
								DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPMEM_FREE(lpwszAppName);
		DPF_ERR("Unable to find game in registry!");
		return FALSE;
	}

	lpci->lpszName = lpwszAppName;

	// Get the string value for the Path.  If this fails, we
	// can use a NULL path, which represents the default path
	// on the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_PATH, &lpwszTemp))
	{
		lpci->lpszPath = lpwszTemp;
	}
		
	// Get the string value for the File
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_FILE, &lpwszTemp))
	{
		DPF_ERR("Error getting value for File key!");
		bReturn = FALSE;
		goto EXIT_GETCONNECTINFO;
	}
	
	lpci->lpszFile = lpwszTemp;

	// Get the string value for the CommandLine.  If this fails,
	// we can pass a NULL command line to the CreateProcess call
	if(PRV_GetKeyStringValue(hkeyApp, SZ_COMMANDLINE, &lpwszTemp))
	{
		lpci->lpszCommandLine = lpwszTemp;
	}
	
	// Get the string value for the AppLauncherName.  If this fails,
	// then we assume there is no launcher application.
	if(PRV_GetKeyStringValue(hkeyApp, SZ_LAUNCHER, &lpwszTemp))
	{
		lpci->lpszAppLauncherName = lpwszTemp;
	}

	// Get the string value for the CurrentDir.  If this fails, just
	// use the value returned by GetCurrentDirectory.
	if(!PRV_GetKeyStringValue(hkeyApp, SZ_CURRENTDIR, &lpwszTemp))
	{
		// Get the size of the string
		dwSize = OS_GetCurrentDirectory(0, NULL);
		if(!dwSize)
		{
			dwError = GetLastError();
			// WARNING: this last error value may not be correct in debug
			// since OS_GetCurrentDirectory may have called another function.
			DPF(0, "GetCurrentDirectory returned an error! dwError = %d", dwError);
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		lpwszTemp = DPMEM_ALLOC(dwSize * sizeof(WCHAR));
		if(!lpwszTemp)
		{
			DPF_ERR("Unable to allocate temporary string for CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}

		if(!OS_GetCurrentDirectory(dwSize, lpwszTemp))
		{
			DPF_ERR("Unable to get CurrentDirectory!");
			bReturn = FALSE;
			goto EXIT_GETCONNECTINFO;
		}
	}
	
	lpci->lpszCurrentDir = lpwszTemp;

	bReturn = TRUE;

EXIT_GETCONNECTINFO:

	// Free any string we allocated if we failed
	if(!bReturn)
		PRV_FreeConnectInfo(lpci);

	// Close the Apps key
	if(hkeyApp)
		RegCloseKey(hkeyApp);

	return bReturn;

} // PRV_GetConnectInfoFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGameProcess"
HRESULT PRV_CreateGameProcess(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	STARTUPINFO			si;
	HRESULT				hr;
	LPWSTR				lpwszPathAndFile = NULL;
	LPWSTR				lpwszTemp = NULL;
	LPWSTR				lpwszCommandLine = NULL;
	LPWSTR              lpwszFileToRun;
	DWORD				dwPathSize,
						dwFileSize,
						dwCurrentDirSize,
						dwPathAndFileSize,
						dwCommandLineSize,
						dwIPCSwitchSize,
						dwError;
	

	DPF(7, "Entering PRV_CreateGameProcess");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);
	

	// Allocate enough memory for the Path, File, an additional backslash,
	// and the null termination
	// Note: the following two OS_StrLen calls with count the null terms
	// on the end of each string.  Since this comes to two characters
	// (4 bytes), this will account for our null terminator and the
	// possible additional backslash after concatenation.  Thus, the
	// size here is big enough for the concatenated string.
	dwPathSize = OS_StrLen(lpci->lpszPath);

	if(lpci->lpszAppLauncherName){
		// when launching with an applauncher, we need a GUID.
		OS_CreateGuid(&lpci->guidIPC);
		lpci->guidIPC.Data1 |= 0x10000000; // make life easy by having fully byte significant first dword.
		lpwszFileToRun = lpci->lpszAppLauncherName;
	} else {
		lpwszFileToRun = lpci->lpszFile;
	}	
		
	dwFileSize = OS_StrLen(lpwszFileToRun);
		
	dwPathAndFileSize = dwPathSize + dwFileSize;
	lpwszPathAndFile = DPMEM_ALLOC(dwPathAndFileSize * sizeof(WCHAR));
	if(!lpwszPathAndFile)
	{
		DPF_ERR("Couldn't allocate memory for temporary string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}
	

	// Concatenate the path & file together
	if(dwPathSize)
	{
		memcpy(lpwszPathAndFile, lpci->lpszPath, (dwPathSize  * sizeof(WCHAR)));
		lpwszTemp = lpwszPathAndFile + dwPathSize - 1;

		// Only add a backslash if one doesn't already exists
		if(memcmp((lpwszTemp - 1), SZ_BACKSLASH, sizeof(WCHAR)))
			memcpy(lpwszTemp++, SZ_BACKSLASH, sizeof(WCHAR));
		else 
			// since we didn't add a backslash, the actual used
			// size is one WCHAR less than the full allocated size so
			// we need to reduce it so when we calculate the spot for
			// the command line we aren't after a NULL.
			dwPathAndFileSize--;
	}
	else
		lpwszTemp = lpwszPathAndFile;

	memcpy(lpwszTemp, lpwszFileToRun, (dwFileSize * sizeof(WCHAR)));


	// Allocate memory for temporary command line string
	// Note: Since the OS_StrLen function counts the null terminator,
	// we will be large enough to include the extra space when we
	// concatenate the two strings together.
	dwCommandLineSize = OS_StrLen(lpci->lpszCommandLine);

	if(lpci->lpszAppLauncherName){
		// leave space for GUID on the command line
		dwIPCSwitchSize = sizeof(SZ_DP_IPC_GUID SZ_GUID_PROTOTYPE)/sizeof(WCHAR);
	} else {
		dwIPCSwitchSize = 0;
	}
	
	lpwszCommandLine = DPMEM_ALLOC(((dwCommandLineSize + dwPathAndFileSize+dwIPCSwitchSize) *
								sizeof(WCHAR)));
	if(!lpwszCommandLine)
	{
		// REVIEW!!!! -- We should fix these error paths post-DX3
		DPF_ERR("Couldn't allocate memory for temporary command line string!");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CREATE_GAME_PROCESS;
	}

	// Concatenate the path & file string with the rest of the command line
	memcpy(lpwszCommandLine, lpwszPathAndFile, (dwPathAndFileSize *
			sizeof(WCHAR)));

	// Add the rest of the command line if it exists
	lpwszTemp = lpwszCommandLine + dwPathAndFileSize;
	if(dwCommandLineSize)
	{
		// First change the null terminator to a space
		lpwszTemp -= 1; 
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));

		// Now copy in the command line
		memcpy(lpwszTemp, lpci->lpszCommandLine, (dwCommandLineSize *
				sizeof(WCHAR)));

	}
	
	if(dwIPCSwitchSize){
		// add switch with a GUID on the command line for IPC when
		// application is started by a launcher
		lpwszTemp += dwCommandLineSize-1;
		// change NULL terminator to a space
		memcpy(lpwszTemp++, SZ_SPACE, sizeof(WCHAR));
		// copy /dplay_ipc_guid: but skip the NULL
		memcpy(lpwszTemp, SZ_DP_IPC_GUID, sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR));
		lpwszTemp+=(sizeof(SZ_DP_IPC_GUID)-sizeof(WCHAR))/sizeof(WCHAR);
		// Copy the GUID directly into the target
		StringFromGUID(&lpci->guidIPC,lpwszTemp,GUID_STRING_SIZE);
	}

	// Make sure the CurrentDirectory string doesn't have a trailing backslash
	// (This will cause CreateProcess to not use the right directory)
	dwCurrentDirSize = OS_StrLen(lpci->lpszCurrentDir);
	if(dwCurrentDirSize > 2)
	{
		lpwszTemp = lpci->lpszCurrentDir + dwCurrentDirSize - 2;

		if(!(memcmp((lpwszTemp), SZ_BACKSLASH, sizeof(WCHAR))))
			memset(lpwszTemp, 0, sizeof(WCHAR));
	}

	// Create the game's process in a suspended state
	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	if(!OS_CreateProcess(lpwszPathAndFile, lpwszCommandLine, NULL,
			NULL, FALSE, (CREATE_SUSPENDED | CREATE_DEFAULT_ERROR_MODE |
			CREATE_NEW_CONSOLE), NULL, lpci->lpszCurrentDir, &si, lppi))
	{
		dwError = GetLastError();
		// WARNING Last error produced here may not be correct since OS_CreateProcess 
		// may call out to other functions (like DPF) before returning.
		DPF_ERR("Couldn't create game process");
		DPF(0, "CreateProcess error = 0x%08x, (WARNING Error may not be correct)", dwError);
		hr = DPERR_CANTCREATEPROCESS;
		goto ERROR_CREATE_GAME_PROCESS;
	} 

	hr = DP_OK;

	// Fall through

ERROR_CREATE_GAME_PROCESS:

	if(lpwszPathAndFile)
		DPMEM_FREE(lpwszPathAndFile);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	return hr;

} // PRV_CreateGameProcess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAppInWaitMode"
BOOL PRV_IsAppInWaitMode(DWORD dwProcessID)
{
	DPLOBBYI_GAMENODE		gn;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	SECURITY_ATTRIBUTES		sa;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	HRESULT					hr;
	HANDLE					hFile = NULL;
	HANDLE					hMutex = NULL;
	BOOL					bReturn = FALSE;
	DWORD					dwError;


	DPF(7, "Entering PRV_IsAppInWaitMode");
	DPF(9, "Parameters: %lu", dwProcessID);

	// Setup a temporary gamenode structure
	memset(&gn, 0, sizeof(DPLOBBYI_GAMENODE));
	gn.dwFlags = GN_LOBBY_CLIENT;
	gn.dwGameProcessID = dwProcessID;
	
	// Get the name of the shared connection settings buffer
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_FILE, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map the file into our process
	hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: Error may not be correct since OpenFileMapping calls out to other functions before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (ERROR MAY NOT BE CORRECT)", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Map a View of the file
	lpConnControl = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if(!lpConnControl)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		goto EXIT_ISAPPINWAITMODE;
	}

	// Get the name of the connection settings buffer mutex	
	hr = PRV_GetInternalName(&gn, TYPE_CONNECT_DATA_MUTEX, (LPWSTR)szName);
	if(FAILED(hr))
	{
		DPF(5, "Unable to get name for shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Set up the security attributes (so that our objects can
	// be inheritable)
	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;

	// Open the Mutex
	hMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)szName);
	if(!hMutex)
	{
		DPF(5, "Unable to create shared conn settings buffer mutex");
		goto EXIT_ISAPPINWAITMODE;
	}

	// Now grab the mutex and see if the app is in wait mode (and
	// it is not in pending mode)
	WaitForSingleObject(hMutex, INFINITE);
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		// Put the app in pending mode
		lpConnControl->dwFlags |= BC_PENDING_CONNECT;

		// Set the return code to true
		bReturn = TRUE;
	}

	// Release the mutex
	ReleaseMutex(hMutex);

	// Fall through

EXIT_ISAPPINWAITMODE:

	if(lpConnControl)
		UnmapViewOfFile(lpConnControl);
	if(hFile)
		CloseHandle(hFile);
	if(hMutex)
		CloseHandle(hMutex);

	return bReturn;

} // PRV_IsAppInWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppNT"

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")

#if 0
HRESULT PRV_FindRunningAppNT(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE		hProcess = NULL;
	DWORD		dwProcessID = 0;
	DWORD		dwError;
	HRESULT		hr = -1;

    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    TCHAR                         szSubKey[1024];
    LANGID                       lid;
    LPTSTR                        p;
    LPTSTR                        p2;
	LPWSTR						nameStr;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    DWORD						dwNumTasks;

	INT							ccStrFind;
	INT							ccStrMatch;

	// on Whistler, the string to match in the process table has changed from
	// being the name of the process without the ".exe" at the end to being
	// the name of the process followed by an '_' and the processid, so we
	// build that string too to compare and accept either when finding the app.
    WCHAR						procString[64];//name concated with proc id for Whistler
    WCHAR						*procStringBaseNameEnd;
    INT							ccStrFindProcBased;

    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    wsprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

	// convert the string to ansi because we can't use _wtoi

    p = (LPTSTR) buf;
    while (*p) {
        if (p > (LPTSTR) buf) {
            for( p2=p-2; _istdigit(*p2); p2--) ;
        }
        if (_tcsicmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            _tcscpy( szSubKey, p2+1 );
        }
        else
        if (_tcsicmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; _istdigit(*p2); p2--) ;
            dwProcessIdTitle = _ttoi( p2+1 );
        }
        //
        // next string
        //
        p += (_tcslen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    DPMEM_FREE( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = DPMEM_ALLOC( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = DPMEM_REALLOC( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD_PTR)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = (DWORD)pObj->NumInstances;

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //

	ccStrFind=(WSTRLEN(lpci->lpszFile)-1)-4; // don't include .exe in compare

	if(ccStrFind > 15){
		ccStrFind=15;
	}

	wcsncpy(procString, lpci->lpszFile, ccStrFind);
	procString[ccStrFind]=L'_';
	procStringBaseNameEnd=&procString[ccStrFind+1];
    
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //

		nameStr = (LPWSTR) ((DWORD_PTR)pInst + pInst->NameOffset);

 		pCounter = (PPERF_COUNTER_BLOCK) ((DWORD_PTR)pInst + pInst->ByteLength);

		// Compare the process name with the executable name we are
		// looking for
		dwProcessID = *((LPDWORD) ((DWORD_PTR)pCounter + dwProcessIdCounter));

		// tack processid onto end of base name to test on Whistler
		_itow(dwProcessID, procStringBaseNameEnd, 10);
		ccStrFindProcBased=WSTRLEN(procString)-1;
	
		ccStrMatch=WSTRLEN(nameStr)-1; // 1 for NULL
		if(ccStrMatch == 16){ // when it is 16, it included a trailing . so strip it.
			ccStrMatch--;
		}
		
		if((CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, nameStr, ccStrMatch, lpci->lpszFile, ccStrFind)) ||
		  (CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, nameStr, ccStrMatch, procString, ccStrFindProcBased)) 
		)
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(dwProcessID))
			{
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					goto exit;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = dwProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					goto exit;
				}
			} // IsAppInWaitMode
		} // Are Filenames Equal
		
		//
        // next process
        //
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        DPMEM_FREE( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );


	return hr;
} // PRV_FindRunningAppNT
#endif

// If you build with the UNICODE flag set, the headers will redefine PROCESSENTRY32
// to be PROCESSENTRY32W. Unfortunately, passing PROCESSENTRY32W to Win9x functions
// will cause them to fail (because of the embedded Unicode string).
//
// Fix is to define our own PROCESSENTRY32A which is guaranteed to have an ANSI
// embedded string which Win9x will always accept.

typedef struct tagPROCESSENTRY32 PROCESSENTRY32A;
typedef PROCESSENTRY32A	*LPPROCESSENTRY32A;

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningAppWin9x"
HRESULT PRV_FindRunningAppWin9x(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	HANDLE			hSnapShot = NULL;
	PROCESSENTRY32A	procentry;
	BOOL			bFlag;
	HRESULT			hr = DPERR_UNAVAILABLE;
	LPBYTE			lpbTemp = NULL;
	DWORD			dwStrSize;
	LPWSTR			lpszFile = NULL;
	HANDLE			hProcess = NULL;
	DWORD			dwError;
	HANDLE			hInstLib = NULL;
	HRESULT			hrTemp;

	// ToolHelp Function Pointers.
	HANDLE (WINAPI *lpfCreateToolhelp32Snapshot)(DWORD,DWORD);
	BOOL (WINAPI *lpfProcess32First)(HANDLE,LPPROCESSENTRY32A);
	BOOL (WINAPI *lpfProcess32Next)(HANDLE,LPPROCESSENTRY32A);
	  

	DPF(7, "Entering PRV_FindRunningAppWin9x");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	// Load library and get the procedures explicitly. We do
	// this so that we can load the entry points dynamically,
	// which allows us to build correctly under WinNT even
	// though the NT kernel32 doesn't have these entry points
	hInstLib = LoadLibraryA( "Kernel32.DLL" );
	if(hInstLib == NULL)
	{
		DPF_ERR("Unable to load Kernel32.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get procedure addresses.
	// We are linking to these functions of Kernel32
	// explicitly, because otherwise a module using
	// this code would fail to load under Windows NT,
	// which does not have the Toolhelp32
	// functions in the Kernel 32.
	lpfCreateToolhelp32Snapshot=(HANDLE(WINAPI *)(DWORD,DWORD)) GetProcAddress( hInstLib, "CreateToolhelp32Snapshot" );
	lpfProcess32First=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A))	GetProcAddress( hInstLib, "Process32First" );
	lpfProcess32Next=(BOOL(WINAPI *)(HANDLE,LPPROCESSENTRY32A)) GetProcAddress( hInstLib, "Process32Next" );
	if( lpfProcess32Next == NULL || lpfProcess32First == NULL || lpfCreateToolhelp32Snapshot == NULL )
	{
		DPF_ERR("Unable to get needed entry points in PSAPI.DLL");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}

	// Get a handle to a Toolhelp snapshot of the systems processes. 
	hSnapShot = lpfCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if(hSnapShot == INVALID_HANDLE_VALUE)
	{
		DPF_ERR("Unable to get snapshot of system processes");
		goto EXIT_FIND_RUNNING_APP_WIN9X;
	}
	
	// Get the first process' information.
	procentry.dwSize = sizeof(PROCESSENTRY32A);
	bFlag = lpfProcess32First(hSnapShot, &procentry);

	// While there are processes, keep looping.
	while(bFlag)
	{
		// Walk the path and filename string (guaranteed to be ANSI)
		// looking for the final backslash (\).  Once we find it,
		// convert the filename to Unicode so we can compare it.
		dwStrSize = lstrlenA((LPBYTE)procentry.szExeFile);
		lpbTemp = (LPBYTE)procentry.szExeFile + dwStrSize - 1;
		while(--dwStrSize)
		{
			if(lpbTemp[0] == '\\')
			{
				lpbTemp++;
				break;
			}
			else
				lpbTemp--;
		}
		
		hrTemp = GetWideStringFromAnsi(&lpszFile, (LPSTR)lpbTemp);
		if(FAILED(hrTemp))
		{
			DPF_ERR("Failed making temporary copy of filename string");
			goto EXIT_FIND_RUNNING_APP_WIN9X;
		}
		
		// Compare the process name with the executable name we are
		// looking for
		if(CSTR_EQUAL == OS_CompareString(LOCALE_SYSTEM_DEFAULT,
			NORM_IGNORECASE, lpszFile, -1, lpci->lpszFile, -1))
		{
			// See if the process is in wait mode
			if(PRV_IsAppInWaitMode(procentry.th32ProcessID))
			{
				// Open the process since Windows9x doesn't do
				// it for us.
				hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procentry.th32ProcessID);
				if(!hProcess)
				{
					dwError = GetLastError();
					DPF_ERRVAL("Unable to open running process, dwError = %lu", dwError);
					bFlag = FALSE;
				}
				else
				{
					// Save off the stuff we need
					lppi->dwProcessId = procentry.th32ProcessID;
					lppi->hProcess = hProcess;
					hr = DP_OK;
					bFlag = FALSE;
				}

			} // IsAppInWaitMode
		} // Are Filenames Equal

		// Free our temporary string
		DPMEM_FREE(lpszFile);

		// If we haven't found it, and we didn't error, then move to
		// the next process
		if(bFlag)
		{
			// Move to the next process
			procentry.dwSize = sizeof(PROCESSENTRY32A);
			bFlag = lpfProcess32Next(hSnapShot, &procentry);
		}
	}
		

EXIT_FIND_RUNNING_APP_WIN9X:

	if(hSnapShot)
		CloseHandle(hSnapShot);
	if(hInstLib)
		FreeLibrary(hInstLib) ;

	return hr;

} // PRV_FindRunningAppWin9x



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FindRunningApp"
HRESULT PRV_FindRunningApp(LPCONNECTINFO lpci, LPPROCESS_INFORMATION lppi)
{
	OSVERSIONINFOA	ver;
	HRESULT			hr = DPERR_UNAVAILABLE;


	DPF(7, "Entering PRV_FindRunningApp");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpci, lppi);

	ASSERT(lpci);
	ASSERT(lppi);


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Figure out which platform we are running on and
	// call the appropriate process enumerating function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- not looking for running app");
		return DPERR_UNAVAILABLE;
	}

	switch(ver.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_NT:
		case VER_PLATFORM_WIN32_WINDOWS:
			// Call the Win9x version of FindRunningApp
			hr = PRV_FindRunningAppWin9x(lpci, lppi);
			break;
#if 0
		case VER_PLATFORM_WIN32_NT:
			hr = PRV_FindRunningAppNT(lpci, lppi);
			break;
#endif
		default:
			DPF_ERR("Unable to determinte platform -- not looking for running app");
			hr = DPERR_UNAVAILABLE;
			break;
	}

	return hr;

} // PRV_FindRunningApp



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RunApplication"
HRESULT DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConn,
							HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;
	PROCESS_INFORMATION		pi;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	CONNECTINFO				ci;
	HANDLE					hDupReceiveEvent = NULL;
	HANDLE					hReceiveThread = NULL;
	HANDLE					hTerminateThread = NULL;
	HANDLE					hKillReceiveThreadEvent = NULL;
	HANDLE					hKillTermThreadEvent = NULL;
	DWORD					dwThreadID;
	BOOL					bCreatedProcess = FALSE;
	GUID					*lpguidIPC = NULL;

	DPF(7, "Entering DPL_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConn, hReceiveEvent);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
        
		// Validate the DPLCONNECTION structure and it's members
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}

		if( !VALID_DWORD_PTR( lpdwGameID ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
	
		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Clear the CONNECTINFO structure since it's on the stack
	memset(&ci, 0, sizeof(CONNECTINFO)); 

	// Get the guid of the game we want to launch
	if(lpConn && lpConn->lpSessionDesc)
		ci.guidApplication = lpConn->lpSessionDesc->guidApplication;
	else
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Get the information out the registry based on the GUID
	if(!PRV_GetConnectInfoFromRegistry(&ci))
	{
		LEAVE_DPLOBBY();
		return DPERR_UNKNOWNAPPLICATION;
	}

	// Clear the PROCESS_INFORMATION structure since it's on the stack
	memset(&pi, 0, sizeof(PROCESS_INFORMATION)); 

	// Look to see if this game is already running AND is in wait mode
	// waiting for new connection settings.  If it is, we want to 
	// send the connection settings to it.
	hr = PRV_FindRunningApp(&ci, &pi);
	if(FAILED(hr))
	{
		// It isn't waiting, so create the game's process & suspend it
		hr = PRV_CreateGameProcess(&ci, &pi);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			return hr;
		}
		if(!(IsEqualGUID(&ci.guidIPC,&GUID_NULL))){
			lpguidIPC=&ci.guidIPC;
		}
		// Set our created flag
		bCreatedProcess = TRUE;
	}

	// Create a game node
	hr = PRV_AddNewGameNode(this, &lpgn, pi.dwProcessId,
							pi.hProcess, TRUE, lpguidIPC);
	if(FAILED(hr))
	{
		DPF_ERR("Couldn't create new game node");
		goto RUN_APP_ERROR_EXIT;
	}

	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_CLIENT_LAUNCHED;
	}

	// Write the connection settings in the shared memory buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, TRUE);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to write the connection settings!");
		goto RUN_APP_ERROR_EXIT;
	}

	// Send the app a message that the new connection settings are available
	// but only if we've sent the settings to a running app
	if(!bCreatedProcess)
		PRV_SendStandardSystemMessage(lpDPL, DPLSYS_NEWCONNECTIONSETTINGS, pi.dwProcessId);

	// Duplicate the Receive Event handle to use a signal to the
	// lobby client that the game has sent game settings to it.
	if(hReceiveEvent)
	{
		hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
		if(!hDupReceiveEvent)
		{
			DPF_ERR("Unable to duplicate ReceiveEvent handle");
			hr = DPERR_OUTOFMEMORY;
			goto RUN_APP_ERROR_EXIT;
		}
	}

	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Create the kill thread event for the monitor thread
	hKillTermThreadEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!hKillTermThreadEvent)
	{
		DPF_ERR("Unable to create kill thread event");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hKillTermThreadEvent = hKillTermThreadEvent;

	// Spawn off a terminate monitor thread
	hTerminateThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
						PRV_ClientTerminateNotification, lpgn, 0, &dwThreadID);

	if(!hTerminateThread)
	{
		DPF_ERR("Unable to create Terminate Monitor Thread!");
		hr = DPERR_OUTOFMEMORY;
		goto RUN_APP_ERROR_EXIT;
	}

	lpgn->hTerminateThread = hTerminateThread;

	// Resume the game's process & let it run, then
	// free the thread handle since we won't use it anymore
	if(bCreatedProcess)
	{
		ResumeThread(pi.hThread);
		CloseHandle(pi.hThread);
	}

	// Set the output pointer
	*lpdwGameID = pi.dwProcessId;

	// Free the strings in the connect info struct
	PRV_FreeConnectInfo(&ci);

	LEAVE_DPLOBBY();
	return DP_OK;

RUN_APP_ERROR_EXIT:

		if(pi.hThread && bCreatedProcess)
			CloseHandle(pi.hThread);
		if(bCreatedProcess && pi.hProcess)
			TerminateProcess(pi.hProcess, 0L);
		if(lpgn)
			PRV_RemoveGameNodeFromList(lpgn);
		PRV_FreeConnectInfo(&ci);

		LEAVE_DPLOBBY();
		return hr;

} // DPL_RunApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplobby.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobby.c
 *  Content:	Methods for lobby management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Fixed interface pointer casts for CreateAddress and
 *						EnumAddress
 *	4/10/97		myronth	Added support for GetCaps
 *	5/8/97		myronth	Drop lobby lock when calling LP
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added Register/UnregisterApplication
 *	12/4/97		myronth	Added ConnectEx
 *  10/22/99	aarono  added support for application flags
 *  12/13/99	pnewson bugs #123583, 123601, 123604 - support to launch dpvhelp.exe on 
 *						apps that are not registered or badly registered
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Connect"
HRESULT DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					LPDIRECTPLAY2 * lplpDP2, IUnknown FAR * lpUnk)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2, lpUnk);

	ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if( !VALID_WRITE_PTR( lplpDP2, sizeof(LPDIRECTPLAY2 *)) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

		if( lpUnk != NULL )
		{
			LEAVE_DPLOBBY();
			return CLASS_E_NOAGGREGATION;
		}

		if(!VALID_CONNECT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLOBBY();
		return DPERR_INVALIDPARAMS;
	}


	// Call the ConnectMe function which resides in the DPlay project
	hr = ConnectMe(lpDPL, lplpDP2, lpUnk, dwFlags);


	LEAVE_DPLOBBY();
	return hr;

} // DPL_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ConnectEx"
HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2 = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	// Call the ConnectMe function which resides in the DPlay project
	hr = DPL_Connect(lpDPL, dwFlags, &lpDP2, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2);
	}

	return hr;

} // DPL_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SaveConnectPointers"
void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 lpDP2, LPDPLCONNECTION lpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_SaveConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpDP2, lpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return;
#endif

	// Save the pointers
	this->lpDP2 = lpDP2;
	this->lpConn = lpConn;

} // PRV_SaveConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectPointers"
BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY lpDPL,
		LPDIRECTPLAY2 * lplpDP2, LPDPLCONNECTION * lplpConn)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_GetConnectPointers");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lplpDP2, lplpConn);


	ASSERT(lplpDP2);
	ASSERT(lplpConn);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// See if we have the pointers
	if((!this->lpDP2) || (!this->lpConn))
		return FALSE;

	// Set the output pointers
	*lplpDP2 = this->lpDP2;
	*lplpConn = this->lpConn;
	return TRUE;

} // PRV_GetConnectPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_IsAsyncConnectOn"
BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_IsAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
		return FALSE;
#endif

	// Check the flag
	if(this->dwFlags & DPLOBBYPR_ASYNCCONNECT)
		return TRUE;
	else
		return FALSE;

} // PRV_IsAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOn"
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOn");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Set the flag
	this->dwFlags |= DPLOBBYPR_ASYNCCONNECT;

} // PRV_TurnAsyncConnectOn



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_TurnAsyncConnectOff"
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_DPLOBJECT	this;


	DPF(7, "Entering PRV_TurnAsyncConnectOff");
	DPF(9, "Parameters: 0x%08x", lpDPL);

	this = DPLOBJECT_FROM_INTERFACE(lpDPL);
#ifdef DEBUG
	if( !VALID_DPLOBBY_PTR( this ) )
	{
		ASSERT(FALSE);
		return;
	}
#endif

	// Clear the flag
	this->dwFlags &= (~DPLOBBYPR_ASYNCCONNECT);

} // PRV_TurnAsyncConnectOff



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateAddress"
HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY lpDPL,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateAddress");
	DPF(9, "Parameters: 0x%08x, guid, guid, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpData, dwDataSize, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalCreateAddress((LPDIRECTPLAYSP)lpDPL, lpguidSP, lpguidDataType, lpData,
							dwDataSize, lpAddress, lpdwAddressSize);

	return hr;

} // DPL_CreateCompoundAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateCompoundAddress"

HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY lpDPL,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_CreateCompoundAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpDPL, lpAddressElements, dwAddressElementCount, lpAddress, lpdwAddressSize);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateCompoundAddress function which resides in the DPlay project
	hr = InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
									   lpAddress, lpdwAddressSize);
	return hr;

} // DPL_CreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddress"
HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY lpDPL,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress,
					DWORD dwAddressSize, LPVOID lpContext)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr;


	DPF(7, "Entering DPL_EnumAddress");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x",
			lpDPL, lpEnumCallback, lpAddress, dwAddressSize, lpContext);

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			return DPERR_INVALIDOBJECT;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// Call the CreateAddress function which resides in the DPlay project
	hr = InternalEnumAddress((LPDIRECTPLAYSP)lpDPL, lpEnumCallback, lpAddress,
							dwAddressSize, lpContext);

	return hr;

} // DPL_EnumAddress



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetCaps"
HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT this, DWORD dwFlags,
				LPDPCAPS lpcaps)
{
	SPDATA_GETCAPS		gcd;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_GetCaps");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", this, dwFlags, lpcaps);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&gcd, 0, sizeof(SPDATA_GETCAPS));
	gcd.dwSize = sizeof(SPDATA_GETCAPS);
	gcd.dwFlags = dwFlags;
	gcd.lpcaps = lpcaps;

	// Call the GetCaps method in the LP
	if(CALLBACK_EXISTS(GetCaps))
	{
		gcd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetCaps, &gcd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetCaps is required
		DPF_ERR("The Lobby Provider callback for GetCaps doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF(2, "Failed calling GetCaps in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetCaps



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteAppKeyFromRegistry"
HRESULT PRV_DeleteAppKeyFromRegistry(LPGUID lpguid)
{
	LPWSTR		lpwszAppName = NULL;
	HKEY		hkeyApp, hkeyDPApps = NULL;
	HRESULT		hr;
	LONG		lReturn;


	DPF(7, "Entering PRV_DeleteAppKeyFromRegistry");
	DPF(9, "Parameters: 0x%08x", lpguid);


	// Allocate memory for the App Name
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if(!lpwszAppName)
	{
		DPF_ERR("Unable to allocate memory for App Name!");
		return DPERR_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!PRV_FindGameInRegistry(lpguid, lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		DPF_ERR("Unable to find game in registry!");
		hr = DPERR_UNKNOWNAPPLICATION;
		goto EXIT_DELETEAPPKEY;
	}

	// Close the app key
	RegCloseKey(hkeyApp);

 	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// If we can't open it, we assume it doesn't exist, so
		// we'll call it a success.
		hr = DP_OK;
		goto EXIT_DELETEAPPKEY;
	}

	// Now delete the key
	hr = OS_RegDeleteKey(hkeyDPApps, lpwszAppName);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key, hr = 0x%08x", hr);
		goto EXIT_DELETEAPPKEY;
	}

EXIT_DELETEAPPKEY:

	// Free our string memory
	if(lpwszAppName)
		DPMEM_FREE(lpwszAppName);
	
	// Close the DP Applications key
	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_DeleteAppKeyFromRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryAnsi"
HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	CHAR	szGuid[GUID_STRING_SIZE];
	LPWSTR   lpwszAppName = NULL;
	HRESULT	hr;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;
	DWORD   dwRegFlags;
	DWORD   dwRegFlagsSize;
	DWORD   dwType;

	DPF(7, "Entering PRV_WriteAppDescInRegistryAnsi");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	// Open the registry key for the App, if it exists, so we can
	// check for the autovoice flag
	DPF(5, "Checking to see if game already present in registry");
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if (lpwszAppName == NULL)
	{
		DPF_ERR("Unable to allocate memory");
		hr = DPERR_NOMEMORY;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}
	if(PRV_FindGameInRegistry(&(lpDesc->guidApplication), lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		// Get the application flags
		DPF(5, "Game already registered");
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		dwType = 0;		
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// This application is already registered. We want to maintain the state
			// of the autovoice flag despite this re-registration, so set the appropriate
			// bit of lpDesc->dwFlags to the correct value.
			DPF(5, "Current Game flags: 0x%08x", dwRegFlags);
			if (dwRegFlags & DPLAPP_AUTOVOICE)
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag ON", dwRegFlags);
				lpDesc->dwFlags |= DPLAPP_AUTOVOICE;
			}
			else
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag OFF", dwRegFlags);
				lpDesc->dwFlags &= (~DPLAPP_AUTOVOICE);
			}
		}

		// Close the app key
		RegCloseKey(hkeyApp);
	}
	DPMEM_FREE(lpwszAppName);
	lpwszAppName = NULL;

	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = OS_RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Create the app's key
	lReturn = RegCreateKeyExA(hkeyDPApps, lpDesc->lpszApplicationNameA,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, (sizeof(wszGuid)/sizeof(WCHAR)));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}
	
	WideToAnsi(szGuid, wszGuid, WSTRLEN_BYTES(wszGuid));
	
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ,
				(LPBYTE)szGuid, lstrlenA(szGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilenameA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				lpDesc->lpszFilenameA, lstrlenA(lpDesc->lpszFilenameA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLineA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
			lpDesc->lpszCommandLineA, lstrlenA(lpDesc->lpszCommandLineA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPathA);
	lReturn = OS_RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				lpDesc->lpszPathA, lstrlenA(lpDesc->lpszPathA));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYANSI;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectoryA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
			lpDesc->lpszCurrentDirectoryA, lstrlenA(lpDesc->lpszCurrentDirectoryA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONA, 0, REG_SZ,
			lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_BINARY,
				(BYTE *)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherNameA){
		lReturn = OS_RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
			lpDesc2->lpszAppLauncherNameA, lstrlenA(lpDesc2->lpszAppLauncherNameA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherA string, lReturn = %lu", lReturn);
		}
	}

	// set the dwFlags field
	lReturn=OS_RegSetValueEx(hkeyApp, SZ_DWFLAGS, 0, REG_DWORD, (CHAR *)&lpDesc->dwFlags,sizeof(DWORD));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to write dwFlags field to registry, lReturn= %lu", lReturn);
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYANSI:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteAppDescInRegistryUnicode"
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC lpDesc)
{
	HKEY	hkeyDPApps = NULL, hkeyApp = NULL;
	LONG	lReturn;
	DWORD	dwDisposition;
	WCHAR	wszGuid[GUID_STRING_SIZE];
	HRESULT	hr;
	LPWSTR  lpwszAppName = NULL;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2)lpDesc;
	DWORD   dwRegFlags;
	DWORD   dwRegFlagsSize;
	DWORD   dwType;

	DPF(7, "Entering PRV_WriteAppDescInRegistryUnicode");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	// Open the registry key for the App, if it exists, so we can
	// check for the autovoice flag
	DPF(5, "Checking to see if game already present in registry");
	lpwszAppName = DPMEM_ALLOC(DPLOBBY_REGISTRY_NAMELEN*sizeof(WCHAR));
	if (lpwszAppName == NULL)
	{
		DPF_ERR("Unable to allocate memory");
		hr = DPERR_NOMEMORY;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}
	if(PRV_FindGameInRegistry(&(lpDesc->guidApplication), lpwszAppName,
				DPLOBBY_REGISTRY_NAMELEN, &hkeyApp))
	{
		// Get the application flags
		DPF(5, "Game already registered");
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		dwType = 0;		
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// This application is already registered. We want to maintain the state
			// of the autovoice flag despite this re-registration, so set the appropriate
			// bit of lpDesc->dwFlags to the correct value.
			DPF(5, "Current Game flags: 0x%08x", dwRegFlags);
			if (dwRegFlags & DPLAPP_AUTOVOICE)
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag ON", dwRegFlags);
				lpDesc->dwFlags |= DPLAPP_AUTOVOICE;
			}
			else
			{
				DPF(5, "Forcing DPLAPP_AUTOVOICE flag OFF", dwRegFlags);
				lpDesc->dwFlags &= (~DPLAPP_AUTOVOICE);
			}
		}

		// Close the app key
		RegCloseKey(hkeyApp);
	}
	DPMEM_FREE(lpwszAppName);
	lpwszAppName = NULL;

	// Delete the application key if it exists
	hr = PRV_DeleteAppKeyFromRegistry(&lpDesc->guidApplication);

 	// Open the Applications key (or create it if it doesn't exist
	lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0, NULL,
				REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDPApps,
				&dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to open DPlay Applications registry key!, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Create the app's key
	lReturn = RegCreateKeyEx(hkeyDPApps, lpDesc->lpszApplicationName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
				&hkeyApp, &dwDisposition);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to create application registry key, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the guid value
	hr = StringFromGUID(&lpDesc->guidApplication, wszGuid, (sizeof(wszGuid)/sizeof(WCHAR)));
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert application guid to string, hr = 0x%08x", hr);
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}
	
	lReturn = RegSetValueEx(hkeyApp, SZ_GUID, 0, REG_SZ, (BYTE *)wszGuid,
				WSTRLEN_BYTES(wszGuid));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Application guid, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the Filename value
	ASSERT(lpDesc->lpszFilename);
	lReturn = RegSetValueEx(hkeyApp, SZ_FILE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszFilename, WSTRLEN_BYTES(lpDesc->lpszFilename));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Filename string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CommandLine value (optional)
	if(lpDesc->lpszCommandLine)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_COMMANDLINE, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszCommandLine,
				WSTRLEN_BYTES(lpDesc->lpszCommandLine));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CommandLine string, lReturn = %lu", lReturn);
		}
	}

	// Set the Path value
	ASSERT(lpDesc->lpszPath);
	lReturn = RegSetValueEx(hkeyApp, SZ_PATH, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszPath, WSTRLEN_BYTES(lpDesc->lpszPath));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to register Path string, lReturn = %lu", lReturn);
		hr = DPERR_GENERIC;
		goto ERROR_WRITEAPPINREGISTRYUNICODE;
	}

	// Set the CurrentDirectory value (optional)
	if(lpDesc->lpszCurrentDirectory)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_CURRENTDIR, 0, REG_SZ,
					(LPBYTE)lpDesc->lpszCurrentDirectory,
					WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register CurrentDirectory string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionA value (optional)
	if(lpDesc->lpszDescriptionA)
	{
		lReturn = RegSetValueExA(hkeyApp, "DescriptionA", 0, REG_SZ,
				lpDesc->lpszDescriptionA, lstrlenA(lpDesc->lpszDescriptionA));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionA string, lReturn = %lu", lReturn);
		}
	}

	// Set the DescriptionW value (optional)
	if(lpDesc->lpszDescriptionW)
	{
		lReturn = RegSetValueEx(hkeyApp, SZ_DESCRIPTIONW, 0, REG_SZ,
				(LPBYTE)lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register DescriptionW string, lReturn = %lu", lReturn);
		}
	}

	// Set the LauncherName value (optional, DESC2 only)
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName){
		lReturn = RegSetValueEx(hkeyApp, SZ_LAUNCHER, 0, REG_SZ,
				(LPBYTE)lpDesc2->lpszAppLauncherName,
				WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName));
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERRVAL("Unable to register LauncherName string, lReturn = %lu", lReturn);
		}
	}

	// set the dwFlags field
	lReturn=RegSetValueEx(hkeyApp, SZ_DWFLAGS, 0, REG_DWORD, (CHAR *)&lpDesc->dwFlags,sizeof(DWORD));
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERRVAL("Unable to write dwFlags field to registry, lReturn= %lu", lReturn);
	}

	// Close the two keys
	RegCloseKey(hkeyDPApps);
	RegCloseKey(hkeyApp);

	return DP_OK;

ERROR_WRITEAPPINREGISTRYUNICODE:

	if(hkeyApp)
	{
		// Delete the key
		// REVIEW!!!! -- TODO

		// Now close the key
		RegCloseKey(hkeyApp);
	}

	if(hkeyDPApps)
		RegCloseKey(hkeyDPApps);

	return hr;

} // PRV_WriteAppDescInRegistryUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterApplication"
HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescA = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;

	DPF(7, "Entering DPL_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, FALSE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on a Unicode platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to ANSI
	if(OS_IsPlatformUnicode())
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDesc);
	}
	else
	{
		// Convert the APPDESC struct to ANSI
		hr = PRV_ConvertDPAPPLICATIONDESCToAnsi(lpDesc, &lpDescA);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Ansi, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDescA);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescA);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UnregisterApplication"
HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_UnregisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpguid);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		if(!VALID_READ_UUID_PTR(lpguid))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	hr = PRV_DeleteAppKeyFromRegistry((LPGUID)lpguid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to delete app key from registry, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();

	return hr;

} // DPL_UnregisterApplication
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplenum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplenum.c
 *  Content:	Methods for enumeration
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	12/10/96	myronth	Fixed bugs #4622 and #5043
 *	2/12/97		myronth	Mass DX5 changes
 *	3/4/97		myronth	Fixed enum size bug #6149
 *	3/12/97		myronth	Added EnumConnections
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/7/97		myronth	Fixed PRV_EnumConnections to use CreateCompoundAddress
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *	5/14/97		myronth	Check for valid guid in EnumLocalApps, bug #7695
 *	5/17/97		myronth	Fixed bug #8506 (return bogus error if last app
 *						is invalid), fixed more GUIDFromString bugs
 *	8/22/97		myronth	Added registry support for Description and Private
 *						values, also cleaned up LP enumeration code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	12/2/97		myronth	Changed EnumLocalApp to use Desc fields (#15448)
 *	01/20/98	sohailm	Don't free sp list after EnumConnections (#17006)
 *  10/22/99	aarono  Add support to hide apps from enum calls
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
LPLSPNODE	glpLSPHead = NULL;


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumAddressTypesCallback"
HRESULT PRV_CallEnumAddressTypesCallback(HKEY hkeySP,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				LPVOID lpContext)
{
	HRESULT		hr;
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
	GUID		guidAddressType;
	HKEY		hkeyAddressTypes;
	DWORD		dwIndex = 0;
	LONG		lReturn;
	BOOL		bReturn = TRUE;


	DPF(7, "Entering PRV_CallEnumAddressTypesCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeySP, lpfnEnumCallback, lpContext);
	
	ASSERT(hkeySP);	
	
	// Get the Address Type registry key
	lReturn = OS_RegOpenKeyEx(hkeySP, SZ_ADDRESS_TYPES, 0,
								KEY_READ, &hkeyAddressTypes);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("No Address Types found for the Service Provider!");
		return DP_OK;
	}

	// Walk the list of Address Types in the registry, looking for the GUID passed in
	while((ERROR_NO_MORE_ITEMS != OS_RegEnumKeyEx(hkeyAddressTypes, dwIndex++,
			(LPWSTR)wszGuidStr, &dwGuidStrSize, NULL, NULL, NULL, NULL)) && bReturn)
	{
		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidAddressType);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't convert Address Type string to GUID");
			dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
			continue;
		}

		// Call the callback
		bReturn = ((LPDPLENUMADDRESSTYPESCALLBACK)lpfnEnumCallback)
					(&guidAddressType, lpContext, 0L);


		// Reset the size variable in the success case
		dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
	}

	// Close the Address Types key
	RegCloseKey(hkeyAddressTypes);

	return DP_OK;


} // PRV_CallEnumAddressTypesCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumAddressTypes"
HRESULT PRV_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSPIn, LPVOID lpContext, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeySPHead, hkeySP;
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
	DWORD					dwType = REG_SZ;
	GUID					guidSP;
	LONG					lReturn;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);
    
	TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if (!VALID_READ_PTR(guidSPIn, sizeof(GUID)))
		{
			DPF_ERR("Invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		// There are no flags defined for DX3
		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Service Providers key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_SP_KEY, 0,
								KEY_READ, &hkeySPHead);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the Service Providers key doesn't exist (most
		// likely), so in that case, there are no SP's to enumerate.
		DPF_ERR("There are no Service Providers registered");
		return DP_OK;
	}


	// Walk the list of SP's in the registry, looking for the GUID passed in
	while(!bFound)
	{
		// Get the next SP in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeySPHead, dwIndex++, (LPWSTR)wszSPName,
					&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want to end on this iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;;

		// Open the SP key
		lReturn = OS_RegOpenKeyEx(hkeySPHead, (LPWSTR)wszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open key for Service Provider!");
			continue;
		}

		// Get the GUID of the SP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID
		hr = GUIDFromString(wszGuidStr, &guidSP);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Invalid SP guid -- skipping SP, hr = 0x%08x", hr);
			RegCloseKey(hkeySP);
			// Set the hresult back to DP_OK in case this is the last
			// SP in the registry -- we want the method call
			// to succeed if we got this far, we just don't want to
			// call the callback for this particular SP
			hr = DP_OK;
			continue;
		}

		// If we match the GUID passed in, then enumerate them
		if(IsEqualGUID(guidSPIn, &guidSP))
		{
			// Enumerate the Address Types for this SP
			hr = PRV_CallEnumAddressTypesCallback(hkeySP,
							lpfnEnumCallback, lpContext);
			bFound = TRUE;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeySPHead);

	// If we didn't find the SP, return an error
	// REVIEW!!!! -- Is this really the error we want here????
	if(!bFound)
		return DPERR_UNAVAILABLE;

	return hr;

} // PRV_EnumAddressTypes


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumAddressTypes"
HRESULT DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMADDRESSTYPESCALLBACK lpfnEnumCallback,
				REFGUID guidSP, LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumAddressTypes");
	DPF(9, "Parameters: 0x%08x, 0x%08x, guid, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumAddressTypes(lpDPL, lpfnEnumCallback, guidSP, lpContext, dwFlags);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumAddressTypes



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPNode"
void PRV_FreeLSPNode(LPLSPNODE lpNode)
{
	DPF(7, "Entering PRV_FreeLSPNode");

	if(!lpNode)
		return;

	if(lpNode->lpwszName)
		DPMEM_FREE(lpNode->lpwszName);
	if(lpNode->lpwszPath)
		DPMEM_FREE(lpNode->lpwszPath);
	if(lpNode->lpszDescA)
		DPMEM_FREE(lpNode->lpszDescA);
	if(lpNode->lpwszDesc)
		DPMEM_FREE(lpNode->lpwszDesc);
	DPMEM_FREE(lpNode);

} // PRV_FreeLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLSPList"
void PRV_FreeLSPList(LPLSPNODE lpLSPHead)
{
	LPLSPNODE	lpTemp;


	DPF(7, "Entering PRV_FreeLSPList");
	DPF(9, "Parameters: 0x%08x", lpLSPHead);
	
	// Walk the list and free each node
	while(lpLSPHead)
	{
		// Save the next one
		lpTemp = lpLSPHead->lpNext;
		
		// Free all of the members
		PRV_FreeLSPNode(lpLSPHead);

		// Move to the next one
		lpLSPHead = lpTemp;
	}

} // PRV_FreeLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddLSPNode"
HRESULT PRV_AddLSPNode(LPWSTR lpwszName, LPWSTR lpwszPath, LPWSTR lpwszDesc,
			LPSTR lpszDescA, LPWSTR lpwszGuid, DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwNodeFlags)
{
	LPLSPNODE	lpLSPNode = NULL;
	DWORD		dwDescASize;
	HRESULT		hr;


	DPF(7, "Entering PRV_AddLSPNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, %lu, 0x%08x",
			lpwszName, lpwszPath, lpwszDesc, lpszDescA, lpwszGuid, dwReserved1,
			dwReserved2, dwNodeFlags);


	// Allocate memory for the node
	lpLSPNode = DPMEM_ALLOC(sizeof(LSPNODE));
	if(!lpLSPNode)
	{
		DPF_ERR("Failed to allocate memory for Lobby Provider node, skipping LP");
		return DPERR_OUTOFMEMORY;
	}

	// Allocate memory for the Name string and copy it
	hr = GetString(&lpLSPNode->lpwszName, lpwszName);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Name string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	// Allocate memory for the Path string and copy it
	hr = GetString(&lpLSPNode->lpwszPath, lpwszPath);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_ADDLSPNODE;
	}

	if(dwNodeFlags & LSPNODE_DESCRIPTION)
	{
		// Allocate memory for the DescriptionA string and copy it
		dwDescASize = lstrlenA(lpszDescA)+1;
		lpLSPNode->lpszDescA = DPMEM_ALLOC(dwDescASize);
		if(!lpLSPNode->lpszDescA)
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider Path string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
		memcpy(lpLSPNode->lpszDescA, lpszDescA, dwDescASize);

		// Allocate memory for the DescriptionW string and copy it
		hr = GetString(&lpLSPNode->lpwszDesc, lpwszDesc);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for Lobby Provider DescriptionW string, skipping provider");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_ADDLSPNODE;
		}
	}

	// Convert the string to a real GUID
	hr = GUIDFromString(lpwszGuid, &lpLSPNode->guid);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Invalid LP guid -- skipping LP, hr = 0x%08x", hr);
		goto ERROR_ADDLSPNODE;
	}

	// Finish setting up the node
	lpLSPNode->dwReserved1 = dwReserved1;
	lpLSPNode->dwReserved2 = dwReserved2;
	lpLSPNode->dwNodeFlags = dwNodeFlags;

	// Add the node to the list
	lpLSPNode->lpNext = glpLSPHead;
	glpLSPHead = lpLSPNode;

	return DP_OK;

ERROR_ADDLSPNODE:

	if(lpLSPNode->lpwszName)
		DPMEM_FREE(lpLSPNode->lpwszName);
	if(lpLSPNode->lpwszPath)
		DPMEM_FREE(lpLSPNode->lpwszPath);
	if(lpLSPNode->lpwszDesc)
		DPMEM_FREE(lpLSPNode->lpwszDesc);
	if(lpLSPNode->lpszDescA)
		DPMEM_FREE(lpLSPNode->lpszDescA);
	DPMEM_FREE(lpLSPNode);

	return hr;

} // PRV_AddLSPNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_BuildLSPList"
HRESULT PRV_BuildLSPList()
{
	HKEY		hkeyLobbySP, hkeySP;
	WCHAR		szSPName[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPPath[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		szSPDescW[DPLOBBY_REGISTRY_NAMELEN];
	CHAR		szSPDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR		wszGuidStr[GUID_STRING_SIZE];
	DWORD		dwSize;
	DWORD		dwGuidStrSize = GUID_STRING_SIZE;
	DWORD		dwType = REG_SZ;
	DWORD		dwIndex = 0;
	DWORD		dwReserved1, dwReserved2, dwReservedSize;
	LONG		lReturn;
	DWORD		dwError;
	HRESULT		hr;
	DWORD		dwNodeFlags = 0;

												
	DPF(7, "Entering PRV_BuildLSPList");
	
	if(glpLSPHead)
	{
		return DP_OK;
	}

	// Open the DPLobby SP key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLOBBY_SP_KEY, 0,
								KEY_READ, &hkeyLobbySP);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the DPLobby SP key doesn't exist (most
		// likely), so in that case, there are no Lobby SP's to enumerate.
		return DP_OK;
	}

	// Walk the list of Lobby SP's in the registry, enumerating them
	while(1)
	{
		// Get the next LSP Name
		dwSize = sizeof(szSPName)/sizeof(TCHAR);
		lReturn = OS_RegEnumKeyEx(hkeyLobbySP, dwIndex++, szSPName,
					&dwSize, NULL, NULL, NULL, NULL);
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;
		else if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider name from the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}

		// Open the subkey
		lReturn = OS_RegOpenKeyEx(hkeyLobbySP, szSPName, 0, KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to open Lobby Provider key in the registry -- dwError = %u -- skipping provider", dwError);
			continue;
		}


		// First see if the "Private" key exists.  If it does, then set the flag
		// so that it will get skipped during enumeration
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PRIVATE, NULL, &dwType, NULL, &dwSize);
		if (ERROR_SUCCESS == lReturn) 
		{
			// The key exists, so set the flag so we don't enumerate it
			dwNodeFlags |= LSPNODE_PRIVATE;
		}


		// Get the LSP Path
		dwSize = sizeof(szSPPath);
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_PATH, NULL, &dwType,
					(LPBYTE)szSPPath, &dwSize);
		if(lReturn != ERROR_SUCCESS)
		{
			dwError = GetLastError();
			DPF_ERRVAL("Unable to get Lobby Provider path from the registry -- dwError = %u -- skipping provider", dwError);
			RegCloseKey(hkeySP);
			continue;
		}

		// Get the LSP Descriptions
		// If the DescriptionA value doesn't exist, then don't worry about
		// getting the DescriptionW value.  If the DescriptionA value exits,
		// but the DescriptionW value does not, convert the DescriptionA
		// value to Unicode and store it in DescriptionW.
		// NOTE: We always assume the DescriptionA value is an ANSI string,
		// even if it's stored in a Unicode format on NT & Memphis.  So we
		// always retrieve this as an ANSI string
		dwSize = sizeof(szSPDescA);
		lReturn = RegQueryValueExA(hkeySP, "DescriptionA", NULL, &dwType,
					(LPBYTE)szSPDescA, &dwSize);
		if(lReturn == ERROR_SUCCESS)
		{
			// Save the description flag
			dwNodeFlags |= LSPNODE_DESCRIPTION;

			// Get the DescriptionW value
			dwSize = sizeof(szSPDescW);
			lReturn = OS_RegQueryValueEx(hkeySP, SZ_DESCRIPTIONW, NULL, &dwType,
						(LPBYTE)szSPDescW, &dwSize);
			if(lReturn != ERROR_SUCCESS)
			{
				// Convert the ANSI Description string to Unicode and store it
				AnsiToWide(szSPDescW, szSPDescA, (lstrlenA(szSPDescA)+1));
			}
		}
		
		// Get the GUID of the LSP
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = OS_RegQueryValueEx(hkeySP, SZ_GUID, NULL, &dwType,
					(LPBYTE)wszGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value for Lobby Provider!");
			continue;
		}

		// Get the Reserved1 dword (we don't care if it fails)
		dwType = REG_DWORD;
		dwReservedSize = sizeof(DWORD);
		dwReserved1 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved1, &dwReservedSize);
		
		// Get the Reserved1 dword (we don't care if it fails)
		dwReservedSize = sizeof(DWORD);
		dwReserved2 = 0;
		OS_RegQueryValueEx(hkeySP, SZ_DWRESERVED1, NULL, &dwType,
			(LPBYTE)&dwReserved2, &dwReservedSize);
		
		
		// Add the node to the list
		hr = PRV_AddLSPNode(szSPName, szSPPath, szSPDescW, szSPDescA,
				wszGuidStr, dwReserved1, dwReserved2, dwNodeFlags);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed adding Lobby Provider to internal list, hr = 0x%08x", hr);
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the Lobby SP key
	RegCloseKey(hkeyLobbySP);

	return DP_OK;

} // PRV_BuildLSPList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumConnections"
HRESULT PRV_EnumConnections(LPCGUID lpGuid, LPDPENUMCONNECTIONSCALLBACK lpCallback,
			LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
	LPLSPNODE					lpLSPNode, lpLSPHead;
	BOOL						bContinue = TRUE;
	DPNAME						name;
	HRESULT						hr = DP_OK;
	DPCOMPOUNDADDRESSELEMENT	AddrOnly;
	LPDPADDRESS					lpAddress = NULL;
	DWORD						dwAddressSize;
	DWORD						dwAddressSizeSave;
	LPWSTR						lpwszName = NULL;


	DPF(7, "Entering PRV_EnumConnections");
	DPF(9, "Parameters: ");

	// Rebuild the LSP List
	PRV_BuildLSPList();

	// If we don't have any entries, just bail here
	if(!glpLSPHead)
		return DP_OK;

	// Get a pointer to the first lobby provider, and store our head pointer
	lpLSPHead = glpLSPHead;
	lpLSPNode = glpLSPHead;

	// Setup the unfinished address
	memset(&AddrOnly, 0, sizeof(DPCOMPOUNDADDRESSELEMENT));
	AddrOnly.guidDataType = DPAID_LobbyProvider;
	AddrOnly.dwDataSize = sizeof(GUID);
	AddrOnly.lpData = &lpLSPNode->guid;

	// Calculate the size of the finished address
	hr = InternalCreateCompoundAddress(&AddrOnly, 1, NULL, &dwAddressSize);
	if(hr != DPERR_BUFFERTOOSMALL)
	{
		DPF_ERRVAL("Failed to retrieve the size of the output address buffer, hr = 0x%08x", hr);
		return hr;
	}

	// Allocate the buffer for the finished address
	lpAddress = DPMEM_ALLOC(dwAddressSize);
	if(!lpAddress)
	{
		DPF_ERR("Unable to allocate memory for temporary address structure");
		return DPERR_OUTOFMEMORY;
	}

	// Clear the DPNAME struct
	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	dwAddressSizeSave = dwAddressSize;

	// Drop the locks
	LEAVE_ALL();

	while ((lpLSPNode) && (bContinue))
	{
		// If the private flag is set, don't enumerate it
		if(!(lpLSPNode->dwNodeFlags & LSPNODE_PRIVATE))
		{
			// Create the real DPADDRESS
			dwAddressSize = dwAddressSizeSave;
			AddrOnly.lpData = &lpLSPNode->guid;
			hr = InternalCreateCompoundAddress(&AddrOnly, 1, lpAddress,
					&dwAddressSize);
			if(SUCCEEDED(hr))
			{
				// Call the callback
				// If the caller is ANSI, convert the string
				if (bAnsi)
				{
					// If we have a description string, use it, and we already
					// have an ANSI version to use
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
					{
						name.lpszShortNameA = lpLSPNode->lpszDescA;

						// Call the app's callback
						bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
									DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
					}
					else
					{
						hr = GetAnsiString(&(name.lpszShortNameA), lpLSPNode->lpwszName);
						if(SUCCEEDED(hr))
						{
							// Call the app's callback
							bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
										DPCONNECTION_DIRECTPLAYLOBBY, lpContext);

							// Free our short name buffer
							DPMEM_FREE(name.lpszShortNameA);
						}
						else
						{
							DPF_ERR("Unable to allocate memory for temporary name string, skipping Connection");
						}
					}
				}
				else 
				{
					// If we have a description, use it
					if(lpLSPNode->dwNodeFlags & LSPNODE_DESCRIPTION)
						lpwszName = lpLSPNode->lpwszDesc;
					else
						lpwszName = lpLSPNode->lpwszName;

					name.lpszShortName = lpwszName;

					// Call the app's callback
					bContinue= lpCallback(&lpLSPNode->guid, lpAddress, dwAddressSize, &name,
								DPCONNECTION_DIRECTPLAYLOBBY, lpContext);
				}
			}
			else
			{
				DPF(2, "Failed to create DPADDRESS structure, skipping this Connection, hr = 0x%08x", hr);
			}
		}
				
		lpLSPNode = lpLSPNode->lpNext;

	} // while

	// Take the locks back
	ENTER_ALL();

	// Free our temporary address struct
	DPMEM_FREE(lpAddress);
	
	return DP_OK;	

} // PRV_EnumConnections





#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CallEnumLocalAppCallback"
HRESULT PRV_CallEnumLocalAppCallback(LPWSTR lpwszAppName, LPGUID lpguidApp,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, BOOL bAnsi, LPSTR lpszDescA,
				LPWSTR lpwszDescW)
{
	LPDPLAPPINFO	lpai = NULL;
	LPSTR			lpszAppName = NULL;
	BOOL			bReturn;


	DPF(7, "Entering PRV_CallEnumLocalAppCallback");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpwszAppName, lpguidApp, lpfnEnumCallback, lpContext, bAnsi,
			lpszDescA, lpwszDescW);

	// Allocate memory for the AppInfo struct
	lpai = DPMEM_ALLOC(sizeof(DPLAPPINFO));
	if(!lpai)
	{
		DPF_ERR("Unable to allocate memory for AppInfo structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Set the size
	lpai->dwSize = sizeof(DPLAPPINFO);

	// If the description strings exist, use them
	// NOTE: We can assume that if the DescriptionA string exists,
	// they both do.
	if(lpszDescA)
	{
		if(bAnsi)
			lpai->lpszAppNameA = lpszDescA;
		else
			lpai->lpszAppName = lpwszDescW;
	}
	else
	{
		// If we're ANSI, convert the string
		if(bAnsi)
		{
			if(FAILED(GetAnsiString(&lpszAppName, lpwszAppName)))
			{
				DPMEM_FREE(lpai);
				DPF_ERR("Unable to allocate memory for temporary string!");
				return DPERR_OUTOFMEMORY;
			}

			lpai->lpszAppNameA = lpszAppName;
		}
		else
		{
			lpai->lpszAppName = lpwszAppName;
		}
	}

	// Set the GUID
	lpai->guidApplication = *lpguidApp;

	// Call the callback
	bReturn = ((LPDPLENUMLOCALAPPLICATIONSCALLBACK)lpfnEnumCallback)
				(lpai, lpContext, 0L);

	// Free all of our memory
	if(lpszAppName)
		DPMEM_FREE(lpszAppName);
	DPMEM_FREE(lpai);

	// Set our HRESULT return value
	if(bReturn)
		return DP_OK;
	else
		return DPLOBBYPR_CALLBACKSTOP;

} // PRV_CallEnumLocalAppCallback


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnumLocalApplications"
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;
	HKEY					hkeyDPApps, hkeyApp;
	WCHAR					wszAppName[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwIndex = 0;
	DWORD					dwNameSize;
	WCHAR					wszGuidStr[GUID_STRING_SIZE];
	DWORD					dwGuidStrSize = sizeof(wszGuidStr)/sizeof(WCHAR);
	DWORD					dwType = REG_SZ;
	GUID					guidApp;
	LONG					lReturn;
	CHAR					szDescA[DPLOBBY_REGISTRY_NAMELEN];
	WCHAR					wszDescW[DPLOBBY_REGISTRY_NAMELEN];
	DWORD					dwDescSize;
	BOOL					bDesc = FALSE;
	LPSTR					lpszDescA = NULL;
	LPWSTR					lpwszDescW = NULL;
	BOOL					bHide;
	DWORD					dwRegFlags;
	DWORD					dwRegFlagsSize;


	DPF(7, "Entering PRV_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }
        
        if( !VALIDEX_CODE_PTR( lpfnEnumCallback ) )
        {
            return DPERR_INVALIDPARAMS;
        }

		if( dwFlags )
		{
			return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Open the Applications key
	lReturn = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY, 0,
								KEY_READ, &hkeyDPApps);
	if(lReturn != ERROR_SUCCESS)
	{
		// This just means that the application key doesn't exist (most
		// likely), so in that case, there are no apps to enumerate.
		return DP_OK;
	}


	// Walk the list of DPlay games in the registry, enumerating them
	while(1)
	{
		// Reset the pointers and the flag
		lpszDescA = NULL;
		lpwszDescW = NULL;
		bDesc = FALSE;
		bHide = FALSE;

		// Get the next app in the list
		dwNameSize = DPLOBBY_REGISTRY_NAMELEN;
		lReturn = OS_RegEnumKeyEx(hkeyDPApps, dwIndex++, (LPWSTR)wszAppName,
						&dwNameSize, NULL, NULL, NULL, NULL);

		// If lReturn is ERROR_NO_MORE_ITEMS, we want this to be the last iteration
		if(lReturn == ERROR_NO_MORE_ITEMS)
			break;

		// Open the app key
		lReturn = OS_RegOpenKeyEx(hkeyDPApps, (LPWSTR)wszAppName, 0,
									KEY_READ, &hkeyApp);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open app key!");
			continue;
		}

		// see if we should even report this game (its hidden)
		dwRegFlags = 0;
		dwRegFlagsSize = sizeof(dwRegFlags);
		lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DWFLAGS, NULL, &dwType, (CHAR *)&dwRegFlags, &dwRegFlagsSize);
		
		if(lReturn == ERROR_SUCCESS && dwRegFlags & DPLAPP_NOENUM){
		
			// application is hidden, don't report it back to the application.
			bHide = TRUE;
			
		} else {

			// Get the GUID of the Game
			dwGuidStrSize = GUID_STRING_SIZE;
			lReturn = OS_RegQueryValueEx(hkeyApp, SZ_GUID, NULL, &dwType,
										(LPBYTE)wszGuidStr, &dwGuidStrSize);
			if(lReturn != ERROR_SUCCESS)
			{
				RegCloseKey(hkeyApp);
				DPF_ERR("Unable to query GUID key value!");
				continue;
			}

			// Convert the string to a real GUID
			hr = GUIDFromString(wszGuidStr, &guidApp);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Invalid game guid -- skipping game, hr = 0x%08x", hr);
				RegCloseKey(hkeyApp);
				// Set the hresult back to DP_OK in case this is the last
				// application in the registry -- we want the method call
				// to succeed if we got this far, we just don't want to
				// call the callback for this particular application
				hr = DP_OK;
				continue;
			}

			// Get the Description strings
			dwDescSize = sizeof(szDescA);
			lReturn = RegQueryValueExA(hkeyApp, "DescriptionA", NULL, &dwType,
						(LPBYTE)szDescA, &dwDescSize);
			if(lReturn != ERROR_SUCCESS) 
			{
				DPF(5,"Could not read Description lReturn = %d\n",lReturn);
				// it's ok if the app doesn't have one of these...
			}
			else
			{
				DPF(5,"Got DescriptionA = %s\n",szDescA);
				
				// Set our description flag
				bDesc = TRUE;

				// Now try to get the DescriptionW string if one exists.  If for some
				// reason a DescriptionW string exists, but the DescriptionA does not,
				// we pretend the DescriptionW string doesn't exist either.
				// NOTE: We always assume the DescriptionW string is a Unicode string,
				// even on Win95.  On Win95, this will be of the type REG_BINARY, but
				// it is really just a Unicode string.
				dwDescSize = sizeof(wszDescW);
				lReturn = OS_RegQueryValueEx(hkeyApp, SZ_DESCRIPTIONW, NULL,
							&dwType, (LPBYTE)wszDescW, &dwDescSize);
				if(lReturn != ERROR_SUCCESS) 
				{
					DPF(5,"Could not get DescriptionW, converting DescriptionA");

					// We couldn't get DescriptionW, so convert DescriptionA...
					AnsiToWide(wszDescW,szDescA,(lstrlenA(szDescA)+1));
				}
				else
				{
					DPF(5,"Got DescriptionW = %ls\n",wszDescW);
				}

			}
		}		
		
		// Close the App key
		RegCloseKey(hkeyApp);

		// Setup the description pointers if they are valid
		if(bDesc)
		{
			lpszDescA = (LPSTR)szDescA;
			lpwszDescW = (LPWSTR)wszDescW;
		}

		if(bHide){
			// not calling back for this hidden application
			hr=DP_OK;
		} else {
			// Call the callback
			hr = PRV_CallEnumLocalAppCallback(wszAppName, &guidApp,
							lpfnEnumCallback, lpContext, bAnsi,
							lpszDescA, lpwszDescW);
		}

		if(hr == DPLOBBYPR_CALLBACKSTOP)
		{
			hr = DP_OK;
			break;
		}
		else
		{
			if(FAILED(hr))
				break;
			else
				continue;
		}
	}

	// Close the DPlay Apps key
	RegCloseKey(hkeyDPApps);
	dwNameSize = DPLOBBY_REGISTRY_NAMELEN;

	return hr;

} // PRV_EnumLocalApplications


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumLocalApplications"
HRESULT DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK lpfnEnumCallback,
				LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpfnEnumCallback, lpContext, dwFlags);

	ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpfnEnumCallback, lpContext,
								dwFlags, FALSE);

	LEAVE_DPLOBBY();

	return hr;

} // DPL_EnumLocalApplications
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplobbya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbya.c
 *  Content:	ANSI Methods for IDirectPlayLobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/24/96		myronth	Created it
 *	9/09/96		kipo	Pass UNICODE IDirectPlayLobby interface to
 *						DPL_Connect() instead of ANSI interface. Bug #3790.
 *	10/23/96	myronth	Added client/server methods
 *	12/12/96	myronth	Fixed DPLCONNECTION validation
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	5/8/97		myronth	Get/SetGroupConnectionSettings, removed dead code
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/5/97		myronth	Fixed locking macro
 *	11/13/97	myronth	Added stop async check for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added DPL_A_RegisterApplication
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_Connect"
HRESULT DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				LPDIRECTPLAY2 * lplpDP2A, IUnknown FAR * lpUnk)
{
	HRESULT			hr;
	LPDIRECTPLAY2	lpDP2;
	LPDIRECTPLAYLOBBY	lpDPLW;


	DPF(7, "Entering DPL_A_Connect");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lplpDP2A, lpUnk);

    ENTER_DPLOBBY();

	TRY
	{
		if( !VALID_WRITE_PTR( lplpDP2A, sizeof(LPDIRECTPLAY2 *) ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	LEAVE_DPLOBBY();

	// QueryInterface for the UNICODE DirectPlayLobby interface
	hr = lpDPL->lpVtbl->QueryInterface(lpDPL, &IID_IDirectPlayLobby, &lpDPLW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to QueryInterface for the UNICODE DirectPlayLobby interface");
		return (hr);
	}

	// Use the UNICODE IDirectPlayLobby interface (fixes bug #3790)
	hr = DPL_Connect(lpDPLW, dwFlags, &lpDP2, lpUnk);

	// release UNICODE IDirectPlayLobby interface
	lpDPLW->lpVtbl->Release(lpDPLW);
	lpDPLW = NULL;

	if(SUCCEEDED(hr))
	{
		ENTER_DPLOBBY();

		// QueryInterface for the ANSI interface
		hr = lpDP2->lpVtbl->QueryInterface(lpDP2, &IID_IDirectPlay2A, lplpDP2A);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to QueryInterface for the ANSI DirectPlay interface");
		}

		// Release the Unicode interface
		lpDP2->lpVtbl->Release(lpDP2);

		LEAVE_DPLOBBY();
	}

	return hr;

} // DPL_A_Connect



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_ConnectEx"
HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
				REFIID riid, LPVOID * ppvObj, IUnknown FAR * lpUnk)
{
	LPDIRECTPLAY2		lpDP2A = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_A_ConnectEx");
	DPF(9, "Parameters: 0x%08x, 0x%08x, iid, 0x%08x, 0x%08x",
			lpDPL, dwFlags, ppvObj, lpUnk);


	hr = DPL_A_Connect(lpDPL, dwFlags, &lpDP2A, lpUnk);
	if(SUCCEEDED(hr))
	{
		hr = DP_QueryInterface((LPDIRECTPLAY)lpDP2A, riid, ppvObj);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling QueryInterface, hr = 0x%08x", hr);
		}

		// Release the DP2 object
		DP_Release((LPDIRECTPLAY)lpDP2A);
	}

	return hr;

} // DPL_A_ConnectEx



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_EnumLocalApplications"
HRESULT DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY lpDPL,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK lpCallback,
					LPVOID lpContext, DWORD dwFlags)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_EnumLocalApplications");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, lpCallback, lpContext, dwFlags);

    ENTER_DPLOBBY();
    
	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_EnumLocalApplications(lpDPL, lpCallback, lpContext,
								dwFlags, TRUE);
	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_EnumLocalApplications



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetConnectionSettings"
HRESULT DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
					DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, TRUE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY lpDP,
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_A_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData, lpdwSize);
	if(SUCCEEDED(hr))
	{
		// Now convert the DPLCONNECTION to ANSI in place
		hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace((LPDPLCONNECTION)lpData,
				lpdwSize, 0);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed converting DPLCONNECTION struct to ANSI, hr = 0x%08x", hr);
		}
	}

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RegisterApplication"
HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPAPPLICATIONDESC		lpDescW = NULL;
	HRESULT					hr = DP_OK;
	LPDPAPPLICATIONDESC 	lpDesc=(LPDPAPPLICATIONDESC)lpvDesc;
	
	DPF(7, "Entering DPL_A_RegisterApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpDesc);

	ENTER_DPLOBBY();

    TRY
    {
		// We only need to validate the interface pointer here.  Everything else
		// will get validated by the main function.
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
		if( !VALID_DPLOBBY_PTR( this ) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
		}

		if(dwFlags)
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationDesc struct
		hr = PRV_ValidateDPAPPLICATIONDESC(lpDesc, TRUE);
		if(FAILED(hr))
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Invalid DPAPPLICATIONDESC structure");
			return hr;
		}
	}

	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
	}

	// If we're on an ANSI platform, just write the stuff in the registry.
	// If it's not, we need to convert the DPAPPLICATIONDESC struct to Unicode
	if(OS_IsPlatformUnicode())
	{
		// Convert the APPDESC struct to Unicode
		hr = PRV_ConvertDPAPPLICATIONDESCToUnicode(lpDesc, &lpDescW);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to convert DPAPPLICATIONDESC to Unicode, hr = 0x%08x", hr);
			goto ERROR_REGISTERAPPLICATION;
		}

		// Write to the registry
		hr = PRV_WriteAppDescInRegistryUnicode(lpDescW);

		// Free our APPDESC structure
		PRV_FreeLocalDPAPPLICATIONDESC(lpDescW);
	}
	else
	{
		// Just write to the registry
		hr = PRV_WriteAppDescInRegistryAnsi(lpDesc);
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed writing ApplicationDesc to registry, hr = 0x%08x", hr);
	}

ERROR_REGISTERAPPLICATION:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RegisterApplication



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeInternalDPLCONNECTION"
void PRV_FreeInternalDPLCONNECTION(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd;
	LPDPNAME			lpn;


	DPF(7, "Entering PRV_FreeInternalDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x", lpConn);

	if(!lpConn)
		return;

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		if(lpsd->lpszSessionName)
			DPMEM_FREE(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			DPMEM_FREE(lpsd->lpszPassword);
		DPMEM_FREE(lpsd);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		if(lpn->lpszShortName)
			DPMEM_FREE(lpn->lpszShortName);
		if(lpn->lpszLongName)
			DPMEM_FREE(lpn->lpszLongName);
		DPMEM_FREE(lpn);
	}

	DPMEM_FREE(lpConn);

} // PRV_FreeInternalDPLCONNECTION


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_RunApplication"
HRESULT DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
							LPDWORD lpdwGameID, LPDPLCONNECTION lpConnA,
							HANDLE hReceiveEvent)
{
	LPDPLCONNECTION	lpConnW = NULL;
	HRESULT			hr;


	DPF(7, "Entering DPL_A_RunApplication");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, lpdwGameID, lpConnA, hReceiveEvent);

    ENTER_DPLOBBY();

	
	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Convert the ANSI DPLCONNECTION structure to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Failed to convert ANSI DPLCONNECTION structure to Unicode (temp)");
		LEAVE_DPLOBBY();
		return hr;
	}

	LEAVE_DPLOBBY();
	hr = DPL_RunApplication(lpDPL, dwFlags, lpdwGameID, lpConnW,
							hReceiveEvent);
	ENTER_DPLOBBY();

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_RunApplication



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetConnectionSettings"
HRESULT DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
						DWORD dwFlags, DWORD dwGameID,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConnA);

    ENTER_DPLOBBY();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_DPLOBBY();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_DPLOBBY();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConnW);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_A_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_A_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY lpDP,
						DWORD dwFlags, DPID idGroup,
						LPDPLCONNECTION lpConnA)
{
	HRESULT			hr;
	LPDPLCONNECTION	lpConnW = NULL;


	DPF(7, "Entering DPL_A_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConnA);

	ENTER_LOBBY_ALL();

	// Validate the DPLCONNECTION structure and it's members
	hr = PRV_ValidateDPLCONNECTION(lpConnA, TRUE);
	if(FAILED(hr))
	{
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Conver the ANSI DPLCONNECTION struct to Unicode
	hr = PRV_ConvertDPLCONNECTIONToUnicode(lpConnA, &lpConnW);
	if(FAILED(hr))
	{
		DPF_ERR("Unable to convert DPLCONNECTION structure to Unicode");
		LEAVE_LOBBY_ALL();
		return hr;
	}

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup,
										lpConnW, TRUE);

	// Free our temporary Unicode DPLCONNECTION structure
	PRV_FreeInternalDPLCONNECTION(lpConnW);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_A_SetGroupConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplobbyi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobbyi.h
 *  Content:    DirectPlayLobby internal include file
 *
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	2/25/97		myronth	Created it
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added Connection & Session Management stuff plus
 *						a few forward declarations for internal objects
 *	3/17/97		myronth	Create/DestroyGroup/Player
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroup/PlayerName, Get/SetGroup/PlayerData
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	3/31/97		myronth	Send
 *	4/10/97		myronth	GetCaps, GetPlayerCaps
 *	5/8/97		myronth	Subgroup functions, GroupConnSettings, StartSession,
 *						Purged dead code
 *	5/13/97		myronth	Pass credentials to PRV_Open, pass them on to the LP
 *	5/17/97		myronth	SendChatMessage
 *	8/19/97		myronth	More prototypes for sending standard lobby messages
 *	8/19/97		myronth	Removed prototypes for dead functions
 *	9/29/97		myronth	Added PRV_ConvertDPLCONNECTIONToAnsiInPlace prototype
 *	10/29/97	myronth	Added group owner ID to create group methods, exposed
 *						map table functions, exposed group owner methods
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added functions for asynchronous Connect (#12541)
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *	1/20/98		myronth	Moved PRV_SendStandardSystemMessage into this file
 ***************************************************************************/
#ifndef __DPLOBBYI_INCLUDED__
#define __DPLOBBYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------
#ifndef DPLAPI
#define DPLAPI WINAPI
#endif

typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;
typedef struct LSPNODE * LPLSPNODE;

#define DPLOBBYPR_GAMEID				0

// Forward declarations needed because of the include file order in DPlay
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY;

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------
extern LPLSPNODE	glpLSPHead;			// In dplenum.c

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// create.c
extern HRESULT PRV_AllocateLobbyObject(LPDPLAYI_DPLAY, LPDPLOBBYI_DPLOBJECT *);

// dplenum.c
extern void PRV_FreeLSPList(LPLSPNODE);
extern HRESULT PRV_EnumConnections(LPCGUID, LPDPENUMCONNECTIONSCALLBACK,
									LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT DPLAPI PRV_GetCaps(LPDPLOBBYI_DPLOBJECT, DWORD, LPDPCAPS);
extern BOOL PRV_GetConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 *, LPDPLCONNECTION *);
extern void PRV_SaveConnectPointers(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2, LPDPLCONNECTION);
extern BOOL PRV_IsAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOn(LPDIRECTPLAYLOBBY);
void PRV_TurnAsyncConnectOff(LPDIRECTPLAYLOBBY);

// dplobbya.c
extern HRESULT DPLAPI DPL_A_GetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_SetGroupConnectionSettings(LPDIRECTPLAY,
						DWORD, DPID, LPDPLCONNECTION);

// dplpack.c
extern void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION);
extern HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION, LPDWORD, DWORD);

// dplshare.c
extern HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY, DWORD, DWORD);

// dplunk.c
extern HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT);
extern void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT);

// group.c
extern HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT, DPID,
			LPDPID, LPDPNAME, LPVOID, DWORD, DWORD, DPID);
extern HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT, DPID, DPID);
extern HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD,
			DPID, LPDPLCONNECTION);
extern HRESULT DPLAPI DPL_GetGroupOwner(LPDIRECTPLAY, DPID, LPDPID);
extern HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY, DPID, DPID);
extern HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY, DWORD, DPID);

// player.c
extern HRESULT DPLAPI PRV_CreatePlayer(LPDPLOBBYI_DPLOBJECT,
			LPDPID, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_DestroyPlayer(LPDPLOBBYI_DPLOBJECT, DPID);
extern HRESULT DPLAPI PRV_GetPlayerCaps(LPDPLOBBYI_DPLOBJECT, DWORD, DPID, LPDPCAPS);
extern HRESULT DPLAPI PRV_GetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, LPDWORD);
extern HRESULT DPLAPI PRV_Send(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPVOID, DWORD);
extern HRESULT DPLAPI PRV_SendChatMessage(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DWORD, LPDPCHAT);
extern HRESULT DPLAPI PRV_SetPlayerData(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD, DWORD);
extern HRESULT DPLAPI PRV_SetPlayerName(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, DWORD);
extern BOOL PRV_GetDPIDByLobbyID(LPDPLOBBYI_DPLOBJECT, DWORD, DPID *);
extern BOOL PRV_GetLobbyIDByDPID(LPDPLOBBYI_DPLOBJECT, DPID, LPDWORD);
extern HRESULT PRV_AddMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD, DPID);
extern BOOL PRV_DeleteMapIDNode(LPDPLOBBYI_DPLOBJECT, DWORD);

// server.c
extern HRESULT PRV_LoadSP(LPDPLOBBYI_DPLOBJECT, LPGUID, LPVOID, DWORD);
extern BOOL FAR PASCAL PRV_FindLPGUIDInAddressCallback(REFGUID, DWORD,
							LPCVOID, LPVOID);

// session.c
extern HRESULT DPLAPI PRV_Close(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_EnumSessions(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, DWORD);
extern HRESULT DPLAPI PRV_GetSessionDesc(LPDPLOBBYI_DPLOBJECT);
extern HRESULT DPLAPI PRV_Open(LPDPLOBBYI_DPLOBJECT, LPDPSESSIONDESC2, DWORD, LPCDPCREDENTIALS);
extern HRESULT DPLAPI PRV_SetSessionDesc(LPDPLOBBYI_DPLOBJECT);

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLOBBYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplobpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplobpr.h
 *  Content:	DirectPlayLobby private header file
 *  History:
 *	Date		By		Reason
 *	====		==		======
 *	4/13/96		myronth	created it
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	10/23/96	myronth	added client/server methods
 *	11/20/96	myronth	Added Implemented Logon/LogoffServer
 *	12/12/96	myronth	Added validation macros for DPSESSIONDESC2 and DPNAME
 *	1/2/97		myronth	Added wrappers for CreateAddress and EnumAddress
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	Added LP node stuff, initial async enumsessions
 *	3/13/97		myronth	Changed reg key, other bug fixes
 *	3/17/97		myronth	Added ID map table to lobby object
 *	3/21/97		myronth	Removed unnecessary response function prototypes
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	3/31/97		myronth	Removed dead code, Added IDPLobbySP methods
 *	4/3/97		myronth	Added dplaypr.h dependency, removed dplayi.h dep,
 *						Removed all duplicated code with dplaypr.h, cleaned
 *						up a bunch of dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names
 *	5/8/97		myronth	Added packed connection header, subgroup function
 *						prototypes
 *	5/12/97		myronth	Added lobby system player
 *	5/17/97		myronth	SendChatMessage function prototype for IDPLobbySP
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup
 *	5/20/97		myronth	Added PRV_DeleteRemotePlayerFromGroup prototype
 *	5/22/97		myronth	Added DPLP_DestroyGroup prototype
 *	6/3/97		myronth	Added PRV_DestroySubgroups and PRV_RemoveSubgroups-
 *						AndPlayersFromGroup function prototypes
 *	6/6/97		myronth	Added prototypes for PRV_DestroyGroupAndParents and
 *						PRV_DeleteRemoteGroupFromGroup
 *	6/16/97		myronth	Added prototype for PRV_SendDeleteShortcutMessage-
 *						ForExitingGroup
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance to GameNode struct, added internal
 *						flad indicating we slammed this guid in a request
 *	8/22/97		myronth	Added Desciptions & flags to LSPNODE structure
 *	9/29/97		myronth	Added prototypes for PRV_SendName/DataChangedMessageLocally
 *	10/7/97		myronth	Added LP version to lobby struct
 *	10/23/97	myronth	Added lpStopParent group parameter to DeleteGroupAndParents
 *						and DeleteRemoteGroupFromGroup (#12885)
 *	10/29/97	myronth	Changed and added internal prototypes for group owners
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added stuff for asynchronous Connect (#12541)
 *	12/2/97		myronth	Added IDPLobby3 interface, Register/UnregisterApp
 *	12/4/97		myronth	Added ConnectEx
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *	1/25/98		sohailm	Added #define for CSTR_EQUAL (we define it if it's not already defined)
 *	6/25/98		a-peterz Added DPL_A_ConnectEx
 *  10/22/99	aarono  added support for application flags
 *  02/08/00    aarono  added pid to ipc struct to allow monitoring by app.
 ***************************************************************************/
#ifndef __DPLOBPR_INCLUDED__
#define __DPLOBPR_INCLUDED__

#include <windows.h>
#include "dpmem.h"
#include "dpf.h"
#include "dplobby.h"
#include "dpneed.h"
#include "dpos.h"
#include "lobbysp.h"
#include "dplaypr.h"
#include "dpmess.h"

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKS;
typedef DIRECTPLAYLOBBYCALLBACKS * LPDIRECTPLAYLOBBYCALLBACKS;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobbyVtbl DIRECTPLAYLOBBYCALLBACKSA;
typedef DIRECTPLAYLOBBYCALLBACKSA * LPDIRECTPLAYLOBBYCALLBACKSA;

typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2;
typedef DIRECTPLAYLOBBYCALLBACKS2 * LPDIRECTPLAYLOBBYCALLBACKS2;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby2Vtbl DIRECTPLAYLOBBYCALLBACKS2A;
typedef DIRECTPLAYLOBBYCALLBACKS2A * LPDIRECTPLAYLOBBYCALLBACKS2A;

typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3;
typedef DIRECTPLAYLOBBYCALLBACKS3 * LPDIRECTPLAYLOBBYCALLBACKS3;
// Right now the ASCII Vtbl is the same (by definition), but we may need
// to change it in the future, so let's use this structure
typedef struct IDirectPlayLobby3Vtbl DIRECTPLAYLOBBYCALLBACKS3A;
typedef DIRECTPLAYLOBBYCALLBACKS3A * LPDIRECTPLAYLOBBYCALLBACKS3A;

typedef struct IDPLobbySPVtbl DIRECTPLAYLOBBYSPCALLBACKS;
typedef DIRECTPLAYLOBBYSPCALLBACKS * LPDIRECTPLAYLOBBYSPCALLBACKS;

//--------------------------------------------------------------------------
//
//	DPLobby SP Node stuff
//
//--------------------------------------------------------------------------

//	DirectPlay Service Provider for DPLobby
//	{4AF206E0-9712-11cf-A021-00AA006157AC}
DEFINE_GUID(GUID_DirectPlaySP, 0x4af206e0, 0x9712, 0x11cf, 0xa0, 0x21, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);

// This is where the service provider info read from
// the registry is kept
typedef struct LSPNODE
{
	LPWSTR		lpwszName;
	LPWSTR		lpwszPath;
	GUID		guid;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpwszDesc;
	struct LSPNODE * lpNext;
} LSPNODE, * LPLSPNODE;

#define LSPNODE_DESCRIPTION		(0x00000001)
#define LSPNODE_PRIVATE			(0x00000002)

//--------------------------------------------------------------------------
//
//	DirectPlayLobby Stuff
//
//--------------------------------------------------------------------------

// Forward declarations for pointers to these two structs
typedef struct DPLOBBYI_INTERFACE * LPDPLOBBYI_INTERFACE;
typedef struct DPLOBBYI_DPLOBJECT * LPDPLOBBYI_DPLOBJECT;

// This is a structure represent each interface on our DPLobby object
typedef struct DPLOBBYI_INTERFACE
{
// REVIEW!!!! -- Why isn't this strongly typed????
//	LPDIRECTPLAYLOBBYCALLBACKS	lpVtbl;
	LPVOID						lpVtbl;
	LPDPLOBBYI_DPLOBJECT		lpDPLobby;
	LPDPLOBBYI_INTERFACE		lpNextInterface;	// Next interface on DPLobby object
	DWORD 						dwIntRefCnt;		// Ref count for this interface
} DPLOBBYI_INTERFACE;

// This structure represents a message node for messages sent between the
// lobby client & the game using Send/ReceiveLobbyMessage
typedef struct DPLOBBYI_MESSAGE
{
	DWORD		dwFlags;				// Flags pertinent to the data in the message
	DWORD		dwSize;					// Size of the data
	LPVOID		lpData;					// Pointer to the data
	struct DPLOBBYI_MESSAGE * lpPrev;	// Pointer to the previous message
	struct DPLOBBYI_MESSAGE * lpNext;	// Pointer to the next message
} DPLOBBYI_MESSAGE, * LPDPLOBBYI_MESSAGE;

// This represents an entry in our ID map table
typedef struct DPLOBBYI_MAPIDNODE
{
	DWORD		dwLobbyID;
	DPID		dpid;
} DPLOBBYI_MAPIDNODE, * LPDPLOBBYI_MAPIDNODE;

// This structure represents each game launched by the lobby client
typedef struct DPLOBBYI_GAMENODE
{
	DWORD		dwSize;					// Size of this structure
	DWORD		dwFlags;				// Flags relevant to the GameNode
	DWORD		dwGameProcessID;		// Process ID of Game spun off (in lobbyclient)
	HANDLE		hGameProcess;			// Process Hande for the Game spun off (in lobbyclient)
	DWORD		dwLobbyClientProcessID; // Process ID of lobby client (in a game)
	HANDLE      hLobbyClientProcess;    // Process Handle for the client (in a game)
	GUID        guidIPC;                // IPC guid for handling ripple launch case
	HANDLE		hTerminateThread;		// Handle to the Terminate monitor thread
	HANDLE		hKillTermThreadEvent;	// Handle of an event used to kill the monitor thread
	DPLOBBYI_MESSAGE	MessageHead;	// Message queue head
	DWORD		dwMessageCount;			// Count of messages in the queue

	// Connection settings shared memory buffer related stuff	
	HANDLE		hConnectDataMutex;		// Mutex for write access to connect data buffer
	HANDLE		hConnectDataFile;		// File handle for game data buffer
	LPVOID		lpConnectDataBuffer;	// Pointer to game data buffer	

	// Game settings shared memory buffer related stuff	
	HANDLE		hGameWriteFile;			// File handle for game write buffer
	LPVOID		lpGameWriteBuffer;		// Pointer to game write buffer	
	HANDLE		hGameWriteEvent;		// Handle to GameWriteEvent
	HANDLE		hGameWriteMutex;		// Handle to GameWrite Mutex

	HANDLE		hLobbyWriteFile;		// File handle for lobby write buffer
	LPVOID		lpLobbyWriteBuffer;		// Pointer to lobby write buffer	
	HANDLE		hLobbyWriteEvent;		// Handle to LobbyWrite Event
	HANDLE		hLobbyWriteMutex;		// Handle to LobbyWrite Mutex

	HANDLE		hReceiveThread;			// Handle to the Receive thread
	HANDLE		hDupReceiveEvent;		// Duplicate Handle of Caller's Event
	HANDLE		hKillReceiveThreadEvent;// Handle of an event used to kill receive thread

	LPDPLOBBYI_DPLOBJECT	this;		// Back pointer to the DPLobby object
	struct DPLOBBYI_GAMENODE * lpgnNext;// Pointer to the next GameNode in the list

	// Pointer to the dplay object which has a connection to the lobby server
	// and the ID of the player that received the start session message
	LPDPLAYI_DPLAY	lpDPlayObject;
	DPID			dpidPlayer;
	GUID			guidInstance;		// Instance guid for the game

} DPLOBBYI_GAMENODE, *LPDPLOBBYI_GAMENODE;

// This is used to keep track of Property requests made via SendLobbyMessage
typedef struct DPLOBBYI_REQUESTNODE
{
	DWORD		dwFlags;					// GN_* flags
	DWORD		dwRequestID;				// Internal Request ID
	DWORD		dwAppRequestID;				// Request ID passed in by the app
	LPDPLOBBYI_GAMENODE	lpgn;				// Pointer to a Game Node
	struct DPLOBBYI_REQUESTNODE * lpPrev;	// Pointer to the previous request node
	struct DPLOBBYI_REQUESTNODE * lpNext;	// Pointer to the next request node

} DPLOBBYI_REQUESTNODE, * LPDPLOBBYI_REQUESTNODE;

// This is the DirectPlayLobby object
typedef struct DPLOBBYI_DPLOBJECT
{
	DWORD						dwSize;				// Size of this structure
	LPDPLOBBYI_INTERFACE		lpInterfaces;		// List of interface on this object
    DWORD						dwRefCnt;			// Reference Count for the object
    DWORD						dwFlags;			// DPLOBBYPR_xxx
	HINSTANCE					hInstanceLP;		// Lobby Provider DLL's hInstance
    LPSP_CALLBACKS				pcbSPCallbacks;		// SP entry points
	LPVOID						lpSPData;			// SP-specific blob storage
	LPDPLOBBYI_GAMENODE			lpgnHead;			// Head node for all launched games

	LPDPLAYI_DPLAY				lpDPlayObject;		// Back pointer to aggregate DPlay object
	LPDPLOBBYI_MAPIDNODE		lpMap;				// Pointer to the ID map table
	DWORD						dwTotalMapEntries;	// Number of total entries in the map table
	DWORD						dwMapEntries;		// Number of used entries in the map table
	DPID						dpidSysPlayer;		// ID of the lobby's system player

	LPDPLOBBYI_REQUESTNODE		lprnHead;			// Head node for all property requests
	DWORD						dwCurrentRequest;	// ID of the next request

	DWORD						dwLPVersion;		// Version of the lobby provider

	LPDIRECTPLAY2				lpDP2;				// DPlay2 interface pointer used by async DP_Connect
	LPDPLCONNECTION				lpConn;				// DPLCONNECTION pointer used by async DP_Connect
} DPLOBBYI_DPLOBJECT;

typedef struct DPLOBBYI_BUFFERCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwReadOffset;	// Offset of the read cursor (relative to this structure)
	DWORD		dwWriteOffset;	// Offset of the write cursor (relative to this structure)
	DWORD		dwFlags;		// Flags for this buffer
	DWORD		dwMessages;		// Number of messages in the buffer
	DWORD		dwBufferSize;	// Size of the entire buffer
	DWORD		dwBufferLeft;	// Number of free bytes left in the buffer
} DPLOBBYI_BUFFERCONTROL, * LPDPLOBBYI_BUFFERCONTROL;

typedef struct DPLOBBYI_CONNCONTROL
{
	DWORD		dwToken;		// Set by the lobby client
	DWORD		dwFlags;		// Flags for this buffer
	DWORD		CliProcId;		// Lobby client's process Id so we can see if it crashes.
} DPLOBBYI_CONNCONTROL, * LPDPLOBBYI_CONNCONTROL;

typedef struct DPLOBBYI_MESSAGEHEADER
{
	DWORD		dwSize;
	DWORD		dwFlags;
} DPLOBBYI_MESSAGEHEADER, * LPDPLOBBYI_MESSAGEHEADER;

typedef struct DPLOBBYI_PACKEDCONNHEADER
{
	DWORD		dwUnicodeSize;
	DWORD		dwAnsiSize;
} DPLOBBYI_PACKEDCONNHEADER, * LPDPLOBBYI_PACKEDCONNHEADER;

typedef struct CONNECTINFO
{
	GUID		guidApplication;
	GUID        guidIPC;
	LPWSTR		lpszName;
	LPWSTR		lpszFile;
	LPWSTR		lpszPath;
	LPWSTR		lpszCommandLine;
	LPWSTR		lpszCurrentDir;
	LPWSTR      lpszAppLauncherName;
} CONNECTINFO, * LPCONNECTINFO;

// This is used for messaging during the StartGame method
typedef struct DPLOBBYI_STARTGAME
{
	DWORD		dwFlags;
	HRESULT		hr;
} DPLOBBYI_STARTGAME, * LPDPLOBBYI_STARTGAME;

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// These two entries are only used by dplos.c.  They can be removed if we
// generalize these functions between DPlay & DPLobby
#define DPLAY_MAX_FILENAMELEN	512
#define DPLOBBY_DEFAULT_CHAR	"-"

#define DPLOBBYPR_DEFAULTMAPENTRIES		100

#define DPLOBBYPR_SIZE_HANDLEMESSAGE_DX50	20

// Note, the 'L' Macro makes these strings Unicode (the TEXT macro uses L also)
#define SZ_DPLAY_APPS_KEY	L"Software\\Microsoft\\DirectPlay\\Applications"
#define SZ_DPLAY_SP_KEY		L"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_DPLOBBY_SP_KEY	L"Software\\Microsoft\\DirectPlay\\Lobby Providers"
#define SZ_ADDRESS_TYPES	L"Address Types"
#define SZ_GUID				L"Guid"
#define SZ_PATH				L"Path"
#define SZ_DESCRIPTIONA		L"DescriptionA"
#define SZ_DESCRIPTIONW		L"DescriptionW"
#define SZ_PRIVATE			L"Private"
#define SZ_FILE				L"File"
#define SZ_LAUNCHER         L"Launcher"
#define SZ_MAJORVERSION		L"Major Version"
#define SZ_MINORVERSION		L"Minor Version"
#define SZ_DWRESERVED1		L"dwReserved1"
#define SZ_DWRESERVED2		L"dwReserved2"
#define SZ_COMMANDLINE		L"CommandLine"
#define SZ_CURRENTDIR		L"CurrentDirectory"
#define SZ_BACKSLASH		L"\\"
#define SZ_SPACE			L" "
#define SZ_SP_FOR_DPLAY		L"dpldplay.dll"
#define SZ_DP_IPC_GUID      L"/dplay_ipc_guid:"
#define SZ_GUID_PROTOTYPE   L"{01020304-0506-0708-090A-0B0C0D0E0F10}"
#define SZ_DWFLAGS          L"dwFlags"

// The following #defines are all for the shared buffers and control
// elements used by the lobby methods for communication between
// a lobby client and a game
#define MAX_PID_LENGTH				(10)
#define	MAX_MMFILENAME_LENGTH		(_MAX_FNAME + MAX_PID_LENGTH)
#define SZ_FILENAME_BASE			L"DPLobby"
#define SZ_CONNECT_DATA_FILE		L"ConnectDataSharedMemory"
#define SZ_CONNECT_DATA_MUTEX		L"ConnectDataMutex"
#define SZ_GAME_WRITE_FILE			L"GameWriteSharedMemory"
#define SZ_GAME_WRITE_EVENT			L"GameWriteEvent"
#define SZ_GAME_WRITE_MUTEX			L"GameWriteMutex"
#define SZ_LOBBY_WRITE_FILE			L"LobbyWriteSharedMemory"
#define SZ_LOBBY_WRITE_EVENT		L"LobbyWriteEvent"
#define SZ_LOBBY_WRITE_MUTEX		L"LobbyWriteMutex"
#define SZ_NAME_TEMPLATE			L"%s-%s-%u"
#define SZ_GUID_NAME_TEMPLATE       L"%s-%s-"

#define TYPE_CONNECT_DATA_FILE		1
#define TYPE_CONNECT_DATA_MUTEX		2
#define TYPE_GAME_WRITE_FILE		3
#define TYPE_LOBBY_WRITE_FILE		4
#define TYPE_LOBBY_WRITE_EVENT		5
#define TYPE_GAME_WRITE_EVENT		7
#define TYPE_LOBBY_WRITE_MUTEX		9
#define TYPE_GAME_WRITE_MUTEX		10



// If this flag is set, the Lobby object has been registered with a lobby
// server.  Some methods require the client to be registered.
#define DPLOBBYPR_REGISTERED			0x00000010

// If this flag is set, we have allocated an IDPLobbySP interface
#define DPLOBBYPR_SPINTERFACE			0x00000020

// If this flag is set, the app has called Connect with the async flag
#define DPLOBBYPR_ASYNCCONNECT			0x00000040

// Message flags
#define DPLOBBYPR_MESSAGE_SYSTEM		0x00000001
#define DPLOBBYPR_INTERNALMESSAGEFLAGS	(0x00000000) // This will change

// HRESULT used by EnumLocalApplication to denote a callback return of
// FALSE (internally, of course)
#define DPLOBBYPR_CALLBACKSTOP			(HRESULT) (0xFFFFFFFF)

// Transport Flags
#define DPLOBBYPR_DPLAYSP				(0x00000001)

// Default Timeout value (15 seconds)
#define DPLOBBYPR_DEFAULTTIMEOUT		(15000)

//
// GameNode Flags
//
// If this flag is set, the calling application is a lobby client and not
// a game.  The user shouldn't even set this, but we should be able to
// figure it out from the connection method.  Use this flag to distinguish
// when to "Create" the memory-mapped files, or when to "Open" them.
#define GN_LOBBY_CLIENT					(0x00000001)

// The memory mapped files are available and ready for use
#define GN_SHARED_MEMORY_AVAILABLE		(0x00000002)

// Used to denote when an application's process has gone away.
#define GN_DEAD_GAME_NODE				(0x00000004)

// These two flags determine whether the game was lobby client launched or
// self-lobbied.  If neither of these are set, the game was lobby client
// launched, and the flag is set on the lobby client side (not on the game side)
#define GN_CLIENT_LAUNCHED				(0x00000008)
#define GN_SELF_LOBBIED					(0x00000010)

// This flag is used to identify whether the guidInstance for the game
// was exchanged for GUID_NULL in the guidPlayer field of a Get/SetProperty
// lobby system message.
#define GN_SLAMMED_GUID					(0x00000020)

// This flag is set when the guidIPC field of the game node has been set
// either because we are a lobby client that ripple launched or it was
// on the application's command line.
#define GN_IPCGUID_SET					(0x00000040)
//
// BufferControl Flags
//
// Flags used by the dwFlags member of the BUFFERCONTROL struct
#define BC_LOBBY_ACTIVE					(0x00000001)
#define BC_GAME_ACTIVE					(0x00000002)
#define BC_WAIT_MODE					(0x00000004)
#define BC_PENDING_CONNECT				(0x00000008)

#define BC_TOKEN						(0xFEEDFACE)

#ifndef CSTR_EQUAL
#define CSTR_EQUAL	2
#endif

//--------------------------------------------------------------------------
//
//	Globals
//
//--------------------------------------------------------------------------

// The vtable!
extern DIRECTPLAYLOBBYCALLBACKS		dplCallbacks;
extern DIRECTPLAYLOBBYCALLBACKSA	dplCallbacksA;
extern DIRECTPLAYLOBBYCALLBACKS2	dplCallbacks2;
extern DIRECTPLAYLOBBYCALLBACKS2A	dplCallbacks2A;
extern DIRECTPLAYLOBBYCALLBACKS3	dplCallbacks3;
extern DIRECTPLAYLOBBYCALLBACKS3A	dplCallbacks3A;
extern DIRECTPLAYLOBBYSPCALLBACKS	dplCallbacksSP;

//--------------------------------------------------------------------------
//
//	Macros, etc.
//
//--------------------------------------------------------------------------

// Our own hard-coded break
#define DEBUGBREAK() _asm { int 3 }

#define DPLOBJECT_FROM_INTERFACE(ptr) (((LPDPLOBBYI_INTERFACE)ptr)->lpDPLobby)

#define DPLOBBY_REGISTRY_NAMELEN	512

// Crit section
extern LPCRITICAL_SECTION gpcsDPLCritSection;		// defined in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLQueueCritSection;	// also in dllmain.c
extern LPCRITICAL_SECTION gpcsDPLGameNodeCritSection;	// also in dllmain.c


// Validation macros
#define VALID_DPLOBBY_INTERFACE( ptr ) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_INTERFACE)) && \
        ((((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksA) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks2A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacks3A) || \
        (((LPDPLOBBYI_INTERFACE)ptr)->lpVtbl == &dplCallbacksSP)))

#define VALID_DPLOBBY_PTR(ptr) \
        (!IsBadWritePtr(ptr, sizeof(DPLOBBYI_DPLOBJECT)) && \
        (ptr->dwSize == sizeof(DPLOBBYI_DPLOBJECT)))

#define VALID_UUID_PTR(ptr) \
        (ptr && !IsBadWritePtr( ptr, sizeof(UUID)))

#define VALID_READ_UUID_PTR(ptr) \
        (ptr && !IsBadReadPtr( ptr, sizeof(UUID)))

#define VALID_DPLOBBY_CONNECTION( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLCONNECTION)) && \
        (ptr->dwSize == sizeof(DPLCONNECTION)))

#define VALID_DPLOBBY_APPLICATIONDESC( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC)))

#define VALID_DPLOBBY_APPLICATIONDESC2( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPAPPLICATIONDESC2)) && \
        (ptr->dwSize == sizeof(DPAPPLICATIONDESC2)))

#define IS_DPLOBBY_APPLICATIONDESC2(ptr) \
		(ptr->dwSize == sizeof(DPAPPLICATIONDESC2))

#define VALID_DPLOGONINFO( ptr ) \
		(!IsBadWritePtr(ptr, sizeof(DPLOGONINFO)) && \
        (ptr->dwSize == sizeof(DPLOGONINFO)))

#define VALID_DPLOBBY_SP_LOADED( ptr ) \
		(ptr->pcbSPCallbacks)

#define VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLMSG_STANDARD) \
		) )

#define VALID_WAIT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLWAIT_CANCEL) \
		) )

#define VALID_REGISTERAPP_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPLAPP_NOENUM | \
                    DPLAPP_AUTOVOICE  | \
                    DPLAPP_SELFVOICE ) \
		) )


#define IS_GAME_DEAD(lpgn) \
		(lpgn->dwFlags & GN_DEAD_GAME_NODE)

#define CALLBACK_EXISTS(fn)	(((LPSP_CALLBACKS)this->pcbSPCallbacks)->fn)

#define CALL_LP(ptr,fn,pdata) (((LPSP_CALLBACKS)ptr->pcbSPCallbacks)->fn(pdata))

#define DPLAPI WINAPI

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// convert.c
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION, LPDPLCONNECTION *);

// dplunk.c
extern HRESULT 	DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY,
								REFIID riid, LPVOID * ppvObj);
extern ULONG	DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY);  
extern ULONG 	DPLAPI DPL_Release(LPDIRECTPLAYLOBBY); 

LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT);
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_INTERFACE *, LPVOID);

// dplgame.c
extern HRESULT	DPLAPI DPL_RunApplication(LPDIRECTPLAYLOBBY, DWORD,
						LPDWORD, LPDPLCONNECTION, HANDLE);

BOOL PRV_FindGameInRegistry(LPGUID, LPWSTR, DWORD, HKEY *);

// dplenum.c
extern HRESULT	DPLAPI DPL_EnumLocalApplications(LPDIRECTPLAYLOBBY,
					LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_EnumAddressTypes(LPDIRECTPLAYLOBBY,
					LPDPLENUMADDRESSTYPESCALLBACK, REFGUID, LPVOID, DWORD);
HRESULT PRV_EnumLocalApplications(LPDIRECTPLAYLOBBY,
				LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD, BOOL);

// dplobby.c
extern HRESULT	DPLAPI DPL_Connect(LPDIRECTPLAYLOBBY, DWORD, LPDIRECTPLAY2 *,
						IUnknown FAR *);
extern HRESULT DPLAPI DPL_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_CreateAddress(LPDIRECTPLAYLOBBY pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_CreateCompoundAddress(LPDIRECTPLAYLOBBY pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPLAPI DPL_EnumAddress(LPDIRECTPLAYLOBBY pISP,
					LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
					LPVOID lpContext);
extern HRESULT DPLAPI DPL_RegisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, LPVOID lpvDesc);
extern HRESULT DPLAPI DPL_UnregisterApplication(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, REFGUID lpguid);

HRESULT PRV_WriteAppDescInRegistryAnsi(LPDPAPPLICATIONDESC);
HRESULT PRV_WriteAppDescInRegistryUnicode(LPDPAPPLICATIONDESC);

// dplobbya.c	(Ansi entry points)
extern HRESULT	DPLAPI DPL_A_Connect(LPDIRECTPLAYLOBBY, DWORD,
				LPDIRECTPLAY2 *, IUnknown FAR *);
extern HRESULT DPLAPI DPL_A_ConnectEx(LPDIRECTPLAYLOBBY, DWORD, REFIID,
					LPVOID *, IUnknown FAR *);
extern HRESULT	DPLAPI DPL_A_EnumLocalApplications(LPDIRECTPLAYLOBBY,
						LPDPLENUMLOCALAPPLICATIONSCALLBACK, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_A_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT DPLAPI DPL_A_RegisterApplication(LPDIRECTPLAYLOBBY,
				DWORD, LPVOID);
extern HRESULT	DPLAPI DPL_A_RunApplication(LPDIRECTPLAYLOBBY,	DWORD, LPDWORD,
						LPDPLCONNECTION, HANDLE);
extern HRESULT	DPLAPI DPL_A_SetConnectionSettings(LPDIRECTPLAYLOBBY,
						DWORD, DWORD, LPDPLCONNECTION);

// dplpack.c
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION, LPDWORD, LPDWORD);
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION, LPVOID, BOOL);
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID, LPVOID);
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID, LPVOID);
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION, BOOL);
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC, BOOL);
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC,
		LPDPAPPLICATIONDESC *);
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC);

// dplshare.c
extern HRESULT	DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDWORD, LPVOID, LPDWORD);
extern HRESULT	DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPVOID, DWORD);
extern HRESULT	DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, LPDPLCONNECTION);
extern HRESULT	DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY, DWORD,
						DWORD, HANDLE);
extern HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY, DWORD);

HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE, DWORD, LPWSTR);
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_GAMENODE *,
						DWORD, HANDLE, BOOL, LPGUID);
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE, LPDPLCONNECTION, BOOL);
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE);
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE);
HANDLE PRV_DuplicateHandle(HANDLE);
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID);
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID);
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, LPVOID,
						LPDWORD, BOOL);
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY, DWORD, DWORD,
						LPDPLCONNECTION);
void PRV_KillThread(HANDLE, HANDLE);
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD, BOOL);
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE, DWORD, LPVOID, DWORD); 
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT, LPDPLOBBYI_REQUESTNODE);

// dplsp.c
extern HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEGROUPTOGROUP);
extern HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP, LPSPDATA_ADDREMOTEPLAYERTOGROUP);
extern HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUP);
extern HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP, LPSPDATA_CREATEREMOTEGROUPINGROUP);
extern HRESULT DPLAPI DPLP_DeleteGroupFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEGROUPFROMGROUP);
extern HRESULT DPLAPI DPLP_DeletePlayerFromGroup(LPDPLOBBYSP, LPSPDATA_DELETEREMOTEPLAYERFROMGROUP);
extern HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
extern HRESULT DPLAPI DPLP_GetSPDataPointer(LPDPLOBBYSP, LPVOID *);
extern HRESULT DPLAPI DPLP_HandleMessage(LPDPLOBBYSP, LPSPDATA_HANDLEMESSAGE);
extern HRESULT DPLAPI DPLP_SendChatMessage(LPDPLOBBYSP, LPSPDATA_CHATMESSAGE);
extern HRESULT DPLAPI DPLP_SetGroupName(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPNAME);
extern HRESULT DPLAPI DPLP_SetGroupOwner(LPDPLOBBYSP, LPSPDATA_SETREMOTEGROUPOWNER);
extern HRESULT DPLAPI DPLP_SetPlayerName(LPDPLOBBYSP, LPSPDATA_SETREMOTEPLAYERNAME);
extern HRESULT DPLAPI DPLP_SetSessionDesc(LPDPLOBBYSP, LPSPDATA_SETSESSIONDESC);
extern HRESULT DPLAPI DPLP_SetSPDataPointer(LPDPLOBBYSP, LPVOID);
extern HRESULT DPLAPI DPLP_StartSession(LPDPLOBBYSP, LPSPDATA_STARTSESSIONCOMMAND);

HRESULT DPLAPI PRV_BroadcastDestroyGroupMessage(LPDPLOBBYI_DPLOBJECT, DPID);
HRESULT PRV_DeleteRemotePlayerFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEPLAYERFROMGROUP, BOOL);
HRESULT DPLAPI DPLP_DestroyGroup(LPDPLOBBYSP, LPSPDATA_DESTROYREMOTEGROUP);
void PRV_RemoveSubgroupsAndPlayersFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPDPLAYI_GROUP, DWORD, BOOL);
HRESULT PRV_DeleteRemoteGroupFromGroup(LPDPLOBBYI_DPLOBJECT,
		LPSPDATA_DELETEREMOTEGROUPFROMGROUP, BOOL, LPDPLAYI_GROUP);
void PRV_SendDeleteShortcutMessageForExitingGroup(LPDPLOBBYI_DPLOBJECT,	LPDPLAYI_GROUP);
HRESULT PRV_SendDataChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPVOID, DWORD);
HRESULT PRV_SendNameChangedMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, LPDPNAME, BOOL);
HRESULT PRV_SendGroupOwnerMessageLocally(LPDPLOBBYI_DPLOBJECT, DPID, DPID, DPID);

// group.c
extern HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPVOID, LPDWORD);
extern HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY, DWORD, DPID,
							LPDPLCONNECTION, BOOL);
extern HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, LPVOID, DWORD, DWORD, DWORD, DPID, DWORD);

void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, BOOL);
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT, LPDPLAYI_GROUP, LPDPLAYI_GROUP);

// player.c
extern HRESULT PRV_GrowMapTable(LPDPLOBBYI_DPLOBJECT);
extern HRESULT PRV_CreateAndMapNewPlayer(LPDPLOBBYI_DPLOBJECT,
			DPID *, LPDPNAME, HANDLE, LPVOID, DWORD, DWORD, DWORD, BOOL);
extern BOOL IsValidLobbyID(DWORD);
extern BOOL IsLobbyIDInMapTable(LPDPLOBBYI_DPLOBJECT, DWORD);

// session.c
extern HRESULT DPLAPI DPLP_EnumSessionsResponse(LPDPLOBBYSP, LPSPDATA_ENUMSESSIONSRESPONSE);


// api.c (in the dplay project)
HRESULT TimeBomb();
HRESULT ConnectMe(LPDIRECTPLAYLOBBY, LPDIRECTPLAY2 FAR *, IUnknown FAR *, DWORD); 

// SECURITY, memcpy that verifies dest bounds before executing, 
// on fail dispatches to label, logs specified string.
#define memcpySecureD(dest,src,len,pBuf,cbBuf,error,action,exit)        \
			if(((LPBYTE)(dest)) > (((LPBYTE)pBuf) + cbBuf)	|| 		\
				((LPBYTE)(dest)) < ((LPBYTE)(pBuf)) 		 	|| 		\
				(((LPBYTE)(dest)+len) > (((LPBYTE)pBuf) + cbBuf)) )	\
			{															\
				DPF(4,error);											\
				action;													\
				goto exit;												\
			} else {													\
				memcpy(dest,src,len);									\
			}

// SECURITY, memcpy that verifies src bounds before executing, 
// on fail dispatches to label, logs specified string.
#define memcpySecureS(dest,src,len,pBuf,cbBuf,error,action,exit)        \
			if(((LPBYTE)(src)) > (((LPBYTE)pBuf) + cbBuf)	|| 		\
				((LPBYTE)(src)) < ((LPBYTE)(pBuf)) 		 	|| 		\
				(((LPBYTE)(src)+len) > (((LPBYTE)pBuf) + cbBuf)) )	\
			{															\
				DPF(4,error);											\
				action;													\
				goto exit;												\
			} else {													\
				memcpy(dest,src,len);									\
			}

//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

#define MAX_APPDATABUFFERSIZE		(65535)
#define APPDATA_RESERVEDSIZE		(2 * sizeof(DWORD))



#endif // __DPLOBPR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplshare.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplshare.c
 *  Content:	Methods for shared buffer management
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/18/96		myronth	Created it
 *	12/12/96	myronth	Fixed DPLCONNECTION validation & bug #4692
 *	12/13/96	myronth	Fixed bugs #4697 and #4607
 *	2/12/97		myronth	Mass DX5 changes
 *	2/20/97		myronth	Changed buffer R/W to be circular
 *	3/12/97		myronth	Kill thread timeout, DPF error levels
 *	4/1/97		myronth	Fixed handle leak -- bug #7054
 *	5/8/97		myronth	Added bHeader parameter to packing function
 *  5/21/97		ajayj	DPL_SendLobbyMessage - allow DPLMSG_STANDARD flag #8929
 *	5/30/97		myronth	Fixed SetConnectionSettings for invalid AppID (#9110)
 *						Fixed SetLobbyMessageEvent for invalid handle (#9111)
 *	6/19/97		myronth	Fixed handle leak (#10063)
 *	7/30/97		myronth	Added support for standard lobby messaging and
 *						fixed receive loop race condition (#10843)
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Support for DPLMSG_NEWSESSIONHOST
 *	8/19/97		myronth	Removed dead PRV_SendStandardSystemMessageByObject
 *	8/20/97		myronth	Added DPLMSG_STANDARD to all standard messages
 *	11/13/97	myronth	Added guidInstance to lobby system message (#10944)
 *	12/2/97		myronth	Fixed swallowed error code, moved structure
 *						validation for DPLCONNECTION (#15527, 15529)
 *	1/20/98		myronth	Added WaitForConnectionSettings
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *	10/31/99	aarono add node lock when to SetLobbyMessageEvent
 *			       NTB#411892
 *  02/08/00    aarono  added monitoring for lobby client crash/exit, notify
 *                        lobbied application, Mill B#131938
 *  7/12/00     aarono  fix GUIDs for IPC to be fully significant, otherwise won't IPC.
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Debug Functions
//
//--------------------------------------------------------------------------
#ifdef DEBUG

DPF_DUMPWSTR(int level, LPWSTR lpwStr)
{
	char lpszStr[200];
	WideToAnsi(lpszStr,lpwStr,200);
	DPF(level, lpszStr);
}
#else 
#define DPF_DUMPWSTR(a,b)
#endif

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

HRESULT PRV_ReadCommandLineIPCGuid(GUID *lpguidIPC)
{
	LPWSTR  pwszCommandLine;
	LPWSTR  pwszAlloc=NULL;
	LPWSTR  pwszSwitch=NULL;
	HRESULT hr=DP_OK;
	
	if(!OS_IsPlatformUnicode())
	{
		// if we get a command line in ANSI, convert to UNICODE, this allows
		// us to avoid the DBCS issues in ANSI while scanning for the IPC GUID
		LPSTR pszCommandLine;

		pszCommandLine=(LPSTR)GetCommandLineA();
		pwszAlloc=DPMEM_ALLOC(MAX_PATH*sizeof(WCHAR));
		if (pwszAlloc == NULL)
		{
			goto exit;
		}
		hr=AnsiToWide(pwszAlloc,pszCommandLine,MAX_PATH);
		if(FAILED(hr))
		{
			goto exit;
		}
		pwszCommandLine=pwszAlloc;
	}
	else
	{
		pwszCommandLine=(LPWSTR)GetCommandLine(); 
	}

	// pwszCommandLine now points to the UNICODE command line.
	if(pwszSwitch=OS_StrStr(pwszCommandLine,SZ_DP_IPC_GUID)){
		// found the GUID on the command line
		if (OS_StrLen(pwszSwitch) >= (sizeof(SZ_DP_IPC_GUID)+sizeof(SZ_GUID_PROTOTYPE)-sizeof(WCHAR))/sizeof(WCHAR)){
			// skip past the switch description to the actual GUID and extract
			hr=GUIDFromString(pwszSwitch+(sizeof(SZ_DP_IPC_GUID)/sizeof(WCHAR))-1, lpguidIPC);
		} else {
			hr=DPERR_GENERIC;
		}
	} else {
		hr=DPERR_GENERIC;
	}


exit:

	if(pwszAlloc){
		DPMEM_FREE(pwszAlloc);
	}
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInternalName"
HRESULT PRV_GetInternalName(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType, LPWSTR lpName)
{
	DWORD	pid;
	LPWSTR	lpFileName;
	LPSTR	lpstr1, lpstr2, lpstr3;
	char	szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	BOOL    bUseGuid=FALSE;


	DPF(7, "Entering PRV_GetInternalName");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x", lpgn, dwType, lpName);


	if(lpgn->dwFlags & GN_IPCGUID_SET){
		bUseGuid=TRUE;
	}
	// Get the current process ID if we are a game, otherwise, we need to
	// get the process ID of the game that we spawned
	else if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		if(lpgn->dwGameProcessID)
			pid = lpgn->dwGameProcessID;
		else
			return DPERR_APPNOTSTARTED;
	}
	else
	{
		pid = GetCurrentProcessId();
	}

	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
			lpFileName = SZ_CONNECT_DATA_FILE;
			break;

		case TYPE_CONNECT_DATA_MUTEX:
			lpFileName = SZ_CONNECT_DATA_MUTEX;
			break;

		case TYPE_GAME_WRITE_FILE:
			lpFileName = SZ_GAME_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_FILE:
			lpFileName = SZ_LOBBY_WRITE_FILE;
			break;

		case TYPE_LOBBY_WRITE_EVENT:
			lpFileName = SZ_LOBBY_WRITE_EVENT;
			break;

		case TYPE_GAME_WRITE_EVENT:
			lpFileName = SZ_GAME_WRITE_EVENT;
			break;

		case TYPE_LOBBY_WRITE_MUTEX:
			lpFileName = SZ_LOBBY_WRITE_MUTEX;
			break;

		case TYPE_GAME_WRITE_MUTEX:
			lpFileName = SZ_GAME_WRITE_MUTEX;
			break;

		default:
			DPF(2, "We got an Internal Name Type that we didn't expect!");
			return DPERR_GENERIC;
	}

	GetAnsiString(&lpstr2, SZ_FILENAME_BASE);
	GetAnsiString(&lpstr3, lpFileName);

	if(!bUseGuid){
		// REVIEW!!!! -- I can't get the Unicode version of wsprintf to work, so
		// for now, use the ANSI version and convert
		//	wsprintf(lpName, SZ_NAME_TEMPLATE, SZ_FILENAME_BASE, lpFileName, pid);
		GetAnsiString(&lpstr1, SZ_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3, pid);
	} else {
		GetAnsiString(&lpstr1, SZ_GUID_NAME_TEMPLATE);
		wsprintfA((LPSTR)szName, lpstr1, lpstr2, lpstr3);
	}

	AnsiToWide(lpName, szName, (strlen(szName) + 1));

	if(bUseGuid){
		// concatenate the guid to the name if we are using the guid.
		WCHAR *pGuid;
		pGuid = lpName + WSTRLEN(lpName) - 1;
		StringFromGUID(&lpgn->guidIPC, pGuid, GUID_STRING_SIZE);
	}

	DPF(9, "Made internal Name...");
	DPF_DUMPWSTR(9,lpName);

	if(lpstr1)
		DPMEM_FREE(lpstr1);
	if(lpstr2)
		DPMEM_FREE(lpstr2);
	if(lpstr3)
		DPMEM_FREE(lpstr3);

	return DP_OK;

} // PRV_GetInternalName



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewGameNode"
HRESULT PRV_AddNewGameNode(LPDPLOBBYI_DPLOBJECT this,
				LPDPLOBBYI_GAMENODE * lplpgn, DWORD dwGameID,
				HANDLE hGameProcess, BOOL bLobbyClient, GUID *lpguidIPC)
{
	LPDPLOBBYI_GAMENODE	lpgn;


	DPF(7, "Entering PRV_AddNewGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			this, lplpgn, dwGameID, hGameProcess, bLobbyClient);

	lpgn = DPMEM_ALLOC(sizeof(DPLOBBYI_GAMENODE));
	if(!lpgn)
	{
		DPF(2, "Unable to allocate memory for GameNode structure!");
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the GameNode
	lpgn->dwSize = sizeof(DPLOBBYI_GAMENODE);
	lpgn->dwGameProcessID = dwGameID;
	lpgn->hGameProcess = hGameProcess;
	lpgn->this = this;
	lpgn->MessageHead.lpPrev = &lpgn->MessageHead;
	lpgn->MessageHead.lpNext = &lpgn->MessageHead;

	if(lpguidIPC){
		// provided during launch by lobby client
		lpgn->guidIPC=*lpguidIPC;
		lpgn->dwFlags |= GN_IPCGUID_SET;
	} else {
		// need to extract the GUID from the command line if present.
		if(DP_OK==PRV_ReadCommandLineIPCGuid(&lpgn->guidIPC)){
			lpgn->dwFlags |= GN_IPCGUID_SET;
		}
	}

	// If we are a lobby client, set the flag
	if(bLobbyClient)
		lpgn->dwFlags |= GN_LOBBY_CLIENT;
	
	// Add the GameNode to the list
	lpgn->lpgnNext = this->lpgnHead;
	this->lpgnHead = lpgn;

	// Set the output pointer
	*lplpgn = lpgn;

	return DP_OK;

} // PRV_AddNewGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGameNode"
LPDPLOBBYI_GAMENODE PRV_GetGameNode(LPDPLOBBYI_GAMENODE lpgnHead, DWORD dwGameID)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp = lpgnHead;
	GUID guidIPC=GUID_NULL;
	BOOL bFoundGUID;

	DPF(7, "Entering PRV_GetGameNode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgnHead, dwGameID);

	if(DP_OK==PRV_ReadCommandLineIPCGuid(&guidIPC)){
		bFoundGUID=TRUE;
	} else {
		bFoundGUID=FALSE;
	}

	while(lpgnTemp)
	{
		if((lpgnTemp->dwGameProcessID == dwGameID) || 
		   ((bFoundGUID) && (lpgnTemp->dwFlags & GN_IPCGUID_SET) && (IsEqualGUID(&lpgnTemp->guidIPC,&guidIPC))))
			return lpgnTemp;
		else
			lpgnTemp = lpgnTemp->lpgnNext;
	}

	return NULL;

} // PRV_GetGameNode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupClientDataAccess"
BOOL PRV_SetupClientDataAccess(LPDPLOBBYI_GAMENODE lpgn)
{
	SECURITY_ATTRIBUTES		sa;
	HANDLE					hConnDataMutex = NULL;
	HANDLE					hLobbyWrite = NULL;
	HANDLE					hLobbyWriteMutex = NULL;
	HANDLE					hGameWrite = NULL;
	HANDLE					hGameWriteMutex = NULL;
	WCHAR					szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];


	DPF(7, "Entering PRV_SetupClientDataAccess");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Set up the security attributes (so that our objects can
	// be inheritable)
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	// Create the ConnectionData Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_CONNECT_DATA_MUTEX,
								(LPWSTR)szName)))
	{
		hConnDataMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)szName);
	}

	// Create the GameWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_EVENT, (LPWSTR)szName)))
	{
		hGameWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)szName);
	}

	// Create the GameWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_GAME_WRITE_MUTEX,
								(LPWSTR)szName)))
	{
		hGameWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)szName);
	}

	// Create the LobbyWrite Event
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_EVENT, (LPWSTR)szName)))
	{
		hLobbyWrite = OS_CreateEvent(&sa, FALSE, FALSE, (LPWSTR)szName);
	}

	// Create the LobbyWrite Mutex
	if(SUCCEEDED(PRV_GetInternalName(lpgn, TYPE_LOBBY_WRITE_MUTEX,
								(LPWSTR)szName)))
	{
		hLobbyWriteMutex = OS_CreateMutex(&sa, FALSE, (LPWSTR)szName);
	}


	// Check for errors
	if(!hConnDataMutex || !hGameWrite || !hGameWriteMutex
			|| !hLobbyWrite || !hLobbyWriteMutex)
	{
		if(hConnDataMutex)
			CloseHandle(hConnDataMutex);
		if(hGameWrite)
			CloseHandle(hGameWrite);
		if(hGameWriteMutex)
			CloseHandle(hGameWriteMutex);
		if(hLobbyWrite)
			CloseHandle(hLobbyWrite);
		if(hLobbyWriteMutex)
			CloseHandle(hLobbyWriteMutex);

		return FALSE;
	}

	// Save the handles
	lpgn->hConnectDataMutex = hConnDataMutex;
	lpgn->hGameWriteEvent = hGameWrite;
	lpgn->hGameWriteMutex = hGameWriteMutex;
	lpgn->hLobbyWriteEvent = hLobbyWrite;
	lpgn->hLobbyWriteMutex = hLobbyWriteMutex;

	return TRUE;

} // PRV_SetupClientDataAccess



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDataBuffer"
HRESULT PRV_GetDataBuffer(LPDPLOBBYI_GAMENODE lpgn, DWORD dwType,
				DWORD dwSize, LPHANDLE lphFile, LPVOID * lplpMemory)
{
	HRESULT						hr;
	SECURITY_ATTRIBUTES			sa;
	WCHAR						szName[MAX_MMFILENAME_LENGTH * sizeof(WCHAR)];
	LPVOID						lpMemory = NULL;
	HANDLE						hFile = NULL;
	DWORD						dwError = 0;


	DPF(7, "Entering PRV_GetDataBuffer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			lpgn, dwType, dwSize, lphFile, lplpMemory);

	// Get the data buffer filename
	hr = PRV_GetInternalName(lpgn, dwType, (LPWSTR)szName);
	if(FAILED(hr))
		return hr;

	// If we are a Lobby Client, we need to create the file. If we
	// are a game, we need to open the already created file for
	// connection data, or we can create the file for game data (if
	// it doesn't already exist).
	if(lpgn->dwFlags & GN_LOBBY_CLIENT)
	{
		// Set up the security attributes (so that our mapping can
		// be inheritable
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = NULL;
		sa.bInheritHandle = TRUE;
		
		// Create the file mapping
		hFile = OS_CreateFileMapping(INVALID_HANDLE_VALUE, &sa,
							PAGE_READWRITE,	0, dwSize,
							(LPWSTR)szName);
	}
	else
	{
		hFile = OS_OpenFileMapping(FILE_MAP_ALL_ACCESS, TRUE, (LPWSTR)szName);
	}

	if(!hFile)
	{
		dwError = GetLastError();
		// WARNING: error may not be correct since calls we are trying to get last error from may have called out
		// to another function before returning.
		DPF(5, "Couldn't get a handle to the shared local memory, dwError = %lu (error may not be correct)", dwError);
		return DPERR_OUTOFMEMORY;
	}

	// Map a View of the file
	lpMemory = MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	if(!lpMemory)
	{
		dwError = GetLastError();
		DPF(5, "Unable to get pointer to shared local memory, dwError = %lu", dwError);
		CloseHandle(hFile);
		return DPERR_OUTOFMEMORY;
	}


	// Setup the control structure based on the buffer type
	switch(dwType)
	{
		case TYPE_CONNECT_DATA_FILE:
		{
			LPDPLOBBYI_CONNCONTROL		lpControl = NULL;
						
			
			lpControl = (LPDPLOBBYI_CONNCONTROL)lpMemory;

			// If the buffer has been initialized, then don't worry
			// about it.  If the token is wrong (uninitialized), then do it
			if(lpControl->dwToken != BC_TOKEN)
			{
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwFlags = 0;
				if(lpgn->dwFlags & GN_LOBBY_CLIENT){
					lpControl->CliProcId = GetCurrentProcessId();
				}
			}
			break;
		}
		case TYPE_GAME_WRITE_FILE:
		case TYPE_LOBBY_WRITE_FILE:
		{
			LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


			lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpMemory;
			if(lpgn->dwFlags & GN_LOBBY_CLIENT)
			{
				// Since we're the lobby client, we know we create the buffer, so
				// initialize the entire structure
				lpControl->dwToken = BC_TOKEN;
				lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
				lpControl->dwFlags = BC_LOBBY_ACTIVE;
				lpControl->dwMessages = 0;
				lpControl->dwBufferSize = dwSize;
				lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
			}
			else
			{
				// We're the game, but we don't know for sure if we just created
				// the buffer or if a lobby client did.  So check the token.  If
				// it is incorrect, we will assume we just created it and we need
				// to initialize the buffer control struct.  Otherwise, we will
				// assume a lobby client created it and we just need to add
				// our flag.
				if(lpControl->dwToken != BC_TOKEN)
				{
					// We don't see the token, so initialize the structure
					lpControl->dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
					lpControl->dwFlags = BC_GAME_ACTIVE;
					lpControl->dwMessages = 0;
					lpControl->dwBufferSize = dwSize;
					lpControl->dwBufferLeft = dwSize - sizeof(DPLOBBYI_BUFFERCONTROL);
				}
				else
				{
					// We assume the lobby created this buffer, so just set our flag
					lpControl->dwFlags |= BC_GAME_ACTIVE;
				}
			}
			break;
		}
	}

	// Fill in the output parameters
	*lphFile = hFile;
	*lplpMemory = lpMemory;

	return DP_OK;

} // PRV_GetDataBuffer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_StartReceiveThread"
HRESULT PRV_StartReceiveThread(LPDPLOBBYI_GAMENODE lpgn)
{
	HANDLE	hReceiveThread = NULL;
	HANDLE	hKillEvent = NULL;
	DWORD	dwThreadID;


	DPF(7, "Entering PRV_StartReceiveThread");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Create the kill event if one doesn't exists
	if(!(lpgn->hKillReceiveThreadEvent))
	{
		hKillEvent = OS_CreateEvent(NULL, FALSE, FALSE, NULL);
		if(!hKillEvent)
		{
			DPF(2, "Unable to create Kill Receive Thread Event");
			return DPERR_OUTOFMEMORY;
		}
	}

	// If the Receive Thread isn't going, start it
	if(!(lpgn->hReceiveThread))
	{
		// Spawn off a receive notification thread for the cross-proc communication
		hReceiveThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)
							PRV_ReceiveClientNotification, lpgn, 0, &dwThreadID);

		if(!hReceiveThread)
		{
			DPF(2, "Unable to create Receive Thread!");
			if(hKillEvent)
				CloseHandle(hKillEvent);
			return DPERR_OUTOFMEMORY;
		}

		lpgn->hReceiveThread = hReceiveThread;
		if(hKillEvent)
			lpgn->hKillReceiveThreadEvent = hKillEvent;

	}

	return DP_OK;

} // PRV_StartReceiveThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetupAllSharedMemory"
HRESULT PRV_SetupAllSharedMemory(LPDPLOBBYI_GAMENODE lpgn)
{
	HRESULT	hr;
	LPVOID		lpConnDataMemory = NULL;
	LPVOID		lpGameMemory = NULL;
	LPVOID		lpLobbyMemory = NULL;
	HANDLE		hFileConnData = NULL;
	HANDLE		hFileGameWrite = NULL;
	HANDLE		hFileLobbyWrite = NULL;
	DWORD		dwError = 0;


	DPF(7, "Entering PRV_SetupAllSharedMemory");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get access to the Connection Data File
	hr = PRV_GetDataBuffer(lpgn, TYPE_CONNECT_DATA_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileConnData, &lpConnDataMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Connection Data buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}

	// Do the same for the Game Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_GAME_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileGameWrite, &lpGameMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Game Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Do the same for the Lobby Write File...
	hr = PRV_GetDataBuffer(lpgn, TYPE_LOBBY_WRITE_FILE,
								MAX_APPDATABUFFERSIZE,
								&hFileLobbyWrite, &lpLobbyMemory);
	if(FAILED(hr))
	{
		DPF(5, "Couldn't get access to Lobby Write buffer");
		goto ERROR_SETUP_SHARED_MEMORY;
	}


	// Setup the signalling objects
	if(!PRV_SetupClientDataAccess(lpgn))
	{
		DPF(5, "Unable to create synchronization objects for shared memory!");
		return DPERR_OUTOFMEMORY;
	}

	// Save the file handles
	lpgn->hConnectDataFile = hFileConnData;
	lpgn->lpConnectDataBuffer = lpConnDataMemory;
	lpgn->hGameWriteFile = hFileGameWrite;
	lpgn->lpGameWriteBuffer = lpGameMemory;
	lpgn->hLobbyWriteFile = hFileLobbyWrite;
	lpgn->lpLobbyWriteBuffer = lpLobbyMemory;

	// Set the flag that tells us the shared memory files are valid
	lpgn->dwFlags |= GN_SHARED_MEMORY_AVAILABLE;

	// Start the Receive Thread
	hr = PRV_StartReceiveThread(lpgn);
	if(FAILED(hr))
	{
		// In this case, we will keep our shared buffers around.  Don't
		// worry about cleaning them up here -- we'll probably still need
		// them later, and they will get cleaned up later.
		DPF(5, "Unable to start receive thread");
		return hr;
	}

	return DP_OK;


ERROR_SETUP_SHARED_MEMORY:

		if(hFileConnData)
			CloseHandle(hFileConnData);
		if(lpConnDataMemory)
			UnmapViewOfFile(lpConnDataMemory);
		if(hFileGameWrite)
			CloseHandle(hFileGameWrite);
		if(lpGameMemory)
			UnmapViewOfFile(lpGameMemory);
		if(hFileLobbyWrite)
			CloseHandle(hFileLobbyWrite);
		if(lpLobbyMemory)
			UnmapViewOfFile(lpLobbyMemory);

		return hr;

} // PRV_SetupAllSharedMemory



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_EnterConnSettingsWaitMode"
void PRV_EnterConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_EnterConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Set the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Set the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Set the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags |= BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_EnterConnSettingsWaitMode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_LeaveConnSettingsWaitMode"
void PRV_LeaveConnSettingsWaitMode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBufferControl = NULL;


	DPF(7, "Entering PRV_LeaveConnSettingsWaitMode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	// Clear the flag in the ConnSettings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	lpConnControl->dwFlags &= ~(BC_WAIT_MODE | BC_PENDING_CONNECT);
	ReleaseMutex(lpgn->hConnectDataMutex);

	// Clear the flag in the GameWrite buffer
	WaitForSingleObject(lpgn->hGameWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hGameWriteMutex);

	// Clear the flag in the LobbyWrite buffer
	WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
	lpBufferControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
	lpBufferControl->dwFlags &= ~BC_WAIT_MODE;
	ReleaseMutex(lpgn->hLobbyWriteMutex);

} // PRV_LeaveConnSettingsWaitMode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteClientData"
HRESULT PRV_WriteClientData(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	HANDLE						hMutex = NULL;
	DWORD						dwSizeToEnd = 0;
	LPBYTE						lpTemp = NULL;
    HRESULT						hr = DP_OK;
    
    DWORD						dwReadOffset;
    DWORD						dwWriteOffset;
    DWORD						dwBufferSize;


	DPF(7, "Entering PRV_WriteClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, dwFlags, lpData, dwSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	
	// Grab the mutex
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteMutex) : (lpgn->hGameWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpLobbyWriteBuffer)
				: (lpgn->lpGameWriteBuffer));

	// If we're in wait mode, bail
	if(lpControl->dwFlags & BC_WAIT_MODE)
	{
		DPF_ERR("Cannot send lobby message while in Wait Mode for new ConnectionSettings");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// If we are the game, check to see if the lobby client is even there. In
	// the self-lobbied case, it won't be.  If it is not there, don't even
	// bother sending anything.
	if((!(lpgn->dwFlags & GN_LOBBY_CLIENT)) && (!(lpControl->dwFlags
		& BC_LOBBY_ACTIVE)))
	{
		DPF(5, "There is not active lobby client; Not sending message");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Make sure there is enough space left for the message and two dwords
	if(lpControl->dwBufferLeft < (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
	{
		DPF(5, "Not enough space left in the message buffer");
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	if(lpControl->dwBufferLeft > MAX_APPDATABUFFERSIZE-(sizeof(DPLOBBYI_BUFFERCONTROL)))
	{
		DPF(4,"SECURITY WARN: invalid amount of buffer left in write buffer");
		hr=DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// SECURITY: need to snapshot these so they aren't
	// altered by attacking code during processing
	dwReadOffset = lpControl->dwReadOffset;
	dwWriteOffset = lpControl->dwWriteOffset;
	dwBufferSize = lpControl->dwBufferSize;

	if(dwReadOffset >= MAX_APPDATABUFFERSIZE || dwWriteOffset >= MAX_APPDATABUFFERSIZE)
	{
		DPF(4,"SECURITY WARN: invalid offsets found in shared memory control block, bailing");
		hr=DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	if(dwBufferSize != MAX_APPDATABUFFERSIZE)
	{
		DPF(4,"SECURITY WARN: shared memory control block buffer size tampered with, bailing");
		hr=DPERR_UNAVAILABLE;
		goto EXIT_WRITE_CLIENT_DATA;
	}

	// Copy in the data. First make sure we can write from the cursor
	// forward without having to wrap around to the beginning of the buffer,
	// but make sure we don't write past the read cursor
	if(dwWriteOffset >= dwReadOffset)
	{
		// Our write pointer is ahead of our read pointer (cool). Figure
		// out if we have enough room between our write pointer and the
		// end of the buffer.  If we do, then just write it.  If we don't
		// we need to wrap it.
		dwSizeToEnd = dwBufferSize - dwWriteOffset;
		if(dwSizeToEnd >= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// We have enough room
			lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ dwWriteOffset);
			lpHeader->dwSize = dwSize;
			lpHeader->dwFlags = dwFlags;
			lpTemp = (LPBYTE)(++lpHeader);

			memcpySecureD(lpTemp, lpData, dwSize,
				    lpControl, MAX_APPDATABUFFERSIZE,
					"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
					hr=DPERR_UNAVAILABLE,
					EXIT_WRITE_CLIENT_DATA);
					

			// Move the write cursor, and check to see if we have enough
			// room for the header on the next message.  If the move causes
			// us to wrap, or if we are within one header's size,
			// we need to move the write cursor back to the beginning
			// of the buffer
			dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
			if(dwWriteOffset > (dwBufferSize -
					sizeof(DPLOBBYI_MESSAGEHEADER)))
			{
				// Increment the amount of free buffer by the amount we
				// are about to skip over to wrap
				lpControl->dwBufferLeft -= (lpControl->dwBufferSize -
					dwWriteOffset);
				
				// We're closer than one header's size
				dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL);
			}

		}
		else
		{
			// We don't have enough room before the end, so we need to
			// wrap the message (ugh).  Here's the rules:
			//		1. If we don't have enough bytes for the header, start
			//			the whole thing at the beginning of the buffer
			//		2. If we have enough bytes, write as much
			//			as we can and wrap the rest.
			if(dwSizeToEnd < sizeof(DPLOBBYI_MESSAGEHEADER))
			{
				// We don't even have room for our two dwords, so wrap
				// the whole thing. So first decrement the amount of
				// free memory left and make sure we will still fit
				lpControl->dwBufferLeft -= dwSizeToEnd;
				if(lpControl->dwBufferLeft < (dwSize +
						sizeof(DPLOBBYI_MESSAGEHEADER)))
				{
					DPF(5, "Not enough space left in the message buffer");
					hr = DPERR_BUFFERTOOSMALL;
					goto EXIT_WRITE_CLIENT_DATA;
				}
				
				// Reset the write pointer and copy
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						sizeof(DPLOBBYI_BUFFERCONTROL));
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;
				lpTemp = (LPBYTE)(++lpHeader);
				
				memcpySecureD(lpTemp, lpData, dwSize,
				    lpControl, MAX_APPDATABUFFERSIZE,
					"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
					hr=DPERR_UNAVAILABLE,
					EXIT_WRITE_CLIENT_DATA);

				// Move the write cursor
				dwWriteOffset += sizeof(DPLOBBYI_BUFFERCONTROL) +
							(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
			}
			else
			{
				// We at least have enough room for the two dwords
				lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
							+ dwWriteOffset);
				lpHeader->dwSize = dwSize;
				lpHeader->dwFlags = dwFlags;

				// Now figure out how much we can write
				lpTemp = (LPBYTE)(++lpHeader);
				dwSizeToEnd -= sizeof(DPLOBBYI_MESSAGEHEADER);
				if(!dwSizeToEnd)
				{
					// We need to wrap to write the whole message
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
					memcpySecureD(lpTemp, lpData, dwSize,
					    lpControl, MAX_APPDATABUFFERSIZE,
						"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
						hr=DPERR_UNAVAILABLE,
						EXIT_WRITE_CLIENT_DATA);

					// Move the write cursor
					dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ dwSize;
				}
				else
				{
					memcpySecureD(lpTemp, lpData, dwSizeToEnd,
					    lpControl, MAX_APPDATABUFFERSIZE,
						"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
						hr=DPERR_UNAVAILABLE,
						EXIT_WRITE_CLIENT_DATA);

					// Move both pointers and finish the job
					lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);

					memcpySecureD(lpTemp, ((LPBYTE)lpData+dwSizeToEnd), (dwSize-dwSizeToEnd),
					    lpControl, MAX_APPDATABUFFERSIZE,
						"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
						hr=DPERR_UNAVAILABLE,
						EXIT_WRITE_CLIENT_DATA);


					// Move the write cursor
					dwWriteOffset = sizeof(DPLOBBYI_BUFFERCONTROL)
							+ (dwSize - dwSizeToEnd);
				}
			}
		}
	}
	else
	{
		// Our read pointer is ahead of our write pointer.  Since we checked
		// and found there is enough room to write, we should just be able
		// to just slam this guy in.
		lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl +
						dwWriteOffset);
		lpHeader->dwSize = dwSize;
		lpHeader->dwFlags = dwFlags;
		lpTemp = (LPBYTE)(++lpHeader);
		memcpySecureD(lpTemp, lpData, dwSize,
			    lpControl, MAX_APPDATABUFFERSIZE,
				"SECURITY WARN: shared memory was about to write outside shared buffer, aborting",
				hr=DPERR_UNAVAILABLE,
				EXIT_WRITE_CLIENT_DATA);

		// Move the write cursor
		dwWriteOffset += dwSize + sizeof(DPLOBBYI_MESSAGEHEADER);
	}

	lpControl->dwWriteOffset = dwWriteOffset;

	// Decrement the amount of free space left and increment the message count
	lpControl->dwBufferLeft -= (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages++;

	// Signal the other user that we have written something
	SetEvent((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hLobbyWriteEvent) : (lpgn->hGameWriteEvent));

	// Fall through

EXIT_WRITE_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);
	return hr;

} // PRV_WriteClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendStandardSystemMessage"
HRESULT PRV_SendStandardSystemMessage(LPDIRECTPLAYLOBBY lpDPL,
			DWORD dwMessage, DWORD dwGameID)
{
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	HRESULT					hr;
	DWORD					dwMessageSize;
	LPVOID					lpmsg = NULL;
	DWORD					dwFlags;


	DPF(7, "Entering PRV_SendStandardSystemMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu",
			lpDPL, dwMessage, dwGameID);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero it means that we are the game, so
	// we need to get the current process ID.  Otherwise, it
	// means we are the lobby client
	if(!dwGameID)
		dwGameID = GetCurrentProcessId();

	// Now find the correct game node
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		if(FAILED(PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, FALSE,NULL)))
		{
			LEAVE_DPLOBBY();
			return DPERR_OUTOFMEMORY;
		}
	}

	// Get the size of the message
	switch(dwMessage)
	{
		case DPLSYS_NEWSESSIONHOST:
			dwMessageSize = sizeof(DPLMSG_NEWSESSIONHOST);
			break;

		default:
			dwMessageSize = sizeof(DPLMSG_SYSTEMMESSAGE);
			break;
	}

	// Allocate a buffer for the message
	lpmsg = DPMEM_ALLOC(dwMessageSize);
	if(!lpmsg)
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Unable to allocate memory for lobby system message, dwMessage = %lu", dwMessage);
		return DPERR_OUTOFMEMORY;
	}

	// Setup the message
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->dwType = dwMessage;
	((LPDPLMSG_SYSTEMMESSAGE)lpmsg)->guidInstance = lpgn->guidInstance;

	// Write into the shared buffer
	dwFlags = DPLMSG_SYSTEM | DPLMSG_STANDARD;
	hr = PRV_WriteClientData(lpgn, dwFlags, lpmsg, dwMessageSize);
	if(FAILED(hr))
	{
		DPF(8, "Couldn't send system message");
	}

	// Free our buffer
	DPMEM_FREE(lpmsg);

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SendStandardSystemMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddNewRequestNode"
HRESULT PRV_AddNewRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_GAMENODE lpgn, LPDPLMSG_GENERIC lpmsg, BOOL bSlamGuid)
{
	LPDPLOBBYI_REQUESTNODE	lprn = NULL;


	// Allocate memory for a Request Node
	lprn = DPMEM_ALLOC(sizeof(DPLOBBYI_REQUESTNODE));
	if(!lprn)
	{
		DPF_ERR("Unable to allocate memory for request node, system message not sent");
		return DPERR_OUTOFMEMORY;
	}
	
	// Setup the request node
	lprn->dwFlags = lpgn->dwFlags;
	lprn->dwRequestID = this->dwCurrentRequest;
	lprn->dwAppRequestID = ((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID;
	lprn->lpgn = lpgn;

	// Add the slammed guid flag if needed
	if(bSlamGuid)
		lprn->dwFlags |= GN_SLAMMED_GUID;

	// Change the request ID in the message to our internal one (we'll
	// change it back on Receive
	((LPDPLMSG_GETPROPERTY)lpmsg)->dwRequestID = this->dwCurrentRequest++;

	// Add the node to the list
	if(this->lprnHead)
		this->lprnHead->lpPrev = lprn;
	lprn->lpNext = this->lprnHead;
	this->lprnHead = lprn;

	return DP_OK;

} // PRV_AddNewRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveRequestNode"
void PRV_RemoveRequestNode(LPDPLOBBYI_DPLOBJECT this,
		LPDPLOBBYI_REQUESTNODE lprn)
{
	// If we're the head, move it
	if(lprn == this->lprnHead)
		this->lprnHead = lprn->lpNext;

	// Fixup the previous & next pointers
	if(lprn->lpPrev)
		lprn->lpPrev->lpNext = lprn->lpNext;
	if(lprn->lpNext)
		lprn->lpNext->lpPrev = lprn->lpPrev;

	// Free the node
	DPMEM_FREE(lprn);

} // PRV_RemoveRequestNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ForwardMessageToLobbyServer"
HRESULT PRV_ForwardMessageToLobbyServer(LPDPLOBBYI_GAMENODE lpgn,
		LPVOID lpBuffer, DWORD dwSize, BOOL bStandard)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLMSG_GENERIC		lpmsg = NULL;
	HRESULT					hr;
	BOOL					bSlamGuid = FALSE;


	DPF(7, "Entering PRV_ForwardMessageToLobbyServer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu, %lu",
			lpgn, lpBuffer, dwSize, bStandard);


    TRY
    {
		// Validate the dplay object
		hr = VALID_DPLAY_PTR( lpgn->lpDPlayObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}

		// Validate the lobby object
		this = lpgn->lpDPlayObject->lpLobbyObject;
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			DPF_ERR("Invalid lobby object");
			return DPERR_INVALIDOBJECT;
        }
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If this is a property request, we need to create a request node
	lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
	if(bStandard)
	{
		// If it's a property message, we need a request node
		switch(lpmsg->dwType)
		{
			case DPLSYS_GETPROPERTY:
			{
				LPDPLMSG_GETPROPERTY	lpgp = lpBuffer;

				// If it's a GETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpgp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpgp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// Add a request node to the pending requests list
				hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
					return hr;
				}
				break;
			}
			
			case DPLSYS_SETPROPERTY:
			{
				LPDPLMSG_SETPROPERTY	lpsp = lpBuffer;
				
				// If it's a SETPROPERTY message, we need to check to see if
				// the player guid is NULL.  If it is, we need to
				// stuff the game's Instance guid in that field
				if(IsEqualGUID(&lpsp->guidPlayer, &GUID_NULL))
				{
					// Stuff the instance guid of the game
					lpsp->guidPlayer = lpgn->guidInstance;
					bSlamGuid = TRUE;
				}

				// If the request ID is zero, we don't need to swap
				// the ID's or add a pending request
				if(lpsp->dwRequestID != 0)
				{
					// Add a request node to the pending requests list
					hr = PRV_AddNewRequestNode(this, lpgn, lpmsg, bSlamGuid);
					if(FAILED(hr))
					{
						DPF_ERRVAL("Unable to add request node to list, hr = 0x%08x", hr);
						return hr;
					}
				}
				break;
			}

			case DPLSYS_NEWSESSIONHOST:
				((LPDPLMSG_NEWSESSIONHOST)lpBuffer)->guidInstance = lpgn->guidInstance;
				break;
			
			default:
				break;
		}
	}


	// Call Send on the lobby object
	hr = PRV_Send(this, lpgn->dpidPlayer, DPID_SERVERPLAYER,
			DPSEND_LOBBYSYSTEMMESSAGE, lpBuffer, dwSize);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed sending lobby message, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_ForwardMessageToLobbyServer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_InjectMessageInQueue"
HRESULT PRV_InjectMessageInQueue(LPDPLOBBYI_GAMENODE lpgn, DWORD dwFlags,
							LPVOID lpData, DWORD dwSize, BOOL bForward)
{
	LPDPLOBBYI_MESSAGE	lpm = NULL;
	LPVOID				lpBuffer = NULL;
	HRESULT				hr;


	DPF(7, "Entering PRV_InjectMessageInQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu, %lu",
			lpgn, dwFlags, lpData, dwSize, bForward);

	ASSERT(lpData);

	// Allocate memory for the node and the data buffer
	lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
	lpBuffer = DPMEM_ALLOC(dwSize);
	if((!lpm) || (!lpBuffer))
	{
		DPF_ERR("Unable to allocate memory for system message");
		if(lpm)
			DPMEM_FREE(lpm);
		if(lpBuffer)
			DPMEM_FREE(lpBuffer);
		return DPERR_OUTOFMEMORY;
	}

	// Copy the data
	memcpy(lpBuffer, lpData, dwSize);

	// Before we put it in our own queue, forward it onto the lobby server
	// if there is one.
	if(bForward && (lpgn->dwFlags & GN_CLIENT_LAUNCHED))
	{
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, FALSE);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed forwarding system message to lobby server, hr = 0x%08x", hr);
		}
	}

	// Save the data pointer & the external flags
	// Note: If we're injecting this, it has to be a system message,
	// so set the flag just in case we forgot elsewhere.
	lpm->dwFlags = (dwFlags | DPLAD_SYSTEM);
	lpm->dwSize = dwSize;
	lpm->lpData = lpBuffer;

	// Add the message to the end of the queue & increment the count
	ENTER_DPLQUEUE();
	lpm->lpPrev = lpgn->MessageHead.lpPrev;
	lpgn->MessageHead.lpPrev->lpNext = lpm;
	lpgn->MessageHead.lpPrev = lpm;
	lpm->lpNext = &lpgn->MessageHead;

	lpgn->dwMessageCount++;
	LEAVE_DPLQUEUE();

	// Kick the event handle
	if(lpgn->hDupReceiveEvent)
	{
		SetEvent(lpgn->hDupReceiveEvent);
	}

	return DP_OK;

} // PRV_InjectMessageInQueue


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadClientData"
HRESULT PRV_ReadClientData(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
							LPVOID lpData, LPDWORD lpdwDataSize)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLOBBYI_MESSAGEHEADER	lpHeader = NULL;
	DWORD						dwSize = 0;
	DWORD_PTR					dwSizeToEnd = 0;
	HANDLE						hMutex = NULL;
	LPBYTE						lpTemp = NULL;
	LPBYTE						lpEnd = NULL;
	HRESULT						hr = DP_OK;

	DWORD	dwReadOffset;
	DWORD	dwBufferSize;

	DPF(7, "Entering PRV_ReadClientData");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwDataSize);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return hr;
		}
	}
	LEAVE_DPLGAMENODE();

	// Grab the mutex
	// REVIEW!!!! -- Is there anything that might cause this wait to hang????
	hMutex = (lpgn->dwFlags & GN_LOBBY_CLIENT) ?
			(lpgn->hGameWriteMutex) : (lpgn->hLobbyWriteMutex);
	WaitForSingleObject(hMutex, INFINITE);

	// Get a pointer to our control structure
	lpControl = (LPDPLOBBYI_BUFFERCONTROL)((lpgn->dwFlags &
				GN_LOBBY_CLIENT) ? (lpgn->lpGameWriteBuffer)
				: (lpgn->lpLobbyWriteBuffer));

	// Make sure there are any messages in the buffer
	if(!lpControl->dwMessages)
	{
		DPF(8, "No messages in shared buffer");
		hr = DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}

	// SECURITY need to snapshot these values so hackers 
	// can't change in the middle of accessing shared object.
	dwReadOffset=lpControl->dwReadOffset;
	dwBufferSize=lpControl->dwBufferSize;

	// Make sure there is enough space for the message
	lpHeader = (LPDPLOBBYI_MESSAGEHEADER)((LPBYTE)lpControl
				+ dwReadOffset);

	if(lpControl->dwReadOffset >= MAX_APPDATABUFFERSIZE)
	{
		DPF(4,"SECURITY WARN: local application hacking shared memory, lobby connection broken");
		hr=DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}
	
	dwSize = lpHeader->dwSize;

	if(dwSize > MAX_APPDATABUFFERSIZE-(sizeof(DPLOBBYI_BUFFERCONTROL)+sizeof(DPLOBBYI_MESSAGEHEADER))){
		DPF(4,"SECURITY WARN: lobby message size %d is too large",lpHeader->dwSize);
		hr=DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Set the output data size (even if we fail, we want to return it)
	if(lpdwDataSize)
		*lpdwDataSize = dwSize;

	if((!lpData) || (dwSize > *lpdwDataSize))
	{
		DPF(8, "Message buffer is too small, must be at least %d bytes", dwSize);
		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Set the output flags
	if(lpdwFlags)
		*lpdwFlags = lpHeader->dwFlags;

	if(dwBufferSize != MAX_APPDATABUFFERSIZE) // note, makes storing this value in header redundant.
	{
		DPF(4, "SECURITY WARN: shared app memory has been tampered with");
		hr = DPERR_NOMESSAGES;
		goto EXIT_READ_CLIENT_DATA;
	}

	// Now check and see if we are going to wrap. If we are, some of the message
	// will be at the end of the buffer, some will be at the beginning.
	lpTemp = (LPBYTE)(++lpHeader) + dwSize;
	if(lpTemp > ((LPBYTE)lpControl + dwBufferSize))
	{
		// Figure out where we need to wrap
		dwSizeToEnd = ((LPBYTE)lpControl + dwBufferSize)
						- (LPBYTE)(lpHeader);

		if(!dwSizeToEnd)
		{
			// We are at the end, so the whole message must be at the
			// beginning of the buffer
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(lpData, lpTemp, dwSize);

			// Move the read cursor
			dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL) + dwSize;
		}
		else
		{
			// Copy the first part of the data
			lpTemp = (LPBYTE)lpHeader;
			memcpy(lpData, lpTemp, (DWORD)dwSizeToEnd);

			// Move the read cursor and copy the rest
			lpTemp = (LPBYTE)lpControl + sizeof(DPLOBBYI_BUFFERCONTROL);
			memcpy(((LPBYTE)lpData + dwSizeToEnd), lpTemp,
					(DWORD)(dwSize - dwSizeToEnd));

			// Move the read pointer
			dwReadOffset = (DWORD)(sizeof(DPLOBBYI_BUFFERCONTROL)
						+ (dwSize - dwSizeToEnd));
		}
	}
	else
	{
		// We don't have to wrap (cool).
		lpTemp = (LPBYTE)lpHeader;
		memcpy(lpData, lpTemp, dwSize);

		// Move the read pointer.  If there are less than 8 bytes left in the
		// buffer, we should move the read pointer to the beginning.  We need
		// to add however many bytes we skip (at the end) back into our free
		// buffer memory counter.
		lpTemp += dwSize;
		lpEnd = (LPBYTE)lpControl + dwBufferSize;
		if(lpTemp > (lpEnd	- sizeof(DPLOBBYI_MESSAGEHEADER)))
		{
			// Move the read cursor to the beginning
			dwReadOffset = sizeof(DPLOBBYI_BUFFERCONTROL);

			// Add the number of bytes to the free buffer total
			lpControl->dwBufferLeft += (DWORD)(lpEnd - lpTemp);
		}
		else
			dwReadOffset += (DWORD)(dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	}

	lpControl->dwReadOffset=dwReadOffset;

	// Increment the amount of free space left and decrement the message count
	lpControl->dwBufferLeft += (dwSize + sizeof(DPLOBBYI_MESSAGEHEADER));
	lpControl->dwMessages--;

	// Fall through

EXIT_READ_CLIENT_DATA:

	// Release the mutex
	ReleaseMutex(hMutex);

	return hr;

} // PRV_ReadClientData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReceiveClientNotification"
DWORD WINAPI PRV_ReceiveClientNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE			lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
    LPDPLOBBYI_MESSAGE			lpm = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;
	LPDPLMSG_GENERIC			lpmsg = NULL;
	HRESULT						hr;
	HANDLE						hEvents[4];
	LPVOID						lpBuffer = NULL;
	DWORD						dwFlags;
	DWORD						dwSize;
	DWORD						dwReturn;
	BOOL						bForward;

	DWORD						dwWait=INFINITE;
	DWORD						nWait=2;

	DPF(7, "Entering PRV_ReceiveClientNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		BOOL	bGameCreate=FALSE;


		DPF(2, "NOTE: ReceiveClientNotification thread starting without shared memory set up.  Setting up now.");
		
		// HACK!!!! -- SetLobbyMessageReceiveEvent may get called from
		// the game without having been lobbied yet.  If that is the case,
		// we need to create the shared memory buffer.  If we don't do
		// that, we may miss messages.
		
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

	
		//hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access App Data memory");
			return 0L;
		}
	}
	LEAVE_DPLGAMENODE();

	// Setup the two events -- one receive event, one kill event
	hEvents[0] = ((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
				(lpgn->hGameWriteEvent) : (lpgn->hLobbyWriteEvent));
	hEvents[1] = lpgn->hKillReceiveThreadEvent;

	if(lpgn->hLobbyClientProcess){
		nWait=3;
		hEvents[2] = lpgn->hLobbyClientProcess;
	} else {
		hEvents[2] = INVALID_HANDLE_VALUE;
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT)){
			dwWait = 5000;
		}
	}
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hEvents[3] = INVALID_HANDLE_VALUE;

	// Make sure we have a valid event
	if(!hEvents[0] || !hEvents[1])
	{
		DPF(2, "Either the Write Event or the Kill Event is NULL and it shouldn't be!");
		ExitThread(0L);
		return 0;
	}

	// If we are the game, we should check the buffer to see if any messages
	// already exist in the shared buffer.
	if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		// If there are any messages, kick our event so that our receive
		// loop will immediately put the messages in the queue
		if(lpControl->dwMessages)
			SetEvent(hEvents[0]);
	}

	// Wait for the event notification
	while(1)
	{
		// Sleep until something shows up
		dwReturn = WaitForMultipleObjects(nWait, (HANDLE *)hEvents,
											FALSE, dwWait);

		if(dwReturn == WAIT_TIMEOUT){
			ASSERT(!(lpgn->dwFlags & GN_LOBBY_CLIENT));
			if(lpgn->hLobbyClientProcess){
				DPF(9,"Got the lobby client process handle, adding to wait list\n");
				hEvents[2] = lpgn->hLobbyClientProcess;
				nWait = 3;
				dwWait=INFINITE;
			} 
			continue;
		}

		if(nWait==3 && dwReturn == WAIT_OBJECT_0 + 2){
			// send the dead lobby client message
			DPLMSG_SYSTEMMESSAGE msg;

			if(lpgn->dwLobbyClientProcessID){
				memset(&msg, 0, sizeof(DPLMSG_SYSTEMMESSAGE));
				msg.dwType = DPLSYS_LOBBYCLIENTRELEASE;
				msg.guidInstance = lpgn->guidInstance;
				lpgn->dwLobbyClientProcessID = 0;
				hr = PRV_InjectMessageInQueue(lpgn, DPLMSG_SYSTEM | DPLMSG_STANDARD, &msg,
										sizeof(DPLMSG_SYSTEMMESSAGE), FALSE);

			}	
			nWait=2;
			hEvents[2]=INVALID_HANDLE_VALUE;
			continue;
		}

		// If the return value was anything bug the receive event,
		// kill the thread
		if(dwReturn != WAIT_OBJECT_0)
		{
			if(dwReturn == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				if(ERROR_INVALID_HANDLE == GetLastError())
				{
					if(!OS_IsValidHandle(hEvents[0]))
						break;
					if(!OS_IsValidHandle(hEvents[1]))
						break;
					continue;
				}
				break;
			}
			else
			{
				// It is either our kill event, or something we don't
				// understand or expect.  In this case, let's exit.
				break;
			}
		}

		while(1)
		{
			// First, call PRV_ReadClientData to get the size of the data
			hr = PRV_ReadClientData(lpgn, NULL, NULL, &dwSize);
			
			// If there are no messages, end the while loop
			if(hr == DPERR_NOMESSAGES)
				break;

			// Otherwise, we should get the BUFFERTOOSMALL case
			if(hr != DPERR_BUFFERTOOSMALL)
			{
				// We should never have a problem here
				DPF_ERRVAL("Recieved an unexpected error reading from shared buffer, hr = 0x%08x", hr);
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}
			
			// Allocate memory for the node and the data buffer
			lpm = DPMEM_ALLOC(sizeof(DPLOBBYI_MESSAGE));
			lpBuffer = DPMEM_ALLOC(dwSize);
			if((!lpm) || (!lpBuffer))
			{
				DPF_ERR("Unable to allocate memory for message");
				ASSERT(FALSE);
				// Might as well keep trying
				break;
			}

			// Copy the data into our buffer
			hr = PRV_ReadClientData(lpgn, &dwFlags, lpBuffer, &dwSize);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Error reading shared buffer, message not read, hr = 0x%08x", hr);
				ASSERT(FALSE);
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
				// Might as well keep trying
				break;
			}

			// Clear our foward flag
			bForward = FALSE;
			
			// If we are a dplay lobby client, we need to forward the message
			// onto the lobby server using the IDP3 interface.  If we're not,
			// then just put the message in the receive queue.
			if(lpgn->dwFlags & GN_CLIENT_LAUNCHED)
			{
				// Foward the message
				hr = PRV_ForwardMessageToLobbyServer(lpgn, lpBuffer, dwSize,
					((dwFlags & DPLMSG_STANDARD) ? TRUE : FALSE));
				if(FAILED(hr))
				{
					DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
				}

				// Set the forwarded flag
				bForward = TRUE;
			}

			// Check for an App Terminated message.  If we get one off the wire,
			// we need to shut down our ClientTerminateMonitor thread, signal
			// this thread (the receive thread to shut down, and mark the game
			// node as dead.  This will keep us from sending or receiving any
			// more messages from the now dead game.  (This message will only
			// ever be received by a lobby client).
			lpmsg = (LPDPLMSG_GENERIC)lpBuffer;
			if(lpmsg->dwType == DPLSYS_APPTERMINATED)
			{
				// Kick the TerminateMonitor thread with it's kill event
				SetEvent(lpgn->hKillTermThreadEvent);

				// Set this thread's kill event (so that when we get done
				// reading messages out of the shared buffer, we go away)
				SetEvent(lpgn->hKillReceiveThreadEvent);

				// Mark the GAMENODE as dead, but don't remove it since we know
				// there will still messages in the queue.
				lpgn->dwFlags |= GN_DEAD_GAME_NODE;
			}

			// If it's one of our DX3 messages, we need to put it in the queue
			// otherwise if we already forwarded it, we can free it. NOTE: All
			// DX3 lobby system messages had a value between 0 and
			// DPLSYS_APPTERMINATED (0x04).
			if( (!bForward) || (lpmsg->dwType <= DPLSYS_APPTERMINATED))
			{

				if (lpmsg->dwType == DPLSYS_LOBBYCLIENTRELEASE) {
					if(lpgn->dwLobbyClientProcessID){
						lpgn->dwLobbyClientProcessID = 0;
					} else {
						goto no_queue;
					}
				} 

				
				// Save the data pointer & the external flags
				lpm->dwFlags = dwFlags & (~DPLOBBYPR_INTERNALMESSAGEFLAGS);
				lpm->dwSize = dwSize;
				lpm->lpData = lpBuffer;

				// Add the message to the end of the queue & increment the count
				ENTER_DPLQUEUE();
				lpm->lpPrev = lpgn->MessageHead.lpPrev;
				lpgn->MessageHead.lpPrev->lpNext = lpm;
				lpgn->MessageHead.lpPrev = lpm;
				lpm->lpNext = &lpgn->MessageHead;

				lpgn->dwMessageCount++;
				LEAVE_DPLQUEUE();

				// NOTE: There is a potential thread problem here, but we are going
				// to ignore it for now.  It is possible for another thread to be
				// going through the SetAppData code which changes this event handle.
				// The problem is if they change it after this IF statement, but
				// before we call SetEvent.  However, the SetEvent call will either
				// succeed on the new handle, or return an error if the handle is
				// changed to NULL.  In either case, no harm, no foul -- we don't care.
				if(!lpgn->hDupReceiveEvent)
				{
					DPF(8, "The Receive Event handle is NULL!");
					continue;
				}

				SetEvent(lpgn->hDupReceiveEvent);
			}
			else
			{
			no_queue:
				// Free the buffers
				DPMEM_FREE(lpm);
				DPMEM_FREE(lpBuffer);
			}
		}
	}

	DPF(8, "Lobby Receive Thread is going away!!!!!");
	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ReceiveClientNotification



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveNodeFromQueue"
void PRV_RemoveNodeFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDPLOBBYI_MESSAGE lpm)
{
	DPF(7, "Entering PRV_RemoveNodeFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpgn, lpm);

	ASSERT(lpgn);
	ASSERT(lpm);

	// Delete the message from the queue & decrement the count
	lpm->lpPrev->lpNext = lpm->lpNext;
	lpm->lpNext->lpPrev = lpm->lpPrev;

	lpgn->dwMessageCount--;

	// Free the memory for the message node
	DPMEM_FREE(lpm->lpData);
	DPMEM_FREE(lpm);

} // PRV_RemoveNodeFromQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CleanUpQueue"
void PRV_CleanUpQueue(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_MESSAGE	lpm, lpmNext;


	DPF(7, "Entering PRV_CleanUpQueue");
	DPF(9, "Parameters: 0x%08x", lpgn);

	ASSERT(lpgn);

	lpm = lpgn->MessageHead.lpNext;
	while(lpm != &lpgn->MessageHead)
	{
		// Save the next pointer
		lpmNext = lpm->lpNext;

		// Remove the node
		PRV_RemoveNodeFromQueue(lpgn, lpm);

		// Move to the next node
		lpm = lpmNext;
	}


} // PRV_CleanUpQueue



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_KillThread"
void PRV_KillThread(HANDLE hThread, HANDLE hEvent)
{

	DPF(7, "Entering PRV_KillThread");
	DPF(9, "Parameters: 0x%08x, 0x%08x", hThread, hEvent);
	
	ASSERT(hThread);
	ASSERT(hEvent);
	
	// Signal the thread to die.
	SetEvent(hEvent);

	// Wait until the thread terminates, if it doesn't something is
	// wrong, so we better fix it.
	DPF(8, "Starting to wait for a thread to exit -- hThread = 0x%08x, hEvent = 0x%08x", hThread, hEvent);
	WaitForSingleObject(hThread, INFINITE);

	// Now close both handles
	CloseHandle(hThread);
	CloseHandle(hEvent);

} // PRV_KillThread



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeGameNode"
HRESULT PRV_FreeGameNode(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_BUFFERCONTROL	lpControl = NULL;


	DPF(7, "Entering PRV_FreeGameNode");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// FIRST: Take care of the connection settings data buffer
	// Unmap & release the shared memory
	if(lpgn->lpConnectDataBuffer)
		UnmapViewOfFile(lpgn->lpConnectDataBuffer);

	if(lpgn->hConnectDataFile)
		CloseHandle(lpgn->hConnectDataFile);

	if(lpgn->hConnectDataMutex)
		CloseHandle(lpgn->hConnectDataMutex);

	// NEXT: Take care of the App Data Events & Buffers
	// Kill the Receive Thread
	if(lpgn->hReceiveThread)
	{
		PRV_KillThread(lpgn->hReceiveThread, lpgn->hKillReceiveThreadEvent);
		CloseHandle(lpgn->hDupReceiveEvent);
	}

	// Close the event handles
	if(lpgn->hLobbyWriteEvent)
		CloseHandle(lpgn->hLobbyWriteEvent);

	if(lpgn->hGameWriteEvent)
		CloseHandle(lpgn->hGameWriteEvent);

	// Kill the Terminate Monitor Thread
	if(lpgn->hTerminateThread)
	{
		PRV_KillThread(lpgn->hTerminateThread, lpgn->hKillTermThreadEvent);
	}

	// Clear the flags since we are no longer going to be active
	if(lpgn->lpGameWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpGameWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	if(lpgn->lpLobbyWriteBuffer)
	{
		lpControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;
		lpControl->dwFlags &= ~((lpgn->dwFlags & GN_LOBBY_CLIENT) ?
					BC_LOBBY_ACTIVE : BC_GAME_ACTIVE);
	}

	// Unmap & release the Game Write memory
	if(lpgn->lpGameWriteBuffer)
		UnmapViewOfFile(lpgn->lpGameWriteBuffer);

	if(lpgn->hGameWriteFile)
		CloseHandle(lpgn->hGameWriteFile);

	if(lpgn->hGameWriteMutex)
		CloseHandle(lpgn->hGameWriteMutex);

	// Unmap & release the Lobby Write memory
	if(lpgn->lpLobbyWriteBuffer)
		UnmapViewOfFile(lpgn->lpLobbyWriteBuffer);

	if(lpgn->hLobbyWriteFile)
		CloseHandle(lpgn->hLobbyWriteFile);

	if(lpgn->hLobbyWriteMutex)
		CloseHandle(lpgn->hLobbyWriteMutex);

	// Clean up the message queue
	PRV_CleanUpQueue(lpgn);

	// Close the process handle we have for the game
	if(lpgn->hGameProcess)
		CloseHandle(lpgn->hGameProcess);

	if(lpgn->hLobbyClientProcess)
		CloseHandle(lpgn->hLobbyClientProcess);
	
	// Free the game node structure
	DPMEM_FREE(lpgn);

	return DP_OK;

} // PRV_FreeGameNode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DuplicateHandle"
HANDLE PRV_DuplicateHandle(HANDLE hSource)
{
	HANDLE					hProcess = NULL;
	HANDLE					hTarget = NULL;
	DWORD					dwProcessID;
	DWORD					dwError;


	DPF(7, "Entering PRV_DuplicateHandle");
	DPF(9, "Parameters: 0x%08x", hSource);

	dwProcessID = GetCurrentProcessId();
	hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessID);
	if(!DuplicateHandle(hProcess, hSource, hProcess, &hTarget,
					0L, FALSE, DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		CloseHandle(hProcess);
		return NULL;
	}

	CloseHandle(hProcess);
	return hTarget;

} // PRV_DuplicateHandle



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetLobbyMessageEvent"
HRESULT DPLAPI DPL_SetLobbyMessageEvent(LPDIRECTPLAYLOBBY lpDPL,
									DWORD dwFlags, DWORD dwGameID,
									HANDLE hReceiveEvent)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPVOID						lpBuffer = NULL;
	HANDLE						hReceiveThread = NULL;
	HANDLE						hDupReceiveEvent = NULL;
	HRESULT						hr;
	BOOL						bCreated = FALSE;
	BOOL						bLobbyClient = TRUE;
	BOOL						bNewEvent = FALSE;


	DPF(7, "Entering DPL_SetLobbyMessageEvent");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, hReceiveEvent);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		// Validate the handle
		if(hReceiveEvent)
		{
			if(!OS_IsValidHandle(hReceiveEvent))
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid hReceiveEvent handle");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// If the dwGameID is zero, we assume we are a game.  In that case,
	// the GameNode we are looking for should have our own ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	ENTER_DPLGAMENODE();
	
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);


	// If the event handle is null, kill our duplicate handle
	if(!hReceiveEvent)
	{
		if(!lpgn)
		{
			DPF(5, "Unable to find GameNode -- Invalid dwGameID!");
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_GENERIC;
		}

		CloseHandle(lpgn->hDupReceiveEvent);
		lpgn->hDupReceiveEvent = NULL;
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DP_OK;
	}

	// If a GameNode structure exists for this process, we must be trying
	// to replace the event handle, so kill the old event handle, OTHERWISE
	// we need to allocate a new GameNode for this process
	if(lpgn)
	{
		if(lpgn->hDupReceiveEvent)
		{
			CloseHandle(lpgn->hDupReceiveEvent);
			lpgn->hDupReceiveEvent = NULL;
		}
	}
	else
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
			{
				LEAVE_DPLGAMENODE();
				LEAVE_DPLOBBY();
				return hr;
			}
		}
		else
		{
			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}

	}

	// Duplicate the caller's handle in case they free it without calling
	// us first to remove the Receive thread.
	hDupReceiveEvent = PRV_DuplicateHandle(hReceiveEvent);
	if(!hDupReceiveEvent)
	{
		DPF(2, "Unable to duplicate ReceiveEvent handle");
		LEAVE_DPLGAMENODE();
		LEAVE_DPLOBBY();
		return DPERR_OUTOFMEMORY;
	}

	if(!lpgn->hDupReceiveEvent)
		bNewEvent = TRUE;
	lpgn->hDupReceiveEvent = hDupReceiveEvent;

	// Check to see if the Receive thread already exists. If it
	// doesn't, create it.  Otherwise, leave it alone.
	if(!(lpgn->hReceiveThread))
	{
		hr = PRV_StartReceiveThread(lpgn);
		if(FAILED(hr))
		{
			if(lpgn->hDupReceiveEvent)
			{
				CloseHandle(lpgn->hDupReceiveEvent);
				lpgn->hDupReceiveEvent = NULL;
			}

			LEAVE_DPLGAMENODE();
			LEAVE_DPLOBBY();
			return hr;
		}
	}

	// If this is a new event, check to see if there are any messages in the
	// queue.  If there are, kick the event so the user knows they are there.
	if(bNewEvent && lpgn->dwMessageCount)
		SetEvent(hDupReceiveEvent);

	LEAVE_DPLGAMENODE();
	LEAVE_DPLOBBY();
	return DP_OK;

} // DPL_SetLobbyMessageEvent


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SendLobbyMessage"
HRESULT DPLAPI DPL_SendLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPVOID lpData, DWORD dwSize)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
	LPDPLMSG_GENERIC		lpmsg = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;
	BOOL					bStandard = FALSE;


	DPF(7, "Entering DPL_SendLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwFlags, dwGameID, lpData, dwSize);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

        if( !VALID_READ_PTR( lpData, dwSize ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
        }

		// Check for valid flags
		if( !VALID_SENDLOBBYMESSAGE_FLAGS(dwFlags))
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}

		// If it's of the system message format, validate the dwType
		if( dwFlags & DPLMSG_STANDARD )
		{
			// Mark this as a standard message
			bStandard = TRUE;
			
			// Make sure the message is big enough to read
			if(! VALID_READ_PTR( lpData, sizeof(DPLMSG_GENERIC)) )
			{
				LEAVE_DPLOBBY();
				DPF_ERR("Invalid message buffer");
				return DPERR_INVALIDPARAMS;
			}
			
			// Make sure it's one we support
			lpmsg = (LPDPLMSG_GENERIC)lpData;			
			switch(lpmsg->dwType)
			{
				case DPLSYS_GETPROPERTY:
				case DPLSYS_SETPROPERTY:
					break;
				default:
					DPF_ERR("The dwType of the message is invalid for a legal standard lobby message");
					LEAVE_DPLOBBY();
					return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		LEAVE_DPLOBBY();
		DPF_ERR("Invalid dwGameID");
		return DPERR_INVALIDPARAMS;
	}

	// If we are self-lobbied, we need to send the message onto the lobby
	// using the IDP3 interface that we are communicating with the lobby on
	// If not, we need to put it in the shared buffer and let the lobby
	// client deal with it.
	if(lpgn->dwFlags & GN_SELF_LOBBIED)
	{
		// Drop the lobby lock so we can call PRV_Send
		LEAVE_DPLOBBY();
		
		// Foward the message
		hr = PRV_ForwardMessageToLobbyServer(lpgn, lpData, dwSize, bStandard);
		
		// Take the lock back
		ENTER_DPLOBBY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to send lobby system message, hr = 0x%08x", hr);
		}
	}
	else
	{
		// Write the data to our shared memory
		hr = PRV_WriteClientData(lpgn, dwFlags, lpData, dwSize);
	}

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SendLobbyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetMessageFromQueue"
HRESULT PRV_GetMessageFromQueue(LPDPLOBBYI_GAMENODE lpgn, LPDWORD lpdwFlags,
								LPVOID lpData, LPDWORD lpdwSize)
{
	LPDPLOBBYI_MESSAGE	lpm;


	DPF(7, "Entering PRV_GetMessageFromQueue");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpgn, lpdwFlags, lpData, lpdwSize);

	ENTER_DPLQUEUE();

	// Get the top message in the queue
	lpm = lpgn->MessageHead.lpNext;

	// Make sure we have a message
	if((!lpgn->dwMessageCount) || (lpm == &lpgn->MessageHead))
	{
		LEAVE_DPLQUEUE();
		return DPERR_NOMESSAGES;
	}

	// If the lpData pointer is NULL, just return the size
	if(!lpData)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}

	// Otherwise, check the remaining output parameters
	if( !VALIDEX_CODE_PTR( lpData ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	if( !VALID_DWORD_PTR( lpdwFlags ) )
	{
		LEAVE_DPLQUEUE();
		return DPERR_INVALIDPARAMS;
	}

	// Copy the message
	if(*lpdwSize < lpm->dwSize)
	{
		*lpdwSize = lpm->dwSize;
		LEAVE_DPLQUEUE();
		return DPERR_BUFFERTOOSMALL;
	}
	else
		memcpy(lpData, lpm->lpData, lpm->dwSize);

	// Set the other output parameters
	*lpdwSize = lpm->dwSize;
	*lpdwFlags = lpm->dwFlags;


	// Delete the message from the queue & decrement the count
	PRV_RemoveNodeFromQueue(lpgn, lpm);

	// Check and see if our GAMENODE is dead.  If it is, and if the message
	// count has gone to zero, then free the GAMENODE structure.
	if((!lpgn->dwMessageCount) && IS_GAME_DEAD(lpgn))
		PRV_RemoveGameNodeFromList(lpgn);

	LEAVE_DPLQUEUE();
	return DP_OK;

} // PRV_GetMessageFromQueue


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ReceiveLobbyMessage"
HRESULT DPLAPI DPL_ReceiveLobbyMessage(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID, LPDWORD lpdwMessageFlags, LPVOID lpData,
					LPDWORD lpdwDataLength)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr = DP_OK;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering DPL_ReceiveLobbyMessage");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
		lpDPL, dwFlags, dwGameID, lpdwMessageFlags, lpData, lpdwDataLength);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwDataLength ) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDPARAMS;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            LEAVE_DPLOBBY();
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If a GameID was passed in, use it to find the correct GameNode.  If
	// one wasn't passed in, assume we are the game and use our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	// Now find the correct game node.  If we don't find it, assume we
	// have an invalid ID and error out.
	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		DPF_ERR("Invalid dwGameID");
		hr = DPERR_INVALIDPARAMS;
		goto EXIT_RECEIVE_LOBBY_MESSAGE;
	}

	// Read the data from shared memory
	hr = PRV_GetMessageFromQueue(lpgn, lpdwMessageFlags, lpData, lpdwDataLength);

	// REVIEW!!!! -- Do we need to send this to the lobby server as part of this API????

EXIT_RECEIVE_LOBBY_MESSAGE:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_ReceiveLobbyMessage


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_WriteConnectionSettings"
HRESULT PRV_WriteConnectionSettings(LPDPLOBBYI_GAMENODE lpgn,
			LPDPLCONNECTION lpConn, BOOL bOverrideWaitMode)
{
    HRESULT					hr;
	DWORD					dwSize;
	BOOL					bGameCreate = FALSE;
	LPBYTE					lpConnBuffer = NULL;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;


	DPF(7, "Entering PRV_WriteConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpgn, lpConn, bOverrideWaitMode);

	ENTER_DPLGAMENODE();

	// Make sure we have a valid shared memory buffer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// HACK!!!! -- SetConnectionSettings may get called from the game
		// without having been lobbied.  If that is the case, we need to
		// create the shared memory with the game's process ID (this process)
		if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
		{
			// Fake the setup routine by setting the lobby client flag
			lpgn->dwFlags |= GN_LOBBY_CLIENT;

			// Set our flag
			bGameCreate = TRUE;
		}

		hr = PRV_SetupAllSharedMemory(lpgn);

		// HACK!!!! -- Reset the settings we changed to fake the setup routines
		if(bGameCreate)
		{
			lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
		}

		// Now handle the failure
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(2, "Unable to access Connection Settings memory");
			return hr;
		}
	}

	// If the ConnectionSettings come from a StartSession message, we need to
	// pick the dplay object pointer out of the DPLCONNECTION structure's
	// reserved field.  This pointer to a dplay object represents the object
	// that has a connection to the lobby server.
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Save the pointer and player ID in our gamenode structure
		lpgn->lpDPlayObject = (LPDPLAYI_DPLAY)lpConn->lpSessionDesc->dwReserved1;
		lpgn->dpidPlayer = (DWORD)lpConn->lpSessionDesc->dwReserved2;

		// Clear the field
		lpConn->lpSessionDesc->dwReserved1 = 0L;
		lpConn->lpSessionDesc->dwReserved2 = 0L;
	}

	// Save the instance pointer for the system messages
	lpgn->guidInstance = lpConn->lpSessionDesc->guidInstance;

	// Get the packaged size of the DPLCONNECTION structure
	PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSize, NULL);

	// Check data sizes
	if(dwSize > (MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE))
	{
		DPF(2, "Packaged Connection Settings exceeded max buffer size of %d",
				(MAX_APPDATABUFFERSIZE - APPDATA_RESERVEDSIZE));
		LEAVE_DPLGAMENODE();
		return DPERR_BUFFERTOOLARGE;
	}

	// Make sure we have the mutex for the shared conn settings buffer
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Look at the control block to see if we are in wait mode
	// If we are, and this is not a call from RunApplication, then
	// we don't want to write the connection settings
	hr = DPERR_UNAVAILABLE;		// Default set to error
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((!(lpConnControl->dwFlags & BC_WAIT_MODE)) || bOverrideWaitMode)
	{
		// Get a pointer to the actual buffer
		lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);

		// Package the connection settings into the buffer
		hr = PRV_PackageDPLCONNECTION(lpConn, lpConnBuffer, TRUE);
		
		// If it succeeded, and we were overriding wait mode, we need
		// to take the buffers out of wait mode and send the new connection
		// settings available message
		if(SUCCEEDED(hr) && bOverrideWaitMode)
		{
			// Take the buffers out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
		}
	}

	ReleaseMutex(lpgn->hConnectDataMutex);

	LEAVE_DPLGAMENODE();
	return hr;

} // PRV_WriteConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetConnectionSettings"
HRESULT PRV_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags,
					DWORD dwGameID,	LPDPLCONNECTION lpConn)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		// Validate the DPLCONNECTION structure
		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;

	}
	
	// If the ConnectionSettings are from a StartSession message (lobby launched),
	// we need to set the flag saying we are self-lobbied
	if(lpConn->lpSessionDesc->dwReserved1)
	{
		// Set the flag that says we were lobby client launched
		lpgn->dwFlags |= GN_SELF_LOBBIED;
	}

	// Write the connection settings to our shared buffer
	hr = PRV_WriteConnectionSettings(lpgn, lpConn, FALSE);

	return hr;

} // PRV_SetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetConnectionSettings"
HRESULT DPLAPI DPL_SetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwFlags, DWORD dwGameID, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwFlags, dwGameID, lpConn);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetConnectionSettings(lpDPL, dwFlags, dwGameID, lpConn);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_SetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ReadConnectionSettings"
HRESULT PRV_ReadConnectionSettings(LPDPLOBBYI_GAMENODE lpgn, LPVOID lpData,
											LPDWORD lpdwSize, BOOL bAnsi)
{
    HRESULT					hr = DP_OK;
	LPDWORD					lpdwBuffer;
	LPDPLOBBYI_CONNCONTROL	lpConnControl = NULL;
	LPBYTE					lpConnBuffer = NULL;
	DWORD					dwSize = 0,
							dwSizeAnsi,
							dwSizeUnicode;


	DPF(7, "Entering PRV_ReadConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, %lu",
			lpgn, lpData, lpdwSize, bAnsi);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF(5, "Unable to access Connect Data memory");
			return DPERR_NOTLOBBIED;
		}
	}

	// Grab the shared buffer mutex
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);

	// Make sure we are not in wait mode without being in pending mode
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if((lpConnControl->dwFlags & BC_WAIT_MODE) &&
		!(lpConnControl->dwFlags & BC_PENDING_CONNECT))
	{
		hr = DPERR_UNAVAILABLE;
		goto EXIT_READ_CONN_SETTINGS;
	}

	if(!(lpgn->dwFlags & GN_LOBBY_CLIENT)){
		lpgn->dwLobbyClientProcessID = lpConnControl->CliProcId;
		lpgn->hLobbyClientProcess = OpenProcess(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE ,FALSE, lpgn->dwLobbyClientProcessID);

		if(!lpgn->hLobbyClientProcess){
			#ifdef DEBUG
				DWORD err;
				err = GetLastError();
				DPF(0,"Couldn't get lobby client processId %d, extended error %d\n",lpConnControl->CliProcId,err);
			#endif
			// lobby client is already dead, don't allow settings across.
			hr = DPERR_UNAVAILABLE;
			goto EXIT_READ_CONN_SETTINGS;
		}
	}

	// Take us out of wait mode and pending mode
	PRV_LeaveConnSettingsWaitMode(lpgn);

	// Verify that the buffer is big enough.  If it's not, OR if the lpData
	// buffer pointer is NULL, just set the lpdwSize parameter to the
	// correct size and return an error.  Note: In our packed structure, the
	// first DWORD is the size of the packed structure with Unicode strings
	// and the second DWORD is the size of the packed structure with ANSI.
	lpConnBuffer = (LPBYTE)lpConnControl + sizeof(DPLOBBYI_CONNCONTROL);
	lpdwBuffer = (LPDWORD)lpConnBuffer;
	dwSizeUnicode = *lpdwBuffer++;
	dwSizeAnsi = *lpdwBuffer;
	dwSize = (bAnsi) ? dwSizeAnsi : dwSizeUnicode;

	if(dwSize > MAX_APPDATABUFFERSIZE-sizeof(DPLOBBYI_CONNCONTROL)){
		DPF(4,"SECURITY WARN: illegal size in settings shared memory buffer");
		hr=DPERR_NOTLOBBIED;
		goto EXIT_READ_CONN_SETTINGS;
	}

	if(((*lpdwSize) < dwSize) || (!lpData))
	{
		if(bAnsi)
			*lpdwSize = dwSizeAnsi;
		else		
			*lpdwSize = dwSizeUnicode;

		hr = DPERR_BUFFERTOOSMALL;
		goto EXIT_READ_CONN_SETTINGS;
	}

	// Copy the DPLCONNECTION structure, taking the ANSI conversion
	// into account if necessary.
	if(bAnsi)
		hr = PRV_UnpackageDPLCONNECTIONAnsi(lpData, lpConnBuffer);
	else
		hr = PRV_UnpackageDPLCONNECTIONUnicode(lpData, lpConnBuffer);

	// If we haven't yet saved off the Instance guid for the game, save
	// it now so that we have it for the system messages
	if(IsEqualGUID(&lpgn->guidInstance, &GUID_NULL))
		lpgn->guidInstance = ((LPDPLCONNECTION)lpData)->lpSessionDesc->guidInstance;

	// Fall through

EXIT_READ_CONN_SETTINGS:

	ReleaseMutex(lpgn->hConnectDataMutex);
	LEAVE_DPLGAMENODE();
	return hr;	

} // PRV_ReadConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetConnectionSettings"
HRESULT PRV_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwGameID,
							LPVOID lpData, LPDWORD lpdwSize, BOOL bAnsi)
{
    LPDPLOBBYI_DPLOBJECT	this;
	LPDPLOBBYI_GAMENODE		lpgn = NULL;
    HRESULT					hr;
	BOOL					bLobbyClient = TRUE;


	DPF(7, "Entering PRV_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDPL, dwGameID, lpData, lpdwSize, bAnsi);

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return DPERR_INVALIDOBJECT;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// If dwGameID is zero, we assume we are a game.  In that case, the
	// GameNode we are looking for should have our ProcessID.
	if(!dwGameID)
	{
		dwGameID = GetCurrentProcessId();
		bLobbyClient = FALSE;
	}

	lpgn = PRV_GetGameNode(this->lpgnHead, dwGameID);
	if(!lpgn)
	{
		// If we are a game, go ahead and create the node
		if(!bLobbyClient)
		{
			hr = PRV_AddNewGameNode(this, &lpgn, dwGameID, NULL, bLobbyClient,NULL);
			if(FAILED(hr))
				return hr;
		}
		else
			return DPERR_INVALIDPARAMS;
	}
	
	// Read the data from our shared memory
	hr = PRV_ReadConnectionSettings(lpgn, lpData, lpdwSize, bAnsi);

	return hr;

} // PRV_GetConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetConnectionSettings"
HRESULT DPLAPI DPL_GetConnectionSettings(LPDIRECTPLAYLOBBY lpDPL,
				DWORD dwGameID, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDPL, dwGameID, lpData, lpdwSize);

    ENTER_DPLOBBY();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetConnectionSettings(lpDPL, dwGameID, lpData,
									lpdwSize, FALSE);

	LEAVE_DPLOBBY();
	return hr;

} // DPL_GetConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_RemoveGameNodeFromList"
void PRV_RemoveGameNodeFromList(LPDPLOBBYI_GAMENODE lpgn)
{
	LPDPLOBBYI_GAMENODE	lpgnTemp;
	BOOL				bFound = FALSE;


	DPF(7, "Entering PRV_RemoveGameNodeFromList");
	DPF(9, "Parameters: 0x%08x", lpgn);

	// Get the head pointer
	lpgnTemp = lpgn->this->lpgnHead;

	// Make sure it's not the first node.  If it is, move the head pointer
	if(lpgnTemp == lpgn)
	{
		lpgn->this->lpgnHead = lpgn->lpgnNext;
		PRV_FreeGameNode(lpgn);
		return;
	}

	// Walk the list looking for the previous node
	while(lpgnTemp)
	{
		if(lpgnTemp->lpgnNext == lpgn)
		{
			bFound = TRUE;
			break;
		}

		lpgnTemp = lpgnTemp->lpgnNext;
	}

	if(!bFound)
	{
		DPF_ERR("Unable to remove GameNode from list!");
		return;
	}

	// We've now got it's previous one, so remove it from the linked list
	// and delete it.
	lpgnTemp->lpgnNext = lpgn->lpgnNext;
	PRV_FreeGameNode(lpgn);

	return;

}  // PRV_RemoveGameNodeFromList



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ClientTerminateNotification"
DWORD WINAPI PRV_ClientTerminateNotification(LPVOID lpParam)
{
    LPDPLOBBYI_GAMENODE		lpgn = (LPDPLOBBYI_GAMENODE)lpParam;
	DPLMSG_SYSTEMMESSAGE	msg;
	HANDLE					hObjects[3];
	HRESULT					hr;
	DWORD					dwResult;
	DWORD					dwError;


	DPF(7, "Entering PRV_ClientTerminateNotification");
	DPF(9, "Parameters: 0x%08x", lpParam);

	// Setup the objects to wait on -- one process handle, one kill event
	hObjects[0] = lpgn->hGameProcess;
	hObjects[1] = lpgn->hKillTermThreadEvent;
	// This extra handle is here because of a Windows 95 bug.  Windows
	// will occasionally miss when it walks the handle table, causing
	// my thread to wait on the wrong handles.  By putting a guaranteed
	// invalid handle at the end of our array, the kernel will do a
	// forced re-walk of the handle table and find the correct handles.
	hObjects[2] = INVALID_HANDLE_VALUE;

	// Wait for the event notification
	while(1)
	{
		// Wait for the process to go away
		dwResult = WaitForMultipleObjects(2, (HANDLE *)hObjects,
											FALSE, INFINITE);

		// If we are signalled by anything but the process going away,
		// just kill the thread.
		if(dwResult != WAIT_OBJECT_0)
		{
			if(dwResult == WAIT_FAILED)
			{
				// This is a Windows 95 bug -- We may have gotten
				// kicked for no reason.  If that was the case, we
				// still have valid handles (we think), the OS
				// just goofed up.  So, validate the handle and if
				// they are valid, just return to waiting.  See
				// bug #3340 for a better explanation.
				dwError = GetLastError();
				if(ERROR_INVALID_HANDLE == dwError)
				{
					DPF(1, "Wait for client termination failed due to invalid handle.");
					if(!OS_IsValidHandle(hObjects[0]))
						break;
					if(!OS_IsValidHandle(hObjects[1]))
						break;
					continue;
				}
				DPF(0, "Wait for client termination failed (err = %u)!", dwError);
				break;
			}
			else
			{
				// This is something we don't understand, so just go away.
				DPF(1, "Exiting thread (result = %u).", dwResult);
				ExitThread(0L);
				return 0L;
			}
		}
		else
		{
			// This is our process handle going away, so bail out of
			// the wait loop and send the system message.
			DPF(2, "Client terminated.");
			break;
		}
	}

	// Send the system message which says the app terminated
	memset(&msg, 0, sizeof(DPLMSG_SYSTEMMESSAGE));
	msg.dwType = DPLSYS_APPTERMINATED;
	msg.guidInstance = lpgn->guidInstance;
	hr = PRV_InjectMessageInQueue(lpgn, DPLAD_SYSTEM, &msg,
							sizeof(DPLMSG_SYSTEMMESSAGE), TRUE);
	if(FAILED(hr))
	{
		DPF(0, "Failed to send App Termination message, hr = 0x%08x", hr);
	}

	// Mark the GAMENODE as dead, but don't remove it since we know
	// there are still messages in the queue.
	lpgn->dwFlags |= GN_DEAD_GAME_NODE;

	ExitThread(0L);

	return 0L; // avoid warning.
} // PRV_ClientTerminateNotification



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_WaitForConnectionSettings"
HRESULT DPLAPI DPL_WaitForConnectionSettings(LPDIRECTPLAYLOBBY lpDPL, DWORD dwFlags)
{
    LPDPLOBBYI_DPLOBJECT		this;
	LPDPLOBBYI_GAMENODE			lpgn = NULL;
	LPDPLOBBYI_CONNCONTROL		lpConnControl = NULL;
	LPDPLOBBYI_BUFFERCONTROL	lpBuffControl = NULL;
	HRESULT						hr = DP_OK;
	BOOL						bCreated = FALSE;
	DWORD						dwProcessID;
	BOOL						bGameCreate = FALSE;
	BOOL						bMessages = TRUE;


	DPF(7, "Entering DPL_WaitForConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDPL, dwFlags);

    ENTER_DPLOBBY();

    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
			return DPERR_INVALIDOBJECT;
        }

		if(!VALID_WAIT_FLAGS(dwFlags))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Get the game node
	dwProcessID = GetCurrentProcessId();
	lpgn = PRV_GetGameNode(this->lpgnHead, dwProcessID);
	if(!lpgn)
	{
		// Create the game node
		hr = PRV_AddNewGameNode(this, &lpgn, dwProcessID, NULL, FALSE, NULL);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating game node, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}

		// Set our flag saying we just created the game node
		bCreated = TRUE;
	}

	// when doing a wait for connection settings, we do NOT use the
	// IPC_GUID, this is because the lobby launching us may not have
	// provided the GUID.
	lpgn->dwFlags &= ~(GN_IPCGUID_SET);

	// Make sure we have a valid memory pointer
	// Note: Take the GameNode lock so that nobody changes the flags
	// for the buffers, or the buffers themselves out from under us.
	ENTER_DPLGAMENODE();
	if(!(lpgn->dwFlags & GN_SHARED_MEMORY_AVAILABLE))
	{
		// First we need to try to setup access to the buffers assuming
		// they already exist (we were lobby launched).  If this doesn't
		// work, then we need to create them.
		hr = PRV_SetupAllSharedMemory(lpgn);
		if(FAILED(hr))
		{
			// We don't have any memory, so set it up
			// HACK!!!! -- WaitForConnectionSettings may get called from the game
			// without having been lobbied.  If that is the case, we need to
			// create the shared memory with the game's process ID (this process)
			// so we'll set the lobby client flag to fake out the creation
			if(!(lpgn->dwFlags & GN_LOBBY_CLIENT))
			{
				// Fake the setup routine by setting the lobby client flag
				lpgn->dwFlags |= GN_LOBBY_CLIENT;

				// Set our flag
				bGameCreate = TRUE;
			}

			// Setup the shared buffers
			hr = PRV_SetupAllSharedMemory(lpgn);

			// HACK!!!! -- Reset the settings we changed to fake the setup routines
			if(bGameCreate)
			{
				lpgn->dwFlags &= (~GN_LOBBY_CLIENT);
			}
		}

		if(FAILED(hr))
		{
			LEAVE_DPLGAMENODE();
			DPF_ERRVAL("Unable to access Connect Data memory, hr = 0x%08x", hr);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Drop the lock
	LEAVE_DPLGAMENODE();

	// If we are in wait mode, and the caller wants to end it, do so,
	// otherwise, just return success
	WaitForSingleObject(lpgn->hConnectDataMutex, INFINITE);
	lpConnControl = (LPDPLOBBYI_CONNCONTROL)lpgn->lpConnectDataBuffer;
	if(lpConnControl->dwFlags & BC_WAIT_MODE)
	{
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Take us out of wait mode
			PRV_LeaveConnSettingsWaitMode(lpgn);
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
		else
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			// Might as well just return OK since we're already doing it
			DPF_ERR("We're already in wait mode");
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}
	else
	{
		// We're not it wait mode, and the caller asked us to turn it off
		if(dwFlags & DPLWAIT_CANCEL)
		{
			// Release Mutex
			ReleaseMutex(lpgn->hConnectDataMutex);

			DPF_ERR("Cannot turn off wait mode - we're not in wait mode");
			hr = DPERR_UNAVAILABLE;
			goto EXIT_WAIT_FOR_CONN_SETTINGS;
		}
	}

	// Release Mutex
	ReleaseMutex(lpgn->hConnectDataMutex);

	// See if a lobby client exists on the other side, if it does, we
	// need to tell him we are going into wait mode by sending him an
	// AppTerminated message.
	PRV_SendStandardSystemMessage(lpDPL, DPLSYS_APPTERMINATED, 0);

	// Go into wait mode
	PRV_EnterConnSettingsWaitMode(lpgn);

	// Kick the receive thread to empty the buffer (just in case there
	// are any messages in it)
	SetEvent(lpgn->hLobbyWriteEvent);

	// Spin waiting for the buffer to get emptied
	while(bMessages)
	{
		// Grab the mutex for the lobby write buffer
		WaitForSingleObject(lpgn->hLobbyWriteMutex, INFINITE);
		lpBuffControl = (LPDPLOBBYI_BUFFERCONTROL)lpgn->lpLobbyWriteBuffer;

		if(!lpBuffControl->dwMessages)
			bMessages = FALSE;

		// Drop the mutex
		ReleaseMutex(lpgn->hLobbyWriteMutex);

		if(bMessages)
		{
			// Now sleep to give the receive thread a chance to work
			Sleep(50);
		}
	}

	// Now clean out the message queue
	PRV_CleanUpQueue(lpgn);

	// Fall through

EXIT_WAIT_FOR_CONN_SETTINGS:

	LEAVE_DPLOBBY();
	return hr;

} // DPL_WaitForConnectionSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplunk.c
 *  Content:	IUnknown implementation for dplobby
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	4/13/96		myronth	Created it
 *	10/23/96	myronth	Added client/server methods
 *	11/08/96	myronth	Added PRV_GetDPLobbySPInterface
 *	11/20/96	myronth	Added LogoffServer call to Release code
 *	2/12/97		myronth	Mass DX5 changes
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/12/97		myronth	New release code for DPlay3 (order different)
 *	3/13/97		myronth	Added FreeLibrary code for LP's
 *	3/17/97		myronth	Cleanup map table
 *	3/24/97		kipo	Added support for IDirectPlayLobby2 interface
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/8/97		myronth	Drop the lobby lock when calling the LP, Purged
 *						dead code
 *	7/30/97		myronth	Added request node cleanup for standard lobby messaging
 *	8/19/97		myronth Added PRV_GetLobbyObjectFromInterface
 *	8/19/97		myronth	Removed PRV_GetLobbyObjectFromInterface (not needed)
 *	12/2/97		myronth	Added IDirectPlayLobby3 interface
 *  2/2/99		aarono  Added lobbies to refcount on DPLAY dll to avoid
 *                      accidental unload.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLobbySPInterface"
LPDPLOBBYSP PRV_GetDPLobbySPInterface(LPDPLOBBYI_DPLOBJECT this)
{
	LPDPLOBBYI_INTERFACE	lpInt;


	ASSERT(this);

	// Get an IDPLobbySP interface
	if(FAILED(PRV_GetInterface(this, &lpInt, &dplCallbacksSP)))
	{
		DPF_ERR("Unable to get non-reference counted DPLobbySP Interface pointer");
		ASSERT(FALSE);
		return NULL;
	}

	// Decrement the ref cnt on the interface
	lpInt->dwIntRefCnt--;

	// Return the interface pointer
	return (LPDPLOBBYSP)lpInt;

} // PRV_GetDPLobbySPInterface

// Find an interface with the pCallbacks vtbl on this object.
// If one doesn't exist, create it, increment the ref count,
// and return the interface
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetInterface"
HRESULT PRV_GetInterface(LPDPLOBBYI_DPLOBJECT this,
							LPDPLOBBYI_INTERFACE * ppInt,
							LPVOID lpCallbacks)
{
	LPDPLOBBYI_INTERFACE	lpCurrentInts = this->lpInterfaces;
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_GetInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, ppInt, lpCallbacks);

	ASSERT(ppInt);

	// See if there is already an interface
	while (lpCurrentInts && !bFound)
	{
		if (lpCurrentInts->lpVtbl == lpCallbacks)
		{
			bFound = TRUE;
		}
		else
			lpCurrentInts = lpCurrentInts->lpNextInterface;
	}

	// If there is one, return it
	if(bFound)
	{
		*ppInt = lpCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}

	// Otherwise create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLOBBYI_INTERFACE));
	if (!(*ppInt)) 
	{
		DPF_ERR("Could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPLobby = this;
	(*ppInt)->lpNextInterface = this->lpInterfaces;
	(*ppInt)->lpVtbl = lpCallbacks;

	this->lpInterfaces = *ppInt;
	this->dwRefCnt++;				// One time only for each interface object
	return DP_OK;
	
} // PRV_GetInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_QueryInterface"
HRESULT DPLAPI DPL_QueryInterface(LPDIRECTPLAYLOBBY lpDPL, REFIID riid, LPVOID * ppvObj) 
{
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr;


	DPF(7, "Entering DPL_QueryInterface");
	DPF(9, "Parameters: 0x%08x, refiid, 0x%08x", lpDPL, ppvObj);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDINTERFACE;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }

		if ( !VALID_READ_UUID_PTR(riid) )
		{
			LEAVE_DPLOBBY();
			return DPERR_INVALIDPARAMS;
		}
		
		if ((!VALID_UUID_PTR(ppvObj)) )
		{
			LEAVE_DPLOBBY();
			DPF_ERR("Object pointer is invalid!");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;
        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		// Get an IDirectPlayLobby Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobbyA) )
	{
		// Get an IDirectPlayLobbyA Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacksA);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2) )
    {
		// Get an IDirectPlayLobby2 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby2A) )
	{
		// Get an IDirectPlayLobby2A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks2A);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3) )
    {
		// Get an IDirectPlayLobby3 Interface (Unicode)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3);
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayLobby3A) )
	{
		// Get an IDirectPlayLobby3A Interface (ANSI)
		hr = PRV_GetInterface(this, (LPDPLOBBYI_INTERFACE *) ppvObj,
							&dplCallbacks3A);
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLOBBY();
    return hr;

} //DPL_QueryInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_AddRef"
ULONG DPLAPI DPL_AddRef(LPDIRECTPLAYLOBBY lpDPL) 
{
	LPDPLOBBYI_INTERFACE lpInt = (LPDPLOBBYI_INTERFACE)lpDPL;    
    LPDPLOBBYI_DPLOBJECT this;


	DPF(7, "Entering DPL_AddRef");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    ENTER_DPLOBBY();
    
    TRY
    {
		if( !VALID_DPLOBBY_INTERFACE( lpDPL ))
		{
			LEAVE_DPLOBBY();
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLOBBY();
        return 0;
    }


	// Make sure someone isn't calling AddRef on our IDPLobbySP interface
	if(lpInt->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call AddRef on an IDPLobbySP interface");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return 0;
	}

	// Increment the interface's reference count
    lpInt->dwIntRefCnt++;
        
    LEAVE_DPLOBBY();
    return (lpInt->dwIntRefCnt);

} //DPL_AddRef


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobby"
HRESULT PRV_DestroyDPLobby(LPDPLOBBYI_DPLOBJECT this) 
{
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_DestroyDPLobby");
	DPF(9, "Parameters: 0x%08x", this);

	// Since we can now be called from the DPlay3 object's Release code,
	// make sure we don't have any interface objects when we go to
	// free our lobby object.  Assert here if any interfaces exist.
	ASSERT(!this->lpInterfaces);

	// Walk the list of GameNodes, freeing them as you go
	while(this->lpgnHead)
		PRV_RemoveGameNodeFromList(this->lpgnHead);

	// Walk the list of pending lobby server requests and free them
	while(this->lprnHead)
		PRV_RemoveRequestNode(this, this->lprnHead);

	// Free our callback table if one exists
	if(this->pcbSPCallbacks)
		DPMEM_FREE(this->pcbSPCallbacks);

	// Free our ID Map Table if it exists
	if(this->lpMap)
		DPMEM_FREE(this->lpMap);

	// Free the dplobby object
	DPMEM_FREE(this);	

	gnObjects--;

	ASSERT(((int)gnObjects) >= 0);

	return DP_OK;

} // PRV_DestroyDPlayLobby


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyDPLobbyInterface"
HRESULT  PRV_DestroyDPLobbyInterface(LPDPLOBBYI_DPLOBJECT this,
								LPDPLOBBYI_INTERFACE lpInterface)
{
	LPDPLOBBYI_INTERFACE	lpIntPrev; // The interface preceeding pInt in the list
	BOOL					bFound = FALSE;


	DPF(7, "Entering PRV_DestroyDPLobbyInterface");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	// Remove pInt from the list of interfaces
	if (this->lpInterfaces == lpInterface)
	{
		// It's the 1st one, just remove it
		this->lpInterfaces = lpInterface->lpNextInterface;
	}
	else 
	{
		lpIntPrev = this->lpInterfaces;
		while (lpIntPrev && !bFound)
		{
			if (lpIntPrev->lpNextInterface == lpInterface)
			{
				bFound = TRUE;
			}
			else lpIntPrev = lpIntPrev->lpNextInterface;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		lpIntPrev->lpNextInterface = lpInterface->lpNextInterface;
		
	}

	DPMEM_FREE(lpInterface);
	return DP_OK;

} // PRV_DestroyDPLobbyInterface


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG PRV_Release(LPDPLOBBYI_DPLOBJECT this, LPDPLOBBYI_INTERFACE lpInterface)
{
	HRESULT				hr = DP_OK;
	SPDATA_SHUTDOWN		sdd;
	DWORD				dwError;


	DPF(7, "==> PRV_Release");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpInterface);

	ENTER_DPLOBBY();

	// Decrement the interface ref count
	if (0 == --(lpInterface->dwIntRefCnt))
	{
		LPDPLOBBYI_GAMENODE lpgn;
		// Notifying apps we launched that we are releasing
		// our lobby interface.
		lpgn=this->lpgnHead;
		while(lpgn){
			if(lpgn->dwFlags & GN_LOBBY_CLIENT) {
				hr=PRV_SendStandardSystemMessage((LPDIRECTPLAYLOBBY)lpInterface, DPLSYS_LOBBYCLIENTRELEASE, lpgn->dwGameProcessID);
				if(DP_OK != hr){
					DPF(0,"Couldn't send system message to game pid %x, hr=%x",lpgn->dwGameProcessID,hr);
				} else {
					DPF(9,"Told Process %x we are releasing the lobby interface",lpgn->dwGameProcessID);
				}
			}	
			lpgn=lpgn->lpgnNext;
		}	

		DPF(7,"Lobby interface Refcount hit 0, freeing\n");
		// Since we're destroying an interface, dec the object count
	    this->dwRefCnt--;
		
		// If our object ref cnt just went to zero, we need to call
		// shutdown in the LP if one is loaded
		if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
		{
			// Clear our stack-based structure
			memset(&sdd, 0, sizeof(SPDATA_SHUTDOWN));

			// Call the Shutdown method in the SP
			if(CALLBACK_EXISTS(Shutdown))
			{
				sdd.lpISP = PRV_GetDPLobbySPInterface(this);

				// Drop the lock so the lobby provider's receive thread can get back
				// in with other messages if they show up in the queue before our
				// CreatePlayer response (which always happens)
				LEAVE_DPLOBBY();
				hr = CALL_LP(this, Shutdown, &sdd);
				ENTER_DPLOBBY();
			}
			else 
			{
				// All LP's should support Shutdown
				ASSERT(FALSE);
				hr = DPERR_UNAVAILABLE;
			}
			
			if (FAILED(hr)) 
			{
				DPF_ERR("Could not invoke Shutdown method in the Service Provider");
			}
		}

		// REVIEW!!!! -- Are we going to have the same problem dplay has
		// with SP's hanging around and crashing after we go away?  We
		// need to make sure the LP goes away first.
		if(this->hInstanceLP)
		{
			DPF(7,"About to free lobby provider library, hInstance %x\n",this->hInstanceLP);
			if (!FreeLibrary(this->hInstanceLP))
			{
				dwError = GetLastError();
				DPF_ERRVAL("Unable to free Lobby Provider DLL, dwError = %lu", dwError);
				ASSERT(FALSE);
			}

			// Just to be safe
			this->hInstanceLP = NULL;
		}

		// If the interface is the IDPLobbySP interface, we had to have been
		// called from the DPlay3 release code, so clear the SP flag since
		// we are going to remove the IDPLobbySP interface just below here.
		this->dwFlags &= ~DPLOBBYPR_SPINTERFACE;

		// Take the interface out of the table
		hr = PRV_DestroyDPLobbyInterface(this, lpInterface);
		if (FAILED(hr)) 
		{
			DPF(0,"Could not destroy DPLobby interface! hr = 0x%08lx\n", hr);
			ASSERT(FALSE);
		}

		// Now destroy the interface if the ref cnt is 0
		if(0 == this->dwRefCnt)
	    {
			// Destroy the DPLobby object
			DPF(0,"Destroying DirectPlayLobby object - ref cnt = 0!");
			hr = PRV_DestroyDPLobby(this);
			if (FAILED(hr)) 
			{
				DPF(0,"Could not destroy DPLobby! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    
		} // 0 == this->dwRefCnt
		
		LEAVE_DPLOBBY();
		return 0;

	} //0 == pInt->dwIntRefCnt 

	DPF(7, "<==PRV_Release, rc=%d\n",lpInterface->dwIntRefCnt);
   	
    LEAVE_DPLOBBY();
    return (lpInterface->dwIntRefCnt);
} // PRV_Release
		


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"
ULONG DPLAPI DPL_Release(LPDIRECTPLAYLOBBY lpDPL)
{
	LPDPLOBBYI_INTERFACE	lpInterface;
    LPDPLOBBYI_DPLOBJECT	this;
    HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_Release");
	DPF(9, "Parameters: 0x%08x", lpDPL);

    TRY
    {
		lpInterface = (LPDPLOBBYI_INTERFACE)lpDPL;
		if( !VALID_DPLOBBY_INTERFACE( lpInterface ))
		{
			return 0;
		}

		this = DPLOBJECT_FROM_INTERFACE(lpDPL);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return 0;
    }


	// Make sure someone isn't calling Release on our IDPLobbySP interface
	if(lpInterface->lpVtbl == &dplCallbacksSP)
	{
		DPF_ERR("You cannot call Release on an IDPLobbySP interface");
		ASSERT(FALSE);
		return 0;
	}

	// Call our internal release function
	return PRV_Release(this, lpInterface);

} //DPL_Release



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeAllLobbyObjects"
void PRV_FreeAllLobbyObjects(LPDPLOBBYI_DPLOBJECT this)
{

	DPF(7, "Entering PRV_FreeAllLobbyObjects");
	DPF(9, "Parameters: 0x%08x", this);

	ASSERT(this);

	// If we have an SP interface, just call release on it
	if(this->dwFlags & DPLOBBYPR_SPINTERFACE)
	{
		// Assert if an interface doesn't exist, because it should
		ASSERT(this->lpInterfaces);
		PRV_Release(this, this->lpInterfaces);
		return;
	}

	// Otherwise, we should only have an uninitialized object,
	// which we should just be able to destroy
	PRV_DestroyDPLobby(this);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dpneed.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpneed.h
 *  Content:	Private definitions needed by DPlay to build
 *
 *  History:
 *	Date	By		Reason
 *	======	=======	======
 *	6/16/96	myronth	Created it
 *	11/5/97	myronth	Added LOBBY_ALL macros
 ***************************************************************************/
#ifndef __DPNEED_INCLUDED__
#define __DPNEED_INCLUDED__

#define INIT_DPLOBBY_CSECT() InitializeCriticalSection(gpcsDPLCritSection);
#define FINI_DPLOBBY_CSECT() DeleteCriticalSection(gpcsDPLCritSection);
#define ENTER_DPLOBBY() EnterCriticalSection(gpcsDPLCritSection);
#define LEAVE_DPLOBBY() LeaveCriticalSection(gpcsDPLCritSection);

#define ENTER_LOBBY_ALL() ENTER_DPLAY(); ENTER_DPLOBBY();
#define LEAVE_LOBBY_ALL() LEAVE_DPLOBBY(); LEAVE_DPLAY();

#define INIT_DPLQUEUE_CSECT() InitializeCriticalSection(gpcsDPLQueueCritSection);
#define FINI_DPLQUEUE_CSECT() DeleteCriticalSection(gpcsDPLQueueCritSection);
#define ENTER_DPLQUEUE() EnterCriticalSection(gpcsDPLQueueCritSection);
#define LEAVE_DPLQUEUE() LeaveCriticalSection(gpcsDPLQueueCritSection);

#define INIT_DPLGAMENODE_CSECT() InitializeCriticalSection(gpcsDPLGameNodeCritSection);
#define FINI_DPLGAMENODE_CSECT() DeleteCriticalSection(gpcsDPLGameNodeCritSection);
#define ENTER_DPLGAMENODE() EnterCriticalSection(gpcsDPLGameNodeCritSection);
#define LEAVE_DPLGAMENODE() LeaveCriticalSection(gpcsDPLGameNodeCritSection);

#endif // __DPNEED_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\group.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       group.c
 *  Content:	Methods for managing groups
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	2/27/97		myronth	Created it
 *	3/17/97		myronth	Create/DestroyGroup, Removed unnecessary Enum functions
 *	3/20/97		myronth	AddPlayerToGroup, DeletePlayerFromGroup
 *	3/21/97		myronth	SetGroupName, Get/SetGroupData
 *	3/31/97		myronth	Removed dead code, Added CreateAndMapNewGroup function
 *	4/3/97		myronth	Changed CALLSP macro to CALL_LP
 *	5/6/97		kipo	GetGroup() now takes a parent ID
 *	5/8/97		myronth	Subgroup support, GroupConnSettings, StartSession,
 *						and drop the lobby lock when calling the LP
 *	5/12/97		myronth	Handle remote groups properly
 *	5/17/97		myronth	Added parent ID to CreateAndMapNewGroup calls, 
 *						Added send message code for DestroyGroup and
 *						DeletePlayerFromGroup on the local machine
 *	5/20/97		myronth	Send Delete & DestroyPlayer messages for remote
 *						players when a local player leaves a group (#8586)
 *						Made AddPlayerToGroup & DeletePlayerFromGroup return
 *						DPERR_ACCESSDENIED on remote players (#8679),
 *						Fixed a bunch of other lock bugs, Changed debug levels
 *	5/21/97		myronth	Pass CreateGroup flags through the lobby (#8813)
 *	5/22/97		myronth	Added functions to destroy remote subgroups when
 *						a local player leaves a group (#8810)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added PRV_DestroySubgroups function (#9134) and
 *						rearranged some of the DestroyGroup code
 *	6/5/97		myronth	Added shortcut checking to PRV_DestroySubgroups by
 *						adding the PRV_AreSubgroupsShortcuts function
 *	6/6/97		myronth	Added PRV_DestroyGroupAndParents and PRV_Destroy-
 *						ShortcutsForExitingPlayer, cleaned up PRV_Delete-
 *						PlayerFromGroup, Fixed StartSession bugs (#9573,#9574)
 *	6/9/97		myronth	Only delete shortcuts (don't destroy the subgoup)
 *						in the PRV_DestroySubgroups function
 *	6/16/97		myronth	Fixed bad deletion of uncle groups & some subgroups
 *						during DeletePlayerFromGroup (#9655)
 *	6/20/97		myronth	Send AddGroupToGroup message locally to avoid
 *						sending duplicate messages.  Also added code to
 *						send local DeleteGroupFromGroup messages (#10139)
 *	6/24/97		myronth	Send AddPlayerToGroup message locally to avoid
 *						sending duplicate messages (#10287)
 *	8/22/97		myronth	Force guidInstance to NULL in SetGroupConnectionSettings
 *	9/29/97		myronth	Send local SetGroupName/Data msgs after call to
 *						lobby server succeeds (#12554)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including
 *						DPL_SetGroupOwner and DPL_GetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddGroupToGroup"
HRESULT DPLAPI PRV_AddGroupToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
					DWORD dwGroupID)
{
	SPDATA_ADDGROUPTOGROUP		ad;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);


    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDGROUPTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDGROUPTOGROUP);
	ad.dwParentID = dwParentID;
	ad.dwGroupID = dwGroupID;

	// Call the AddGroupToGroup method in the SP
	if(CALLBACK_EXISTS(AddGroupToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, AddGroupToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddGroupToGroup is required
		DPF_ERR("The Lobby Provider callback for AddGroupToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDGROUPTOGROUP;
	}

	// If it succeeded, send the AddGroupToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDGROUPTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddGroupToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDGROUPTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AddPlayerToGroup"
HRESULT DPLAPI PRV_AddPlayerToGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					DWORD dwPlayerID)
{
	SPDATA_ADDPLAYERTOGROUP		ad;
	LPDPLAYI_PLAYER				lpPlayer = NULL;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	LPDPLAYI_GROUP				lpGroup = NULL;
	HRESULT						hr = DP_OK;


	DPF(7, "Entering DPL_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }

	
	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		LEAVE_DPLAY();
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		LEAVE_DPLAY();
		DPF_ERR("Cannot add a remote player to a group");
		hr = DPERR_ACCESSDENIED;
		goto EXIT_ADDPLAYERTOGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&ad, 0, sizeof(SPDATA_ADDPLAYERTOGROUP));
	ad.dwSize = sizeof(SPDATA_ADDPLAYERTOGROUP);
	ad.dwGroupID = dwGroupID;
	ad.dwPlayerID = dwPlayerID;

	// Call the AddPlayerToGroup method in the SP
	if(CALLBACK_EXISTS(AddPlayerToGroup))
	{
		ad.lpISP = PRV_GetDPLobbySPInterface(this);
		
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
		hr = CALL_LP(this, AddPlayerToGroup, &ad);
		ENTER_DPLOBBY();
	}
	else 
	{
		// AddPlayerToGroup is required
		DPF_ERR("The Lobby Provider callback for AddPlayerToGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_ADDPLAYERTOGROUP;
	}

	// If it succeeded, send the AddPlayerToGroup message to our local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();
		
		// Find dplay's internal group struct for the To group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_DPLAY();
			DPF_ERR("Unable to find group in nametable");
			hr = DPERR_INVALIDGROUP;
			goto EXIT_ADDPLAYERTOGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
		msg.dwPlayerID = dwPlayerID;
		msg.dwGroupID = dwGroupID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
		else
		{
			// We need to see if this player is the group owner.  If it is,
			// we need to send a SetGroupOwner message as well.
			lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
			if(lpGroup && (dwPlayerID == lpGroup->dwOwnerID))
			{
				// Now send the message
				PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwPlayerID, 0);
			}
		 }


		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling AddPlayerToGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_ADDPLAYERTOGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroup"
HRESULT DPLAPI PRV_CreateGroup(LPDPLOBBYI_DPLOBJECT this, LPDPID lpidGroup,
			LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize, DWORD dwFlags,
			DWORD dwOwnerID)
{
	SPDATA_CREATEGROUP		cg;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	DWORD					dwInternalFlags;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&cg, 0, sizeof(SPDATA_CREATEGROUP));
	cg.dwSize = sizeof(SPDATA_CREATEGROUP);
	cg.lpName = lpName;
	cg.lpData = lpData;
	cg.dwDataSize = dwDataSize;
	cg.dwFlags = dwFlags;
	cg.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroup))
	{
		cg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroup, &cg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroup in the Lobby Provider, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Add the player to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cg.dwGroupID, 0, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Take the lock
	ENTER_DPLAY();

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find system group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	LEAVE_DPLAY();

EXIT_CREATEGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateGroupInGroup"
HRESULT DPLAPI PRV_CreateGroupInGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwParentID,
			LPDPID lpidGroup, LPDPNAME lpName, LPVOID lpData, DWORD dwDataSize,
			DWORD dwFlags, DWORD dwOwnerID)
{
	SPDATA_CREATEGROUPINGROUP	cgig;
	MSG_PLAYERMGMTMESSAGE		msg;
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpGroupTo = NULL;
	HRESULT						hr = DP_OK;
	DWORD						dwInternalFlags;


	DPF(7, "Entering PRV_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x, 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwParentID, lpidGroup, lpName, lpData, dwDataSize, dwFlags, dwOwnerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&cgig, 0, sizeof(SPDATA_CREATEGROUPINGROUP));
	cgig.dwSize = sizeof(SPDATA_CREATEGROUPINGROUP);
	cgig.dwParentID = dwParentID;
	cgig.lpName = lpName;
	cgig.lpData = lpData;
	cgig.dwDataSize = dwDataSize;
	cgig.dwFlags = dwFlags;
	cgig.dwGroupOwnerID = dwOwnerID;

	// Call the CreateGroupInGroup method in the SP
	if(CALLBACK_EXISTS(CreateGroupInGroup))
	{
		cgig.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, CreateGroupInGroup, &cgig);
		ENTER_DPLOBBY();
	}
	else 
	{
		// CreateGroupInGroup is required
		DPF_ERR("The Lobby Provider callback for CreateGroupInGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling CreateGroupInGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}


	// Setup the flags to pass to GetGroup
	dwInternalFlags = DPLAYI_PLAYER_PLAYERLOCAL;
	if(dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags |= DPLAYI_GROUP_STAGINGAREA;
	if(dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;


	// Add the group to dplay's nametable and put it in our map table
	hr = PRV_CreateAndMapNewGroup(this, lpidGroup, lpName, lpData,
			dwDataSize, dwInternalFlags, cgig.dwGroupID, dwParentID, dwOwnerID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed creating a new local group, hr = 0x%08x", hr);
		// REVIEW!!!! -- We need to send a message back to the server saying
		// we couldn't complete the deal on our end.
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = *lpidGroup;

	// Find dplay's internal group struct for the To group
	// Since this is local, send it to all players
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		LEAVE_DPLAY();
		DPF_ERRVAL("Unable to find parent group in nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEGROUPINGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(2, "Failed adding CreateGroupInGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// Drop the dplay lock
	LEAVE_DPLAY();


EXIT_CREATEGROUPINGROUP:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_CreateGroupInGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeleteGroupFromGroup"
HRESULT DPLAPI PRV_DeleteGroupFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwParentID, DWORD dwGroupID)
{
	SPDATA_DELETEGROUPFROMGROUP		dgd;
	MSG_PLAYERMGMTMESSAGE			msg;
	LPDPLAYI_GROUP					lpGroupTo = NULL;
	HRESULT							hr = DP_OK;


	DPF(7, "Entering DPL_DeleteGroupFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwParentID, dwGroupID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dgd, 0, sizeof(SPDATA_DELETEGROUPFROMGROUP));
	dgd.dwSize = sizeof(SPDATA_DELETEGROUPFROMGROUP);
	dgd.dwParentID = dwParentID;
	dgd.dwGroupID = dwGroupID;

	// Call the DeleteGroupFromGroup method in the SP
	if(CALLBACK_EXISTS(DeleteGroupFromGroup))
	{
		dgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeleteGroupFromGroup, &dgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeleteGroupFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeleteGroupFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	// If it succeeded, send the DeleteGroupFromGroup message to all local players
	if(SUCCEEDED(hr))
	{
		// Take the dplay lock
		ENTER_DPLAY();

		// Get a pointer to dplay's system group
		lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
		if(!lpGroupTo)
		{
			LEAVE_LOBBY_ALL();
			DPF_ERR("Unable to find system group in nametable, not sending DeleteGroupFromGroup message");
			return DPERR_INVALIDGROUP;
		}

		// Now build the system message (at least the parts we need)
		memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&msg);
		SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEGROUPFROMGROUP);
		msg.dwPlayerID = dwGroupID;
		msg.dwGroupID = dwParentID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding DeleteGroupFromGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
		}

		// Drop the dplay lock
		LEAVE_DPLAY();
	}
	else
	{
		DPF_ERRVAL("Failed calling DeleteGroupFromGroup in the Lobby Provider, hr = 0x%08x", hr);
	}

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DeleteGroupFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DoSubgroupsContainLocalPlayers"
BOOL PRV_DoSubgroupsContainLocalPlayers(LPDPLAYI_GROUP lpGroup,
		BOOL bIncludeGroup)
{
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_DoSubgroupsContainLocalPlayers");
	DPF(9, "Parameters: 0x%08x, %lu", lpGroup, bIncludeGroup);

	ASSERT(lpGroup);

	// Figure out how many local players are in this group.  If it's
	// nonzero, just return true from this function.  If the bIncludeGroup
	// parameter is set to FALSE, then don't look at the group passed in
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					lpGroup->lpDP->pSysPlayer->dwID);
	if(lpGroupnode && (lpGroupnode->nPlayers > 0) && bIncludeGroup)
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if((!(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_DoSubgroupsContainLocalPlayers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_AreSubgroupsShortcuts"
BOOL PRV_AreSubgroupsShortcuts(LPDPLAYI_GROUP lpGroup)
{
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;


	DPF(7, "Entering PRV_AreSubgroupsShortcuts");
	DPF(9, "Parameters: 0x%08x", lpGroup);

	ASSERT(lpGroup);

	// If the group is one of the following, then we want to return TRUE so
	// it doesn't get nuked:
	// 1) Root group, nGroups > 0
	// 2) Root group, hidden, nGroups = 0
	// 2) Non-root group, nGroups > 1
	// Otherwise, we can check it's subgroups and return FALSE as appropriate
	if(((lpGroup->dwIDParent == 0) && ((lpGroup->nGroups > 0) ||
		(!(lpGroup->dwFlags & DPLAYI_GROUP_HIDDEN)) && (lpGroup->nGroups == 0))) ||
		((lpGroup->dwIDParent != 0) && (lpGroup->nGroups > 1)))
		return TRUE;	

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// We're going recursive here to do the entire heirarchy
		// Check out any of it's subgroups
		if(PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))
			return TRUE;
		else
			lpSubgroup = lpSubgroup->pNextSubgroup;
		
	} // while subgroups

	return FALSE;

} // PRV_AreSubgroupsShortcuts



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroupAndParents"
void PRV_DestroyGroupAndParents(LPDPLOBBYI_DPLOBJECT this,
		LPDPLAYI_GROUP lpGroup, LPDPLAYI_GROUP lpStopParent)
{
	LPDPLAYI_GROUPNODE			lpGroupnode = NULL;
	LPDPLAYI_GROUP				lpParentGroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dg;
	DPID						dpidParent;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroyGroupAndParents");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, lpGroup, lpStopParent);

	ASSERT(lpGroup);

	// Now we need to decide if this is the last group this group was in.  If
	// it is, then we need to destroy the group as well, and remove them from
	// our map table.  Of course, only destroy the group if it is a remote group.
	// ALSO, we need to walk the heirarchy backward (up the tree) to the root
	// node and delete all groups that were only created to get to our shortcut.
	if(!(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Walk our parental heirarchy until we reach a a root group.
		dpidParent = lpGroup->dwIDParent;
		while(dpidParent)
		{
			// Get dplay's internal group structures
			lpParentGroup = GroupFromID(this->lpDPlayObject, dpidParent);
			if(!lpParentGroup)
			{
				ASSERT(FALSE);
				DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dpidParent);
				return;
			}

			// If there are any local players in the parent group, we don't want to
			// destroy it or any of it's subgroups (since players in the group will
			// be able to see subgroups)
			lpGroupnode = FindPlayerInGroupList(lpParentGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
			if((lpGroupnode) && (lpGroupnode->nPlayers > 0))
				return;

			// Make sure we haven't reached our stop parent group if the caller
			// passed one in.  This will keep us from recursively destroying
			// a subgroup's parent, which we might be spinning on, deleting all
			// of it's subgroups.
			if(lpStopParent && (lpStopParent == lpParentGroup))
				return;

			// Destroy the subgroups
			PRV_DestroySubgroups(this, lpParentGroup, TRUE);

			// Get the next parent
			dpidParent = lpParentGroup->dwIDParent;
		}

		// See if we processed any parents, or if we already have a root
		// group.  If lpParentGroup is NULL, we have a root group, so just
		// stuff our group pointer in the parent group pointer
		if(!lpParentGroup)
			lpParentGroup = lpGroup;
		
		// Now see if our root group is hidden, and if it doesn't contain any
		// references, then we want to destroy it as well.
		if((!PRV_DoSubgroupsContainLocalPlayers(lpParentGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpParentGroup)) &&
			(lpParentGroup->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpParentGroup->dwID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote root group, hr = 0x%08x", hr);
			}
		}
	}

} // PRV_DestroyGroupAndParents



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemoteShortcutsForExitingPlayer"
void PRV_DestroyRemoteShortcutsForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drgd;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP		lpNextSubgroup = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_DestroyRemoteShortcutsForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, dwGroupID);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drgd, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drgd.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drgd.dwParentID = dwGroupID;

	// Walk the list of subgroups, destroying all remote shortcuts
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;

		// Make sure the group is remote and that this is really
		// a shortcut and not a child
		if(((lpSubgroup->dwFlags & DPGROUP_SHORTCUT)) &&
			(!(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
		{
			// Get the subgroup's lobby ID
			drgd.dwGroupID = lpSubgroup->pGroup->dwID;
			
			// Call our internal DeleteGroupFromGroup routine to delete
			// the shortcut and send the appropriate messages
			// NOTE: It is imperative that we pass in a pointer to the
			// group who's shortcuts we are removing as the stop parent.
			// If we do not, we run the risk of deleting it or one of
			// it's children that we haven't yet looped through, which
			// will result in a crash as we continue to walk the
			// subgroup list.
			hr = PRV_DeleteRemoteGroupFromGroup(this, &drgd, TRUE, lpGroup);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
			}
		}


		// Go to the next one
		lpSubgroup = lpNextSubgroup;
	}

} // PRV_DestroyRemoteShortcutsForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyRemotePlayersForExitingPlayer"
void PRV_DestroyRemotePlayersForExitingPlayer(LPDPLOBBYI_DPLOBJECT this,
				LPDPLAYI_GROUP lpGroup, DWORD dwGroupID)
{
	SPDATA_DELETEREMOTEPLAYERFROMGROUP	drpd;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	LPDPLAYI_GROUPNODE					lpNextGroupnode = NULL;
	HRESULT								hr;


	DPF(7, "Entering PRV_DestroyRemotePlayersForExitingPlayer");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, lpGroup);

	ASSERT(lpGroup);

	// Setup the SPDATA_DELETEREMOTEPLAYERFROMGROUP data struct
	memset(&drpd, 0, sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP));
	drpd.dwSize = sizeof(SPDATA_DELETEREMOTEPLAYERFROMGROUP);
	drpd.dwGroupID = dwGroupID;
	
	// Walk the list of groupnodes, deleting remote players that are not in
	// any other groups
	lpGroupnode = lpGroup->pGroupnodes;
	while(lpGroupnode)
	{
		// Save our next groupnode pointer since our current groupnode
		// will be gone when we come back from the delete
		lpNextGroupnode = lpGroupnode->pNextGroupnode;

		// Delete the player from the group if it's remote and then
		// destroy the player if he is in no other groups
		if (!(lpGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			// Get the remote player's ID
			drpd.dwPlayerID = lpGroupnode->pPlayer->dwID;

			// Delete the player from the group
			hr = PRV_DeleteRemotePlayerFromGroup(this, &drpd, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed deleting remote player from group, hr = 0x%08x", hr);
			}
		}

		lpGroupnode = lpNextGroupnode;

	} // while

} // PRV_DestroyRemotePlayersForExitingPlayer



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroySubgroups"
void PRV_DestroySubgroups(LPDPLOBBYI_DPLOBJECT this, LPDPLAYI_GROUP lpGroup,
		BOOL bRemoteOnly)
{
	LPDPLAYI_SUBGROUP			lpSubgroup = NULL;
	LPDPLAYI_SUBGROUP			lpNextSubgroup = NULL;
	SPDATA_DESTROYREMOTEGROUP	dgd;
	SPDATA_DELETEREMOTEGROUPFROMGROUP	drg;
	HRESULT						hr;


	DPF(7, "Entering PRV_DestroySubgroups");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", this, lpGroup, bRemoteOnly);

	ASSERT(lpGroup);

	// Setup the static part of the SPDATA structures
	memset(&dgd, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
	dgd.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);

	memset(&drg, 0, sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP));
	drg.dwSize = sizeof(SPDATA_DELETEREMOTEGROUPFROMGROUP);
	drg.dwParentID = lpGroup->dwID;

	// Walk the list of subgroups
	lpSubgroup = lpGroup->pSubgroups;
	while(lpSubgroup)
	{
		// Save the next subgroup
		lpNextSubgroup = lpSubgroup->pNextSubgroup;
		
		// Make sure it's a remote group if the flag is set
		if((bRemoteOnly) &&
			(lpSubgroup->pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			lpSubgroup = lpNextSubgroup;
			continue;
		}
		
		// If the subgroup doesn't contain any local players,
		// nor do any of it's subgroups, then destroy it
		if((!bRemoteOnly) || 
			((!PRV_DoSubgroupsContainLocalPlayers(lpSubgroup->pGroup, TRUE)) &&
			(!PRV_AreSubgroupsShortcuts(lpSubgroup->pGroup))))
		{
			// If the group is a shortcut, just delete the link.  If it's a child,
			// destroy the subgroup.
			if(lpSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// Finish setting up the SPDATA structure
				drg.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DeleteGroupFromGroup((LPDPLOBBYSP)this->lpInterfaces, &drg);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed deleting remote group from group, hr = 0x%08x", hr);
				}
			}
			else
			{
				// Finish setting up the SPDATA structure
				dgd.dwGroupID = lpSubgroup->pGroup->dwID;
	
				// Destroy the subgroup
				hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dgd);
				if(FAILED(hr))
				{
					DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				}
			}
		}

		lpSubgroup = lpNextSubgroup;

	} // while lpSubgroups

} // PRV_DestroySubgroups



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DeletePlayerFromGroup"
HRESULT DPLAPI PRV_DeletePlayerFromGroup(LPDPLOBBYI_DPLOBJECT this,
					DWORD dwGroupID, DWORD dwPlayerID)
{
	SPDATA_DELETEPLAYERFROMGROUP		dpd;
	MSG_PLAYERMGMTMESSAGE				msg;
	LPDPLAYI_PLAYER						lpPlayer = NULL;
	LPDPLAYI_GROUP						lpGroup =NULL;
	LPDPLAYI_GROUPNODE					lpGroupnode = NULL;
	HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_DeletePlayerFromGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			this, dwGroupID, dwPlayerID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Take the dplay lock since we'll be looking at a dplay internal struct
	ENTER_DPLAY();

	// Make sure the player is a local player, otherwise return AccessDenied
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	if(!(lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		DPF_ERR("Cannot delete a remote player from a group");
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}
	
	// Drop the dplay lock since we're done
	LEAVE_DPLAY();

	// Setup our SPDATA struct
	memset(&dpd, 0, sizeof(SPDATA_DELETEPLAYERFROMGROUP));
	dpd.dwSize = sizeof(SPDATA_DELETEPLAYERFROMGROUP);
	dpd.dwGroupID = dwGroupID;
	dpd.dwPlayerID = dwPlayerID;

	// Call the DeletePlayerFromGroup method in the SP
	if(CALLBACK_EXISTS(DeletePlayerFromGroup))
	{
		dpd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DeletePlayerFromGroup, &dpd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DeletePlayerFromGroup is required
		DPF_ERR("The Lobby Provider callback for DeletePlayerFromGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DeletePlayerFromGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// We need to remove all other players in the group and send the appropriate
	// message to the player we are about to delete because he won't see the
	// system messages for them once he leaves the group.  However, if any other
	// local players are in the group, we don't want to remove the remote players
	// from the nametable because the other local players need to see them.

	// Get a pointer to dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
	if(!lpGroup)
	{
		DPF_ERRVAL("Unable to find group in nametable, idGroup = %lu", dwGroupID);
		hr = DPERR_INVALIDGROUP;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// Get a pointer to dplay's internal player structure
	lpPlayer = PlayerFromID(this->lpDPlayObject, dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERRVAL("Unable to find player in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_DELETEPLAYERFROMGROUP;
	}

	// We need to send a DeletePlayerFromGroup message to the player who
	// was deleted since he won't get the group message once he's gone

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwPlayerID = dwPlayerID;
	msg.dwGroupID = dwGroupID;

	// Call dplay's handleplayermessage function to put the message in the queue
	hr = HandlePlayerMessage(lpPlayer, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed adding message to player's receive queue from lobby, hr = 0x%08x", hr);
		// Set the hresult back to DP_OK since only the message failed
		hr = DP_OK;
	}

	// Figure out how many local players are in this group.  If it's only 1,
	// then delete all the remote players.
	lpGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,
					this->lpDPlayObject->pSysPlayer->dwID);
	if((!lpGroupnode) || (lpGroupnode->nPlayers == 0))
	{
		// Destroy all remote players that are only in this group
		PRV_DestroyRemotePlayersForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all the remote shortcut groups, making sure we are
		// not in them, and removing their entire parental heirarchy
		PRV_DestroyRemoteShortcutsForExitingPlayer(this, lpGroup, dwGroupID);

		// Destroy all remote subgroups of this group, making sure we're
		// not in them for some reason
		PRV_DestroySubgroups(this, lpGroup, TRUE);

		// Destroy the group we're leaving if it is remote as well as it's
		// parental chain.
		PRV_DestroyGroupAndParents(this, lpGroup, NULL);
	}


EXIT_DELETEPLAYERFROMGROUP:

	// The dplay InternalDeletePlayerFromGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_LOBBY_ALL();
	return hr;

} // PRV_DeletePlayerFromGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_DestroyGroup"
HRESULT DPLAPI PRV_DestroyGroup(LPDPLOBBYI_DPLOBJECT this, DWORD dwLobbyID)
{
	SPDATA_DESTROYGROUP		dg;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering PRV_DestroyGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", this, dwLobbyID);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Setup our SPDATA struct
	memset(&dg, 0, sizeof(SPDATA_DESTROYGROUP));
	dg.dwSize = sizeof(SPDATA_DESTROYGROUP);
	dg.dwGroupID = dwLobbyID;

	// Call the DestroyGroup method in the SP
	if(CALLBACK_EXISTS(DestroyGroup))
	{
		dg.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, DestroyGroup, &dg);
		ENTER_DPLOBBY();
	}
	else 
	{
		// DestroyGroup is required
		DPF_ERR("The Lobby Provider callback for DestroyGroup doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling DestroyGroup in the Lobby Provider, hr = 0x%08x", hr);
		LEAVE_DPLOBBY();
		return hr;
	}

	// Take the lock
	ENTER_DPLAY();

	// So, get dplay's internal group structure
	lpGroup = GroupFromID(this->lpDPlayObject, dwLobbyID);
	if(!lpGroup)
	{
		// This shouldn't ever happen.  If the groups isn't in the nametable,
		// we should never get this far.
		ASSERT(FALSE);
		LEAVE_LOBBY_ALL();
		DPF_ERRVAL("Unable to find group in nametable, dpidGroup = %lu", dwLobbyID);
		return DPERR_INVALIDGROUP;
	}

	// Send messages to remove shortcuts to this group (since dplay won't
	// do it for us)
	PRV_SendDeleteShortcutMessageForExitingGroup(this, lpGroup);

	// Destroy all the subgroups and remote players
	PRV_RemoveSubgroupsAndPlayersFromGroup(this, lpGroup, dwLobbyID, FALSE);

	// Drop the dplay lock since we're done mucking around with it's structures
	LEAVE_DPLAY();

	// Broadcast the DestroyGroup message
	hr = PRV_BroadcastDestroyGroupMessage(this, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed to send DestroyGroup message to local players, hr = 0x%08x", hr);
	}

	// The dplay InternalDestroyGroup code will take care of the rest of
	// the internal cleanup (nametable, players, etc.), so we can just return
	// from here.

	LEAVE_DPLOBBY();
	return hr;

} // PRV_DestroyGroup



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupConnectionSettings"
HRESULT PRV_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
			DWORD dwGroupID, LPVOID lpData, LPDWORD lpdwSize) 
{
	SPDATA_GETGROUPCONNECTIONSETTINGS	gcs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID, lpData, lpdwSize);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("GetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		if( !VALID_DWORD_PTR( lpdwSize ) )
		{
			DPF_ERR("lpdwSize was not a valid dword pointer!");
			return DPERR_INVALIDPARAMS;
		}

		if(lpData)
		{
			if( !VALID_WRITE_PTR(lpData, *lpdwSize) )
			{
				DPF_ERR("lpData is not a valid output buffer of the size specified in *lpdwSize");
				return DPERR_INVALIDPARAMS;
			}
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&gcs, 0, sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS));
	gcs.dwSize = sizeof(SPDATA_GETGROUPCONNECTIONSETTINGS);
	gcs.dwFlags = dwFlags;
	gcs.dwGroupID = dwGroupID;
	gcs.lpdwBufferSize = lpdwSize;
	gcs.lpBuffer = lpData;

	// Call the GetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(GetGroupConnectionSettings))
	{
		gcs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we are going to send a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, GetGroupConnectionSettings, &gcs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// GetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for GetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr) && (hr != DPERR_BUFFERTOOSMALL))
	{
		DPF_ERRVAL("Failed calling GetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_GetGroupConnectionSettings


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupConnectionSettings"
HRESULT DPLAPI DPL_GetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
		DWORD dwFlags, DPID idGroup, LPVOID lpData, LPDWORD lpdwSize)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_GetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpData, lpdwSize);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_GetGroupConnectionSettings(lpDP, dwFlags, idGroup,
							lpData,	lpdwSize);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_GetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetGroupData"
HRESULT DPLAPI PRV_GetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, LPDWORD lpdwDataSize)
{
	SPDATA_GETGROUPDATA		ggd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_GetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpData, lpdwDataSize);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
            LEAVE_DPLOBBY();
            return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&ggd, 0, sizeof(SPDATA_GETGROUPDATA));
	ggd.dwSize = sizeof(SPDATA_GETGROUPDATA);
	ggd.dwGroupID = dwGroupID;
	ggd.lpdwDataSize = lpdwDataSize;
	ggd.lpData = lpData;

	// Call the GetGroupData method in the SP
	if(CALLBACK_EXISTS(GetGroupData))
	{
		ggd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, GetGroupData, &ggd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// GetGroupData is required
		DPF_ERR("The Lobby Provider callback for GetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		LEAVE_DPLOBBY();
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling GetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

	LEAVE_DPLOBBY();
	return hr;

} // PRV_GetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetGroupOwner"
HRESULT DPAPI DPL_GetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		LPDPID lpidOwner)
{
	LPDPLAYI_DPLAY		this;
	LPDPLAYI_GROUP		lpGroup = NULL;
	HRESULT				hr;


	DPF(7, "Entering DPL_GetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, lpidOwner);

	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		lpGroup = GroupFromID(this, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_DPLAY();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(lpidOwner))
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid owner id pointer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// This method is only valid in lobby session
	if(IS_LOBBY_OWNED(this))
	{	
		*lpidOwner = lpGroup->dwOwnerID;
	}
	else
	{
		DPF_ERR("GetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
	}

	LEAVE_DPLAY();
	return hr;

} // DPL_GetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupConnectionSettings"
HRESULT PRV_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, DWORD dwFlags,
				DWORD dwGroupID, LPDPLCONNECTION lpConn, BOOL bAnsi) 
{
	SPDATA_SETGROUPCONNECTIONSETTINGS	scs;
	LPDPLOBBYI_DPLOBJECT				this = NULL;
    LPDPLAYI_DPLAY						lpDPObject = NULL;
	LPDPLAYI_GROUP						lpGroup = NULL;
    HRESULT								hr = DP_OK;


	DPF(7, "Entering PRV_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x, %lu",
			lpDP, dwFlags, dwGroupID, lpConn, bAnsi);

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			return hr;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			return DPERR_INVALIDOBJECT;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            return DPERR_INVALIDGROUP;
        }

		hr = PRV_ValidateDPLCONNECTION(lpConn, FALSE);
		if(FAILED(hr))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return hr;
		}

		// We haven't defined any flags for this release
		if( (dwFlags) )
		{
            return DPERR_INVALIDFLAGS;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&scs, 0, sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS));
	scs.dwSize = sizeof(SPDATA_SETGROUPCONNECTIONSETTINGS);
	scs.dwFlags = dwFlags;
	scs.dwGroupID = dwGroupID;
	scs.lpConn = lpConn;

	// Ensure that the guidInstance in the DPLCONNECTION structure is NULL
	lpConn->lpSessionDesc->guidInstance = GUID_NULL;

	// Call the SetGroupConnectionSettings method in the SP
	if(CALLBACK_EXISTS(SetGroupConnectionSettings))
	{
		scs.lpISP = PRV_GetDPLobbySPInterface(this);
	    
		// Drop the dplay lock since we're sending a guaranteed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, SetGroupConnectionSettings, &scs);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupConnectionSettings is required
		DPF_ERR("The Lobby Provider callback for SetGroupConnectionSettings doesn't exist -- it's required");
		ASSERT(FALSE);
		return DPERR_UNAVAILABLE;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling SetGroupConnectionSettings in the Lobby Provider, hr = 0x%08x", hr);
	}

	return hr;

} // PRV_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupConnectionSettings"
HRESULT DPLAPI DPL_SetGroupConnectionSettings(LPDIRECTPLAY lpDP, 
				DWORD dwFlags, DPID idGroup, LPDPLCONNECTION lpConn)
{
	HRESULT		hr;


	DPF(7, "Entering DPL_SetGroupConnectionSettings");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, idGroup, lpConn);

	ENTER_LOBBY_ALL();

	// Set the ANSI flag to TRUE and call the internal function
	hr = PRV_SetGroupConnectionSettings(lpDP, dwFlags, idGroup, lpConn, FALSE);

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupConnectionSettings



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupData"
HRESULT DPLAPI PRV_SetGroupData(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPVOID lpData, DWORD dwDataSize, DWORD dwFlags)
{
	SPDATA_SETGROUPDATA		sgd;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupData");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, %lu, 0x%08x",
			this, dwGroupID, lpData, dwDataSize, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgd, 0, sizeof(SPDATA_SETGROUPDATA));
	sgd.dwSize = sizeof(SPDATA_SETGROUPDATA);
	sgd.dwGroupID = dwGroupID;
	sgd.dwDataSize = dwDataSize;
	sgd.lpData = lpData;
	sgd.dwFlags = dwFlags;

	// Call the SetGroupData method in the SP
	if(CALLBACK_EXISTS(SetGroupData))
	{
		sgd.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupData, &sgd);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupData is required
		DPF_ERR("The Lobby Provider callback for SetGroupData doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPDATA;
	}

	// If it succeeded, send the SetGroupData message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendDataChangedMessageLocally(this, dwGroupID, lpData, dwDataSize);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupData in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPDATA:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupData



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SetGroupName"
HRESULT DPLAPI PRV_SetGroupName(LPDPLOBBYI_DPLOBJECT this, DWORD dwGroupID,
					LPDPNAME lpName, DWORD dwFlags)
{
	SPDATA_SETGROUPNAME		sgn;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_SetGroupName");
	DPF(9, "Parameters: 0x%08x, %lu, 0x%08x, 0x%08x",
			this, dwGroupID, lpName, dwFlags);

    ENTER_DPLOBBY();
    
    TRY
    {
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLAY();
			return DPERR_INVALIDOBJECT;
        }
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
		return DPERR_INVALIDPARAMS;
    }


	// Setup our SPDATA struct
	memset(&sgn, 0, sizeof(SPDATA_SETGROUPNAME));
	sgn.dwSize = sizeof(SPDATA_SETGROUPNAME);
	sgn.dwGroupID = dwGroupID;
	sgn.lpName = lpName;
	sgn.dwFlags = dwFlags;

	// Call the SetGroupName method in the SP
	if(CALLBACK_EXISTS(SetGroupName))
	{
		sgn.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, SetGroupName, &sgn);
		ENTER_DPLOBBY();
	}
	else 
	{
		// SetGroupName is required
		DPF_ERR("The Lobby Provider callback for SetGroupName doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPNAME;
	}

	// If it succeeded, send the SetGroupName message to our local players
	if(SUCCEEDED(hr))
	{
		hr = PRV_SendNameChangedMessageLocally(this, dwGroupID, lpName, FALSE);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupName in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPNAME:

	LEAVE_DPLOBBY();
	return hr;

} // PRV_SetGroupName



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetGroupOwner"
HRESULT DPLAPI DPL_SetGroupOwner(LPDIRECTPLAY lpDP, DWORD dwGroupID,
		DWORD dwOwnerID)
{
	LPDPLOBBYI_DPLOBJECT	this;
	LPDPLAYI_DPLAY			lpDPlayObject;
	SPDATA_SETGROUPOWNER	sgo;
	LPDPLAYI_PLAYER			lpNewOwner = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;
	DWORD					dwOldOwnerID;


	DPF(7, "Entering DPL_SetGroupOwner");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwGroupID, dwOwnerID);

	ENTER_LOBBY_ALL();
	
    TRY
    {
		lpDPlayObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPlayObject );
		if (FAILED(hr))
		{
			LEAVE_LOBBY_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        this = lpDPlayObject->lpLobbyObject;
		if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_LOBBY_ALL();
			return DPERR_INVALIDOBJECT;
        }

	    lpGroup = GroupFromID(lpDPlayObject, dwGroupID);
	    if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == dwGroupID)) 
	    {
			LEAVE_LOBBY_ALL();
			DPF_ERR("Invalid group id");
	        return DPERR_INVALIDGROUP;
	    }

	    // DPID_SERVERPLAYER is valid here
		if(dwOwnerID != DPID_SERVERPLAYER)
		{
			lpNewOwner = PlayerFromID(lpDPlayObject, dwOwnerID);
			if (!VALID_DPLAY_PLAYER(lpNewOwner))
			{
				LEAVE_LOBBY_ALL();
				DPF_ERR("Invalid new owner player id");
				return DPERR_INVALIDPLAYER;
			}
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_LOBBY_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// do the send
	if(!IS_LOBBY_OWNED(lpDPlayObject))
	{
		DPF_ERR("SetGroupOwner is only supported for lobby sessions");
		hr = DPERR_UNSUPPORTED;
		goto EXIT_SETGROUPOWNER;
	}


	// Setup our SPDATA struct
	memset(&sgo, 0, sizeof(SPDATA_SETGROUPOWNER));
	sgo.dwSize = sizeof(SPDATA_SETGROUPOWNER);
	sgo.dwGroupID = dwGroupID;
	sgo.dwOwnerID = dwOwnerID;

	// Call the SetGroupOwner method in the SP
	if(CALLBACK_EXISTS(SetGroupOwner))
	{
		sgo.lpISP = PRV_GetDPLobbySPInterface(this);

		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// response (which always happens)
		LEAVE_LOBBY_ALL();
	    hr = CALL_LP(this, SetGroupOwner, &sgo);
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// SetGroupOwner is required
		DPF_ERR("The Lobby Provider callback for SetGroupOwner doesn't exist");
		hr = DPERR_UNAVAILABLE;
		goto EXIT_SETGROUPOWNER;
	}

	// If it succeeded, send the SetGroupOwner message to our local players
	if(SUCCEEDED(hr))
	{
		// Get a pointer to our internal data struct for the group, just in
		// case it changed for some reason while we had dropped the locks
		lpGroup = GroupFromID(this->lpDPlayObject, dwGroupID);
		if(!lpGroup)
		{
			DPF_ERR("Unable to find group in nametable -- local nametable will be incorrect");
			goto EXIT_SETGROUPOWNER;
		}

		// Save the old owner so we can put it in the message
		dwOldOwnerID = lpGroup->dwOwnerID;
		
		// Change the owner
		lpGroup->dwOwnerID = dwOwnerID;

		// Send a SetGroupOwner message locally
		PRV_SendGroupOwnerMessageLocally(this, dwGroupID, dwOwnerID, dwOldOwnerID);
	}
	else
	{
		DPF_ERRVAL("Failed calling SetGroupOwner in the Lobby Provider, hr = 0x%08x", hr);
	}

EXIT_SETGROUPOWNER:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_SetGroupOwner



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_StartSession"
HRESULT DPLAPI DPL_StartSession(LPDIRECTPLAY lpDP, DWORD dwFlags, DWORD dwGroupID)
{
	SPDATA_STARTSESSION		ss;
	LPDPLOBBYI_DPLOBJECT	this = NULL;
	LPDPLAYI_DPLAY			lpDPObject = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	HRESULT					hr = DP_OK;


	DPF(7, "Entering DPL_StartSession");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpDP, dwFlags, dwGroupID);

	ENTER_LOBBY_ALL();

    TRY
    {
        lpDPObject = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( lpDPObject );
		if (FAILED(hr))
		{
			DPF_ERRVAL("Bad DPlay interface pointer - hr = 0x%08lx\n",hr);
			goto ERROR_STARTSESSION;
        }
    
		if(!IS_LOBBY_OWNED(lpDPObject))
		{
			DPF_ERR("SetGroupConnectionSettings is only supported for lobby connections");
			hr = DPERR_UNSUPPORTED;
			goto ERROR_STARTSESSION;
		}

		this = lpDPObject->lpLobbyObject;
		if(!VALID_DPLOBBY_PTR(this))
		{
			DPF_ERR("Bad DPLobby object");
			hr = DPERR_INVALIDOBJECT;
			goto ERROR_STARTSESSION;
		}

		if(dwFlags)
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto ERROR_STARTSESSION;
		}

		lpGroup = GroupFromID(lpDPObject, dwGroupID);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERR("Invalid group id");
            hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
        }

		// Make sure the group is a staging area
		if(!(lpGroup->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			DPF_ERR("StartSession can only be called on a Staging Area");
			hr = DPERR_INVALIDGROUP;
			goto ERROR_STARTSESSION;
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
		goto ERROR_STARTSESSION;
    }


	// Setup our SPDATA struct
	memset(&ss, 0, sizeof(SPDATA_STARTSESSION));
	ss.dwSize = sizeof(SPDATA_STARTSESSION);
	ss.dwGroupID = dwGroupID;
	ss.dwFlags = dwFlags;

	// Call the StartSession method in the SP
	if(CALLBACK_EXISTS(StartSession))
	{
		ss.lpISP = PRV_GetDPLobbySPInterface(this);

	    // Drop the dplay lock so we can send a guarateed message
		LEAVE_LOBBY_ALL();

		hr = CALL_LP(this, StartSession, &ss);

		// Take the lock back
		ENTER_LOBBY_ALL();
	}
	else 
	{
		// StartSession is required
		DPF_ERR("The Lobby Provider callback for StartSession doesn't exist -- it's required");
		ASSERT(FALSE);
		hr = DPERR_UNAVAILABLE;
		goto ERROR_STARTSESSION;
	}

	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed calling StartSession in the Lobby Provider, hr = 0x%08x", hr);
	}

ERROR_STARTSESSION:

	LEAVE_LOBBY_ALL();
	return hr;

} // DPL_StartSession



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_CreateAndMapNewGroup"
HRESULT PRV_CreateAndMapNewGroup(LPDPLOBBYI_DPLOBJECT this,
			DPID * lpdpid, LPDPNAME lpName, LPVOID lpData,
			DWORD dwDataSize, DWORD dwFlags, DWORD dwLobbyID,
			DPID dpidParent, DWORD dwOwnerID)
{
	LPDPLAYI_GROUP		lpGroup = NULL, lpSysGroup = NULL;
	HRESULT				hr;
	DPID				dpidGroup, dpidSysPlayer;


	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the lobby ID is valid
	if(!IsValidLobbyID(dwLobbyID))
	{
		DPF_ERRVAL("ID %lu is reserved, cannot create new player", dwLobbyID);
		hr = DPERR_INVALIDPLAYER;
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// If this is a remote player, we need allocate a new nametable entry
	// for them and set the correct system player ID
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Allocate a new ID for the player
		hr = NS_AllocNameTableEntry(this->lpDPlayObject, &dpidGroup);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to allocate new nametable id, hr = 0x%08x", hr);
			goto EXIT_CREATEANDMAPNEWGROUP;
		}

		// Make sure we have a lobby system player (for all remote players
		// & groups). If we don't then allocate a new one.
		if(!(this->dpidSysPlayer))
		{
			hr = PRV_CreateAndMapNewPlayer(this, &dpidSysPlayer, NULL, NULL,
					NULL, 0, DPLAYI_PLAYER_SYSPLAYER,
					DPID_LOBBYREMOTESYSTEMPLAYER, TRUE);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to create lobby system player, hr = 0x%08x", hr);
				ASSERT(FALSE);
				goto EXIT_CREATEANDMAPNEWGROUP;
			}

			// Set the lobby system player ID pointer to the new ID
			this->dpidSysPlayer = dpidSysPlayer;
		}
	}

	// Get a group struct for the group (if it's local, this will add it
	// to the nametable.  If it's remote, we need to add it below)
	hr = GetGroup(this->lpDPlayObject, &lpGroup, lpName, lpData,
					dwDataSize, dwFlags, dpidParent, dwLobbyID);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Failed trying to add group to the nametable, hr = 0x%08x", hr);
		goto EXIT_CREATEANDMAPNEWGROUP;
	}

	// Fixup the group's owner
	lpGroup->dwOwnerID = dwOwnerID;
	
	// If the group is remote, set the group's ID to the new one we
	// allocated and then set the system group ID to the lobby system group
	if(!(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// 
		lpGroup->dwIDSysPlayer = this->dpidSysPlayer;

		// Add the group to the nametable
		hr = AddItemToNameTable(this->lpDPlayObject, (DWORD_PTR)lpGroup,
				&dpidGroup, TRUE, dwLobbyID);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("Unable to add new group to the nametable, hr = 0x%08x", hr);
			ASSERT(FALSE);
			goto EXIT_CREATEANDMAPNEWGROUP;
	    }

		// Set the group's ID
		lpGroup->dwID = dpidGroup;
	}

	// Set the output dpid pointer
	*lpdpid = lpGroup->dwID;

EXIT_CREATEANDMAPNEWGROUP:

	LEAVE_DPLAY();
	return hr;

} // PRV_CreateAndMapNewGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplpack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplpack.c
 *  Content:	Methods for packing/unpacking structures
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	5/31/96		myronth	Created it
 *	6/26/96		kipo	added support for DPADDRESS.
 *  7/13/96		kipo	Bug fix - added (LPBYTE) cast to lpConnPack (address calc)
 *						in PRV_UnpackageDPLCONNECTIONAnsi()
 *	11/20/96	myronth	Removed packing for DPTRANSPORT
 *	12/12/96	myronth	Added DPLCONNECTION structure validation
 *	2/12/97		myronth	Mass DX5 changes
 *	4/3/97		myronth Changed STRLEN's to WSTRLEN's from dplaypr.h
 *	5/8/97		myronth	Changed most packing functions to use the packed
 *						conn header, added pointer fixup function, Moved
 *						PRV_ConvertDPLCONNECTIONToUnicode from convert.c
 *	9/29/97		myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	12/2/97		myronth	Made SessionDesc mandatory in DPLCONNECTION (#15529)
 *	7/08/98	   a-peterz	Allow for MBCS for ANSI string sizes. ManBug 16299
 *  2/10/99     aarono  add support for application launcher
 *  10/22/99	aarono  added support for application flags
 *  01/21/00	aarono  added support for DPSESSION_ALLOWVOICERETRO flag
 ***************************************************************************/
#include "dplobpr.h"

//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_GetDPLCONNECTIONPackageSize"
void PRV_GetDPLCONNECTIONPackageSize(LPDPLCONNECTION lpConn,
						LPDWORD lpdwUnicode, LPDWORD lpdwAnsi)
{
	DWORD				dwSize;
	DWORD				dwStringSize = 0;
	DWORD				dwStringSizeA = 0;
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_GetDPLCONNECTIONPackageSize");
	DPF(9, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			lpConn, lpdwUnicode, lpdwAnsi);

	ASSERT(lpConn);
	
	// First calculate the size of the structures
	dwSize = sizeof(DPLCONNECTION);

	// Add the size of the SessionDesc and Name structs
	if(lpConn->lpSessionDesc)
	{
		dwSize += sizeof(DPSESSIONDESC2);
		lpsd = lpConn->lpSessionDesc;
		
		if(lpsd->lpszSessionName)
			dwStringSize += WSTRLEN(lpsd->lpszSessionName);
		if(lpsd->lpszPassword)
			dwStringSize += WSTRLEN(lpsd->lpszPassword);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszSessionName);
			dwStringSizeA += WSTR_ANSILENGTH(lpsd->lpszPassword);
		}
	}


	if(lpConn->lpPlayerName)
	{
		dwSize += sizeof(DPNAME);
		lpn = lpConn->lpPlayerName;
		
		if(lpn->lpszShortName)
			dwStringSize += WSTRLEN(lpn->lpszShortName);
		if(lpn->lpszLongName)
			dwStringSize += WSTRLEN(lpn->lpszLongName);
		// only compute ANSI size if needed. Macro handles NULLS; includes terminator
		if(lpdwAnsi)
		{
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszShortName);
			dwStringSizeA += WSTR_ANSILENGTH(lpn->lpszLongName);
		}
	}

	// Add the size of the SP-specific data
	if(lpConn->lpAddress)
		dwSize += lpConn->dwAddressSize;

	// Now add in the size of the packed structure header
	dwSize += sizeof(DPLOBBYI_PACKEDCONNHEADER);

	// Fill in the output variables
	if(lpdwAnsi)
		*lpdwAnsi = dwSize + dwStringSizeA;
	if(lpdwUnicode)
		*lpdwUnicode = dwSize + (dwStringSize * sizeof(WCHAR));

} // PRV_GetDPLCONNECTIONPackageSize


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_PackageDPLCONNECTION"
HRESULT PRV_PackageDPLCONNECTION(LPDPLCONNECTION lpConn, LPVOID lpBuffer,
			BOOL bHeader)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnPacked = NULL;
	LPDPSESSIONDESC2				lpsd = NULL,
									lpsdPacked = NULL;
	LPDPNAME						lpn = NULL,
									lpnPacked = NULL;
	LPBYTE							lpStart, lpCurrent;
	DWORD							dwSizeAnsi,
									dwSizeUnicode,
									dwTemp;
	

	DPF(7, "Entering PRV_PackageDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu", lpConn, lpBuffer, bHeader);

	ASSERT(lpConn);
	
	// If the bHeader flag is set, we want to copy the packed header into the
	// buffer first.  If it is not, we only want the packed DPLCONNECTION struct
	if(bHeader)
	{
		PRV_GetDPLCONNECTIONPackageSize(lpConn, &dwSizeUnicode, &dwSizeAnsi);
		lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpBuffer;
		lpHeader->dwUnicodeSize = dwSizeUnicode;
		lpHeader->dwAnsiSize = dwSizeAnsi;
		lpStart = (LPBYTE)lpBuffer + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	}
	else
	{
		lpStart = lpBuffer;
	}

	// Copy in the structures & store the offsets
	memcpy(lpStart, lpConn, sizeof(DPLCONNECTION));
	lpConnPacked = (LPDPLCONNECTION)lpStart;
	lpCurrent = lpStart + sizeof(DPLCONNECTION);

	if(lpConn->lpSessionDesc)
	{
		lpsd = lpConn->lpSessionDesc;
		lpsdPacked = (LPDPSESSIONDESC2)lpCurrent;
		if(lpsdPacked->dwSize==sizeof(DPSESSIONDESC2)){
			// we are over-riding and existing session descriptor, don't let
			// the session flag for the retrofit get over-riden
			lpsd->dwFlags |= (lpsdPacked->dwFlags & DPSESSION_ALLOWVOICERETRO);
		}
		memcpy(lpCurrent, lpsd, sizeof(DPSESSIONDESC2));
		(DWORD_PTR)lpConnPacked->lpSessionDesc = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPSESSIONDESC2);
	}

	if(lpConn->lpPlayerName)
	{
		lpn = lpConn->lpPlayerName;
		memcpy(lpCurrent, lpn, sizeof(DPNAME));
		lpnPacked = (LPDPNAME)lpCurrent;
		(DWORD_PTR)lpConnPacked->lpPlayerName = (DWORD_PTR)(lpCurrent - lpStart);
		lpCurrent += sizeof(DPNAME);
	}

	// Copy in the strings in the SessionDesc and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpsd)
	{
		if(lpsd->lpszSessionName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszSessionName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszSessionName, dwTemp);

			// Store the offset
                        lpsdPacked->lpszSessionName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

		if(lpsd->lpszPassword)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpsd->lpszPassword) * sizeof(WCHAR);
			memcpy(lpCurrent, lpsd->lpszPassword, dwTemp);

			// Store the offset
                        lpsdPacked->lpszPassword = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

	}

	// Copy in the strings in the DPName struct and store the offset of the
	// string from lpStart (relative offset in our package) in the pointer
	// for the string in the SessionDesc structure.  We will use this
	// value to unpack and fix up the pointers during GetConnectionSettings
	if(lpn)
	{
		if(lpn->lpszShortName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszShortName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszShortName, dwTemp);

			// Store the offset
                        lpnPacked->lpszShortName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

		if(lpn->lpszLongName)
		{
			// Copy the string
			dwTemp = WSTRLEN(lpn->lpszLongName) * sizeof(WCHAR);
			memcpy(lpCurrent, lpn->lpszLongName, dwTemp);

			// Store the offset
                        lpnPacked->lpszLongName = (LPWSTR)(DWORD_PTR)(lpCurrent - lpStart);

			lpCurrent += dwTemp;
		}

	}

    // Copy in the SP-specific data
    if(lpConn->lpAddress)
    {
        // Copy the data
        memcpy(lpCurrent, lpConn->lpAddress, lpConn->dwAddressSize);

        // Store the offset
        ((LPDPLCONNECTION)lpStart)->lpAddress = (LPVOID)(DWORD_PTR)(lpCurrent - lpStart);
    }

    return DP_OK;

} // PRV_PackageDPLCONNECTION



#define MAX_DPLCONNECTIONBUFFERSIZE	(MAX_APPDATABUFFERSIZE -sizeof(DPLOBBYI_CONNCONTROL))


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONUnicode"
// NOTE : really need to define a WIRE LPDPLCONNECTION so that
//        we can crack it that way.  This will allow compile, until
//        we can test on Win64, there is no way to verify cracking
//        the packet, so I've deffered this work until then AO 11/10/98
// not bringing DP4 to Win64 AO 04/03/2001
HRESULT PRV_UnpackageDPLCONNECTIONUnicode(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConn = NULL;
	LPDPSESSIONDESC2				lpsd = NULL;
	LPDPNAME						lpn = NULL;
	LPBYTE							lpPackCur, lpDataStart;
	DWORD_PTR						dwSize;
	
	PCHAR							pBufStart=(PCHAR)lpPackage;
	PCHAR							pBufEnd=(PCHAR)lpPackage+MAX_DPLCONNECTIONBUFFERSIZE-3;

	HRESULT					 		hr=DP_OK;

	// SECURITY: ensure NULL termination for string scanning.
	((LPBYTE)lpPackage)[MAX_DPLCONNECTIONBUFFERSIZE-1]=0;
	((LPBYTE)lpPackage)[MAX_DPLCONNECTIONBUFFERSIZE-2]=0;

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Unicode, all we need to do is copy the entire package
	// and fix up the pointers
	lpHeader = (LPDPLOBBYI_PACKEDCONNHEADER)lpPackage;
	dwSize = lpHeader->dwUnicodeSize;
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataStart = lpData;
	
	// Copy the data
	memcpy(lpData, lpPackCur, (DWORD)dwSize);

	// Fix up the pointers -- the offset of every element relative to
	// the start of lpConn is stored in the pointer for the element.
	// So all we have to do to fix up the pointers is calculate it from
	// the given offset + the value of lpConn.
	lpConn = (LPDPLCONNECTION)lpData;

	if(lpConn->lpSessionDesc)
	{
		if((UINT)lpConn->lpSessionDesc > MAX_DPLCONNECTIONBUFFERSIZE-(sizeof(DPSESSIONDESC2)))
		{
			DPF(4,"SECURITY WARN: Invalid offset in shared memory");
			hr=DPERR_GENERIC;
			goto err_exit;
		}
		dwSize = (DWORD_PTR)lpConn->lpSessionDesc;
		lpsd = lpConn->lpSessionDesc = (LPDPSESSIONDESC2)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpsd->lpszSessionName)
		{
			if((UINT)lpsd->lpszSessionName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid offset in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpsd->lpszSessionName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszSessionName));
		}

		if(lpsd->lpszPassword)
		{
			if((UINT)lpsd->lpszPassword > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid offset in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpsd->lpszPassword = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpsd->lpszPassword));
		}
	}

	if(lpConn->lpPlayerName)
	{
		if((UINT)lpConn->lpPlayerName > MAX_DPLCONNECTIONBUFFERSIZE-(sizeof(DPNAME)))
		{
			DPF(4,"SECURITY WARN: Invalid offset in shared memory");
			hr=DPERR_GENERIC;
			goto err_exit;
		}
		dwSize = (DWORD_PTR)lpConn->lpPlayerName;
		lpn = lpConn->lpPlayerName = (LPDPNAME)(lpDataStart + dwSize);

		// Now do the same for the strings
		if(lpn->lpszShortName)
		{
			if((UINT)lpn->lpszShortName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid offset in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpn->lpszShortName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszShortName));
		}

		if(lpn->lpszLongName)
		{
			if((UINT)lpn->lpszLongName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid offset in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpn->lpszLongName = (LPWSTR)(lpDataStart +
								((DWORD_PTR)lpn->lpszLongName));
		}

	}

	// Fix the SPData pointer
	if(lpConn->lpAddress)
	{
		if((UINT)lpConn->lpAddress > MAX_DPLCONNECTIONBUFFERSIZE-(sizeof(DPADDRESS)) ||
			(UINT)lpConn->lpAddress+lpConn->dwAddressSize > MAX_DPLCONNECTIONBUFFERSIZE-3)
		{
			DPF(4,"SECURITY WARN: Invalid offset in shared memory");
			hr=DPERR_GENERIC;
			goto err_exit;
		}
		lpConn->lpAddress = lpDataStart + ((DWORD_PTR)lpConn->lpAddress);
	}

	return DP_OK;

err_exit:
	return hr;

} // PRV_UnpackageDPLCONNECTIONUnicode


#undef DPF_MODNAME
#define DPF_MODNAME "PRV_UnpackageDPLCONNECTIONAnsi"
HRESULT PRV_UnpackageDPLCONNECTIONAnsi(LPVOID lpData, LPVOID lpPackage)
{
	LPDPLOBBYI_PACKEDCONNHEADER		lpHeader = NULL;
	LPDPLCONNECTION					lpConnData, lpConnPack;
	LPDPSESSIONDESC2				lpsdData = NULL,
									lpsdPack = NULL;
	LPDPNAME						lpnData = NULL,
									lpnPack = NULL;
	LPBYTE							lpDataCur, lpPackCur;
	DWORD							dwTemp;
	LPWSTR							lpszTemp;

	HRESULT					 		hr=DP_OK;


	// SECURITY: ensure NULL termination for string scanning.
	((LPBYTE)lpPackage)[MAX_DPLCONNECTIONBUFFERSIZE -1]=0;
	((LPBYTE)lpPackage)[MAX_DPLCONNECTIONBUFFERSIZE -2]=0;

	DPF(7, "Entering PRV_UnpackageDPLCONNECTIONAnsi");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpData, lpPackage);

	// If we're Ansi, we need to do is copy the structures, convert
	// and copy the strings, and fix up all the pointers
	lpPackCur = ((LPBYTE)lpPackage) + sizeof(DPLOBBYI_PACKEDCONNHEADER);
	lpDataCur = lpData;
	
	// First copy the main structures
	dwTemp = sizeof(DPLCONNECTION);
	memcpy(lpDataCur, lpPackCur, dwTemp);
	lpConnData = (LPDPLCONNECTION)lpDataCur;
	lpConnPack = (LPDPLCONNECTION)lpPackCur;

	lpDataCur += dwTemp;
	lpPackCur += dwTemp;

	if(lpConnData->lpSessionDesc)
	{
		dwTemp = sizeof(DPSESSIONDESC2);
		memcpySecureS(lpDataCur, lpPackCur, sizeof(DPSESSIONDESC2),lpPackage,MAX_DPLCONNECTIONBUFFERSIZE,"SECURITY WARN: Invalid Session Description in shared memory",hr=DPERR_GENERIC,err_exit);
		lpsdData = lpConnData->lpSessionDesc = (LPDPSESSIONDESC2)lpDataCur;
		lpsdPack = (LPDPSESSIONDESC2)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	if(lpConnData->lpPlayerName)
	{
		dwTemp = sizeof(DPNAME);
		memcpySecureS(lpDataCur, lpPackCur, sizeof(DPNAME),lpPackage,MAX_DPLCONNECTIONBUFFERSIZE,"SECURITY WARN: Invalid DPNAME in shared memory",hr=DPERR_GENERIC,err_exit);
		lpnData = lpConnData->lpPlayerName = (LPDPNAME)lpDataCur;
		lpnPack = (LPDPNAME)lpPackCur;
		lpDataCur += dwTemp;
		lpPackCur += dwTemp;
	}

	// Copy the strings & fix up the pointers
	if(lpsdData)
	{
		if(lpsdData->lpszSessionName)
		{
			if((UINT)lpsdData->lpszSessionName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid Session Name in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszSessionName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszSessionNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpsdData->lpszPassword)
		{
			if((UINT)lpsdData->lpszPassword > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid Password in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpsdPack->lpszPassword);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpsdData->lpszPasswordA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}
	}

	if(lpnData)
	{
		if(lpnData->lpszShortName)
		{
			if((UINT)lpnData->lpszShortName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid Short Name in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszShortName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszShortNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

		if(lpnData->lpszLongName)
		{
			if((UINT)lpnData->lpszLongName > MAX_DPLCONNECTIONBUFFERSIZE-3){
				DPF(4,"SECURITY WARN: Invalid Long Name in shared memory");
				hr=DPERR_GENERIC;
				goto err_exit;
			}
			lpszTemp = (LPWSTR)((LPBYTE)lpConnPack + (DWORD_PTR)lpnPack->lpszLongName);
			dwTemp = WideToAnsi(NULL, lpszTemp, 0);	// size includes terminator
			WideToAnsi((LPSTR)lpDataCur, lpszTemp, dwTemp);
			lpnData->lpszLongNameA = (LPSTR)lpDataCur;
			lpDataCur += dwTemp;
		}

	}

	// Copy in the SPData & fix up the pointer
	if(lpConnData->lpAddress)
	{
		lpPackCur = ((LPBYTE)lpConnPack) + (DWORD_PTR)lpConnPack->lpAddress;
		memcpySecureS(lpDataCur, lpPackCur, lpConnPack->dwAddressSize,lpPackage,MAX_DPLCONNECTIONBUFFERSIZE,"SECURITY WARN: Invalid ADDRESS in shared memory",hr=DPERR_GENERIC,err_exit);
		lpConnData->lpAddress = lpDataCur;
	}

	return DP_OK;

err_exit:
	return hr;

} // PRV_UnpackageDPLCONNECTIONAnsi




#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPLCONNECTION"
HRESULT PRV_ValidateDPLCONNECTION(LPDPLCONNECTION lpConn, BOOL bAnsi)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;


	DPF(7, "Entering PRV_ValidateDPLCONNECTION");
	DPF(9, "Parameters: 0x%08x, %lu", lpConn, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(!VALID_DPLOBBY_CONNECTION(lpConn))
		{
			DPF_ERR("Invalid DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(lpConn->dwFlags & ~(DPLCONNECTION_CREATESESSION | DPLCONNECTION_JOINSESSION))
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPLCONNECTION structure");
			return DPERR_INVALIDFLAGS;
		}

		// Validate the SessionDesc structure
		if(lpConn->lpSessionDesc)
		{
			lpsd = lpConn->lpSessionDesc;
			// Validate the structure itself
			if(!VALID_READ_DPSESSIONDESC2(lpsd))
			{
				DPF_ERR("Invalid DPSESSIONDESC2 structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the SessionName string
			if(lpsd->lpszSessionName)
			{
				if(!VALID_READ_PTR(lpsd->lpszSessionName, (bAnsi ?
					strlen(lpsd->lpszSessionNameA) : WSTRLEN_BYTES(lpsd->lpszSessionName))))
				{
					DPF_ERR("Invalid SessionName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the Password string
			if(lpsd->lpszPassword)
			{
				if(!VALID_READ_PTR(lpsd->lpszPassword, (bAnsi ?
					strlen(lpsd->lpszPasswordA) : WSTRLEN_BYTES(lpsd->lpszPassword))))
				{
					DPF_ERR("Invalid Password string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}
		else
		{
			DPF_ERR("Invalid SessionDesc pointer in DPLCONNECTION structure");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Name structure
		if(lpConn->lpPlayerName)
		{
			lpn = lpConn->lpPlayerName;
			if(!VALID_READ_DPNAME_PTR(lpn))
			{
				DPF_ERR("Invalid DPNAME structure in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}

			// Validate the ShortName string
			if(lpn->lpszShortName)
			{
				if(!VALID_READ_PTR(lpn->lpszShortName, (bAnsi ?
					strlen(lpn->lpszShortNameA) : WSTRLEN_BYTES(lpn->lpszShortName))))
				{
					DPF_ERR("Invalid ShortName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}

			// Validate the LongName string
			if(lpn->lpszLongName)
			{
				if(!VALID_READ_PTR(lpn->lpszLongName, (bAnsi ?
					strlen(lpn->lpszLongNameA) : WSTRLEN_BYTES(lpn->lpszLongName))))
				{
					DPF_ERR("Invalid LongName string in DPLCONNECTION structure");
					return DPERR_INVALIDPARAMS;
				}
			}
		}

		// Validate the DPADDRESS structure
		if(lpConn->lpAddress)
		{
			if(!VALID_READ_PTR(lpConn->lpAddress, lpConn->dwAddressSize))
			{
				DPF_ERR("Invalid lpAddress in DPLCONNECTION structure");
				return DPERR_INVALIDPARAMS;
			}
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPLCONNECTION



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToUnicode"
HRESULT PRV_ConvertDPLCONNECTIONToUnicode(LPDPLCONNECTION lpConnA,
					LPDPLCONNECTION * lplpConnW)
{
	LPDPLCONNECTION		lpConnW = NULL;
	LPDPSESSIONDESC2	lpsdW = NULL, lpsdA;
	LPDPNAME			lpnW = NULL, lpnA;
	LPWSTR				lpwszSessionName = NULL;
	LPWSTR				lpwszPassword = NULL;
	LPWSTR				lpwszLongName = NULL;
	LPWSTR				lpwszShortName = NULL;
	HRESULT				hr = DP_OK;


	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToUnicode");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpConnA, lplpConnW);

	ASSERT(lpConnA);
	ASSERT(lplpConnW);


	// Allocate memory for the DPLCONNECTION structure
	lpConnW = DPMEM_ALLOC(sizeof(DPLCONNECTION));
	if(!lpConnW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPLCONNECTION struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPLCONNECTION;
	}

	// If we need a SessionDesc struct, allocate one
	if(lpConnA->lpSessionDesc)
	{
		lpsdW = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
		if(!lpsdW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPSESSIONDESC struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// If we need a DPName struct, allocate one
	if(lpConnA->lpPlayerName)
	{
		lpnW = DPMEM_ALLOC(sizeof(DPNAME));
		if(!lpnW)
		{
			DPF_ERR("Unable to allocate memory for temporary Unicode DPNAME struct");
			hr = DPERR_OUTOFMEMORY;
			goto ERROR_CONVERT_DPLCONNECTION;
		}
	}

	// Copy the fixed size members of the structures
	memcpy(lpConnW, lpConnA, sizeof(DPLCONNECTION));
	if(lpsdW)
		memcpy(lpsdW, lpConnA->lpSessionDesc, sizeof(DPSESSIONDESC2));
	if(lpnW)
		memcpy(lpnW, lpConnA->lpPlayerName, sizeof(DPNAME));


	// Get Unicode copies of all the strings
	if(lpConnA->lpSessionDesc)
	{
		lpsdA = lpConnA->lpSessionDesc;
		if(lpsdA->lpszSessionNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszSessionName),
										(LPSTR)lpsdA->lpszSessionNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Session Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpsdA->lpszPasswordA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszPassword),
										(LPSTR)lpsdA->lpszPasswordA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Password string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	if(lpConnA->lpPlayerName)
	{
		lpnA = lpConnA->lpPlayerName;
		if(lpnA->lpszShortNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszShortName),
										(LPSTR)lpnA->lpszShortNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Short Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}

		if(lpnA->lpszLongNameA)
		{
			hr = GetWideStringFromAnsi((LPWSTR *)&(lpwszLongName),
										(LPSTR)lpnA->lpszLongNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to allocate temporary Unicode Long Name string");
				goto ERROR_CONVERT_DPLCONNECTION;
			}
		}
	}    

	// Now we've got everything so just fix up the pointers
	lpConnW->lpSessionDesc = lpsdW;
	lpConnW->lpPlayerName = lpnW;

	if(lpsdW)
	{
		lpsdW->lpszSessionName = lpwszSessionName;
		lpsdW->lpszPassword = lpwszPassword;
	}

	if(lpnW)
	{
		lpnW->lpszShortName = lpwszShortName;
		lpnW->lpszLongName = lpwszLongName;
	}

	*lplpConnW = lpConnW;

	return DP_OK;


ERROR_CONVERT_DPLCONNECTION:

	if(lpConnW)
		DPMEM_FREE(lpConnW);
	if(lpsdW)
		DPMEM_FREE(lpsdW);
	if(lpnW)
		DPMEM_FREE(lpnW);
	if(lpwszSessionName)
		DPMEM_FREE(lpwszSessionName);
	if(lpwszPassword)
		DPMEM_FREE(lpwszPassword);
	if(lpwszShortName)
		DPMEM_FREE(lpwszShortName);
	if(lpwszLongName)
		DPMEM_FREE(lpwszLongName);

	return hr;		

} // PRV_ConvertDPLCONNECTIONToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FixupDPLCONNECTIONPointers"
void PRV_FixupDPLCONNECTIONPointers(LPDPLCONNECTION lpConn)
{
	LPDPSESSIONDESC2	lpsd = NULL;
	LPDPNAME			lpn = NULL;
	

	DPF(7, "Entering PRV_FixupDPLCONNECTIONPointers");
	DPF(9, "Parameters: 0x%08x", lpConn);

	// Make sure we have a valid DPLCONNECTION pointer
	if(!lpConn)
	{
		DPF_ERR("Invalid DPLCONNECTION pointer");
		ASSERT(FALSE);
		return;
	}

	// Fixup the DPSESSIONDESC2 pointer
	if(lpConn->lpSessionDesc)
	{
		lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
		lpConn->lpSessionDesc = lpsd;
	}

	// Fixup the name strings in the SessionDesc struct
	if(lpsd)
	{
		// Fixup the session name
		if(lpsd->lpszSessionName)
		{
			lpsd->lpszSessionName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszSessionName);
		}

		// Fixup the password
		if(lpsd->lpszPassword)
		{
			lpsd->lpszPassword = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpsd->lpszPassword);
		}
	}

	// Fixup the DPNAME pointer
	if(lpConn->lpPlayerName)
	{
		lpn = (LPDPNAME)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpPlayerName);
		lpConn->lpPlayerName = lpn;
	}

	// Fixup the name strings
	if(lpn)
	{
		// Fixup the short name
		if(lpn->lpszShortName)
		{
			lpn->lpszShortName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszShortName);
		}

		// Fixup the long name
		if(lpn->lpszLongName)
		{
			lpn->lpszLongName = (LPWSTR)((LPBYTE)lpConn +
				(DWORD_PTR)lpn->lpszLongName);
		}
	}

	// Fixup the address pointer
	if(lpConn->lpAddress)
	{
		lpConn->lpAddress = (LPBYTE)lpConn + (DWORD_PTR)lpConn->lpAddress;
	}

} // PRV_FixupDPLCONNECTIONPointers



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPLCONNECTIONToAnsiInPlace"
HRESULT PRV_ConvertDPLCONNECTIONToAnsiInPlace(LPDPLCONNECTION lpConn,
		LPDWORD lpdwSize, DWORD dwHeaderSize)
{
	DWORD					dwSessionNameSize = 0, dwPasswordSize = 0;
	DWORD					dwShortNameSize = 0, dwLongNameSize = 0;
	DWORD					dwSessionDescSize = 0, dwNameSize = 0;
	DWORD					dwAnsiSize = 0;
	LPSTR					lpszSession = NULL, lpszPassword = 0;
	LPSTR					lpszShort = NULL, lpszLong = 0;
	LPBYTE					lpByte = NULL;

	
	DPF(7, "Entering PRV_ConvertDPLCONNECTIONToAnsiInPlace");
	DPF(9, "Parameters: 0x%08x, 0x%08x, %lu",
			lpConn, lpdwSize, dwHeaderSize);

	// If we don't have a DPLCONNECTION struct, something's wrong
	ASSERT(lpConn);
	ASSERT(lpdwSize);

	// Start with the DPSESSIONDESC2 strings
	if(lpConn->lpSessionDesc)
	{
		if(lpConn->lpSessionDesc->lpszSessionName)
		{
			GetAnsiString(&lpszSession, lpConn->lpSessionDesc->lpszSessionName);
			dwSessionNameSize = STRLEN(lpszSession);
		}

		if(lpConn->lpSessionDesc->lpszPassword)
		{
			GetAnsiString(&lpszPassword, lpConn->lpSessionDesc->lpszPassword);
			dwPasswordSize = STRLEN(lpszPassword);
		}
		dwSessionDescSize = sizeof(DPSESSIONDESC2) + dwSessionNameSize +
								dwPasswordSize;
	}

	// Next the DPNAME strings
	if(lpConn->lpPlayerName)
	{
		if(lpConn->lpPlayerName->lpszShortName)
		{
			GetAnsiString(&lpszShort, lpConn->lpPlayerName->lpszShortName);
			dwShortNameSize = STRLEN(lpszShort);
		}

		if(lpConn->lpPlayerName->lpszLongName)
		{
			GetAnsiString(&lpszLong, lpConn->lpPlayerName->lpszLongName);
			dwLongNameSize = STRLEN(lpszLong);
		}
		dwNameSize = sizeof(DPNAME) + dwShortNameSize + dwLongNameSize;
	}

	dwAnsiSize = dwHeaderSize + sizeof(DPLCONNECTION) +
				dwSessionDescSize + dwNameSize + lpConn->dwAddressSize;

	if (dwAnsiSize > *lpdwSize)
	{
		if(lpszSession)
			DPMEM_FREE(lpszSession);
		if(lpszPassword)
			DPMEM_FREE(lpszPassword);
		if(lpszShort)
			DPMEM_FREE(lpszShort);
		if(lpszLong)
			DPMEM_FREE(lpszLong);
		*lpdwSize = dwAnsiSize;
		return DPERR_BUFFERTOOSMALL;
	}

	// store return size
	*lpdwSize = dwAnsiSize;

	// figure out where to start repacking strings
	lpByte = (LPBYTE)lpConn + sizeof(DPLCONNECTION);
	if(lpConn->lpSessionDesc)
		lpByte += sizeof(DPSESSIONDESC2);
	if(lpConn->lpPlayerName)
		lpByte += sizeof(DPNAME);

	// repack 'em
	if(lpszSession)
	{
		memcpy(lpByte, lpszSession, dwSessionNameSize);
		lpConn->lpSessionDesc->lpszSessionNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszSession);
		lpByte += dwSessionNameSize;
	}
	if(lpszPassword)
	{
		memcpy(lpByte, lpszPassword, dwPasswordSize);
		lpConn->lpSessionDesc->lpszPasswordA = (LPSTR)lpByte;
		DPMEM_FREE(lpszPassword);
		lpByte += dwPasswordSize;
	}
	if(lpszShort)
	{
		memcpy(lpByte, lpszShort, dwShortNameSize);
		lpConn->lpPlayerName->lpszShortNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszShort);
		lpByte += dwShortNameSize;
	}
	if(lpszLong)
	{
		memcpy(lpByte, lpszLong, dwLongNameSize);
		lpConn->lpPlayerName->lpszLongNameA = (LPSTR)lpByte;
		DPMEM_FREE(lpszLong);
		lpByte += dwLongNameSize;
	}

	if(lpConn->lpAddress)
	{
		// recopy the address, and account for the fact that we could
		// be doing an overlapping memory copy (So use MoveMemory instead
		// of CopyMemory or memcpy)
		MoveMemory(lpByte, lpConn->lpAddress, lpConn->dwAddressSize);
		lpConn->lpAddress = lpByte;
	}

	return DP_OK;
} // PRV_ConvertDPLCONNECTIONToAnsiInPlace



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ValidateDPAPPLICATIONDESC"
HRESULT PRV_ValidateDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc, BOOL bAnsi)
{
	DWORD LobbyDescVer;
	LPDPAPPLICATIONDESC2 lpDesc2=(LPDPAPPLICATIONDESC2) lpDesc;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, %lu", lpDesc, bAnsi);
	

	TRY
	{
		// Validate the connection structure itself
		if(VALID_DPLOBBY_APPLICATIONDESC(lpDesc)){
			LobbyDescVer=1;
		} else if (VALID_DPLOBBY_APPLICATIONDESC2(lpDesc)){
			LobbyDescVer=2;
		} else {
			DPF_ERR("Invalid structure pointer or invalid size");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the flags
		if(!VALID_REGISTERAPP_FLAGS(lpDesc->dwFlags))
		{
			DPF_ERR("Invalid flags exist in the dwFlags member of the DPAPPLICATIONDESC structure");
			return DPERR_INVALIDFLAGS;
		}
		if((lpDesc->dwFlags & (DPLAPP_AUTOVOICE|DPLAPP_SELFVOICE))==(DPLAPP_AUTOVOICE|DPLAPP_SELFVOICE))
		{
			return DPERR_INVALIDFLAGS;
		}

		// Validate the ApplicationName string (required)
		if(lpDesc->lpszApplicationName)
		{
			if(!VALID_READ_PTR(lpDesc->lpszApplicationName, (bAnsi ?
				strlen(lpDesc->lpszApplicationNameA) :
				WSTRLEN_BYTES(lpDesc->lpszApplicationName))))
			{
				DPF_ERR("Invalid lpszApplicationName string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszApplicationName member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the GUID (required)
		// We can really only check this against GUID_NULL since it will
		// always be a valid guid structure inside the APPDESC struct
		if(IsEqualGUID(&lpDesc->guidApplication, &GUID_NULL))
		{
			DPF_ERR("The guidApplication member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the Filename string (required)
		if(lpDesc->lpszFilename)
		{
			if(!VALID_READ_PTR(lpDesc->lpszFilename, (bAnsi ?
				strlen(lpDesc->lpszFilenameA) :
				WSTRLEN_BYTES(lpDesc->lpszFilename))))
			{
				DPF_ERR("Invalid lpszFilename string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszFilename member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CommandLine string (optional)
		if(lpDesc->lpszCommandLine)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCommandLine, (bAnsi ?
				strlen(lpDesc->lpszCommandLineA) :
				WSTRLEN_BYTES(lpDesc->lpszCommandLine))))
			{
				DPF_ERR("Invalid lpszCommandLine string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the Path string (required)
		if(lpDesc->lpszPath)
		{
			if(!VALID_READ_PTR(lpDesc->lpszPath, (bAnsi ?
				strlen(lpDesc->lpszPathA) :
				WSTRLEN_BYTES(lpDesc->lpszPath))))
			{
				DPF_ERR("Invalid lpszPath string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}
		else
		{
			DPF_ERR("The lpszPath member of the DPAPPLICTIONDESC structure is required");
			return DPERR_INVALIDPARAMS;
		}

		// Validate the CurrentDirectory string (optional)
		if(lpDesc->lpszCurrentDirectory)
		{
			if(!VALID_READ_PTR(lpDesc->lpszCurrentDirectory, (bAnsi ?
				strlen(lpDesc->lpszCurrentDirectoryA) :
				WSTRLEN_BYTES(lpDesc->lpszCurrentDirectory))))
			{
				DPF_ERR("Invalid lpszCurrentDirectory string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionA string (optional)
		if(lpDesc->lpszDescriptionA)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionA,
				strlen(lpDesc->lpszDescriptionA)))
			{
				DPF_ERR("Invalid lpszDescriptionA string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// Validate the DescriptionW string (optional)
		if(lpDesc->lpszDescriptionW)
		{
			if(!VALID_READ_PTR(lpDesc->lpszDescriptionW,
				WSTRLEN_BYTES(lpDesc->lpszDescriptionW)))
			{
				DPF_ERR("Invalid lpszDescriptionW string in DPAPPLICTIONDESC structure");
				return DPERR_INVALIDPARAMS;
			}
		}

		// if the DPAPPLICATIONDESC2 is being used, validate the launcher name if present
		if(LobbyDescVer==2)
		{
			// Validate AppLauncherName Name
			if(lpDesc2->lpszAppLauncherNameA){
				if(!VALID_READ_PTR(lpDesc2->lpszAppLauncherNameA, (bAnsi ?
					strlen(lpDesc2->lpszAppLauncherNameA) :
					WSTRLEN_BYTES(lpDesc2->lpszAppLauncherName))))
				{
					DPF_ERR("Invalid lpszAppLauncherName string in DPAPPLICATIONDESC2 structure");
					return DPERR_INVALIDPARAMS;
				}
			}	
		}
	}

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	return DP_OK;

} // PRV_ValidateDPAPPLICATIONDESC



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToUnicode"
HRESULT PRV_ConvertDPAPPLICATIONDESCToUnicode(LPDPAPPLICATIONDESC lpDescA,
					LPDPAPPLICATIONDESC * lplpDescW)
{
	#define lpDesc2A ((LPDPAPPLICATIONDESC2) lpDescA)
	#define lpDesc2W ((LPDPAPPLICATIONDESC2) lpDescW)

	LPDPAPPLICATIONDESC		lpDescW = NULL;
	LPWSTR					lpwszApplicationName = NULL;
	LPWSTR					lpwszFilename = NULL;
	LPWSTR					lpwszCommandLine = NULL;
	LPWSTR					lpwszPath = NULL;
	LPWSTR					lpwszCurrentDirectory = NULL;
	LPWSTR					lpwszAppLauncherName = NULL;
	HRESULT					hr;


	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescA, lplpDescW);

	ASSERT(lpDescA);
	ASSERT(lplpDescW);

	
	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescW = DPMEM_ALLOC(lpDescA->dwSize);
	if(!lpDescW)
	{
		DPF_ERR("Unable to allocate memory for temporary Unicode DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
	}

	// Copy the structure itself
	memcpy(lpDescW, lpDescA, lpDescA->dwSize);

	// Convert the ApplicationName
	if(lpDescA->lpszApplicationNameA)
	{
		hr = GetWideStringFromAnsi(&lpwszApplicationName,
				lpDescA->lpszApplicationNameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Filename
	if(lpDescA->lpszFilenameA)
	{
		hr = GetWideStringFromAnsi(&lpwszFilename,
				lpDescA->lpszFilenameA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CommandLine
	if(lpDescA->lpszCommandLineA)
	{
		hr = GetWideStringFromAnsi(&lpwszCommandLine,
				lpDescA->lpszCommandLineA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the Path
	if(lpDescA->lpszPathA)
	{
		hr = GetWideStringFromAnsi(&lpwszPath,
				lpDescA->lpszPathA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescA->lpszCurrentDirectoryA)
	{
		hr = GetWideStringFromAnsi(&lpwszCurrentDirectory,
				lpDescA->lpszCurrentDirectoryA);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
		}
	}

	// Convert the AppLauncher string if presend on an APPLICATIONDESC2
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDescA)){
		if(lpDesc2A->lpszAppLauncherNameA){
			hr = GetWideStringFromAnsi(&lpwszAppLauncherName,
					lpDesc2A->lpszAppLauncherNameA);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert CurrentDirectory string to Unicode");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE;
			}
		} 
		lpDesc2W->lpszAppLauncherName=lpwszAppLauncherName;
	}

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescW->lpszApplicationName = lpwszApplicationName;
	lpDescW->lpszFilename = lpwszFilename;
	lpDescW->lpszCommandLine = lpwszCommandLine;
	lpDescW->lpszPath = lpwszPath;
	lpDescW->lpszCurrentDirectory = lpwszCurrentDirectory;
	
	lpDescW->lpszDescriptionA = lpDescA->lpszDescriptionA;
	lpDescW->lpszDescriptionW = lpDescA->lpszDescriptionW;

	// Set the output pointer
	*lplpDescW = lpDescW;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_UNICODE:

	if(lpwszApplicationName)
		DPMEM_FREE(lpwszApplicationName);
	if(lpwszFilename)
		DPMEM_FREE(lpwszFilename);
	if(lpwszCommandLine)
		DPMEM_FREE(lpwszCommandLine);
	if(lpwszPath)
		DPMEM_FREE(lpwszPath);
	if(lpwszCurrentDirectory)
		DPMEM_FREE(lpwszCurrentDirectory);
	if(lpDescW)
		DPMEM_FREE(lpDescW);
	if(lpwszAppLauncherName){
		DPMEM_FREE(lpwszAppLauncherName);
	}

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W 
	
} // PRV_ConvertDPAPPLICATIONDESCToUnicode



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_ConvertDPAPPLICATIONDESCToAnsi"
HRESULT PRV_ConvertDPAPPLICATIONDESCToAnsi(LPDPAPPLICATIONDESC lpDescW,
					LPDPAPPLICATIONDESC * lplpDescA)
{
	#define lpDesc2W ((LPDPAPPLICATIONDESC2)(lpDescW))
	#define lpDesc2A ((LPDPAPPLICATIONDESC2)(lpDescA))

	LPDPAPPLICATIONDESC		lpDescA = NULL;
	LPSTR					lpszApplicationName = NULL;
	LPSTR					lpszFilename = NULL;
	LPSTR					lpszCommandLine = NULL;
	LPSTR					lpszPath = NULL;
	LPSTR					lpszCurrentDirectory = NULL;
	LPSTR					lpszAppLauncherName=NULL;
	HRESULT					hr;

	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpDescW, lplpDescA);

	ASSERT(lpDescW);
	ASSERT(lplpDescA);

	// Allocate memory for the DPAPPLICATIONDESC structure
	lpDescA = DPMEM_ALLOC(lpDescW->dwSize);
	if(!lpDescA)
	{
		DPF_ERR("Unable to allocate memory for temporary Ansi DPAPPLICATIONDESC struct");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
	}

	// Copy the structure itself
	memcpy(lpDescA, lpDescW, lpDescW->dwSize);

	// Convert the ApplicationName
	if(lpDescW->lpszApplicationName)
	{
		hr = GetAnsiString(&lpszApplicationName, lpDescW->lpszApplicationName);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert ApplicationName string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Filename
	if(lpDescW->lpszFilename)
	{
		hr = GetAnsiString(&lpszFilename, lpDescW->lpszFilename);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Filename string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CommandLine
	if(lpDescW->lpszCommandLine)
	{
		hr = GetAnsiString(&lpszCommandLine, lpDescW->lpszCommandLine);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CommandLine string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the Path
	if(lpDescW->lpszPath)
	{
		hr = GetAnsiString(&lpszPath, lpDescW->lpszPath);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert Path string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convert the CurrentDirectory
	if(lpDescW->lpszCurrentDirectory)
	{
		hr = GetAnsiString(&lpszCurrentDirectory, lpDescW->lpszCurrentDirectory);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to convert CurrentDirectory string to Ansi");
			goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
		}
	}

	// Convers the app launcher string if present.
	if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc2W)){
		if(lpDesc2W->lpszAppLauncherName){
			hr = GetAnsiString(&lpszAppLauncherName, lpDesc2W->lpszAppLauncherName);
			if(FAILED(hr))
			{
				DPF_ERR("Unable to convert AppLauncherName string to Ansi");
				goto ERROR_CONVERT_DPAPPLICATIONDESC_ANSI;
			}
		} 
		lpDesc2A->lpszAppLauncherNameA = lpszAppLauncherName;
	}	

	// We won't convert the description strings because they will
	// get put in the registry as-is.

	// So now that we have all the strings, setup the structure
	lpDescA->lpszApplicationNameA = lpszApplicationName;
	lpDescA->lpszFilenameA = lpszFilename;
	lpDescA->lpszCommandLineA = lpszCommandLine;
	lpDescA->lpszPathA = lpszPath;
	lpDescA->lpszCurrentDirectoryA = lpszCurrentDirectory;
	
	lpDescA->lpszDescriptionA = lpDescW->lpszDescriptionA;
	lpDescA->lpszDescriptionW = lpDescW->lpszDescriptionW;

	// Set the output pointer
	*lplpDescA = lpDescA;

	return DP_OK;

ERROR_CONVERT_DPAPPLICATIONDESC_ANSI:

	if(lpszApplicationName)
		DPMEM_FREE(lpszApplicationName);
	if(lpszFilename)
		DPMEM_FREE(lpszFilename);
	if(lpszCommandLine)
		DPMEM_FREE(lpszCommandLine);
	if(lpszPath)
		DPMEM_FREE(lpszPath);
	if(lpszCurrentDirectory)
		DPMEM_FREE(lpszCurrentDirectory);
	if(lpDescA)
		DPMEM_FREE(lpDescA);
	if(lpszAppLauncherName)
		DPMEM_FREE(lpszAppLauncherName);

	return hr;

	#undef lpDesc2A
	#undef lpDesc2W
} // PRV_ConvertDPAPPLICATIONDESCToAnsi



#undef DPF_MODNAME
#define DPF_MODNAME "PRV_FreeLocalDPAPPLICATIONDESC"
void PRV_FreeLocalDPAPPLICATIONDESC(LPDPAPPLICATIONDESC lpDesc)
{
	LPDPAPPLICATIONDESC2 lpDesc2 = (LPDPAPPLICATIONDESC2)lpDesc;
	DPF(7, "Entering PRV_ValidateDPAPPLICATIONDESC");
	DPF(9, "Parameters: 0x%08x", lpDesc);

	if(lpDesc)
	{
		if(lpDesc->lpszApplicationName)
			DPMEM_FREE(lpDesc->lpszApplicationName);
		if(lpDesc->lpszFilename)
			DPMEM_FREE(lpDesc->lpszFilename);
		if(lpDesc->lpszCommandLine)
			DPMEM_FREE(lpDesc->lpszCommandLine);
		if(lpDesc->lpszPath)
			DPMEM_FREE(lpDesc->lpszPath);
		if(lpDesc->lpszCurrentDirectory)
			DPMEM_FREE(lpDesc->lpszCurrentDirectory);
		if(IS_DPLOBBY_APPLICATIONDESC2(lpDesc) && lpDesc2->lpszAppLauncherName)
			DPMEM_FREE(lpDesc2->lpszAppLauncherName);

		// Note: We don't need to free the Description strings because they
		// were never allocated in either of the above routines, the pointers
		// were just copied.

		DPMEM_FREE(lpDesc);
	}

} // PRV_FreeLocalDPAPPLICATIONDESC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplobby\dplsp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplsp.c
 *  Content:	DirectPlayLobby Service Provider interface code
 *
 *  History:
 *	Date		By		Reason
 *	=======		=======	======
 *	10/23/96	myronth	Created it
 *	11/20/96	myronth Added DPLAPI to function declarations
 *	2/12/97		myronth	Mass DX5 changes
 *	2/18/97		myronth	Implemented GetObjectCaps
 *	2/26/97		myronth	#ifdef'd out DPASYNCDATA stuff (removed dependency)
 *	3/31/97		myronth	Implemented all IDPLobbySP methods without putting
 *						player management message in the message queue.
 *						Removed dead code
 *	4/4/97		myronth	Changed IDPLobbySP methods' structure names and
 *						implemented system messages for all of them
 *  4/27/97     sohailm Updated calls to HandlePlayerMessage to reflect new params
 *	5/8/97		myronth	All remote subgroup functions for IDPLobbySP
 *						including StartSession, Purged dead code
 *	5/12/97		myronth	Extra semi-colon bug fixes, Fixed group player count
 *						decrement that was in the wrong place
 *	5/14/97		myronth	Allow CreateGroup message to pass even if the
 *						Group ID is in the map table (bug #8354).
 *	5/17/97		myronth	Fixed HandleMessage, Added SendChatMessage
 *	5/17/97		myronth	Filtered some message to certain groups, Fixed calls
 *						to CreateAndMapNewGroup which needed a parent ID
 *	5/20/97		myronth	Changed DPLP_DeleteRemotePlayerFromGroup to use
 *						InternalDeletePlayerFromGroup instead of
 *						RemovedPlayerFromGroup (now includes system player)
 *						(Bug #8586)
 *	5/21/97		myronth	Fixed the player name for players joining a session
 *						(#8798), Changed to new DPMSG_CHAT format (#8642)
 *	5/22/97		myronth	Fixed flag propagation in DPLP_CreateGroup (#8813)
 *	5/23/97		myronth	Send messages locally for CreateGroup and
 *						CreateGroupInGroup (#8870)
 *	6/3/97		myronth	Added support for player flags in AddPlayerToGroup
 *						(#9091) and added PRV_RemoveSubgroupsAndPlayers-
 *						FromGroup function (#9134)
 *	6/5/97		myronth	Fixed AddGroupToGroup & DeleteGroupFromGroup by
 *						adding heirarchy creating & deletion. (#8731)
 *	6/6/97		myronth	Moved code from PRV_DeleteRemoteGroupFromGroup to
 *						PRV_DestroyGroupAndParents in group.c, Changed all
 *						DistributeGroupMessage calls to go to all players
 *	6/16/97		myronth	Fixed call to InternalAddGroupToGroup (#9745) and
 *						fixed Delete messages for shortcuts on DestroyGroup
 *						(#9739)
 *	6/20/97		myronth	Changed AddGroupToGroup to check if a group exists
 *						and not send a duplicate message (#10139)
 *	6/24/97		myronth	Changed AddPlayerToGroup to check if a player exists
 *						and not send a duplicate message (#10287)
 *	7/30/97		myronth	Added support for standard lobby messaging
 *	8/11/97		myronth	Added guidInstance handling in standard lobby requests
 *	8/19/97		myronth	Removed bogus assert
 *	9/29/97		myronth	Ignore SetPlayerName/Data msgs for local players (#12554)
 *	10/3/97		myronth	Fixed player & group data for remote players/groups (#10961)
 *	10/7/97		myronth	Fixed LP version checking for player & group data (regresssion)
 *	10/8/97		myronth	Rolled back fix for #10961 (group & player data)
 *	10/23/97	myronth	Added hidden group support (#12688), fixed crashing
 *						bug on DeletePlayerFromGroup (#12885)
 *	10/29/97	myronth	Added support for group owners, including DPLP_SetGroupOwner
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/6/97		myronth	Made SendChatMessage handle a dwFromID of
 *						DPID_SERVERPLAYER (#12843)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	 2/13/98	aarono	changed InternalDeletePlayer, added flag.
 *   8/30/00    aarono  B#43812 improper construction of DATA CHANGED.
 *                         in SendDataChangedLocally.
 ***************************************************************************/
#include "dplobpr.h"


//--------------------------------------------------------------------------
//
//	Functions
//
//--------------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "PRV_SendBuildParentalHeirarchyMessage"
void PRV_SendBuildParentalHeirarchyMessage(LPDPLOBBYI_DPLOBJECT this,
				DWORD dwGroupID, DWORD dwParentID)
{
	SPDATA_BUILDPARENTALHEIRARCHY	bph;
	HRESULT							hr;


	DPF(7, "Entering PRV_SendBuildParentalHeirarchyMessage");
	DPF(9, "Parameters: 0x%08x, %lu, %lu", this, dwGroupID, dwParentID);

	// Setup the SPDATA structure
	memset(&bph, 0, sizeof(SPDATA_BUILDPARENTALHEIRARCHY));
	bph.dwSize = sizeof(SPDATA_BUILDPARENTALHEIRARCHY);
	bph.lpISP = PRV_GetDPLobbySPInterface(this);
	bph.dwGroupID = dwGroupID;
	bph.dwMessage = DPSYS_ADDGROUPTOGROUP;
	bph.dwParentID = dwParentID;

	// Call the BuildParentalHeirarchy method in the SP
	if(CALLBACK_EXISTS(BuildParentalHeirarchy))
	{
		// Drop the lock so the lobby provider's receive thread can get back
		// in with other messages if they show up in the queue before our
		// CreatePlayer response (which always happens)
		LEAVE_DPLOBBY();
	    hr = CALL_LP(this, BuildParentalHeirarchy, &bph);
		ENTER_DPLOBBY();
	}
	else 
	{
		// BuildParentalHeirarchy is required
		DPF_ERR("The Lobby Provider callback for BuildParentalHeirarchy doesn't exist -- it's required");
		ASSERT(FALSE);
	}

} // PRV_SendBuildParentalHeirarchyMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddGroupToGroup"
HRESULT DPLAPI DPLP_AddGroupToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEGROUPTOGROUP lpd)
{
	SPDATA_CREATEREMOTEGROUPINGROUP		cgig;
	SPDATA_DESTROYREMOTEGROUP			dg;
	SPDATA_CREATEREMOTEGROUP			cg;
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpAnchor = NULL;
	LPDPLAYI_SUBGROUP		lpSubgroup = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;


	DPF(7, "Entering DPLP_AddGroupToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEGROUPTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwAnchorID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddGroupToGroup message for unknown anchor group, dwGroupID = %lu, discarding message", lpd->dwAnchorID);
		return DPERR_INVALIDGROUP;
	}

	// Now see if the group is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		// See if the group is a root group (remember hidden groups won't
		// get pushed down to us).  If it is, then just create it.
		if(!(lpd->dwParentID))
		{
			// Setup the SPDATA struct for CreateRemoteGroup
			memset(&cg, 0, sizeof(SPDATA_CREATEREMOTEGROUP));
			cg.dwSize = sizeof(SPDATA_CREATEREMOTEGROUP);
			cg.dwGroupID = lpd->dwGroupID;
			cg.lpName = lpd->lpName;
			cg.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cg.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cg.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroup((LPDPLOBBYSP)this->lpInterfaces, &cg);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote parent group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
		else
		{
			// See if it's parent shows up in the map table, if it doesn't,
			// we need to send a message to the server to tell it to build
			// the entire tree for us
			if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
			{
				DPF(8, "Sending message to server to build parental heirarchy, ignoring AddGroupToGroup message");
				PRV_SendBuildParentalHeirarchyMessage(this, lpd->dwGroupID,
						lpd->dwAnchorID);
				LEAVE_DPLOBBY();
				return DPERR_INVALIDGROUP;
			}

			// Setup the SPDATA struct for CreateRemoteGroupInGroup
			memset(&cgig, 0, sizeof(SPDATA_CREATEREMOTEGROUPINGROUP));
			cgig.dwSize = sizeof(SPDATA_CREATEREMOTEGROUPINGROUP);
			cgig.dwParentID = lpd->dwParentID;
			cgig.dwGroupID = lpd->dwGroupID;
			cgig.lpName = lpd->lpName;
			cgig.dwFlags = lpd->dwGroupFlags;

			if(this->dwLPVersion > DPLSP_DX5VERSION)
				cgig.dwGroupOwnerID = lpd->dwGroupOwnerID;
			else
				cgig.dwGroupOwnerID = DPID_SERVERPLAYER;

			// Call our internal remote create
			hr = DPLP_CreateGroupInGroup((LPDPLOBBYSP)this->lpInterfaces, &cgig);
			if(FAILED(hr))
			{
				LEAVE_DPLOBBY();
				DPF_ERRVAL("Failed creating remote group in group, hr = 0x%08x", hr);
				return hr;
			}

			bCreated = TRUE;
		}
	}

	// Take the dplay lock
	ENTER_DPLAY();

	// Make sure the group isn't already in the parent group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpAnchor = GroupFromID(this->lpDPlayObject, lpd->dwAnchorID);
	if(!lpAnchor)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}
	
	lpSubgroup = lpAnchor->pSubgroups;
    while(lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(2,"Group already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDGROUPTOGROUP;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay's AGtoG function
	hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwAnchorID, lpd->dwGroupID, DPGROUP_SHORTCUT, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Setup the SPDATA struct for DestroyRemoteGroup
			memset(&dg, 0, sizeof(SPDATA_DESTROYREMOTEGROUP));
			dg.dwSize = sizeof(SPDATA_DESTROYREMOTEGROUP);
			dg.dwGroupID = lpd->dwGroupID;

			// Call our internal remote create
			hr = DPLP_DestroyGroup((LPDPLOBBYSP)this->lpInterfaces, &dg);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed destroying remote group, hr = 0x%08x", hr);
				goto ERROR_DPLP_ADDGROUPTOGROUP;
			}
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote group to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}


	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDGROUPTOGROUP;
	}

	// Now build the system message (at least the parts we need)
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDSHORTCUTTOGROUP);
	msg.dwPlayerID = lpd->dwGroupID;
	msg.dwGroupID = lpd->dwAnchorID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddGroupToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}


ERROR_DPLP_ADDGROUPTOGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddGroupToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_AddPlayerToGroup"
HRESULT DPLAPI DPLP_AddPlayerToGroup(LPDPLOBBYSP lpILP,
				LPSPDATA_ADDREMOTEPLAYERTOGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidPlayer;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUPNODE		lpGroupnode = NULL;
	MSG_PLAYERMGMTMESSAGE	msg, cpmsg;
	BOOL					bCreated = FALSE;
	DWORD					dwPlayerFlags = 0;


	DPF(7, "Entering DPLP_AddPlayerToGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_ADDREMOTEPLAYERTOGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		LEAVE_DPLOBBY();
		DPF(8, "Recieved AddPlayerToGroup message for unknown group, dwGroupID = %lu, discarding message", lpd->dwGroupID);
		return DPERR_INVALIDGROUP;
	}

	// Fix up the player flags
	if(lpd->dwPlayerFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;
	if(lpd->dwPlayerFlags & DPPLAYER_SERVERPLAYER)
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;

	// Take the dplay lock
	ENTER_DPLAY();

	// Now see if the player is in our map table.  If it is, we
	// probably want to update the name.  If it's not, we need to
	// add them to the nametable and the map table
	if(!IsLobbyIDInMapTable(this, lpd->dwPlayerID))
	{
		// It doesn't show up in our map table, so create a new
		// nametable entry for them and put them in our map table.
		hr = PRV_CreateAndMapNewPlayer(this, &dpidPlayer, lpd->lpName,
				NULL, NULL, 0, dwPlayerFlags,
				lpd->dwPlayerID, FALSE);
		if(FAILED(hr))
		{
			DPF(8, "Unable to add player to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_ADDPLAYER;
		}

		bCreated = TRUE;
	}

	// Make sure the player isn't already in the group.  If it is,
	// we just want to return DP_OK and exit so that we don't send any
	// duplicate messages.
	lpGroup = GroupFromID(this->lpDPlayObject, lpd->dwGroupID);
	if(!lpGroup)
	{
		DPF_ERR("Unable to find group in nametable");
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpPlayer = PlayerFromID(this->lpDPlayObject, lpd->dwPlayerID);
	if(!lpPlayer)
	{
		DPF_ERR("Unable to find player in nametable");
		hr = DPERR_INVALIDPLAYER;
		goto ERROR_DPLP_ADDPLAYER;
	}
	
	lpGroupnode = lpGroup->pGroupnodes;
    while(lpGroupnode) 
    {
        if(lpGroupnode->pPlayer == lpPlayer) 
        {
			DPF(2, "Player already in group!");
			hr = DP_OK;
			goto ERROR_DPLP_ADDPLAYER;
        }

		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }

	// So now we should have a valid group and valid player in both
	// the map table and the nametable, so call dplay with the add message
	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->lpDPlayObject->pInterfaces,
				lpd->dwGroupID, lpd->dwPlayerID, FALSE);
	if(FAILED(hr))
	{
		// If we created the player and mapped it, then destroy the
		// player and unmap it.
		if(bCreated)
		{
			// Remove the player from the nametable
			InternalDestroyPlayer(this->lpDPlayObject, lpPlayer, FALSE, FALSE);
		}

		// If we failed, don't send the system message
		DPF_ERRVAL("Failed adding remote player to group from the lobby, hr = 0x%08x", hr);
		goto ERROR_DPLP_ADDPLAYER;
	}

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_ADDPLAYER;
	}

	// If we created this player, we need to send a CreatePlayer message ahead
	// of the AddPlayerToGroup message
	if(bCreated)
	{
		// Now build the system message (at least the parts we need)
		memset(&cpmsg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
		SET_MESSAGE_HDR(&cpmsg);
		SET_MESSAGE_COMMAND(&cpmsg, DPSP_MSG_CREATEPLAYER);
		cpmsg.dwPlayerID = lpd->dwPlayerID;

		// Call dplay's DistributeGroupMessage function to put the message
		// in the queues of all the appropriate players
		hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
				(LPBYTE)&cpmsg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
		if(FAILED(hr))
		{
			DPF(8, "Failed adding CreatePlayer message to player's receive queue from lobby, hr = 0x%08x", hr);
		}
	}

	// Now build the system message for AddPlayerToGroup
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_ADDPLAYERTOGROUP);
	msg.dwPlayerID = lpd->dwPlayerID;
	msg.dwGroupID = lpd->dwGroupID;

	// Call dplay's DistributeGroupMessage function to put the message
	// in the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo,
			(LPBYTE)&msg, sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding AddPlayerToGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

	// We need to see if this player is the group owner.  If it is,
	// we need to send a SetGroupOwner message as well.
	if(lpd->dwPlayerID == lpGroup->dwOwnerID)
	{
		// Now send the message
		PRV_SendGroupOwnerMessageLocally(this, lpd->dwGroupID,
				lpd->dwPlayerID, 0);
	}

ERROR_DPLP_ADDPLAYER:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_AddPlayerToGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroup"
HRESULT DPLAPI DPLP_CreateGroup(LPDPLOBBYSP lpILP,
						LPSPDATA_CREATEREMOTEGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	MSG_PLAYERMGMTMESSAGE	msg;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLOBBY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Fix the flags from external to internal
	if(lpd->dwFlags & DPGROUP_STAGINGAREA)
		dwInternalFlags = DPLAYI_GROUP_STAGINGAREA;
	if(lpd->dwFlags & DPGROUP_HIDDEN)
		dwInternalFlags |= DPLAYI_GROUP_HIDDEN;

	// Take the lock
	ENTER_DPLAY();

	// First see if the group is in our map table.  If it is,
	// we just want to return.  If it's not, we want to add
	// them and send the appropriate message
	if(IsLobbyIDInMapTable(this, lpd->dwGroupID))
	{
		DPF(2, "Received a CreateGroup message for a group we already know about");
		hr = DP_OK;
		goto ERROR_DPLP_CREATEGROUP;
	}
	else
	{
		// Make the owner default to the server player if we have a problem
		dwOwnerID = DPID_SERVERPLAYER;

		// If we are talking to at least a DX6 lobby provider, we should
		// be able to use the GroupOwnerID element
		if(this->dwLPVersion > DPLSP_DX5VERSION)
			dwOwnerID = lpd->dwGroupOwnerID;
		
		// Create a new entry in the nametable and map the ID's
		hr = PRV_CreateAndMapNewGroup(this, &dpidGroup, lpd->lpName,
				lpd->lpData, lpd->dwDataSize, dwInternalFlags,
				lpd->dwGroupID, 0, dwOwnerID);
		if(FAILED(hr))
		{
			// If we fail, we don't want to send the system message
			DPF_ERRVAL("Unable to add group to nametable or map table, hr = 0x%08x", hr);
			goto ERROR_DPLP_CREATEGROUP;
		}
	}

	// Now build the system message (at least the parts we need
	memset(&msg, 0, sizeof(MSG_PLAYERMGMTMESSAGE));
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg, DPSP_MSG_CREATEGROUP);
	msg.dwPlayerID = lpd->dwGroupID;

	// Find dplay's internal group struct for the To group
	lpGroupTo = GroupFromID(this->lpDPlayObject, DPID_ALLPLAYERS);
	if(!lpGroupTo)
	{
		DPF_ERRVAL("Unable to find group in nametable, hr = 0x%08x", hr);
		hr = DPERR_INVALIDGROUP;
		goto ERROR_DPLP_CREATEGROUP;
	}

	// Call dplay's DistributeGroupMessage function to put the message in
	// the queues of all the appropriate players
	hr = DistributeGroupMessage(this->lpDPlayObject, lpGroupTo, (LPBYTE)&msg,
			sizeof(MSG_PLAYERMGMTMESSAGE), FALSE, 0);
	if(FAILED(hr))
	{
		DPF(8, "Failed adding CreateGroup message to player's receive queue from lobby, hr = 0x%08x", hr);
	}

ERROR_DPLP_CREATEGROUP:

	// Drop the lock
	LEAVE_LOBBY_ALL();
	return hr;

} // DPLP_CreateGroup



#undef DPF_MODNAME
#define DPF_MODNAME "DPLP_CreateGroupInGroup"
HRESULT DPLAPI DPLP_CreateGroupInGroup(LPDPLOBBYSP lpILP,
					LPSPDATA_CREATEREMOTEGROUPINGROUP lpd)
{
	LPDPLOBBYI_DPLOBJECT	this;
	HRESULT					hr = DP_OK;
	DPID					dpidGroup;
	LPDPLAYI_PLAYER			lpPlayer = NULL;
	LPDPLAYI_GROUP			lpGroup = NULL;
	LPDPLAYI_GROUP			lpGroupTo = NULL;
	MSG_PLAYERMGMTMESSAGE	msg;
	BOOL					bCreated = FALSE;
	DWORD					dwInternalFlags = 0;
	DWORD					dwOwnerID;


	DPF(7, "Entering DPLP_CreateGroupInGroup");
	DPF(9, "Parameters: 0x%08x, 0x%08x", lpILP, lpd);

	ENTER_DPLOBBY();

	//	Make sure the LP doesn't throw us a curve
    TRY
    {
		this = DPLOBJECT_FROM_INTERFACE(lpILP);
        if( !VALID_DPLOBBY_PTR( this ) )
        {
			LEAVE_DPLOBBY();
			DPF_ERR("Lobby Provider passed invalid DPLobby object!");
            return DPERR_INVALIDOBJECT;
        }

		// Validate the struct pointer
		if(!lpd)
		{
			LEAVE_DPLOBBY();
			DPF_ERR("SPDATA_CREATEREMOTEGROUPINGROUP structure pointer cannot be NULL");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLOBBY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First see if the group is in our map table.  If it's not,
	// we should just ignore this message because it's for a
	// group we are not currently in.
	if(!IsLobbyIDInMapTable(this, lpd->dwParentID))
	{
		LEAVE_DPLOBBY();
		DPF_ERRVAL("Recieved CreateGroupInGroup message for unknown parent group, dwGroupID = %lu, discard