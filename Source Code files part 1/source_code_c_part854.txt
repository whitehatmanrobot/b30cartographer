n)))
        {
            TCHAR sz[100];
            LoadString(HINST_THISDLL, IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical, fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = fVertical ? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen, fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwState = 0;

            TBBUTTON tbb;
            if (-1 != ToolBar_GetButton(_pmtbItem->_hwndMB, _iIndex, &tbb))
            {
                dwState = tbb.fsState; // ToolBar_GetState returns -1 for some menus, need to use ToolBar_GetButton
            }

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            
            DWORD dwAccState;            
            if (dwState & TBSTATE_ENABLED)
            {
                dwAccState = STATE_SYSTEM_FOCUSABLE;
            }
            else
            {
                dwAccState = STATE_SYSTEM_UNAVAILABLE;
            }

            if (dwState & (TBSTATE_PRESSED | TBSTATE_ENABLED))
            {
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;
            }

            if ((-1 != idHotTracked) && (idHotTracked == _iIndex))
            {
                dwAccState |= STATE_SYSTEM_HOTTRACKED;
            }

            if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            {
                dwAccState |= STATE_SYSTEM_HASPOPUP;
            }

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    *pszKeyboardShortcut = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {
            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR szAccel[100] = TEXT("");
                    if (pmtb->_hwndMB)
                    {
                        TCHAR sz[MAX_PATH];
                        int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (S_FALSE == _psma->IsEmpty())
                        {
                            int cch = SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);
                            // cch is strlen of the string, not including terminator
                            if (cch != 0 && cch < ARRAYSIZE(sz))
                            {
                                if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                                {
                                    BOOL fVertical, fOpen;
                                    _psma->GetState(&fVertical, &fOpen);
                                    if (!fVertical)
                                    {
                                        // minus 1 since we'll be adding a char.
                                        LoadString(HINST_THISDLL, IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel) - 1);
                                    }
                                    int cchLen = lstrlen(szAccel);
                                    szAccel[cchLen] = GetAccelerator(sz, TRUE);
                                    szAccel[cchLen + 1] = TEXT('\0');
                                    hr = S_OK;
                                }
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        *pszKeyboardShortcut = SysAllocStringT(szAccel);
                        if (!*pszKeyboardShortcut)
                            hr = E_OUTOFMEMORY;
                    }
                    pmtb->Release();
                }
            }
        }
        break;
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT * pvarFocusChild)
{   
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                if (pmtbTracked->_hwndMB)
                {
                    int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                    hr = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                        iIndex, pvarFocusChild);
                }
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hr;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            LoadString(HINST_THISDLL, IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU) ? IDS_ACC_OPEN: IDS_ACC_EXEC;
                LoadString(HINST_THISDLL, iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hr = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hr = _psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk));
                    if (SUCCEEDED(hr))
                    {
                        IOleWindow* poct;
                        hr = IUnknown_QueryService(punk, SID_SMenuPopup, IID_PPV_ARG(IOleWindow, &poct));
                        if (SUCCEEDED(hr))
                        {
                            HWND hwnd;
                            hr = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hr))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hr = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hr))
                    {
labelGetRect:
                        if (pmtb->_hwndMB)
                        {
                            int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                            if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                                hr = E_INVALIDARG;
                            MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hr))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hr;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hr;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iTBIndex;
    HRESULT hr = S_FALSE;

    TBBUTTONINFO tbInfo;
    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    int iIndex = 0;         // 1 based index
    _GetChildFromVariant(&varStart, NULL, &iIndex);

    BOOL fVertical;
    BOOL fOpen;
    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        // uhhhh what?
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert = {0};
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                ASSERT(VT_BOOL == varVert.vt);
                // Yes. Then punt
                hr = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_DOWN:
        hr = NOERROR;
        while (SUCCEEDED(hr))
        {
            iIndex++;
            VARIANT varTemp;
            hr = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hr))
            {
                CMenuToolbarBase *pmtb;
                hr = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hr))
                {
                    if (pmtb->_hwndMB)
                    {
                        tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                        int idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                        ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hr = S_FALSE;
            break;
        }

        iIndex = 0;
        hr = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hr = S_FALSE;
            break;
        }
        iIndex = -1;
        hr = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            if (pmtb->_hwndMB)
            {
                int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
                if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
                {
                    IMenuPopup* pmp;
                    hr = _psma->GetSubMenu(&varStart, IID_PPV_ARG(IMenuPopup, &pmp));
                    if (SUCCEEDED(hr))
                    {
                        IAccessible* pacc;
                        hr = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc));
                        if (SUCCEEDED(hr))
                        {
                            hr = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                            pacc->Release();
                        }
                        pmp->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }

            return hr;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert = {0};
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                ASSERT(VT_BOOL == varVert.vt);
                // Yes. Then punt
                hr = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hr = NOERROR;
        while (SUCCEEDED(hr))
        {
            iIndex--;
            VARIANT varTemp;
            hr = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hr))
            {
                CMenuToolbarBase *pmtb;
                hr = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hr))
                {
                    if (iTBIndex == 0)    
                    {   
                        hr = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_PPV_ARG(IUnknown, &punk))))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_PPV_ARG(IOleCommandTarget, &poct))))
                            {
                                VARIANT varVert = {0};

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    ASSERT(VT_BOOL == varVert.vt);

                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_PPV_ARG(IAccessible, &pacc))))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hr = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClear(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    if (pmtb->_hwndMB)
                    {
                        int idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                        ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) && S_FALSE != hr)
        hr = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hr;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        if (SUCCEEDED(pacc->InitAcc()))
        {
            hr = pacc->QueryInterface(IID_PPV_ARG(IDispatch, ppdisp));
        }
        pacc->Release();
    }
    return hr;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT * rgvar, 
                        unsigned long * pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT ** ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\icotask.cpp ===
#include "shellprv.h"
#include "brutil.h"
#include "icotask.h"

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
static const GUID TASKID_IconExtraction = 
{ 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CIconTask::CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId):
    _pidl(pidl), _pfn(pfn), _pvData(pvData), _uId(uId), CRunnableTask(RTF_DEFAULT)
   
{ 
    
}

CIconTask::~CIconTask()
{
    if (_pidl)
        ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CIconTask::RunInitRT(void)
{
    int iIndex = -1;
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;

    // We need to rebind because shell folders may not be thread safe.
    HRESULT hr = IEBindToParentFolder(_pidl, &psf, &pidlItem);

    if (SUCCEEDED(hr))
    {
        iIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
        psf->Release();
    }

    _pfn(_pvData, _uId, iIndex);
    return S_OK;        // return S_OK even if we don't get an icon.
}


// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98

HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder, 
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, 
                    UINT uId, int* piTempIcon)
{
    if (!pts)
        return E_INVALIDARG;


    HRESULT hr = E_PENDING;
    TCHAR szIconFile[MAX_PATH];


    // The shell has a concept of GIL_ASYNC which means that an extension called with this flag
    // should not really load the target file, it should "Fake" it, returning an icon for the type.
    // Later, on a background thread, we're going to call it again without the GIL_ASYNC, and at
    // that time, it should really extract the icon.

    // This is an optimiation for slow icon extraction, such as network shares

    // NOTE: There is significant overhead to actually loading the shell extension. If you know the
    // type of the item, pass NULL to piTempIcopn


    if (piTempIcon)
    {
        *piTempIcon = -1;

        UINT uFlags;
        IExtractIconA* pixa;
        IExtractIconW* pix;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidl, IID_X_PPV_ARG(IExtractIconW, NULL, &pix))))
        {
            hr = pix->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFile, ARRAYSIZE(szIconFile), piTempIcon, &uFlags);
            pix->Release();
        }
        else if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1,(LPCITEMIDLIST*)&pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pixa))))
        {
            char szIconFileA[MAX_PATH];
            hr = pixa->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFileA, ARRAYSIZE(szIconFileA), piTempIcon, &uFlags);
            SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            pixa->Release();
        }
    }

    if (hr == E_PENDING)
    {
        if (piTempIcon)
            *piTempIcon = Shell_GetCachedImageIndex(szIconFile, *piTempIcon, 0);

        LPITEMIDLIST pidlFull;
        if (psf)
            pidlFull = ILCombine(pidlFolder, pidl);
        else
            pidlFull = (LPITEMIDLIST)pidl;

        hr = E_OUTOFMEMORY;
        CIconTask* pit = new CIconTask(pidlFull, pfn, pvData, uId);
        // Don't ILFree(pidlFull) because CIconTask takes ownership.
        // FEATURE (lamadio) Remove this from the memory list. Ask Saml how to do this
        // for the IMallocSpy stuff.

        if (pit)
        {
            hr = pts->AddTask(SAFECAST(pit, IRunnableTask*), TASKID_IconExtraction, 
                ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);

            pit->Release();
        }
    }
    else
    {
        *piTempIcon = SHMapPIDLToSystemImageListIndex(psf, pidl, NULL);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\isfband.cpp ===
#include "shellprv.h"
#include "common.h"
#include <varutil.h>

#include "bands.h"
#include "isfband.h"
#include "resource.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include "uemapp.h"
#include "mnfolder.h"
#include "legacy.h"
#include "util.h"
#include "strsafe.h"
#include "isfmenu.h"

#define DM_VERBOSE      0       // misc verbose traces
#define DM_PERSIST      0
#define TF_BANDDD   TF_BAND
#define DM_RENAME       0
#define DM_MISC         0       // miscellany

#define SZ_PROPERTIESA     "properties"
#define SZ_PROPERTIES      TEXT(SZ_PROPERTIESA)
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };


#define SUPERCLASS CToolBand

extern UINT g_idFSNotify;

HRESULT CLogoExtractImageTask_Create(CLogoBase *plb,
                                  IExtractImage *pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  IRunnableTask ** ppTask);

class CLogoExtractImageTask : public IRunnableTask
{
    public:
        STDMETHOD (QueryInterface) (REFIID riid, void **ppvObj);
        STDMETHOD_(ULONG, AddRef) ();
        STDMETHOD_(ULONG, Release) ();

        STDMETHOD (Run)(void);
        STDMETHOD (Kill)(BOOL fWait);
        STDMETHOD (Suspend)();
        STDMETHOD (Resume)();
        STDMETHOD_(ULONG, IsRunning)(void);

    protected:

        CLogoExtractImageTask(HRESULT * pHr,
                           CLogoBase *plb,
                           IExtractImage * pImage,
                           LPCWSTR pszCache,
                           DWORD dwItem,
                           int iIcon,
                           DWORD dwFlags);
        ~CLogoExtractImageTask();
        HRESULT InternalResume();

        friend HRESULT CLogoExtractImageTask_Create(CLogoBase* plb,
                                                 IExtractImage *pExtract,
                                                 LPCWSTR pszCache,
                                                 DWORD dwItem,
                                                 int iIcon,
                                                 DWORD dwFlags,
                                                 IRunnableTask ** ppTask);

        LONG            m_cRef;
        LONG            m_lState;
        IExtractImage * m_pExtract;
        IRunnableTask * m_pTask;
        WCHAR           m_szPath[MAX_PATH];
        DWORD           m_dwFlags;
        DWORD           m_dwItem;
        CLogoBase*      m_plb;
        HBITMAP         m_hBmp;
        int             m_iIcon;
};
//=================================================================
// Implementation of CISFBand
//=================================================================


CISFBand::CISFBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
    _eUemLog = UEMIND_NIL;
    _dwPriv = -1;

    _fHasOrder = TRUE;  // ISFBand always has an order...
    _fAllowDropdown = BOOLIFY(SHRegGetBoolUSValue(SZ_REGKEY_ADVFOLDER, TEXT("CascadeFolderBands"),
                    FALSE,
                    FALSE)); 

    // Should we enable logging of arbirary events?
//    _pguidUEMGroup = &UEMIID_SHELL;
    ASSERT(_pguidUEMGroup == NULL);


    // Assert that this class is ZERO INITed.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
}


CISFBand::~CISFBand()
{
    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
}

// aggregation checking is handled in class factory

HRESULT CISFBand_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;
    CISFBand *pObj = new CISFBand();
    if (pObj) 
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hr;
}


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

HRESULT CISFBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CISFBand, IShellFolderBand),
        QITABENT(CISFBand, IFolderBandPriv),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr))
        hr = CToolBand::QueryInterface(riid, ppvObj);

    if (FAILED(hr))
        hr = CSFToolbar::QueryInterface(riid, ppvObj);


    if (S_OK != hr)
    {
        // HACKHACK: this is yucko!
        if (IsEqualIID(riid, CLSID_ISFBand))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_ISFBand"));
            return S_OK;
        }
    }

    return hr;
}

//***   ILIsParentCSIDL -- like ILIsParent, but accepts a CSIDL_* for pidl1
// NOTES
//  TODO move to shlwapi (if/when idlist.c moves there)?
STDAPI_(BOOL) ILIsParentCSIDL(int csidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidlSpec;
    BOOL fRet = FALSE;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl1, &pidlSpec)))
    {
        fRet = ILIsParent(pidlSpec, pidl2, fImmediate);
        ILFree(pidlSpec);
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: IShellFolderBand::InitializeSFB

         - supply IShellFolder with no PIDL if you want to view some
           ISF (either already instantiated from the filesystem or
           some non-filesystem ISF) that you do NOT want to receive
           notifies from (either from SHChangeNotify nor from
           IShellChangeNotify)

         - supply a PIDL with no IShellFolder for a full-blown band
           looking at a shell namespace (rooted on desktop) item.

*/
HRESULT CISFBand::InitializeSFB(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    // Did they try to add the Recycle Bin? If so we need to reject it
    // for consistance reasons.  We also reject the Temp. Internet Files
    // for security reasons.
    if (pidl && (ILIsParentCSIDL(CSIDL_BITBUCKET, pidl, FALSE) ||
                ILIsParentCSIDL(CSIDL_INTERNET_CACHE, pidl, FALSE)))
    {
        // this will eventually show up as IDS_CANTISFBAND
        TraceMsg(DM_TRACE, "cib.isfb: recycle => E_INVALIDARG");
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
        hr = CSFToolbar::SetShellFolder(psf, pidl);
    if (SUCCEEDED(hr))
        hr = _AfterLoad();

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::SetBandInfoSFB

*/
HRESULT CISFBand::SetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if ((pbi->dwMask & ISFB_MASK_INVALID) ||
        (pbi->dwMask & ISFB_MASK_VIEWMODE) && (pbi->wViewMode & ~3))
        return E_INVALIDARG;

    // We don't handle ISFB_MASK_SHELLFOLDER and ISFB_MASK_IDLIST
    // in Set because there's a lot of work to resync pidl, psf, and
    // notifcations in the toolbar.  If somebody wants to do it,
    // more power to ya.  :)
    if (pbi->dwMask & (ISFB_MASK_SHELLFOLDER | ISFB_MASK_IDLIST))
        return E_INVALIDARG;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        if (pbi->dwStateMask & ISFB_STATE_DEBOSSED)
            _fDebossed = BOOLIFY(pbi->dwState & ISFB_STATE_DEBOSSED);
        if (pbi->dwStateMask & ISFB_STATE_ALLOWRENAME)
            _fAllowRename = BOOLIFY(pbi->dwState & ISFB_STATE_ALLOWRENAME);
        if (pbi->dwStateMask & ISFB_STATE_NOSHOWTEXT)
            _fNoShowText = BOOLIFY(pbi->dwState & ISFB_STATE_NOSHOWTEXT);
        if (pbi->dwStateMask & ISFB_STATE_CHANNELBAR)
            _fChannels = BOOLIFY(pbi->dwState & ISFB_STATE_CHANNELBAR);
        /* ISFB_STATE_NOTITLE: removed 970619, use cbs::SetBandState */
        if (pbi->dwStateMask & ISFB_STATE_QLINKSMODE)
            _fLinksMode = BOOLIFY(pbi->dwState & ISFB_STATE_QLINKSMODE);
        if (pbi->dwStateMask & ISFB_STATE_FULLOPEN)
            _fFullOpen = BOOLIFY(pbi->dwState & ISFB_STATE_FULLOPEN);
        if (pbi->dwStateMask & ISFB_STATE_NONAMESORT)
            _fNoNameSort = BOOLIFY(pbi->dwState & ISFB_STATE_NONAMESORT);
        if (pbi->dwStateMask & ISFB_STATE_BTNMINSIZE)
            _fBtnMinSize = BOOLIFY(pbi->dwState & ISFB_STATE_BTNMINSIZE);
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        _crBkgnd = pbi->crBkgnd;
        _fHaveBkColor = TRUE;
        if (EVAL(_hwndTB))
            SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_CUSTOMERASE, TBSTYLE_CUSTOMERASE);

        ASSERT(_hwnd);

        if (_hwndPager)
        {
            TraceMsg(TF_BAND, "cib.sbisfb: Pager_SetBkColor(_hwnd=%x crBkgnd=%x)", _hwnd, _crBkgnd);
            Pager_SetBkColor(_hwnd, _crBkgnd);
        }
    }

    // We don't support changing these once TB is created, So?
    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        _crBtnLt = pbi->crBtnLt;
        _crBtnDk = pbi->crBtnDk;
        _fHaveColors = TRUE;
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        _uIconSize = (pbi->wViewMode & 3); // stored in a 2-bit field currently...

        // only force no recalc if one of the recalcable fields was set
        _fNoRecalcDefaults = TRUE;
    }


    // If the bandsite queried us before, let it know the info may have changed
    if (_fInitialized)
        _BandInfoChanged();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::GetBandInfoSFB

*/
HRESULT CISFBand::GetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        pbi->dwState = 0;
        pbi->dwStateMask = ISFB_STATE_ALL;

        if (_fDebossed)
            pbi->dwState |= ISFB_STATE_DEBOSSED;
        if (_fAllowRename)
            pbi->dwState |= ISFB_STATE_ALLOWRENAME;
        if (_fNoShowText)
            pbi->dwState |= ISFB_STATE_NOSHOWTEXT;
        if (_fLinksMode)
            pbi->dwState |= ISFB_STATE_QLINKSMODE;
        if (_fFullOpen)
            pbi->dwState |= ISFB_STATE_FULLOPEN;
        if (_fNoNameSort)
            pbi->dwState |= ISFB_STATE_NONAMESORT;
        if (_fBtnMinSize)
            pbi->dwState |= ISFB_STATE_BTNMINSIZE;
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        pbi->crBkgnd = (_fHaveBkColor) ? _crBkgnd : CLR_DEFAULT;
    }

    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        if (_fHaveColors)
        {
            pbi->crBtnLt = _crBtnLt;
            pbi->crBtnDk = _crBtnDk;
        }
        else
        {
            pbi->crBtnLt = CLR_DEFAULT;
            pbi->crBtnDk = CLR_DEFAULT;
        }
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        pbi->wViewMode = _uIconSize;
    }

    if (pbi->dwMask & ISFB_MASK_SHELLFOLDER)
    {
        pbi->psf = _psf;
        if (pbi->psf)
            pbi->psf->AddRef();
    }

    if (pbi->dwMask & ISFB_MASK_IDLIST)
    {
        if (_pidl)
            pbi->pidl = ILClone(_pidl);
        else
            pbi->pidl = NULL;
    }
    return S_OK;
}

// *** IInputObject methods ***
HRESULT CISFBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

void CISFBand::_SetCacheMenuPopup(IMenuPopup* pmp)
{
    if (!SHIsSameObject(pmp, _pmpCache))
    {
        _ReleaseMenuPopup(&_pmpCache);
        _pmpCache = pmp;
        if (_pmpCache)
            _pmpCache->AddRef();
    }
}


void CISFBand::_ReleaseMenuPopup(IMenuPopup** ppmp)
{
    IUnknown_SetSite(*ppmp, NULL);
    ATOMICRELEASE(*ppmp);
}

/*----------------------------------------------------------
Purpose: Releases the held menu popup.

*/
void CISFBand::_ReleaseMenu()
{
    if (!SHIsSameObject(_pmp, _pmpCache))
    {
        TraceMsg(TF_MENUBAND, "Releasing pmp %#lx", _pmp);
        _ReleaseMenuPopup(&_pmp);
    } else
        ATOMICRELEASE(_pmp);
}

//***
// ENTRY/EXIT
//  S_OK        desktop browser
//  S_FALSE     other browser (explorer, OC, etc.)
//  E_xxx       not a browser at all (e.g. band asking tray)
HRESULT MBIsDesktopBrowser(IUnknown *punkSite)
{
    HRESULT hr;
    IServiceProvider *psp;
    IUnknown *punk;

    hr = E_FAIL;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &psp))))
    {
        hr = S_FALSE;
        if (SUCCEEDED(psp->QueryInterface(SID_SShellDesktop, (void**)&punk)))
        {
            hr = S_OK;
            punk->Release();
        }
        psp->Release();
    }

    TraceMsg(DM_VERBOSE, "idb: ret hrDesk=%x (0=dt 1=sh e=!brow)", hr);
    return hr;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::SetSite method.

*/
HRESULT CISFBand::SetSite(IUnknown* punkSite)
{
    _ReleaseMenu();

    SUPERCLASS::SetSite(punkSite);

    if (_punkSite)
    {
        if (!_hwndTB)
            _CreateToolbar(_hwndParent);

        IUnknown_SetOwner(_psf, SAFECAST(this, IDeskBand*));

        _Initialize();
    }
    else
        IUnknown_SetOwner(_psf, NULL);


    // First destroy the band proxy

    // Call SetSite(NULL) only if you own
    // if not, it's the parent from whom you got it via QS who will call SetSite(NULL)

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
    _fCreatedBandProxy = FALSE;
    // Need a bandproxy
    QueryService_SID_IBandProxy(punkSite, IID_IBandProxy, &_pbp, NULL);
    if (!_pbp)
    {
        // We need to create it ourselves since our parent couldn't help
        ASSERT(FALSE == _fCreatedBandProxy);
        HRESULT hr = CreateIBandProxyAndSetSite(punkSite, IID_IBandProxy, &_pbp, NULL);
        if (_pbp)
        {
            ASSERT(S_OK == hr);
            _fCreatedBandProxy = TRUE;
        }
    }

    return S_OK;
}

void CISFBand::_Initialize()
{
    _fDesktop = (MBIsDesktopBrowser(_punkSite) == S_OK);

    return;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
HRESULT CISFBand::CloseDW(DWORD dw)
{
    _fClosing = TRUE;

    // close down the task scheduler ...
    if (_pTaskScheduler)
        ATOMICRELEASE(_pTaskScheduler);

    _UnregisterToolbar();
    EmptyToolbar();

    IUnknown_SetOwner(_psf, NULL);
    _SetCacheMenuPopup(NULL);

    // should get freed in EmptyToolbar();
    ASSERT(!_hdpa);

    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

*/
HRESULT CISFBand::ShowDW(BOOL fShow)
{
    HRESULT hr = S_OK;

    SUPERCLASS::ShowDW(fShow);

    if (fShow)
    {
        _fShow = TRUE;

        if (_fDirty)
        {
            _FillToolbar();
        }

        if (!_fDelayInit)
        {
            _RegisterToolbar();
        }
    }
    else
    {
        _fShow = FALSE;
    }

    return hr;
}

void CISFBand::_StopDelayPainting()
{
    if (_fDelayPainting)
    {
        _fDelayPainting = FALSE;
        // May be called by background thread
        // Use PostMessage instead of SendMessage to avoid deadlock
        PostMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);
        if (_hwndPager)
            PostMessage(_hwnd, PGM_RECALCSIZE, 0L, 0L);
    }
}

HWND CISFBand::_CreatePager(HWND hwndParent)
{
    // don't create a pager for isfbands
    return hwndParent;
}

HRESULT CISFBand::_CreateToolbar(HWND hwndParent)
{
    if (_fHaveBkColor)
        _dwStyle |= TBSTYLE_CUSTOMERASE;
    
    HRESULT hr = CSFToolbar::_CreateToolbar(hwndParent);

    if (SUCCEEDED(hr))
    {
        ASSERT(_hwndTB);

        if (_fHaveBkColor)
            ToolBar_SetInsertMarkColor(_hwndTB, GetSysColor(COLOR_BTNFACE));

        SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        if (_fChannels)
        {
            SHSetWindowBits(_hwndTB, GWL_EXSTYLE, dwExStyleRTLMirrorWnd, 0);        
        }    

        _hwnd = _hwndPager ? _hwndPager : _hwndTB;

        if (_fHaveColors)
        {
            COLORSCHEME cs;

            cs.dwSize = sizeof(cs);
            cs.clrBtnHighlight  = _crBtnLt;
            cs.clrBtnShadow     = _crBtnDk;
            SendMessage(_hwndTB, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);
        }
    }
    return hr;
}

int CISFBand::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;
    if (_uIconSize == ISFBVIEWMODE_LOGOS)
    {
        IRunnableTask *pTask = NULL;
        DWORD dwPriority = 0;
        // fetch the logo instead...
        ASSERT(!_fDelayPainting);
       // Warning - cannot hold ptask in a member variable - it will be a circular reference
        iBitmap = GetLogoIndex(iCommandID, pibdata->GetPidl(), &pTask, &dwPriority, NULL);
        if (pTask)
        {
            AddTaskToQueue(pTask, dwPriority, (DWORD)iCommandID);
            ATOMICRELEASE(pTask);
        }
    }
    else
        iBitmap = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);

    return iBitmap;
}

void CISFBand::_SetDirty(BOOL fDirty)
{
    CSFToolbar::_SetDirty(fDirty);

    if (fDirty)
        IUnknown_Exec(_punkSite, &CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
}

BOOL CISFBand::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);

    _uIconSize = uIconSize;
    HIMAGELIST himl = NULL;

    if (uIconSize == ISFBVIEWMODE_LOGOS)
    {
        if (SUCCEEDED(InitLogoView()))
        {
            himl = GetLogoHIML();
        }
        if (himl)
        {
            SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

            _UpdateButtons();
        }
    }

    if (!himl)
        fChanged |= CSFToolbar::_UpdateIconSize(uIconSize,fUpdateButtons);
    return fChanged;
}

void CISFBand::_UpdateVerticalMode(BOOL fVertical)
{
    _fVertical = (fVertical != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateVerticalMode going %hs", _fVertical ? "VERTICAL" : "HORIZONTAL");

    ASSERT(_hwnd);

    if (_hwndPager)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, PGS_HORZ|PGS_VERT,
            _fVertical ? PGS_VERT : PGS_HORZ);
    }

    if (_hwndTB)
    {
        SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_WRAPABLE | CCS_VERT,
            TBSTYLE_WRAPABLE | (_fVertical ? CCS_VERT : 0));
    }
}

HRESULT IUnknown_QueryBand(IUnknown *punk, DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hr;
    IBandSite *pbs;

    hr = punk->QueryInterface(IID_PPV_ARG(IBandSite, &pbs));
    if (SUCCEEDED(hr))
    {
        hr = pbs->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
        pbs->Release();
    }
    return hr;
}

#define CISFBAND_GETBUTTONSIZE()  (_hwndTB ?  (LONG)SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L) : MAKELONG(16, 16))

// _GetIdealSize
// calculates ideal height and width for band and passes back in
// psize, if psize isn't NULL; return value is band's 'ideal length'
// (ideal height if vertical, else ideal width)
int CISFBand::_GetIdealSize(PSIZE psize)
{
    SIZE size;
    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();
    RECT rc = {0};
    if (psize)
    {
        rc.right = psize->cx;
        rc.bottom = psize->cy;
    }
    else if (_hwndTB)
    {
        GetClientRect(_hwndTB, &rc);
    }

    if (_fVertical)
    {
        // set width to be max of toolbar width and toolbar button width
        size.cx = max(RECTWIDTH(rc), LOWORD(lButtonSize));
        // have toolbar calculate height given that width
        SendMessage(_hwndTB, TB_GETIDEALSIZE, TRUE, (LPARAM)&size);
    }
    else
    {
        // set height to be max of toolbar width and toolbar button width
        size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));
        // have toolbar calculate width given that height
        SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
    }

    if (psize)
    {
        *psize = size;
    }

    return _fVertical ? size.cy : size.cx;
}

/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/

HRESULT CISFBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                              DESKBANDINFO* pdbi)
{
    HRESULT hr = S_OK;
    WCHAR szQLPath[MAX_PATH] = L"";

    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szQLPath)))
    {
        WCHAR szSubDir[MAX_PATH];
        LoadString(g_hinst, IDS_QLAUNCHAPPDATAPATH, szSubDir, ARRAYSIZE(szSubDir));
        PathCombine(szQLPath, szQLPath, szSubDir);
    }


    _dwBandID = dwBandID;
    // We don't know the default icon size until GetBandInfo is called.
    // After we set the default, we pay attention to the context menu.
    if (!_fNoRecalcDefaults)
    {
        _uIconSize = (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL)) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        _fNoRecalcDefaults = TRUE;
    }

    if (!_fInitialized)
    {
        _fInitialized = TRUE;
        _UpdateIconSize(_uIconSize, FALSE);
        _UpdateShowText(_fNoShowText);
    }

    // we treat floating the same as vertical
    _UpdateVerticalMode(fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL));

    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();

    pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT | DBIMF_USECHEVRON;
    if (_fDebossed)
        pdbi->dwModeFlags |= DBIMF_DEBOSSED;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptIntegral.y = (fViewMode & DBIF_VIEWMODE_VERTICAL) ? 1 : HIWORD(lButtonSize);
    pdbi->ptIntegral.x = 1;

    if (!_fFullOpen)
        _iIdealLength = _GetIdealSize((PSIZE)&pdbi->ptActual);

    // CalcMinWidthHeight {
    #define g_cxScrollbar   (GetSystemMetrics(SM_CXVSCROLL) * 3 / 4)
    #define g_cyScrollbar   (GetSystemMetrics(SM_CYVSCROLL) * 3 / 4)
    #define CX_TBBUTTON_MAX (16 + CX_FILENAME_AVG)  // button + name
    #define CY_TBBUTTON_MAX (16)                    // button

    int csBut, csButMin, clBut, clButMin, clScroll;

    // set up short/long aliases
    if (_fVertical)
    {
        csBut = LOWORD(lButtonSize);
        if (_fBtnMinSize)
            csButMin = min(csBut, CX_TBBUTTON_MAX);
        else
            csButMin = 0;   // people like to shrink things way down, so let 'em

        clBut = HIWORD(lButtonSize);
        clButMin = clBut;
        //ASSERT(min(clBut, CY_TBBUTTON_MAX) == clButMin);  // fails!

        clScroll = g_cyScrollbar;
    }
    else
    {
        csBut = HIWORD(lButtonSize);
        csButMin = csBut;
        //ASSERT(min(csBut, CY_TBBUTTON_MAX) == csButMin);  // fails!

        clBut = LOWORD(lButtonSize);
        clButMin = min(clBut, CX_TBBUTTON_MAX);

        clScroll = g_cxScrollbar;

        // nt5:176448: integral for horz
        //pdbi->ptIntegral.y = csBut;   this is the cause for 287082 and 341592
    }

    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = csButMin;

    DWORD dwState = BSSF_NOTITLE;

    BANDINFOSFB bi;
    TCHAR szBandPath[MAX_PATH];
    bi.dwMask = ISFB_MASK_IDLIST;
    GetBandInfoSFB(&bi);
    SHGetPathFromIDList(bi.pidl, szBandPath);
    if ((lstrcmp(szBandPath, szQLPath) == 0) && (!_fIgnoreAddToFront))
    {
        pdbi->dwModeFlags |= DBIMF_ADDTOFRONT;
    }
    ILFree(bi.pidl);

    IUnknown_QueryBand(_punkSite, dwBandID, NULL, &dwState, NULL, 0);
    if (dwState & BSSF_NOTITLE) // _fNoTitle
    {
        int i, cBut, clTmp;

        // cbut=    text    notext
        // horz     1       4
        // vert     1       1
        cBut = 1;
        if (!_fVertical && _fNoShowText)
        {
            // special-case for QLaunch so see several buttons
            cBut = 3;   // for both QLaunch and arbitrary ISF band
        }

        pdbi->ptMinSize.x = cBut * clButMin;

        if (_hwndPager)
        {
            // tack on extra space for pager arrows
            pdbi->ptMinSize.x += 2 * clScroll;
        }

        i = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (i <= cBut)
        {
            clTmp = i * clBut;
            if (clTmp < pdbi->ptMinSize.x)
            {
                // scrollbars take as much space as button would
                // so just do the button
                pdbi->ptMinSize.x = clTmp;
            }
        }
    }
    // }

    hr = _GetTitleW(pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (SUCCEEDED(hr))
    {
        // set window text to give accessibility apps something to read
        SetWindowText(_hwndTB, pdbi->wszTitle);
    }
    else
    {
        // we don't support title
#ifdef DEBUG
        if (pdbi->dwMask & DBIM_TITLE)
            TraceMsg(DM_VERBOSE, "cisfb.gbi: patch ~DBIM_TITLE");
#endif
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    return hr;
}

LRESULT CISFBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres = CDRF_DODEFAULT;

    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if (_hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS)
        {
            ASSERT(pnmcd->hdc);
            _hpalOld = SelectPalette(pnmcd->hdc, _hpalHalftone, TRUE);
            // LINTASSERT(_hpalOld || !_hpalOld);   // 0 semi-ok for SelectPalette
            RealizePalette(pnmcd->hdc);
        }

        // make sure we get the postpaint as well so we can de-select the palette...
        lres = CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_POSTPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if (_hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS)
        {
            ASSERT(pnmcd->hdc);
            (void) SelectPalette(pnmcd->hdc, _hpalOld, TRUE);
            // we don't need a realize here, we can keep the other palette realzied, we
            // re select the old palette above, otherwise we bleed the resource....
            // RealizePalette(pnmcd->hdc);
        }
        break;

    case CDDS_PREERASE:
        if (_fHaveBkColor)
        {
            RECT rcClient;
            GetClientRect(_hwndTB, &rcClient);
            SHFillRectClr(pnmcd->hdc, &rcClient, _crBkgnd);
            lres = CDRF_SKIPDEFAULT;
        }
        break;
    }

    return lres;
}

void CISFBand::_OnDragBegin(int iItem, DWORD dwPreferredEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_MarkButton(_hwndTB, iItem, TRUE);

    if (pidl)
        DragDrop(_hwnd, _psf, pidl, dwPreferredEffect, NULL);

    ToolBar_MarkButton(_hwndTB, iItem, FALSE);
    _iDragSource = -1;
}

LRESULT CISFBand::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;
    LRESULT lres = 0;

    if (_hwndPager && (lpnmhi->dwFlags & HICF_ARROWKEYS))
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;

        int iSelected = lpnmhi->idNew;
        iOldPos = (int)SendMessage(_hwnd, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);

        if (rc.top < iOldPos)
        {
             iNewPos =rc.top;
        }

        GetClientRect(_hwnd, &rcPager);
        heightPager = RECTHEIGHT(rcPager);

        if (rc.top >= iOldPos + heightPager)
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }

        if (iNewPos != iOldPos)
            SendMessage(_hwnd, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }
    else
    {
        lres = CToolbarBand::_OnHotItemChange(pnm);
    }

    return lres;
}

LRESULT CISFBand::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        {
            LPNMTOOLBAR pnmtb = (LPNMTOOLBAR)pnm;
            lres = TBDDRET_DEFAULT;
            _DropdownItem(_IDToPidl(pnmtb->iItem), pnmtb->iItem);
        }
        break;

    case NM_THEMECHANGED:
        {
            SendMessage(_hwndTB, TB_SETBUTTONSIZE, 0, 0);
            SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(0, 0));
            _fInitialized = FALSE;
            _BandInfoChanged();
        }
        break;

    default:
        lres = CSFToolbar::_OnNotify(pnm);
    }

    return lres;
}


HRESULT CISFBand::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                               DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon)
{
    HRESULT hr = CSFToolbar::_TBStyleForPidl(pidl, pdwTBStyle, pdwTBState, pdwMIFFlags, piIcon);

    if (_fAllowDropdown &&
        !_fCascadeFolder && 
        ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
         IsBrowsableShellExt(pidl)))
    {
        *pdwTBStyle &= ~BTNS_BUTTON;
        *pdwTBStyle |= BTNS_DROPDOWN;
    }
    return hr;
}

HMENU CISFBand::_GetContextMenu()
{
    HMENU hmenu = CSFToolbar::_GetContextMenu();
    if (hmenu)
    {
        //
        // nuke the menu items which might resize us (show text,
        // view menu) if bandsite is in locked mode
        //
        IBandSite* pbs;
        if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbs))))
        {
            BANDSITEINFO bsi = {0};
            bsi.dwMask = BSIM_STYLE;
            pbs->GetBandSiteInfo(&bsi);
            if (bsi.dwStyle & BSIS_LOCKED)
            {
                DeleteMenu(hmenu, 0, MF_BYPOSITION);                 // View menu
                DeleteMenu(hmenu, ISFBIDM_SHOWTEXT, MF_BYCOMMAND);   // show text
            }
            pbs->Release();
        }
    }
    return hmenu;
}

LRESULT CISFBand::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    // todo: csidl?
    TraceMsg(DM_MISC, "cib._ocm: _dwPriv=%d", _dwPriv);
    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, (_dwPriv == CSIDL_APPDATA || _dwPriv == CSIDL_FAVORITES) ? UIBL_CTXTQCUTITEM : UIBL_CTXTISFITEM);

    return lres;
}

LRESULT CISFBand::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SIZE:
        // forward to toolbar
        SendMessage(_hwndTB, TB_AUTOSIZE, wParam, lParam);

        if (_GetIdealSize(NULL) != _iIdealLength)
        {
            // our ideal size has changed since the last time bandsite
            // asked; so tell bandsite ask us for our bandinfo again
            _BandInfoChanged();
        }
        return 0;
    }
    return CSFToolbar::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose: Set the given IMenuPopup as the submenu to expand.  Returns
         S_FALSE if the menu was modal, S_OK if it was modeless, or
         failure.

*/
HRESULT CISFBand::_SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMPPF)
{
    HRESULT hr = E_FAIL;

    _ReleaseMenu();

    _pmp = pmp;

    if (pmp)
    {
        pmp->AddRef();

        RECT rc;
        POINT pt;

        SendMessage(_hwndTB, TB_GETRECT, uiCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

        // Align the sub menu appropriately
        if (_fVertical)
        {
            pt.x = rc.right;
            pt.y = rc.top;
        }
        else
        {
            pt.x = rc.left;
            pt.y = rc.bottom;
        }

        // Use a reflect point for the sub-menu to start
        // if the window is RTL mirrored. [samera]
        if (IS_WINDOW_RTL_MIRRORED(_hwndTB))
        {
            pt.x = (_fVertical) ? rc.left : rc.right;
        }

        // Tell the sub menu deskbar who we are, so it can
        // inform us later when the user navigates out of
        // its scope.
        IUnknown_SetSite(_pmp, SAFECAST(this, IDeskBand*));

        // This must be called after SetSite is done above
        _SendInitMenuPopup(pmp, pidl);

        // Show the menubar
        hr = _pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlagsMPPF);
    }
    return hr;
}

void CISFBand::_SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl)
{
}

HRESULT CISFBand::_DropdownItem(LPCITEMIDLIST pidl, UINT idCmd)
{
    HRESULT hr = E_FAIL;
    if (_pidl && _psf)
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);

        if (pidlFull)
        {
            IShellFolder* psf;

            if (SUCCEEDED(_psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                RECT rc;
                SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

                ITrackShellMenu* ptsm;
                if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(ITrackShellMenu, &ptsm))))
                {
                    CISFMenuCallback *pISFMcb = new CISFMenuCallback();

                    if(pISFMcb)
                    {
                        ptsm->Initialize(pISFMcb, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL | SMINIT_NOSETSITE );
                        pISFMcb->SetSite(_punkSite);
                    }
                    else
                        ptsm->Initialize(NULL, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL);

                    if (SUCCEEDED(ptsm->SetShellFolder(psf, pidlFull, NULL, SMSET_TOP | SMSET_USEBKICONEXTRACTION)))
                    {
                        POINTL pt = {rc.left, rc.right};
                        hr = ptsm->Popup(_hwndTB, &pt, (RECTL*)&rc, MPPF_BOTTOM);
                    }
                    if(pISFMcb)
                        pISFMcb->Release();
                    ptsm->Release();
                }
                psf->Release();
            }

            ILFree(pidlFull);
        }
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Try treating the pidl as a cascading menu item.

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd)
{
    LRESULT lRet = 0;

    // Do we cascade to another submenu?
    if ((GetKeyState(VK_CONTROL) < 0) || _fCascadeFolder)
    {
        // Is the item a browsable folder?
        if ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
            IsBrowsableShellExt(pidl))
        {
            // Yes; cascade the browsable folder as a submenu
            lRet = (S_OK == _DropdownItem(pidl, uiCmd));
        }
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Try just invoking the pidl

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TrySimpleInvoke(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    if (S_OK == _pbp->IsConnected())    // Force IE
    {
        LPITEMIDLIST pidlDest;

        if (SUCCEEDED(SHGetNavigateTarget(_psf, pidl, &pidlDest, NULL)) && pidlDest &&
            ILIsWeb(pidlDest))
        {

            TCHAR szPath[MAX_PATH];

            // We want to ensure that we first give NavFrameWithFile a chance
            // since this will do the right thing if the PIDL points to a
            // shortcut.
            // If the PIDL is a shortcut, NavFrameWithFile will restore any
            // persistence information stored in the shortcut
            // if that fails - we take the default code path that simply
            // uses the PIDL
            lRet = SUCCEEDED(GetPathForItem(_psf, pidl, szPath, NULL)) &&
                   SUCCEEDED(NavFrameWithFile(szPath, (IServiceProvider *)this));

            if (!lRet)
            {
                if (EVAL(_pbp) && (SUCCEEDED(_pbp->NavigateToPIDL(pidlDest))))
                    lRet = 1;
            }
            ILFree(pidlDest);
        }
    }

    if (!lRet)
    {
        IContextMenu *pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
        if (pcm)
        {
            LPCSTR pVerb = NULL;
            UINT fFlags = 0;

            // If ALT double click, accelerator for "Properties..."
            if (GetKeyState(VK_MENU) < 0)
            {
                pVerb = SZ_PROPERTIESA;
            }

            //  SHIFT+dblclick does a Explore by default
            if (GetKeyState(VK_SHIFT) < 0)
            {
                fFlags |= CMF_EXPLORE;
            }

            IContextMenu_Invoke(pcm, _hwndTB, pVerb, fFlags);

            pcm->Release();
        }
    }

    return lRet;
}


LRESULT CISFBand::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uiCmd = GET_WM_COMMAND_ID(wParam, lParam);
    LRESULT lres = 0;

    TraceMsg(TF_BAND, "_OnCommand 0x%x", uiCmd);

    LPCITEMIDLIST pidl = _IDToPidl(uiCmd);

    if (pidl)
    {
        if (_eUemLog != UEMIND_NIL) 
        {
            // FEATURE_UASSIST should be grp,uiCmd
            UEMFireEvent(&UEMIID_SHELL, UEME_UIQCUT, UEMF_XEVENT, -1, (LPARAM)-1);
        }

        // Only do this if we are the quick links in the browser. The derived class will set this
        if (_pguidUEMGroup)
        {
            LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
            if (pidlFull)
            {
                UEMFireEvent(_pguidUEMGroup, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)_psf, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidlFull);
                ILFree(pidlFull);
            }
        }

        lres = _TryCascadingItem(pidl, uiCmd);

        if (!lres && _fChannels)
            lres = _TryChannelSurfing(pidl);

        if (!lres)
            lres = _TrySimpleInvoke(pidl);
    }
    else
    {
        MessageBeep(MB_OK);
    }

    return(lres);
}

// *** IPersistStream
HRESULT CISFBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ISFBand;
    return S_OK;
}

//  This might be a directory inside CSIDL_APPDATA that was created on
//  a Win9x machine.  Win9x doesn't do the special folder signature info,
//  so when it shows up on NT, it's just a boring directory that now points
//  to the wrong place.
//  So if we get a bad directory, see if it's one of these corrupted
//  Win9x pidls and if so, try to reconstitute the original CSIDL_APPDATA
//  by searching for "Application Data".

void CISFBand::_FixupAppDataDirectory()
{
    TCHAR szDirPath[MAX_PATH];

    //  We use PathFileExists to check for existence because it turns off
    //  hard error boxes if the target is not available (e.g., floppy not
    //  in drive)

    if (SHGetPathFromIDList(_pidl, szDirPath) &&
        !PathFileExists(szDirPath))
    {
        static TCHAR szBSAppData[] = TEXT("\\Application Data");
        LPTSTR pszAppData;

        // For every instance of "Application Data", try to graft it
        // into the real CSIDL_APPDATA. If it works, run with it.

        for (pszAppData = szDirPath;
             pszAppData = StrStrI(pszAppData, szBSAppData);
             pszAppData++)
        {
            // Found a candidate.  The thing after "\\Application Data"
            // had better be another backslash (in which case we step
            // over it) or the end of the string (in which case we don't).

            TCHAR szPathBuffer[MAX_PATH];
            LPTSTR pszTail = pszAppData + ARRAYSIZE(szBSAppData) - 1;

            // If we did our math right, we should be right after the
            // "a" at the end of "Application Data".
            ASSERT(pszTail[-1] == TEXT('a'));

            if (pszTail[0] == TEXT('\\'))
                pszTail++;              // Step over separator
            else if (pszTail[0] == TEXT('\0'))
                { }                     // at end of string; stay there
            else
                continue;               // we were faked out; keep looking

            if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPathBuffer)))
            {
                PathCombine(szPathBuffer, szPathBuffer, pszTail);
                if (PathFileExists(szPathBuffer))
                {
                    LPITEMIDLIST    pidlReal;
                    pidlReal = ILCreateFromPath(szPathBuffer);
                    if (pidlReal)
                    {
                        ILFree(_pidl);
                        _pidl = pidlReal;
                    }
                    ASSERT(_pidl);
                    break;              // found it; stop looking
                }
            }
        }
    }
}

typedef struct tagBANDISFSTREAM {
    WORD        wVersion;   // version of this structure
    WORD        cbSize;     // size of this structure
    DWORD       dwFlags;    // BANDISF_ flags
    DWORD       dwPriv;     // special folder identifier
    WORD        wViewMode;  // small/large/logo
    WORD        wUnused;    // For DWORD alignment
    COLORREF    crBkgnd;    // band background color
    COLORREF    crBtnLt;    // band button hilite color
    COLORREF    crBtnDk;    // band button lolite color
} BANDISFSTREAM, * PBANDISFSTREAM;

#define BANDISF_VERSION 0x22

#define BANDISF_MASK_PSF         0x00000001 // TRUE if _psf is saved
#define BANDISF_BOOL_NOSHOWTEXT  0x00000002 // TRUE if _fNoShowText
#define BANDISF_BOOL_LARGEICON   0x00000004 // last used in version 0x20
#define BANDISF_MASK_PIDLASLINK  0x00000008 // TRUE if _pidl is saved as a link
#define BANDISF_UNUSED10         0x00000010 // (obsolete) was BOOL_NOTITLE
#define BANDISF_BOOL_CHANNELS    0x00000020 // TRUE if in channel mode
#define BANDISF_BOOL_ALLOWRENAME 0x00000040 // TRUE if _psf context menu should be enabled
#define BANDISF_BOOL_DEBOSSED    0x00000080 // TRUE if band should have embossed background
#define BANDISF_MASK_ORDERLIST   0x00000100 // TRUE if an order list is saved
#define BANDISF_BOOL_BKCOLOR     0x00000200 // TRUE if bk color is persisted
#define BANDISF_BOOL_FULLOPEN    0x00000400 // TRUE if band should maximize when opened
#define BANDISF_BOOL_NONAMESORT  0x00000800 // TRUE if band should _not_ sort icons by name
#define BANDISF_BOOL_BTNMINSIZE  0x00001000 // TRUE if band should report min thickness of button
#define BANDISF_BOOL_COLORS      0x00002000 // TRUE if colors are persisted
#define BANDISF_VALIDBITS        0x00003FFF

HRESULT CISFBand::Load(IStream *pstm)
{
    HRESULT hr;
    DWORD cbRead;
    BANDISFSTREAM bisfs = {0};

    // figure out what we need to load
    // read first DWORD only (old stream format started with ONE dword)
    hr = pstm->Read(&bisfs, sizeof(DWORD), &cbRead);
    _fIgnoreAddToFront = TRUE;

    if (SUCCEEDED(hr))
    {
        if (bisfs.cbSize == 0)
        {
            // upgrade case, IE4 beta1 shipped this way
            bisfs.dwFlags = *((LPDWORD)&bisfs);
            bisfs.cbSize = sizeof(bisfs);
            bisfs.wVersion = BANDISF_VERSION;
            bisfs.dwPriv = -1;
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        }
        else
        {
            // read rest of stream
            DWORD dw = (DWORD)bisfs.cbSize;
            if (dw > sizeof(bisfs))
                dw = sizeof(bisfs);
            dw -= sizeof(DWORD);
            hr = pstm->Read(&(bisfs.dwFlags), dw, &cbRead);
            if (FAILED(hr))
                return(hr);
        }

        // HEY, DON'T BE LAME ANY MORE.  When you next touch this code,
        // I suggest you figure out what sizes of this structure have
        // been actually shipped and only upgrade those.  Also use
        // the offsetof macro so you don't have to keep calculating these
        // things...

        // old upgrade, I don't know what state is persisted at setup time!
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF) - sizeof(DWORD) - sizeof(DWORD))
        {
            bisfs.dwPriv = -1;
            bisfs.cbSize += sizeof(DWORD);
        }
        // most recent upgrade, this is NOT persisted in registry at setup time!!!
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF) - sizeof(DWORD))
        {
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
            bisfs.cbSize = sizeof(bisfs);
        }
        // upgrade from version 0x21 + crBkgnd only to 0x22
        if (bisfs.cbSize == sizeof(bisfs) - 2*sizeof(COLORREF))
        {
            bisfs.cbSize = sizeof(bisfs);
        }
        // upgrade from version 0x21 to 0x22
        if (bisfs.cbSize == sizeof(bisfs) - 3*sizeof(COLORREF))
        {
            bisfs.cbSize = sizeof(bisfs);
        }

        if (!EVAL(bisfs.cbSize >= sizeof(bisfs)))
        {
            return(E_FAIL);
        }
        ASSERT(!(bisfs.dwFlags & ~BANDISF_VALIDBITS));

        if (bisfs.dwFlags & BANDISF_BOOL_NOSHOWTEXT)
            _fNoShowText = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_ALLOWRENAME)
            _fAllowRename = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_DEBOSSED)
            _fDebossed = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_FULLOPEN)
            _fFullOpen = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_NONAMESORT)
            _fNoNameSort = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BTNMINSIZE)
            _fBtnMinSize = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BKCOLOR)
        {
            _crBkgnd = bisfs.crBkgnd;
            _fHaveBkColor = TRUE;
        }
        if (bisfs.dwFlags & BANDISF_BOOL_COLORS)
        {
            _crBtnLt = bisfs.crBtnLt;
            _crBtnDk = bisfs.crBtnDk;
            _fHaveColors = TRUE;
        }

        _dwPriv = bisfs.dwPriv;
        if (_dwPriv == CSIDL_APPDATA) 
        {
            _eUemLog = UEMIND_SHELL;
        }

        _uIconSize = bisfs.wViewMode;
        _fNoRecalcDefaults = TRUE;

        if (bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
        {
            ASSERT(NULL==_pidl);
            hr = LoadPidlAsLink(_punkSite, pstm, &_pidl);
            // If we hit hits, LoadPidlAsLink() read a chuck of our data. - BryanSt
            ASSERT(SUCCEEDED(hr));

//            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
//            TraceMsg(TF_BAND|TF_GENERAL, "CISFBand::Load() _pidl=>%s<", Dbg_PidlStr(_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            _FixupAppDataDirectory();

        }
                
        if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_PSF))
        {
            ASSERT(NULL == _psf);
            hr = OleLoadFromStream(pstm, IID_PPV_ARG(IShellFolder, &_psf));
        }

        // map this to working info
        if (SUCCEEDED(hr))
            hr = _AfterLoad();

        // we need _psf before we can read the order list.
        if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
        {
            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            if (SUCCEEDED(hr))
            {
                // _fDropped "persists" along with the orderlist - if this flag
                // is set, we assume we have a non-default ordering
                _fDropped = TRUE;
            }
        }
    }

    return hr;
}

HRESULT SaveIsfToStream(IShellFolder *psf, IStream *pstm)
{
    IPersistStream* pps;
    HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = OleSaveToStream(pps, pstm);
        pps->Release();
    }
    return hr;
}

HRESULT CISFBand::Save(IStream *pstm, BOOL fClearDirty)
{
    IPersistStream* pps = NULL;
    BANDISFSTREAM bisfs = {0};

    // figure out what we will save
    if (_pidl)
        bisfs.dwFlags |= BANDISF_MASK_PIDLASLINK;

    if (_psf && !_fPSFBandDesktop)
        bisfs.dwFlags |= BANDISF_MASK_PSF;
    if (_fDropped && (_hdpa || _hdpaOrder)) // only if a drop occurred do we have non-default ordering
        bisfs.dwFlags |= BANDISF_MASK_ORDERLIST;

    if (_fNoShowText)
        bisfs.dwFlags |= BANDISF_BOOL_NOSHOWTEXT;
    if (_fAllowRename)
        bisfs.dwFlags |= BANDISF_BOOL_ALLOWRENAME;
    if (_fDebossed)
        bisfs.dwFlags |= BANDISF_BOOL_DEBOSSED;
    if (_fFullOpen)
        bisfs.dwFlags |= BANDISF_BOOL_FULLOPEN;
    if (_fNoNameSort)
        bisfs.dwFlags |= BANDISF_BOOL_NONAMESORT;
    if (_fBtnMinSize)
        bisfs.dwFlags |= BANDISF_BOOL_BTNMINSIZE;
    if (_fHaveBkColor)
    {
        bisfs.dwFlags |= BANDISF_BOOL_BKCOLOR;
        bisfs.crBkgnd = _crBkgnd;
    }
    if (_fHaveColors)
    {
        bisfs.dwFlags |= BANDISF_BOOL_COLORS;
        bisfs.crBtnLt = _crBtnLt;
        bisfs.crBtnDk = _crBtnDk;
    }

    bisfs.cbSize = sizeof(bisfs);
    bisfs.wVersion = BANDISF_VERSION;
    bisfs.dwPriv = _dwPriv;
    bisfs.wViewMode = _uIconSize;

    // now save it
    HRESULT hr = pstm->Write(&bisfs, sizeof(bisfs), NULL);

    if (SUCCEEDED(hr) && bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
    {
        hr = SavePidlAsLink(_punkSite, pstm, _pidl);
    }

    if (SUCCEEDED(hr) && bisfs.dwFlags & BANDISF_MASK_PSF)
    {
        hr = SaveIsfToStream(_psf, pstm);
    }

    if (SUCCEEDED(hr) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
    {
        hr = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);
    }


    return hr;
}

// IContextMenu implementation
HRESULT CISFBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    UINT uNewMode = 0;
    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case ISFBIDM_LARGE:
        uNewMode = ISFBVIEWMODE_LARGEICONS;
        goto newViewMode;

    case ISFBIDM_SMALL:
        uNewMode = ISFBVIEWMODE_SMALLICONS;
newViewMode:
        if (uNewMode != _uIconSize)
        {
            BOOL fRefresh = FALSE;

            if (uNewMode == ISFBVIEWMODE_LOGOS || _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                // invalidate all before switching the imagelist...
                _RememberOrder();

                EmptyToolbar();
                fRefresh = TRUE;
            }

            // we Logo view has now left the building...
            if (uNewMode != ISFBVIEWMODE_LOGOS && _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                ExitLogoView();
            }

            fChanged = _UpdateIconSize(uNewMode, TRUE);

            if (fRefresh)
            {
                _FillToolbar();
            }
            if (fChanged)
                _BandInfoChanged();
        }
        // fall thru
    default:
        return CSFToolbar::InvokeCommand(lpici);
    }

    return(S_OK);
}

// *** IOleCommandTarget methods ***

STDMETHODIMP CISFBand::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case ISFBID_CACHEPOPUP:
            case ISFBID_ISITEMVISIBLE:
            case ISFBID_PRIVATEID:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SHDVID_UEMLOG:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_IsPidlVisible(LPITEMIDLIST pidl)
{
    int i;
    HRESULT hr = _GetButtonFromPidl(pidl, NULL, &i, NULL);

    if (SUCCEEDED(hr))
    {
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        if (SHIsButtonObscured(_hwndTB, &rc, i))
            hr = S_FALSE;
        else
            hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_OrderListFromIStream(VARIANT* pvarargIn)
{
    HRESULT hr = E_FAIL;
    if (pvarargIn->vt == VT_UNKNOWN)
    {
        IStream* pstm;
        if (SUCCEEDED(pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IStream, &pstm))))
        {
            OrderList_Destroy(&_hdpaOrder);
            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
            if (SUCCEEDED(hr))
            {
                _SetDirty(TRUE);
                // flush out since our orderlist changed -- filltoolbar will just
                // do a diff and that won't do anything on a simple reordering.
                EmptyToolbar();
                if (_fShow)
                {
                    _FillToolbar();
                }
            }
            pstm->Release();
        }
    }

    return hr;
}

HRESULT CISFBand::_IStreamFromOrderList(VARIANT* pvarargOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    ASSERT(pvarargOut != NULL);

    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        hr = OrderList_SaveToStream(pstm, _hdpa, _psf);
        if (SUCCEEDED(hr))
        {
            pvarargOut->vt = VT_UNKNOWN;
            pvarargOut->punkVal = pstm;
            pvarargOut->punkVal->AddRef();
        }
        pstm->Release();
    }

    return hr;
}

STDMETHODIMP CISFBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ISFBID_CACHEPOPUP:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
            {
                IMenuPopup* pmp = NULL;
                if (pvarargIn->punkVal)
                    pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp));

                _SetCacheMenuPopup(pmp);

                ATOMICRELEASE(pmp);
            }

            if (pvarargOut)
            {
                pvarargOut->vt = VT_UNKNOWN;
                pvarargOut->punkVal = _pmpCache;
                if (_pmpCache)
                    _pmpCache->AddRef();
            }
            return S_OK;

        case ISFBID_ISITEMVISIBLE:
            {
                HRESULT hr = E_INVALIDARG;

                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    hr = _IsPidlVisible((LPITEMIDLIST)pvarargIn->byref);

                return hr;
            }

        case ISFBID_PRIVATEID:
            // hack hack for BSMenu to differentiate between specially created
            // isfbands. see bsmenu's _FindBand
            // if pvarargOut is set, we give back the id we have stored.
            if (pvarargOut)
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _dwPriv;
            }
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _dwPriv = pvarargIn->lVal;

            return S_OK;

        case ISFBID_GETORDERSTREAM:
            return _IStreamFromOrderList(pvarargOut);

        case ISFBID_SETORDERSTREAM:
            return _OrderListFromIStream(pvarargIn);
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_UEMLOG:
            ASSERT(pvarargOut == NULL);
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _eUemLog = pvarargIn->lVal;
                ASSERT(_eUemLog == UEMIND_SHELL || _eUemLog == UEMIND_BROWSER);
            }

            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_DELAYINIT:
            _fDelayInit = TRUE;
            break;

        case DBID_FINISHINIT:
            _fDelayInit = FALSE;
            _RegisterToolbar();
            break;

        case DBID_SETWINDOWTHEME:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                if (_hwndTB)
                {
                    SendMessage(_hwndTB, TB_SETWINDOWTHEME, 0, (LPARAM)pvarargIn->bstrVal);
                    _BandInfoChanged();
                }
            }
        }
        return S_OK;
    }
    
    return OLECMDERR_E_NOTSUPPORTED;
}

IShellFolder * CISFBand::GetSF()
{
    ASSERT(_psf);
    return _psf;
}

HWND CISFBand::GetHWND()
{
    return _hwndTB;
}

REFTASKOWNERID CISFBand::GetTOID()
{
    return TOID_ExtractImage;
}

HRESULT CISFBand::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (lEvent == SHCNE_RMDIR && _IsEqualID(pidl1))
    {
        HRESULT hr = E_FAIL;
        IBandSite *pbandSite;
        if (_punkSite)
        {
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbandSite));
            if (EVAL(SUCCEEDED(hr))) 
            {
                pbandSite->RemoveBand(_dwBandID);
                pbandSite->Release();
            }
        }
        return hr;
    }
    else
    {
        return CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    }
}

HRESULT CISFBand::UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache)
{
    int iItem = (int)dwItem;
    HRESULT hr;
    UINT uImage;

    // catch if we are closing...
    if (_fClosing)
        return S_OK;

    IMAGECACHEINFO rgInfo;
    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
    rgInfo.cbSize = sizeof(rgInfo);
    rgInfo.pszName = pszCache;

    rgInfo.hBitmapLarge = hImage;

    ASSERT(_pLogoCache);
    if (_pLogoCache)
        hr = _pLogoCache->AddImage(&rgInfo, &uImage);
    else
        hr = E_FAIL;

    // catch if we are closing...
    if (_fClosing)
        return S_OK;

    if (SUCCEEDED(hr))
    {
        // remember the icon to logo mapping....
        AddIndicesToLogoList(iIcon, uImage);

        // catch we are closing before we try and doa bloc
        PostMessage(_hwndTB, TB_CHANGEBITMAP, iItem, uImage);
    }

    // stop delay painting when the last extract image task calls back
    if (_fDelayPainting)
    {
        if (_pTaskScheduler && _pTaskScheduler->CountTasks(TOID_NULL) == 1)
        {
            _StopDelayPainting();
        }
    }

    return hr;
}

// }


HRESULT CISFBand::_GetTitleW(LPWSTR pwszTitle, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_BAND, "Calling baseclass CISFBand::_GetTitleW");

    if (!EVAL(pwszTitle))
        return E_INVALIDARG;

    *pwszTitle = 0;
    if (_pidl)
    {
        hr = SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pwszTitle, cchSize, NULL);
    }

    return hr;
}

STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl);

LRESULT CISFBand::_TryChannelSurfing(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    ASSERT(_fChannels);

    LPITEMIDLIST pidlTarget;

    HRESULT hr = SHGetNavigateTarget(_psf, pidl, &pidlTarget, NULL);
    if (SUCCEEDED(hr))
    {
        IWebBrowser2* pwb;

        // n.b. careful! only one of GCB and C_OB up the refcnt
        _GetChannelBrowser(&pwb);
        if (SUCCEEDED(Channels_OpenBrowser(&pwb, pwb != NULL)))
        {
            lRet = 1;   // success at this point

            if (SUCCEEDED(NavigateToPIDL(pwb, pidlTarget)))
            {
                LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
                if (pidlFull)
                {
                    VARIANT varURLpidl, flags;
                    flags.vt = VT_I4;
                    flags.lVal = navBrowserBar;
                    if (SUCCEEDED(InitVariantFromIDList(&varURLpidl, pidlFull)))
                    {
                        pwb->Navigate2(&varURLpidl, &flags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                        VariantClear(&varURLpidl);
                    }
                    ILFree(pidlFull);
                }
            }
        }
        if (pwb)
            pwb->Release();

        ILFree(pidlTarget);
    }

    return lRet;
}

//***   _GetChannelBrowser -- find appropriate browser for surfing
// DESCRIPTION
//  for the DTBrowser case, we fail (pwb=NULL, hr=S_FALSE) so that our
// caller will create a new SHBrowser (which can be put into theater mode).
// for the SHBrowser case, we find the top-level browser (so we'll navigate
// in-place).
HRESULT CISFBand::_GetChannelBrowser(IWebBrowser2 **ppwb)
{
    HRESULT hr;

    *ppwb = NULL;   // assume failure
    if (_fDesktop) 
    {
        ASSERT(*ppwb == NULL);
        hr = S_FALSE;
    }
    else 
    {
        hr = IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, ppwb));
    }

    return hr;
}

///////////////////////////CLogoExtractImageTask///////////////////////////////////////////////

// Warning
// The CLogoBase class cannot have a ref on the returned task
// since that would be a circular reference
// Warning

HRESULT CLogoExtractImageTask_Create(CLogoBase *plb,
                                  IExtractImage *pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  IRunnableTask ** ppTask)
{
    if (!ppTask || !plb || !pExtract)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    CLogoExtractImageTask * pNewTask = new CLogoExtractImageTask(&hr, plb, pExtract, pszCache, dwItem, iIcon, dwFlags);
    if (pNewTask)
    {
        *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


CLogoExtractImageTask::CLogoExtractImageTask(HRESULT * pHr, CLogoBase *plb, IExtractImage * pImage,
    LPCWSTR pszCache, DWORD dwItem, int iIcon, DWORD dwFlags)
{
    m_lState = IRTIR_TASK_NOT_RUNNING;

    m_plb = plb;
    m_plb->AddRef();

    // cannot assume the band will kill us before it dies....
    // hence we hold a reference

    StringCchCopy(m_szPath, ARRAYSIZE(m_szPath), pszCache);

    m_pExtract = pImage;
    pImage->AddRef();

    m_cRef = 1;

    // use the upper bit of the flags to determine if we should always call....
    m_dwFlags = dwFlags;
    m_dwItem = dwItem;
    m_iIcon = iIcon;

    // Since the task moves from thread to thread,
    // don't charge this thread for the objects we're using
}

CLogoExtractImageTask::~CLogoExtractImageTask()
{
    ATOMICRELEASE(m_pExtract);
    ATOMICRELEASE(m_pTask);

    if (m_hBmp && !(m_dwFlags & EITF_SAVEBITMAP))
    {
        DeleteObject(m_hBmp);
    }

    if (m_plb)
        m_plb->Release();
}

STDMETHODIMP CLogoExtractImageTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CLogoExtractImageTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CLogoExtractImageTask::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_ (ULONG) CLogoExtractImageTask::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CLogoExtractImageTask::Run(void)
{
    HRESULT hr = E_FAIL;
    if (m_lState == IRTIR_TASK_RUNNING)
    {
        hr = S_FALSE;
    }
    else if (m_lState == IRTIR_TASK_PENDING)
    {
        hr = E_FAIL;
    }
    else if (m_lState == IRTIR_TASK_NOT_RUNNING)
    {
        LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_RUNNING);
        if (lRes == IRTIR_TASK_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
            return S_OK;
        }

        // see if it supports IRunnableTask
        m_pExtract->QueryInterface(IID_PPV_ARG(IRunnableTask, &m_pTask));

        // IE4.01 has an error - it returns the wrong VTABLE
        // when this QI is done.

        if ((void *)m_pTask == (void *)m_pExtract)
        {
            m_pTask = m_pTask + 2; // This vtable is two ptrs away and is in fstree.cpp in shell32 in IE4.01
        }

        if (m_lState == IRTIR_TASK_RUNNING)
        {
            // start the extractor....
            hr = m_pExtract->Extract(&m_hBmp);
        }

        if ((SUCCEEDED(hr) || (hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL))) && m_lState == IRTIR_TASK_RUNNING)
        {
            hr = InternalResume();
        }

        if (m_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Kill(BOOL fWait)
{
    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return S_FALSE;
    }

    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        m_lState = lRes;
        return S_OK;
    }

    // does it support IRunnableTask ? Can we kill it ?
    HRESULT hr = E_NOTIMPL;
    if (m_pTask != NULL)
    {
        hr = m_pTask->Kill(FALSE);
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Suspend(void)
{
    if (!m_pTask)
    {
        return E_NOTIMPL;
    }

    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }


    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_SUSPENDED);
    HRESULT hr = m_pTask->Suspend();
    if (SUCCEEDED(hr))
    {
        lRes = (LONG) m_pTask->IsRunning();
        if (lRes == IRTIR_TASK_SUSPENDED)
        {
            m_lState = lRes;
        }
    }
    else
    {
        m_lState = lRes;
    }

    return hr;
}

STDMETHODIMP CLogoExtractImageTask::Resume(void)
{
    if (!m_pTask)
    {
        return E_NOTIMPL;
    }

    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = m_pTask->Resume();
    if (SUCCEEDED(hr) || (hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL)))
    {
        hr = InternalResume();
    }

    return hr;
}

HRESULT CLogoExtractImageTask::InternalResume()
{
    HRESULT hr = S_OK;
    if (m_dwFlags & EITF_ALWAYSCALL || m_hBmp)
    {
        // call the update function
        hr = m_plb->UpdateLogoCallback(m_dwItem, m_iIcon, m_hBmp, m_szPath, TRUE);
    }

    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP_(ULONG) CLogoExtractImageTask:: IsRunning(void)
{
    return m_lState;
}


// static data...
IImageCache * CLogoBase::s_pSharedWideLogoCache = NULL;
long CLogoBase::s_lSharedWideLogosRef = 0;
HDSA CLogoBase::s_hdsaWideLogoIndices = NULL;
CRITICAL_SECTION CLogoBase::s_csSharedLogos = {0};


CLogoBase::CLogoBase(BOOL fWide)
{
    // are we paletized, then use the global halftone palette ....
    HDC hdcTmp = GetDC(NULL);
    if (hdcTmp)
    {
        if (GetDeviceCaps(hdcTmp, RASTERCAPS) & RC_PALETTE)
        {
            // we're allocating in the constructor, but so what
            // nobody calls this code anyway, i was going to delete it all but that bug got punted
            _hpalHalftone = SHCreateShellPalette(NULL);
        }
        ReleaseDC(NULL, hdcTmp);
    }

    _fWide = fWide;
}

CLogoBase::~CLogoBase()
{
    if (_pLogoCache || _pTaskScheduler)
    {
        ExitLogoView();
    }

    if (_hpalHalftone)
    {
        DeletePalette(_hpalHalftone);
    }
}

HRESULT CLogoBase::AddRefLogoCache(void)
{
    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);

        if (!s_lSharedWideLogosRef)
        {
            if (!s_hdsaWideLogoIndices)
            {
                s_hdsaWideLogoIndices = DSA_Create(sizeof(LogoIndex), 5);
                if (!s_hdsaWideLogoIndices)
                {
                    LeaveCriticalSection(&s_csSharedLogos);
                    return E_OUTOFMEMORY;
                }
            }

            ASSERT(s_hdsaWideLogoIndices);
            ASSERT(!s_pSharedWideLogoCache);

            HRESULT hr = CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC,
                                           IID_PPV_ARG(IImageCache, &s_pSharedWideLogoCache));
            if (FAILED(hr))
            {
                LeaveCriticalSection(&s_csSharedLogos);
                return hr;
            }
        }

        ASSERT(s_pSharedWideLogoCache);

        // bump up the ref and get a pointer to it...
        s_lSharedWideLogosRef ++;
        _pLogoCache = s_pSharedWideLogoCache;
        _pLogoCache->AddRef();
        _hdsaLogoIndices = s_hdsaWideLogoIndices;
        LeaveCriticalSection(&s_csSharedLogos);

        return S_OK;
    }
    else
    {
        // non wide logo version we don't share because w eonly expect there ever to be one...
        _hdsaLogoIndices = DSA_Create(sizeof(LogoIndex), 5);
        if (!_hdsaLogoIndices)
        {
            return E_OUTOFMEMORY;
        }

        return CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC, IID_PPV_ARG(IImageCache, &_pLogoCache));
    }
}

HRESULT CLogoBase::ReleaseLogoCache(void)
{
    if (!_pLogoCache)
    {
        return S_FALSE;
    }

    ATOMICRELEASE(_pLogoCache);

    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);

        ASSERT(s_lSharedWideLogosRef > 0);

        s_lSharedWideLogosRef --;
        if (! s_lSharedWideLogosRef)
        {
            // let go of the final ref.....
            ATOMICRELEASE(s_pSharedWideLogoCache);

            ASSERT(s_hdsaWideLogoIndices);
            DSA_Destroy(s_hdsaWideLogoIndices);
            s_hdsaWideLogoIndices = NULL;
        }

        LeaveCriticalSection(&s_csSharedLogos);
    }
    else
    {
        // free the HDSA
        DSA_Destroy(_hdsaLogoIndices);
    }

    return S_OK;
}

HRESULT CLogoBase::InitLogoView(void)
{
    HRESULT hr = AddRefLogoCache();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                              IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler));
        if (FAILED(hr))
        {
            ATOMICRELEASE(_pLogoCache);
        }
        else
        {
            _rgLogoSize.cx = (_fWide) ? LOGO_WIDE_WIDTH : LOGO_WIDTH ;
            _rgLogoSize.cy = LOGO_HEIGHT;

            IMAGECACHEINITINFO rgInfo;
            rgInfo.cbSize = sizeof(rgInfo);
            rgInfo.dwMask = ICIIFLAG_LARGE;
            rgInfo.iStart = 0;
            rgInfo.iGrow = 5;

            // the color depth is currently the screen resolution...
            int iColorRes = SHGetCurColorRes();

            _dwClrDepth = (DWORD) iColorRes;
            switch (iColorRes)
            {
                case 16 :   rgInfo.dwFlags = ILC_COLOR16;
                            break;
                case 24 :
                case 32 :   rgInfo.dwFlags = ILC_COLOR24;
                            break;
                default :   rgInfo.dwFlags = ILC_COLOR8;
            }

            rgInfo.rgSizeLarge = _rgLogoSize;
            if (_pLogoCache)
                hr = _pLogoCache->GetImageList(&rgInfo);
            else
                hr = E_UNEXPECTED;

            if (FAILED(hr))
            {
                ATOMICRELEASE(_pLogoCache);
                ATOMICRELEASE(_pTaskScheduler);
            }
            else
            {
                _himlLogos = rgInfo.himlLarge;

                // GetImageList() will return S_FALSE if it was already created...
                if ((hr == S_OK) && (iColorRes <= 8))
                {
                    // init the color table so that it matches The "special halftone palette"
                    HPALETTE hpal = SHCreateShellPalette(NULL);
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    ASSERT(hpal);
                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // SHGetShellPalette should always return a 256 colour palette
                    ASSERT(nColours == ARRAYSIZE(rgColours));

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    DeletePalette(hpal);

                    ImageList_SetColorTable(_himlLogos, 0, 256, rgDIBColours);
                }
            }
        }
    }

    return hr;
}

HRESULT CLogoBase::ExitLogoView(void)
{
    ATOMICRELEASE(_pTaskScheduler);

    // the task scheduler callbacks can reference
    // the logocache, so make sure you free the
    // logo cache AFTER the task scheduler!
    ReleaseLogoCache();

    return S_OK;
}

int CLogoBase::GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD *pdwFlags)
{
    DWORD dwPassedFlags = 0;

    if (pdwFlags)
    {
        dwPassedFlags = *pdwFlags;
        *pdwFlags = 0;
    }

    // No logo cache?
    if (!_pLogoCache)
        return 0;

    ASSERT(pidl);
    // HACK: this is used on browser only mode to tell what sort of logos we need...
    IExtractImage *pImage = NULL;
    int iImage = -1;
    HRESULT hr = E_FAIL;

    // IID_IEXtractLogo and IID_IExtractImage are the same interface, by using a new guid
    // it means we can selectively decided what can logo in logo view...
    hr = GetSF()->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractImage, NULL, &pImage));
    if (SUCCEEDED(hr))
    {
        // extract ....
        HBITMAP hImage;
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ASPECT | dwPassedFlags;
        IMAGECACHEINFO rgInfo;
        UINT uIndex;
        BOOL fAsync;
        DWORD dwPriority;

        rgInfo.cbSize = sizeof(rgInfo);

        hr = pImage->GetLocation(szPath, MAX_PATH, &dwPriority, &_rgLogoSize, _dwClrDepth, &dwFlags);
        fAsync = (hr == E_PENDING);
        if (SUCCEEDED(hr) || fAsync)
        {
            // mask off the flags passed to use by the flags returned from the extractor...
            if (pdwFlags)
                *pdwFlags = dwPassedFlags & dwFlags;

            rgInfo.dwMask = ICIFLAG_NAME;
            rgInfo.pszName = szPath;

            hr = _pLogoCache->FindImage(&rgInfo, &uIndex);
            if (hr == S_OK)
            {
                ATOMICRELEASE(pImage);
                return (int) uIndex;
            }

            if (fAsync)
            {
                IRunnableTask *pTaskTmp = NULL;

                ASSERT(_pTaskScheduler);

                // pass the icon index so we can find the right logo later...
                int iIcon = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
                hr = CLogoExtractImageTask_Create(this,
                                               pImage,
                                               szPath,
                                               dwItem,
                                               iIcon,
                                               0,
                                               &pTaskTmp);
                if (SUCCEEDED(hr))
                {
                    if (!ppTask)
                    {
                        hr = AddTaskToQueue(pTaskTmp, dwPriority, dwItem);
                        pTaskTmp->Release();
                    }
                    else
                    {
                        * ppTask = pTaskTmp;

                        ASSERT(pdwPriority);
                        *pdwPriority = dwPriority;
                    }
                }
                else if (ppTask)
                {
                    *ppTask = NULL;
                }

                // if all this failed, then we will just end up with a default
                // logo. This is only likely to fail in low memory conditions,
                // so that will be fine.

                // if this SUCCEEDED we will drop through to pick up a defualt piccy for now.
            }
            else
            {
                // otherwise extract synchronously.......
                hr = pImage->Extract(&hImage);
                if (SUCCEEDED(hr))
                {
                    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
                    rgInfo.hBitmapLarge = hImage;

                    hr = _pLogoCache->AddImage(&rgInfo, &uIndex);
                    DeleteObject(hImage);
                }
                if (SUCCEEDED(hr))
                {
                    iImage = (int) uIndex;
                }
            }
        }
    }

    ATOMICRELEASE(pImage);

    return iImage;
}

int CLogoBase::GetLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD *pdwFlags)
{
    int iImage = GetCachedLogoIndex(dwItem, pidl, ppTask, pdwPriority, pdwFlags);

    if (iImage == -1)
    {
        // always pass FALSE, we want the proper ICON, cdfview no longer hits the
        // wire for the icon so we can safely ask for the correct icon.
        iImage = GetDefaultLogo(pidl, FALSE);

    }
    return iImage;
}

HRESULT CLogoBase::AddTaskToQueue(IRunnableTask *pTask, DWORD dwPriority, DWORD dwItem)
{
    ASSERT(_pTaskScheduler);
    return _pTaskScheduler->AddTask(pTask, GetTOID(), dwItem, dwPriority);
}

int CLogoBase::GetDefaultLogo(LPCITEMIDLIST pidl, BOOL fQuick)
{
    USES_CONVERSION;

    // Get icon to draw from
    int iIndex = -1;
    if (!fQuick)
    {
        iIndex = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
    }
    if (iIndex < 0)
    {
        iIndex = II_DOCNOASSOC;
    }

    WCHAR wszText[MAX_PATH];

    wszText[0] = 0;

    STRRET strret;
    HRESULT hr = GetSF()->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strret);
    if (SUCCEEDED(hr))
    {
        StrRetToBufW(&strret, pidl, wszText, ARRAYSIZE(wszText));
    }

    UINT uCacheIndex = (UINT) -1;

    if (_pLogoCache)    // We didn't have one in stress.
    {
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof(rgInfo);
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX;
        rgInfo.pszName = wszText;
        rgInfo.iIndex = iIndex;

        hr = _pLogoCache->FindImage(&rgInfo, &uCacheIndex);
        if (hr == S_OK)
        {
            return uCacheIndex;
        }

        HBITMAP hDef;
        hr = CreateDefaultLogo(iIndex, _rgLogoSize.cx, _rgLogoSize.cy, W2T(wszText), &hDef);
        if (SUCCEEDED(hr))
        {
            rgInfo.hBitmapLarge = hDef;
            rgInfo.hMaskLarge = NULL;
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_BITMAP | ICIFLAG_LARGE;

            hr = _pLogoCache->AddImage(&rgInfo, &uCacheIndex);
            if (FAILED(hr))
            {
                uCacheIndex = (UINT) -1;
            }
            else
            {
                // remember the index of the logo
                AddIndicesToLogoList(iIndex, uCacheIndex);
            }
            DeleteObject(hDef);
        }
    }

    return (int) uCacheIndex;
}

#define DXFUDGE     4
#define COLORTEXT   RGB(255,255,255)
#define COLORBK     RGB(0,0,0)
HRESULT CLogoBase::CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo)
{
    HRESULT hr = E_OUTOFMEMORY;
    HBITMAP hbmp = NULL;

    HIMAGELIST himl;
    int cxIcon, cyIcon;
   int x, y, dx, dy;

    // get the small icons....
    Shell_GetImageLists(NULL, &himl);
    ImageList_GetIconSize(himl, &cxIcon, &cyIcon);

    // Calculate position info. We assume logos are wider than they are tall.
    ASSERT(cxLogo >= cyLogo);

    // Put the icon on the left
    x = 2;

    // Center the icon vertically
    if (cyIcon <= cyLogo)
    {
        y = (cyLogo - cyIcon) / 2;
        dy = cyIcon;
        dx = cxIcon;
    }
    else
    {
        y = 0;
        dy = cyLogo;

        // keep shrinkage proportional
        dx = MulDiv(cxIcon, cyIcon, cyLogo);
    }

    // get ready to draw
    HDC hTBDC = GetDC(GetHWND());
    if (!hTBDC)
    {
        return E_FAIL;
    }
    HDC hdc = CreateCompatibleDC(hTBDC);
    if (hdc)
    {
        RECT    rc;
        int     dx, dy, x, y;
        SIZE    size;
        hbmp = CreateCompatibleBitmap(hTBDC, cxLogo, cyLogo);
        if (hbmp)
        {
            HGDIOBJ hTmp = SelectObject(hdc, hbmp);
            HPALETTE hpalOld;
            HFONT hfont, hfontOld;

            if (_hpalHalftone)
            {
                hpalOld = SelectPalette(hdc, _hpalHalftone, TRUE);
                // LINTASSERT(hpalOld || !hpalOld);     // 0 semi-ok for SelectPalette
                RealizePalette(hdc);
            }

            SetMapMode(hdc, MM_TEXT);
            rc.left = rc.top = 0;
            rc.bottom = cyLogo;
            rc.right = cxLogo;
            SHFillRectClr(hdc, &rc, COLORBK);
            // draw the icon into the memory DC.
            ImageList_GetIconSize(himl, &dx, &dy);
            x = DXFUDGE;
            y = ((cyLogo- dy) >> 1);
            ImageList_Draw(himl, iIcon, hdc, x, y, ILD_TRANSPARENT);
            hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            hfontOld = hfont ? (HFONT)SelectObject(hdc, hfont) : NULL;
            GetTextExtentPoint32(hdc, pszText, lstrlen(pszText), &size);
            x += (dx + DXFUDGE);
            y = ((cyLogo- size.cy) >> 1);
            rc.left = x;
            UINT eto = ETO_CLIPPED;
            SetTextColor(hdc, COLORTEXT);
            SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, x, y, eto, &rc
                                        , pszText, lstrlen(pszText), NULL);
            if (hfontOld)
                SelectObject(hdc, hfontOld);

            if (hfont)
                DeleteObject(hfont);

            if (_hpalHalftone)
            {
                (void) SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }

            // remove the final bitmap
            SelectObject(hdc, hTmp);
            hr = S_OK;

            if (FAILED(hr))
            {
                DeleteObject(hbmp);
                hbmp = NULL;
            }
        }

        DeleteDC(hdc);
    }
    ReleaseDC(GetHWND(), hTBDC);

    *phBmpLogo = hbmp;

    return hr;
}

int CLogoBase::AddIndicesToLogoList(int iIcon, UINT uIndex)
{
    int iRet = -1;

    LogoIndex * pIndex;
    LogoIndex rgNew;

    rgNew.iIcon = iIcon;
    rgNew.iLogo = (int) uIndex;

    if (_fWide)
    {
        EnterCriticalSection(&s_csSharedLogos);
    }

    // scan to see if we have an extact match already in there...
    for (int n = 0; n < DSA_GetItemCount(_hdsaLogoIndices); n ++)
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr(_hdsaLogoIndices, n);
        ASSERT(pIndex);
        if (pIndex->iLogo == (int) uIndex)
        {
            // set the icon just incase it changed...
            pIndex->iIcon = iIcon;
            iRet = n;
            break;
        }
    }

    if (iRet == -1)
    {
        iRet = DSA_AppendItem(_hdsaLogoIndices, &rgNew);
    }

    if (_fWide)
    {
        LeaveCriticalSection(&s_csSharedLogos);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

// (DavidJen) might be paranoic but these two function were previously defined extern "C" in this header
// just to be sure I pull in the thunked definitions; these definitions are used within browseUI
#if !defined(NotifyWinEvent) || !defined(LresultFromObject)
#include "apithk.h"
#endif

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

// NOTE (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();

    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\isfband.h ===
#ifndef BANDISF
#define BANDISF

#include "bands.h"
#include "logo.h"
#include "sftbar.h"

class CISFBand : public CToolbarBand,
                 public CSFToolbar,
                 public CLogoBase,
                 public IFolderBandPriv
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods (CToolBand PURE) ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IContextMenu methods (override) ***
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    
    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IShellFolderBand methods ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi);
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IFolderBandPriv
    // for internal guys so that we don't have to use a prop page
    virtual STDMETHODIMP SetCascade(BOOL f) { _fCascadeFolder = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetAccelerators(BOOL f) { _fAccelerators = BOOLIFY(f); return S_OK; }; 
    virtual STDMETHODIMP SetNoIcons(BOOL f)   { _fNoIcons = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetNoText(BOOL f)  { _fNoShowText = BOOLIFY(f); return S_OK; };

protected:

    friend HRESULT    CISFBand_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
    friend HRESULT    CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

    CISFBand();
    virtual ~CISFBand();

    void    _ReleaseMenu();
    void    _SetDirty(BOOL fDirty);
    virtual HRESULT _SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMDBPU);
    virtual void _SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);
    virtual HMENU   _GetContextMenu();

    void    _ReleaseMenuPopup(IMenuPopup** ppmp);
    void    _SetCacheMenuPopup(IMenuPopup* pmp);
    HRESULT _DropdownItem(LPCITEMIDLIST pidl, UINT idCmd);

    LRESULT _TryChannelSurfing(LPCITEMIDLIST pidl);
    HRESULT _GetChannelBrowser(IWebBrowser2 **ppwb);
    HRESULT _IStreamFromOrderList(VARIANT* pvarargOut);
    HRESULT _OrderListFromIStream(VARIANT* pvarargIn);

    IMenuPopup *_pmpCache;
    IMenuPopup *    _pmp;               // Submenu popup

    const GUID*     _pguidUEMGroup;


    BITBOOL         _fCascadeFolder :1;
    BITBOOL         _fNoRecalcDefaults :1;// Don't recalc defaults during GetBandInfo
    BITBOOL         _fInitialized :1;   // have we initialized the toolbar
    BITBOOL         _fDebossed :1;      // TRUE to enable debossed rebar style
    BITBOOL         _fLinksMode :1;     // TRUE: do not allow drag & drop onto content items.
    BITBOOL         _fHaveBkColor :1;    // TRUE if _crBkgnd is valid
    BITBOOL         _fHaveColors :1;    // TRUE if _crBtnXX are valid
    BITBOOL         _fFullOpen :1;      // TRUE if band should maximize when opened
    BITBOOL         _fClosing : 1;      // TRUE if we are shutting down....
    BITBOOL         _fDesktop :1;       // 1:desktop 0:browser(or non-ActDesk)
    BITBOOL         _fBtnMinSize :1;    // TRUE if band should report min thickness of button
    BITBOOL         _fDelayPainting :1;
    BITBOOL         _fChannels :1;      // TRUE if we want "Navigate Target" sup
    BITBOOL         _fCreatedBandProxy :1; // TRUE if we created a BandProxy ourself and hence need to call SetOwner on it
    BITBOOL         _fAllowDropdown: 1;
    BITBOOL         _fDelayInit :1;
    BOOL            _fIgnoreAddToFront;
    
    int             _eUemLog :2;        // UEMIND_* (NIL:off, o.w.:group)
    int             _iIdealLength;      // our ideal height/width last time bandsite asked
    
    COLORREF        _crBkgnd;           // Background color (must set _fHaveBkColor)
    COLORREF        _crBtnLt;           // Button hilite color (must set _fHaveColors)
    COLORREF        _crBtnDk;           // Button lolite color (must set _fHaveColors)

    DWORD _dwPriv; // private for bsmenu
    IBandProxy      * _pbp;

    HPALETTE _hpalOld;          // the old palette saved while we do a draw.....

    int _GetIdealSize(PSIZE psize);

    HRESULT _IsPidlVisible(LPITEMIDLIST pidl);

    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferredEffect);
    
    virtual HRESULT _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);

    virtual int _GetBitmap(int iCommandID, PIBDATA pibData, BOOL fUseCache);
    virtual void _ToolbarChanged() { _BandInfoChanged(); };

    BOOL _IsChildID(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlChild);

    BOOL _UpdateIconSize(UINT fIconSize, BOOL fUpdateButtons);
    void _UpdateVerticalMode(BOOL fVertical);

    LRESULT _TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd);
    LRESULT _TrySimpleInvoke(LPCITEMIDLIST pidl);

    virtual HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);

    virtual void _Initialize();

    friend class CExtractImageTask;
    friend HRESULT CALLBACK UpdateBandLogo( LPVOID pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );


    // stuff for CLogoBase
    virtual IShellFolder * GetSF();
    virtual HWND GetHWND();
    virtual REFTASKOWNERID GetTOID();
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );
    
    void _StopDelayPainting();
    void _FixupAppDataDirectory();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\legacy.h ===
#ifndef __LEGACY_H__
#define __LEGACY_H__

#include "logo.h"

#define CGID_MenuBand CLSID_MenuBand
#define CGID_ISFBand  CLSID_ISFBand
#define SID_SDropBlocker CLSID_SearchBand


// REARCHITECT: An exercise for the reader, how many of these are unused now?
#define MBANDCID_GETFONTS       1       // Command Id for getting font info
#define MBANDCID_RECAPTURE      2       // Take the mouse capture back
#define MBANDCID_NOTAREALSITE   3       // This is not a real site
#define MBANDCID_SELECTITEM     5       // Select an item
#define MBANDCID_POPUPITEM      6       // Popup an item
#define MBANDCID_ITEMDROPPED    7       // Item was dropped into a menu
#define MBANDCID_DRAGENTER      8       // Entering a drag operation
#define MBANDCID_DRAGLEAVE      9       // Leaving a Drag operation
#define MBANDCID_ISVERTICAL     10      // Is this a vertical band
#define MBANDCID_RESTRICT_CM    11      // Disallow ContextMenu
#define MBANDCID_RESTRICT_DND   12      // Disallow Drag And Drop
#define MBANDCID_EXITMENU       13      // Nofity: Exiting Menu
#define MBANDCID_ENTERMENU      14      // Notify: Entering Menu
#define MBANDCID_SETACCTITLE    15      // Sets the title of the band
#define MBANDCID_SETICONSIZE    16
#define MBANDCID_SETFONTS       17
#define MBANDCID_SETSTATEOBJECT 18      // Sets the global state
#define MBANDCID_ISINSUBMENU    19      // Returns S_OK if in submenu, S_FALSE if not.
#define MBANDCID_EXPAND         20      // Cause this band to expand
#define MBANDCID_KEYBOARD       21      // Popuped up because of a keyboard action
#define MBANDCID_DRAGCANCEL     22      // Close menus because of drag
#define MBANDCID_REPOSITION     23      // 
#define MBANDCID_EXECUTE        24      // sent to the site when somethis is executed.
#define MBANDCID_ISTRACKING     25      // Tracking a Context Menu

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);

class CISFBand;
HRESULT CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef enum {
    ISFBID_PRIVATEID        = 1,
    ISFBID_ISITEMVISIBLE    = 2,
    ISFBID_CACHEPOPUP       = 3,
    ISFBID_GETORDERSTREAM   = 4,
    ISFBID_SETORDERSTREAM   = 5,
} ISFBID_FLAGS;

HRESULT CLogoExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

extern long g_lMenuPopupTimeout;

#define QLCMD_SINGLELINE 1

#define CITIDM_VIEWTOOLS     4      // This toggles on/off
#define CITIDM_VIEWADDRESS   5      // This toggles on/off
#define CITIDM_VIEWLINKS     6      // This toggles on/off
#define CITIDM_SHOWTOOLS     7      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWADDRESS   8      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWLINKS     9      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_EDITPAGE      10
#define CITIDM_BRANDSIZE     11     // brand at minimum always or not
#define CITIDM_VIEWMENU      12      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_VIEWAUTOHIDE  13      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_GETMINROWHEIGHT 14    // gets the minimum height of row 0... for branding
#define CITIDM_SHOWMENU      15
#define CITIDM_STATUSCHANGED 16
#define CITIDM_GETDEFAULTBRANDCOLOR 17
#define CITIDM_DISABLESHOWMENU      18
#define CITIDM_SET_DIRTYBIT         19  // nCmdexecopt equals TRUE or FALSE which will overwrite _fDirty.
#define CITIDM_VIEWTOOLBARCUSTOMIZE       20
#define CITIDM_VIEWEXTERNALBAND_BYCLASSID 21
#define CITIDM_DISABLEVISIBILITYSAVE 22 // bands can choose not to persist their visibility state
#define CITIDM_GETFOLDERSEARCHES        26


#define TOOLBAR_MASK 0x80000000

#endif // __LEGACY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menubar.h ===
#ifndef _menubar_h
#define _menubar_h


#ifdef __cplusplus

#include "basebar.h"

IMenuPopup* CreateMenuPopup(IMenuPopup *pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* CreateMenuPopup2(IMenuPopup *pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);
HRESULT ShowBandInBandSite(IUnknown* punkBS, IUnknown* punkDB);


class CMenuDeskBar : 
        public CBaseBar
        ,public IMenuPopup
        ,public IObjectWithSite
        ,public IBanneredBar
        ,public IInitializeObject
{
public:    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CBaseBar::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CBaseBar::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return CBaseBar::GetWindow(lphwnd); };
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return CBaseBar::ContextSensitiveHelp(fEnterMode); };

    // *** IDeskBar methods ***
    STDMETHODIMP SetClient(IUnknown* punk) { return CBaseBar::SetClient(punk); };
    STDMETHODIMP GetClient(IUnknown** ppunkClient) { return CBaseBar::GetClient(ppunkClient); };
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return CBaseBar::OnPosRectChangeDB(prc); };

    // *** IInputObjectSite methods (override) ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown * pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IBanneredBar methods ***
    virtual STDMETHODIMP SetIconSize(DWORD iIcon);
    virtual STDMETHODIMP GetIconSize(DWORD* piIcon)
        { ASSERT(piIcon); *piIcon = _iIconSize; return NOERROR;};
    virtual STDMETHODIMP SetBitmap(HBITMAP hBitmap);
    virtual STDMETHODIMP GetBitmap(HBITMAP* phBitmap)
        { ASSERT(phBitmap); *phBitmap = _hbmp; return NOERROR;};

    // *** IInitializeObject methods ***
    // This is for Backwards compatility with Start Menu.
    STDMETHODIMP Initialize() { return NOERROR; }


    CMenuDeskBar();

    
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void _OnCreate();
    virtual void _OnSize();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();
 
    void    _AllowMessageThrough(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _GetPopupWindowPosition(RECT* rcDesired, RECT* rcExclude, RECT *prcResult, SIZE * psizeEdge, UINT uside); 
    void    _PopDown();
    BOOL    _IsMyParent(HWND hwnd);  
    IMenuPopup* _GetMenuBarParent(IUnknown* punk);
    UINT    _GetSide() { return _uSide;};
    HRESULT _PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags);
    LRESULT _DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags);
    void _DoNCPaint(HWND hwnd, HDC hdc);
    void _SelectItem(BOOL bFirst);
    void AdjustForTheme();

    virtual ~CMenuDeskBar();
            
    POINT   _pt;
    IMenuPopup* _pmpParent;
    IMenuPopup* _pmpChild;
    IUnknown* _punkSite;
    UINT    _uSide;


    HBITMAP _hbmp;
    DWORD   _iIconSize;
    SIZE    _sizeBmp;
    COLORREF    _rgb;

    BITBOOL _fActive: 1;

    RECT    _rcExclude;
    BITBOOL _fExcludeRect: 1;  // TRUE: _rcExclude contains valid 
    BITBOOL _fExpanded: 1;
    BITBOOL _fFlatMenuMode: 1;
    BOOL    _fNoBorder;
};

HRESULT TrackShellMenu(HWND hwnd, LPRECT prc, IShellMenu* psm, DWORD dwFlags);

#endif // __cplusplus
#endif // _menubar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menuband.cpp ===
#include "shellprv.h"
#define WANT_SHLWAPI_POSTSPLIT
#include <shlwapi.h>

#include "common.h"
#include "initguid.h"
#include "menuband.h"
#include "bands.h"
#include "isfband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "oleacc.h"
#include "apithk.h"
#include "uemapp.h"
#include "mnbase.h"
#include "mnfolder.h"
#include "mnstatic.h"
#include "iaccess.h"
#include "util.h"
#include "tbmenu.h"

// NOTE: Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define PF_USINGNTSD    0x00000400      // set this if you're debugging on ntsd

// This must be reset to -1 on any WM_WININICHANGE.  We do it in
// shbrows2.cpp, but if there are no browser windows open when the
// metric changes, we end up running around with a stale value.  Oh well.
long g_lMenuPopupTimeout = -1;

// {AD35F50A-0CC0-11d3-AE2D-00C04F8EEA99}
static const CLSID CLSID_MenuBandMetrics =
{ 0xad35f50a, 0xcc0, 0x11d3, { 0xae, 0x2d, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99
} };

// Registered window messages for the menuband
UINT    g_nMBPopupOpen = 0;
UINT    g_nMBFullCancel = 0;
UINT    g_nMBDragCancel = 0;
UINT    g_nMBAutomation = 0;
UINT    g_nMBExecute = 0;
UINT    g_nMBOpenChevronMenu = 0;
HCURSOR g_hCursorArrow = NULL;
//UINT    g_nMBIgnoreNextDeselect = 0;  // Dealt with in menuisf.cpp

BOOL IsAncestor(HWND hwndChild, HWND hwndAncestor)
{
    HWND hwnd = hwndChild;
    while (hwnd != hwndAncestor && hwnd != NULL)
    {
        hwnd = GetParent(hwnd);
    } 

    return hwndAncestor == hwnd;
}

//=================================================================
// Implementation of menuband message filter
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);


// Just one of these, b/c we only need one message filter
CMBMsgFilter g_msgfilter = { 0 };     

static DWORD g_tlsMessageFilter = -1;

CMBMsgFilter* GetMessageFilter()
{
    CMBMsgFilter* pmf = NULL;

    if (g_tlsMessageFilter == -1)
    {
        DWORD tls = TlsAlloc();
        if (tls != -1)
        {
            InterlockedExchange((LONG*)&g_tlsMessageFilter, tls);
            if (tls != g_tlsMessageFilter)
            {
                TlsFree(tls);
            }
        }
    }

    if (g_tlsMessageFilter != -1)
    {
        pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == NULL)
        {
            pmf = new CMBMsgFilter;
            if (pmf)
            {
                pmf->_fAllocated = TRUE;
                TlsSetValue(g_tlsMessageFilter, pmf);
            }
        }
    }

    if (pmf == NULL)
        pmf = &g_msgfilter;

    return pmf;
}

void FreeMessageFilter(CMBMsgFilter* that)
{
    if (g_tlsMessageFilter != -1)
    {
        CMBMsgFilter* pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == that)
        {
            TlsSetValue(g_tlsMessageFilter, NULL);
        }
    }
}

void CMBMsgFilter::AddRef()
{
    _cRef++;

}

void CMBMsgFilter::Release()
{
    _cRef--;
    if (_cRef <= 0 && _fAllocated)
    {
        FreeMessageFilter(this);
        delete this;
    }
}

void CMBMsgFilter::SetModal(BOOL fModal)
{
    // There was an interesting problem:
    //   Click on the Chevron menu. Right click Delete. 
    //   The menus were hosed
    // Why?
    //   Well, I'll tell you:
    //   We got a deactivate on the subclassed window. We have
    //   2 menus subclassing it: The Main menu, and the modal
    //   chevron menu. Problem is, the main menu snagged the WM_ACTIVATE
    //   and does a set context. This causes a Pop and releases the Message hook.
    //   Since I still had a menu up, this caused havoc.
    //   So I introduced a concept of a "Modal" menuband. 
    //   This says: "Ignore any request to change contexts until I'm done". When
    //   that modal band is done, it sets the old context back in.
    //   Seems like a hack, but we need a better underlying archtecture for
    //   the message passing.
    _fModal = fModal;
}

void CMBMsgFilter::ReEngage(void* pvContext)      
{ 
    // We need to make sure that we don't dis/reengage when 
    // switching contexts
    if (pvContext == _pvContext)
        _fEngaged = TRUE; 
}

void CMBMsgFilter::DisEngage(void* pvContext)     
{ 
    if (pvContext == _pvContext)
        _fEngaged = FALSE;
}

CMenuBand * CMBMsgFilter::_GetTopPtr(void)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, cItems-1, MBELEM); 
        pmb = pmbelem->pmb;
    }
    return pmb;
}

CMenuBand * CMBMsgFilter::_GetBottomMostSelected(void)
{
    // Ick, I can't believe I just did this. Mix COM and C++ identities... Yuck.
    CMenuBand* pmb = NULL;
    if (_pmb)
    {
        IUnknown_QueryService(SAFECAST(_pmb, IMenuBand*), SID_SMenuBandBottomSelected, CLSID_MenuBand, (void**)&pmb);

        // Since we have the C++ identity, release the COM identity.
        if (pmb)
            pmb->Release();
    }

    return pmb;
}


CMenuBand * CMBMsgFilter::_GetWindowOwnerPtr(HWND hwnd)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.
        int i;

        for (i = 0; i < cItems; i++)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 
            if (pmbelem->pmb && S_OK == pmbelem->pmb->IsWindowOwner(hwnd))
            {
                pmb = pmbelem->pmb;
                break;
            }
        }
    }
    return pmb;
}


/*----------------------------------------------------------
Purpose: Return menuband or NULL based upon hittest.  pt must be 
         in screen coords
*/
CMenuBand * CMBMsgFilter::_HitTest(POINT pt, HWND * phwnd)
{ 
    CMenuBand * pmb = NULL;
    HWND hwnd = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.  Work backwards since the
        // later bands are on top (z-order), if the menus ever overlap.
        int i = cItems - 1;

        while (0 <= i)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 

            RECT rc;

            // Do this dynamically because the hwndBar hasn't been positioned
            // until after this mbelem has been pushed onto the msg filter stack.
            GetWindowRect(pmbelem->hwndBar, &rc);
            
            if (PtInRect(&rc, pt))
            {
                pmb = pmbelem->pmb;
                hwnd = pmbelem->hwndTB;
                break;
            }
            i--;
        }
    }

    if (phwnd)
        *phwnd = hwnd;

    return pmb;
}


void CMBMsgFilter::RetakeCapture(void)
{
    // The TrackPopupMenu submenus can steal the capture.  Take
    // it back.  Don't take it back if the we're in edit mode,
    // because the modal drag/drop loop has the capture at that
    // point.
    // We do not want to take capture unless we are engaged. 
    // We need to do this because we are not handling mouse messages lower down
    // in the code. When we set the capture, the messages that we do not handle
    // trickle up to the top level menu, and can cause weird problems (Such
    // as signaling a "click out of bounds" or a context menu of the ITBar)
    if (_hwndCapture && !_fPreventCapture && _fEngaged)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Setting capture to %#lx", _hwndCapture);
        SetCapture(_hwndCapture);
    }
}    

void CMBMsgFilter::SetHook(BOOL fSet, BOOL fDontIgnoreSysChar)
{
    if (fDontIgnoreSysChar)
        _iSysCharStack += fSet? 1: -1;

    if (NULL == _hhookMsg && fSet)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Initialize");
        _hhookMsg = SetWindowsHookEx(WH_GETMESSAGE, GetMsgHook, HINST_THISDLL, GetCurrentThreadId());
        _fDontIgnoreSysChar = fDontIgnoreSysChar;
    }
    else if (!fSet && _iSysCharStack == 0)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Hook removed");
        if (_hhookMsg)
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }
    }
}

// 1) Set Deskbars on Both Monitors and set to chevron
// 2) On Monitor #2 open a chevron
// 3) On Monitor #1 open a chevron then open the Start Menu
// Result: Start Menu does not work.

// The reason is, we set the _fModal of the global message filter. This prevents context switches. Why? 
// The modal flag was invented to solve context switching problems with the browser frame. So what causes this?
// Well, when switching from #2 to #3, we have not switched contexts. But since we got a click out of bounds, we collapse
// the previous menu. When switching from #3 to #4, neither have the context, so things get messy.

void CMBMsgFilter::ForceModalCollapse()
{
    if (_fModal)
    {
        _fModal = FALSE;
        SetContext(NULL, TRUE);
    }
}

void CMBMsgFilter::SetContext(void* pvContext, BOOL fSet)
{
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::SetContext from 0x%x to 0x%x", _pvContext, pvContext);
    // When changing a menuband context, we need to pop all of the items
    // in the stack. This is to prevent a race condition that can occur.

    // We do not want to pop all of the items off the stack if we're setting the same context.
    // We do a set context on Activation, Both when we switch from one Browser frame to another
    // but also when right clicking or causing the Rename dialog to be displayed.

    BOOL fPop = FALSE;

    if (_fModal)
        return;

    // Are we setting a new context?
    if (fSet)
    {
        // Is this different than the one we've got?
        if (pvContext != _pvContext)
        {
            // Yes, then we need to pop off all of the old items.
            fPop = TRUE;
        }

        _pvContext = pvContext;
    }
    else
    {
        // Then we are trying to unset the message hook. Make sure it still belongs to
        // this context
        if (pvContext == _pvContext)
        {
            // This context is trying to unset itself, and no other context owns it.
            // remove all the old items.
            fPop = TRUE;
        }
    }

    if (fPop)
    {
        CMenuBand* pcmb = _GetTopPtr();
        if (pcmb)
        {
            PostMessage(pcmb->_pmbState->GetSubclassedHWND(), g_nMBFullCancel, 0, 0);
            // No release.

            if (FDSA_GetItemCount(&_fdsa) != 0)
            {
                CMBMsgFilter* pmf = GetMessageFilter();
                while (pmf->Pop(pvContext))
                    ;
            }
        }
    }
}




/*----------------------------------------------------------
Purpose: Push another menuband onto the message filter's stack

*/
void CMBMsgFilter::Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite)
{
    ASSERT(IS_VALID_CODE_PTR(pmb, CMenuBand));
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::Push called from context 0x%x", pvContext);

    if (pmb && pvContext == _pvContext)
    {
        BOOL bRet = TRUE;
        HWND hwndBand;

        pmb->GetWindow(&hwndBand);

        // If the bar isn't available use the band window
        HWND hwndBar = hwndBand;
        IOleWindow * pow;

        IUnknown_QueryService(punkSite, SID_SMenuPopup, IID_PPV_ARG(IOleWindow, &pow));
        if (pow)
        {
            pow->GetWindow(&hwndBar);
            pow->Release();
        }

        if (NULL == _hhookMsg)
        {
            // We want to ignore the WM_SYSCHAR message in the message filter because
            // we are using the IsMenuMessage call instead of the global message hook.
            SetHook(TRUE, FALSE);
            TraceMsg(TF_MENUBAND, "CMBMsgFilter::push Setting hook from context 0x%x", pvContext);
            _fSetAtPush = TRUE;
        }

        if (!_fInitialized)
        {
            ASSERT(NULL == _hwndCapture);
            _hwndCapture = hwndBar;

            _fInitialized = TRUE;

            bRet = FDSA_Initialize(sizeof(MBELEM), CMBELEM_GROW, &_fdsa, _rgmbelem, CMBELEM_INIT);

            // We need to initialize this for the top level guy so that we have the correct positioning
            // from the start of this new set of bands. This is used to eliminate spurious WM_MOUSEMOVE
            // messages which cause problems. See _HandleMouseMessages for more information
            AcquireMouseLocation();
        }

        if (EVAL(bRet))
        {
            MBELEM mbelem = {0};
            
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Push (pmp:%#08lx) onto stack", SAFECAST(pmb, IMenuPopup *));
            pmb->AddRef();

            mbelem.pmb = pmb;
            mbelem.hwndTB = hwndBand;
            mbelem.hwndBar = hwndBar;

            FDSA_AppendItem(&_fdsa, &mbelem);

            CMenuBand* pmbTop = _GetTopPtr();

            if ((pmbTop && (pmbTop->GetFlags() & SMINIT_LEGACYMENU)) || NULL == GetCapture())
                RetakeCapture();
        }
        else
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
            _hwndCapture = NULL;
        }
    }
}    


/*----------------------------------------------------------
Purpose: Pop a menuband off the message filter stack

         Returns the number of bands left on the stack
*/
int CMBMsgFilter::Pop(void* pvContext)
{
    int nRet = 0;

    TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop called from context 0x%x", pvContext);

    // This can be called from a context switch or when we're exiting menu mode,
    // so we'll switch off the fact that we clear _hhookMsg when we pop the top twice.
    if (pvContext == _pvContext && _hhookMsg)
    {
        int iItem = FDSA_GetItemCount(&_fdsa) - 1;
        MBELEM * pmbelem;

        ASSERT(0 <= iItem);

        pmbelem = FDSA_GetItemPtr(&_fdsa, iItem, MBELEM);
        if (EVAL(pmbelem->pmb))
        {
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Pop (pmb=%#08lx) off stack", SAFECAST(pmbelem->pmb, IMenuPopup *));
            pmbelem->pmb->Release();
            pmbelem->pmb = NULL;
        }
        FDSA_DeleteItem(&_fdsa, iItem);

        if (0 == iItem)
        {

            TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop removing hook from context 0x%x", pvContext);
            if (_fSetAtPush)
                SetHook(FALSE, FALSE);

            PreventCapture(FALSE);
            _fInitialized = FALSE;

            if (_hwndCapture && GetCapture() == _hwndCapture)
            {
                TraceMsg(TF_MENUBAND, "CMBMsgFilter: Releasing capture");
                ReleaseCapture();
            }
            _hwndCapture = NULL;
        }
        nRet = iItem;
  
        
    }
    return nRet;
}    


LRESULT CMBMsgFilter::_HandleMouseMsgs(MSG * pmsg, BOOL bRemove)
{
    LRESULT lRet = 0;
    CMenuBand * pmb;
    HWND hwnd = GetCapture();

    // Do we still have the capture?
    if (hwnd != _hwndCapture)
    {
        // No; is it b/c a CTrackPopupBar has it?
        if (NULL == hwnd)
        {
            // There are times that we must retake the capture because
            // TrackPopupMenuEx has taken it, or some context menu
            // might have taken it, so take it back.
            RetakeCapture();
            TraceMsg(TF_WARNING, "CMBMsgFilter: taking the capture back");
        }
    }
    else
    {
        // Yes; decide what to do with it
        POINT pt;
        HWND hwndPt;
        MSG msgT;

        pt.x = GET_X_LPARAM(pmsg->lParam);
        pt.y = GET_Y_LPARAM(pmsg->lParam);
        ClientToScreen(pmsg->hwnd, &pt);

        if (WM_MOUSEMOVE == pmsg->message)
        {
            // The mouse cursor can send repeated WM_MOUSEMOVE messages
            // with the same coordinates.  When the user tries to navigate
            // thru the menus with the keyboard, and the mouse cursor
            // happens to be over a menu item, these spurious mouse 
            // messages cause us to think the menu has been invoked under
            // the mouse cursor.  
            //
            // To avoid this unpleasant rudeness, we eat any gratuitous
            // WM_MOUSEMOVE messages.
            if (_ptLastMove.x == pt.x && _ptLastMove.y == pt.y)
            {
                pmsg->message = WM_NULL;
                goto Bail;
            }

            // Since this is not a duplicate point, we need to keep it around. 
            // We will use this stored point for the above comparison

            // msadek; W2k bug# 426005
            // On a mirrored system, we got a system bug as mouse coordinates has an off-by-one
            // This makes comparing the value with what we got from GetCursorPos() always fail.
            // Do not use AcquireMouseLocation().

            if(!IS_WINDOW_RTL_MIRRORED(pmsg->hwnd))
            {
                AcquireMouseLocation();
            }
            else
            {
                _ptLastMove.x = pt.x;
                _ptLastMove.y = pt.y;                
            }
            

            if (_hcurArrow == NULL)
                _hcurArrow = LoadCursor(NULL, IDC_ARROW);

            if (GetCursor() != _hcurArrow)
                SetCursor(_hcurArrow);

        }

        // Use a stack variable b/c we don't want to confuse USER32
        // by changing the coords of the real message.
        msgT = *pmsg;
        msgT.lParam = MAKELPARAM(pt.x, pt.y);

        pmb = _HitTest(pt, &hwndPt);

        if (_TopFilterMouseMessage(&msgT, bRemove, pmb) == S_OK)
        {
            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        else if (pmb)
        {
            // Forward mouse message onto appropriate menuband.  Note
            // the appropriate menuband's GetMsgFilterCB (below) will call
            // ScreenToClient to convert the coords correctly.

            lRet = pmb->GetMsgFilterCB(&msgT, bRemove);

            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        // Debug note: to debug menubands on ntsd, set the prototype
        // flag accordingly.  This will keep menubands from going
        // away the moment the focus changes to the NTSD window.

        else if ((WM_LBUTTONDOWN == pmsg->message || WM_RBUTTONDOWN == pmsg->message) &&
            !(g_dwPrototype & PF_USINGNTSD))
        {
            // Mouse down happened outside the menu.  Bail.
            pmb = _GetTopPtr();
            if (EVAL(pmb))
            {
                msgT.hwnd = pmsg->hwnd;
                msgT.message = g_nMBFullCancel;
                msgT.wParam = 0;
                msgT.lParam = 0;

                TraceMsg(TF_MENUBAND, "CMBMsgFilter (pmb=%#08lx): hittest outside, bailing", SAFECAST(pmb, IMenuPopup *));
                pmb->GetMsgFilterCB(&msgT, bRemove);
            }
        }
        else
        {
            pmb = _GetTopPtr();
            if (pmb)
            {
                IUnknown_QueryServiceExec(SAFECAST(pmb, IOleCommandTarget*), SID_SMenuBandBottom, 
                    &CGID_MenuBand, MBANDCID_SELECTITEM, MBSI_NONE, NULL, NULL);
            }
        }
    }

Bail:
    return lRet;    
}    

HRESULT CMBMsgFilter::_TopFilterMouseMessage(MSG *pmsg, BOOL bRemove, CMenuBand *pmbTarget)
{
    CMenuBand *pmb = _GetTopPtr();
    if (pmb && pmb->_psmcb)
    {
        // This is a high-frequency message so we handle the callback
        // ourselves.  (_CallCB will allocate memory.)
        SMDATA smd = {0};
        if (pmbTarget)
        {
            smd.punk = SAFECAST(pmbTarget, IShellMenu*);
            smd.uIdParent = pmbTarget->_uId;
            smd.uIdAncestor = pmbTarget->_uIdAncestor;
            smd.hwnd = pmbTarget->_hwnd;
            smd.hmenu = pmbTarget->_hmenu;
            smd.pvUserData = pmbTarget->_pvUserData;
        }
        return pmb->_psmcb->CallbackSM(&smd, SMC_MOUSEFILTER, bRemove, (LPARAM)pmsg);
    }
    return S_FALSE; // not handled
}

/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while the menuband is "active".  
         
         The menuband can't steal the focus away -- we use this
         hook to catch messages.

*/
LRESULT CMBMsgFilter::GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;
    BOOL bRemove = (PM_REMOVE == wParam);
    CMBMsgFilter* pmf = GetMessageFilter();


    // The global message filter may be in a state when we are not processing messages,
    // but the menubands are still displayed. A situation where this will occur is when
    // a dialog box is displayed because of an interaction with the menus.

    // Are we engaged? (Are we allowed to process messages?)
    if (pmf->_fEngaged)
    {
        if (WM_SYSCHAR == pmsg->message)
        {
            // _fDontIgnoreSysChar is set when the Menubands ONLY want to know about
            // WM_SYSCHAR and nothing else.
            if (pmf->_fDontIgnoreSysChar)
            {
                CMenuBand * pmb = pmf->GetTopMostPtr();
                if (pmb)
                    lRet =  pmb->GetMsgFilterCB(pmsg, bRemove);
            }
        }
        else if (pmf->_fInitialized) // Only filter if we are initalized (have items on the stack)
        {
            switch (nCode)
            {
            case HC_ACTION:
#ifdef DEBUG
                if (g_dwDumpFlags & DF_GETMSGHOOK)
                    DumpMsg(TEXT("GetMsg"), pmsg);
#endif

                // A lesson about GetMsgHook: it gets the same message
                // multiple times for as long as someone calls PeekMessage
                // with the PM_NOREMOVE flag.  So we want to take action 
                // only when PM_REMOVE is set (so we don't handle more than
                // once).  If we modify any messages to redirect them (on a
                // regular basis), we must modify all the time so we don't 
                // confuse the app.

                // Messages get redirected to different bands in the stack
                // in this way:
                //
                //  1) Keyboard messages go to the currently open submenu 
                //     (topmost on the stack).  
                //
                //  2) The PopupOpen message goes to the hwnd that belongs 
                //     to the menu band (via IsWindowOwner).
                //

                switch (pmsg->message)
                {
                case WM_SYSKEYDOWN:
                case WM_KEYDOWN:
                case WM_CHAR:
                case WM_KEYUP:
                case WM_CLOSE:          // only this message filter gets WM_CLOSE
                    {
                        // There is a situation that can occur when the last selected
                        // menu pane is NOT the bottom most pane.
                        // We need to see if that last selected guy is tracking a context
                        // menu so that we forward the messages correctly.
                        CMenuBand * pmb = pmf->_GetBottomMostSelected();
                        if (pmb)
                        {
                            // Is it tracking a context menu?
                            if (S_OK == IUnknown_Exec(SAFECAST(pmb, IMenuBand*), &CGID_MenuBand, 
                                MBANDCID_ISTRACKING, 0, NULL, NULL))
                            {
                                // Yes, forward for proper handling.
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                            }
                            else
                            {
                                // No; Then do the default processing. This can happen if there is no
                                // context menu, but there is a selected parent and not a selected child.
                                goto TopHandler;
                            }
                        }
                        else
                        {
                    TopHandler:
                            pmb = pmf->_GetTopPtr();
                            if (pmb)
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                        }
                    }
                    break;

                case WM_NULL:
                    // Handle this here (we do nothing) to avoid mistaking this for
                    // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
                    // RegisterWindowMessage fails.
                    break;

                default:
                    if (bRemove && IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
                    {
                        lRet = pmf->_HandleMouseMsgs(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBPopupOpen)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                            lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBExecute)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                        {
                            VARIANT var;
                            var.vt = VT_UINT_PTR;
                            var.ullVal = (UINT_PTR)pmsg->hwnd;
                            pmb->Exec(&CGID_MenuBand, MBANDCID_EXECUTE, (DWORD)pmsg->wParam, &var, NULL);
                        }
                    }

                    break;
                }
                break;

            default:
                if (0 > nCode)
                    return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);
                break;
            }
        }
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);

    return 0;       // Always return 0
}    

//=================================================================
// Implementation of CMenuBand
//=================================================================

// Struct used by EXEC with a MBANDCID_GETFONTS to return fonts
typedef struct tagMBANDFONTS
{
    HFONT hFontMenu;    // [out]    TopLevelMenuBand's menu font
    HFONT hFontArrow;   // [out]    TopLevelMenuBand's font for drawing the cascade arrow
    int   cyArrow;      // [out]    Height of TopLevelMenuBand's cascade arrow
    int   cxArrow;      // [out]    Width of TopLevelMenuBand's cascade arrow
    int   cxMargin;     // [out]    Margin b/t text and arrow
} MBANDFONTS;

#define THISCLASS CMenuBand
#define SUPERCLASS CToolBand

#ifdef DEBUG
int g_nMenuLevel = 0;

#define DBG_THIS    _nMenuLevel, SAFECAST(this, IMenuPopup *)
#else
#define DBG_THIS    0, 0
#endif


CMenuBand::CMenuBand() :
    SUPERCLASS()
{
    GetMessageFilter()->AddRef();
    _fCanFocus = TRUE;

    _fAppActive = TRUE;

    _nItemNew = -1;
    _nItemCur = -1;
    _nItemTimer = -1;
    _uIconSize = ISFBVIEWMODE_SMALLICONS;
    _uIdAncestor = ANCESTORDEFAULT;
    _nItemSubMenu = -1;
}


// The purpose of this method is to finish initializing Menubands, 
// since it can be initialized in many ways. 

HRESULT CMenuBand::_Initialize(DWORD dwFlags)
{
    _fVertical = !BOOLIFY(dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(dwFlags & SMINIT_TOPLEVEL);

    _dwFlags = dwFlags;

    // We cannot have a horizontal menu if it is not the toplevel menu
    ASSERT(!_fVertical && _fTopLevel || _fVertical);

    HRESULT hr = S_OK;

    if (_fTopLevel)
    {
        if (!g_nMBPopupOpen) 
        {
            g_nMBPopupOpen  = RegisterWindowMessage(TEXT("CMBPopupOpen"));
            g_nMBFullCancel = RegisterWindowMessage(TEXT("CMBFullCancel"));
            g_nMBDragCancel = RegisterWindowMessage(TEXT("CMBDragCancel"));
            g_nMBAutomation = RegisterWindowMessage(TEXT("CMBAutomation"));
            g_nMBExecute    = RegisterWindowMessage(TEXT("CMBExecute"));
            g_nMBOpenChevronMenu = RegisterWindowMessage(TEXT("CMBOpenChevronMenu"));

            g_hCursorArrow = LoadCursor(NULL, IDC_ARROW);
            TraceMsg(TF_MENUBAND, "CMBPopupOpen message = %#lx", g_nMBPopupOpen);
            TraceMsg(TF_MENUBAND, "CMBFullCancel message = %#lx", g_nMBFullCancel);
        }

        if (!_pmbState)
            _pmbState = new CMenuBandState;

        if (!_pmbm)
            _pmbm = new CMenuBandMetrics();

        if (!_pmbState || !_pmbm)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    DEBUG_CODE( _nMenuLevel = -1; )

    return hr;
}


CMenuBand::~CMenuBand()
{
    CMBMsgFilter* pmf = GetMessageFilter();
    // the message filter does not have a ref'd pointer to us!!!
    if (pmf->GetTopMostPtr() == this)
        pmf->SetTopMost(NULL);

    _CallCB(SMC_DESTROY);
    ATOMICRELEASE(_psmcb);

    // Cleanup
    CloseDW(0);

    if (_pmtbMenu)
        delete _pmtbMenu;

    if (_pmtbShellFolder)
        delete _pmtbShellFolder;

    Str_SetPtr(&_pszTheme, NULL);
   
    ASSERT(_punkSite == NULL);
    ATOMICRELEASE(_pmpTrackPopup);

    ATOMICRELEASE(_pmbm);

    if (_fTopLevel)
    {
        if (_pmbState)
            delete _pmbState;
    }

    GetMessageFilter()->Release();
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
HRESULT CMenuBand_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;
    CMenuBand *pObj = new CMenuBand();
    if (pObj) 
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hr;
}

void CMenuBand::_UpdateButtons()
{
    if (_pmtbMenu) 
        _pmtbMenu->v_UpdateButtons(FALSE);
    if (_pmtbShellFolder)
        _pmtbShellFolder->v_UpdateButtons(FALSE);

    _fForceButtonUpdate = FALSE;
}

HRESULT CMenuBand::ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Given a change notify from the ShellFolder child, we will forward that notify to each of our
    // sub menus, but only if they have a shell folder child.

    HRESULT hres = E_FAIL;
    BOOL fDone = FALSE;
    CMenuToolbarBase* pmtb = _pmtbBottom;   // Start With the bottom toolbar. This is
                                            // is an optimization because typically
                                            // menus that have both a Shell Folder portion
                                            // and a static portion have the majority
                                            // of the change activity in the bottom portion.

    // This can be NULL on a shutdown, when we're deregistering change notifies
    if (pmtb && pmtb->_hwndMB)
    {
        HWND hwnd = pmtb->_hwndMB;


        for (int iButton = 0; !fDone; iButton++)
        {
            IShellChangeNotify* ptscn;

            int idCmd = GetButtonCmd(hwnd, iButton);

            // If it's not a seperator, see if there is a sub menu with a shell folder child.
            if (idCmd != -1 &&
                SUCCEEDED(pmtb->v_GetSubMenu(idCmd, &SID_MenuShellFolder, IID_PPV_ARG(IShellChangeNotify, &ptscn))))
            {
                IShellMenu* psm;
                // Don't forward this notify if the sub menu has specifically registered for change notify (By not passing
                // DontRegisterChangeNotify.
                if (SUCCEEDED(ptscn->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
                {
                    UINT uIdParent = 0;
                    DWORD dwFlags = 0;
                    // Get the flags
                    psm->GetShellFolder(&dwFlags, NULL, IID_NULL, NULL);
                    psm->GetMenuInfo(NULL, &uIdParent, NULL, NULL);

                    // If this menupane is an "Optimized" pane, (meaning that we don't register for change notify
                    // and forward from a top level menu down) then we want to forward. We also
                    // forward if this is a child of Menu Folder. If it is a child,
                    // then it also does not register for change notify, but does not explicitly set it in it's flags
                    // (review: Should we set it in it's flags?)
                    // If it is not an optimized pane, then don't forward.
                    if ((dwFlags & SMSET_DONTREGISTERCHANGENOTIFY) ||
                        uIdParent == MNFOLDER_IS_PARENT)
                    {
                        // There is!, then pass to the child the change.
                        hres = ptscn->OnChange(lEvent, pidl1, pidl2);

                        // Update Dir on a Recursive change notify forces us to update everyone... Good thing
                        // this does not happen alot and is caused by user interaction most of the time.
                    }
                    psm->Release();
                }

                ptscn->Release();
            }

            // Did we go through all of the buttons on this toolbar?
            if (iButton >= ToolBar_ButtonCount(hwnd) - 1)
            {
                // Yes, then we need to switch to the next toolbar.
                if (_pmtbTop != _pmtbBottom && pmtb != _pmtbTop)
                {
                    pmtb = _pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    iButton = -1;       // -1 because at the end of the loop the for loop will increment.
                }
                else
                {
                    // No; Then we must be done.
                    fDone = TRUE;
                }
            }
        }
    }
    else
        hres = S_OK;        // Return success because we're shutting down.

    return hres;
}

// Resize the parent menubar
VOID CMenuBand::ResizeMenuBar()
{
    // If we're not shown, then we do not need to do any kind of resize.
    // NOTE: Horizontal menubands are always shown. Don't do any of the 
    // vertical stuff if we're horizontal.
    if (!_fShow)
        return;

    // If we're horizontal, don't do any Vertical sizing stuff.
    if (!_fVertical)
    {
        // BandInfoChanged is only for Horizontal Menubands.
        _BandInfoChanged();
        return;
    }

    // We need to update the buttons before a resize so that the band is the right size.
    _UpdateButtons();

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_RESIZE, 0, NULL, NULL);
}


STDMETHODIMP CMenuBand::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        // Do not need IOleWindow (base class for IDeskBar)
        // because CToolBand::IDeskBand::IDockingWindow::IOleWindow
        // handles it.
        QITABENT(CMenuBand, IDeskBar),      // Base class for IMenuPopup
        QITABENT(CMenuBand, IMenuPopup),
        QITABENT(CMenuBand, IMenuBand),
        QITABENT(CMenuBand, IShellMenu),
        QITABENT(CMenuBand, IShellMenu2),
        QITABENT(CMenuBand, IWinEventHandler),
        QITABENT(CMenuBand, IShellMenuAcc),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    if (FAILED(hres) && IsEqualGUID(riid, CLSID_MenuBand)) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuBand::QueryService(REFGUID guidService,
                                     REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_SMenuPopup) || 
        IsEqualIID(guidService, SID_SMenuBandChild) || 
        IsEqualIID(guidService, SID_SMenuBandParent) || 
        (_fTopLevel && IsEqualIID(guidService, SID_SMenuBandTop)))
    {
        if (IsEqualIID(riid, IID_IAccessible) || IsEqualIID(riid, IID_IDispatch))
        {
            hr = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(SAFECAST(this, IMenuBand*));

            if (pacc)
            {
                hr = pacc->InitAcc();
                if (SUCCEEDED(hr))
                {
                    hr = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }
        }
        else
            hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected))
    {
        // SID_SMenuBandBottom queries down
        BOOL fLookingForSelected = IsEqualIID(SID_SMenuBandBottomSelected, guidService);

        // Are we the leaf node?
        if (!_fInSubMenu)
        {
            if ( fLookingForSelected && 
                (_pmtbTracked == NULL ||
                 ToolBar_GetHotItem(_pmtbTracked->_hwndMB) == -1))
            {
                hr = E_FAIL;
            }
            else
            {
                hr = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
        else 
        {
            // No; QS down...

            IMenuPopup* pmp = _pmpSubMenu;
            if (_pmpTrackPopup)
                pmp = _pmpTrackPopup;
            
            ASSERT(pmp);
            hr = IUnknown_QueryService(pmp, guidService, riid, ppvObj);
            if (FAILED(hr) && fLookingForSelected && _pmtbTracked != NULL)
            {
                hr = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
    }
    else if (IsEqualIID(guidService, SID_MenuShellFolder))
    {
        // This is a method of some other menu in the scheme to get to specifically the MenuShellfolder,
        // This is for the COM Identity property.
        if (_pmtbShellFolder)
            hr = _pmtbShellFolder->QueryInterface(riid, ppvObj);
    }
    else
        hr = SUPERCLASS::QueryService(guidService, riid, ppvObj);

    return hr;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

*/
STDMETHODIMP CMenuBand::IsWindowOwner(HWND hwnd)
{
    if (( _pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) ) ||
        (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK)))
        return S_OK;
    return S_FALSE;
}

#define MB_EICH_FLAGS (EICH_SSAVETASKBAR | EICH_SWINDOWMETRICS | EICH_SPOLICY | EICH_SSHELLMENU | EICH_KWINPOLICY)

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
STDMETHODIMP  CMenuBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = NOERROR;

    EnterModeless();

    // Could our metrics be changing?  (We keep track of this only for the 
    // toplevel menu)
    BOOL fProcessSettingChange = FALSE;

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        fProcessSettingChange = !lParam || 
                                (SHIsExplorerIniChange(wParam, lParam) & MB_EICH_FLAGS) ||
                                wParam == SPI_SETDROPSHADOW ||
                                wParam == SPI_SETFLATMENU;
        break;

    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        fProcessSettingChange = TRUE;
        break;
    }

    if (_fTopLevel && 
        fProcessSettingChange && 
        _pmbState && !_pmbState->IsProcessingChangeNotify())
    {

        // There is a race condition that can occur during a refresh 
        // that's really nasty. It causes another one to get pumped in the
        // middle of processing this one, Yuck!
        _pmbState->PushChangeNotify();
        // There is a race condiction that can occur when the menuband is created,
        // but not yet initialized. This has been hit by the IEAK group....
        if (_pmtbTop)
        {
            // Yes; create a new metrics object and tell the submenus
            // about it.

            CMenuBandMetrics* pmbm = new CMenuBandMetrics();

            if (pmbm)
            {
                ATOMICRELEASE(_pmbm);
                _pmbm = pmbm;
                _pmbm->Init(_pmtbTop->_hwndMB);
                
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);

                _CallCB(SMC_REFRESH, wParam, lParam);

                // We need to force a button update at some point so that the new sizes are calculated
                // Setting this flag will cause the buttons to be updatted before the next time it 
                // is shown. If, however, the menu is currently displayed, then the ResizeMenuBar will
                // recalculate immediatly.
                
                _fForceButtonUpdate = TRUE;
                RECT rcOld;
                RECT rcNew;

                // Resize the MenuBar
                GetClientRect(_hwndParent, &rcOld);
                ResizeMenuBar();
                GetClientRect(_hwndParent, &rcNew);

                // If the rect sizes haven't changed, then we need to re-layout the
                // band because the button widths may have changed.
                if (EqualRect(&rcOld, &rcNew) && _fVertical)
                    _pmtbTop->NegotiateSize();
            }
        }

        if (_pmtbMenu)
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        _pmbState->PopChangeNotify();
    }
    else
    {
        if (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    ExitModeless();

    return hres;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow method

*/
STDMETHODIMP CMenuBand::GetWindow(HWND * phwnd)
{
    if (_pmtbMenu)
    {
        *phwnd = _pmtbMenu->_hwndMB;
        return NOERROR;
    }
    else if (_pmtbShellFolder)
    {
        *phwnd = _pmtbShellFolder->_hwndMB;
        return NOERROR;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}    


/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp method

*/
STDMETHODIMP CMenuBand::ContextSensitiveHelp(BOOL bEnterMode)
{
    return SUPERCLASS::ContextSensitiveHelp(bEnterMode);
}    


/*----------------------------------------------------------
Purpose: Handle WM_CHAR for accelerators

         This is handled for any vertical menu.  Since we have
         two toolbars (potentially), this function determines
         which toolbar gets the message depending on the 
         accelerator.

*/
HRESULT CMenuBand::_HandleAccelerators(MSG * pmsg)
{
    TCHAR ch = (TCHAR)pmsg->wParam;
    HWND hwndTop = _pmtbTop->_hwndMB;
    HWND hwndBottom = _pmtbBottom->_hwndMB;

    // Here's how this works: the menu can have one or two toolbars.
    // 
    // One toolbar: we simply forward the message onto the toolbar 
    // and let it handle any potential accelerators.
    //
    // Two toolbars: get the count of accelerators that match the
    // given char for each toolbar.  If only one toolbar has at
    // least one match, forward the message onto that toolbar.
    // Otherwise, forward the message onto the currently tracked
    // toolbar and let it negotiate which accelerator button to
    // choose (we might get a TBN_WRAPHOTITEM).
    //
    // If no match occurs, we beep.  Beep beep.
    //

    if (!_pmtbTracked)
        SetTracked(_pmtbTop);

    ASSERT(_pmtbTracked);

    if (_pmtbTop != _pmtbBottom)
    {
        int iNumBottomAccel;
        int iNumTopAccel;

        // Tell the dup handler not to handle this one....
        _fProcessingDup = TRUE;

        ToolBar_HasAccelerator(hwndTop, ch, &iNumTopAccel);
        ToolBar_HasAccelerator(hwndBottom, ch, &iNumBottomAccel);

        BOOL bBottom = (0 < iNumBottomAccel);
        BOOL bTop = (0 < iNumTopAccel);

        // Does one or the other (but not both) have an accelerator?
        if (bBottom ^ bTop)
        {
            // Yes; do the work here for that specific toolbar
            HWND hwnd = bBottom ? hwndBottom : hwndTop;
            int cAccel = bBottom ? iNumBottomAccel : iNumTopAccel;
            int idCmd;

            pmsg->message = WM_NULL;    // no need to forward the message

            // This should never really fail since we just checked
            EVAL( ToolBar_MapAccelerator(hwnd, ch, &idCmd) );

            DWORD dwFlags = HICF_ACCELERATOR | HICF_RESELECT;

            if (cAccel == 1)
                dwFlags |= HICF_TOGGLEDROPDOWN;

            int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
            ToolBar_SetHotItem2(hwnd, iPos, dwFlags);
        }
        // No; were there no accelerators?
        else if ( !bTop )
        {
            // Yes
            if (_fVertical)
            {
                MessageBeep(MB_OK);
            }
            else
            {
                _CancelMode(MPOS_FULLCANCEL);
            }
        }
        // Else allow the message to go to the top toolbar

        _fProcessingDup = FALSE;
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: Callback for the get message filter.  We handle the
         keyboard messages here (rather than IInputObject::
         TranslateAcceleratorIO) so that we can redirect the
         message *and* have the message pump still call
         TranslateMessage to generate WM_CHAR and WM_SYSCHAR
         messages.

*/
LRESULT CMenuBand::GetMsgFilterCB(MSG * pmsg, BOOL bRemove)
{
    // (See the note in CMBMsgFilter::GetMsgHook about bRemove.)

    if (bRemove && !_fVertical && (pmsg->message == g_nMBPopupOpen) && _pmtbTracked)
    {
        // Menu is being popped open, send a WM_MENUSELECT equivalent.
        _pmtbTracked->v_SendMenuNotification((UINT)pmsg->wParam, FALSE);
    }

    if (_fTopLevel &&                           // Only do this for the top level
        _dwFlags & SMINIT_USEMESSAGEFILTER &&   // They want to use the message filter 
                                                // instead of IsMenuMessage
        bRemove &&                              // Only do this if we're removing it.
        WM_SYSCHAR == pmsg->message)            // We only care about WM_SYSCHAR
    {
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //
        if (_OnSysChar(pmsg, TRUE) == S_OK)
        {
            pmsg->message = WM_NULL;
        }
    }

    // If a user menu is up, then we do not want to intercept those messages. Intercepting
    // messages intended for the poped up user menu causes havoc with keyboard accessibility.
    // We also don't want to process messages if we're displaying a sub menu (It should be
    // handling them).

    BOOL fTracking = FALSE;
    if (_pmtbMenu)
        fTracking = _pmtbMenu->v_TrackingSubContextMenu();

    if (_pmtbShellFolder && !fTracking)
        fTracking = _pmtbShellFolder->v_TrackingSubContextMenu();


    if (!_fInSubMenu && !fTracking)    
    {
        // We don't process these messages when we're in a (modal) submenu

        switch (pmsg->message)
        {
        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:
            if (bRemove && 
                (VK_ESCAPE == pmsg->wParam || VK_MENU == pmsg->wParam))
            {
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received Esc in msg filter", DBG_THIS);

                DWORD dwSelect = (VK_ESCAPE == pmsg->wParam) ? MPOS_CANCELLEVEL : MPOS_FULLCANCEL;

                _CancelMode(dwSelect);

                pmsg->message = WM_NULL;
                return 1;
            }
            // Fall thru

        case WM_CHAR:
            // Hitting the spacebar should invoke the system menu
            if (!_fVertical && 
                WM_CHAR == pmsg->message && TEXT(' ') == (TCHAR)pmsg->wParam)
            {
                // We need to leave this modal loop before bringing
                // up the system menu (otherwise the user would need to 
                // hit Alt twice to get out.)  Post the message.
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Leaving menu mode for system menu", DBG_THIS);

                UIActivateIO(FALSE, NULL);

                // Say the Alt-key is down to catch DefWindowProc's attention
                pmsg->lParam |= 0x20000000;   
                pmsg->message = WM_SYSCHAR;

                // Use the parent of the toolbar, because toolbar does not
                // forward WM_SYSCHAR onto DefWindowProc.
                pmsg->hwnd = GetParent(_pmtbTop->_hwndMB);
                return 1;
            }
            else if (_fVertical && WM_CHAR == pmsg->message &&
                pmsg->wParam != VK_RETURN)
            {
                // We do not want to pass VK_RETURN to _HandleAccelerators
                // because it will try to do a character match. When it fails
                // it will beep. Then we pass the VK_RETURN to the tracked toolbar
                // and it executes the command.

                // Handle accelerators here
                _HandleAccelerators(pmsg);
            }
            // Fall thru

        case WM_KEYUP:
            // Collection point for most key messages...

            if (NULL == _pmtbTracked)
            {
                // Normally we default to the top toolbar, unless that toolbar
                // cannot receive the selection (As is the case on the top level
                // start menu where the fast items are (Empty).                

                // Can the top toolbar be cycled into?
                if (_pmtbTop && !_pmtbTop->DontShowEmpty())
                {
                    // Yes;
                    SetTracked(_pmtbTop);      // default to the top toolbar
                }
                else
                {
                    // No; Set the tracked to the bottom, and hope that he can....
                    SetTracked(_pmtbBottom);
                }
            }

            // F10 has special meaning for menus. 
            //  - F10 alone, should toggle the selection of the first item 
            //      in a horizontal menu
            //  - Shift-F10 should display a context menu.

            if (VK_F10 == pmsg->wParam)
            {
                // Is this the Shift-F10 Case?
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    // Yes. We need to force this message into a context menu
                    // message.
                    pmsg->message = WM_CONTEXTMENU;
                    pmsg->lParam = -1;
                    pmsg->wParam = (WPARAM)_pmtbTracked->_hwndMB;
                    return 0;
                }
                else if (!_fVertical)   //No; Then we need to toggle in the horizontal case
                {
                    if (_pmtbMenu)
                    {
                        // Set the hot item to the first one.
                        int iHot = 0;
                        if (ToolBar_GetHotItem(_pmtbMenu->_hwndMB) != -1)
                            iHot = -1;  // We're toggling the selection off.
                        ToolBar_SetHotItem(_pmtbMenu->_hwndMB, iHot);
                    }
                    return 0;
                }
            }
                
            // Redirect to the toolbar
            if (_pmtbTracked)
                pmsg->hwnd = _pmtbTracked->_hwndMB;
            return 0;

        case WM_NULL:
            // Handle this here (we do nothing) to avoid mistaking this for
            // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
            // RegisterWindowMessage fails.
            return 0;

        default:
            // We used to handle g_nMBPopupOpen here.  But we can't because calling TrackPopupMenu
            // (via CTrackPopupBar::Popup) w/in a GetMessageFilter is very bad.
            break;
        }
    }

    if (bRemove)
    {
        // These messages must be processed even when no submenu is open
        switch (pmsg->message)
        {
        case WM_CLOSE:
            // Being deactivated.  Bail out of menus.
            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): sending MPOS_FULLCANCEL", DBG_THIS);

            _CancelMode(MPOS_FULLCANCEL);
            break;

        default:
            if (IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
            {
                // If we move the mouse, collapse the tip. Careful not to blow away a balloon tip...
                if (_pmbState)
                    _pmbState->HideTooltip(FALSE);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                if (_pmtbMenu)
                    _pmtbMenu->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                // Don't let the message be dispatched now that we've
                // forwarded it.
                pmsg->message = WM_NULL;
            }
            else if (pmsg->message == g_nMBFullCancel)
            {
                // Popup 
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private full cancel message", DBG_THIS);

                _SubMenuOnSelect(MPOS_CANCELLEVEL);
                _CancelMode(MPOS_FULLCANCEL);
                return 1;
            }
            break;
        }
    }
    
    return 0;    
}    


/*----------------------------------------------------------
Purpose: Handle WM_SYSCHAR

         This is handled for the toplevel menu only.

*/
HRESULT CMenuBand::_OnSysChar(MSG * pmsg, BOOL bFirstDibs)
{
    TCHAR ch = (TCHAR)pmsg->wParam;

    // HACKHACK (scotth): I'm only doing all this checking because I don't
    // understand why the doc-obj case sometimes (and sometimes doesn't) 
    // intercept this in its message filter.
    
    if (!bFirstDibs && _fSysCharHandled)
    {
        _fSysCharHandled = FALSE;
        return S_FALSE;
    }
    
    if (TEXT(' ') == (TCHAR)pmsg->wParam)
    {
        _fAltSpace = TRUE;  // In the words of Spock..."Remember"
        // start menu alt+space
        TraceMsg(DM_MISC, "cmb._osc: alt+space _fTopLevel(1)");
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
    }
    else if (!_fInSubMenu)
    {
        int idBtn;

        ASSERT(_fTopLevel);

        // There is a brief instant when we're merging a menu and pumping messages
        // This results in a null _pmtbMenu.
        if (_pmtbMenu)
        {
            // Only a toplevel menubar follows this codepath.  This means only
            // the static menu toolbar will exist (and not the shellfolder toolbar).
            _pmtbTracked = _pmtbMenu;

            HWND hwnd = _pmtbTracked->_hwndMB;
            if (ToolBar_MapAccelerator(hwnd, ch, &idBtn))
            {
                // Post a message since we're already in a menu loop
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): WM_SYSCHAR: Posting CMBPopup message", DBG_THIS);
                UIActivateIO(TRUE, NULL);
                _pmtbTracked->PostPopup(idBtn, TRUE, TRUE);
                // browser menu alt+key, start menu alt+key
                TraceMsg(DM_MISC, "cmb._osc: alt+key _fTopLevel(1)");
                UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
                return S_OK;
            }
        }
    }

    // Set or reset
    _fSysCharHandled = bFirstDibs ? TRUE : FALSE;
    
    return S_FALSE;
}

HRESULT CMenuBand::_ProcessMenuPaneMessages(MSG* pmsg)
{
    if (pmsg->message == g_nMBPopupOpen)
    {
        // Popup the submenu.  Since the top-level menuband receives this first, the
        // command must be piped down the chain to the bottom-most menuband.
        IOleCommandTarget * poct;
    
        QueryService(SID_SMenuBandBottom, IID_PPV_ARG(IOleCommandTarget, &poct));

        if (poct)
        {
            BOOL bSetItem = LOWORD(pmsg->lParam);
            BOOL bInitialSelect = HIWORD(pmsg->lParam);
            VARIANTARG vargIn;

            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private popup menu message", DBG_THIS);

            DWORD dwOpt = 0;

            vargIn.vt = VT_I4;
            vargIn.lVal = (LONG)pmsg->wParam;
        
            if (bSetItem)
                dwOpt |= MBPUI_SETITEM;

            if (bInitialSelect)
                dwOpt |= MBPUI_INITIALSELECT;
            
            poct->Exec(&CGID_MenuBand, MBANDCID_POPUPITEM, dwOpt, &vargIn, NULL);
            poct->Release();
            return S_OK;
        }
    }
    else if (pmsg->message == g_nMBDragCancel)
    {
        // If we got a drag cancel, make sure that the bottom most
        // menu does not have the drag enter.
        IUnknown_QueryServiceExec(SAFECAST(this, IOleCommandTarget*), 
            SID_SMenuBandBottom, &CGID_MenuBand, MBANDCID_DRAGCANCEL, 0, NULL, NULL);
        return S_OK;
    }
    else if (pmsg->message == g_nMBOpenChevronMenu)
    {

        VARIANTARG v;
        v.vt = VT_I4;
        v.lVal = (LONG)pmsg->wParam;

        IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
    }
    else if (pmsg->message == g_nMBFullCancel)
    {
        _SubMenuOnSelect(MPOS_CANCELLEVEL);
        _CancelMode(MPOS_FULLCANCEL);
        return S_OK;
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::IsMenuMessage method

         The thread's message pump calls this function to see if any
         messages need to be redirected to the menu band.

         This returns S_OK if the message is handled.  The
         message pump should not pass it onto TranslateMessage
         or DispatchMessage if it does.

*/
STDMETHODIMP CMenuBand::IsMenuMessage(MSG * pmsg)
{
    HRESULT hres = S_FALSE;

    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::IsMM"), pmsg);
#endif
    if (!_fShow)
        goto Return;

    switch (pmsg->message)
    {
    case WM_SYSKEYDOWN:
        // blow this off if it's a repeated keystroke
        if (!(pmsg->lParam & 0x40000000))
        {
            SendMessage(_hwndParent, WM_CHANGEUISTATE ,MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);

            // Are we pressing the Alt key to activate the menu?
            if (!_fMenuMode && pmsg->wParam == VK_MENU && _pmbState)
            {
                // Yes; The the menu was activated because of a keyboard,
                // Set the global state to show the keyboard cues.
                _pmbState->SetKeyboardCue(TRUE);

                // Since this only happens on the top level menu,
                // We only have to tell the "Top" menu to update it's state.
                _pmtbTop->SetKeyboardCue();
            }
        }
        break;

    case WM_SYSKEYUP:
        // If we're in menu mode, ignore this message. 
        // 
        if (_fMenuMode)
            hres = S_OK;
        break;

    case WM_SYSCHAR:
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //

        // Outlook Express needs a message hook in order to filter this 
        // message for perf we do not use that method.

        // Athena fix 222185 (lamadio) We also don't want to do this if we are not active! 
        // otherwise when WAB is on top of OE, we'll steal it's messages

        // (lamadio): If the Message filter is "engaged", then we can process accelerators.
        // Engaged does not mean that the filter is running.
        if (GetMessageFilter()->IsEngaged())
        {
            hres = (_OnSysChar(pmsg, TRUE) == S_OK) ? S_OK : S_FALSE;
        }
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (_fMenuMode)
        {
            // All keystrokes should be handled or eaten by menubands
            // if we're engaged.  We must do this, otherwise hosted 
            // components like mshtml or word will try to handle the 
            // keystroke in CBaseBrowser.

            // Also, don't bother forwarding tabs
            if (VK_TAB != pmsg->wParam)
            {
                // Since we're answer S_OK, dispatch it ourselves.
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
            }

            hres = S_OK;
        }
        break;

    case WM_CONTEXTMENU:
        // Since the start button has the keyboard focus,
        // the start button will handle this. We need to forward this off to the 
        // currently tracked item at the bottom of the chain
        LRESULT lres;
        IWinEventHandler* pweh;

        if (_fMenuMode &&
            SUCCEEDED(QueryService(SID_SMenuBandBottomSelected, IID_PPV_ARG(IWinEventHandler, &pweh))))
        {
            pweh->OnWinEvent(HWND_BROADCAST, pmsg->message, 
                pmsg->wParam, pmsg->lParam, &lres);
            pweh->Release();
            hres = S_OK;
        }
        break;

    default:

        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point

        if (_pmbState->GetSubclassedHWND() == NULL)
            hres = _ProcessMenuPaneMessages(pmsg);
        break;
    }

Return:
    if (!_fMenuMode && hres != S_OK)
        hres = E_FAIL;


    return hres;
}

BOOL HasWindowTopmostOwner(HWND hwnd)
{
    HWND hwndOwner = hwnd;
    while (hwndOwner = GetWindowOwner(hwndOwner))
    {
        if (GetWindowLong(hwndOwner, GWL_EXSTYLE) & WS_EX_TOPMOST)
            return TRUE;
    }

    return FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::TranslateMenuMessage method

         The main app's window proc calls this so the menuband
         catches messages that are dispatched from a different
         message pump (than the thread's main pump).
         
         Translates messages specially for menubands.  Some messages
         are processed while the menuband is active.  Others are only
         processed when it is not.  Messages that are not b/t
         WM_KEYFIRST and WM_KEYLAST are handled here (the browser
         does not send these messages to IInputObject::
         TranslateAcceleratorIO).


Returns: S_OK if message is processed

*/
STDMETHODIMP CMenuBand::TranslateMenuMessage(MSG * pmsg, LRESULT * plRet)
{
    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::TMM"), pmsg);
#endif

    switch (pmsg->message)
    {
    case WM_SYSCHAR:
        // In certain doc-obj situations, the OLE message filter (??)
        // grabs this before the main thread's message pump gets a 
        // whack at it.  So we handle it here too, in case we're in
        // this scenario.
        //
        // See the comments in IsMenuMessage regarding this message.
        return _OnSysChar(pmsg, FALSE);

    case WM_INITMENUPOPUP:
        // Normally the LOWORD(lParam) is the index of the menu that 
        // is being popped up.  TrackPopupMenu (which CMenuISF uses) 
        // always sends this message with an index of 0.  This breaks 
        // clients (like DefView) who check this value.  We need to
        // massage this value if we find we're the source of the 
        // WM_INITMENUPOPUP.
        //
        // (This is not in TranslateAcceleratorIO b/c TrackPopupMenu's
        // message pump does not call it.  The wndproc must forward
        // the message to this function for us to get it.)

        if (_fInSubMenu && _pmtbTracked)
        {
            // Massage lParam to use the right index
            int iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, _nItemCur);
            pmsg->lParam = MAKELPARAM(iPos, HIWORD(pmsg->lParam));

            // Return S_FALSE so this message will still be handled
        }
        break;

    case WM_UPDATEUISTATE:
        if (_pmbState)
        {
            // we don't care about UISF_HIDEFOCUS
            if (UISF_HIDEACCEL == HIWORD(pmsg->wParam))
                _pmbState->SetKeyboardCue(UIS_CLEAR == LOWORD(pmsg->wParam) ? TRUE : FALSE);
        }
        break;


    case WM_ACTIVATE:
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            // Debug note: to debug menubands on ntsd, set the prototype
            // flag accordingly.  This will keep menubands from going
            // away the moment the focus changes.

            // Becomming inactive?
            if (WA_INACTIVE == LOWORD(pmsg->wParam))
            {
                // Yes; Free up the global object
                // Athena fix (lamadio) 08.02.1998: Athena uses menubands. Since they
                // have a band per window in one thread, we needed a mechanism to switch
                // between them. So we used the Msgfilter to forward messages. Since there 
                // are multiple windows, we need to set correct one.
                // But, On a deactivate, we need to NULL it out incase a window,
                // running in the same thread, has normal USER menu. We don't want to steal
                // their messages.
                if (pmf->GetTopMostPtr() == this)
                    pmf->SetTopMost(NULL);

                pmf->DisEngage(_pmbState->GetContext());

                HWND hwndLostTo = (HWND)(pmsg->lParam);

                // We won't bail on the menus if we're loosing activation to a child.
                if (!IsAncestor(hwndLostTo, _pmbState->GetWorkerWindow(NULL)))
                {
                    if (_fMenuMode &&
                        !(g_dwPrototype & PF_USINGNTSD) && 
                        !_fDragEntered)
                    {
                        // Being deactivated.  Bail out of menus.  
                        // (Only the toplevel band gets this message.)
                        if (_fInSubMenu)
                        {
                            IMenuPopup* pmp = _pmpSubMenu;
                            if (_pmpTrackPopup)
                                pmp = _pmpTrackPopup;
                            ASSERT(pmp);    // This should be valid. If not, someone messed up.
                            pmp->OnSelect(MPOS_FULLCANCEL);
                        }

                        _CancelMode(MPOS_FULLCANCEL);
                    }
                }
            }
            else if (WA_ACTIVE == LOWORD(pmsg->wParam) || 
                     WA_CLICKACTIVE == LOWORD(pmsg->wParam))
            {
                // If I have activation, the Worker Window needs to be bottom...
                //
                // NOTE: Don't do this if the worker window has a topmost owner
                // (such as the tray).  Setting a window to HWND_NOTOPMOST moves
                // its owner windows to HWND_NOTOPMOST as well, which in this case
                // was breaking the tray's "always on top" feature.
                //
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker) && !_fDragEntered)
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

                // Set the context because when a menu heirarchy becomes active because the
                // subclassed HWND becomes active, we need to reenable the message hook.
                pmf->SetContext(this, TRUE);

                // When we get reactivated, we need to position ourself above the start bar.
                Exec(&CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
            
                // Becomming activated. We need to reengage the message hook so that
                // we get the correct messages.
                pmf->ReEngage(_pmbState->GetContext());

                // Are we in menu mode?
                if (_fMenuMode)
                {
                    // Need to reengage some things.
                    // Take the capture back because we have lost it to context menus or dialogs.
                    pmf->RetakeCapture();

                }
                pmf->SetTopMost(this);
            }

            //
            // Memphis and NT5 grey their horizontal menus when the windows is inactive.
            //
            if (!_fVertical && _pmtbMenu)
            {
                // This needs to stay here because of the above check...
                if (WA_INACTIVE == LOWORD(pmsg->wParam))
                {
                    _fAppActive = FALSE;
                }
                else
                {
                    _fAppActive = TRUE;
                }
                // Reduces flicker by using this instead of an InvalidateWindow/UpdateWindow Pair
                RedrawWindow(_pmtbMenu->_hwndMB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;

    case WM_SYSCOMMAND:
        if ( !_fMenuMode )
        {
            switch (pmsg->wParam & 0xFFF0)
            {
            case SC_KEYMENU:
                // The user either hit the Alt key by itself or Alt-space.
                // If it was Alt-space, let DefWindowProc handle it so the
                // system menu comes up.  Otherwise, we'll handle it to
                // toggle the menuband.

                // Was it Alt-space?
                if (_fAltSpace)
                {
                    // Yes; let it go
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the Alt-space", DBG_THIS);
                    _fAltSpace = FALSE;
                }
                else if (_fShow)
                {
                    // No; activate the menu
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the WM_SYSCOMMAND, SC_KEYMENU", DBG_THIS);

                    UIActivateIO(TRUE, NULL);

                    // We sit in a modal loop here because typically
                    // WM_SYSCOMMAND doesn't return until the menu is finished.
                    //
                    while (_fMenuMode) 
                    {
                        MSG msg;
                        if (GetMessage(&msg, NULL, 0, 0)) 
                        {
                            if ( S_OK != IsMenuMessage(&msg) )
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }

                    *plRet = 0;
                    return S_OK;        // Caller shouldn't handle this
                }
                break;
            }
        }
        break;

    default:
        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point
        if (_pmbState->GetSubclassedHWND() != NULL)
            return _ProcessMenuPaneMessages(pmsg);
        break;


    }
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

         Called by the menusite to host this band.  Since the
         menuband contains two toolbars, we set their parent
         window to be the site's hwnd.

*/
STDMETHODIMP CMenuBand::SetSite(IUnknown* punkSite)
{
    // Do this first because SetParent needs to query to the top level browser for
    // sftbar who queries to the top level browser to get the drag and drop window.
    HRESULT hres = SUPERCLASS::SetSite(punkSite);

    if (_psmcb && _fTopLevel && !(_dwFlags & SMINIT_NOSETSITE))
        IUnknown_SetSite(_psmcb, punkSite);

    IUnknown_GetWindow(punkSite, &_hwndParent);

    // Need this for Closing an expanded vertical menu. Start Menu knows to do this when it's top level,
    // but the Favorites needs to know when it's parent is the horizontal menu.
    VARIANT var = {0};
    if (SUCCEEDED(IUnknown_QueryServiceExec(punkSite, SID_SMenuBandParent, &CGID_MenuBand,
                                       MBANDCID_ISVERTICAL, 0, NULL, &var)) && 
        var.boolVal == VARIANT_FALSE)
    {
        ASSERT(VT_BOOL == var.vt);

        _fParentIsHorizontal = TRUE;
    }

    if (_fNoBorder)
    {
        IUnknown_QueryServiceExec(punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, MBCID_NOBORDER, _fNoBorder, NULL, NULL);
    }


    // Tell the toolbars who their new parent is
    if (_pmtbMenu)
        _pmtbMenu->SetParent(_hwndParent);
    if (_pmtbShellFolder)
        _pmtbShellFolder->SetParent(_hwndParent);

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu::Initialize method

*/
STDMETHODIMP CMenuBand::Initialize(IShellMenuCallback* psmcb, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{
    // Initalized can be called with NULL values to only set some of them.

    // Default to Vertical
    if (!(dwFlags & SMINIT_HORIZONTAL) && !(dwFlags & SMINIT_VERTICAL) && !(dwFlags & SMINIT_MULTICOLUMN))
        dwFlags |= SMINIT_VERTICAL;

    HRESULT hr = _Initialize(dwFlags);
    if (SUCCEEDED(hr))
    {
        DEBUG_CODE( _fInitialized = TRUE; );

        if (uIdAncestor != ANCESTORDEFAULT)
            _uIdAncestor = uIdAncestor;

        if (_uId != -1)
            _uId = uId;

        if (psmcb)
        {
            if (!SHIsSameObject(psmcb, _psmcb))
            {
                if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                    IUnknown_SetSite(_psmcb, NULL);

                ATOMICRELEASE(_psmcb);
                _psmcb = psmcb;
                _psmcb->AddRef();

                // We do not set the site in case this callback is shared between 2 bands (Menubar/Chevron menu)
                if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                    IUnknown_SetSite(_psmcb, _punkSite);

                // Only call this if we're setting a new one. Pass the address of the user associated
                // data section. This is so that the callback can associate data with this pane only
                _CallCB(SMC_CREATE, 0, (LPARAM)&_pvUserData);
            }
        }
    }
    return hr;
}

/*----------------------------------------------------------
Purpose: IShellMenu::GetMenuInfo method

*/
STDMETHODIMP CMenuBand::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags)
{
    if (ppsmc)
    {
        *ppsmc = _psmcb;
        if (_psmcb)
            ((IShellMenuCallback*)*ppsmc)->AddRef();
    }

    if (puId)
        *puId = _uId;

    if (puIdAncestor)
        *puIdAncestor = _uIdAncestor;

    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}


HRESULT CMenuBand::_AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags)
{
    if (_pszTheme)
    {
        pmtb->SetTheme(_pszTheme);
    }

    if (_fNoBorder)
    {
        pmtb->SetNoBorder(_fNoBorder);
    }

    pmtb->SetSite(SAFECAST(this, IMenuBand*));
    HRESULT hr = S_OK;
    if (_hwndParent)
        hr = pmtb->CreateToolbar(_hwndParent);
    
    if (SUCCEEDED(hr))
    {
        // Treat this like a two-element stack, where this function
        // behaves like a "push".  The one additional trick is we 
        // could be pushing onto the top or the bottom of the "stack".

        if (dwFlags & SMSET_BOTTOM)
        {
            if (_pmtbBottom)
            {
                // I don't need to release, because _pmtbTop and _pmtbBottom are aliases for
                // _pmtbShellFolder and _pmtbMenu
                _pmtbTop = _pmtbBottom;
                _pmtbTop->SetToTop(TRUE);
            }

            _pmtbBottom = pmtb;
            _pmtbBottom->SetToTop(FALSE);
        }
        else    // Default to Top...
        {
            if (_pmtbTop)
            {
                _pmtbBottom = _pmtbTop;
                _pmtbBottom->SetToTop(FALSE);
            }

            _pmtbTop = pmtb;
            _pmtbTop->SetToTop(TRUE);
        }

        // _pmtbBottom should never be the only toolbar that exists in the menuband.
        if (!_pmtbTop)
            _pmtbTop = _pmtbBottom;

        // The menuband determines there is a single toolbar by comparing
        // the bottom with the top.  So make the bottom the same if necessary.
        if (!_pmtbBottom)
            _pmtbBottom = _pmtbTop;
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetShellFolder method

*/
STDMETHODIMP CMenuBand::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl,
                                       REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    if (_pmtbShellFolder)
    {
        *pdwFlags = _pmtbShellFolder->GetFlags();

        hres = S_OK;

        if (ppvObj)
        {
            // HACK HACK.  this should QI for a mnfolder specific interface to do this.
            hres = _pmtbShellFolder->GetShellFolder(ppidl, riid, ppvObj);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetShellFolder method

*/
STDMETHODIMP CMenuBand::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags)
{
    ASSERT(_fInitialized);
    HRESULT hr = E_OUTOFMEMORY;

    // If we're processing a change notify, we cannot do anything that will modify state.
    // NOTE: if we don't have a state, we can't possibly processing a change notify
    if (_pmbState && _pmbState->IsProcessingChangeNotify())
        return E_PENDING;

    // Only one shellfolder menu can exist per menuband.  Additionally,
    // a shellfolder menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a static menu).

    // Is there already a shellfolder menu?
    if (_pmtbShellFolder)
    {
        IShellFolderBand* psfb;
        _pmtbShellFolder->QueryInterface(IID_PPV_ARG(IShellFolderBand, &psfb));
        ASSERTMSG(psfb != NULL, "CMenuBand::SetShellFolder should have gotten interface");
        hr = psfb->InitializeSFB(psf, pidlFolder);
        psfb->Release();
        
    }
    else
    {
        _pmtbShellFolder = new CMenuSFToolbar(this, psf, pidlFolder, hKey, dwFlags);
        if (_pmtbShellFolder)
        {
            hr = _AddToolbar(_pmtbShellFolder, dwFlags);
        }
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: IMenuBand::GetMenu method

*/
STDMETHODIMP CMenuBand::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    HRESULT hres = E_FAIL;

    // HACK HACK.  this should QI for a menustatic specific interface to do this.
    if (_pmtbMenu)
        hres = _pmtbMenu->GetMenu(phmenu, phwnd, pdwFlags);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::SetMenu method

*/
STDMETHODIMP CMenuBand::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // Passing a NULL hmenu is valid. It means destroy our menu object.
    ASSERT(_fInitialized);
    HRESULT hr = E_FAIL;

    // Only one static menu can exist per menuband.  Additionally,
    // a static menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a shellfolder menu).

    // Is there already a static menu?
    if (_pmtbMenu)
    {
        // Since we're merging in a new menu, make sure to update the cache...
        _hmenu = hmenu;
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMenu(hmenu, hwnd, dwFlags);
    }
    else
    {
        // This is to work around a problem in the interface definintion: We have
        // no method of setting the Subclassed HWND outside of a SetMenu. So I'm just piggybacking
        // off of this. A better fix would be to introduce IMenuBand2::SetSubclass(HWND). IMenuBand
        // actually implements the "Subclassing", so extending this interface would be worthwhile.
        _hwndMenuOwner = hwnd;

        if (_fTopLevel)
        {
            _pmbState->SetSubclassedHWND(hwnd);
        }

        if (hmenu)
        {
            _hmenu = hmenu;
            _pmtbMenu = new CMenuStaticToolbar(this, hmenu, hwnd, _uId, dwFlags);
            if (_pmtbMenu)
            {
                hr = _AddToolbar(_pmtbMenu, dwFlags);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetMenuToolbar method

*/
STDMETHODIMP CMenuBand::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    CMenuToolbarBase* pmtb;
    if (punk && SUCCEEDED(punk->QueryInterface(CLSID_MenuToolbarBase, (void**)&pmtb)))
    {
        ASSERT(_pmtbShellFolder == NULL);
        _pmtbShellFolder = pmtb;
        hr = _AddToolbar(pmtb, dwFlags);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IShellMenu::InvalidateItem method

*/
STDMETHODIMP CMenuBand::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    // If psmd is NULL, we need to just dump the toolbars and do a full reset.
    if (psmd == NULL)
    {
        // If we're processing a change notify, we cannot do anything that will modify state.
        if (_pmbState && _pmbState->IsProcessingChangeNotify())
            return E_PENDING;

        if (_pmbState)
            _pmbState->PushChangeNotify();

        // Tell the callback we're refreshing so that it can
        // reset any cached state
        _CallCB(SMC_REFRESH);

        // Reinitialize the callback if requested
        if (dwFlags & SMINV_INITMENU)
        {
            _CallCB(SMC_INITMENU);
        }

        _fExpanded = FALSE;

        // We don't need to refill if the caller only wanted to 
        // refresh the sub menus.

        // Refresh the Shell Folder first because
        // It may have no items after it's done, and the
        // menuband may rely on this to add a seperator
        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Refresh();

        // Refresh the Static menu
        if (_pmtbMenu)
            _pmtbMenu->v_Refresh();

        if (_pmpSubMenu)
        {
            _fInSubMenu = FALSE;
            IUnknown_SetSite(_pmpSubMenu, NULL);
            ATOMICRELEASE(_pmpSubMenu);
        }

        if (_pmbState)
            _pmbState->PopChangeNotify();

    }
    else
    {
        if (_pmtbTop)
            hres = _pmtbTop->v_InvalidateItem(psmd, dwFlags);

        // We refresh everything at this level if the psmd is null
        if (_pmtbBottom && hres != S_OK)
            hres = _pmtbBottom->v_InvalidateItem(psmd, dwFlags);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetState method

*/
STDMETHODIMP CMenuBand::GetState(LPSMDATA psmd)
{
    if (_pmtbTracked)
        return _pmtbTracked->v_GetState(-1, psmd);
    // todo: might want to put stuff from _CallCB (below) in here
    return E_FAIL;
}


HRESULT CMenuBand::_CallCB(DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_psmcb)
        return S_FALSE;

    // We don't need to check callback mask here because these are not maskable events.

    SMDATA smd = {0};
    smd.punk = SAFECAST(this, IShellMenu*);
    smd.uIdParent = _uId;
    smd.uIdAncestor = _uIdAncestor;
    smd.hwnd = _hwnd;
    smd.hmenu = _hmenu;
    smd.pvUserData = _pvUserData;
    if (_pmtbShellFolder)
        _pmtbShellFolder->GetShellFolder(&smd.pidlFolder, IID_PPV_ARG(IShellFolder, &smd.psf));
    HRESULT hres = _psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    ILFree(smd.pidlFolder);
    if (smd.psf)
        smd.psf->Release();

    return hres;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         This is called by the base browser only when the menuband
         "has the focus", and only for messages b/t WM_KEYFIRST
         and WM_KEYLAST.  This isn't very useful for menubands.
         See the explanations in GetMsgFilterCB, IsMenuMessage
         and TranslateMenuMessage.

         In addition, menubands cannot ever have the activation,
         so this method should never be called.

         Returns S_OK if handled.
*/
STDMETHODIMP CMenuBand::TranslateAcceleratorIO(LPMSG pmsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

*/
STDMETHODIMP CMenuBand::HasFocusIO()
{
    // We consider a menuband has the focus even if it has submenus
    // that are currently cascaded out.  All menubands in the chain
    // have the focus.
    return _fMenuMode ? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

         The child menubar calls us with its IMenuPopup pointer.
*/
STDMETHODIMP CMenuBand::SetSubMenu(IMenuPopup * pmp, BOOL fSet)
{
    ASSERT(IS_VALID_CODE_PTR(pmp, IMenuPopup));

    if (fSet)
    {
        _fInSubMenu = TRUE;
    }
    else 
    {
        if (_pmtbTracked)
        {
            _pmtbTracked->PopupClose();
        }

        _fInSubMenu = FALSE;
        _nItemSubMenu = -1;
    }

    return S_OK;
}    

HRESULT CMenuBand::_SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    HRESULT hres;
    IMenuPopup * pmpSite;

    hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmpSite));
    if (SUCCEEDED(hres))
    {
        hres = pmpSite->SetSubMenu(pmp, bSet);
        pmpSite->Release();
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Tell the GetMsg filter that this menuband is ready to
         listen to messages.

*/
HRESULT CMenuBand::_EnterMenuMode(void)
{
    ASSERT(!_fMenuMode);        // Must not push onto stack more than once

    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    DEBUG_CODE( _nMenuLevel = g_nMenuLevel++; )

    _fMenuMode = TRUE;
    _fInSubMenu = FALSE;
    _nItemMove = -1;
    _fCascadeAnimate = TRUE;

    _hwndFocusPrev = NULL;

    if (_fTopLevel)
    {
        // REVIEW (scotth): some embedded controls (like the surround
        // video ctl on the carpoint website) have another thread that
        // eats all the messages when the control has the focus.
        // This prevents us from getting any messages once we're in
        // menu mode.  I don't understand why USER menus work yet.
        // One way to work around this bug is to detect this case and
        // set the focus to our main window for the duration.
        
        if (GetWindowThreadProcessId(GetFocus(), NULL) != GetCurrentThreadId())
        {
            IShellBrowser* psb;
            
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
            {
                HWND hwndT;
                
                psb->GetWindow(&hwndT);
                _hwndFocusPrev = SetFocus(hwndT);
                psb->Release();
            }
        }
    
        _hCursorOld = GetCursor();
        SetCursor(g_hCursorArrow);
        HideCaret(NULL);
    }

    _SiteSetSubMenu(this, TRUE);

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        if (!_fVertical && -1 == _nItemNew)
        {
            // The Alt key always highlights the first menu item initially
            SetTracked(_pmtbTop);
            ToolBar_SetHotItem(hwnd, 0);
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTop->_hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(TRUE, 0));
        }

        _pmtbTop->Activate(TRUE);

        // The toolbar usually tracks mouse events.  However, as the mouse
        // moves over submenus, we still want the parent menubar to
        // behave as if it has retained the focus (that is, keep the
        // last selected item highlighted). This also prevents the toolbar
        // from handling WM_MOUSELEAVE messages unnecessarily.
        ToolBar_SetAnchorHighlight(hwnd, TRUE);

        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Entering menu mode", DBG_THIS);
        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPSTART: EVENT_SYSTEM_MENUSTART, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(TRUE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, TRUE); // Turn off anchoring
    }

    GetMessageFilter()->Push(_pmbState->GetContext(), this, _punkSite);

    return S_OK;
}    


void CMenuBand::_ExitMenuMode(void)
{
    _fMenuMode = FALSE;
    _nItemCur = -1;
    _fPopupNewMenu = FALSE;
    _fInitialSelect = FALSE;
    CMBMsgFilter* pmf = GetMessageFilter();

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        ToolBar_SetAnchorHighlight(hwnd, FALSE); // Turn off anchoring
        if (!_fVertical)
        {
            // Use the first item, since we're assuming every menu must have
            // at least one item
            _pmtbTop->v_SendMenuNotification(0, TRUE);
        
            // The user may have clicked outside the menu, which would have
            // cancelled it.  But since we set the ANCHORHIGHLIGHT attribute,
            // the toolbar won't receive a message to cause it to
            // remove the highlight.  So do it explicitly now.
            SetTracked(NULL);
            UpdateWindow(hwnd);
        }

        _pmtbTop->Activate(FALSE);

        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPEND: EVENT_SYSTEM_MENUEND, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(FALSE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, FALSE); // Turn off anchoring
    }

    pmf->Pop(_pmbState->GetContext());

    _SiteSetSubMenu(this, FALSE);

    if (_fTopLevel)
    {
        SetCursor(_hCursorOld);
        ShowCaret(NULL);
        
        pmf->SetContext(this, FALSE);

        // We do this here, because ShowDW(FALSE) does not get called on the
        // top level menu band. This resets the state, so that the accelerators 
        // are not shown.
        if (_pmbState)
            _pmbState->SetKeyboardCue(FALSE);

        // Tell the menus to update their state to the current global cue state.
        if (_pmtbTop)
            _pmtbTop->SetKeyboardCue();

        if (_pmtbTop != _pmtbBottom && _pmtbBottom)
            _pmtbBottom->SetKeyboardCue();

    }

    if (_hwndFocusPrev)
        SetFocus(_hwndFocusPrev);

    if (_fTopLevel)
    {
        //
        // The top-level menu has gone away.  Win32 focus and ui-activation don't
        // actually change when this happens, so the browser and focused dude have
        // no idea that something happened and won't generate any AA event.  So, we
        // do it here for them.  Note that if there was a selection inside the focused
        // dude, we'll lose it.  This is the best we can do for now, as we don't
        // currently have a way to tell the focused/ui-active guy (who knows about the
        // current selection) to reannounce focus.
        //
        HWND hwndFocus = GetFocus();
        NotifyWinEvent(EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, CHILDID_SELF);
    }
        
    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Exited menu mode", DBG_THIS);
    DEBUG_CODE( g_nMenuLevel--; )
    DEBUG_CODE( _nMenuLevel = -1; )
    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
}    


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO

         Menubands CANNOT take the activation.  Normally
         a band would return S_OK and call the site's 
         OnFocusChangeIS method, so that its TranslateAcceleratorIO
         method would receive keyboard messages.

         However, menus are different.  The window/toolbar that
         currently has the activation must retain that activation
         when the menu pops down.  Because of this, menubands use 
         a GetMessage filter to intercept messages.

*/
STDMETHODIMP CMenuBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (lpMsg != NULL)
    {
        // don't allow TAB to band (or any other 'non-explicit' activation).
        // (if we just cared about TAB we'd check IsVK_TABCycler).
        // all kinds of badness would result if we did.
        // the band can't take focus (see above), so it can't obey the
        // UIAct/OnFocChg rules (e.g. can't call OnFocusChangeIS), so
        // our basic activation-tracking assumptions would be broken.
        return S_FALSE;
    }

    if (fActivate)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);
        
        if (!_fMenuMode)
        {
            _EnterMenuMode();

            // The toplevel menuband does not set the real activation.  
            // But the children do, so activation can be communicated
            // with the parent menuband.
            if (_fVertical)
            {
                IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
            }
            else
            {
                IUnknown_Exec(_punkSite, &CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
            }
        }

        if (_fPopupNewMenu)
        {
            _nItemCur = _nItemNew;
            ASSERT(-1 != _nItemCur);
            ASSERT(_pmtbTracked);

            _fPopupNewMenu = FALSE;
            _nItemNew = -1;

            // Popup a menu
            hres = _pmtbTracked->PopupOpen(_nItemCur);
            if (FAILED(hres))
            {
                // Don't fail the activation
                TraceMsg(TF_ERROR, "%d (pmb=%#08lx): PopupOpen failed", DBG_THIS);
                MessageBeep(MB_OK);
            }
            else if (S_FALSE == hres)
            {
                // The submenu was modal and is finished now
                _ExitMenuMode();
            }
        }
    }
    else if (_fMenuMode)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);

        ASSERT( !_fInSubMenu );

        if (!_fTopLevel)
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);

        _ExitMenuMode();
    }

    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/
HRESULT CMenuBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    HRESULT hres = NOERROR;

    _dwBandID = dwBandID;           // critical for perf! (BandInfoChanged)

    pdbi->dwMask &= ~DBIM_TITLE;    // no title (ever, for now)

    // We expect that _pmtbBottom should never be the only toolbar
    // that exists in the menuband.
    ASSERT(NULL == _pmtbBottom || _pmtbTop);

    pdbi->dwModeFlags = DBIMF_USECHEVRON;

    if (_pmtbTop)
    {
        // If the buttons need to be updated in the toolbars, the we should 
        // do this before we start asking them about their sizes....
        if (_fForceButtonUpdate)
        {
            _UpdateButtons();
        }

        if (_fVertical) 
        {
            pdbi->ptMaxSize.y = 0;
            pdbi->ptMaxSize.x = 0;

            SIZE size = {0};
        
            if (_pmtbMenu)
            {
                // size param zero here => it's just an out param
                _pmtbMenu->GetSize(&size);

                // HACKHACK (lamadio): On downlevel, LARGE metrics mode causes 
                // Start menu to push the programs menu item off screen.
                if (size.cy > (3 * GetSystemMetrics(SM_CYSCREEN) / 4))
                {
                    Exec(&CGID_MenuBand, MBANDCID_SETICONSIZE, ISFBVIEWMODE_SMALLICONS, NULL, NULL);
                    size.cx = 0;
                    size.cy = 0;
                    _pmtbMenu->GetSize(&size);
                }

                pdbi->ptMaxSize.y = size.cy;
                pdbi->ptMaxSize.x = size.cx;
            }
            if (_pmtbShellFolder)
            {
                // size param should be non-zero here => it's an in/out param
                _pmtbShellFolder->GetSize(&size);
                pdbi->ptMaxSize.y += size.cy + ((_pmtbMenu && !_fExpanded)? 1 : 0);   // Minor sizing problem
                pdbi->ptMaxSize.x = max(size.cx, pdbi->ptMaxSize.x);
            }

            pdbi->ptMinSize = pdbi->ptMaxSize;

        }
        else
        {
            HWND hwnd = _pmtbTop->_hwndMB;
            ShowDW(TRUE);

            SIZE rgSize;
            if ( SendMessage( hwnd, TB_GETMAXSIZE, 0, (LPARAM) &rgSize ))
            {
                pdbi->ptActual.y = rgSize.cy;
                SendMessage(hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&pdbi->ptActual);
            }

            // make our min size identical to the size of the first button
            // (we're assuming that the toolbar has at least one button)
            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, 0, (WPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
    }
    return hres;
}

/*----------------------------------------------------------
Purpose: IOleService::Exec method

*/
STDMETHODIMP CMenuBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdExecOpt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{

    // Don't do anything if we're closing.
    if (_fClosing)
        return E_FAIL;

    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case MBCID_GETSIDE:
            if (pvarargOut) 
            {
                BOOL fOurChoice = FALSE;
                pvarargOut->vt = VT_I4;
                
                if (!_fTopLevel) 
                {
                    // if we are not the top level menu, we 
                    // must continue with the direction our parent was in
                    IMenuPopup* pmpParent;
                    IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmpParent));
                    if (pmpParent) 
                    {
                        if (FAILED(IUnknown_Exec(pmpParent, pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut)))
                            fOurChoice = TRUE;
                        pmpParent->Release();
                    }
                } else 
                    fOurChoice = TRUE;

                if (!fOurChoice)
                {
                    // only use the parent's side hint if it is in the same orientation (ie, horizontal menubar to vertical popup 
                    // means we need to make a new choice)
                    BOOL fParentVertical = (pvarargOut->lVal == MENUBAR_RIGHT || pvarargOut->lVal == MENUBAR_LEFT);
                    if (BOOLIFY(_fVertical) != BOOLIFY(fParentVertical))
                        fOurChoice = TRUE;
                }

                if (fOurChoice) 
                {
                    if (_fVertical)
                    {
                        HWND hWndMenuBand;

                        //
                        // The MenuBand is Mirrored , then start the first Menu Window
                        // as Mirrored. [samera]
                        //
                        if ((SUCCEEDED(GetWindow(&hWndMenuBand))) &&
                            (IS_WINDOW_RTL_MIRRORED(hWndMenuBand)) ) 
                            pvarargOut->lVal = MENUBAR_LEFT;
                        else
                            pvarargOut->lVal = MENUBAR_RIGHT;
                    }
                    else
                        pvarargOut->lVal = MENUBAR_BOTTOM;
                }

            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_GETFONTS:
            if (pvarargOut)
            {
                if (EVAL(_pmbm))
                {
                    // this is not marshal-safe, but we're inproc
                    pvarargOut->vt = VT_UNKNOWN;
                    _pmbm->QueryInterface(IID_PPV_ARG(IUnknown, &pvarargOut->punkVal));
                    return S_OK;
                }
                else
                    return E_FAIL;
            }
            else
                return E_INVALIDARG;
            break;

        case MBANDCID_SETFONTS:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal)
            {
                // this is not marshal-safe, but we're inproc
                ATOMICRELEASE(_pmbm);
                pvarargIn->punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);

                _fForceButtonUpdate = TRUE;
                // Force Update of Toolbars:
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);
            }
            else
                return E_INVALIDARG;
            break;


        case MBANDCID_RECAPTURE:
            GetMessageFilter()->RetakeCapture();
            break;

        case MBANDCID_NOTAREALSITE:
            _fParentIsNotASite = BOOLIFY(nCmdExecOpt);
            break;

        case MBANDCID_ITEMDROPPED:
            {
                _fDragEntered = FALSE;
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker))
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
            }
            break;

        case MBANDCID_DRAGENTER:
            _fDragEntered = TRUE;
            break;

        case MBANDCID_DRAGLEAVE:
            _fDragEntered = FALSE;
            break;

            
        case MBANDCID_SELECTITEM:
            {
                int iPos = nCmdExecOpt;

                // If they are passing vararg in, then this is an ID, not a position
                if (pvarargIn && pvarargIn->vt == VT_I4)
                {
                    _nItemNew = pvarargIn->lVal;
                    _fPopupNewItemOnShow = TRUE;
                }

                // This can be called outside of a created band.
                if (_pmtbTop)
                {
                    if (iPos == MBSI_NONE)
                    {
                        SetTracked(NULL);
                    }
                    else
                    {
                        CMenuToolbarBase* pmtb = (iPos == MBSI_LASTITEM) ? _pmtbBottom : _pmtbTop;
                        ASSERT(pmtb);

                        SetTracked(pmtb);
                        _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                        // If the new hot item is in the obscured part of the menu, then the
                        // above call will have reentered & nulled out _pmtbTracked (since we
                        // drop down the chevron menu if the new hot item is obscured).  So we
                        // need to revalidate _pmtbTracked.
                        if (!_pmtbTracked)
                            break;

                        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                            GetIndexFromChild(TRUE, iPos));
                    }
                }
            }
            break;

        case MBANDCID_KEYBOARD:
            // If we've been executed because of a keyboard, then set the global
            // state to reflect that. This is sent by MenuBar when it's ::Popup
            // member is called with the flag MPPF_KEYBOARD. This is for start menu.
            if (_pmbState)
                _pmbState->SetKeyboardCue(TRUE);
            break;

        case MBANDCID_POPUPITEM:
            if (pvarargIn && VT_I4 == pvarargIn->vt)
            {
                // we don't want to popup a sub menu if we're tracking a context menu...
                if ( !((_pmtbBottom && _pmtbBottom->v_TrackingSubContextMenu()) || 
                       (_pmtbTop && _pmtbTop->v_TrackingSubContextMenu())))
                {
                    // No tracked item? Well default to the top (For the chevron menu)
                    if (!_pmtbTracked)
                    {
                        SetTracked(_pmtbTop);
                    }

                    // We don't want to display the sub menu if we're not shown.
                    // We do this because we could have been dismissed before the message
                    // was routed.
                    if (_fShow && _pmtbTracked)
                    {
                        int iItem;
                        int iPos;

                        if (nCmdExecOpt & MBPUI_ITEMBYPOS)
                        {
                            iPos = pvarargIn->lVal;
                            iItem = GetButtonCmd(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                        }
                        else
                        {
                            iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                            iItem = pvarargIn->lVal;
                        }


                        if (nCmdExecOpt & MBPUI_SETITEM)
                        {
                            // Set the hot item explicitly since this can be
                            // invoked by the keyboard and the mouse could be 
                            // anywhere.
                            _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                            // If the new hot item is in the obscured part of the menu, then the
                            // above call will have reentered & nulled out _pmtbTracked (since we
                            // drop down the chevron menu if the new hot item is obscured).  So we
                            // need to revalidate _pmtbTracked.
                            if (!_pmtbTracked)
                                break;

                            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                                GetIndexFromChild(TRUE, iPos) );
                        }

                        _pmtbTracked->PopupHelper(iItem, nCmdExecOpt & MBPUI_INITIALSELECT);
                    }
                }
            }
            break;

        case MBANDCID_ISVERTICAL:
            if (pvarargOut)
            {
                pvarargOut->vt = VT_BOOL;
                pvarargOut->boolVal = (_fVertical)? VARIANT_TRUE: VARIANT_FALSE;
            }
            break;
            
        case MBANDCID_SETICONSIZE:
            ASSERT(nCmdExecOpt == ISFBVIEWMODE_SMALLICONS || 
                nCmdExecOpt == ISFBVIEWMODE_LARGEICONS);

            _uIconSize = nCmdExecOpt;

            if (_pmtbTop)
                _pmtbTop->v_UpdateIconSize(nCmdExecOpt, TRUE);

            if (_pmtbBottom)
                _pmtbBottom->v_UpdateIconSize(nCmdExecOpt, TRUE);
            break;

        case MBANDCID_SETSTATEOBJECT:
            if (pvarargIn && VT_INT_PTR == pvarargIn->vt)
            {
                _pmbState = (CMenuBandState*)pvarargIn->byref;
            }
            break;

        case MBANDCID_ISINSUBMENU:
            if (_fInSubMenu || (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu()))
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_ISTRACKING:
            if (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu())
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_REPOSITION:

            // Don't reposition unless we're shown (Avoids artifacts onscreen of a bad positioning)
            if (_fShow)
            {
                // Don't forget to reposition US!!!
                IMenuPopup* pmdb;
                DWORD dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;

                // If we should force a reposition. This is so that we get
                // the trickle down reposition so things overlap correctly
                if (nCmdExecOpt)
                    dwFlags |= MPPF_FORCEZORDER;

                if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmdb))))
                {
                    pmdb->Popup(NULL, NULL, dwFlags);
                    pmdb->Release();
                }

                // Reposition the Tracked sub menu based on the current popped up item 
                // since this pane has now moved
                // If they have a sub menu, tell them to reposition as well.
                if (_fInSubMenu && _pmtbTracked)
                {
                    IUnknown_QueryServiceExec(_pmpSubMenu, SID_SMenuBandChild,
                    &CGID_MenuBand, MBANDCID_REPOSITION, nCmdExecOpt, NULL, NULL);
                }
                _pmbState->PutTipOnTop();
            }
            break;

        case MBANDCID_REFRESH:
            InvalidateItem(NULL, SMINV_REFRESH);
            break;
            
        case MBANDCID_EXPAND:
            if (_pmtbShellFolder)
                _pmtbShellFolder->Expand(TRUE);

            if (_pmtbMenu)
                _pmtbMenu->Expand(TRUE);
            break;

        case MBANDCID_DRAGCANCEL:
            // If one of the Sub bands in the menu heirarchy has the drag 
            // (Either because of Drag enter or because of the drop) then 
            // we do not want to cancel. 
            if (!_pmbState->HasDrag())
                _CancelMode(MPOS_FULLCANCEL);
            break;

        case MBANDCID_EXECUTE:
            ASSERT(pvarargIn != NULL);
            if (_pmtbTop && _pmtbTop->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbTop->v_ExecItem((int)nCmdExecOpt);
            else if (_pmtbBottom && _pmtbBottom->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbBottom->v_ExecItem((int)nCmdExecOpt);
            _SiteOnSelect(MPOS_EXECUTE);
            break;
        }

        // Don't bother passing CGID_MenuBand commands to CToolBand
        return S_OK;
    }     
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);    
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
STDMETHODIMP CMenuBand::CloseDW(DWORD dw)
{
    // We don't want to destroy the band if it's cached. 
    // That means it's the caller's respocibility to Unset this bit and call CloseDW explicitly
    if (_dwFlags & SMINIT_CACHED)
        return S_OK;

    if (_pmtbMenu)
    {
        _pmtbMenu->v_Close();
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->v_Close();
    }

    if (_pmpSubMenu)
    {
        _fInSubMenu = FALSE;
        IUnknown_SetSite(_pmpSubMenu, NULL);
        ATOMICRELEASE(_pmpSubMenu);
    }

    // Since we're blowing away all of the menus,
    // Top and bottom are invalid
    _pmtbTracked = _pmtbTop = _pmtbBottom = NULL;

    // We don't want our base class to blow this window away. It belongs to someone else.
    _hwnd = NULL;
    _fClosing = TRUE;
    
    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

Notes:
    for the start menu (non-browser) case, we bracket* the top-level popup
    operation w/ a LockSetForegroundWindow so that another app can't steal
    the foreground and collapse our menu.  (nt5:172813: don't do it for
    the browser case since a) we don't want to and b) ShowDW(FALSE) isn't
    called until exit the browser so we'd be permanently locked!)
*/
STDMETHODIMP CMenuBand::ShowDW(BOOL fShow)
{   
    CMBMsgFilter* pmf = GetMessageFilter();
    // Prevent rentrancy when we're already shown.
    ASSERT((int)_fShow == BOOLIFY(_fShow));
    if ((int)_fShow == BOOLIFY(fShow))
        return NOERROR;

    HRESULT hr = SUPERCLASS::ShowDW(fShow);

    if (SUCCEEDED(hr))
    {
        if (!fShow)
        {
            _fShow = FALSE;
            if (_fTopLevel)
            {
                if (_fVertical) 
                {
                    // (_fTopLevel && _fVertical) => start menu
                    LockSetForegroundWindow(LSFW_UNLOCK);
                }
                else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
                {
                    pmf->SetHook(FALSE, TRUE);
                    pmf->SetTopMost(this);
                }

            }

            if ((_fTopLevel || _fParentIsHorizontal) && _pmbState)
            {
                // Reset to not have the drag when we collapse.
                _pmbState->HasDrag(FALSE);
                _pmbState->SetExpand(FALSE);
                _pmbState->SetUEMState(0);
            }

            hr = _CallCB(SMC_EXITMENU);
        }
        else
        {
            hr = _CallCB(SMC_INITMENU);

            _fClosing = FALSE;
            _fShow = TRUE;
            _GetFontMetrics();

            if (_fTopLevel)
            {
                // We set the context here so that the ReEngage causes the message filter
                // to start taking messages on a TopLevel::Show. This prevents a problem
                // where tracking doesn't work when switching between Favorites and Start Menu
                _pmbState->SetContext(this);
                pmf->SetContext(this, TRUE);

                pmf->ReEngage(_pmbState->GetContext());
                if (_hwndMenuOwner && _fVertical)
                    SetForegroundWindow(_hwndMenuOwner);

                if (_fVertical) 
                {
                    // (_fTopLevel && _fVertical) => start menu
                    LockSetForegroundWindow(LSFW_LOCK);
                }
                else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
                {
                    pmf->SetHook(TRUE, TRUE);
                    pmf->SetTopMost(this);
                }

                _pmbState->CreateFader();
            }
        }

        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Show(_fShow, _fForceButtonUpdate);

        // Menu needs to be last so that it can update the seperator.
        if (_pmtbMenu)
            _pmtbMenu->v_Show(_fShow, _fForceButtonUpdate);

        if (_fPopupNewItemOnShow)
        {
            HWND hwnd = _pmbState ? _pmbState->GetSubclassedHWND() : NULL;

            if (hwnd || _pmtbMenu)
            {
                PostMessage(hwnd ? hwnd : _pmtbMenu->_hwndMB, g_nMBPopupOpen, 
                    _nItemNew, MAKELPARAM(TRUE, TRUE));
            }
            _fPopupNewItemOnShow = FALSE;
        }

        _fForceButtonUpdate = FALSE;
    }
    return hr;
}

void CMenuBand::_GetFontMetrics()
{
    if (_fTopLevel)
    {
        if (!_pmbm)
            _pmbm = new CMenuBandMetrics();

        if (_pmbm && _pmtbTop)
        {
            // We need only 1 HWND
            _pmbm->Init(_pmtbTop->_hwndMB);
        }
    }
    else if (!_pmbm)
    {
        AssertMsg(0, TEXT("When this menuband was created, someone forgot to set the metrics"));

        VARIANTARG vargOut;
        HRESULT hres = IUnknown_QueryServiceExec(_punkSite, SID_SMenuBandTop, &CGID_MenuBand, MBANDCID_GETFONTS, 0, NULL, &vargOut);
        if (SUCCEEDED(hres))
        {
            if (vargOut.vt == VT_UNKNOWN && vargOut.punkVal)
            {
                vargOut.punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);
            }
            VariantClear(&vargOut);
        }
    }
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the child menubar to tell us when and how
         to bail out of the menu.
*/
STDMETHODIMP CMenuBand::OnSelect(DWORD dwType)
{
    int iIndex;

    switch (dwType)
    {
    case MPOS_CHILDTRACKING:
        // this means that our child did get tracked over it, so we should abort any timeout to destroy it

        if (_pmtbTracked)
        {
            HWND hwnd = _pmtbTracked->_hwndMB;
            if (_nItemTimer) 
            {
                _pmtbTracked->KillPopupTimer();
        
                // Use the command id of the SubMenu that we actually have cascaded out.
                iIndex = ToolBar_CommandToIndex(hwnd, _nItemSubMenu);
                ToolBar_SetHotItem(hwnd, iIndex);
            }
            KillTimer(hwnd, MBTIMER_DRAGOVER);
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_SELECTLEFT:
        if (!_fVertical)
            _OnSelectArrow(-1);
        else
        {
            // Cancel the child submenu.  Hitting left arrow is like
            // hitting escape.
            _SubMenuOnSelect(MPOS_CANCELLEVEL);
        }
        break;

    case MPOS_SELECTRIGHT:
        if (!_fVertical)
            _OnSelectArrow(1);
        else
        {
            // The right arrow gets propagated up to the top, so
            // a fully cascaded menu will be cancelled and the
            // top level menuband will move to the next menu to the
            // right.
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_CANCELLEVEL:
        // Forward onto submenu
        _SubMenuOnSelect(dwType);
        break;

    case MPOS_FULLCANCEL:
    case MPOS_EXECUTE:
        DEBUG_CODE( TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): CMenuToolbarBase received %s", 
                    DBG_THIS, MPOS_FULLCANCEL == dwType ? TEXT("MPOS_FULLCANCEL") : TEXT("MPOS_EXECUTE")); )

        _CancelMode(dwType);
        break;
    }
    return S_OK;    
}    

void CMenuBand::SetTrackMenuPopup(IUnknown* punk)
{ 
    ATOMICRELEASE(_pmpTrackPopup);
    if (punk)
    {
        punk->QueryInterface(IID_PPV_ARG(IMenuPopup, &_pmpTrackPopup));
    }
}


/*----------------------------------------------------------
Purpose: Set the currently tracked toolbar.  Only one
         of the toolbars can have the "activation" at one time.
*/
BOOL CMenuBand::SetTracked(CMenuToolbarBase* pmtb)
{
    if (pmtb == _pmtbTracked)
        return FALSE;

    if (_pmtbTracked)
    {
        // Tell the existing toolbar we're leaving him
        SendMessage(_pmtbTracked->_hwndMB, TB_SETHOTITEM2, -1, HICF_LEAVING);
    }

    _pmtbTracked = pmtb;

    if (_pmtbTracked)
    {
        // This is for accessibility.
        HWND hwnd = _pmtbTracked->_hwndMB;
        int iHotItem = ToolBar_GetHotItem(hwnd);

        if (iHotItem >= 0)
        {
            // Toolbar Items are 0 based, Accessibility apps require 1 based
            NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, 
                GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iHotItem)); 
        }
    }

    return TRUE;
}


void CMenuBand::_OnSelectArrow(int iDir)
{
    _fKeyboardSelected = TRUE;
    int iIndex;

    if (!_pmtbTracked)
    {
        if (iDir < 0)
        {
            SetTracked(_pmtbBottom);
            iIndex = ToolBar_ButtonCount(_pmtbTracked->_hwndMB) - 1;
        }
        else
        {
            SetTracked(_pmtbTop);
            iIndex = 0;
        }

        // This can happen when going to the chevron.
        if (_pmtbTracked)
            _pmtbTracked->SetHotItem(iDir, iIndex, -1, HICF_ARROWKEYS);
    }
    else
    {
        HWND hwnd = _pmtbTracked->_hwndMB;
        iIndex = ToolBar_GetHotItem(hwnd);
        int iCount = ToolBar_ButtonCount(hwnd);
    
        // Set the hot item explicitly since this is invoked by the 
        // keyboard and the mouse could be anywhere.

        // cycle iIndex by iDir (add extra iCount to avoid negative number problems
        iIndex = (iIndex + iCount + iDir) % iCount; 

        ToolBar_SetHotItem(hwnd, iIndex);
    }

    if (_pmtbTracked)
    {
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iIndex));
    }
    _fKeyboardSelected = FALSE;
}

void CMenuBand::_CancelMode(DWORD dwType)
{
    // Tell the hosting site to cancel this level
    if (_fParentIsNotASite)
        UIActivateIO(FALSE, NULL);
    else
        _SiteOnSelect(dwType);
}    

HRESULT CMenuBand::OnPosRectChangeDB (LPRECT prc)
{
    // We want the HMENU portion to ALWAYS have the maximum allowed.
    RECT rcMenu = {0};
    SIZE sizeMenu = {0};
    SIZE sizeSF = {0};
    SIZE sizeMax;

    if (_pmtbMenu)
        _pmtbMenu->GetSize(&sizeMenu);

    if (_pmtbShellFolder)
        _pmtbShellFolder->GetSize(&sizeSF);

    if (sizeSF.cx > sizeMenu.cx)
        sizeMax = sizeSF;
    else
        sizeMax = sizeMenu;

    if (_pmtbMenu)
    {
        if (_pmtbMenu->GetFlags() & SMSET_TOP)
        {

            rcMenu.bottom = sizeMenu.cy;
            rcMenu.right = prc->right;
        }
        else
        {
            rcMenu.bottom = prc->bottom;
            rcMenu.right = prc->right;

            rcMenu.top = prc->bottom - sizeMenu.cy;
            rcMenu.left = 0;
        }

        if (RECTHEIGHT(rcMenu) > RECTHEIGHT(*prc))
        {
            rcMenu.bottom -= RECTHEIGHT(rcMenu) - RECTHEIGHT(*prc);
        }

        _pmtbMenu->SetWindowPos(&sizeMax, &rcMenu, 0);
    }

    if (_pmtbShellFolder)
    {
        RECT rc = *prc;

        if (_pmtbShellFolder->GetFlags() & SMSET_TOP)
        {
            rc.bottom = prc->bottom - RECTHEIGHT(rcMenu);
        }
        else
        {
            rc.top = prc->top + RECTHEIGHT(rcMenu);
        }

        _pmtbShellFolder->SetWindowPos(&sizeMax, &rc, 0);
    }

    return NOERROR;
}


HRESULT IUnknown_OnSelect(IUnknown* punk, DWORD dwType, REFGUID guid)
{
    HRESULT hres;
    IMenuPopup * pmp;

    hres = IUnknown_QueryService(punk, guid, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }

    return hres;
}

HRESULT CMenuBand::_SiteOnSelect(DWORD dwType)
{
    return IUnknown_OnSelect(_punkSite, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::_SubMenuOnSelect(DWORD dwType)
{
    IMenuPopup* pmp = _pmpSubMenu;
    if (_pmpTrackPopup)
        pmp = _pmpTrackPopup;

    return IUnknown_OnSelect(pmp, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::GetTop(CMenuToolbarBase** ppmtbTop)
{
    *ppmtbTop = _pmtbTop;

    if (*ppmtbTop)
    {
        (*ppmtbTop)->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CMenuBand::GetBottom(CMenuToolbarBase** ppmtbBottom)
{
    *ppmtbBottom = _pmtbBottom;

    if (*ppmtbBottom)
    {
        (*ppmtbBottom)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetTracked(CMenuToolbarBase** ppmtbTracked)
{
    *ppmtbTracked = _pmtbTracked;

    if (*ppmtbTracked)
    {
        (*ppmtbTracked)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetParentSite(REFIID riid, void** ppvObj)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvObj);

    return E_FAIL;
}

HRESULT CMenuBand::GetState(BOOL* pfVertical, BOOL* pfOpen)
{
    *pfVertical = _fVertical;
    *pfOpen = _fMenuMode;
    return NOERROR;
}

HRESULT CMenuBand::DoDefaultAction(VARIANT* pvarChild)
{
    if (pvarChild->lVal != CHILDID_SELF)
    {
        CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
        int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

        SendMessage(pmtb->_hwndMB, TB_SETHOTITEM2, idCmd, HICF_OTHER | HICF_TOGGLEDROPDOWN);
    }
    else
    {
        _CancelMode(MPOS_CANCELLEVEL);
    }

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IShellMenuAcc::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
    int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

    *ppvObj = NULL;

    if (idCmd != -1 && pmtb)
    {
        hres = pmtb->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu2::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(UINT idCmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

    if (_pmtbMenu)
    {
        hres = _pmtbMenu->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    if (hres == HRESULT_FROM_WIN32(ERROR_NOT_FOUND) && _pmtbShellFolder)
    {
        hres = _pmtbShellFolder->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }
    return hres;
}

HRESULT CMenuBand::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMenuToolbarBase *pmtb = ToolbarMenu_Create(hwnd);
    if (pmtb)
    {
        hr = SetMenuToolbar(SAFECAST(pmtb, IWinEventHandler*), dwFlags);
        // DONT release! The menus break com identity rules because of a foobar when they were
        // initially designed.
    }
    return hr;
}

HRESULT CMenuBand::SetMinWidth(int cxMenu)
{
    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMinWidth(cxMenu);
    }
    else
        return E_FAIL;
}

HRESULT CMenuBand::SetNoBorder(BOOL fNoBorder)
{
    HRESULT hr = S_OK;

    _fNoBorder = fNoBorder;

    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        hr = _pmtbMenu->SetNoBorder(fNoBorder);
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->SetNoBorder(fNoBorder);
    }

    if (_punkSite)
    {
        hr = IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, MBCID_NOBORDER, fNoBorder, NULL, NULL);
    }

    return hr;
}

HRESULT CMenuBand::SetTheme(LPCWSTR pszTheme)
{
    HRESULT hr = S_OK;

    Str_SetPtr(&_pszTheme, pszTheme);

    if (_pmtbMenu)
    {
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        hr = _pmtbMenu->SetTheme(_pszTheme);
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->SetTheme(_pszTheme);
    }

    return hr;
}

HRESULT CMenuBand::IsEmpty()
{
    BOOL fReturn = TRUE;
    if (_pmtbShellFolder)
        fReturn = _pmtbShellFolder->IsEmpty();

    if (fReturn && _pmtbMenu)
        fReturn = _pmtbMenu->IsEmpty();

    return fReturn? S_OK : S_FALSE;
}


//----------------------------------------------------------------------------
// CMenuBandMetrics
//
//----------------------------------------------------------------------------


COLORREF GetLumColor(int isys, int iLumAdjust)
{
    WORD iHue;
    WORD iLum;
    WORD iSat;
    COLORREF clr = (COLORREF)GetSysColor(isys);
    HDC hdc = GetDC(NULL);

    // Office CommandBars use this same algorithm for their "intellimenus"
    // colors.  We prefer to call them "expando menus"...

    if (hdc)
    {
        int cColors = GetDeviceCaps(hdc, BITSPIXEL);
        
        ReleaseDC(NULL, hdc);
        
        switch (cColors)
        {
        case 4:     // 16 Colors
        case 8:     // 256 Colors
            // Default to using Button Face
            break;
            
        default:    // 256+ colors
            
            ColorRGBToHLS(clr, &iHue, &iLum, &iSat);
            
            if (iLum > 220)
                iLum -= iLumAdjust;
            else if (iLum <= 20)
                iLum += 2 * iLumAdjust;
            else
                iLum += iLumAdjust;
            
            clr = ColorHLSToRGB(iHue, iLum, iSat);
            break;
        }
    }
    
    return  clr;
}


ULONG CMenuBandMetrics::AddRef()
{
    return ++_cRef;
}

ULONG CMenuBandMetrics::Release()
{
    ASSERT(_cRef > 0);
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMenuBandMetrics::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else if (IsEqualIID(riid, CLSID_MenuBandMetrics))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_FAIL;
    }

    AddRef();
    return S_OK;
}

CMenuBandMetrics::CMenuBandMetrics()
                : _cRef(1)
{
}

void CMenuBandMetrics::Init(HWND hwnd)
{
    if (_fInit)
        return;

    _SetMenuFont();
    _SetColors();

    HIGHCONTRAST hc = {sizeof(HIGHCONTRAST)};

    if (SystemParametersInfoA(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        _fHighContrastMode = (HCF_HIGHCONTRASTON & hc.dwFlags);
    }

    if (g_dwPrototype & 0x00000100)
    {
        SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(TRUE), SPIF_SENDCHANGE);
        SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(TRUE), SPIF_SENDCHANGE);
    }
    
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&_fFlatMenuMode, 0);

    _SetArrowFont(hwnd);
    _SetChevronFont(hwnd);
#ifndef DRAWEDGE
    _SetPaintMetrics(hwnd);
#endif
    _SetTextBrush(hwnd);

    _fInit = TRUE;
}


CMenuBandMetrics::~CMenuBandMetrics()
{
    if (_hFontMenu)
        DeleteObject(_hFontMenu);

    if (_hFontArrow)
        DeleteObject(_hFontArrow);

    if (_hFontChevron)
        DeleteObject(_hFontChevron);

    if (_hbrText)
        DeleteObject(_hbrText);

#ifndef DRAWEDGE
    if (_hPenHighlight)
        DeleteObject(_hPenHighlight);

    if (_hPenShadow)
        DeleteObject(_hPenShadow);
#endif
}

HFONT CMenuBandMetrics::_CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
                                  int* pcy, int* pcxMargin, int iOrientation, int iWeight)
{
    ASSERT(hwnd);

    HFONT hFontOld, hFontRet = NULL;
    TEXTMETRIC tm;
    RECT rect={0};

    int cx = 0, cy = 0, cxM = 0;

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        hFontOld = (HFONT)SelectObject(hdc, _hFontMenu);
        GetTextMetrics(hdc, &tm);

        // Set the font height (based on original USER code)
        cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

        // Use the menu font's avg character width as the margin.
        cxM = tm.tmAveCharWidth; // Not exactly how USER does it, but close

        // Shlwapi wraps the ansi/unicode behavior.
        hFontRet = CreateFontWrap(cy, 0, iOrientation, 0, iWeight, 0, 0, 0, dwCharSet, 0, 0, 0, 0, pszFont);
        if (TPTR(hFontRet))
        {
            // Calc width of arrow using this new font
            SelectObject(hdc, hFontRet);
            if (DrawText(hdc, &ch, 1, &rect, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER))
                cx = rect.right;
            else
                cx = tm.tmMaxCharWidth;
        }
        else
        {
            cx = tm.tmMaxCharWidth;
        }
    
        SelectObject(hdc, hFontOld);   
        ReleaseDC(hwnd, hdc);
    }

    *pcx = cx;
    *pcy = cy;
    *pcxMargin = cxM;
    
    return hFontRet;

}


/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetChevronFont(HWND hwnd)
{
    ASSERT(!_hFontChevron);
    TCHAR szPath[MAX_PATH];

    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
   
    // Obtain the font's metrics
    SHAnsiToTChar(ncm.lfMenuFont.lfFaceName, szPath, ARRAYSIZE(szPath));
    _hFontChevron = _CalcFont(hwnd, szPath, DEFAULT_CHARSET, CH_MENUARROW, &_cxChevron, &_cyChevron, 
        &_cxChevron, -900, FW_NORMAL);
}

/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetArrowFont(HWND hwnd)
{
    ASSERT(!_hFontArrow);
    ASSERT(_hFontMenu);
   
    // Obtain the font's metrics
    if (_hFontMenu)
    {
        _hFontArrow = _CalcFont(hwnd, szfnMarlett, SYMBOL_CHARSET, CH_MENUARROW, &_cxArrow, &_cyArrow, 
            &_cxMargin, 0, FW_NORMAL);
    }
    else
    {
        _cxArrow = _cyArrow = _cxMargin = 0;
    }
}

void CMenuBandMetrics::_SetMenuFont()
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
    _hFontMenu = CreateFontIndirect(&ncm.lfMenuFont);
}

void CMenuBandMetrics::_SetColors()
{
    _clrBackground = GetSysColor(COLOR_MENU);
    _clrMenuText = GetSysColor(COLOR_MENUTEXT);
    _clrDemoted = GetLumColor(COLOR_MENU, 20);
    _clrMenuGrad = GetLumColor(COLOR_MENU, -20);
}


#ifndef DRAWEDGE
// Office "IntelliMenu" style
void CMenuBandMetrics::_SetPaintMetrics(HWND hwnd)
{
    DWORD dwSysHighlight = GetSysColor(COLOR_3DHIGHLIGHT);
    DWORD dwSysShadow = GetSysColor(COLOR_3DSHADOW);

    _hPenHighlight = CreatePen(PS_SOLID, 1, dwSysHighlight);
    _hPenShadow = CreatePen(PS_SOLID, 1, dwSysShadow);
}
#endif

void CMenuBandMetrics::_SetTextBrush(HWND hwnd)
{
    _hbrText = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));
}


CMenuBandState::CMenuBandState()                
{ 
    // We will default to NOT show the keyboard cues. This
    // is overridden based on the User Settings.
    _fKeyboardCue = FALSE;
}

CMenuBandState::~CMenuBandState()
{
    ATOMICRELEASE(_ptFader);

    ATOMICRELEASE(_pScheduler);

    if (IsWindow(_hwndToolTip))
        DestroyWindow(_hwndToolTip);

    if (IsWindow(_hwndWorker)) // JANK : Fix for bug #101302
        DestroyWindow(_hwndWorker);
}

int CMenuBandState::GetKeyboardCue()
{
    return _fKeyboardCue;
}

void CMenuBandState::SetKeyboardCue(BOOL fKC)
{
    _fKeyboardCue = fKC;
}

IShellTaskScheduler* CMenuBandState::GetScheduler()
{
    HRESULT hr = S_OK;
    if (!_pScheduler)
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
    }

    ASSERT((SUCCEEDED(hr) && _pScheduler) || (FAILED(hr) && !_pScheduler));

    if (SUCCEEDED(hr))
        _pScheduler->AddRef();


    return _pScheduler;
}

HRESULT CMenuBandState::FadeRect(LPCRECT prc)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    BOOL fFade = FALSE;
    SystemParametersInfo(SPI_GETSELECTIONFADE, 0, &fFade, 0);
    if (_ptFader && fFade)
    {
        hr = _ptFader->FadeRect(prc);
    }

    return hr;
}

void CMenuBandState::CreateFader()
{
    // We do this on first show, because in the Constuctor of CMenuBandState,
    // the Window classes might not be registered yet (As is the case with start menu).
    if (!_ptFader)
    {
        CoCreateInstance(CLSID_FadeTask, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IFadeTask, &_ptFader));
    }
}


void CMenuBandState::CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR pszTip)
{
    // Balloon style holds presidence over info tips
    if (_fTipShown && _fBalloonStyle)
        return;

    if (!_hwndToolTip)
    {
        _hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                         WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         NULL, NULL, g_hinst,
                                         NULL);

        if (_hwndToolTip) 
        {
            // set the version so we can have non buggy mouse event forwarding
            SendMessage(_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)300);
        }
    }

    if (_hwndToolTip)
    {
        // Collapse the previous tip because we're going to be doing some stuff to it before displaying again.
        SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

        // Balloon tips don't have a border, but regular tips do. Swap now...
        SHSetWindowBits(_hwndToolTip, GWL_STYLE, TTS_BALLOON | WS_BORDER, (fBalloon) ? TTS_BALLOON : WS_BORDER);

        if (pszTip && pszTip[0])
        {
            POINT   ptCursor;
            RECT    rcItemScreen, rcItemTB;
            TOOLINFO ti = {0};
            ti.cbSize = sizeof(ti);

            // This was pretty bad: I kept adding tools, but never deleteing them. Now we get rid of the current
            // one then add the new one.
            if (SendMessage(_hwndToolTip, TTM_ENUMTOOLS, 0, (LPARAM)&ti))
            {
                SendMessage(_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&ti);   // Delete the current tool.
            }

            SendMessage(hwndTB, TB_GETRECT, idCmd, (LPARAM)&rcItemScreen);
            rcItemTB = rcItemScreen;
            MapWindowPoints(hwndTB, HWND_DESKTOP, (POINT*)&rcItemScreen, 2);

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_TRANSPARENT | (fBalloon? TTF_TRACK : 0);
            
            // Check if the cursor is within the bounds of the hot item.
            // If it is, then proceed as usual.
            // If it isn't, then the hot item was activated via the keyboard, so the tooltip
            // shouldn't be hung from the cursor.  Stick it on the hot item instead.
            
            // Set the vertical offset to use later.
            // Notice the correction for the bottom: gsierra wanted it up a couple of pixels.
            int nOffset = -3;
            
            GetCursorPos(&ptCursor);
            if (!PtInRect(&rcItemScreen, ptCursor))
            {
                ti.uFlags |= TTF_TRACK;

                // Force the tool tip to track along the bottom.
                nOffset = 1;
            }

            // The tooltip won't pick up the hot item's rect right, so
            // do it manually.
            ti.rect = rcItemTB;

            SendMessage(_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rcItemScreen.left + rcItemScreen.right)/2, rcItemScreen.bottom + nOffset));

            ti.hwnd = hwndTB;
            ti.uId = (UINT_PTR)hwndTB;
            SendMessage(_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

            ti.lpszText = pszTip;
            SendMessage(_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

            SendMessage(_hwndToolTip, TTM_SETTITLE, TTI_INFO, (LPARAM)pszTitle);

            SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            _fTipShown = TRUE;
            _fBalloonStyle = fBalloon;
        }
    }

}

void CMenuBandState::HideTooltip(BOOL fAllowBalloonCollapse)
{
    if (_hwndToolTip && _fTipShown)
    {
        // Now we're going to latch the Balloon style. The rest of menuband blindly
        // collapses the tooltip when selection changes. Here's where we say "Don't collapse
        // the chevron balloon tip because of a selection change."
        if ((_fBalloonStyle && fAllowBalloonCollapse) || !_fBalloonStyle)
        {
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);
            _fTipShown = FALSE;
        }
    }
}

void CMenuBandState::PutTipOnTop()
{
    // Force the tooltip to the topmost.
    if (_hwndToolTip)
    {
        SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
}

HWND CMenuBandState::GetWorkerWindow(HWND hwndParent)
{
    if (!_hwndSubclassed)
        return NULL;

    if (!_hwndWorker)
    {
        // We need a worker window, so that dialogs show up on top of our menus.
        // HiddenWndProc is included from sftbar.h
        _hwndWorker = SHCreateWorkerWindow(HiddenWndProc, _hwndSubclassed, 
            WS_EX_TOOLWINDOW, WS_POPUP, 0, (void*)_hwndSubclassed);
    }

    //hwndParent is unused at this time. I plan on using it to prevent the parenting to the subclassed window.

    return _hwndWorker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\isfmenu.cpp ===
//
// isfmenu.cpp
//
// callback for chevron drop-down menu for isfbands
//

#include "shellprv.h"
#include "isfmenu.h"
#include "legacy.h"
#include "util.h"

// *** IUnknown methods ***
STDMETHODIMP CISFMenuCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CISFMenuCallback, IShellMenuCallback),
        QITABENT(CISFMenuCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CISFMenuCallback::AddRef ()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CISFMenuCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

BOOL CISFMenuCallback::_IsVisible(LPITEMIDLIST pidl)
{
    if (_poct) {
        VARIANTARG v;

        v.vt = VT_INT_PTR;
        v.byref = pidl;

        HRESULT hr = _poct->Exec(&CGID_ISFBand, ISFBID_ISITEMVISIBLE, 0, &v, NULL);
        return (hr == S_OK);
    }

    return FALSE;
}


HRESULT IUnknown_SeekToZero(IUnknown* punk)
{
    HRESULT hres = E_FAIL;
    IStream* pstm;
    if (punk && SUCCEEDED(punk->QueryInterface(IID_IStream, (void**)&pstm)))
    {
        // We need to seek to the beginning of the stream here. We don't do this in
        // the menubands because it's rude: They should not seek to the beginning
        // because there may be information that needs to be saved after them.
        //Set the seek pointer at the beginning.
        const LARGE_INTEGER li0 = {0};
        hres = pstm->Seek(li0, STREAM_SEEK_SET, NULL);
        pstm->Release();
    }

    return hres;
}

HRESULT CISFMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = S_FALSE;
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    VARIANTARG v = {0};

                    v.vt = VT_UNKNOWN;
                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_GETORDERSTREAM, 0, NULL, &v);

                    if (SUCCEEDED(hres))
                    {
                        IUnknown_SeekToZero(v.punkVal);

                        hres = v.punkVal->QueryInterface(riid, ppvObj);
                        v.punkVal->Release();
                    }
                }
                ILFree(pidlFull);
            }
        }
    }
    return hres;
}

HRESULT CISFMenuCallback::_SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    ASSERT(ppvObj);

                    VARIANTARG v;

                    v.vt = VT_UNKNOWN;
                    v.punkVal = *(IUnknown**)ppvObj;

                    IUnknown_SeekToZero(*(IUnknown**)ppvObj);

                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_SETORDERSTREAM, 0, &v, NULL);
                }
                ILFree(pidlFull);
            }
        }
    }

    return hres;
}


HRESULT CISFMenuCallback::_GetSFInfo(LPSMDATA psmd, PSMINFO psminfo)
{
    // We only want to filter pidls if:
    //  1) It's at the root of the links chevron menu
    //  2) It's _IS_ visible in the links bar. We don't want to show links
    //     in this menu that are visible.
    if (psmd->uIdAncestor == ANCESTORDEFAULT &&
        (psminfo->dwMask & SMIM_FLAGS)       && 
        _IsVisible(psmd->pidlItem))
    {
        // not obscured on the subject isfband; exclude from menu
        psminfo->dwFlags |= SMIF_HIDDEN;
    }

    return S_OK;
}

// *** IShellMenuCallback methods ***
STDMETHODIMP CISFMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg) 
    {
    case SMC_SFEXEC:
        hr = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (PSMINFO)lParam);
        break;

    case SMC_GETSFOBJECT:
        hr = _GetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    case SMC_SETSFOBJECT:
        hr = _SetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    }

    return hr;
}

// *** IObjectWithSite methods ***
STDMETHODIMP CISFMenuCallback::SetSite(IUnknown* punkSite)
{
    if (punkSite != _punkSite)
        IUnknown_Set(&_punkSite, punkSite);

    return S_OK;
}


HRESULT CISFMenuCallback::Initialize(IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
        hr = punk->QueryInterface(IID_IOleCommandTarget, (PVOID*)&_poct);

    IShellFolderBand* psfb;
    hr = punk->QueryInterface(IID_IShellFolderBand, (PVOID*)&psfb);

    if (SUCCEEDED(hr)) 
    {
        BANDINFOSFB bi;
        bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

        hr = psfb->GetBandInfoSFB(&bi);
        _pidl = bi.pidl;
        if (bi.psf)
            bi.psf->Release();
        psfb->Release();
    }

    return hr;
}

CISFMenuCallback::CISFMenuCallback() : _cRef(1)
{
}

CISFMenuCallback::~CISFMenuCallback()
{
    ASSERT(_cRef == 0);

    ILFree(_pidl);

    ATOMICRELEASE(_poct);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menubar.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "basebar.h"
#include "bands.h"
#include "menubar.h"
#include "menuband.h"
#include "isfband.h"
#include "util.h"
#include "apithk.h"

#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define THISCLASS CMenuDeskBar
#define SUPERCLASS CBaseBar


// Don't fade the menu if it's larger than this magical number. Based on experiments
// on a Pentium II - 233
#define MAGICAL_NO_FADE_HEIGHT  600

// For TraceMsg
#define DM_POPUP   DM_TRACE

#define UP    0
#define DOWN  1
#define LEFT  2
#define RIGHT 3

#ifdef ENABLE_CHANNELS
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);
#endif  // ENABLE_CHANNELS

STDAPI CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv)
{
    // aggregation checking is handled in class factory
    HRESULT hr = E_OUTOFMEMORY;

    CMenuDeskBar *pwbar = new CMenuDeskBar();
    if (pwbar)
    {
        hr = pwbar->QueryInterface(riid, ppv);
        pwbar->Release();
    }

    return hr;
}


CMenuDeskBar::CMenuDeskBar() : SUPERCLASS()
{
    _dwMode = DBIF_VIEWMODE_VERTICAL; 
    
    _iIconSize = BMICON_SMALL;
}

CMenuDeskBar::~CMenuDeskBar()
{
    SetSite(NULL);
}


STDMETHODIMP CMenuDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IMenuPopup),
        QITABENT(THISCLASS, IObjectWithSite),
        QITABENT(THISCLASS, IBanneredBar),
        QITABENT(THISCLASS, IInitializeObject),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubmenu method

*/
STDMETHODIMP CMenuDeskBar::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (fSet)
    {
        if (_pmpChild)
            _pmpChild->Release();
        
        _pmpChild = pmp;
        _pmpChild->AddRef();    
    }
    else
    {
        if (_pmpChild && SHIsSameObject(pmp, _pmpChild))
        {
            _pmpChild->Release();
            _pmpChild = NULL;
        }
    }
    return S_OK;
}


void CMenuDeskBar::_PopDown()
{
    DAD_ShowDragImage(FALSE);
    if (_pmpChild)
        _pmpChild->OnSelect(MPOS_CANCELLEVEL);
    
//    ShowWindow(_hwnd, SW_HIDE);
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);
    ShowDW(FALSE);
    if (_pmpParent)
    {
        _pmpParent->SetSubMenu(this, FALSE);
    }
    UIActivateIO(FALSE, NULL);
    _fActive = FALSE;
    DAD_ShowDragImage(TRUE);
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CMenuDeskBar::OnSelect(DWORD dwSelectType)
{
    switch (dwSelectType)
    {
    case MPOS_CHILDTRACKING:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;
        
    case MPOS_SELECTRIGHT:
    case MPOS_SELECTLEFT:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_EXECUTE:
    case MPOS_FULLCANCEL:
        _PopDown();
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_CANCELLEVEL:
        _PopDown();
        break;
        
    }
    
    return S_OK;
} 

void SetExpandedBorder(HWND hwnd, BOOL fExpanded)
{
#ifdef MAINWIN
    // IEUNIX : WS_DLGFRAME implementaion looks ugly on UNIX.
    fExpanded = TRUE;
#endif

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

    if (fExpanded)
    {
        dwStyle |= WS_BORDER;
        dwStyle &= ~WS_DLGFRAME;
    }
    else
    {
        dwStyle &= ~WS_BORDER;
        dwStyle |= WS_DLGFRAME;
    }

    SetWindowLong(hwnd, GWL_STYLE, dwStyle);
    SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    UpdateWindow(hwnd);
}

void CMenuDeskBar::_OnCreate()
{
    if (!_fFlatMenuMode)
        SetExpandedBorder(_hwnd, _fExpanded);
}


DWORD CMenuDeskBar::_GetClassStyle()
{
    DWORD dwStyle = CS_SAVEBITS; // Faster repaint for menus when they go away
    
    if (IsOS(OS_WHISTLERORGREATER))
    {
        dwStyle |= CS_DROPSHADOW;   // Cool dropshadow effect on whistler....
    }

    return dwStyle;
}

DWORD CMenuDeskBar::_GetExStyle()
{
#ifndef MAINWIN
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
#else
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_MW_UNMANAGED_WINDOW;
#endif
}

// We use the following structure to pass a whole bunch of information from 
// the GetPopupWindowPosition to WillFit function. We have WillFit function 
// to cut the amount of duplicate code in getpopup window position. The order 
// in which different the sides are checked is the only difference for popping 
// up a window on a particular side.
//
// Having this function helps us to do that check by means of a parameter instead 
// of repeating portions of code again and again.

typedef struct  {
    RECT rcAvail;           // Available dimensions b/t monitor edge and exclude edge
    SIZE sizeAdjust;          // Size of menu edge
    int  cyMonitor;         // Size of monitor 
    int  cxMonitor;
    int  cx;                // Size of menu
    int  cy;
    int  cyExtendDiff;      // Difference b/t calc'd size and available size
    RECT *prcResult;
    RECT *prcExclude;       // Exclude rect
    RECT *prcMonitor;
} PopupInfo;

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3 

/*----------------------------------------------------------
Purpose: Attempt to fit and position a menu in the given direction
         relative to an exclude rect.

         Setting fForce to TRUE will cause the menu size to be adjusted
         to fit, if necessary.

         This function only sets the top and left coords, not the bottom
         and right coords.
         
         Returns TRUE if the desired direction can be accomplished.

*/
BOOL WillFit(PopupInfo * pinfo, int side, BOOL fForce)
{
    BOOL bRet = FALSE;
    LPRECT prcResult = pinfo->prcResult;
    
    pinfo->cyExtendDiff = 0;
    
    switch(side)
    {
    case TOP:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.top;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    

            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;    
        }

        // Can the menu be positioned above?
        if (pinfo->cy <= pinfo->rcAvail.top)
        {
            // Yes
            prcResult->top  = pinfo->prcExclude->top - pinfo->cy;
            
            goto AdjustHorzPos;
        }
        break;
        
    case BOTTOM:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.bottom;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    
            
            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;
        }

        // Can the menu be positioned below?
        if (pinfo->cy <= pinfo->rcAvail.bottom)
        {
            // Yes
            prcResult->top = pinfo->prcExclude->bottom;

AdjustHorzPos:            
            prcResult->left = max(pinfo->prcExclude->left, pinfo->prcMonitor->left);

            // Can the menu be positioned relative to its left edge (hanging right)?
            if (prcResult->left + pinfo->cx >= pinfo->prcMonitor->right)
            {
                // No; move it in so it is on the screen
                //  (cx has already been adjusted to fit inside the monitor dimensions)
                prcResult->left = pinfo->prcMonitor->right - pinfo->cx - 1;
            }
            bRet = TRUE;
        }
        break;
        
    case LEFT:
        // Can the menu be positioned to the left?
        if (pinfo->cx <= pinfo->rcAvail.left || fForce)
        {
            // Yes
            
            // When cascading left, the menu does not overlap.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->left - pinfo->cx - 1;

            goto AdjustVerticalPos;
        }
        break;

    case RIGHT:
        // Can the menu be positioned to the right?
        if (pinfo->cx  <=  pinfo->rcAvail.right || fForce)
        {
            // Yes
            
            // Adjust the menu to slightly overlap the parent menu.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->right - pinfo->sizeAdjust.cx;

AdjustVerticalPos:            
            prcResult->top = pinfo->prcExclude->top - pinfo->sizeAdjust.cy;

            // Can the menu be positioned relative to its top edge (hanging down)?
            if (prcResult->top + pinfo->cy >= pinfo->prcMonitor->bottom)
            {
                // No; can it be positioned relative to its bottom edge (hanging up)?
                prcResult->top = pinfo->prcExclude->bottom + pinfo->sizeAdjust.cy - pinfo->cy;
                
                if (prcResult->top < pinfo->prcMonitor->top)
                {
                    // No; move the menu so it fits, but isn't vertically snapped.
                    //  (cy has already been adjusted to fit inside the monitor
                    //  dimensions)
                    prcResult->top = pinfo->prcMonitor->bottom - pinfo->cy - 1;
                }
            }
            
            bRet = TRUE;

        }
        break;
    }
    return bRet;

}


void CMenuDeskBar::_GetPopupWindowPosition(RECT* prcDesired, RECT* prcExclude, 
                                           RECT *prcResult, SIZE * psizeAdjust, UINT uSide) 
{
    PopupInfo info;
    MONITORINFO mi;
    HMONITOR hMonitor;
    RECT rcMonitor;
    int cyExtendDiff = 0;

    // Is this going to display the banner bitmap?
    if (_iIconSize == BMICON_LARGE)
    {
        // Yes; add that to the dimensions
        prcDesired->right += _sizeBmp.cx;
    }

    // First get the monitor information
    hMonitor = MonitorFromRect(prcExclude, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        rcMonitor = mi.rcMonitor;

        // Set the result rectangle same as the desired window
        prcResult->left = prcDesired->left;
        prcResult->top  = prcDesired->top;

        // Calculate some sizes needed for calculation
        info.rcAvail.left   = prcExclude->left - rcMonitor.left;
        info.rcAvail.right  = rcMonitor.right - prcExclude->right;
        info.rcAvail.top    = prcExclude->top - rcMonitor.top;
        info.rcAvail.bottom = rcMonitor.bottom - prcExclude->bottom;

        info.sizeAdjust = *psizeAdjust;
    
        info.cyMonitor = RECTHEIGHT(rcMonitor); 
        info.cxMonitor = RECTWIDTH(rcMonitor);

        info.cx  = RECTWIDTH(*prcDesired);
        info.cy = RECTHEIGHT(*prcDesired);

        // If the desired rect is bigger than monitor then clip it to the monitor size
        if (info.cy > info.cyMonitor)
            info.cy = info.cyMonitor;

        if (info.cx > info.cxMonitor)
            info.cx = info.cxMonitor;

        info.prcResult = prcResult;
        info.prcExclude = prcExclude;
        info.prcMonitor = &rcMonitor;

        //Now Adjust the rectangle for the correct position
        switch(uSide)
        {
        int iSide;

        case MENUBAR_TOP:
    
            if (WillFit(&info, TOP, FALSE))
            {
                _uSide = MENUBAR_TOP;
            }
            else 
            {
                // We couldn't fit it above, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, BOTTOM, FALSE))
                    _uSide = MENUBAR_BOTTOM;
                // We can't fit it below either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
            }
            break;

        case MENUBAR_BOTTOM:
    
            if (WillFit(&info, BOTTOM, FALSE))
            {
                _uSide = MENUBAR_BOTTOM;
            }
            else
            {   
                // We couldn't fit it below, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, TOP, FALSE))
                    _uSide = MENUBAR_TOP;

                // We can't fit it above either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
            }
            break;

        case MENUBAR_LEFT:

            if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) > (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;

        case MENUBAR_RIGHT:

            if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) >= (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;
        }
    
        // Finally set the bottom and right

        if (prcResult->top < rcMonitor.top)
            prcResult->top = rcMonitor.top;
        if (prcResult->left < rcMonitor.left)
            prcResult->left = rcMonitor.left;

        prcResult->bottom = prcResult->top  + info.cy;
        prcResult->right  = prcResult->left + info.cx;

        if (prcResult->bottom > rcMonitor.bottom)
        {
            // -2 for some breathing room at the edge of the screen
            prcResult->bottom = rcMonitor.bottom - 2;
            prcResult->top = prcResult->bottom - info.cy;
        }
    }
}


void SlideAnimate(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide)
{
    DWORD dwAnimateFlags = AW_CENTER;
    switch(uSide) 
    {
    case MENUBAR_LEFT:      dwAnimateFlags = AW_HOR_NEGATIVE;
        break;
    case MENUBAR_RIGHT:     dwAnimateFlags = AW_HOR_POSITIVE;
        break;
    case MENUBAR_TOP:       dwAnimateFlags = AW_VER_NEGATIVE;
        break;
    case MENUBAR_BOTTOM:    dwAnimateFlags = AW_VER_POSITIVE;
        break;
    }
    AnimateWindow(hwnd, 120, dwAnimateFlags | AW_SLIDE);
}

void AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate)
{
    // simple check to see if we're too big for animatewindow, based on menu area.
    // this is because it has to read from video mem to do the alpha and thats slow, maybe
    // let it back if we get hardware acceleration in a future release.
    BOOL fPerfBad = (RECTWIDTH(*prc) * RECTHEIGHT(*prc) > 600 * 200);
    if (!fNoAnimate && !fPerfBad)
    {
        BOOL fAnimate = FALSE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
        if (fAnimate)
        {
            SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top,
                    RECTWIDTH(*prc), RECTHEIGHT(*prc), uFlags);
        
            fAnimate = FALSE;
            SystemParametersInfo(SPI_GETMENUFADE, 0, &fAnimate, 0);
            if (fAnimate)
            {
                AnimateWindow(hwnd, 175, AW_BLEND);
            }
            else
            {
                SlideAnimate(hwnd, prc, uFlags, uSide);
            }
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        // Enable the show window so that it gets displayed.
        uFlags |= SWP_SHOWWINDOW;

        SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
                     uFlags);
    }
}



HRESULT CMenuDeskBar::_PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    BOOL bSetFocus = (dwFlags & MPPF_SETFOCUS);
    RECT rcDesired;
    RECT rcExclude;
    RECT rc;
    SIZE sizeAdjust;
    UINT uAnimateSide;

    BOOL bMirroredWindow=IS_WINDOW_RTL_MIRRORED(_hwnd);

    static const iPosition[] = {MENUBAR_TOP, MENUBAR_LEFT, MENUBAR_RIGHT, MENUBAR_BOTTOM};

    if (dwFlags & MPPF_POS_MASK)
    {
        UINT uPosIndex = ((dwFlags & MPPF_POS_MASK) >> 29) - 1;
        ASSERT(uPosIndex < 4);
        _uSide = iPosition[uPosIndex];
    }

    if (bSetFocus)
        SetForegroundWindow(_hwnd);
    
    _pt = *(POINT*)ppt;

    // Get the size of the ideal client rect of the child
    RECT rcChild = {0};

    // (scotth): This only sets the bottom and the right values
    _pDBC->GetSize(DBC_GS_IDEAL, &rcChild);

    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

    // Adjust for the window border style
    rcDesired = rcChild;        // use rcDesired as a temp variable
    if (!_fNoBorder)
    {
        AdjustWindowRectEx(&rcChild, dwStyle, FALSE, dwExStyle);
    }

    // Calculate the edge of the menu border, and add a fudge factor so
    // left/right-cascaded menus overlap the parent menu a bit and are
    // correctly aligned vertically.

    sizeAdjust.cx = (RECTWIDTH(rcChild) - RECTWIDTH(rcDesired)) / 2;
    sizeAdjust.cy = (RECTHEIGHT(rcChild) - RECTHEIGHT(rcDesired)) / 2;

    if (prcExclude)
    {
        CopyRect(&rcExclude, (RECT*)prcExclude);

        //
        // If mirroring is enabled, let's mirror this guy
        // by simulating a different mirrored rect. This is
        // only for dropdown menus. [samera]
        //  
        if (bMirroredWindow)           
        {
            if ((_uSide != MENUBAR_LEFT)    &&
                (_uSide != MENUBAR_RIGHT) )
            {  
                int x;
                int iW  = rcExclude.right-rcExclude.left;
                int icW = (rcChild.right-rcChild.left);


                if( icW > iW )
                {
                    x = icW - iW;
                    rcExclude.left  -= x ;
                    rcExclude.right -= x ;
                }
                else
                {
                    x = iW - icW;
                    rcExclude.left  += x;
                    rcExclude.right += x;
                }

                ppt->x = rcExclude.left;
            }

        }

        TraceMsg(DM_POPUP, "Parent Side is %d ", _uSide);
        switch(_uSide) 
        {
        case MENUBAR_LEFT :
            rcDesired.left = rcExclude.left - rcChild.right;  // right is width
            rcDesired.top  = rcExclude.top;
            break;

        case MENUBAR_RIGHT :
            rcDesired.left = rcExclude.right;
            rcDesired.top  = rcExclude.top;
            break;
            
        case MENUBAR_TOP:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.top - rcChild.bottom;  // bottom is height
            break;

        case MENUBAR_BOTTOM:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.bottom;
            break;

        default:
            rcDesired.left   = _pt.x;
            rcDesired.top    = _pt.y;
        }
    }
    else
    {
        SetRectEmpty(&rcExclude);

        rcDesired.left   = _pt.x;
        rcDesired.top    = _pt.y;
    }

    rcDesired.right  =  rcDesired.left + RECTWIDTH(rcChild);
    rcDesired.bottom =  rcDesired.top + RECTHEIGHT(rcChild);

    _GetPopupWindowPosition(&rcDesired, &rcExclude, &rc, &sizeAdjust, _uSide);

    UINT uFlags = SWP_NOOWNERZORDER;
    if (!bSetFocus)
        uFlags |= SWP_NOACTIVATE;

    //
    // Open the menus properly. In case of a RTL mirrored window,
    // flip the animation side. [samera]
    //
    if( bMirroredWindow )
    {
        switch( _uSide )
        {
        case MENUBAR_LEFT:
            uAnimateSide = MENUBAR_RIGHT;
        break;
        case MENUBAR_RIGHT:
            uAnimateSide = MENUBAR_LEFT;
        break;
        default:
            uAnimateSide = _uSide;
        }
    }
    else
    {
        uAnimateSide = _uSide;
    }

    TraceMsg(TF_MENUBAND, "CMenuBar::_PositionWindow (%d,%d,%d,%d)",
        rc.left, rc.top, rc.right, rc.bottom);

    // Last minuite tweak. Since we're in large icon, we need to add this
    // so that the bitmap is painted correctly.
    if(_iIconSize == BMICON_LARGE && _fExpanded)
        rc.right += 1;

    // We _DO_ want to do a Z-Order position when this flag is specified. This is
    // for full repositioning where we need to preserve the overlap state of all bands.
    // Otherwize we just want to size the bar without changing it's z-order.
    if (!(dwFlags & MPPF_FORCEZORDER) && 
        (S_OK == IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild,
         &CGID_MenuBand, MBANDCID_ISINSUBMENU, 0, NULL, NULL)))
    {
        uFlags |= SWP_NOZORDER;
    }

    // If it's bigger than this magical number, then we don't animate. change to taste
  
    if (RECTHEIGHT(rc) > MAGICAL_NO_FADE_HEIGHT)
        dwFlags |= MPPF_NOANIMATE;

    AnimateSetMenuPos(_hwnd, &rc, uFlags, uAnimateSide, dwFlags & MPPF_NOANIMATE);

    // Save information so we can later resize this window
    // We already have: _pt, _uSide
    if (prcExclude)
    {
        _fExcludeRect = TRUE;
        CopyRect(&_rcExclude, (RECT*)prcExclude);
    }
    else
        _fExcludeRect = FALSE;
    return S_OK;
} 

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CMenuDeskBar::Popup(POINTL* ppt, RECTL* prcExclude, DWORD dwFlags)
{
    HRESULT hr;

    // Is the caller telling us to reposition?
    if (dwFlags & MPPF_REPOSITION)
    {
        if (ppt == NULL)
            ppt = (POINTL*)&_pt;

        if (prcExclude == NULL)
            prcExclude = (RECTL*)&_rcExclude;

        // Yes; Then we don't need to do any First show stuff.
        _PositionWindow(ppt, prcExclude, dwFlags);
        return S_OK;
    }

    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    if (_pmpParent) 
    {
        _pmpParent->SetSubMenu(this, TRUE);
    }

    IOleCommandTarget* poct;
    hr = IUnknown_QueryService(_punkChild, SID_SMenuBandChild, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (SUCCEEDED(hr))
    {
        // We need to do this before the ShowDW. This saves us from doing the setting twice
        // Because in the ShowDW of MenuBand, we actually go an initialize the toolbar with
        // the current default setting which should be "No Keyboard Cues." If we set the state
        // here, then the state will be "Show keyboard cues." Then we will update the toolbar. 
        if (dwFlags & MPPF_KEYBOARD)
            poct->Exec(&CGID_MenuBand, MBANDCID_KEYBOARD, 0, NULL, NULL);
    }
    else
    {
        ASSERT(poct == NULL);
    }
    
    _NotifyModeChange(_dwMode);
    hr = ShowDW(TRUE);

    if (SUCCEEDED(hr) && _pmpParent)
    {
        VARIANT varg;
        // If this Exec fails, don't panic; it just means we use the default side
        if (SUCCEEDED(IUnknown_Exec(_pmpParent, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &varg)))
        {
            if (varg.vt == VT_I4)
            {
                _uSide = (UINT) varg.lVal;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        SHPlaySound(TEXT("MenuPopup"));

        _PositionWindow(ppt, prcExclude, dwFlags);

        // Set focus
        UIActivateIO(TRUE, NULL);
    
        _fActive = TRUE;

        // Select the first/last item?
        if ((dwFlags & (MPPF_INITIALSELECT | MPPF_FINALSELECT)) && poct)
        {
            DWORD nCmd = (dwFlags & MPPF_INITIALSELECT) ? MBSI_FIRSTITEM : MBSI_LASTITEM;
            poct->Exec(&CGID_MenuBand, MBANDCID_SELECTITEM, nCmd, NULL, NULL);
        }
    }

    ATOMICRELEASE(poct);
    
    return hr;
} 


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

Returns: 
Cond:    --
*/
HRESULT CMenuDeskBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CMenuDeskBar::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    if (_fShow)
        _PopDown();

    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pmpParent);
    
    _punkSite = punkSite;
    
    if (_punkSite)
    {    
        _punkSite->AddRef();
        IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &_pmpParent));
    }
    else
    {
        CloseDW(0);
    }
        
    return S_OK;
} 


/*----------------------------------------------------------
Purpose: IObjectWithSite::GetSite method

*/
STDMETHODIMP CMenuDeskBar::GetSite(REFIID riid, LPVOID* ppvSite)
{
    if (_punkSite)
    {
        return _punkSite->QueryInterface(riid, ppvSite);
    }

    *ppvSite = NULL;
    return E_FAIL;
} 

void CMenuDeskBar::AdjustForTheme()
{
    if (_fFlatMenuMode)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_BORDER);
    }
    else if (!_fExpanded)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_CLIPCHILDREN | WS_DLGFRAME);
    }
}


/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec method

*/
STDMETHODIMP CMenuDeskBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBCID_EMPTY:
            // if we have no bands left, close
            OnSelect(MPOS_FULLCANCEL);
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case MBCID_GETSIDE :
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _GetSide();
                return S_OK;

            case MBCID_RESIZE:
                if (_fActive)
                {
                    if (_fExcludeRect)
                        _PositionWindow((POINTL *)&_pt, (RECTL *)&_rcExclude, 0);
                    else
                        _PositionWindow((POINTL *)&_pt, NULL, 0);
                }
                return S_OK;

            case MBCID_SETEXPAND:
                if ((BOOL)_fExpanded != (BOOL)nCmdexecopt && !_fFlatMenuMode)
                {
                    _fExpanded = nCmdexecopt;

                    SetExpandedBorder(_hwnd, _fExpanded);
                }
                return S_OK;

            case MBCID_SETFLAT:
                {
                    _fFlatMenuMode = BOOLIFY(nCmdexecopt);
                    AdjustForTheme();
                }
                break;

            case MBCID_NOBORDER:
                {
                    _fNoBorder = BOOLIFY(nCmdexecopt);
                    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
                }
                break;

            default : 
                return OLECMDERR_E_NOTSUPPORTED;

        }   
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}    

    
/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuPopup)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
             IsEqualIID(guidService, SID_SMenuBandChild))
    {
        // SID_SMenuBandBottom queries down
        return IUnknown_QueryService(_punkChild, guidService, riid, ppvObj);
    }
    else
    {
        HRESULT hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
        
        if (FAILED(hres))
        {
            hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
        }
        
        return hres;
    }
        
} 

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetIconSize(DWORD iIcon)
{
    HRESULT hres;

    _iIconSize = iIcon;

    hres = IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild, &CGID_MenuBand, 
        MBANDCID_SETICONSIZE, iIcon == BMICON_SMALL? ISFBVIEWMODE_SMALLICONS: ISFBVIEWMODE_LARGEICONS, NULL, NULL);


    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetBitmap(HBITMAP hBitmap)
{
    ASSERT(hBitmap);
    BITMAP bm;
    _hbmp = hBitmap;

    if (_hbmp)
    {
        if(!GetObject(_hbmp, sizeof(bm), &bm))
            return E_FAIL;
        _sizeBmp.cx = bm.bmWidth;
        _sizeBmp.cy = bm.bmHeight;

        // Hack to get color
        HDC hdc = GetDC(_hwnd);
        if (hdc)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, _hbmp);
                _rgb = GetPixel(hdcMem, 0, 0);
                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }
            ReleaseDC(_hwnd, hdc);
        }
    }

    return NOERROR;
}

void CMenuDeskBar::_OnSize()
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);

    if(_iIconSize == BMICON_LARGE)
    {
        rc.left += _sizeBmp.cx;
        if (_fExpanded)
            rc.left++;
    }

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER|SWP_FRAMECHANGED);

    rc.right = rc.left;
    rc.left -= _sizeBmp.cx;
    if (_fShow)
        InvalidateRect(_hwnd, &rc, TRUE);
}

LRESULT CMenuDeskBar::_DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags)
{
    HDC hdcmem;
    HBITMAP hbmpOld;
    RECT rc;
    HBRUSH   hbrush;
    int iDC = SaveDC(hdc);

    GetClientRect(hwnd, &rc);

    //Create a compatable DC
    hdcmem = CreateCompatibleDC(hdc);
    if(hdcmem)
    {
        // Offset the stuff we're paining if we're expanded
        BYTE bOffset = 0;
        // Store this for the Bar fill cycle
        int cyBitmap = 0;

        if (!_fFlatMenuMode)
        {
            bOffset = _fExpanded? 1 : 0;
        }

        if (_sizeBmp.cy <= RECTHEIGHT(rc) + 1)
        {
            //Select the bitmap into the memory DC
            hbmpOld = (HBITMAP)SelectObject(hdcmem, _hbmp);

            //Blit to the window
            BitBlt(hdc, bOffset, rc.bottom - _sizeBmp.cy - bOffset, _sizeBmp.cx, _sizeBmp.cy, hdcmem, 0, 0, SRCCOPY);

            // Ok, We need to subtract this value to see how much we need to paint for the banner.
            cyBitmap = _sizeBmp.cy;

            //Restore the DC
            SelectObject(hdcmem, hbmpOld);
        }

        rc.right = _sizeBmp.cx + bOffset;

        if (_fExpanded && !_fFlatMenuMode && !_fNoBorder)
            DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_LEFT | BF_TOP | BF_BOTTOM);

        //Paint the rest
        hbrush = CreateSolidBrush(_rgb);
        if(hbrush)
        {
            rc.bottom -= cyBitmap + bOffset;

            if (_fExpanded)
            {
                rc.left += bOffset;
                rc.top += bOffset;
            }

            FillRect(hdc, &rc, hbrush);
            DeleteObject(hbrush);
        }


        //Delete the DC.
        DeleteDC(hdcmem);
    }

    RestoreDC(hdc, iDC);
    return 0;
}

void CMenuDeskBar::_DoNCPaint(HWND hwnd, HDC hdc)
{
    if (!_fNoBorder)
    {
        RECT rc;

        // Since we need to paint the border, we get the window rect
        GetWindowRect(hwnd, &rc);
        // then change the rect so that it represents values relative to 
        // the origin.
        OffsetRect(&rc, -rc.left, -rc.top);

        if (hdc)
        {
            if (_fFlatMenuMode)
            {
                SHOutlineRect(hdc, &rc, GetSysColor(COLOR_3DSHADOW));
            }
            else 
                DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);
        }
    }
}


LRESULT CMenuDeskBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    LRESULT lres;

    switch (uMsg) 
    {
#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
        break;
#endif

    case WM_GETOBJECT:
        if ((DWORD)lParam == OBJID_MENU)
        {
            IAccessible* pacc;
            if (SUCCEEDED(QueryService(SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc))))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
                pacc->Release();

                return lres;
            }
        }
        break;


    case WM_NCCREATE:
        //
        // Since this is a mirrored menu, then open it
        // on the left (mirrored) edge if possible. WillFit(...) will
        // ensure this for us [samera]
        //
        // Mirror the menu initially if its window is mirrored
        //
        ASSERT(_uSide == 0);
        if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            _uSide = MENUBAR_LEFT;
        else
            _uSide = MENUBAR_RIGHT;
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) 
        {
            if (_fActive && !_pmpChild) 
            {
                
                // if we were active, and the thing going active now
                // is not one of our parent menubars, then cancel everything.
                
                // if it's a parent of ours going active, assume that
                // they will tell us to die when they want us to...
                if (!_IsMyParent((HWND)lParam))
                    OnSelect(MPOS_FULLCANCEL);
            }
        } 
        else 
        {
            if (_pmpChild) 
            {
                // if we're becoming active, and we have a child, that child should go away
                _pmpChild->OnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case WM_PRINTCLIENT:
        if (_iIconSize == BMICON_LARGE)
        {
            _DoPaint(hwnd, (HDC)wParam, (DWORD)lParam);
            return 0;
        }
        break;

    case WM_PAINT:
        // Paint the banner if we're in showing large icons
        if (_iIconSize == BMICON_LARGE)
        {
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            _DoPaint(hwnd, ps.hdc, 0);
            EndPaint(hwnd, &ps);
            return 0;
        }
        break;

   case WM_PRINT:
        if ((_fFlatMenuMode || _fExpanded) && PRF_NONCLIENT & lParam)
        {
            HDC hdc = (HDC)wParam;

            DefWindowProcWrap(hwnd, WM_PRINT, wParam, lParam);

            // Do this after so that we look right...
            _DoNCPaint(hwnd, hdc);

            return 1;
        }
        break;

    case WM_NCCALCSIZE:
        if (_fNoBorder)
        {
            return 0;
        }
        else
        {
            return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        break;

    case WM_NCPAINT:
        if (_fNoBorder)
        {
            return 0;
        }
        else if (_fExpanded || _fFlatMenuMode)
        {    
            HDC hdc;    
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                _DoNCPaint(hwnd, hdc);
                ReleaseDC(hwnd, hdc);
            }
            return 1;
        } 
        break;

    case WM_NCHITTEST:
        lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

        switch (lres)
        {
        case HTBOTTOM:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTLEFT:
        case HTRIGHT:
        case HTTOP:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            // Don't allow the window to be resized
            lres = HTBORDER;
            break;

        case HTTRANSPARENT:
            // Don't let a click go thru to the window underneath
            lres = HTCLIENT;
            break;

        }
        return lres;

        // HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
        // (lamadio) 1.25.99
        // This hack is here to fix a problem on down level Windows with Integrated
        // IE4.01, IE5 and Office 2000.
        // The bug revolves around Start Menu not being destroyed when Explorer.exe shuts
        // down. Start Menu unregisters itself at CloseDW, but since the menubar never gets
        // destroyed, Start Menu never deregisters itself.
        // When an System service, such as MSTASK.dll keeps shell32 alive in the background,
        // it leaves an outstanding reference to a change notify. When a new user logs in,
        // O2k and IE5 fire up group conv, generating more than 10 change notify events in the
        // start menu. This causes the batching code to be fired up: Which does not really
        // work without the shell started. GroupConv also adds these events using memory 
        // alloced from it's process heap. Since there is an outstanding change notify handler
        // these pidls get forced to be handled. Shell32 then faults derefing a bad pidl.
        // By detecting an Endsession, we can eliminate this problem. Doing a SetClient(NULL)
        // cause Menubar to free it's references to MenuSite. Menusite, calls CloseDW on menuband
        // menuband then causes MNFolder to unregister itself. Since no one is listening any more
        // the crash is avoided.

    case WM_ENDSESSION:
        if (wParam != 0)
        {
            SetClient(NULL);
        }
        break;

    }
    
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
} 

IMenuPopup* CMenuDeskBar::_GetMenuBarParent(IUnknown* punk)
{
    IMenuPopup *pmp = NULL;
    IObjectWithSite* pows;
    punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));

    if (pows)
    {    
        IServiceProvider* psp;
        pows->GetSite(IID_PPV_ARG(IServiceProvider, &psp));
        
        if (psp)
        {    
            psp->QueryService(SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
            psp->Release();
        }
        
        pows->Release();
    }
    
    return pmp;
}


// this assumes that hwnd is a toplevel window and that the menudeskbars are also 
// the only hosts and are themselves toplevel
BOOL CMenuDeskBar::_IsMyParent(HWND hwnd)
{
    BOOL fRet = FALSE;
    if (hwnd)
    {
        HWND hwndMenu;
        
        IMenuPopup *pmpParent = _pmpParent;
        if (pmpParent)
            pmpParent->AddRef();
        
        while (pmpParent && !fRet &&
               SUCCEEDED(IUnknown_GetWindow(pmpParent, &hwndMenu)))
        {
            if (hwndMenu == hwnd)
            {
                fRet = TRUE;
            }
            
            IMenuPopup* pmpNext = _GetMenuBarParent(pmpParent);
            pmpParent->Release();
            pmpParent = pmpNext;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\logo.h ===
#ifndef _LOGO_H
#define _LOGO_H

typedef HRESULT (* LPUPDATEFN)( void *pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

#define LOGO_HEIGHT 32
#define LOGO_WIDE_WIDTH 194
#define LOGO_WIDTH  80

class CLogoBase
{
public:
    CLogoBase( BOOL fWide = FALSE );
    ~CLogoBase();

    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    virtual IShellFolder * GetSF() PURE;
    virtual HWND GetHWND() PURE;

    inline HIMAGELIST GetLogoHIML( void );
    
    // intialisation functions
    HRESULT InitLogoView( void );
    HRESULT ExitLogoView( void );

    int GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    int GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick );

    HRESULT AddTaskToQueue( IRunnableTask *pTask, DWORD dwPriority, DWORD lParam );
    
    // create the default logo for an item....
    HRESULT CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo);

    HRESULT AddRefLogoCache( void );
    HRESULT ReleaseLogoCache( void );

    // get the task ID used with the task scheduler
    virtual REFTASKOWNERID GetTOID( void ) PURE;

    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache ) PURE;

    int AddIndicesToLogoList( int iIcon, UINT uIndex );

protected:
    
    int GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    
    IImageCache * _pLogoCache;              // My be NULL in low memory conditions.
    IShellTaskScheduler * _pTaskScheduler;
    HIMAGELIST _himlLogos;
    SIZEL _rgLogoSize;
    DWORD _dwClrDepth;
    HDSA  _hdsaLogoIndices;

    static CRITICAL_SECTION s_csSharedLogos;
    static long             s_lSharedWideLogosRef;
    static IImageCache *    s_pSharedWideLogoCache;
    static HDSA             s_hdsaWideLogoIndices;

    HPALETTE _hpalHalftone;
    BOOL     _fWide;
};

inline HIMAGELIST CLogoBase::GetLogoHIML( )
{
    return _himlLogos;
}

struct LogoIndex
{
    int iIcon;
    int iLogo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menuband.h ===
#ifndef _MENUBAND_H_
#define _MENUBAND_H_

#include "bands.h"
#include "mnbase.h"

#include "legacy.h"

// Flags for MBANDCID_POPUPITEM

#define MBPUI_SETITEM           0x00001
#define MBPUI_INITIALSELECT     0x00002
#define MBPUI_ITEMBYPOS      0x00004

#ifdef STARTMENUSPLIT
// Flags for constructor
#define MENUBAND_HORIZ      0x00000001
#define MENUBAND_TOPLEVEL   0x00000002
#endif

// Special indices for MBANDCID_SELECTITEM
#define MBSI_FIRSTITEM       0
#define MBSI_NONE           -1
#define MBSI_LASTITEM       -2

// This arrow is used when we are in Right-To-Left Mirror mode
#define CH_MENUARROWRTLA '3'

// Forward declare
struct CMBMsgFilter;

// Define this to get Shell Expando menu style
// Undefine to get "Office IntelliMenu" style
//#define DRAWEDGE

// The CMenuBand class handles all menu behavior for bands.  

class CMenuBandMetrics : public IUnknown
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HFONT   _CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
        int* pcy, int* pcxMargin, int iOrientation, int iWeight);
    void    _SetMenuFont();         // (Called for TopLevMBand only) Sets: _hFontMenu
    void    _SetArrowFont(HWND hwnd);        // (Called for TopLevMBand only) Sets: _hFontArrow, _cyArrow
    void    _SetChevronFont(HWND hwnd);
    void    _SetTextBrush(HWND hwnd);

#ifndef DRAWEDGE
    void    _SetPaintMetrics(HWND hwnd);
#endif
    void    _SetColors();
    int     _cyArrow;               // Height of cascade arrow
    int     _cxArrow;               // Width of cascade arrow
    int     _cxMargin;              // Margin b/t text and arrow
    int     _cyChevron;
    int     _cxChevron;
    int     _cxChevronMargin;
    HCURSOR _hCursorOld;            // Cursor that was in use prior to entering menu mode
    HFONT   _hFontMenu;             // Font for menu text
    HFONT   _hFontArrow;            // Correct sized Marlett font for cascade arrow
    HFONT   _hFontChevron;
    HBRUSH  _hbrText;
#ifndef DRAWEDGE
    HPEN    _hPenHighlight;            // Pen for BTNHIGHLIGHT
    HPEN    _hPenShadow;               // Pen for BTNSHADOW
#endif

    COLORREF _clrBackground;
    COLORREF _clrDemoted;
    COLORREF _clrMenuText;
    COLORREF _clrMenuGrad;

    BOOL  _fHighContrastMode;        // Accessibility
    BOOL  _fFlatMenuMode;
    BOOL  _fInit;

    CMenuBandMetrics();
    void Init(HWND hwnd);

private:
    ~CMenuBandMetrics();

    ULONG _cRef;
};


class CMenuBandState
{

    // Global State Variables
    BYTE    _fsUEMState;
    BOOL    _fKeyboardCue;
    IFadeTask* _ptFader;
    IShellTaskScheduler* _pScheduler;
    HWND    _hwndSubclassed;
    HWND    _hwndToolTip;
    HWND    _hwndWorker;
    void*   _pvContext;

    // Bits
    BITBOOL _fExpand: 1;
    BITBOOL _fContainsDrag: 1;
    BITBOOL _fTipShown: 1;
    BITBOOL _fBalloonStyle: 1;

    int     _cChangeNotify;

    // This will, in the future, contain the menuband stack
public:
    CMenuBandState();
    virtual ~CMenuBandState();

    // Set/Get the expand state for new popups.
    BOOL GetExpand()                { return (BOOL)_fExpand;      };
    void SetExpand(BOOL fExpand)    { _fExpand = BOOLIFY(fExpand);};
    BYTE GetUEMState()              { return _fsUEMState;         };
    void SetUEMState(BYTE bState)   { _fsUEMState = bState;       };
    BOOL GetKeyboardCue();
    void SetKeyboardCue(int iKC);
    BOOL HasDrag()                  { return _fContainsDrag;      };
    void HasDrag(BOOL fHasDrag)     { _fContainsDrag = BOOLIFY(fHasDrag); };
    void SetSubclassedHWND(HWND hwndSubclassed)   
                                    { _hwndSubclassed = hwndSubclassed; };
    HWND GetSubclassedHWND()        { return _hwndSubclassed; };
    HWND GetWorkerWindow(HWND hwndParent);
    void PushChangeNotify()         { ++_cChangeNotify; };
    void PopChangeNotify()          { --_cChangeNotify; };
    BOOL IsProcessingChangeNotify() { return _cChangeNotify != 0;   };

    // Context Stuff
    // a menuband context is used for the global message filter. Since we may have
    // more than one menu present in the system, there is a race condition that can occur
    // where the menu in one thread tries to pop off it's menus, when a menuband in another thread
    // tries to push them on. Through the use of a context, we can know when this is happening and
    // make sure that we pop all of the menus of one context before pushing from another.
    // - lamadio 9.15.98
    void SetContext(void* pvContext)    {_pvContext = pvContext;};
    void* GetContext()                  { return _pvContext;};

    // Fade Stuff
    HRESULT FadeRect(LPCRECT prc);
    void CreateFader();
    IShellTaskScheduler* GetScheduler();

    // Chevron Tip Stuff
    void CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR szTip);
    void HideTooltip(BOOL fAllowBalloonCollapse);
    void PutTipOnTop();
};



interface IShellMenuAcc: public IUnknown
{
    // *** IShellMenuAcc methods ***
    STDMETHOD(GetTop)(THIS_ CMenuToolbarBase** ppmtbTop) PURE;
    STDMETHOD(GetBottom)(THIS_ CMenuToolbarBase** ppmtbBottom) PURE;
    STDMETHOD(GetTracked)(THIS_ CMenuToolbarBase** ppmtbTracked) PURE;
    STDMETHOD(GetParentSite)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD(GetState)(THIS_ BOOL* pfVertical, BOOL* pfOpen) PURE;
    STDMETHOD(DoDefaultAction)(THIS_ VARIANT* pvarChild) PURE;
    STDMETHOD(GetSubMenu)(THIS_ VARIANT* pvarChild, REFIID riid, void** ppvObj) PURE;
    STDMETHOD(IsEmpty)() PURE;
};

// {FAF6FE96-CE5E-11d1-8371-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuAcc,              0xfaf6fe96, 0xce5e, 0x11d1, 0x83, 0x71, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);



class CMenuBand : public CToolBand,
                  public IMenuPopup,
                  public IMenuBand,
                  public IShellMenu2,
                  public IWinEventHandler,
                  public IShellMenuAcc
{
    // REVIEW (lamadio): I don't like this. Should I make these nested classes?
    friend class CMenuToolbarBase;
    friend class CMenuSFToolbar;
    friend class CMenuStaticToolbar;
    friend class CToolbarMenu;
    friend struct CMBMsgFilter;

public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) { return E_NOTIMPL; };

    // *** IMenuBand methods ***
    virtual STDMETHODIMP IsMenuMessage(MSG * pmsg);
    virtual STDMETHODIMP TranslateMenuMessage(MSG * pmsg, LRESULT * plRet);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    // ** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IStream*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Save(IStream*, BOOL) { return E_NOTIMPL; };

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);


    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // *** IShellMenuAcc ***
    virtual STDMETHODIMP GetTop(CMenuToolbarBase** ppmtbTop);
    virtual STDMETHODIMP GetBottom(CMenuToolbarBase** ppmtbBottom);
    virtual STDMETHODIMP GetTracked(CMenuToolbarBase** ppmtbTracked);
    virtual STDMETHODIMP GetParentSite(REFIID riid, void** ppvObj);
    virtual STDMETHODIMP GetState(BOOL* pfVertical, BOOL* pfOpen);
    virtual STDMETHODIMP DoDefaultAction(VARIANT* pvarChild);
    virtual STDMETHODIMP GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP IsEmpty();
    
    // Other methods
    LRESULT GetMsgFilterCB(MSG * pmsg, BOOL bRemove);
    inline BOOL IsInSubMenu(void)       { return _fInSubMenu; };
    inline DWORD GetFlags()   {return _dwFlags; };
    
    // Other public methods
    void    ResizeMenuBar();        // Make our parent menubar resize
    void    SetTrackMenuPopup(IUnknown* punk);
    HRESULT ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);   // Change notify Forwarder.

    CMenuBand();


    BOOL    SetTracked(CMenuToolbarBase* pmtb);

private:

    friend HRESULT CMenuBand_CreateInstance(IUnknown * punkOuter, REFIID riid, void **ppv);
    friend VOID CALLBACK CMenuBand_TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );
    friend CMenuBand * CMenuBand_Create(IShellFolder* psf, LPCITEMIDLIST pidl,
                             BOOL bHorizontal);


    virtual ~CMenuBand();

    HRESULT _Initialize(DWORD dwFlags);// Flags are MENUBAND_*

    HRESULT _EnterMenuMode(void);
    void    _ExitMenuMode(void);
    void    _GetFontMetrics();      // (Called for non-TopLevelMBands) Uses IUnk_QS to set
                                    //  _hFontMenu, _hFontArrow, _cyArrow based on TopLevel's values
    void    _CancelMode(DWORD dwType);
    HRESULT _AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags);
    HRESULT _SiteOnSelect(DWORD dwType);
    HRESULT _SubMenuOnSelect(DWORD dwType);

    HRESULT _OnSysChar(MSG * pmsg, BOOL bFirstDibs);
    HRESULT _HandleAccelerators(MSG * pmsg);

    HRESULT _SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet);

    void    _OnSelectArrow(int iDir);
    void    _UpdateButtons();

    HRESULT _CallCB(DWORD dwMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    HRESULT _ProcessMenuPaneMessages(MSG* pmsg);

    
    // Member variables
    int     _nItemCur;              // Current item selected
    int     _nItemNew;              // New item to be selected/expanded
    int     _nItemTimer;            // the timer id for popping up cascading menus
    int     _nItemMove;             // Current item being moved
    int     _nItemSubMenu;          // item that's cascaded
    HWND    _hwndFocusPrev;
    HWND    _hwndParent;
    BOOL    _fNoBorder;
    WCHAR*  _pszTheme;

    CMenuToolbarBase*   _pmtbMenu;          // The static menu toolbar 
                                            //  (may be pmtbTop or pmtbBottom)
    CMenuToolbarBase*   _pmtbShellFolder;   // Non-menu toolbar (shellfolder or other)
                                            //  (may be pmtbTop or pmtbBottom)
    
    CMenuToolbarBase*   _pmtbTop;           // The top toolbar
    CMenuToolbarBase*   _pmtbBottom;        // The bottom toolbar (may be == pmtbTop)
    CMenuToolbarBase*   _pmtbTracked;       // This is transient, may be pmtbTop or pmtbBottom

    IAugmentedShellFolder2* _pasf2;

    UINT    _uId;       // Id of this band (Derived from the item that poped it up)
    UINT    _uIdAncestor;   // Id of the top most menu item.
    HMENU   _hmenu;
    HWND    _hwndMenuOwner;
    DWORD   _dwMenuFlags;


    CMenuBandState*     _pmbState;              // Menu Band global state
    CMenuBandMetrics*   _pmbm;
    IShellMenuCallback* _psmcb;             // Callback Mechanism
    HCURSOR             _hCursorOld;
    DWORD               _dwFlags;
    UINT                _uIconSize;

    IMenuPopup*         _pmpSubMenu;        // Cached submenu
    IMenuPopup*         _pmpTrackPopup;     // Find a way to use only menubands.

    void*               _pvUserData;        // User associated data.


    BITBOOL _fTopLevel: 1;          // TRUE: this is the toplevel parent menu
                                    //       (may be vertical for context menus)
    BITBOOL _fMenuMode: 1;          // TRUE: we are in menu mode
    BITBOOL _fPopupNewMenu: 1;      // TRUE: popup a new menu (_nItemNew) 
                                    //    once done with current menu
    BITBOOL _fInitialSelect: 1;     // TRUE: select first item when popping up submenu
    BITBOOL _fInSubMenu: 1;         // TRUE: currently in a submenu
    BITBOOL _fAltSpace: 1;          // TRUE: Alt-space was hit
    BITBOOL _fMenuFontCreated: 1;   // TRUE: This instance created the font and should delete it
    BITBOOL _fArrowFontCreated: 1;  // TRUE: This instance created the font and should delete it
    BITBOOL _fEmpty: 1;             // TRUE: Menu is empty
    BITBOOL _fParentIsNotASite: 1;  
    BITBOOL _fKeyboardSelected: 1;  
    BITBOOL _fInvokedByDrag: 1;     // TRUE: the menu cascaded open b/c of drag/drop
    BITBOOL _fDragEntered : 1;
    BITBOOL _fSysCharHandled: 1;    // TRUE: WM_SYSCHAR was already handled
    BITBOOL _fHasSubMenu:1;
    BITBOOL _fAppActive:1;       // TRUE: The Menus should be drawn using Memphis' grey menu.
    BITBOOL _fVertical: 1;
    BITBOOL _fShow : 1;
    BITBOOL _fClosing: 1;           // TRUE: When CloseDW is called.
    BITBOOL _fForceButtonUpdate: 1; // TRUE: Force a v_UpdateButtons.
    BITBOOL _fProcessingDup: 1;     // TRUE: when the contained classes are processing Dup chars.
    BITBOOL _fExpanded: 1;          // TRUE: This band is expanded
    BITBOOL _fCascadeAnimate: 1;
    BITBOOL _fPopupNewItemOnShow: 1;    // Causes _nItemNew to be displayed at ShowDW time.
    BITBOOL _fParentIsHorizontal: 1;

#ifdef DEBUG
    BITBOOL _fInitialized: 1;
#endif
    

    DEBUG_CODE( int _nMenuLevel; )
};

HRESULT IUnknown_BandChildSetKey(IUnknown* punk, HKEY hKey);

// The message filter redirects messages to the menuband
// that is at the top of the stack.  Each additional cascade
// pushes the new menuband onto the stack, and a cancel-level
// pops one off.
typedef struct tagMBELEM
{
    CMenuBand * pmb;
    HWND        hwndTB;
    HWND        hwndBar;
    RECT        rc;             // rect of hwndBar
    BITBOOL     bInitRect: 1;   // TRUE: rc is initialized
} MBELEM;

#define CMBELEM_INIT    10
#define CMBELEM_GROW    10

struct CMBMsgFilter
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndCapture;
    FDSA        _fdsa;              // Stack
    MBELEM      _rgmbelem[CMBELEM_INIT];
    BITBOOL     _fPreventCapture : 1;
    BITBOOL     _fInitialized: 1;
    BITBOOL     _fSetAtPush: 1;
    BITBOOL     _fDontIgnoreSysChar: 1;
    BITBOOL     _fEngaged: 1;
    BITBOOL     _fModal: 1;
    BITBOOL     _fAllocated: 1;
    POINT       _ptLastMove;
    CMenuBand*  _pmb;
    int         _iSysCharStack;
    void*       _pvContext;
    HCURSOR     _hcurArrow;
    int         _cRef;

    DEBUG_CODE( int _nMenuLevel; )
    void    AddRef();
    void    Release();


    void    ForceModalCollapse();
    void    SetModal(BOOL fModal);      // This is so that
                                        // a modal message band (Links)
                                        // sets activation correctly.
    void*   GetContext()    {   return _pvContext;  };
    void    SetContext(void* pvContext, BOOL fSet);
    void    Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite);
    int     Pop(void* pvContext);
    void    RetakeCapture(void);
    void    AcquireMouseLocation()   { GetCursorPos(&_ptLastMove); };


    void    ReEngage(void* pvContext);
    void    DisEngage(void* pvContext);
    BOOL    IsEngaged()  { return _fEngaged;};

    CMenuBand * _GetBottomMostSelected(void);
    CMenuBand * _GetTopPtr(void);
    CMenuBand * _GetWindowOwnerPtr(HWND hwnd);
    CMenuBand * _HitTest(POINT pt, HWND * phwnd = NULL);
    LRESULT     _HandleMouseMsgs(MSG * pmsg, BOOL bRemove);
    HRESULT     _TopFilterMouseMessage(MSG *pmsg, BOOL bRemove, CMenuBand *pmbTarget);
    void        PreventCapture(BOOL bSet) { _fPreventCapture = BOOLIFY(bSet); }
    CMenuBand * GetTopMostPtr(void)         { return _pmb; };
    void        SetTopMost(CMenuBand* pmb)  {_pmb = pmb; };
    void        SetHook(BOOL fSet, BOOL fIgnoreSysChar); 

    static LRESULT CALLBACK GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
};

CMBMsgFilter* GetMessageFilter();


extern CMBMsgFilter g_msgfilter;
extern UINT    g_nMBPopupOpen;
extern UINT    g_nMBFullCancel;
extern UINT    g_nMBDragCancel;
extern UINT    g_nMBAutomation;
extern UINT    g_nMBExecute;
extern UINT    g_nMBOpenChevronMenu;


#define MBTIMER_POPOUT      0x00008001         // event ID for popout menu timer
#define MBTIMER_DRAGOVER    0x00008002         // event ID for popout menu timer
#define MBTIMER_EXPAND      0x00008003
#define MBTIMER_TIMEOUT     (GetDoubleClickTime() * 4 / 5) // same formula that USER uses

#define MBTIMER_ENDEDIT     0x00008004
#define MBTIMER_ENDEDITTIME 1000

#define MBTIMER_CLOSE       0x00008005
#define MBTIMER_CLOSETIME   2000

#define MBTIMER_CLICKUNHANDLE 0x00008006

// Flashing Support
#define MBTIMER_FLASH       0x00008007
#define MBTIMER_FLASHTIME   100
#define COUNT_ENDFLASH      8

// UEM Profiling.
#define MBTIMER_UEMTIMEOUT  0x00008008

#define MBTIMER_DRAGPOPDOWN 0x00008009
#define MBTIMER_DRAGPOPDOWNTIMEOUT     (2 * GetDoubleClickTime()) //ASSERT(MBTIMER_DRAGPOPDOWNTIMEOUT > 
                                                        // MBTIMER_TIMEOUR)

#define MBTIMER_CHEVRONTIP  0x0000800A

#define MBTIMER_INFOTIP     0x0000800B
#define CH_RETURN       0xd

#define szfnMarlett     TEXT("MARLETT")

#endif  // _MENUBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menuisf.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "resource.h"
#include "caggunk.h"
#include "menuisf.h"
#include "menubar.h"
#include "menuband.h"
#include "iaccess.h"
#include "apithk.h"

//=================================================================
// Implementation of CMenuAgent
//
//  The single global object of this class (g_menuagent) is the
//  manager of the message filter proc used to track mouse and
//  keyboard messages on behalf of CTrackPopupBar while a menu is
//  in a modal menu loop in TrackPopupMenu.
//
//  We track these messages so we can pop out of the menu, behaving
//  as if the visual menu bar consisted of a homogeneous menu
//  object.
//
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);

struct CMenuAgent
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndSite;          // hwnd to receive forwarded messages
    HWND        _hwndParent;
    CTrackPopupBar * _ptpbar;
    IMenuPopup * _pmpParent;
    void*       _pvContext;

    BITBOOL     _fEscHit: 1;

    // we need to keep track of whether the last selected
    // menu item was on a popup or not.  we can do this by storing the 
    // last WM_MENUSELECT flags
    UINT        _uFlagsLastSelected; 
    HMENU       _hmenuLastSelected;
    POINT       _ptLastMove;

    void    Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, HWND hwndParent, HWND hwndSite);
    void    Reset(void* pvContext);
    void    CancelMenu(void* pvContext);

    static LRESULT CALLBACK MsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
    void _OnMenuSelect(HMENU hmenu, int i, UINT uFlags);
    BOOL _OnKey(WPARAM vkey);
};

// Just one of these, b/c we only need one message filter
CMenuAgent g_menuagent = { 0 };     


/*----------------------------------------------------------
Purpose: Initialize the message filter hook

*/
void CMenuAgent::Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, 
                      HWND hwndParent, HWND hwndSite)
{
    TraceMsg(TF_MENUBAND, "Initialize CMenuAgent");

    ASSERT(IS_VALID_READ_PTR(ptpbar, CTrackPopupBar));
    ASSERT(IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(IS_VALID_HANDLE(hwndSite, WND));

    if (_pvContext != pvContext)
    {
        // When switching contexts, we need to collapse the old menu. This keeps us from
        // hosing the menubands when switching from one browser to another.
        CancelMenu(_pvContext);
        ATOMICRELEASE(_ptpbar);
        ATOMICRELEASE(_pmpParent);
        _pvContext = pvContext;
    }

    pmpParent->SetSubMenu(ptpbar, TRUE);

    _hwndSite = hwndSite;
    _hwndParent = hwndParent;

    // Since the message hook wants to forward messages to the toolbar,
    // we need to ask the pager control to do this
    Pager_ForwardMouse(_hwndSite, TRUE);

    _pmpParent = pmpParent;
    _pmpParent->AddRef();

    _ptpbar = ptpbar;
    _ptpbar->AddRef();

    if (NULL == _hhookMsg)
    {
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);
    }

    _fEscHit = FALSE;

    GetCursorPos(&_ptLastMove);
}


/*----------------------------------------------------------
Purpose: Reset the menu agent; no longer track mouse and keyboard
         messages.  The menuband calls this when it exits menu mode.

*/
void CMenuAgent::Reset(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        _pmpParent->SetSubMenu(_ptpbar, FALSE);

        // The only time to not send MPOS_FULLCANCEL is if the escape
        // key caused the menu to terminate.

        if ( !_fEscHit )
            _pmpParent->OnSelect(MPOS_FULLCANCEL);

        // Eat any mouse-down/up sequence left in the queue.  This is how 
        // we keep the toolbar from getting a mouse-down if the user 
        // clicks on the same menuitem as what is currently popped down.
        // (E.g., click File, then click File again.  W/o this, the menu
        // would never toggle up.)

        MSG msg;

        while (PeekMessage(&msg, _hwndSite, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
            ;   // Do nothing

        Pager_ForwardMouse(_hwndSite, FALSE);

        _hwndSite = NULL;
        _hwndParent = NULL;

        ATOMICRELEASE(_pmpParent);
        ATOMICRELEASE(_ptpbar);

        if (_hhookMsg)
        {
            TraceMsg(TF_MENUBAND, "CMenuAgent: Hook removed");

            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }

        _pvContext = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CMenuAgent::CancelMenu(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        if (_hwndParent)
        {
            ASSERT(IS_VALID_HANDLE(_hwndParent, WND));

            TraceMsg(TF_MENUBAND, "Sending cancel mode to menu");

            // Use PostMessage so USER32 doesn't RIP on us in 
            // MsgHook when it returns from the WM_MOUSEMOVE
            // that triggered this code path in the first place.

            PostMessage(_hwndParent, WM_CANCELMODE, 0, 0);

            // Disguise this as if the escape key was hit,
            // since this is called when the mouse hovers over
            // another menu sibling.
            _fEscHit = TRUE;

            // this can be called before a context is set up, so guard for NULL.
            if (_pmpParent)
            {
                _pmpParent->SetSubMenu(_ptpbar, FALSE);
            }
        }
    }
}    

// store away the identity of the selected menu item.
// if uFlags & MF_POPUP then i is the index.
// otherwise it's the command and we need to convert it to the index.
// we store index always because some popups don't have ids

void CMenuAgent::_OnMenuSelect(HMENU hmenu, int i, UINT uFlags)
{
    _uFlagsLastSelected = uFlags;
    _hmenuLastSelected = hmenu;
}

BOOL CMenuAgent::_OnKey(WPARAM vkey)
{
    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwndSite))
    {
        switch (vkey)
        {
        case VK_LEFT:
          vkey = VK_RIGHT;
          break;

        case VK_RIGHT:
          vkey = VK_LEFT;
          break;
        }
    }

    switch (vkey)
    {
    case VK_RIGHT:
        if (!_hmenuLastSelected || !(_uFlagsLastSelected & MF_POPUP) || (_uFlagsLastSelected & MF_DISABLED) ) 
        {
            // if the currently selected item does not have a cascade, then 
            // we need to cancel out of all of this and tell the top menu bar to go right
            _pmpParent->OnSelect(MPOS_SELECTRIGHT);
        }
        break;
        
    case VK_LEFT:
        if (!_hmenuLastSelected || _hmenuLastSelected == _ptpbar->GetPopupMenu()) {
            // if the currently selected menu item is in our top level menu,
            // then we need to cancel out of all this menu loop and tell the top menu bar
            // to go left 
            _pmpParent->OnSelect(MPOS_SELECTLEFT);
        }
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while in a TrackPopupMenu modal loop.

*/
LRESULT CMenuAgent::MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
        switch (pmsg->message)
        {
        case WM_MENUSELECT:
            // keep track of the items as the are selected.
            g_menuagent._OnMenuSelect(GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam));
            break;
            
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            // Since we've received this msg, any previous escapes
            // (like escaping out of a cascaded menu) should be cleared
            // to prevent a false reason for termination.
            g_menuagent._fEscHit = FALSE;
            break;

        case WM_KEYDOWN:
            if (g_menuagent._OnKey(pmsg->wParam))
                break;
            
        case WM_SYSKEYDOWN:
            g_menuagent._fEscHit = (VK_ESCAPE == pmsg->wParam);
            break;

        case WM_MOUSEMOVE:
            // HACKHACK (isn't all of this a hack?): ignore zero-move
            // mouse moves, so the mouse does not contend with the keyboard.

            POINT pt;
            
            // In screen coords....
            pt.x = GET_X_LPARAM(pmsg->lParam);
            pt.y = GET_Y_LPARAM(pmsg->lParam);

            if (g_menuagent._ptLastMove.x == pt.x && 
                g_menuagent._ptLastMove.y == pt.y)
            {
                TraceMsg(TF_MENUBAND, "CMenuAgent: skipping dup mousemove");
                break;
            }
            g_menuagent._ptLastMove = pt;

            // Since we got a WM_MOUSEMOVE, we need to tell the Menuband global message hook.
            // We need to do this because this message hook steels all of the messages, and
            // the Menuband message hook never updates it's internal cache for removing duplicate
            // WM_MOUSEMOVE messages which cause problems as outlined in CMsgFilter::_HandleMouseMessages
            GetMessageFilter()->AcquireMouseLocation();

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ScreenToClient(g_menuagent._hwndSite, &pt);

            SendMessage(g_menuagent._hwndSite, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    



//=================================================================
// Implementation of a menu deskbar object that uses TrackPopupMenu.
//
// This object uses traditional USER32 menus (via TrackPopupMenu)
// to implement menu behavior.  It uses the CMenuAgent object to 
// help get its work done.  Since the menu deskbar site (_punkSite) 
// sits in a modal loop while any menu is up, it needs to know when
// to quit its loop.  The child object accomplishes this by sending
// an OnSelect(MPOS_FULLCANCEL).
//
// The only time that TrackPopupMenu returns (but we don't want to
// send an MPOS_FULLCANCEL) is if it's b/c the Escape key was hit.
// This just means cancel the current level.  Returning from Popup
// is sufficient for this case.  Otherwise, all other cases of
// returning from TrackPopupMenu means we send a MPOS_FULLCANCEL.
//
// Summary:
//
//  1) User clicked outside the menu.  This is a full cancel.
//  2) User hit the Alt key.  This is a full cancel.
//  3) User hit the Esc key.  This just cancels the current level.
//     (TrackPopupMenu handles this fine.  No notification needs
//     to be sent b/c we want the top-level menu to stay in its
//     modal loop.)
//  4) User selected a menu item.  This is a full cancel.
//
//=================================================================


#undef THISCLASS
#undef SUPERCLASS
#define SUPERCLASS  CMenuDeskBar

// Constructor
CTrackPopupBar::CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd)
{
    _hmenu = hmenu;
    _hwndParent = hwnd;
    _id = id;
    _pvContext = pvContext;
    _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));
}

// Destructor
CTrackPopupBar::~CTrackPopupBar()
{
    SetSite(NULL);
}


STDMETHODIMP_(ULONG) CTrackPopupBar::AddRef()
{
    return SUPERCLASS::AddRef();
}

STDMETHODIMP_(ULONG) CTrackPopupBar::Release()
{
    return SUPERCLASS::Release();
}

STDMETHODIMP CTrackPopupBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTrackPopupBar, IMenuPopup),
        QITABENT(CTrackPopupBar, IObjectWithSite),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CTrackPopupBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuBandChild)) 
    {
        if (IsEqualIID(riid, IID_IAccessible))
        {
            HRESULT hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(_hmenu, (WORD)_id);

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }

            return hres;
        }
        else
            return QueryInterface(riid, ppvObj);
    }
    else
        return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the parent menubar to tell us when to
         bail out of the TrackPopupMenu
*/
STDMETHODIMP CTrackPopupBar::OnSelect(DWORD dwType)
{
    switch (dwType)
    {
    case MPOS_CANCELLEVEL:
    case MPOS_FULLCANCEL:
        g_menuagent.CancelMenu(_pvContext);
        break;

    default:
        TraceMsg(TF_WARNING, "CTrackPopupBar doesn't handle this MPOS_ value: %d", dwType);
        break;
    }
    return S_OK;    
}    


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/
STDMETHODIMP CTrackPopupBar::SetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    return E_NOTIMPL;
}    

// HACKHACK: DO NOT TOUCH! This is the only way to select
// the first item for a user menu. TrackMenuPopup by default does
// not select the first item. We pump these messages to our window. 
// User snags these messages, and thinks the user pressed the down button
// and selects the first item for us. The lParam is needed because Win95 gold
// validated this message before using it. Another solution would be to listen
// to WM_INITMENUPOPUP and look for the HWND of the menu. Then send that 
// window the private message MN_SELECTFIRSTVALIDITEM. But thats nasty compared 
// to this. - lamadio 1.5.99
void CTrackPopupBar::SelectFirstItem()
{
    HWND hwndFocus = GetFocus();
    // pulled the funny lparam numbers out of spy's butt.
    if (hwndFocus) {
        PostMessage(hwndFocus, WM_KEYDOWN, VK_DOWN, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_DOWN, 0xD1500001);
#ifdef UNIX
        /* HACK HACK
         * The above PostMessages were causing the second menu item
         * to be selected if you access the menu from the keyboard.
         * The following PostMessages will nullify the above effect.
         * This is to make sure that menus in shdocvw work properly
         * with user32 menus.
         */
        PostMessage(hwndFocus, WM_KEYDOWN, VK_UP, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_UP, 0xD1500001);
#endif /* UNIX */
    }
}
           
/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

         Invoke the menu.
*/
STDMETHODIMP CTrackPopupBar::Popup(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));
    ASSERT(IS_VALID_CODE_PTR(_pmpParent, IMenuPopup));

    // We must be able to talk to the parent menu bar 
    if (NULL == _pmpParent)
        return E_FAIL;

    ASSERT(IS_VALID_HANDLE(_hmenu, MENU));
    ASSERT(IS_VALID_CODE_PTR(_punkSite, IUnknown));
    
    HMENU hmenu = GetSubMenu(_hmenu, _id);
    HWND hwnd;
    TPMPARAMS tpm;
    TPMPARAMS * ptpm = NULL;

    // User32 does not want to fix this for compatibility reasons,
    // but TrackPopupMenu does not snap to the nearest monitor on Single and Multi-Mon
    // systems. This has the side effect that if we pass a non-visible coordinate, then
    // User places menu at a random location on screen. So instead, we're going to bias
    // the point to the monitor.

    MONITORINFO mi = {0};
    mi.cbSize = sizeof(mi);

    HMONITOR hMonitor = MonitorFromPoint(*((POINT*)ppt), MONITOR_DEFAULTTONEAREST);
    GetMonitorInfo(hMonitor, &mi);

    if (ppt->x >= mi.rcMonitor.right)
        ppt->x = mi.rcMonitor.right;

    if (ppt->y >= mi.rcMonitor.bottom)
        ppt->y = mi.rcMonitor.bottom;

    if (ppt->x <= mi.rcMonitor.left)
        ppt->x = mi.rcMonitor.left;

    if (ppt->y <= mi.rcMonitor.top)
        ppt->y = mi.rcMonitor.top;


    if (prcExclude)
    {
        tpm.cbSize = SIZEOF(tpm);
        tpm.rcExclude = *((LPRECT)prcExclude);
        ptpm = &tpm;
    }

    // The forwarding code in CShellBrowser::_ShouldForwardMenu
    // and CDocObjectHost::_ShouldForwardMenu expects the first
    // WM_MENUSELECT to be sent for the top-level menu item.
    // 
    // We need to fake an initial menu select on the top menu band
    // to mimic USER and satisfy this expectation.
    //
    UINT uMSFlags = MF_POPUP;
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(_id, uMSFlags), (LPARAM)_hmenu);
    
    SendMessage(_hwndParent, _nMBIgnoreNextDeselect, NULL, NULL);

    // Initialize the menu agent
    IUnknown_GetWindow(_punkSite, &hwnd);
    
    VARIANTARG v = {0};
    UINT uFlags = TPM_VERTICAL | TPM_TOPALIGN;
    UINT uAnimateFlags = 0;
    if (SUCCEEDED(IUnknown_Exec(_punkSite, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &v))) {
        if (v.vt == VT_I4 && 
            (v.lVal == MENUBAR_RIGHT ||
             v.lVal == MENUBAR_LEFT))
        {
            uFlags = TPM_TOPALIGN;
        }

        switch (v.lVal)
        {
        case MENUBAR_LEFT:      uAnimateFlags = TPM_HORNEGANIMATION;
            break;
        case MENUBAR_RIGHT:     uAnimateFlags = TPM_HORPOSANIMATION;
            break;
        case MENUBAR_TOP:       uAnimateFlags = TPM_VERNEGANIMATION;
            break;
        case MENUBAR_BOTTOM:    uAnimateFlags = TPM_VERPOSANIMATION;
            break;
        }
    }

    g_menuagent.Init(_pvContext, this, _pmpParent, _hwndParent, hwnd);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    if (dwFlags & MPPF_INITIALSELECT)
        SelectFirstItem();

    uFlags |= uAnimateFlags;

    TrackPopupMenuEx(hmenu, uFlags,
                   ppt->x, ppt->y, _hwndParent, ptpm);

    // Tell the parent that the menu is now gone
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);

    g_menuagent.Reset(_pvContext);
    _pmpParent->SetSubMenu(this, FALSE);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menuisf.h ===
#ifndef _MENUISF_H
#define _MENUISF_H

#include "caggunk.h"
#include "menubar.h"


//  Object that uses TrackPopupMenu as its implementation for IMenuPopup.
//

class CTrackPopupBar : public CMenuDeskBar
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { return E_NOTIMPL; }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) { return E_NOTIMPL; }

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    
    CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd);
    ~CTrackPopupBar();
    
    HMENU GetPopupMenu() { return GetSubMenu(_hmenu, _id); };
    void SelectFirstItem();
    
protected:
    int     _id;
    HMENU   _hmenu;
    HWND    _hwndParent;
    void*   _pvContext;
    
    // Popup message to indicate - "Ignore next MENUSELECT clear msg"
    UINT _nMBIgnoreNextDeselect;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnbandid.h ===
#define IDS_QLINKS              0x8700
#define IDS_EMPTY               0x8701
#define IDS_FAVS_ADDTOFAVORITES 0x8702
#define IDS_FAVS_INVALIDFN      0x8703
#define IDS_LINKSBANDTEXT       0x8704
#define IDS_QLAUNCHAPPDATAPATH  0x8705

#define DLG_ISFBANDRENAME       0x2000

#define MENU_ISFBAND            500
#define MENU_MNFOLDERCONTEXT    501

#define ISFBIDM_LARGE           0x0001
#define ISFBIDM_SMALL           0x0002
#define ISFBIDM_LOGOS           0x0003
#define ISFBIDM_SHOWTEXT        0x0004
#define ISFBIDM_REFRESH         0x0005
#define ISFBIDM_OPEN            0x0006

// mnfolder context menu commands
#define MNIDM_RESORT            0x0001
#define MNIDM_LAST              0x0001

#define IDS_ACC_OPEN            0x3232
#define IDS_ACC_CLOSE           0x3233
#define IDS_ACC_EXEC            0x3234
#define IDS_ACC_APP             0x3235
#define IDS_ACC_APPMB           0x3236
#define IDS_ACC_SEP             0x3237
#define IDS_ACC_CHEVRON         0x3238
#define IDS_ACC_ALT             0x3239
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menusite.cpp ===
#include "shellprv.h"
#include "menusite.h"

CMenuSite::CMenuSite() : _cRef(1)
{
}


CMenuSite::~CMenuSite()
{
    // Make sure that SetDeskBarSite(NULL) was called
    ASSERT(_punkSite == NULL);
    ASSERT(_punkSubActive == NULL);
    ASSERT(_pweh == NULL);
    ASSERT(_pdb == NULL);
    ASSERT(_hwnd == NULL);
}


STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;
    CMenuSite *pbs = new CMenuSite();
    if (pbs)
    {
        hr = pbs->QueryInterface(riid, ppv);
        pbs->Release();
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CMenuSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMenuSite, IBandSite),
        QITABENT(CMenuSite, IDeskBarClient),
        QITABENT(CMenuSite, IOleCommandTarget),
        QITABENT(CMenuSite, IInputObject),
        QITABENT(CMenuSite, IInputObjectSite),
        QITABENT(CMenuSite, IWinEventHandler),
        QITABENT(CMenuSite, IServiceProvider),
        QITABENT(CMenuSite, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CMenuSite::AddRef(void)
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CMenuSite::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;     // assume error

    if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
        IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
        IsEqualIID(guidService, SID_SMenuBandChild))
    {
        if (_punkSubActive)
            hres = IUnknown_QueryService(_punkSubActive, guidService, riid, ppvObj);
    }
    else
    {
        ASSERT(_punkSite);
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IOleCommandTarget::QueryStatus

*/
STDMETHODIMP CMenuSite::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_punkSite);

    return IUnknown_QueryStatus(_punkSite, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec

*/
STDMETHODIMP CMenuSite::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    ASSERT(_punkSite);

    return IUnknown_Exec(_punkSite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

         This function is called by the client band to negotiate
         which band in this bandsite gets the focus.  Typically
         this function will then change its focus to the given
         client band.

         CMenuSite only maintains one and only one band, which
         is set at AddBand time, so this function is a nop.

*/
STDMETHODIMP CMenuSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    // Return S_OK since the menu site only ever has one band.
    // No need to negotiate which other band in this bandsite 
    // might have the "activation".
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO method

*/
STDMETHODIMP CMenuSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    // Forward onto the client band
    return IUnknown_UIActivateIO(_punkSubActive, fActivate, lpMsg);
}


/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

         Since the menuband can never have true activation (from
         the browser's perspective) this always returns S_FALSE.

         See comments in CMenuBand::UIActivateIO for more details
         about this.

*/
STDMETHODIMP CMenuSite::HasFocusIO()
{
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         Menubands cannot ever have the activation, so this method 
         should never be called.
*/
STDMETHODIMP CMenuSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}


// Utility Functions

void CMenuSite::_CacheSubActiveBand(IUnknown * punk)
{
    if (SHIsSameObject(punk, _punkSubActive))
        return;
    
    IUnknown_SetSite(_punkSubActive, NULL);

    ATOMICRELEASE(_punkSubActive);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_pweh);
    _hwndChild = NULL;

    if (punk != NULL) 
    {
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBand, &_pdb))));
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh))));

        IUnknown_SetSite(punk, SAFECAST(this, IOleWindow*));
        IUnknown_GetWindow(punk, &_hwndChild);

        _punkSubActive = punk;
        _punkSubActive->AddRef();
    }
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand

*/
STDMETHODIMP CMenuSite::AddBand(IUnknown* punk)
{
    _CacheSubActiveBand(punk);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IBandSite::EnumBands

*/
STDMETHODIMP CMenuSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    HRESULT hres = NOERROR;

    // The menusite only holds one band ever
    if (0 == uBand)
        *pdwBandID = 0;
    else
        hres = E_FAIL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand

*/
HRESULT CMenuSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hres = E_NOINTERFACE;

    ASSERT(dwBandID == 0);
    ASSERT(IS_VALID_WRITE_PTR(ppstb, IDeskBand *));

    if (_punkSubActive && 0 == dwBandID)
    {
        hres = _punkSubActive->QueryInterface(IID_PPV_ARG(IDeskBand, ppstb));
        *pdwState = BSSF_VISIBLE; // Only band....

        if (cchName > 0)
            *pszName = L'\0';
    }
    else
        *ppstb = NULL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

*/
HRESULT CMenuSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand

*/
HRESULT CMenuSite::RemoveBand(DWORD dwBandID)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CMenuSite::GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    ASSERT(dwBandID == 0);

    if (_punkSubActive && 0 == dwBandID)
        hres = _punkSubActive->QueryInterface(riid, ppvObj);
    else
    {
        *ppvObj = NULL;
        hres = E_NOINTERFACE;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CMenuSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CMenuSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow

*/
HRESULT CMenuSite::GetWindow(HWND * lphwnd)
{
    ASSERT(IS_VALID_HANDLE(_hwnd, WND));

    *lphwnd = _hwnd;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp

*/
HRESULT CMenuSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetDeskBarSite

*/
HRESULT CMenuSite::SetDeskBarSite(IUnknown* punkSite)
{
    if (punkSite)
    {
        ATOMICRELEASE(_punkSite);

        HWND hwnd;
        IUnknown_GetWindow(punkSite, &hwnd);

        if (hwnd)
        {
            _CreateSite(hwnd);

            _punkSite = punkSite;
            _punkSite->AddRef();
        }
    }
    else
    {
        if (_pdb)
        {
            _pdb->CloseDW(0);
        }
        _CacheSubActiveBand(NULL);      // This is asymetric by design

        if (_hwnd)
        {
            DestroyWindow(_hwnd);
            _hwnd = NULL;
        }

        ATOMICRELEASE(_punkSite);
    }

    return _hwnd ? NOERROR : E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetModeDBC

*/
HRESULT CMenuSite::SetModeDBC(DWORD dwMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::UIActivateDBC

*/
HRESULT CMenuSite::UIActivateDBC(DWORD dwState)
{
    HRESULT hr = S_OK;

    ASSERT(_pdb);
    if (_pdb)
        hr = _pdb->ShowDW(0 != dwState);

    return hr;
}

/*----------------------------------------------------------
Purpose: IDeskBarClient::GetSize

*/
HRESULT CMenuSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    if (dwWhich == DBC_GS_IDEAL)
    {
        if (_pdb)
        {
            DESKBANDINFO dbi = {0};
            _pdb->GetBandInfo(0, 0, &dbi);
            prc->right = dbi.ptMaxSize.x;
            prc->bottom = dbi.ptMaxSize.y;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

*/
HRESULT CMenuSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (_pweh)
        return _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner

*/
HRESULT CMenuSite::IsWindowOwner(HWND hwnd)
{
    if (_hwnd == hwnd || (_pweh && _pweh->IsWindowOwner(hwnd) != S_FALSE))
        return S_OK;
    else
        return S_FALSE;
}


LRESULT CMenuSite::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    AddRef();

    switch(uMsg)
    {
    case WM_SIZE:
        {
            IMenuPopup* pmp;

            if (_punkSubActive && SUCCEEDED(_punkSubActive->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp))))
            {
                RECT rc = {0};

                GetClientRect(_hwnd, &rc);

                pmp->OnPosRectChangeDB(&rc);
                pmp->Release();
            }
            lres = 1;
        }
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    default:
        Release();
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        break;
    }

    if (hwnd && _pweh && _pweh->IsWindowOwner(hwnd) == S_OK) 
    {
        _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres);
    }

    Release();
    return lres;
}


void CMenuSite::_CreateSite(HWND hwndParent)
{
    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));    // just to be safe...
        return;
    }

    WNDCLASS wc = {0};
    wc.style            = 0;
    wc.lpfnWndProc      = s_WndProc;
    wc.cbWndExtra       = SIZEOF(CMenuSite*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_MENU+1);
    wc.lpszClassName    = TEXT("MenuSite");

    SHRegisterClass(&wc);

    _hwnd = CreateWindow(TEXT("MenuSite"), NULL, WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, 
        hwndParent, NULL, HINST_THISDLL, (LPVOID)SAFECAST(this, CImpWndProc*));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnbase.cpp ===
#include "shellprv.h"
#include "common.h"
#include "menuband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "iaccess.h"
#include "uemapp.h"
#include "util.h"

#ifdef UXCTRL_VERSION
#include <uxtheme.h>
#include <tmschema.h>
#endif

// Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

const TCHAR c_wzMenuBandTheme[] = TEXT("MenuBand");

#define DM_MISC     0               // miscellany

#define MAXUEMTIMEOUT 2000

/*----------------------------------------------------------
Purpose: Return the button command given the position.

*/
int GetButtonCmd(HWND hwnd, int iPos)
{
    ASSERT(!hwnd || IsWindow(hwnd));
    int nRet = -1;          // Punt on failure

    TBBUTTON tbb;
    if (hwnd && ToolBar_GetButton(hwnd, iPos, &tbb))
    {
        nRet = tbb.idCommand;
    }
    return nRet;
}    



long GetIndexFromChild(BOOL fTop, int iIndex)
{
    return  (fTop? TOOLBAR_MASK: 0) | iIndex + 1;
}

//--------------------------------------------------------------------------------
//
// CMenuToolbarBase
//
//--------------------------------------------------------------------------------

CMenuToolbarBase::~CMenuToolbarBase()
{
    Str_SetPtr(&_pszTheme, NULL);
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
    }
}

CMenuToolbarBase::CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags) : _pcmb(pmb)
{
#ifdef DEBUG
    _cRef = 1;
#endif
    _dwFlags = dwFlags;
    _nItemTimer = -1;
    _idCmdChevron = -1;
    _fFirstTime = TRUE;
}

// *** IObjectWithSite methods ***

HRESULT CMenuToolbarBase::SetSite(IUnknown *punkSite)
{
    ASSERT(punkSite && IS_VALID_READ_PTR(punkSite, CMenuBand*));

    // We are guaranteed the lifetime of this object is contained within
    // the menuband, so we don't addref pcmb.
    if (SUCCEEDED(punkSite->QueryInterface(CLSID_MenuBand, (void**)&_pcmb))) 
    {
        punkSite->Release();
    } 
    else 
    {
        ASSERT(0);
    }

    _fVerticalMB = !BOOLIFY(_pcmb->_dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(_pcmb->_dwFlags & SMINIT_TOPLEVEL);
    
    return S_OK;
}

HRESULT CMenuToolbarBase::GetSite(REFIID riid, void ** ppvSite)
{
    if (!_pcmb)
        return E_FAIL;

    return _pcmb->QueryInterface(riid, ppvSite);
}

// *** IUnknown methods ***

STDMETHODIMP_(ULONG) CMenuToolbarBase::AddRef()
{
    DEBUG_CODE(_cRef++);
    if (_pcmb)
    {
        return _pcmb->AddRef();
    }

    return 0;
}


STDMETHODIMP_(ULONG) CMenuToolbarBase::Release()
{
    ASSERT(_cRef > 0);
    DEBUG_CODE(_cRef--);

    if (_pcmb)
    {
        return _pcmb->Release();
    }

    return 0;
}

HRESULT CMenuToolbarBase::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_MenuToolbarBase) && ppvObj) 
    {
        AddRef();
        *ppvObj = (void*)this;
        hres = S_OK;
    }
    else
        hres = _pcmb->QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuToolbarBase::SetToTop(BOOL bToTop)
{
    // A menu toolbar can be at the top or the bottom of the menu.
    // This is an exclusive attribute.
    if (bToTop)
    {
        _dwFlags |= SMSET_TOP;
        _dwFlags &= ~SMSET_BOTTOM;
    }
    else
    {
        _dwFlags |= SMSET_BOTTOM;
        _dwFlags &= ~SMSET_TOP;
    }
}


void CMenuToolbarBase::KillPopupTimer()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Killing Popout Timer...", this);
    KillTimer(_hwndMB, MBTIMER_POPOUT);
    _nItemTimer = -1;
}


void CMenuToolbarBase::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (_hwndMB)
    {
        ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
        DWORD rectWidth = RECTWIDTH(*prc);
        TraceMsg(TF_MENUBAND, "CMTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
            prc->left, prc->top, prc->right, prc->bottom);
        ::SetWindowPos(_hwndMB, NULL, prc->left, prc->top, 
            rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
        // hackhack:  we only do this when multicolumn.  this call is to facilitate the size negotiation between 
        // static menu and folder menu.  Set the width of the toolbar to the width of the button in case 
        // of non-multicolumn.
        if (!(_fMulticolumnMB) && psize)
        {
            int cx = psize->cx;
            ToolBar_SetButtonWidth(_hwndMB, cx, cx);
        }

        // Force this to redraw. I put this here because the HMenu portion was painting after the shell
        // folder portion was done enumerating the folder, which is pretty slow. I wanted the HMENU portion
        // to paint right away...
        RedrawWindow(_hwndMB, NULL, NULL, RDW_UPDATENOW);
    }
}

// NOTE: if psize is (0,0) we use tb button size as param in figuring out ideal tb size
//   else we use max of psize length and tb button length as our metric
void CMenuToolbarBase::GetSize(SIZE* psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (_hwndMB)
    {
        LRESULT lButtonSize;

        lButtonSize = TB_GetButtonSizeWithoutThemeBorder(_hwndMB, _hTheme);

        if (psize->cx || psize->cy)
        {
            int cx = max(psize->cx, LOWORD(lButtonSize));
            int cy = max(psize->cy, HIWORD(lButtonSize));
            lButtonSize = MAKELONG(cx, cy);
        }

        if (_fVerticalMB)
        {
            psize->cx = LOWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, TRUE, (LPARAM)psize);
        }
        else
        {
            psize->cy = HIWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, FALSE, (LPARAM)psize);
        }

        TraceMsg(TF_MENUBAND, "CMTB::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}


/*----------------------------------------------------------
Purpose: Timer handler.  Used to pop open/close cascaded submenus.

*/
LRESULT CMenuToolbarBase::_OnTimer(WPARAM wParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    switch (wParam) 
    {

    case MBTIMER_INFOTIP:
        {
            // Do we have a hot item to display the tooltip for?
            int iHotItem = ToolBar_GetHotItem(_hwndMB);
            KillTimer(_hwndMB, wParam);
            if (iHotItem >= 0)
            {
                // Yep.
                TCHAR szTip[MAX_PATH];
                int idCmd = GetButtonCmd(_hwndMB, iHotItem);

                // Ask the superclass for the tip
                if (S_OK == v_GetInfoTip(idCmd, szTip, ARRAYSIZE(szTip)))
                {
                    // Now display it. Yawn.
                    _pcmb->_pmbState->CenterOnButton(_hwndMB, FALSE, idCmd, NULL, szTip);
                }
            }
        }
        break;

    case MBTIMER_CHEVRONTIP:
        KillTimer(_hwndMB, wParam);
       _pcmb->_pmbState->HideTooltip(TRUE);
       break;
 
    case MBTIMER_FLASH:
        {
            _cFlashCount++;
            if (_cFlashCount == COUNT_ENDFLASH)
            {
                _cFlashCount = 0;
                KillTimer(_hwndMB, wParam);
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
                _SetTimer(MBTIMER_UEMTIMEOUT);

                // Now that we've flashed, let's show the Chevron tip.
                // This is for a confused user: If they've hovered over an item for too long,
                // or this is the first time they've seen intellimenus, then we flash and display
                // the tooltip. We only want to display this if we are shown: We would end up with
                // and dangling tooltip if you happen to move to another menu while it was flashing.
                // Ummm, is the Chevron still visible?
                if (_fShowMB && _idCmdChevron != -1)
                {
                    TCHAR szTip[MAX_PATH];
                    TCHAR szTitle[MAX_PATH];
                    // SMC_CHEVRONGETTIP handler assumes MAX_PATH
                    if (S_OK == v_CallCBItem(_idCmdChevron, SMC_CHEVRONGETTIP, (WPARAM)szTitle, (LPARAM)szTip))
                    {
                        _pcmb->_pmbState->CenterOnButton(_hwndMB, TRUE, _idCmdChevron, szTitle, szTip);
                        _SetTimer(MBTIMER_CHEVRONTIP);
                    }
                }
            }
            else
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, (_cFlashCount % 2) == 0);
        }
        break;

    case MBTIMER_UEMTIMEOUT:
        {
            POINT pt;
            RECT rect;

            // Don't fire timeouts when we're in edit mode.
            if (_fEditMode)
            {
                KillTimer(_hwndMB, wParam);
                break;
            }

            GetWindowRect(_hwndMB, &rect);
            GetCursorPos(&pt);
            if (PtInRect(&rect, pt))
            {
                TraceMsg(TF_MENUBAND, "*** UEM TimeOut. At Tick Count (%d) ***", GetTickCount());
                _FireEvent(UEM_TIMEOUT);
            }
            else
            {
                TraceMsg(TF_MENUBAND, " *** UEM TimeOut. At Tick Count (%d)."
                    " Mouse outside menu. Killing *** ", GetTickCount());
                KillTimer(_hwndMB, wParam);
            }
        }
        break;


    case MBTIMER_EXPAND:
        KillTimer(_hwndMB, wParam);
        if (_fShowMB)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
            _fClickHandled = TRUE;
            _SetTimer(MBTIMER_CLICKUNHANDLE); 
        }
        break;

    case MBTIMER_DRAGPOPDOWN:
        // There has not been a drag enter in this band for a while, 
        // so we'll try to cancel the menus.
        KillTimer(_hwndMB, wParam);
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBDragCancel, 0, 0);
        break;

    case MBTIMER_DRAGOVER:
        {
            TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG)");
            KillTimer(_hwndMB, wParam);
            DAD_ShowDragImage(FALSE);
            // Does this item cascade?
            int idBtn = GetButtonCmd(_hwndMB, v_GetDragOverButton());
            DWORD dwFlags = v_GetFlags(idBtn);
            if (dwFlags & SMIF_SUBMENU)
            {
                TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG): Is a submenu");
                // Yes; pop it open
                if (!_fVerticalMB)
                    _pcmb->_fInvokedByDrag = TRUE;
                _DoPopup(idBtn, FALSE);
            }
            else if (dwFlags & SMIF_DRAGNDROP)
            {
                v_CallCBItem(idBtn, SMC_EXEC, 0, 1);
            }
            else if (idBtn == _idCmdChevron)
            {
                Expand(TRUE);
            }
            else
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }

        }
        break;

    case MBTIMER_POPOUT:
        {
            int nItemTimer = _nItemTimer;
            KillPopupTimer();

            // Popup a new submenu?
            if (-1 != nItemTimer)
            {
                if (nItemTimer != _pcmb->_nItemCur)
                {
                    // Yes;  post message since the currently expanded submenu
                    // may be a CTrackPopup object, which posts its cancel mode.

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Timer went off.  Expanding...", this);
                    PostPopup(nItemTimer, FALSE, FALSE);
                }
            }
            else 
            {
                // No; just collapse the currently open submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_CANCELLEVEL to submenu popup", this);
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
            break;
        }
    
    case MBTIMER_CLOSE:
        KillTimer(_hwndMB, wParam);

        TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_FULLCANCEL", this);

        if (_fVerticalMB)
            _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
        else
        {
            _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        }
        break;
    }
        
    return 1;
}


void CMenuToolbarBase::_DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText )
{
    SIZE size = {_pcmb->_pmbm->_cxArrow, _pcmb->_pmbm->_cyArrow};

    //
    // If the DC is mirrred, then the Arrow should be mirrored
    // since it is done thru TextOut, NOT the 2D graphics APIs [samera]
    //

    _DrawMenuGlyph(hdc, 
                   _pcmb->_pmbm->_hFontArrow,
                   prc, 
                   (IS_DC_RTL_MIRRORED(hdc)) ? CH_MENUARROWRTLA :
                   CH_MENUARROWA, 
                   rgbText, 
                   &size);
}


void CMenuToolbarBase::_DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_pmbm->_hFontArrow)
    {
        SIZE    size;
        int cx, cy, y, x;
        HFONT hFontOld;
        int iOldBk = SetBkMode(hdc, TRANSPARENT);
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        if (psize == NULL)
        {
            GetTextExtentPoint32A( hdc, &ch, 1, &size);
            psize = &size;
        }

        cy = prc->bottom - prc->top;
        y = prc->top  + ((cy - psize->cy) / 2);

        cx = prc->right - prc->left;
        x = prc->left + ((cx - psize->cx) /2);
    
        COLORREF rgbOld = SetTextColor(hdc, rgbText);

        TextOutA(hdc, x, y, &ch, 1);
    
        SetTextColor(hdc, rgbOld);
        SetBkMode(hdc, iOldBk);
        SelectObject(hdc, hFontOld);
    }
}

void CMenuToolbarBase::SetMenuBandMetrics(CMenuBandMetrics* pmbm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // This can be called before the toolbar is created. 
    // So we'll check this condition. When the toolbar is created, then
    // the toolbar will get the metrics at that point.
    if (!_hwndMB)
        return;

    //Loop through toolbar.
    for (int iButton = ToolBar_ButtonCount(_hwndMB)-1; iButton >= 0; iButton--)
    {
        IOleCommandTarget* poct;

        int idCmd = GetButtonCmd(_hwndMB, iButton);

        // If it's not a seperator, see if there is a sub menu.
        if (idCmd != -1 &&
            SUCCEEDED(v_GetSubMenu(idCmd, NULL, IID_PPV_ARG(IOleCommandTarget, &poct))))
        {
            VARIANT Var;
            Var.vt = VT_UNKNOWN;
            Var.punkVal = SAFECAST(pmbm, IUnknown*);

            // Exec to set new Metrics.
            poct->Exec(&CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);
            poct->Release();
        }
    }

    _SetFontMetrics();
    // return
}

void CMenuToolbarBase::_SetFontMetrics()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_hwndMB && _pcmb->_pmbm)
    {
        SendMessage(_hwndMB, WM_SETFONT, (WPARAM)_pcmb->_pmbm->_hFontMenu, FALSE);

        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETFLAT, _pcmb->_pmbm->_fFlatMenuMode, NULL, NULL);
    }
}


HRESULT CMenuToolbarBase::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT( _hwndMB != NULL );
    DWORD dwToolBarStyle = TBSTYLE_TRANSPARENT;

    // if we're set up as a popup, don't do any transparent stuff
    if (_fVerticalMB) 
    {
        dwToolBarStyle  = TBSTYLE_CUSTOMERASE;    // Vertical Toolbars don't get Transparent
        DWORD dwExtendedStyle = 0;

        // This is for TBMenu which actually has a Horizontal menubar within the 
        // Vertical menuband.
        if (!_fHorizInVerticalMB)
            dwExtendedStyle |= TBSTYLE_EX_VERTICAL;

        if (_fMulticolumnMB)
            dwExtendedStyle |= TBSTYLE_EX_MULTICOLUMN;

        ToolBar_SetExtendedStyle(_hwndMB, 
            dwExtendedStyle, TBSTYLE_EX_VERTICAL | TBSTYLE_EX_MULTICOLUMN);

        ToolBar_SetListGap(_hwndMB, LIST_GAP);
    }

    ToolBar_SetExtendedStyle(_hwndMB, TBSTYLE_EX_DOUBLEBUFFER, TBSTYLE_EX_DOUBLEBUFFER);

    SHSetWindowBits(_hwndMB, GWL_STYLE, 
        TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE, dwToolBarStyle );

    ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));

    v_UpdateIconSize(_pcmb->_uIconSize, FALSE);

    _SetFontMetrics();

    if (_pszTheme)
    {
        SendMessage(_hwndMB, TB_SETWINDOWTHEME, 0, (LPARAM)_pszTheme);
        _RefreshTheme();
    }

    return S_OK;
}


HRESULT CMenuToolbarBase::_SetMenuBand(IShellMenu* psm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;
    IBandSite* pmbs = NULL;
    if (!_pcmb->_pmpSubMenu)
    {
        hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &_pcmb->_pmpSubMenu));
        if (SUCCEEDED(hres))
        {
            IUnknown_SetSite(_pcmb->_pmpSubMenu, SAFECAST(_pcmb, IOleCommandTarget*));
            hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pmbs));
            if (SUCCEEDED(hres))
            {
                hres = _pcmb->_pmpSubMenu->SetClient(pmbs);
                // Don't release pmbs here. We are using below
            }
            // Menu band will Release _pmpSubMenu.
        }
    }
    else
    {
        IUnknown* punk;
        _pcmb->_pmpSubMenu->GetClient(&punk);
        if (punk)
        {
            hres = punk->QueryInterface(IID_PPV_ARG(IBandSite, &pmbs));
            punk->Release();
        }
    }

    if (pmbs)
    {
        if (SUCCEEDED(hres))
            hres = pmbs->AddBand(psm);

        pmbs->Release();
    }
 
    return hres;
}

HRESULT CMenuToolbarBase::GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj)
{
    // pguidService is for asking a for specifically the Shell Folder portion or the Static portion
    HRESULT hres = E_FAIL;
    if (v_GetFlags(idCmd) & SMIF_TRACKPOPUP ||
        _pcmb->_dwFlags & SMINIT_DEFAULTTOTRACKPOPUP)
    {
        hres = v_CreateTrackPopup(idCmd, riid, (void**)ppvObj);
        if (SUCCEEDED(hres))
        {
            _pcmb->SetTrackMenuPopup((IUnknown*)*ppvObj);
        }
    }
    else
    {
        IShellMenu* psm;
        hres = v_GetSubMenu(idCmd, pguidService, IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hres)) 
        {
            if (_pszTheme)
            {
                IShellMenu2* psm2;
                if (SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2))))
                {
                    if (_fNoBorder)
                    {
                        psm2->SetNoBorder(_fNoBorder);
                    }

                    psm2->SetTheme(_pszTheme);
                    psm2->Release();
                }
            }

            TraceMsg(TF_MENUBAND, "GetUIObject psm %#lx", psm);
            _pcmb->SetTracked(this);

            hres = _SetMenuBand(psm);
            psm->Release();

            // Did we succeed in getting a menupopup?
            if (SUCCEEDED(hres))
            {
                // Yep; Sweet!
                _pcmb->_pmpSubMenu->QueryInterface(riid, ppvObj);

                HWND hwnd;
                IUnknown_GetWindow(_pcmb->_pmpSubMenu, &hwnd);
                PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)hwnd, (LPARAM)-1);
            }
        }
    }

    return hres;
}

HRESULT CMenuToolbarBase::PositionSubmenu(int idCmd)
{
    IMenuPopup* pmp = NULL;
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0;

    if (_pcmb->_fInSubMenu)
    {
        // Since the selection has probrably changed, we use the cached item id
        // to calculate the postion rect
        idCmd = _pcmb->_nItemSubMenu;
        dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;
        pmp = _pcmb->_pmpSubMenu;
        pmp->AddRef();

        ASSERT(pmp);    // If _fInSubmenu is set, then this must be valid
        hres = S_OK;
    }
    else
    {
        // Only do these when we're not repositioning.
        if (_pcmb->_fInitialSelect)
            dwFlags |= MPPF_INITIALSELECT;

        if (!_pcmb->_fCascadeAnimate)
            dwFlags |= MPPF_NOANIMATE;

        _pcmb->_nItemSubMenu = idCmd;

        hres = GetSubMenu(idCmd, NULL, IID_PPV_ARG(IMenuPopup, &pmp));
    }

    ASSERT(idCmd != -1);    // Make sure at this point we have an item.


    if (SUCCEEDED(hres))
    {
        ASSERT(pmp);

        // Make sure the menuitem is pressed
        _PressBtn(idCmd, TRUE);

        RECT rc;
        RECT rcTB;
        RECT rcTemp;
        POINT pt;

        if (!SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc))
        {
            // Under weird conditions, idCmd can be invalid.
            // (See bug 403077.)  So just blow off the reposition
            // and keep using the old position.
            hres = E_FAIL;
        }
        else
        {
            GetClientRect(_hwndMB, &rcTB);

            if (rc.right > rcTB.right)
            {
                rc.right = rcTB.right;
            }

            // Is the button rect within the boundries of the
            // visible toolbar?
            if (!IntersectRect(&rcTemp, &rcTB, &rc))
            {
                // No; Then we need to bias that rect into
                // the visible region of the toolbar.
                // We only want to bias one side
                if (rc.left > rcTB.right)
                {
                    rc.left = rcTB.right - (rc.right - rc.left);
                    rc.right = rcTB.right;
                }
            }

            MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

            if (_fVerticalMB)
            {
                pt.x = rc.right;
                pt.y = rc.top;
            }
            else
            {
                //
                // If the shell dropdown (toolbar button) menus are mirrored,
                // then take the right edge as the anchor point
                //
                if (IS_WINDOW_RTL_MIRRORED(_hwndMB))
                    pt.x = rc.right;
                else
                    pt.x = rc.left;
                pt.y = rc.bottom;
            }

            // Since toolbar buttons expand almost to the end of the basebar,
            // shrink the exclude rect so if overlaps.
            // NOTE: the items are GetSystemMetrics(SM_CXEDGE) larger than before. So adjust to that.

            if (_pcmb->_fExpanded)
                InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), 0);

            // We want to stop showing the chevron tip when we cascade into another menu
            _pcmb->_pmbState->HideTooltip(TRUE);

            // Only animate the first show at this level.
            _pcmb->_fCascadeAnimate = FALSE;

            hres = pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlags);
        }
        pmp->Release();

    }
    return hres;
}
/*----------------------------------------------------------
Purpose: Cascade to the _nItemCur item's menu popup.

         If the popup call was modal, S_FALSE is returned; otherwise
         it is S_OK, or error.

*/
HRESULT CMenuToolbarBase::PopupOpen(int idBtn)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;


    // Tell the current submenu popup to cancel.  This must be done 
    // before the PostMessage b/c CTrackPopupBar itself posts a message
    // which it must receive before we receive our post.
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): PostPopup sending MPOS_CANCELLEVEL to submenu popup", this);
    if (_pcmb->_fInSubMenu)
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

    hres = PositionSubmenu(idBtn);

    // Modal?
    if (S_FALSE == hres)
    {
        // Yes; take the capture back
        GetMessageFilter()->RetakeCapture();

        // return S_OK so we stay in the menu mode
        hres = S_OK;
    }
    else if (FAILED(hres))
        _PressBtn(idBtn, FALSE);

    // Since CTrackPopupBar is modal, it should be a useless blob 
    // of bits in memory by now...
    _pcmb->SetTrackMenuPopup(NULL);
   
    return hres;
}


/*----------------------------------------------------------
Purpose: Called to hide a modeless menu.

*/
void CMenuToolbarBase::PopupClose(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != _pcmb->_nItemCur)
    {
        _PressBtn(_pcmb->_nItemCur, FALSE);
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, _pcmb->_nItemCur)));

        _pcmb->_fInSubMenu = FALSE;
        _pcmb->_fInvokedByDrag = FALSE;
        _pcmb->_nItemCur = -1;
    }
}    


LRESULT CMenuToolbarBase::_OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_fProcessingWrapHotItem ||
        !_pcmb->_pmtbTracked ||
        (_pcmb->_pmtbTop == _pcmb->_pmtbBottom && !_fHasDemotedItems))
        return 0;

    _fProcessingWrapHotItem = TRUE;


    // If we want ourselves to not be wrapped into (Like for empty items) 
    // Then forward the wrap message to the other toolbar
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP && !(_pcmb->_pmtbBottom->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbBottom);
    }
    else if (!(_pcmb->_pmtbTop->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbTop);
    }

    int iIndex;

    if (pnmwh->iDir < 0)
    {
        HWND hwnd = _pcmb->_pmtbTracked->_hwndMB;
        iIndex = ToolBar_ButtonCount(hwnd) - 1;
        int idCmd = GetButtonCmd(hwnd, iIndex);

        // We do not want to wrap onto a chevron.
        if (idCmd == _idCmdChevron)
            iIndex -= 1;

    }
    else
    {
        iIndex = 0;
    }

    _pcmb->_pmtbTracked->SetHotItem(pnmwh->iDir, iIndex, -1, pnmwh->nReason);


    _fProcessingWrapHotItem = FALSE;

    return 1;
}


LRESULT CMenuToolbarBase::_OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    int iHotItem = -1;
    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;

    if (_pcmb->_fProcessingDup)
        return 0;

    // Check to see if there is only one toolbar.
    if (_pcmb->_pmtbTop == _pcmb->_pmtbBottom)
        return 0;

    ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iNumTopAccel);
    ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iNumBottomAccel);

    _pcmb->_fProcessingDup = TRUE;

    CMenuToolbarBase* pmbtb = NULL;
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP)
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbBottom;
    }
    else
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbTop;
    }

    _pcmb->_fProcessingDup = FALSE;

    if (iHotItem != -1)
    {
        _pcmb->SetTracked(pmbtb);
        int idCmd = ToolBar_CommandToIndex(pmbtb->_hwndMB, iHotItem);
        DWORD dwFlags = HICF_ACCELERATOR;

        // If either (but not both) toolbars have the accelerator, and it is exactly one,
        // then cause the drop down.
        if ( (iNumTopAccel >= 1) ^ (iNumBottomAccel >= 1) &&
             (iNumTopAccel == 1 || iNumBottomAccel == 1) )
            dwFlags |= HICF_TOGGLEDROPDOWN;

        SendMessage(pmbtb->_hwndMB, TB_SETHOTITEM2, idCmd, dwFlags);
        pnmwa->iButton = -1;
        return 1;
    }

    return 0;
}


LRESULT CMenuToolbarBase::_OnDupAccelerator(NMTBDUPACCELERATOR* pnmda)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_fProcessingDup || (_pcmb->_pmtbBottom == _pcmb->_pmtbTop))
        return 0;

    _pcmb->_fProcessingDup = TRUE;

    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;
    
    if (_pcmb->_pmtbTop)
        ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmda->ch, &iNumTopAccel);

    if (_pcmb->_pmtbBottom)
        ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmda->ch, &iNumBottomAccel);


    _pcmb->_fProcessingDup = FALSE;

    if (0 == iNumTopAccel && 0 == iNumBottomAccel)
    {
        // We want to return 1 if Both of them have one. 
        //Otherwise, return 0, and let the toolbar handle it itself.
        return 0;
    }

    pnmda->fDup = TRUE;

    return 1;
}

/*----------------------------------------------------------
Purpose: Handle WM_NOTIFY

*/
LRESULT CMenuToolbarBase::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;
    CMBMsgFilter* pmf = GetMessageFilter();

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case NM_CUSTOMDRAW:
        {
            BOOL fHandled = FALSE;
            NMCUSTOMDRAW *pnmcd = (NMCUSTOMDRAW*)pnm;
            // first we give the callback a chance to handle it
            if (_pcmb->_dwFlags & SMINIT_CUSTOMDRAW)
            {
                fHandled = (S_OK == v_CallCBItem((int)pnmcd->dwItemSpec, SMC_CUSTOMDRAW, (WPARAM)&lres, (LPARAM)pnmcd));

            }
            if (!fHandled)
            {
                // We now custom draw even the TopLevelMenuBand (for the correct font)
                lres = v_OnCustomDraw(pnmcd);
            }
        }
        break;
    case NM_THEMECHANGED:
        {
            _RefreshTheme();
        }
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !pmf->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...

        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

    switch (pnm->code)
    {
    case NM_RELEASEDCAPTURE:
        pmf->RetakeCapture();
        break;

    case NM_KEYDOWN:
        BLOCK
        {
            LPNMKEY pnmk = (LPNMKEY)pnm;
            lres = _OnKey(TRUE, pnmk->nVKey, pnmk->uFlags);
        }
        break;

    case NM_CHAR:
        {
            LPNMCHAR pnmc = (LPNMCHAR)pnm;
            if (pnmc->ch == TEXT(' '))
                return TRUE;

            if (pnmc->dwItemNext == -1 &&
                !_pcmb->_fVertical)
            {
                // If it's horizontal, then it must be top level.
                ASSERT(_pcmb->_fTopLevel);
                _pcmb->_CancelMode(MPOS_FULLCANCEL);
            }
        }
        break;

    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;

    case NM_LDOWN:
        // We need to kill the expand timer, because the user might
        // move out of the chevron and accidentally select another item.
        if ( (int)((LPNMCLICK)pnm)->dwItemSpec == _idCmdChevron && _idCmdChevron != -1)
        {
            KillTimer(_hwndMB, MBTIMER_EXPAND);
            _fIgnoreHotItemChange = TRUE;
        }
        break;

    case NM_CLICK:
        {
            int idCmd = (int)((LPNMCLICK)pnm)->dwItemSpec;
            _fIgnoreHotItemChange = FALSE;
            if ( idCmd == -1 )
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
                _pcmb->SetTracked(NULL);
                lres = 1;
            }
            else if ( idCmd == _idCmdChevron )
            {
                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                Expand(TRUE);
                _fClickHandled = TRUE;
                _SetTimer(MBTIMER_CLICKUNHANDLE);
                lres = 1;
            }
            else if (!_fEmpty)
            {
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): upclick %d", this, idCmd);

                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                if (v_GetFlags(idCmd) & SMIF_SUBMENU)     // Submenus support double click
                {
                    if (_iLastClickedTime == 0) // First time it was clicked
                    {
                        _iLastClickedTime = GetTickCount();
                        _idCmdLastClicked = idCmd;
                    }
                    // Did they click on the same item twice?
                    else if (idCmd != _idCmdLastClicked)
                    {
                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                    else
                    {
                        // Was this item double clicked on?
                        if ((GetTickCount() - _iLastClickedTime) < GetDoubleClickTime())
                        {
                            // We need to post this back to ourselves, because
                            // the Tray will become in active when double clicking
                            // on something like programs. This happens because the 
                            // Toolbar will set capture back to itself and the tray
                            // doesn't get any more messages.
                            PostMessage(_hwndMB, g_nMBExecute, idCmd, 0);
                            _fClickHandled = TRUE;
                        }

                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                }

                // Sent on the button-up.  Handle the same way.
                if (!_fClickHandled && -1 != idCmd)
                    _DropDownOrExec(idCmd, FALSE);

                _fClickHandled = FALSE;
                lres = 1;
            }
        }
        break;

    case TBN_DROPDOWN:
        lres = _OnDropDown((LPNMTOOLBAR)pnm);
        break;

#ifdef UNICODE
    case TBN_GETINFOTIPA:
        {
            LPNMTBGETINFOTIPA pnmTT = (LPNMTBGETINFOTIPA)pnm;
            UINT uiCmd = pnmTT->iItem;
            TCHAR szTip[MAX_PATH];

            if ( S_OK == v_GetInfoTip(pnmTT->iItem, szTip, ARRAYSIZE(szTip)) )
            {
                SHUnicodeToAnsi(szTip, pnmTT->pszText, pnmTT->cchTextMax);
            }
            else
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }


            lres = 1;
            break;

        }
#endif
    case TBN_GETINFOTIP:
        {
            LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
            UINT uiCmd = pnmTT->iItem;

            if ( S_OK != v_GetInfoTip(pnmTT->iItem, pnmTT->pszText, pnmTT->cchTextMax) )
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }
            lres = 1;
            break;
        }

    case NM_RCLICK:
        // When we go into a context menu, stop monitoring.
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        break;

    case TBN_WRAPHOTITEM:
        lres = _OnWrapHotItem((NMTBWRAPHOTITEM*)pnm);
        break;

    case TBN_WRAPACCELERATOR:
        lres = _OnWrapAccelerator((NMTBWRAPACCELERATOR*)pnm);
        break;

    case TBN_DUPACCELERATOR:
        lres = _OnDupAccelerator((NMTBDUPACCELERATOR*)pnm);
        break;

    case TBN_DRAGOVER:
        // This message is sent when drag and drop within the toolbar indicates that it
        // is about to mark a button. Since this gets messed up because of LockWindowUpdate
        // we tell it not to do anything.
        lres = 1;
        break;
    }

    return(lres);
}


BOOL CMenuToolbarBase::_SetTimer(int nTimer)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    long lTimeOut;

    // If we're on NT5 or Win98, use the cool new SPI
    if (SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &g_lMenuPopupTimeout, 0))
    {
        // Woo-hoo, all done.
    }
    else if (g_lMenuPopupTimeout == -1)
    {
        // NT4 or Win95.  Grovel the registry (yuck).
        DWORD dwType;
        TCHAR szDelay[6]; // int is 5 characters + null.
        DWORD cbSize = ARRAYSIZE(szDelay);

        g_lMenuPopupTimeout = MBTIMER_TIMEOUT;

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
            TEXT("MenuShowDelay"), &dwType, (void*)szDelay, &cbSize))
        {
            g_lMenuPopupTimeout = (UINT)StrToInt(szDelay);
        }
    }

    lTimeOut = g_lMenuPopupTimeout;

    switch (nTimer)
    {
    case MBTIMER_EXPAND:
    case MBTIMER_DRAGPOPDOWN:
        lTimeOut *= 2;
        if (lTimeOut < MAXUEMTIMEOUT)
            lTimeOut = MAXUEMTIMEOUT;
        break;

    case MBTIMER_UEMTIMEOUT:
            if (!_fHasDemotedItems || _pcmb->_pmbState->GetExpand() || _fEditMode)
                return TRUE;
            lTimeOut *= 5;

            // We want a minimum of MAXUEMTIMEOUT for people who set the expand rate to zero
            if (lTimeOut < MAXUEMTIMEOUT)
                lTimeOut = MAXUEMTIMEOUT;
            TraceMsg(TF_MENUBAND, "*** UEM SetTimeOut to (%d) milliseconds" 
                "at Tick Count (%d).*** ", GetTickCount());
            break;

    case MBTIMER_CHEVRONTIP:
        lTimeOut = 60 * 1000;    // Please make the intellimenu's balloon tip go 
                                 // away after one minute of no action.
        break;

    case MBTIMER_INFOTIP:
        lTimeOut = 500;    // Half a second hovering over an item?
        break;
    }

    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Setting %d Timer to %d milliseconds at tickcount %d", 
        this, nTimer, lTimeOut, GetTickCount());
    return (BOOL)SetTimer(_hwndMB, nTimer, lTimeOut, NULL);
}

BOOL CMenuToolbarBase::_HandleObscuredItem(int idCmd)
{
    RECT rc;
    GetClientRect(_hwndMB, &rc);

    int iButton = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (SHIsButtonObscured(_hwndMB, &rc, iButton)) 
    {
        // clear hot item
        ToolBar_SetHotItem(_hwndMB, -1);

        _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        _pcmb->_CancelMode(MPOS_FULLCANCEL);        // This is for the track menus.

        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBOpenChevronMenu, (WPARAM)idCmd, 0);

        return TRUE;
    }

    return FALSE;
}


LRESULT CMenuToolbarBase::_OnHotItemChange(NMTBHOTITEM * pnmhot)
{
	ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

    if (_pcmb->_fMenuMode && _pcmb->_fShow && !_fIgnoreHotItemChange)
    {
        // Always kill the expand timer when something changes
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);

        // Is this toolbar being entered?
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            // Yes; set it to be the currently tracking toolbar
            TraceMsg(TF_MENUBAND, "CMTB::OnHotItemChange. Setting Tracked....", this);
            _pcmb->SetTracked(this);

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }

        // If the Toolbar has keybaord focus, we need to send OBJID_CLIENT so that we track correctly.
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, pnmhot->idNew)));
        }

        DEBUG_CODE( TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHANGE (state:%#02lx, %d-->%d)", 
                             this, pnmhot->dwFlags, 
                             (pnmhot->dwFlags & HICF_ENTERING) ? -1 : pnmhot->idOld, 
                             (pnmhot->dwFlags & HICF_LEAVING) ? -1 : pnmhot->idNew); )

        // While in edit mode, we do not automatically cascade 
        // submenus, unless while dropping.  But the dropping case
        // is handled in HitTest, not here.  So don't deal with that
        // here.

        // Is this because an accelerator key was hit?
        if (pnmhot->dwFlags & HICF_ACCELERATOR)
        {
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
            // Yes; now that TBSTYLE_DROPDOWN is used, let _DropDownOrExec handle it
            // in response to TBN_DROPDOWN.
        }
        // Is this because direction keys were hit?
        else if (pnmhot->dwFlags & HICF_ARROWKEYS)
        {
            // Yes
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

            if (!_fVerticalMB && 
                _HandleObscuredItem(pnmhot->idNew))
            {
                lres = 1;
            }
            else
            {
                // It doesn't make sense that we would get these keyboard
                // notifications if there is a submenu open...it should get
                // the messages
                ASSERT(!_pcmb->_fInSubMenu);
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // Since the only way that the chevron can get the highlight is
                // through a keyboard down, then we expand.
                if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                {
                    v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                    Expand(TRUE);
                    lres = 1;       // We already handled the hot item change
                }
            }

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }
        // Is this because the mouse moved or an explicit sendmessage?
        else if (!(pnmhot->dwFlags & HICF_LEAVING) && 
                 (pnmhot->idNew != _pcmb->_nItemCur || // Ignore if we're moving over same item
                  (_nItemTimer != -1 && _pcmb->_nItemCur == pnmhot->idNew)))     // we need to go through here to reset if the user went back to the cascaded guy
        {
            // Yes
            if (!_fVerticalMB)    // Horizontal menus will always have an underlying hmenu
            {
                if (_HandleObscuredItem(pnmhot->idNew))
                {
                    lres = 1;
                }
                else if (_pcmb->_fInSubMenu)
                {
                    // Only popup a menu since we're already in one (as mouse
                    // moves across bar).

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Posting CMBPopup message", this);
                    PostPopup(pnmhot->idNew, FALSE, _pcmb->_fKeyboardSelected);  // Will handle menu notification on receipt of message
                }
                else
                    v_SendMenuNotification(pnmhot->idNew, FALSE);
            }
            else if (!_fEditMode)
            {
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // check to see if we have just entered a new item and it is a sub-menu...

                // Did we already set a timer?
                if (-1 != _nItemTimer)
                {
                    // Yes; kill it b/c the mouse moved to another item
                    KillPopupTimer();
                }

                // if we're not over the currently expanded guy
                // Have we moved over an item that expands OR
                // are we moving away from a cascaded item?
                DWORD dwFlags = v_GetFlags(pnmhot->idNew);
                // Reset the user timer
                KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

                // UEMStuff
                if (!(dwFlags & SMIF_SUBMENU))
                {
                    _SetTimer(MBTIMER_UEMTIMEOUT);
                    _FireEvent(UEM_HOT_ITEM);
                }

                if ( (pnmhot->dwFlags & HICF_MOUSE) && _pcmb->_nItemCur != pnmhot->idNew) 
                {
                    if (dwFlags & SMIF_SUBMENU || _pcmb->_fInSubMenu)
                    {
                        // Is this the only item in the menu?
                        if ( _cPromotedItems == 1 && 
                            !(_fHasDemotedItems && _pcmb->_fExpanded) && 
                            dwFlags & SMIF_SUBMENU)
                        {
                            // Yes; Then we want to pop it open immediatly, 
                            // instead of waiting for the timeout
                            PostPopup(pnmhot->idNew, FALSE, FALSE);
                        }
                        else if (_SetTimer(MBTIMER_POPOUT))
                        {
                            // No; fire a timer to open/close the submenu
                            TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Starting timer for id=%d", this, pnmhot->idNew);
                            if (v_GetFlags(pnmhot->idNew) & SMIF_SUBMENU)
                                _nItemTimer = pnmhot->idNew;
                            else
                                _nItemTimer = -1;
                        }
                    }
                    
                    if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                    {
                        _SetTimer(MBTIMER_EXPAND);
                    }

                    _pcmb->_pmbState->HideTooltip(FALSE);
                    _SetTimer(MBTIMER_INFOTIP);
                }

            }
        }
        else if (pnmhot->dwFlags & HICF_LEAVING)
        {
            v_SendMenuNotification(pnmhot->idOld, TRUE);

            if (-1 != _nItemTimer && !_fEditMode)
            {
                // kill the cascading menu popup timer...
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Killing timer", this);
            
                KillPopupTimer();
            }
            _pcmb->_pmbState->HideTooltip(FALSE);
        }

        if ( !(pnmhot->dwFlags & HICF_LEAVING) )
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
    }

    return lres;
}    

LRESULT CMenuToolbarBase::_DropDownOrExec(UINT idCmd, BOOL bKeyboard)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _DropDownOrExec %d", this, idCmd);

    // Don't do anything when we're in edit mode
    if (_fEditMode)
        return 0;

    if ( v_GetFlags(idCmd) & SMIF_SUBMENU )
    {
        v_SendMenuNotification(idCmd, FALSE);
        
        PostPopup(idCmd, FALSE, bKeyboard);
    }
    else if (idCmd != -1)
    {
        RECT rc;
        AddRef();   // I might get released in the call.

        // Fading Selection
        SHPlaySound(TEXT("MenuCommand"));
        SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

        if (!(GetKeyState(VK_SHIFT) < 0))
        {
            // Initiate the fade (if enabled) before blowing away the menus
            _pcmb->_pmbState->FadeRect(&rc);
            _pcmb->_SiteOnSelect(MPOS_EXECUTE);
        }

        if (g_dwProfileCAP & 0x00002000) 
            StartCAP();
        v_ExecItem(idCmd);
        if (g_dwProfileCAP & 0x00002000) 
            StopCAP();

        Release();
    }
    else
        MessageBeep(MB_OK);

    return 0;
}


/*----------------------------------------------------------
Purpose: Handles TBN_DROPDOWN, which is sent on the button-down.

*/
LRESULT CMenuToolbarBase::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    DWORD dwInput = _fTopLevel ? 0 : -1;    // -1: don't track, 0: do
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

    // Expected behavior with the mouse:
    //
    // 1) For cascading menuitems-
    //    a) expand on button-down
    //    b) collapse on button-up (horizontal menu only)
    //    c) if the button-down occurs on the item that is
    //       already selected, then assume the click indicates
    //       a drag/drop scenario
    // 2) For other menuitems-
    //    a) execute on button-up

#ifdef DEBUG
    if (_fTopLevel)
    {
        // browser menu comes thru here; start menu goes elsewhere (via tray.c)
        //ASSERT(!_fVertical);
        TraceMsg(DM_MISC, "cmtbb._odd: _fTopLevel(1) mouse=%d", GetKeyState(VK_LBUTTON) < 0);
    }
#endif
    // Is this because the mouse button was used?
    if (GetKeyState(VK_LBUTTON) < 0)
    {
        // Yes

        // Assume it won't be handled.  This will allow the toolbar
        // to see the button-down as a potential drag and drop.
        lres = TBDDRET_TREATPRESSED;

        // Clicking on same item that is currently expanded?
        if (pnmtb->iItem == _pcmb->_nItemCur)
        {

            // Is this horizontal?
            if (!_fVerticalMB)
            {
                // Yes; toggle the dropdown
                _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
                
                // Say it is handled, so the button will toggle
                lres = TBDDRET_DEFAULT;
            }
            
            _fClickHandled = TRUE;
            
            // Otherwise don't do anything more, user might be starting a 
            // drag-drop procedure on the cascading menuitem
        }
        else
        {
            if (v_GetFlags(pnmtb->iItem) & SMIF_SUBMENU)
            {
                // Handle on the button-down
                _fClickHandled = TRUE;
                lres = _DropDownOrExec(pnmtb->iItem, FALSE);
            }
        }

        if (dwInput != -1)
            dwInput = UIBL_INPMOUSE;
    }
    else
    {
        // No; must be the keyboard
        _fClickHandled = TRUE;
        lres = _DropDownOrExec(pnmtb->iItem, TRUE);

        if (dwInput != -1)
            dwInput = UIBL_INPMENU;
    }

    // browser menu (*not* start menu) alt+key, mouse
    if (dwInput != -1)
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, dwInput);

    return lres;
}    


/*----------------------------------------------------------
Purpose: Handle WM_KEYDOWN/WM_KEYUP

Returns: TRUE if handled
*/
BOOL CMenuToolbarBase::_OnKey(BOOL bDown, UINT vk, UINT uFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int idCmd;
    HWND hwnd = _hwndMB;

    _pcmb->_pmbState->SetKeyboardCue(TRUE);

    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        switch (vk)
        {
        case VK_LEFT:
          vk = VK_RIGHT;
          break;

        case VK_RIGHT:
          vk = VK_LEFT;
          break;
        }
    }

    switch (vk)
    {
    case VK_LEFT:
        if (_fVerticalMB)
        {
            _pcmb->_SiteOnSelect(MPOS_SELECTLEFT);
            return TRUE;
        }
        break;

    case VK_RIGHT:
        if (_fVerticalMB)
            goto Cascade;
        break;

    case VK_DOWN:
    case VK_UP:
        if (!_fVerticalMB)
        {
Cascade:
            idCmd = GetButtonCmd(hwnd, ToolBar_GetHotItem(hwnd));
            if (v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                // Enter the submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnKey: Posting CMBPopup message", this);
                
                PostPopup(idCmd, FALSE, TRUE);
            }
            else if (VK_RIGHT == vk)
            {
                // Nothing to cascade to, move to next sibling menu
                _pcmb->_SiteOnSelect(MPOS_SELECTRIGHT);
            }
            return TRUE;
        }
        break;

    case VK_SPACE:

        if (!_pcmb->_fExpanded && _fHasDemotedItems)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
        }
        else
        {
            // Toolbars map the spacebar to VK_RETURN.  Menus don't except
            // in the horizontal menubar.
            if (_fVerticalMB)
                MessageBeep(MB_OK);
        }
        return TRUE;
    }

    return FALSE;
}    

/*----------------------------------------------------------
Purpose: There are two flavors of this function: _DoPopup and
         PostPopup.  Both cancel the existing submenu (relative 
         to this band) and pops open a new submenu.  _DoPopup
         does it atomically.  PostPopup posts a message to
         handle it.

*/
void CMenuToolbarBase::_DoPopup(int idCmd, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        PopupHelper(idCmd, bInitialSelect);
    }
}    


/*----------------------------------------------------------
Purpose: See the _DoPopup comment
*/
void CMenuToolbarBase::PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
        _pcmb->SetTracked(this);
        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBPopupOpen, idCmd, MAKELPARAM(bSetItem, bInitialSelect));
    }
}    


/*----------------------------------------------------------
Purpose: Helper function to finally invoke submenu.  Use _DoPopup
         or PostPopup
*/
void CMenuToolbarBase::PopupHelper(int idCmd, BOOL bInitialSelect)
{
    // We do not want to pop open a sub menu if we are not displayed. This is especially
    // a problem during drag and drop.
    if (_fShowMB)
    {
        _pcmb->_nItemNew = idCmd;
        ASSERT(-1 != _pcmb->_nItemNew);
        _pcmb->SetTracked(this);
        _pcmb->_fPopupNewMenu = TRUE;
        _pcmb->_fInitialSelect = BOOLIFY(bInitialSelect);
        _pcmb->UIActivateIO(TRUE, NULL);
        _FireEvent(UEM_HOT_FOLDER);
        _SetTimer(MBTIMER_UEMTIMEOUT);
    }
}


// Paints the 3d rect around a button.
void    CMenuToolbarBase::_PaintButton3D(HDC hdc, int idCmd, LPRECT prc, DWORD dwSMIF)
{

    // Only needed when the menu is expanded.
    // We don't need no stink'n 3D stuff in Flat mode.
    if (!_pcmb->_fExpanded || _pcmb->_pmbm->_fFlatMenuMode)
        return;

    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    RECT rcClient;
    GetClientRect(_hwndMB, &rcClient);
#ifndef DRAWEDGE
    // Draw Left Edge
    HPEN hPenOld = (HPEN)SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
    MoveToEx(hdc, prc->left, prc->top, NULL);
    LineTo(hdc, prc->left, prc->bottom);
#endif

    if (!(dwSMIF & SMIF_DEMOTED))
    {
#ifdef DRAWEDGE
        DWORD dwEdge = BF_RIGHT;

        // Don't paint the edge next to the bitmap.
        if (_uIconSizeMB == ISFBVIEWMODE_SMALLICONS)
            dwEdge |= BF_LEFT;


        RECT rc = *prc;
#else
        // Draw Right Edge:
        SelectObject(hdc, _pcmb->_pmbm->_hPenShadow);
        MoveToEx(hdc, prc->right-1, prc->top, NULL);
        LineTo(hdc, prc->right-1, prc->bottom);
#endif

        HWND hwnd = _hwndMB;
        int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
        if (iPos == -1)
        {
            iPos = ToolBar_ButtonCount(hwnd) - 1;
        }

        if (iPos >= 0)
        {
            int iNumButtons = ToolBar_ButtonCount(hwnd);
            int idCmd2 = GetButtonCmd(hwnd, iPos + 1);
            CMenuToolbarBase* pmtb = this;
            BOOL    fOverflowed = FALSE;

            // Situations for Drawing the Bottom line
            // 1) This button is at the bottom.
            // 2) This button is at the bottom and the toolbar
            //      below is not visible (_fDontShowEmpty).
            // 3) This button is at the bottom and the button
            //      at the top of the bottom toolbar is demoted.
            // 4) The button below this one in the toolbar is
            //      demoted.
            // 5) The botton below this one is demoted and we're
            //      not expanded
    
            if (iPos + 1 >= iNumButtons)
            {
                if (_pcmb->_pmtbBottom != this &&
                    !_pcmb->_pmtbBottom->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbBottom;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, 0);
                }
                else
                    fOverflowed = TRUE;
            }
            else if (prc->bottom == rcClient.bottom &&
                _pcmb->_pmtbBottom == this)   // This button is at the top.
                fOverflowed = TRUE;


            DWORD dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) || 
                 fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_BOTTOM;
#else
                int iLeft = prc->left;
                if (iPos != iNumButtons - 1)   
                    iLeft ++;   // Move the next line in.

                MoveToEx(hdc, iLeft, prc->bottom-1, NULL);
                LineTo(hdc, prc->right-1, prc->bottom-1);
#endif
            }

            // Situations for Drawing the Top line
            // 1) This button is at the top.
            // 2) This button is at the top and the toolbar
            //      above is not visible (_fDontShowEmpty).
            // 3) This button is at the top and the button
            //      at the bottom of the top toolbar is demoted.
            // 4) The button above this one in the toolbar is
            //      demoted.
            // 5) If the button above this is demoted, and we're
            //      not expanded

            fOverflowed = FALSE; 

            if (iPos - 1 < 0)
            {
                if (_pcmb->_pmtbTop != this && 
                    !_pcmb->_pmtbTop->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, ToolBar_ButtonCount(hwnd) - 1);
                }
                else
                    fOverflowed = TRUE; // There is nothing at the top of this menu, draw the line.
            }
            else
            {
                hwnd = _hwndMB;
                idCmd2 = GetButtonCmd(hwnd, iPos - 1);
                pmtb = this;

                if (prc->top == rcClient.top &&
                    _pcmb->_pmtbTop == this)   // This button is at the top.
                    fOverflowed = TRUE;
            }

            dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) ||
                fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_TOP;
#else
                SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
                MoveToEx(hdc, prc->left, prc->top, NULL);
                LineTo(hdc, prc->right-1, prc->top);
#endif
            }
        }

#ifdef DRAWEDGE
        DrawEdge(hdc, &rc, BDR_RAISEDINNER, dwEdge);
#endif
    }

#ifndef DRAWEDGE
    SelectObject(hdc, hPenOld);
#endif
}

int GetTBImageListWidth(HWND hwnd)
{
    int cx = 0;
    int cy;
    HIMAGELIST himl = (HIMAGELIST)SendMessage(hwnd, TB_GETIMAGELIST, 0, 0);
    if (himl)
    {
        
        // Start with the width of the button
        ImageList_GetIconSize(himl, &cx, &cy);
    }

    return cx;
}

LRESULT CMenuToolbarBase::v_OnCustomDraw(NMCUSTOMDRAW * pnmcd)
{
    // Make it look like a menu
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    DWORD dwRet = 0;
    DWORD dwSMIF = v_GetFlags((UINT)pnmcd->dwItemSpec);


    // Edit mode never hot tracks, and the selected item being
    // moved has a black frame around it.  Items that cascade are 
    // still highlighted normally, even in edit mode.

    switch(pnmcd->dwDrawStage)
    {

    case CDDS_PREPAINT:
        dwRet = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_ITEMPREPAINT:
        if (_fVerticalMB)
        {
            if (pnmcd->dwItemSpec == -1)
            {
                if (_hTheme)
                {
                    DrawThemeBackground(_hTheme, pnmcd->hdc, MDP_SEPERATOR, 0, &pnmcd->rc, 0);
                }
                else
                {
                    // a -1 is sent with a seperator
                    RECT rc = pnmcd->rc;
                    rc.top += 3;    // Hard coded in toolbar.
                    rc.right -= GetSystemMetrics(SM_CXEDGE);
                    rc.left += GetSystemMetrics(SM_CXEDGE);

                    if (_pcmb->_pmbm->_fFlatMenuMode)
                    {
                        // Sep is a 1 pixel line
                        rc.bottom = rc.top + 1;
                        SHFillRectClr(pnmcd->hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
                    }
                    else
                        DrawEdge(pnmcd->hdc, &rc, EDGE_ETCHED, BF_TOP);

                    _PaintButton3D(pnmcd->hdc, -1, &pnmcd->rc, dwSMIF);
                }

                dwRet = CDRF_SKIPDEFAULT;
            }
            else
            {
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

                // This is for Darwin Ads.
                if (dwSMIF & SMIF_ALTSTATE)
                {
                    ptbcd->clrText = GetSysColor(COLOR_BTNSHADOW);
                }

                ptbcd->rcText.right = ptbcd->rcText.right - _pcmb->_pmbm->_cxMargin + ICONFUDGE;
                ptbcd->clrBtnFace = (_pcmb->_pmbm->_fFlatMenuMode && (!GetSystemMetrics(SM_REMOTESESSION) && !GetSystemMetrics(SM_REMOTECONTROL))) ? CLR_NONE : _pcmb->_pmbm->_clrBackground;

                if (_hTheme)
                {
                    if (dwSMIF & SMIF_SUBMENU)
                        ptbcd->rcText.right -= _pcmb->_pmbm->_cxArrow;
                }
                else
                {
                    if (_fHasSubMenu)
                        ptbcd->rcText.right -= _pcmb->_pmbm->_cxArrow;
                }

                // Draw the chevron.
                if ( _fHasDemotedItems && _idCmdChevron == (int)pnmcd->dwItemSpec && 
                    !_pcmb->_pmbm->_fFlatMenuMode)  // In flat mode, we only draw the chevron glyph, which is below.
                {
                    _DrawChevron(pnmcd->hdc, &pnmcd->rc, 
                        (BOOL)(pnmcd->uItemState & CDIS_HOT) ||
                         (BOOL)(pnmcd->uItemState & CDIS_MARKED), 
                        (BOOL)(pnmcd->uItemState & CDIS_SELECTED));

                    dwRet |= CDRF_SKIPDEFAULT;
                }
                else
                {
                    if (!_pszTheme)
                    {
                        // Yes; draw with highlight
                        if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                        {
                            if (_pcmb->_pmbm->_fFlatMenuMode)
                            {
                                ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_MENUHILIGHT);
                                ptbcd->clrBtnFace = GetSysColor(COLOR_MENUHILIGHT);
                            }
                            else
                            {
                                ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                                ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                            }
                            ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                            dwRet |= TBCDRF_HILITEHOTTRACK;
                        }
                    }


                    // Is this menu empty?
                    if (_fEmpty)
                    {
                        // Yes, draw the empty string as disabled.
                        if (!_hTheme)
                        {
                            pnmcd->uItemState |= CDIS_DISABLED;
                        }
                        ptbcd->clrText = ptbcd->clrBtnFace;

                        // Don't draw the etched effect if it is selected
                        if (pnmcd->uItemState & CDIS_HOT)
                            dwRet |= TBCDRF_NOETCHEDEFFECT;
                    }

                    // When this item is demoted, we only want to paint his background
                    // then we are in edit mode _OR_ it is not selected, checked or hot.
                    if (dwSMIF & SMIF_DEMOTED)
                    {
                        BOOL fDrawDemoted = TRUE;
                        if (_fEditMode)
                            fDrawDemoted = TRUE;

                        if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                            fDrawDemoted = FALSE;

                        if (fDrawDemoted)
                        {
                            RECT rc = pnmcd->rc;
                            // In flat mode we only paint the icon background in a demoted state. This matches office
                            COLORREF crDemoted = _pcmb->_pmbm->_clrDemoted;
                            if (_pszTheme)
                            {
                                crDemoted = RGB(GetRValue(COLOR_MENU) / 2, GetGValue(COLOR_MENU) / 2, GetBValue(COLOR_MENU) / 2);
                            }

                            if (_pcmb->_pmbm->_fFlatMenuMode)
                            {
                                rc.right = rc.left + GetTBImageListWidth(_hwndMB) + ICONBACKGROUNDFUDGE;
                                SHFillRectClr(pnmcd->hdc, &rc, crDemoted);
                            }
                            else
                            {
                                ptbcd->clrBtnFace = CLR_NONE;
                                SHFillRectClr(pnmcd->hdc, &rc, crDemoted);
                            }
                        }
                    }

                    // "New" items get the tooltip look
                    if (dwSMIF & SMIF_NEW && !(pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT)))
                    {
                        if (_hTheme)
                        {
                            DrawThemeBackground(_hTheme, pnmcd->hdc, MDP_NEWAPPBUTTON, 0, &pnmcd->rc, 0);
                            dwRet |= TBCDRF_NOBACKGROUND;
                        }
                        else
                        {
                            ptbcd->clrBtnFace = CLR_NONE;
                            SHFillRectClr(pnmcd->hdc, &pnmcd->rc, GetSysColor(COLOR_INFOBK));
                            ptbcd->clrText = GetSysColor(COLOR_INFOTEXT);
                        }
                    }

                    // We draw our own highlighting
                    if (!_pszTheme)
                    {
                        dwRet |= (TBCDRF_NOEDGES | TBCDRF_NOOFFSET);
                    }
                }
            }
        }
        else
        {
            // If g_fRunOnMemphis or g_fRunOnNT5 are not defined then the menus will
            // never be grey.
            if (!_pcmb->_fAppActive)
                // menus from user use Button Shadow for non active menus
                ptbcd->clrText = GetSysColor(COLOR_3DSHADOW);
            else
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

            // If we're in high contrast mode make the menu bar look like
            // veritcal items on select or in flat mode use the new "selection" ui.
            if (_pcmb->_pmbm->_fHighContrastMode || _pcmb->_pmbm->_fFlatMenuMode)
            {
                // Yes; draw with highlight
                if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                {
                    ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                    ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                    ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);

                    if (!_pszTheme)
                    {
                        dwRet |= (TBCDRF_NOEDGES | TBCDRF_NOOFFSET | TBCDRF_HILITEHOTTRACK);
                    }
                }
            }
        }
        dwRet |= CDRF_NOTIFYPOSTPAINT | TBCDRF_NOMARK;
        break;
    case CDDS_ITEMPOSTPAINT:
        if (_fVerticalMB)
        {
            RECT rc = pnmcd->rc;
            COLORREF rgbText =  _pcmb->_pmbm->_clrMenuText;
            if (_pcmb->_pmbm->_fFlatMenuMode)
            {
                // Flat menu mode has a rect around the selection.
                if (pnmcd->uItemState & (CDIS_SELECTED | CDIS_HOT) && !_pszTheme)
                {
                    SHOutlineRect(pnmcd->hdc, &pnmcd->rc, GetSysColor(COLOR_HIGHLIGHT));
                }

                // Draw the chevron Glyph
                if ( _fHasDemotedItems && _idCmdChevron == (int)pnmcd->dwItemSpec)
                {
                    _DrawChevron(pnmcd->hdc, &pnmcd->rc, 
                        (BOOL)(pnmcd->uItemState & CDIS_HOT) ||
                         (BOOL)(pnmcd->uItemState & CDIS_MARKED), 
                        (BOOL)(pnmcd->uItemState & CDIS_SELECTED));
                }
            }
            else if (pnmcd->uItemState & (CDIS_SELECTED | CDIS_HOT))
            {
                rgbText = GetSysColor( COLOR_HIGHLIGHTTEXT );
            }

            // Is this item Checked?
            if (dwSMIF & SMIF_CHECKED)
            {
                rc.right = rc.left + (rc.bottom - rc.top);
                _DrawMenuGlyph(pnmcd->hdc, _pcmb->_pmbm->_hFontArrow
                    , &rc, CH_MENUCHECKA, rgbText, NULL);
                rc = pnmcd->rc;
            }

            // Is this a cascading item?
            if (dwSMIF & SMIF_SUBMENU)
            {
                // Yes; draw the arrow
                COLORREF crArrow = rgbText;

                if (_hTheme)
                {
                    int iState = MDS_NORMAL;
                    if (pnmcd->uItemState & CDIS_DISABLED)
                        iState = MDS_DISABLED;
                    else if ((pnmcd->uItemState & CDIS_HOT) && (pnmcd->uItemState & CDIS_CHECKED))
                        iState = MDS_HOTCHECKED;
                    else if (pnmcd->uItemState & CDIS_HOT)
                        iState = MDS_HOT;
                    else if (pnmcd->uItemState & CDIS_CHECKED)
                        iState = MDS_CHECKED;

                    GetThemeColor(_hTheme, 0, iState, TMT_TEXTCOLOR, &crArrow);
                }

                RECT rcT = rc;
   
                RECT rcClient;
                GetClientRect(_hwndMB, &rcClient);
                if (rcClient.right < rcT.right)
                {
                    rcT.right = rcClient.right;
                }
                rcT.left = rcT.right - _pcmb->_pmbm->_cxArrow;
                _DrawMenuArrowGlyph(pnmcd->hdc, &rcT, crArrow);
            }

            if (!_pszTheme)
            {
                _PaintButton3D(pnmcd->hdc, (UINT)pnmcd->dwItemSpec, &rc, dwSMIF);
            }
        }
        break;
    case CDDS_PREERASE:
        if (!_pszTheme)
        {
            RECT rcClient;
            GetClientRect(_hwndMB, &rcClient);
            ptbcd->clrBtnFace = _pcmb->_pmbm->_clrBackground;
            SHFillRectClr(pnmcd->hdc, &rcClient, _pcmb->_pmbm->_clrBackground);
            dwRet = CDRF_SKIPDEFAULT;
        }
        break;
    }

    return dwRet;
}    



void CMenuToolbarBase::_PressBtn(int idBtn, BOOL bDown)
{
    if (!_fVerticalMB)
    {
        DWORD dwState = ToolBar_GetState(_hwndMB, idBtn);

        if (bDown)
            dwState |= TBSTATE_PRESSED;
        else
            dwState &= ~TBSTATE_PRESSED;

        ToolBar_SetState(_hwndMB, idBtn, dwState);

        // Avoid ugly late repaints
        UpdateWindow(_hwndMB);
    }
}    


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuToolbarBase::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = S_FALSE;

    EnterModeless();

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        if ((SHIsExplorerIniChange(wParam, lParam) == EICH_UNKNOWN) || 
            (wParam == SPI_SETNONCLIENTMETRICS))
        {
            v_UpdateIconSize(-1, TRUE);
            v_Refresh();
            goto L_WM_SYSCOLORCHANGE;
        }
        break;

    case WM_SYSCOLORCHANGE:
    L_WM_SYSCOLORCHANGE:
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        SendMessage(_hwndMB, uMsg, wParam, lParam);
        InvalidateRect(_hwndMB, NULL, TRUE);
        hres = S_OK;
        break;

    case WM_PALETTECHANGED:
        InvalidateRect( _hwndMB, NULL, FALSE );
        SendMessage( _hwndMB, uMsg, wParam, lParam );
        hres = S_OK;
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hres = S_OK;
        break;
    }

    ExitModeless();

    return hres;
}


void CMenuToolbarBase::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));

    *pcxMin = 0;
    *pcxMax = 0;

    if (_fVerticalMB && _pcmb->_pmbm && _pcmb->_pmbm->_hFontMenu)
    {
        HIMAGELIST himl;
        int cel;
        int cxItemMax = 0;
        int cyItemMax = 0;
        HWND hwnd = _hwndMB;
        
        ASSERT(hwnd);
        
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
            HFONT hFontOld = (HFONT) SelectObject(hdc, _pcmb->_pmbm->_hFontMenu);

            if (hFontOld)
            {
                TCHAR sz[MAX_PATH];
                cel = ToolBar_ButtonCount(hwnd);

                // Find the maximum length text
                for (int i = 0; i < cel; i++)
                {
                    int idCmd = GetButtonCmd(hwnd, i);
                    if (_idCmdChevron != idCmd &&
                        !(!_pcmb->_fExpanded && v_GetFlags(idCmd) & SMIF_DEMOTED))
                    {
                        int cch = SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, NULL);
                        if (cch > 0 && cch < ARRAYSIZE(sz))
                        {
                            if (SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                            {
                                RECT rect = {0};
                                DWORD dwDTFlags = DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER;
                                if (ShowAmpersand())
                                    dwDTFlags |= DT_NOPREFIX;

                                DrawText(hdc, sz, -1, &rect, dwDTFlags);
                                cxItemMax = max(rect.right, cxItemMax);
                                cyItemMax = max(rect.bottom, cyItemMax);
                            }
                        }
                    }
                }

                SelectObject(hdc, hFontOld);
            }
            ReleaseDC(hwnd, hdc);
        }
        
        himl = (HIMAGELIST)SendMessage(hwnd, TB_GETIMAGELIST, 0, 0);
        if (himl)
        {
            int cy;
            
            // Start with the width of the button
            ImageList_GetIconSize(himl, pcxMin, &cy);

            // We want at least a bit of space around the icon
            if (_uIconSizeMB != ISFBVIEWMODE_SMALLICONS)
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added 2.
                ToolBar_SetPadding(hwnd, ICONFUDGE, 0);
                *pcxMin += 10;
            }
            else 
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added cySpacing, which defaults to 6.
                ToolBar_SetPadding(hwnd, ICONFUDGE, ICONFUDGE);
                *pcxMin += 3 * GetSystemMetrics(SM_CXEDGE);
            }

            cyItemMax = max(cyItemMax, cy) + ICONFUDGE;
        }

        
        RECT rect = {0};
        int cxDesired = _pcmb->_pmbm->_cxMargin + cxItemMax + _pcmb->_pmbm->_cxArrow;
        int cxMax = 0;
           
        if (SystemParametersInfoA(SPI_GETWORKAREA, 0, &rect, 0))
        {
            // We're figuring a third of the screen is a good max width
            cxMax = (rect.right-rect.left) / 3;
        }

        *pcxMin += min(cxDesired, cxMax) + LIST_GAP;
        *pcxMax = *pcxMin;
    }

    *pcxMin = max(*pcxMin, _cxMinMenu);
    TraceMsg(TF_MENUBAND, "CMenuToolbarBase::v_CalcWidth(%d, %d)", *pcxMin, *pcxMax);
}


void CMenuToolbarBase::_SetToolbarState()
{
    SHSetWindowBits(_hwndMB, GWL_STYLE, TBSTYLE_LIST, TBSTYLE_LIST);
}


void CMenuToolbarBase::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    GetWindowRect(_hwndMB, &rc);

    if (PtInRect(&rc, pt))
    {
        ScreenToClient(_hwndMB, &pt);
        SendMessage(_hwndMB, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}

void CMenuToolbarBase::NegotiateSize()
{
    HWND hwndParent = GetParent(_hwndMB);
    if (hwndParent && (GetDesktopWindow() != hwndParent))
    {
        RECT rc = {0};
        GetClientRect(hwndParent, &rc);
        _pcmb->OnPosRectChangeDB(&rc);
    }
    // If we came in here it's because the Menubar did not change sizes or position.
}

void CMenuToolbarBase::SetParent(HWND hwndParent) 
{ 
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (hwndParent)
    {
        if (!_hwndMB)
            CreateToolbar(hwndParent);
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
    }

    // We want to set the parent all the time because we don't want to destroy the 
    // window with it's parent..... Sizing to -1,-1,-1,-1 causes it not to be displayed.
    if (_hwndMB)
    {
        ::SetParent(_hwndMB, hwndParent); 
        SendMessage(_hwndMB, TB_SETPARENT, (WPARAM)hwndParent, NULL);
    }
}


void CMenuToolbarBase::v_OnEmptyToolbar()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    for (int iNumButtons = ToolBar_ButtonCount(_hwndMB) -1;
         iNumButtons >= 0; 
         iNumButtons--)
    {
        // HACKHACK (lamadio): For some reason, _fEmptyingToolbar gets set to FALSE.
        // We then Do a TB_DELETEBUTTON, which sends a notify. This does go through on
        // the top level menubands (Start Menu, Browser menu bar), and deletes the 
        // associated data. We then try and delete it again.
        // So now, I set null into the sub menu, so that the other code gracefully fails.

        TBBUTTONINFO tbbi = {0};
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
        ToolBar_GetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        void *pData = (void*)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        SendMessage(_hwndMB, TB_DELETEBUTTON, iNumButtons, 0);
        v_OnDeleteButton(pData);
    }
}

void CMenuToolbarBase::EmptyToolbar()
{
    if (_hwndMB)
    {
        _fEmptyingToolbar = TRUE;
        v_OnEmptyToolbar();
        _fEmptyingToolbar = FALSE;
    }
}

void CMenuToolbarBase::v_Close()
{
    EmptyToolbar();
    if (_hwndMB)
    {
        //Kill timers to prevent race condition
        KillTimer(_hwndMB, MBTIMER_POPOUT);
        KillTimer(_hwndMB, MBTIMER_DRAGOVER);
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_ENDEDIT);
        KillTimer(_hwndMB, MBTIMER_CLOSE);
        KillTimer(_hwndMB, MBTIMER_CLICKUNHANDLE);
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);

        DestroyWindow(_hwndMB);
        _hwndMB = NULL;
    }
}

void CMenuToolbarBase::Activate(BOOL fActivate)
{
    if (fActivate == FALSE)
    {
        _fEditMode = FALSE;
    }
}

int CMenuToolbarBase::_CalcChevronSize()
{

    int dSeg;
    int dxy = _pcmb->_pmbm->_cyChevron;

    dxy -= 4;
    dSeg = dxy / 4;

    return dSeg * 4 + 4;
}

void CMenuToolbarBase::_DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected)
{
    RECT rcBox = *prect;
    RECT rcDrop;

    const int dExtra = 3;
    int dxy;

    rcBox.left += dExtra;
    rcBox.right -= dExtra;
    dxy = _CalcChevronSize();

    rcDrop.left = ((rcBox.right + rcBox.left) >> 1) - (dxy/4);
    rcDrop.right = rcDrop.left + dxy - 1;

    int dSeg = ((RECTWIDTH(rcDrop) - 2) >> 2);

    rcDrop.top = (rcBox.top + rcBox.bottom)/2 - (2 * dSeg + 1);
    //rcDrop.bottom = rcBox.top;

    if (fFocus && !_pszTheme)
    {
        if (_pcmb->_pmbm->_fFlatMenuMode)
        {
            SHFillRectClr(hdc, prect, GetSysColor(COLOR_MENUHILIGHT));
            SHOutlineRect(hdc, prect, GetSysColor(COLOR_HIGHLIGHT));
        }
        else
        {
            InflateRect(&rcBox, 0, -3);
            SHFillRectClr(hdc, &rcBox, _pcmb->_pmbm->_clrDemoted);
            DrawEdge(hdc, &rcBox, fSelected? BDR_SUNKENINNER : BDR_RAISEDINNER, BF_RECT);

            if (fSelected)
            {
                rcDrop.top += 1;
                rcDrop.left += 1;
            }
        }
    }

    HBRUSH hbrOld = SelectBrush(hdc, _pcmb->_pmbm->_hbrText);


    int y = rcDrop.top + 1;
    int xBase = rcDrop.left+ dSeg;

    for (int x = -dSeg; x <= dSeg; x++)
    {
        PatBlt(hdc, xBase + x, y, 1, dSeg, PATCOPY);
        PatBlt(hdc, xBase + x, y+(dSeg<<1), 1, dSeg, PATCOPY);

        y += (x >= 0) ? -1 : 1;
    }

    SelectBrush(hdc, hbrOld);
}


// Takes into accout Separators, hidden and Disabled items
/*----------------------------------------------------------
Purpose: This function sets the nearest legal button to be
         the hot item, skipping over any separators, or hidden
         or disabled buttons.
    

*/

int CMenuToolbarBase::GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    if (iIndex == MBSI_LASTITEM)
    {
        // -2 is special value meaning "last item on toolbar"
        int cButtons = (int)SendMessage(_hwndMB, TB_BUTTONCOUNT, 0, 0);
        iIndex = cButtons - 1;
    }

    while ( (iCount == -1 || iIndex < iCount) && iIndex >= 0)
    {
        TBBUTTON tbb;

        // Toolbar will trap out of bounds condition when iCount is -1
        if (!SendMessage(_hwndMB, TB_GETBUTTON, iIndex, (LPARAM)&tbb))
            return -1;

        int idCmd = GetButtonCmd(_hwndMB, iIndex);


        if (tbb.fsState & TBSTATE_ENABLED && 
            !(tbb.fsStyle & TBSTYLE_SEP || 
              tbb.fsState & TBSTATE_HIDDEN) &&
              !(v_GetFlags(idCmd) & SMIF_DEMOTED && !_pcmb->_fExpanded) )
        {
            return iIndex;
        }
        else
            iIndex += iDir;
    }

    return -1;
}

BOOL CMenuToolbarBase::SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    int iPos = GetValidHotItem(iDir, iIndex, iCount, dwFlags);
    if (iPos >= 0)
        SendMessage(_hwndMB, TB_SETHOTITEM2, iPos, dwFlags);

    return (BOOL)(iPos >= 0);
}


static const BYTE g_rgsStateMap[][3] = 
{
#if defined(FIRST)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  2},      // State 3
    { 10,  1,  6},      // State 4
    {  7,  1,  2},      // State 5
    {  8,  1,  2},      // State 6
    { 11,  9,  2},      // State 7
    { 10,  1, 10},      // State 8
    { 11,  1,  2},      // State 9
    { 10,  1,  2},      // State 10     // End State
    { 12,  1,  2},      // State 11     // Flash.
    { 10,  1,  2},      // State 12
#elif defined(SECOND)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  9,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    { 10,  9,  8},      // State 12
    { 10,  9,  8},      // State 13
#elif defined(THIRD)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    { 12,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    { 13,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    {  4,  1,  2},      // State 12
    {  8,  5,  6},      // State 13
#else
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    {  4,  3,  4},      // State 11     // Flash.
#endif
};

#define MAX_STATE 13

void CMenuToolbarBase::_FireEvent(BYTE bEvent)
{
    // We don't want to expand and cover up any dialogs.
    if (_fSuppressUserMonitor)
        return;

    if (!_fHasDemotedItems)
        return;

    if (UEM_RESET == bEvent)
    {
        TraceMsg(TF_MENUBAND, "CMTB::UEM Reset state to 0");
        _pcmb->_pmbState->SetUEMState(0);
        return;
    }

    ASSERT(bEvent >= UEM_TIMEOUT && 
            bEvent <= UEM_HOT_FOLDER);

    BYTE bOldState = _pcmb->_pmbState->GetUEMState();
    BYTE bNewState = g_rgsStateMap[_pcmb->_pmbState->GetUEMState()][bEvent];

    ASSERT(bOldState >= 0 &&  bOldState <= MAX_STATE);

    TraceMsg(TF_MENUBAND, "*** UEM OldState (%d), New State (%d) ***", bOldState, bNewState);

    _pcmb->_pmbState->SetUEMState(bNewState);

    switch (bNewState)
    {
    case 10:    // End State
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 10. Expanding *** ", bOldState, bNewState);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        if (_pcmb->_fInSubMenu)
        {
            IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                &CGID_MenuBand, MBANDCID_EXPAND, 0, NULL, NULL);
        }
        else
        {
            Expand(TRUE);
        }
        _pcmb->_pmbState->SetUEMState(0);
        break;

    case 11:   // Flash
        // This gets reset when the flash is done...
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 11 Flashing *** ");
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        _FlashChevron();
        break;
    }
}


void CMenuToolbarBase::_FlashChevron()
{
    if (_idCmdChevron != -1)
    {
        _cFlashCount = 0;
        ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
        SetTimer(_hwndMB, MBTIMER_FLASH, MBTIMER_FLASHTIME, NULL);
    }
}


LRESULT CMenuToolbarBase::_DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Are we being asked for the IAccessible for the client?
    if (uMsg == WM_GETOBJECT && (OBJID_CLIENT == (DWORD)lParam))
    {
        // Don't process OBJID_MENU. By the time we get here, we ARE the menu.
        LRESULT lres = 0;
        CAccessible* pacc = new CAccessible(SAFECAST(_pcmb, IMenuBand*));
        if (pacc)
        {
            lres = pacc->InitAcc();
            if (SUCCEEDED((HRESULT)lres))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
            }
            pacc->Release();
        }

        return lres;
    }

    return 0;
}

void CMenuToolbarBase::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    // HACKHACK (lamadio): When we create the menubands, we do not set the
    // TOP level band's fonts until a refresh. This code here fixes it.
    if (_fFirstTime && _pcmb->_fTopLevel)
    {
        SetMenuBandMetrics(_pcmb->_pmbm);
    }

    if (fShow)
    {
        SetKeyboardCue();
        _pcmb->_pmbState->PutTipOnTop();
    }
    else
    {
        _fHasDrop = FALSE;
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);    // Don't show it if we're not displayed :-)
        _pcmb->_pmbState->HideTooltip(TRUE);
    }

    _fSuppressUserMonitor = FALSE;
}

void CMenuToolbarBase::SetKeyboardCue()
{
    if (_pcmb->_pmbState)
    {
        SendMessage(GetParent(_hwndMB), WM_CHANGEUISTATE, 
            MAKEWPARAM(_pcmb->_pmbState->GetKeyboardCue() ? UIS_CLEAR : UIS_SET,
            UISF_HIDEACCEL), 0);
    }
}

HRESULT CMenuToolbarBase::SetMinWidth(int cxMenu)
{
    _cxMinMenu = cxMenu;
    return S_OK;
}

HRESULT CMenuToolbarBase::SetNoBorder(BOOL fNoBorder)
{
    _fNoBorder = fNoBorder;
    return S_OK;
}

HRESULT CMenuToolbarBase::SetTheme(LPCWSTR pszTheme)
{
    HRESULT hr = S_OK;

    Str_SetPtr(&_pszTheme, pszTheme);

    if (_hwndMB)
    {
        SendMessage(_hwndMB, TB_SETWINDOWTHEME, 0, (LPARAM)_pszTheme);
        _RefreshTheme();
    }

    return hr;
}


void CMenuToolbarBase::_RefreshTheme()
{
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
    }

    _hTheme = OpenThemeData(_hwndMB, c_wzMenuBandTheme);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\menusite.h ===
#ifndef _MENUSITE_H_
#define _MENUSITE_H_

//#define WANT_CBANDSITE_CLASS

//#include "bandsite.h"
#include "cwndproc.h"

// MenuSite will never have more than one client.


class CMenuSite : public IBandSite,
                  public IDeskBarClient,
                  public IOleCommandTarget,
                  public IInputObject,
                  public IInputObjectSite,
                  public IWinEventHandler,
                  public IServiceProvider,
                  public CImpWndProc
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(IUnknown* punkSite);
    virtual STDMETHODIMP SetModeDBC(DWORD dwMode);
    virtual STDMETHODIMP UIActivateDBC(DWORD dwState);
    virtual STDMETHODIMP GetSize(DWORD dwWhich, LPRECT prc);

    // *** IWinEventHandler Methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IBandSite ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);


    CMenuSite();
    
protected:
    virtual ~CMenuSite();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _CreateSite(HWND hwndParent);
    void _CacheSubActiveBand(IUnknown * punk);


    IUnknown*   _punkSite;
    IUnknown*   _punkSubActive;
    IDeskBand*  _pdb;
    IWinEventHandler*   _pweh;
    HWND        _hwndChild;

    int         _cRef;    
};

#endif  // _MENUSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnbase.h ===
#ifndef MNBASE
#define MNBASE

// Characters for _DrawMenuGlyph
#define CH_MENUARROWA    '8'
#define CH_MENUARROW     TEXT(CH_MENUARROWA)
#define CH_MENUCHECKA    'a'
#define CH_MENUCHEVRONA  187

class CMenuBand;    // Forward Declare
class CMenuBandMetrics;

#define LIST_GAP 8      // from Observation

class CMenuToolbarBase: public IWinEventHandler, public IObjectWithSite
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd) PURE;
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods

    CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags);

    // Returns the HWND and Converts the pt to child.
    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) PURE;
    virtual BOOL v_TrackingSubContextMenu() PURE;
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) PURE;
    virtual void v_UpdateButtons(BOOL fNegotiateSize) PURE;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) PURE;
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd) PURE;
    virtual HRESULT v_ExecItem(int iCmd) PURE;
    virtual DWORD v_GetFlags(int iCmd) PURE;
    virtual void v_Refresh() PURE;
    virtual void v_Close();
    virtual void v_OnEmptyToolbar();
    virtual void v_OnDeleteButton(LPVOID pData) {};
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags) 
        { return E_NOTIMPL; };

    virtual void NegotiateSize();
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual void GetSize(SIZE*);
    virtual HRESULT CreateToolbar(HWND hwndParent);
    virtual void SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj) {return E_FAIL;};
    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) { return E_FAIL; };
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags) { return E_FAIL;};
    virtual void Expand(BOOL fExpand) {};

    HRESULT GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj);

    HRESULT PositionSubmenu(int idCmd);
    void Activate(BOOL fActivate);
    void SetMenuBandMetrics(CMenuBandMetrics* pmbm);
    void PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect);
    void PopupClose(void);
    HRESULT PopupOpen(int nCmd);
    void PopupHelper(int idCmd, BOOL bInitialSelect);
    void KillPopupTimer();
    void SetToTop(BOOL bToTop);
    void EmptyToolbar();        // override
    DWORD GetFlags(void)          { return _dwFlags; };
    BOOL DontShowEmpty()           { return _fDontShowEmpty; };
    void DontShowEmpty(BOOL fDontShowEmpty) { _fDontShowEmpty = BOOLIFY(fDontShowEmpty); };
    BOOL GetChevronID()               { return _idCmdChevron;  };
    int GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    BOOL SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    void SetKeyboardCue();
    inline virtual BOOL ShowAmpersand() { return FALSE; }
    HRESULT SetMinWidth(int cxMenu);
    HRESULT SetNoBorder(BOOL fNoBorder);
    HRESULT SetTheme(LPCWSTR pszTheme);

    virtual ~CMenuToolbarBase();

    BOOL IsEmpty()      { return _fEmpty; };

    HWND        _hwndMB;
    WCHAR*      _pszTheme;
    BOOL        _fNoBorder;
   
protected:
    virtual void v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual int  v_GetDragOverButton() PURE;
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) PURE;
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) PURE;
    
    // Window Proc Overrides
    LRESULT _DropDownOrExec(UINT idCmd, BOOL bKeyboard);
    virtual LRESULT v_OnCustomDraw(NMCUSTOMDRAW * pnmcd);
    void    _PaintButton3D(HDC hdc, int idCmd, LPRECT prc, DWORD dwMBIF);
    LRESULT _OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh);
    LRESULT _OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa);
    LRESULT _OnDupAccelerator(NMTBDUPACCELERATOR* pnmda);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);
    virtual LRESULT _OnTimer( WPARAM wParam );
    virtual void _FlashChevron();
    virtual LRESULT _DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL    _OnKey(BOOL bDown, UINT vk, UINT uFlags);
    void    _OnSelectArrow(int iDir);
    void    _FireEvent(BYTE bEvent);
    void    _RefreshTheme();

    // Utility Functions
    void    _DoPopup(int idCmd, BOOL bInitialSelect);
    virtual void    _SetFontMetrics();
    virtual void    _SetToolbarState();
    void    _PressBtn(int idBtn, BOOL bDown);
    HRESULT _SetMenuBand(IShellMenu* psm);
    BOOL    _SetTimer(int nTimer);

    void    _DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText );
    void    _DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize);

    int     _CalcChevronSize();
    void    _DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected);

    BOOL    _HandleObscuredItem(int idCmd);

    CMenuBand*  _pcmb;
    DEBUG_CODE (int _cRef);     // To debug references to the sub objects.
    DWORD       _dwFlags;           // SMSET_* flags
    UINT        _uIconSizeMB;
    UINT        _nItemTimer;
    int         _idCmdChevron;     // -1 if no chevron exists
    int         _cPromotedItems;    // Number of promoted items.
    BYTE        _cFlashCount;
    int         _idCmdLastClicked;
    int         _iLastClickedTime;
    int         _idCmdDragging;   
    int         _cxMinMenu;
    HTHEME      _hTheme;
    
    BITBOOL     _fHasDemotedItems: 1;
    BITBOOL     _fVerticalMB: 1;
    BITBOOL     _fTopLevel: 1;
    BITBOOL     _fEmpty : 1;
    BITBOOL     _fHasSubMenu: 1;
    BITBOOL     _fEditMode : 1;
    BITBOOL     _fClickHandled: 1;
    BITBOOL     _fProcessingWrapHotItem: 1;
    BITBOOL     _fEmptyingToolbar : 1;
    BITBOOL     _fMulticolumnMB : 1;
    BITBOOL     _fExpandTimer: 1;   // There is an expand timer.
    BITBOOL     _fIgnoreHotItemChange: 1;
    BITBOOL     _fShowMB: 1;
    BITBOOL     _fFirstTime: 1;
    BITBOOL     _fHasDrop: 1;
    BITBOOL     _fRefreshInfo: 1;
    BITBOOL     _fDontShowEmpty: 1;
    BITBOOL     _fSuppressUserMonitor: 1;
    BITBOOL     _fHorizInVerticalMB: 1;     // TRUE: Don't set EX_Vertical on the Toolbar
};


int     GetButtonCmd(HWND hwndTB, int iPos);
void*   ItemDataFromPos(HWND hwndTB, int iPos);
BOOL    SetHotItem(HWND hwnd, int iDir, int iIndex, int iCount, DWORD dwFlags);
long    GetIndexFromChild(BOOL fTop, int iIndex);
int     GetTBImageListWidth(HWND hwnd);

// UEM Parameters
#define UEM_TIMEOUT         0
#define UEM_HOT_ITEM        1
#define UEM_HOT_FOLDER      2

#define UEM_RESET           -1

// This fudge factor is to widen the icon spacing.
#define ICONFUDGE   4

// This fudge factor is the width we add on to the icon width in order to draw a "pleasent" background.
#define ICONBACKGROUNDFUDGE 5

#endif  // MNBASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnstatic.cpp ===
#include "shellprv.h"
#include "common.h"
#include "mnstatic.h"
#include "menuband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include <uxtheme.h>
#include "menuisf.h"

#define PGMP_RECALCSIZE  200

//***   IDTTOIDM -- convert idtCmd to idmMenu
// NOTES
//  as an optimization, we make the toolbar idtCmd the same as the menu idm.
// this macro (hopefully) makes things a bit clearer in the code by making
// the type conversion explicit.
#define IDTTOIDM(idtBtn)   (idtBtn)

BOOL TBHasImage(HWND hwnd, int iImageIndex);

//------------------------------------------------------------------------
//
// CMenuStaticToolbar::CMenuStaticData class
//
//------------------------------------------------------------------------


CMenuStaticToolbar::CMenuStaticData::~CMenuStaticData()
{
    ATOMICRELEASE(_punkSubMenu);
}


void CMenuStaticToolbar::CMenuStaticData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubMenu);
    _punkSubMenu = punk;
    if (_punkSubMenu)
        _punkSubMenu->AddRef();
}


HRESULT CMenuStaticToolbar::CMenuStaticData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj)
{
    if (_punkSubMenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubMenu, *pguidService, riid, ppvObj);
        }
        else
            return _punkSubMenu->QueryInterface(riid, ppvObj);
    }
    else
        return E_NOINTERFACE;
}



//------------------------------------------------------------------------
//
// CMenuStaticToolbar
//
//------------------------------------------------------------------------



CMenuStaticToolbar::CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags)
    : CMenuToolbarBase(pmb, dwFlags)
{
    _hmenu = hmenu;
    _hwndMenuOwner = hwnd;
    _idCmd = idCmd;
    _iDragOverButton = -1;
    _fDirty = TRUE;
}


CMenuStaticToolbar::~CMenuStaticToolbar()
{
    if (!(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }
}


STDMETHODIMP CMenuStaticToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMenuStaticToolbar, IDropTarget),
        { 0 },
    };

    // If you QI MenuStatic for a drop target, you get a different
    // one than if you QI MenuShellFolder. This breaks COM identity rules.
    // Proper fix would be to implement a drop target that encapsulates both.
    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CMenuToolbarBase::QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuStaticToolbar::_CheckSeparators()
{
    if (_fHasTopSep)
    {
        if (_pcmb->_pmtbTop->DontShowEmpty() )
        {
            if (!_fTopSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, 0, 0);
                _fTopSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fTopSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = MFT_SEPARATOR;
                _Insert(0, &mii);
                _fTopSepRemoved = FALSE;
            }
        }
    }

    if (_fHasBottomSep)
    {
        if (_pcmb->_pmtbBottom->DontShowEmpty() )
        {
            if (!_fBottomSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, ToolBar_ButtonCount(_hwndMB) - 1, 0);
                _fBottomSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fBottomSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = SMIT_SEPARATOR;
                _Insert(-1, &mii);
                _fBottomSepRemoved = FALSE;
            }
        }
    }
}


void CMenuStaticToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    CMenuToolbarBase::v_Show(fShow, fForceUpdate);
    _fShowMB = fShow;
    if (fShow)
    {
        _fFirstTime = FALSE;
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);
        ToolBar_SetHotItem(_hwndMB, -1);

        // Have the menubar think about changing its height
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);

        if (fForceUpdate)
            v_UpdateButtons(FALSE);

        CDelegateDropTarget::Init();
    }
    else
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}

void CMenuStaticToolbar::_Insert(int iIndex, MENUITEMINFO* pmii)
{
    CMenuStaticData* pmsd = new CMenuStaticData();
    if (pmsd)
    {
        BYTE bTBStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN;

        SMINFO sminfo = {0};
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;


        // These are somethings that the callback does not fill in:
        if ( pmii->hSubMenu )
            sminfo.dwFlags |= SMIF_SUBMENU;

        if ( pmii->fState & MFS_CHECKED)
            sminfo.dwFlags |= SMIF_CHECKED;

        if (pmii->fState & MFS_DISABLED || pmii->fState & MFS_GRAYED)
            sminfo.dwFlags |= SMIF_DISABLED;

        if ( pmii->fType & MFT_SEPARATOR)
        {
            sminfo.dwType = SMIT_SEPARATOR;
            bTBStyle &= ~TBSTYLE_BUTTON;
            bTBStyle |= TBSTYLE_SEP;
        }
        else
            sminfo.dwType = SMIT_STRING;

        if (!_fVerticalMB)
            bTBStyle |= TBSTYLE_AUTOSIZE;

        if (S_OK != CallCB(pmii->wID, SMC_GETINFO, 0, (LPARAM)&sminfo))
        {
            sminfo.iIcon = -1;
        }

        pmsd->_dwFlags = sminfo.dwFlags;

        // Now add it to the toolbar
        TBBUTTON tbb = {0};

        tbb.iBitmap = sminfo.iIcon;
        tbb.idCommand = pmii->wID;
        tbb.dwData = (DWORD_PTR)pmsd;
        tbb.fsState = (sminfo.dwFlags & SMIF_HIDDEN)?TBSTATE_HIDDEN : TBSTATE_ENABLED;
        tbb.fsStyle = bTBStyle; 
        if (_dwFlags & SMSET_NOPREFIX)
            tbb.fsStyle |= BTNS_NOPREFIX;

        TCHAR szMenuString[MAX_PATH];

        if (pmii->fType & MFT_OWNERDRAW)
        {
            // dwTypeData is user defined 32 bit value, not a string if MFT_OWNERDRAW is set
            // then the (unicode) string is the very first element in a structure dwItemData
            // points to
            LPWSTR pwsz = (LPWSTR)pmii->dwItemData;
            SHUnicodeToTChar(pwsz, szMenuString, ARRAYSIZE(szMenuString));
            tbb.iString = (INT_PTR)(szMenuString);
        }
        else
            tbb.iString = (INT_PTR)(LPTSTR)pmii->dwTypeData;

        SendMessage(_hwndMB, TB_INSERTBUTTON, iIndex, (LPARAM)&tbb);
    }
}


/*----------------------------------------------------------
Purpose: GetMenu method

*/
HRESULT CMenuStaticToolbar::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    if (phmenu)
        *phmenu = _hmenu;
    if (phwnd)
        *phwnd = _hwndMenuOwner;
    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return S_OK;
}

HRESULT CMenuStaticToolbar::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // When we are merging in a new menu, we need to destroy the old one if we own it.
    if (_hmenu && !(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }

    _hmenu = hmenu;
            
    // If we're processing a change notify, we cannot do anything that will modify state.
    if (_pcmb->_pmbState && 
        _pcmb->_pmbState->IsProcessingChangeNotify())
    {
        _fDirty = TRUE;
    }
    else
    {
        EmptyToolbar();
        _pcmb->_fInSubMenu = FALSE;
        IUnknown_SetSite(_pcmb->_pmpSubMenu, NULL);
        ATOMICRELEASE(_pcmb->_pmpSubMenu);

        if (_fShowMB)
            _FillToolbar();

        BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif

        // This causes a paint to occur right away instead of waiting until the
        // next message dispatch which could take a noticably long time.
        RedrawWindow(_hwndMB, NULL, NULL, (fSmooth? RDW_ERASE: 0) | RDW_INVALIDATE | RDW_UPDATENOW);  
    }
    return S_OK;
}


CMenuStaticToolbar::CMenuStaticData* CMenuStaticToolbar::_IDToData(int idCmd)
{
    CMenuStaticData* pmsd= NULL;

    // Initialize to NULL in case the GetButtonInfo Fails. We won't fault because
    // the lParam is just stack garbage. 
    TBBUTTONINFO tbbi = {0};
    int iPos;

    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    iPos = ToolBar_GetButtonInfo(_hwndMB, idCmd, &tbbi);
    if (iPos >= 0)
        pmsd = (CMenuStaticData*)tbbi.lParam;

    return pmsd;
}

HRESULT CMenuStaticToolbar::v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) 
{
    HRESULT hres = E_OUTOFMEMORY;
    int iPos = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (iPos >= 0)
    {
        CTrackPopupBar* ptpb = new CTrackPopupBar(_pcmb->_pmbState->GetContext(), iPos, _hmenu, _hwndMenuOwner);

        if (ptpb)
        {
            hres = ptpb->QueryInterface(riid, ppvObj);
            if (SUCCEEDED(hres))
                IUnknown_SetSite(SAFECAST(ptpb, IMenuPopup*), SAFECAST(_pcmb, IMenuPopup*));

            PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)_hmenu, (LPARAM)iPos);
            ptpb->Release();
        }
    }

    return hres;
}

HRESULT CMenuStaticToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuStaticData* pmsd = _IDToData(idCmd);

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    if (pmsd)
    {
        // Get the cached submenu
        hres = pmsd->GetSubMenu(pguidService, riid, ppvObj);

        // Did that fail?
        if (FAILED(hres) && (pmsd->_dwFlags & SMIF_SUBMENU) && 
            IsEqualGUID(riid, IID_IShellMenu))
        {
            // Yes; ask the callback for it
            hres = CallCB(idCmd, SMC_GETOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);

            if (S_OK != hres)
            {
                hres = E_OUTOFMEMORY;   // Set to error case incase something happens

                // Callback didn't handle it, try and see if we can get it
                MENUITEMINFO mii;
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU | MIIM_ID;
                if (GetMenuItemInfo(_hmenu, idCmd, MF_BYCOMMAND, &mii) && mii.hSubMenu)
                {
                    IShellMenu* psm = (IShellMenu*)new CMenuBand();
                    if (psm)
                    {
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        hres = psm->Initialize(_pcmb->_psmcb, idCmd, uIdAncestor, SMINIT_VERTICAL);
                        if (SUCCEEDED(hres))
                        {
                            hres = psm->SetMenu(mii.hSubMenu, _hwndMenuOwner, SMSET_TOP | SMSET_DONTOWN);
                            if (SUCCEEDED(hres))
                            {
                                hres = psm->QueryInterface(riid, ppvObj);
                            }
                        }
                        psm->Release();
                    }
                }
            }

            if (*ppvObj)
            {
                // Cache it now
                pmsd->SetSubMenu((IUnknown*)*ppvObj);

                // Initialize the fonts
                VARIANT Var;
                Var.vt = VT_UNKNOWN;
                Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                // Set the CMenuBandState  into the new menuband
                Var.vt = VT_INT_PTR;
                Var.byref = _pcmb->_pmbState;
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);

                ASSERT(IsEqualGUID(riid, IID_IShellMenu));
                _SetMenuBand((IShellMenu*)*ppvObj);
            }
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hres;
}


HRESULT CMenuStaticToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    return CallCB(idCmd, SMC_GETINFOTIP, (WPARAM)psz, (LPARAM)cch);
}


HRESULT CMenuStaticToolbar::v_ExecItem(int idCmd)
{
    HRESULT hres = CallCB(idCmd, SMC_EXEC, 0, 0);

    if (S_OK != hres && _hwndMenuOwner)
    {
        PostMessage(_hwndMenuOwner, WM_COMMAND, idCmd, 0);
        hres = S_OK;
    }

    return hres;
}

DWORD CMenuStaticToolbar::v_GetFlags(int idCmd)
{
    CMenuStaticData* pmsd = _IDToData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of erasing the background
    if (pmsd)
    {
        return pmsd->_dwFlags;
    }
    else
        return 0;
}


void CMenuStaticToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (S_FALSE == CallCB(idCmd, SMC_SELECTITEM, (WPARAM)fClear, 0))
    {
        UINT uFlags = (UINT)-1;
        if (v_GetFlags(idCmd) & SMIF_SUBMENU)
             uFlags = MF_POPUP;

        if (!fClear)
            uFlags = MF_HILITE;

        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(idCmd, uFlags), fClear? NULL : (LPARAM)_hmenu);

    }
}

BOOL CMenuStaticToolbar::v_TrackingSubContextMenu()
{
    return (_pcm != NULL);
}

HWND CMenuStaticToolbar::_CreatePager(HWND hwndParent)
{
    _hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL,
                             WS_CHILD | WS_TABSTOP |
                             WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                             0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
    if (_hwndPager)
    {
        hwndParent = _hwndPager;
    }

    return hwndParent;
}

HRESULT CMenuStaticToolbar::CreateToolbar(HWND hwndParent)
{
    HRESULT hr = S_OK;
    if (!_hwndMB)
    {
        if (_dwFlags & SMSET_USEPAGER)
        {
            hwndParent = _CreatePager(hwndParent);
        }

        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"),
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE  | TBSTYLE_REGISTERDROP,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_MENUBAND, "CMenuStaticToolbar::CreateToolbar: Failed to Create Toolbar");
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (_hwndPager)
            SendMessage(_hwndPager, PGM_SETCHILD, 0, (LPARAM)_hwndMB);

        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndMB, DLL_IS_UNICODE);

        _SubclassWindow(_hwndMB);
        _RegisterWindow(_hwndMB, NULL, SHCNE_UPDATEIMAGE);

        // Make sure we're on the same wavelength.
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        RECT rc;
        SIZE size;

        SystemParametersInfoA(SPI_GETWORKAREA, sizeof(RECT), &rc, FALSE);
        if (!_hwndPager)
        {
            size.cx = RECTWIDTH(rc);
            size.cy = GetSystemMetrics(SM_CYSCREEN) - (2 * GetSystemMetrics(SM_CYEDGE));    // Need to subrtact off the borders
        }
        else
        {
            //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
            size.cx = RECTWIDTH(rc);
            size.cy = 32000;
        }
        ToolBar_SetBoundingSize(_hwndMB, &size);

        if (_hwndPager)
        {
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_DRAGNDROP, PGS_DRAGNDROP);
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_AUTOSCROLL, PGS_AUTOSCROLL);
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_HORZ|PGS_VERT,
               _fVerticalMB ? PGS_VERT : PGS_HORZ);
        }

        SetWindowTheme(_hwndMB, L"", L"");
        hr = CMenuToolbarBase::CreateToolbar(hwndParent);
    }
    else if (GetParent(_hwndMB) != hwndParent)
        ::SetParent(_hwndMB, hwndParent);

    return hr;
}


STDMETHODIMP CMenuStaticToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_FAIL;

    AddRef();

    if (SHCNE_UPDATEIMAGE == lEvent) // global
    {
	hr = S_OK;

        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if (pidl2)
            {
                iImage = SHHandleUpdateImage( pidl2 );
                if ( iImage == -1 )
                {
		    hr = E_FAIL;
                }
            }
            
	    if (SUCCEEDED(hr) && (iImage == -1 || TBHasImage(_hwndMB, iImage)))
            {
                v_UpdateIconSize(-1, TRUE);
                v_Refresh();
            }
        } 
	else
	{
	    v_Refresh();
	}
    }

    Release();

    return hr;
}


LRESULT CMenuStaticToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch(uMessage)
    {
    case WM_TIMER:
        if (_OnTimer(wParam)) 
            return 1;
        break;
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;

    }

    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we fix mnfolder.cpp.
HRESULT CMenuStaticToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    psmd->dwMask = SMDM_HMENU;

    psmd->hmenu = _hmenu;
    psmd->hwnd = _hwndMenuOwner;
    psmd->uIdParent = _idCmd;
    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndMB, ToolBar_GetHotItem(_hwndMB));
    psmd->uId = IDTTOIDM(idtCmd);
    psmd->punk = SAFECAST(_pcmb, IShellMenu*);
    psmd->punk->AddRef();

    return S_OK;
}

HRESULT CMenuStaticToolbar::CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hres = S_FALSE;

    // todo: call v_GetState (but see comment in mnfolder.cpp)
    smd.dwMask = SMDM_HMENU;

    smd.hmenu = _hmenu;
    smd.hwnd = _hwndMenuOwner;
    smd.uIdParent = _idCmd;
    smd.uIdAncestor = _pcmb->_uIdAncestor;
    smd.uId = idCmd;
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hres = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    return hres;
}

HRESULT CMenuStaticToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int idm;

    idm = IDTTOIDM(idtCmd);
    return CallCB(idm, uMsg, wParam, lParam);
}



void CMenuStaticToolbar::v_UpdateButtons(BOOL fNegotiateSize)
{
    if (_hwndMB)
    {
        _SetToolbarState();
        int cxMin, cxMax;
        v_CalcWidth(&cxMin, &cxMax);
        SendMessage(_hwndMB, TB_SETBUTTONWIDTH, 0, MAKELONG(cxMin, cxMax));
        SendMessage(_hwndMB, TB_AUTOSIZE, 0, 0);

        // Should we renegotiate size? AND are we vertical,
        // because we cannot renegoitate when horizontal.
        if (fNegotiateSize && _fVerticalMB)
            NegotiateSize();
    }
}

BOOL CMenuStaticToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    if (-1 == uIconSize)
        uIconSize = _uIconSizeMB;
    BOOL fChanged = (_uIconSizeMB != uIconSize);
    
    _uIconSizeMB = uIconSize;

    if (_hwndMB)
    {
        if (_fVerticalMB)
        {
            HIMAGELIST himlLarge, himlSmall;

            // set the imagelist size
            for (int i = 0; CallCB(i, SMC_GETIMAGELISTS, (WPARAM)&himlLarge, (LPARAM)&himlSmall) == S_OK; i++)
            {
                HIMAGELIST himl = (_uIconSizeMB == ISFBVIEWMODE_LARGEICONS) ? himlLarge : himlSmall;
                SendMessage(_hwndMB, TB_SETIMAGELIST, i, (LPARAM)himl);
            }

            if (i == 0)
            {
                IImageList* piml;
                int iImageList = (_uIconSizeMB == ISFBVIEWMODE_LARGEICONS) ? SHIL_LARGE : SHIL_SYSSMALL;
                HRESULT hr = SHGetImageList(iImageList, IID_PPV_ARG(IImageList, &piml));
                if (SUCCEEDED(hr))
                {
                    SendMessage(_hwndMB, TB_SETIMAGELIST, 0, (LPARAM)IImageListToHIMAGELIST(piml));
                    piml->Release();
                }
            }
        }
        else
        {
            // sending a null himl is significant..  it means no image list
            SendMessage(_hwndMB, TB_SETIMAGELIST, 0, NULL);
        }

        if (fUpdateButtons)
            v_UpdateButtons(TRUE);
    }
    
    return fChanged;
}


void CMenuStaticToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;

    if (pdi->dwMask & TBNF_IMAGE) 
    {
        if (_fVerticalMB)
        {
            SMINFO smi;
            smi.dwMask = SMIM_ICON;
            if (CallCB(pdi->idCommand, SMC_GETINFO, 0, (LPARAM)&smi) == S_OK)
                pdi->iImage = smi.iIcon;
            else
                pdi->iImage = -1;
        }
        else
            pdi->iImage = -1;

    }
    
    if (pdi->dwMask & TBNF_TEXT) 
    {
        if (pdi->pszText) 
        {
            if (fUnicode) 
            {
                pdi->pszText[0] = 0;
            }
            else 
            {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;

    return;
}

LRESULT CMenuStaticToolbar::_OnGetObject(NMOBJECTNOTIFY* pon)
{
    pon->hResult = QueryInterface(*pon->piid, &pon->pObject);

    return 1;
}

LRESULT CMenuStaticToolbar::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;

    if (_hwndPager && (lpnmhi->dwFlags & (HICF_ARROWKEYS | HICF_ACCELERATOR)) )
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;            
        
        int iSelected = ToolBar_CommandToIndex(_hwndMB, lpnmhi->idNew);
        iOldPos = (int)SendMessage(_hwndPager, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndMB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);
        
        if (rc.top < iOldPos) 
        {
             iNewPos =rc.top;
        }
        
        GetClientRect(_hwndPager, &rcPager);
        heightPager = RECTHEIGHT(rcPager);
        
        if (rc.top >= iOldPos + heightPager)  
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }
        
        if (iNewPos != iOldPos)
            SendMessage(_hwndPager, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }

    return CMenuToolbarBase::_OnHotItemChange(pnm);
}

LRESULT CMenuStaticToolbar::v_OnCustomDraw(NMCUSTOMDRAW * pnmcd)
{
    LRESULT lRes = CMenuToolbarBase::v_OnCustomDraw(pnmcd);

#ifdef FLATMENU_ICONBAR
    // In flat menu mode, we may have an icon banner
    if (pnmcd->dwDrawStage == CDDS_PREERASE && _pcmb->_pmbm->_fFlatMenuMode)
    {
        UINT cBits = GetDeviceCaps(pnmcd->hdc, BITSPIXEL);

        // We only do the banner on 16bit color
        if (cBits > 8)
        {
            RECT rcClient;
            GetClientRect(_hwndMB, &rcClient);
            // This draw's the gradient along the background of the icons
            // We only do it in large icons for "design" reasons.
            if (_uIconSizeMB == ISFBVIEWMODE_LARGEICONS)
            {
                rcClient.right = GetTBImageListWidth(_hwndMB) + ICONBACKGROUNDFUDGE;
                COLORREF cr1 = GetSysColor(COLOR_MENU);
                COLORREF cr2 = _pcmb->_pmbm->_clrMenuGrad;
                TRIVERTEX pt[2];
                GRADIENT_RECT gr;
                pt[0].x = 0;
                pt[0].y = 0;
                pt[1].x = RECTWIDTH(rcClient);
                pt[1].y = RECTHEIGHT(rcClient);

                pt[0].Red = GetRValue(cr1) << 8;
                pt[0].Green = GetGValue(cr1) << 8;
                pt[0].Blue = GetBValue(cr1) << 8;
                pt[0].Alpha = 0x0000;
                pt[1].Red = GetRValue(cr2) << 8;
                pt[1].Green = GetGValue(cr2) << 8;
                pt[1].Blue = GetBValue(cr2) << 8;
                pt[1].Alpha = 0x0000;


                gr.UpperLeft = 0;
                gr.LowerRight = 1;

                GradientFill(pnmcd->hdc, pt, 2, &gr, 1, GRADIENT_FILL_RECT_V);
            }
            else
            {
                rcClient.right = GetTBImageListWidth(_hwndMB) + ICONBACKGROUNDFUDGE;

                SHFillRectClr(pnmcd->hdc, &rcClient, _pcmb->_pmbm->_clrMenuGrad);
            }
        }
    }
#endif

    return lRes;

}

LRESULT CMenuStaticToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    //The following statement traps all pager control notification messages.
    if ((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        return SendMessage(_hwndMB, WM_NOTIFY, (WPARAM)0, (LPARAM)pnm);
    }

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
        lres = 0;
        break;
    
    case TBN_DELETINGBUTTON:
    {
        if (!_fEmptyingToolbar)
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            CMenuStaticData* pmsd = (CMenuStaticData*)ptbn->tbButton.dwData;
            if (pmsd)
                delete pmsd;
        }
        break;    
    }

    case NM_TOOLTIPSCREATED:
        SHSetWindowBits(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST, TTS_ALWAYSTIP | TTS_TOPMOST);
        SendMessage(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);        
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    
    case TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_MAPACCELERATOR:
        lres = _OnAccelerator((NMCHAR*)pnm);
        break;

    default:
        lres = CMenuToolbarBase::_OnNotify(pnm);
    }

    return(lres);
}

void CMenuStaticToolbar::_FillToolbar()
{
    if (_fDirty && _hmenu && _hwndMB && !_pcmb->_fClosing)
    {
        EmptyToolbar();
        BOOL_PTR fRedraw = SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

        TCHAR szName[MAX_PATH];
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

        int iCount = GetMenuItemCount(_hmenu);
        for (int i = 0; i < iCount; i++)
        {
            mii.dwTypeData = szName;
            mii.cch = ARRAYSIZE(szName);
            if (GetMenuItemInfo(_hmenu, i, MF_BYPOSITION, &mii))
            {
                if (mii.fType & MFT_SEPARATOR)
                {
                    if (i == 0)
                        _fHasTopSep = TRUE;
                    else if (i == iCount - 1)
                        _fHasBottomSep = TRUE;
                }

                _Insert(i, &mii);
            }
        }

        if (iCount == 0)
            _fEmpty = TRUE;

        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);

        SendMessage(_hwndMB, WM_SETREDRAW, fRedraw, 0);

        _fDirty = FALSE;
        v_UpdateButtons(TRUE);
        _pcmb->ResizeMenuBar();
    }
}

void CMenuStaticToolbar::v_OnDeleteButton(void *pData)
{
    CMenuStaticData* pmsd = (CMenuStaticData*)pData;
    if (pmsd)
        delete pmsd;
}

void CMenuStaticToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    _fDirty = TRUE;
    _fHasTopSep = FALSE;
    _fHasBottomSep = FALSE;
    _fTopSepRemoved = FALSE;
    _fBottomSepRemoved = FALSE;
}

void CMenuStaticToolbar::v_Close()
{
    if (_hwndMB)
    {
        _UnregisterWindow(_hwndMB);
        _UnsubclassWindow(_hwndMB);
    }    
    CMenuToolbarBase::v_Close();

    if (_hwndPager)
    {
        DestroyWindow(_hwndPager);  // Should Destroy Toolbar.
        _hwndPager = NULL;
    }
}

void CMenuStaticToolbar::v_Refresh()
{
    EmptyToolbar();
    _FillToolbar();
    v_UpdateButtons(TRUE);
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuStaticToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB || _hwndPager == hwnd || hwnd == HWND_BROADCAST) 
        return S_OK;
    else 
        return S_FALSE; 
}




/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetWindowsDDT

*/
HRESULT CMenuStaticToolbar::GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) 
{ 
    *phwndLock = _hwndMB;
    *phwndScroll = _hwndMB; 
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

*/
HRESULT CMenuStaticToolbar::HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP))
        {
            _pcmb->_pmbState->HasDrag(TRUE);
            GetMessageFilter()->PreventCapture(TRUE);
            if (_pcmb->_pmtbShellFolder &&
                _pcmb->_pmtbShellFolder->DontShowEmpty())
            {
                DAD_ShowDragImage(FALSE);
                _pcmb->_pmtbShellFolder->DontShowEmpty(FALSE);
                _pcmb->ResizeMenuBar();
                UpdateWindow(_hwndMB);
                DAD_ShowDragImage(TRUE);
            }
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        {
            TBINSERTMARK tbim;
            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;

            if (WindowFromPoint(pt) == _hwndPager ) 
            {
                *pdwId = IBHT_PAGER;
            } 
            else if (!ToolBar_InsertMarkHitTest(_hwndMB, &pt, &tbim))
            {
                int idCmd = GetButtonCmd(_hwndMB, tbim.iButton);

                DWORD dwFlags = v_GetFlags(idCmd);
                if (((dwFlags & SMIF_DROPCASCADE) || (dwFlags & SMIF_DROPTARGET) || (dwFlags & SMIF_DRAGNDROP)) &&
                    (tbim.iButton != _iDragOverButton))
                {
                    *pdwId = idCmd;

                    DAD_ShowDragImage(FALSE);
                    _pcmb->SetTracked(this);
                    _iDragOverButton = tbim.iButton;
                    SetTimer(_hwndMB, MBTIMER_DRAGOVER, 1000, NULL);
                    _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
                    BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndMB, FALSE);
                    ToolBar_SetHotItem(_hwndMB, _iDragOverButton);
                    ToolBar_SetAnchorHighlight(_hwndMB, fOldAnchor);
                    UpdateWindow(_hwndMB);
                    DAD_ShowDragImage(TRUE);
                }
            }
        }
        break;

    case HTDDT_LEAVE:
        // We can take the capture back anytime now
        _pcmb->_pmbState->HasDrag(FALSE);
        _SetTimer(MBTIMER_DRAGPOPDOWN);
        GetMessageFilter()->PreventCapture(FALSE);
        _iDragOverButton = -1;
        DAD_ShowDragImage(FALSE);
        ToolBar_SetHotItem(_hwndMB, -1);
        DAD_ShowDragImage(TRUE);
        break;
    }
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CMenuStaticToolbar::GetObjectDDT (DWORD_PTR dwId, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    // FEATURE: Pager Support look in mnfolder.cpp

    if (dwId == IBHT_PAGER)
    {
        SendMessage(_hwndPager, PGM_GETDROPTARGET, 0, (LPARAM)ppvObj);
    }
    else
    {
        SMDATA smd = {0};
        smd.punk = SAFECAST(_pcmb, IShellMenu*);
        smd.uIdParent = (UINT) dwId;
        if (_pcmb->_psmcb)
        {
            hres = _pcmb->_psmcb->CallbackSM(&smd, SMC_GETOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);

            if (hres == S_FALSE)
                hres = E_FAIL;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CMenuStaticToolbar::OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return E_NOTIMPL;
}



HRESULT CMenuStaticToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            // Refresh the whole thing
            v_Refresh();
        }
    }

    // Are we dealing with an Hmenu?
    // Have we filled it yet?  (If not, then we can skip the invalidate
    // here, because we'll catch it when we fill it.)
    else if ((psmd->dwMask & SMDM_HMENU) && !_fDirty)
    {
        // Yes; What are they asking for?

        int iPos = -1;   // Assume this is a position
        int idCmd = -1;

        // Did they pass an ID instead of a position?
        if (dwFlags & SMINV_ID)
        {
            // Yes; Crack out the position.
            iPos = GetMenuPosFromID(_hmenu, psmd->uId);
            idCmd = psmd->uId;
        }

        if (dwFlags & SMINV_POSITION)
        {
            iPos = psmd->uId;
            idCmd = GetMenuItemID(_hmenu, iPos);
        }


        if (dwFlags & SMINV_REFRESH)
        {
            // Do they want to refresh a sepcific button?
            if (idCmd >= 0)
            {
                // Yes;

                // First delete the old one if it exists.
                int iTBPos = ToolBar_CommandToIndex(_hwndMB, idCmd);

                if (iTBPos >= 0)
                    SendMessage(_hwndMB, TB_DELETEBUTTON, iTBPos, 0);

                // Now Insert a new one
                MENUITEMINFO mii;
                TCHAR szName[MAX_PATH];
                mii.cbSize = sizeof(mii);
                mii.cch = ARRAYSIZE(szName);
                mii.dwTypeData = szName;
                mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

                // This can fail...
                if (GetMenuItemInfo(_hmenu, iPos, MF_BYPOSITION, &mii))
                {
                    _Insert(iPos, &mii);
                    hres = S_OK;
                }
            }
            else
            {
                // No; Refresh the whole thing
                v_Refresh();
            }

            if (!_fShowMB)
                _pcmb->_fForceButtonUpdate = TRUE;

            _pcmb->ResizeMenuBar();
        }
    }

    return hres;
}

void CMenuStaticToolbar::GetSize(SIZE* psize)
{
    _CheckSeparators();

    CMenuToolbarBase::GetSize(psize);
}

LRESULT CMenuStaticToolbar::_OnAccelerator(NMCHAR* pnmChar)
{
    SMDATA smdOut = {0};
    SMDATA smd = {0};
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.uIdParent = _pcmb->_uId;

    if (_pcmb->_psmcb &&
        S_FALSE != _pcmb->_psmcb->CallbackSM(&smd, SMC_MAPACCELERATOR, (WPARAM)pnmChar->ch, (LPARAM)&smdOut))
    {
        pnmChar->dwItemNext = ToolBar_CommandToIndex(_hwndMB, smdOut.uId);;
        return TRUE;
    }

    return FALSE;
}

LRESULT CMenuStaticToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    LockSetForegroundWindow(LSFW_UNLOCK);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
    {
        RECT rc;
        LPRECT prcExclude = NULL;
        POINT pt;
        int i;

        if (lParam != (LPARAM)-1) 
        {
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            POINT pt2 = pt;
            MapWindowPoints(HWND_DESKTOP, _hwndMB, &pt2, 1);

            i = ToolBar_HitTest(_hwndMB, &pt2);
        } 
        else 
        {
            // keyboard context menu.
            i = (int)SendMessage(_hwndMB, TB_GETHOTITEM, 0, 0);
            if (i >= 0) 
            {
                SendMessage(_hwndMB, TB_GETITEMRECT, i, (LPARAM)&rc);
                MapWindowPoints(_hwndMB, HWND_DESKTOP, (LPPOINT)&rc, 2);
                pt.x = rc.left;
                pt.y = rc.bottom;
                prcExclude = &rc;
            }
        }
        if (i >= 0)
        {
            UINT idCmd = GetButtonCmd(_hwndMB, i);
            if (S_OK == CallCB(idCmd, SMC_GETOBJECT, (WPARAM)(GUID*)&IID_IContextMenu, (LPARAM)(void**)(&_pcm)))
            {
                TPMPARAMS tpm;
                TPMPARAMS * ptpm = NULL;

                if (prcExclude)
                {
                    tpm.cbSize = sizeof(tpm);
                    tpm.rcExclude = *((LPRECT)prcExclude);
                    ptpm = &tpm;
                }
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    KillTimer(_hwndMB, MBTIMER_INFOTIP);
                    _pcmb->_pmbState->HideTooltip(FALSE);

                    _pcm->QueryContextMenu(hmenu, 0, 0, -1, 0);

                    idCmd = TrackPopupMenuEx(hmenu,
                        TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                        pt.x, pt.y, _hwndMB, ptpm);

                    CMINVOKECOMMANDINFO ici = {
                        sizeof(CMINVOKECOMMANDINFO),
                        0,
                        _hwndMB,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    _pcm->InvokeCommand(&ici);

                    DestroyMenu(hmenu);
                }

                ATOMICRELEASE(_pcm);
            }
        }

        GetMessageFilter()->RetakeCapture();
    }

    return lres;
}

STDMETHODIMP CMenuStaticToolbar::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (WM_CONTEXTMENU == dwMsg)
    {
        *plres = _OnContextMenu(wParam, lParam);
    }
    else
        return CMenuToolbarBase::OnWinEvent(hwnd, dwMsg, wParam, lParam, plres);

    return S_OK;
}

void CMenuStaticToolbar::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    HWND    hwndFwd;
    
    // These are in screen coords
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    hwndFwd = _hwndPager ? _hwndPager : _hwndMB;
    GetWindowRect(hwndFwd, &rc);

    if (PtInRect(&rc, pt))
    {
        MapWindowPoints(NULL, hwndFwd, &pt, 1);
        HWND hwnd = ChildWindowFromPoint(hwndFwd, pt);

        if (hwnd) 
        {
            MapWindowPoints(hwndFwd, hwnd, &pt, 1);
        }
        else
        {
            hwnd = hwndFwd;
        }

        SendMessage(hwnd, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}

void CMenuStaticToolbar::SetParent(HWND hwndParent)
{ 
    int nCmdShow = SW_SHOW;
    if (hwndParent)
    {
        if (!_hwndMB)
            CreateToolbar(hwndParent);
        else
        {
            // make sure width is set correctly . . . 
            // SendMessage(_hwndMB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));
        }
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
        nCmdShow = SW_HIDE;
    }


    HWND hwnd = _hwndPager ? _hwndPager: _hwndMB;
    
    if (IsWindow(hwnd)) // JANK : Fix for bug #98253
    {
       if (nCmdShow == SW_HIDE)
       {
           ShowWindow(hwnd, nCmdShow);
       }

       ::SetParent(hwnd, hwndParent); 
       SendMessage(hwnd, TB_SETPARENT, (WPARAM)hwndParent, NULL);

       if (nCmdShow == SW_SHOW)
       {
           ShowWindow(hwnd, nCmdShow);
       }
    }
}


void CMenuStaticToolbar::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (!_hwndPager)
    {
        CMenuToolbarBase::SetWindowPos(psize, prc, dwFlags);
        return;
    }
    DWORD rectWidth = RECTWIDTH(*prc);

    TraceMsg(TF_MENUBAND, "CMSFTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
        prc->left, prc->top, prc->right, prc->bottom);

    ShowWindow(_hwndPager, SW_SHOW);
    ::SetWindowPos(_hwndPager, NULL, prc->left, prc->top, 
        rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
    if (psize)
    {
        int cx = psize->cx;
        ToolBar_SetButtonWidth(_hwndMB, cx, cx);
    }

    SendMessage(_hwndPager, PGMP_RECALCSIZE, 0L, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnfolder.cpp ===
#include "shellprv.h"
#include "common.h"
#include "menuband.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "mnfolder.h"
#include "icotask.h"
#include "util.h"
#include <uxtheme.h>

#define PGMP_RECALCSIZE  200

HRESULT IUnknown_RefreshParent(IUnknown* punk, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    IShellMenu* psm;
    HRESULT hr = IUnknown_QueryService(punk, SID_SMenuBandParent, IID_PPV_ARG(IShellMenu, &psm));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlParent = ILClone(pidl);
        if (pidlParent)
        {
            SMDATA smd;
            ILRemoveLastID(pidlParent);
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = pidlParent;
            smd.pidlItem = ILFindLastID(pidl);
            hr = psm->InvalidateItem(&smd, dwFlags);
            ILFree(pidlParent);
        }
        psm->Release();
    }

    return hr;
}

void CMenuData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubmenu);
    _punkSubmenu = punk;
    if (_punkSubmenu)
        _punkSubmenu->AddRef();
}

HRESULT CMenuData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppv)
{
    // pguidService is for asking specifically for the Shell Folder portion or the Static portion
    if (_punkSubmenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubmenu, *pguidService, riid, ppv);
        }
        else
            return _punkSubmenu->QueryInterface(riid, ppv);
    }
    else
        return E_NOINTERFACE;
}

CMenuData::~CMenuData()
{
    ATOMICRELEASE(_punkSubmenu);
}

STDMETHODIMP CMenuSFToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hr = CMenuToolbarBase::QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        hr = CSFToolbar::QueryInterface(riid, ppvObj); 
    
    return hr;
}

//-------------------------------------------------------------------------
//
//  CMenuSFToolbar class
//
//-------------------------------------------------------------------------

#define SENTINEL_EMPTY          0
#define SENTINEL_CHEVRON        1
#define SENTINEL_SEP            2

#define PIDLSENTINEL(i)     ((LPCITEMIDLIST)MAKEINTRESOURCE(i))
#define POISENTINEL(i)      ((PORDERITEM)   MAKEINTRESOURCE(i))

STDMETHODIMP CMenuSFToolbar::SetSite(IUnknown* punkSite)
{
    HRESULT hr = CMenuToolbarBase::SetSite(punkSite);
    if (SUCCEEDED(hr)) 
    {
        _fMulticolumnMB = BOOLIFY(_pcmb->_dwFlags & SMINIT_MULTICOLUMN);
        _fMulticolumn = _fMulticolumnMB;
        _fVertical = _fVerticalMB;
        if (_fVerticalMB)
            _dwStyle |= CCS_VERT;

    }
    return hr;
}

CMenuSFToolbar::CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags) 
    : CMenuToolbarBase(pmb, dwFlags)
    , _idCmdSep(-1)
{
    // Change this to IStream
    _hKey = hKey;

    // Do we have a place to persist our reorder?
    if (_hKey == NULL)
    {
        // No, then don't allow it.
        _fAllowReorder = FALSE;
    }


    _dwStyle |= TBSTYLE_REGISTERDROP;
    _dwStyle &= ~TBSTYLE_TOOLTIPS;      // We handle our own tooltips.

    _iDefaultIconIndex = -1;

    SetShellFolder(psf, pidl);

    _AfterLoad();
}

HRESULT CMenuSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = CSFToolbar::SetShellFolder(psf, pidl);
    ATOMICRELEASE(_pasf2);

    if (psf)
        psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder2, &_pasf2));

    if (!_pasf2)
    {
        // SMSET_SEPARATEMERGEFOLDER requires IAugmentedShellFolder2 support
        _dwFlags &= ~SMSET_SEPARATEMERGEFOLDER;
    }

    if (_dwFlags & SMSET_SEPARATEMERGEFOLDER)
    {
        // Remember the namespace GUID of the one to highlight
        DWORD dwNSId;
        if (SUCCEEDED(_pasf2->EnumNameSpace(0, &dwNSId)))
        {
            _pasf2->QueryNameSpace(dwNSId, &_guidAboveSep, NULL);
        }
    }

    return hr;
}

CMenuSFToolbar::~CMenuSFToolbar()
{
    ASSERT(_pcmb->_cRef == 0 || _pcmb->_pmtbShellFolder == NULL);
    _hwndWorkerWindow = NULL;       // This is destroyed by the _pmbState destructor. 
                                    // Prevent a double delete which happens in the base class.
    ATOMICRELEASE(_pasf2);
    if (_hKey)
        RegCloseKey(_hKey);
}


void CMenuSFToolbar::v_Close()
{
    CMenuToolbarBase::EmptyToolbar();
    _UnregisterToolbar();

    if (_hwndPager)
    {
        DestroyWindow(_hwndPager);  // Should Destroy Toolbar.
    }
    else if (_hwndMB)
    {
        // In the MultiColumn case, there is no pager so we have to 
        // manually destroy the Toolbar
        DestroyWindow(_hwndMB);
    }

    _hwndPager = NULL;
    _hwndMB = NULL;
    _hwndTB = NULL;
}


PIBDATA CMenuSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return (PIBDATA)new CMenuData(poi);
}


HRESULT CMenuSFToolbar::_AfterLoad()
{
    HRESULT hr = CSFToolbar::_AfterLoad();

    if (SUCCEEDED(hr))
        _LoadOrderStream();

    return hr;
}


HRESULT CMenuSFToolbar::_LoadOrderStream()
{
    OrderList_Destroy(&_hdpaOrder);
    IStream* pstm;
    HRESULT hr = E_FAIL;

    if (_hKey)
    {
        // We use "Menu" for Backwards compatibility with shdoc401 start menu, but having no
        // sub key is more correct (Other places use it) so on NT5 we use the new method.
        pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""), 
            TEXT("Order"), STGM_READ);
    }
    else
    {
        if (S_FALSE == CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
            pstm = NULL;
    }

    if (pstm)
    {
        hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
        _fHasOrder = FALSE;
        _fAllowReorder = TRUE;

        // Check to see if we have a persisted order. If we don't have a persisted order,
        // then all of the items are -1. If just one of those has a number other than
        // -1, then we do have "Order" and should use that instead of alphabetizing.
        if (_hdpaOrder)
        {
            for (int i = 0; !_fHasOrder && i < DPA_GetPtrCount(_hdpaOrder); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpaOrder, i);
                if (poi->nOrder != MNFOLDER_NORODER)
                    _fHasOrder = TRUE;
            }
        }
        pstm->Release();
    }
    return hr;
}

HRESULT CMenuSFToolbar::_SaveOrderStream()
{
    IStream* pstm;
    HRESULT hr = E_FAIL;

    // Persist the new order out to the registry
    // It is reasonable to assume that if we don't have an _hdpa we have
    // not filled the toolbar yet. Since we have not filled it, we haven't changed
    // the order, so we don't need to persist out that order information.
    if (_hdpa)
    {
        // Always save this information
        _FindMinPromotedItems(TRUE);

        // Did we load an order stream when we initialized this pane?
        if (!_fHasOrder)
        {
            // No; Then we do not want to persist the order. We will initialize
            // all of the order items to -1. This is backward compatible because
            // IE 4 will merge alphabetically, but revert to a persited order when saving.
            for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
                poi->nOrder = MNFOLDER_NORODER;
            }
        }

        if (_hKey)
        {
            pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""), 
                TEXT("Order"), STGM_CREATE | STGM_WRITE);
        }
        else
        {
            if (S_OK != CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
                pstm = NULL;
        }

        if (pstm)
        {
            hr = OrderList_SaveToStream(pstm, _hdpaOrder ? _hdpaOrder : _hdpa, _psf);
            if (SUCCEEDED(hr))
            {
                CallCB(NULL, SMC_SETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm);
            }
            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
        hr = CSFToolbar::_SaveOrderStream();

    return hr;
}


void CMenuSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(_fDropping);

    CSFToolbar::_Dropped(nIndex, fDroppedOnSource);

    SHPlaySound(TEXT("MoveMenuItem"));

    // Set this to false here because it is ugly that we don't behave like a menu right after a drop.
    _fEditMode = FALSE;

    // Notify the toplevel menuband of the drop in case it was popped open
    // because of the drag/drop event.  
    //
    // (There are some functionality/activation problems if we keep the
    // menu up after this case.  So to avoid those things at this late date,
    // we're going to cancel the menu after a timeout.)

    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_ITEMDROPPED, 0, NULL, NULL);
        poct->Release();
    }

    _pcmb->_fDragEntered = FALSE;
}


HMENU CMenuSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    *pid += MNIDM_LAST;
    HMENU hmenu = CSFToolbar::_GetContextMenu(pcm, pid);
    HMENU hmenu2 = SHLoadMenuPopup(HINST_THISDLL, MENU_MNFOLDERCONTEXT);
    
    // now find the properties insertion point and 
    int iCount = GetMenuItemCount(hmenu);
    for (int i = 0; i < iCount; i++)
    {
        TCHAR szCommand[40];
        UINT id = GetMenuItemID(hmenu, i);
        if (IsInRange(id, *pid, 0x7fff))
        {
            id -= *pid;
            ContextMenu_GetCommandStringVerb(pcm, id, szCommand, ARRAYSIZE(szCommand));
            if (!lstrcmpi(szCommand, TEXT("properties")))
            {
                break;
            }
        }
    }
    Shell_MergeMenus(hmenu, hmenu2, i, 0, 0x7FFF, 0);
    DestroyMenu(hmenu2);
    return hmenu;
}

void CMenuSFToolbar::_OnDefaultContextCommand(int idCmd)
{
    switch (idCmd) 
    {
    case MNIDM_RESORT:
        {
            // We used to blow away the order stream and refill, but since we use the order stream
            // for calculating the presence of new items, this promoted all of the items were were 
            // sorting.

            HDPA hdpa = _hdpa;

            // if we have a _hdpaOrder it may be out of sync and we just want to resort the
            // ones in _hdpa anyway so ditch the orderlist.
            OrderList_Destroy(&_hdpaOrder);

            _SortDPA(hdpa);
            OrderList_Reorder(hdpa);
            _fChangedOrder = TRUE;

            // This call knows about _hdpa and _hdpaOrder
            _SaveOrderStream();
            // MIKESH: this is needed because otherwise FillToolbar will use the current _hdpa
            // and nothing gets changed...  I think it's because OrderItem_Compare returns failure on some of the pidls
            CMenuToolbarBase::EmptyToolbar();
            _SetDirty(TRUE);
            _LoadOrderStream();
            if (_fShow)
            {
                _FillToolbar();
            }
            break;
        }
    }
}

LRESULT CMenuSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    //
    // When the NoSetTaskbar restriction is set, this code will disallow 
    // Context menus. It querys up to the Start menu to ask for permission
    // to set.
    LRESULT lres = 0;

    //  No UEM on Context Menus. This avoids the problem where we expand the menubands
    // with a context menu present.
    _fSuppressUserMonitor = TRUE;

    // Allow the selected item to blow away the menus. This is explicitly for the Verbs "Open"
    // "Print" and such that launch another process. Inprocess commands are unaffected by this.
    LockSetForegroundWindow(LSFW_UNLOCK);

    BOOL fOwnerIsTopmost = (WS_EX_TOPMOST & GetWindowLong(_pcmb->_pmbState->GetSubclassedHWND(), GWL_EXSTYLE));

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    KillTimer(_hwndMB, MBTIMER_INFOTIP);
    _pcmb->_pmbState->HideTooltip(FALSE);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
        lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

        IUnknown_QueryServiceExec(SAFECAST(_pcmb, IOleCommandTarget*), SID_SMenuBandTop,
            &CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
    }

    // Take the capture back after the context menu
    GetMessageFilter()->RetakeCapture();
    return lres;
}


HRESULT CMenuSFToolbar::_GetInfo(LPCITEMIDLIST pidl, SMINFO* psminfo)
{
    if (psminfo->dwMask & SMIM_TYPE)
    {
        psminfo->dwType = SMIT_STRING;
    }

    if (psminfo->dwMask & SMIM_FLAGS)
    {
        psminfo->dwFlags = SMIF_ICON | SMIF_DROPTARGET;
    }

    if (psminfo->dwMask & SMIM_ICON)
    {
        psminfo->dwMask &= ~SMIM_ICON;
        psminfo->iIcon = -1;
    }

    DWORD dwAttr = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_BROWSABLE;

    // Folders that behave like shortcuts should not be considered 
    // as cascading menu items.  Channels are an example.

    // HACKHACK: to detect channels, we originally planned to GetUIObject
    // IShellLink.  But this doesn't work on browser-only b/c it doesn't
    // pipe down to the shell extension.   So as a hack, we'll key off
    // the absence of SFGAO_FILESYSTEM.

    // Is this a folder?
    // And is it NOT a browseable folder? If it's a Browseable folder, this means that it's a namespace
    // such as the Internet Namespace. The Internet name space's shell folder does not return real items, so it
    // makes it useless in menus. So, filter it out, and treat it like an item.
    HRESULT hr = _psf->GetAttributesOf(1, &pidl, &dwAttr);
    if (SUCCEEDED(hr) && ((dwAttr & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_FOLDER))
    {
        // Since SHIsExpandableFolder is such an expensive call, and we only need
        // it for legacy Channels support, only do this call where channels are:
        // Favorites menu and Start Menu | Favorites.
        if (_dwFlags & SMSET_HASEXPANDABLEFOLDERS)
        {
            // Yes; but does it also behave like a shortcut?
            if (SHIsExpandableFolder(_psf, pidl))
                psminfo->dwFlags |= SMIF_SUBMENU;
        }
        else
        {
            // We're going to assume that if it's a folder, it really is a folder.
            psminfo->dwFlags |= SMIF_SUBMENU;
        }
    }

    CallCB(pidl, SMC_GETSFINFO, 0, (LPARAM)psminfo);

    return hr;
}


/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwStyle is set.

*/
HRESULT CMenuSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwStyle, DWORD* pdwState, DWORD * pdwMIFFlags, int * piIcon)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hr = S_FALSE;
    DWORD dwStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN | TBSTYLE_NOPREFIX;

    *pdwState = TBSTATE_ENABLED;
    *pdwMIFFlags = 0;
    *piIcon = -1;

    if (!IS_INTRESOURCE(pidl))
    {
        SMINFO sminfo;
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;

        if (SUCCEEDED(_GetInfo(pidl, &sminfo)))
        {
            *pdwMIFFlags = sminfo.dwFlags;

            if (sminfo.dwFlags & SMIF_ACCELERATOR)
                dwStyle &= ~TBSTYLE_NOPREFIX;

            if (sminfo.dwType & SMIT_SEPARATOR)
            {
                dwStyle &= ~TBSTYLE_BUTTON;
                dwStyle |= TBSTYLE_SEP;
            }

            if (sminfo.dwFlags & SMIF_ICON)
                *piIcon = sminfo.iIcon;

            if (sminfo.dwFlags & SMIF_DEMOTED &&
                !_pcmb->_fExpanded)
            {
                *pdwState |= TBSTATE_HIDDEN;
                _fHasDemotedItems = TRUE;
            }

            if (sminfo.dwFlags & SMIF_HIDDEN)
                *pdwState |= TBSTATE_HIDDEN;

            hr = S_OK;
        }
    }
    else if (pidl == PIDLSENTINEL(SENTINEL_EMPTY) ||
             pidl == PIDLSENTINEL(SENTINEL_CHEVRON))
    {
        // For null pidls ("empty" menuitems), there is no icon. 
        // SMIF_DROPTTARGET is set so the user can drop into an empty submenu.
        *pdwMIFFlags = SMIF_DROPTARGET;

        // Return S_OK so the pdwMIFFlags is examined.  
        hr = S_OK;
    }
    else if (pidl == PIDLSENTINEL(SENTINEL_SEP))
    {
        dwStyle &= ~TBSTYLE_BUTTON;
        dwStyle |= TBSTYLE_SEP;
        hr = S_OK;
    }

    *pdwStyle = dwStyle;

    return hr;
}


BOOL CMenuSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;
    if (pidl)
    {
        fRet = (S_OK == CallCB(pidl, SMC_FILTERPIDL, 0, 0));
    }
    return fRet;
}

//
//  Note: This must return exactly TRUE or FALSE.
//
BOOL CMenuSFToolbar::_IsAboveNSSeparator(LPCITEMIDLIST pidl)
{
    GUID guidNS;
    return (_dwFlags & SMSET_SEPARATEMERGEFOLDER) &&
           SUCCEEDED(_pasf2->GetNameSpaceID(pidl, &guidNS)) &&
           IsEqualGUID(guidNS, _guidAboveSep);

}

void CMenuSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    _fHasSubMenu = FALSE;

    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    CSFToolbar::_FillDPA(hdpa, hdpaSort, dwEnumFlags);

    //
    //  If we are doing separators, make sure all the "above" items
    //  come before the "below" items.
    //
    //  The items are almost always in the correct order already,
    //  with maybe one or two exceptions, so optimize for that case.
    //
    if (_dwFlags & SMSET_SEPARATEMERGEFOLDER)
    {
        // Invariant:  Items 0..i-1 are _guidAboveSep
        //             Items i..j-1 are not _guidAboveSep
        //             Items j...   are unknown

        int i, j;
        for (i = j = 0; j < DPA_GetPtrCount(hdpa); j++)
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, j);
            if (_IsAboveNSSeparator(poi->pidl))
            {
                if (i != j)
                {
                    DPA_InsertPtr(hdpa, i, DPA_DeletePtr(hdpa, j));
                }
                i++;
            }
        }
        OrderList_Reorder(hdpa); // Recompute item numbers after we shuffled them around
    }
    // End of separator enforcement

    CallCB(NULL, SMC_ENDENUM, 0, 0);
    if (0 == DPA_GetPtrCount(hdpa) && _psf)
    {
        OrderList_Append(hdpa, NULL, 0);     // Add a bogus pidl
        _fEmpty = TRUE;
        _fHasDemotedItems = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;
    }
    else
    {
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;
    }
}

void CMenuSFToolbar::_AddChevron()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Does this menu get a chevron button?
    if (_fHasDemotedItems && !_pcmb->_fExpanded && _idCmdChevron == -1)
    {
        // Yes; (we shouldn't get here if the menu is empty)
        ASSERT(!_fEmpty);   

        int iIndex;
        // Add the chevron to the top or the bottom
        if (_dwFlags & SMSET_TOP && _pcmb->_pmtbTop != _pcmb->_pmtbBottom)
            iIndex = 0;                             // add to top
        else
            iIndex = ToolBar_ButtonCount(_hwndTB);  // append to bottom

        PIBDATA pibd = _AddOrderItemTB(POISENTINEL(SENTINEL_CHEVRON), iIndex, NULL);

        // Remember where the Chevron ended up
        if (pibd)
        {
            _idCmdChevron = GetButtonCmd(_hwndTB, iIndex);
        }
    }
}

void CMenuSFToolbar::_RemoveChevron()
{
    if (-1 != _idCmdChevron)
    {
        // Yes; remove the chevron
        int iPos = ToolBar_CommandToIndex(_hwndTB, _idCmdChevron);
        InlineDeleteButton(iPos);
        _idCmdChevron = -1;
    }
}

//
//  Return the index of the first item that goes below the separator.
//
//  For large directories this can get called a lot so try to keep
//  the running time sublinear.
//
int CMenuSFToolbar::_GetNSSeparatorPlacement()
{
    //
    //  Invariant:
    //
    //      if...                       then DPA_GetPtrCount(i) is...
    //      ------------------------    -----------------------------
    //      i < iLow                    above the separator
    //      iLow <= i < iHigh           unknown
    //      iHigh <= i                  below the separator
    //
    //  where we pretend that item -1 is above the separator and all items
    //  past the end of the DPA are below the separator.
    //

    if (!_hdpa) return -1;      // Weird low-memory condition

    int iLow = 0;
    int iHigh = DPA_GetPtrCount(_hdpa);
    while (iLow < iHigh)
    {
        int iMid = (iLow + iHigh) / 2;
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, iMid);
        if (_IsAboveNSSeparator(poi->pidl))
        {
            iLow = iMid + 1;
        }
        else
        {
            iHigh = iMid;
        }
    }

    return iLow;
}

void CMenuSFToolbar::_AddNSSeparator()
{
    if (_idCmdSep == -1 && (_dwFlags & SMSET_SEPARATEMERGEFOLDER))
    {
        int iPos = _GetNSSeparatorPlacement();
        if (iPos > 0 && iPos < DPA_GetPtrCount(_hdpa))
        {
            PIBDATA pibd = _AddOrderItemTB(POISENTINEL(SENTINEL_SEP), iPos, NULL);
            if (pibd)
            {
                _idCmdSep = GetButtonCmd(_hwndTB, iPos);
            }
        }
    }
}

void CMenuSFToolbar::_RemoveNSSeparator()
{
    if (-1 != _idCmdSep)
    {
        // Yes; remove the Sep
        int iPos = ToolBar_CommandToIndex(_hwndTB, _idCmdSep);
        InlineDeleteButton(iPos);
        _idCmdSep = -1;
    }
}


// Note! This must return exactly TRUE or FALSE.
BOOL CMenuSFToolbar::_IsBelowNSSeparator(int iIndex)
{
    if (_idCmdSep != -1)
    {
        int iPos = ToolBar_CommandToIndex(_hwndTB, _idCmdSep);
        if (iPos >= 0 && iIndex >= iPos)
        {
            return TRUE;
        }
    }
    return FALSE;
}

//
//  Our separator line isn't recorded in the DPA so we need to
//  subtract it out...
//
int CMenuSFToolbar::v_TBIndexToDPAIndex(int iTBIndex)
{
    if (_IsBelowNSSeparator(iTBIndex))
    {
        iTBIndex--;
    }
    return iTBIndex;
}

int CMenuSFToolbar::v_DPAIndexToTBIndex(int iIndex)
{
    if (_IsBelowNSSeparator(iIndex))
    {
        iIndex++;
    }
    return iIndex;
}

void CMenuSFToolbar::_ToolbarChanged()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fForceButtonUpdate = TRUE;
    // We shouldn't change the size of the menubar while we're in the middle
    // of a delete. Wait until we're done...
    if (!_fPreventToolbarChange && _fShow && !_fEmptyingToolbar)
    {
        // Resize the MenuBar
        HWND hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
        if (hwndP && (GetDesktopWindow() != hwndP))
        {
            RECT rcOld = {0};
            RECT rcNew = {0};

            GetClientRect(hwndP, &rcOld);
            _pcmb->ResizeMenuBar();
            GetClientRect(hwndP, &rcNew);

            // If the rect sizes haven't changed, then we need to re-layout the
            // band because the button widths may have changed.
            if (EqualRect(&rcOld, &rcNew))
                NegotiateSize();

            // This pane may have changed sizes. If there is a sub menu, then
            // we need to have them reposition themselves
            if (_pcmb->_fInSubMenu && _pcmb->_pmtbTracked)
            {
                _pcmb->_pmtbTracked->PositionSubmenu(-1);
                IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                    &CGID_MenuBand, MBANDCID_REPOSITION, 0, NULL, NULL);
            }
        }
    }
}

void CMenuSFToolbar::_FillToolbar()
{
    // Don't fill the toolbar if we're not dirty or we're emptying the toolbar
    // If we try and fill the toolbar while we're emptying we enter a race condition
    // where we could AV. This fixes a bug where when dragging a folder into the
    // start menu, and cascade a menu, we empty one toolbar, which causes the
    // other toolbar to get destroyed, unregister itself, flush the change notify
    // queue, causing the original window to empty again... (lamadio) 7.16.98
    if (_fDirty && !_fEmptyingToolbar)
    {
        LPITEMIDLIST pidlItem = NULL;
        IShellMenu* psmSubMenu = NULL;
        // Populating the menu will take a long time since we're hitting
        // the disk.  Give the user some feedback if the cursor is
        // IDC_ARROW.  (If the cursor is something else, then don't
        // mess with it.)  Note that we have to use (HCURSOR)-1 as a
        // sentinel, because it's possible that the current cursor is NULL.

        // Prevent _ToolbarChanged from Doing things. (Perf)
        _fPreventToolbarChange = TRUE;

        _RemoveNSSeparator();
        _RemoveChevron();       // Remove the chevron...

        if (S_OK == CallCB(NULL, SMC_DUMPONUPDATE, 0, 0))
        {
            EmptyToolbar();
        }

        CSFToolbar::_FillToolbar();

        // If we had a Chevron before we refreshed the toolbar, 
        // then we need to add it back.
        _AddChevron();
        _AddNSSeparator();      // See if we need a separator now

        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);

        _fPreventToolbarChange = FALSE;

        _ToolbarChanged();
    }
}

void CMenuSFToolbar::v_OnDeleteButton(void *pData)
{
    CMenuData* pmd = (CMenuData*)pData;
    if (pmd)
        delete pmd;
}

void CMenuSFToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    OrderList_Destroy(&_hdpa);
    _fDirty = TRUE;
    _nNextCommandID = 0;
}


void CMenuSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    // We overload this function because we have some special sentinel pidls

    if (!IS_INTRESOURCE(pidl))
    {
        CSFToolbar::_ObtainPIDLName(pidl, psz, cchMax);
    }
    else if (pidl == PIDLSENTINEL(SENTINEL_EMPTY))
    {
        LoadString(HINST_THISDLL, IDS_EMPTY, psz, cchMax);
    }
    else
    {
        ASSERT(pidl == PIDLSENTINEL(SENTINEL_CHEVRON) ||
               pidl == PIDLSENTINEL(SENTINEL_SEP));
        StrCpyN(psz, TEXT(""), cchMax);
    }
}


void CMenuSFToolbar::v_NewItem(LPCITEMIDLIST pidl)
{
    // This is called when an item is present in the filesystem
    // that is not in the order stream. This occurs when an item is
    // created when the menu is not up.

    // New items are going to have a weird Promotion state
    // if there are multiple clients. Each client is going to be the create, and try to increment this.
    // We have to syncronize access to this. I'm not sure how to do this.
    // Note, this has not been a problem.

    // New items get promoted.
    CallCB(pidl, SMC_NEWITEM, 0, 0);

    // Since this is a new item, we want to increment the promoted items
    // so that we can do chevron tracking.
    _cPromotedItems++;
}

void CMenuSFToolbar::_SetDirty(BOOL fDirty)
{
    if (fDirty)
        _pcmb->_fForceButtonUpdate = TRUE;

    CSFToolbar::_SetDirty(fDirty);
}

void CMenuSFToolbar::_NotifyBulkOperation(BOOL fStart)
{
    if (fStart)
    {
        _RemoveNSSeparator();
        _RemoveChevron();
    }
    else
    {
        _AddChevron();
        _AddNSSeparator();
    }
}

void CMenuSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl, DWORD dwFlags, int nIndex)
{
    DWORD dwEnumFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (!(dwFlags & FSNA_BULKADD))
    {
        // Removing the separator shuffles the indices around, so compensate for it here
        if (_IsBelowNSSeparator(nIndex))
        {
            nIndex--;
        }
        if (_fDropping && _tbim.iButton != -1 && _IsBelowNSSeparator(_tbim.iButton))
        {
            _tbim.iButton--;
        }
        _NotifyBulkOperation(TRUE); // pretend this is a one-item bulk operation
    }

    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    if ((dwFlags & FSNA_ADDDEFAULT) && (_dwFlags & SMSET_SEPARATEMERGEFOLDER) &&
        _IsAboveNSSeparator(pidl))
    {
        dwFlags &= ~FSNA_ADDDEFAULT;
        nIndex = _GetNSSeparatorPlacement(); // inserts above the separator
    }

    CSFToolbar::_OnFSNotifyAdd(pidl, dwFlags, nIndex);
    CallCB(NULL, SMC_ENDENUM, 0, 0);

    // When we add something to this, we want to promote our parent.
    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_PROMOTE);

    if (!(dwFlags & FSNA_BULKADD))
    {
        _NotifyBulkOperation(FALSE); // pretend this is a one-item bulk operation
        _SaveOrderStream();
    }
}

UINT ToolBar_GetVisibleCount(HWND hwnd)
{
    UINT cVis = 0;
    int cItems = ToolBar_ButtonCount(hwnd) - 1;
    for (; cItems >= 0; cItems--)
    {
        TBBUTTONINFO tbinfo;
        tbinfo.cbSize = sizeof(tbinfo);
        tbinfo.dwMask = TBIF_BYINDEX | TBIF_STATE;
        if (ToolBar_GetButtonInfo(hwnd, cItems, &tbinfo))
        {
            if (!(tbinfo.fsState & TBSTATE_HIDDEN))
            {
                cVis ++;
            }
        }
    }

    return cVis;
}

void CMenuSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int i;
    _RemoveNSSeparator();
    _RemoveChevron();
    // Check to see if this item is a promoted guy...
    LPITEMIDLIST pidlButton;
    if (SUCCEEDED(_GetButtonFromPidl(pidl, NULL, &i, &pidlButton)))
    {
        int idCmd = GetButtonCmd(_hwndMB, i);

        // Is he promoted?
        if (!(v_GetFlags(idCmd) & SMIF_DEMOTED))
        {
            // Yes, then we need to decrement the promoted count because
            // we are removing a promoted guy.
            _cPromotedItems--;

            // We should expand if we go to zero
            if (_cPromotedItems == 0)
            {
                // Demote the parent
                IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_DEMOTE | SMINV_NEXTSHOW);
                Expand(TRUE);
            }
        }

        if (_pcmb->_fInSubMenu && _pcmb->_nItemSubMenu == idCmd)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
    }

    CSFToolbar::_OnFSNotifyRemove(pidl);

    //Oooppsss, we removed the only string. Replace with our "(Empty)"
    // handler....
    if (0 == DPA_GetPtrCount(_hdpa) && _psf && _fVerticalMB)
    {
        ASSERT(_fEmpty == FALSE);
        // If we are Empty, then we cannot have any demoted items
        // NOTE: We can have no demoted items and not be empty, so one does
        // not imply the other.
        _fHasDemotedItems = FALSE;
        _AddPidl(NULL, FALSE, 0);
        _fEmpty = TRUE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;
    }

    if (_dwFlags & SMSET_COLLAPSEONEMPTY &&
        ToolBar_GetVisibleCount(_hwndMB) == 0)
    {
        // When we don't want to be shown when empty, collapse.
        _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
    }
    _AddChevron();
    _AddNSSeparator();
}

void CMenuSFToolbar::_OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    if ((_dwFlags & SMSET_SEPARATEMERGEFOLDER) &&
        _IsAboveNSSeparator(pidlFrom) != _IsAboveNSSeparator(pidlTo))
    {
        // This is a rename of something "to itself" but which crosses
        // the separator line.  Don't handle it as an internal rename;
        // just ignore it and let the upcoming updatedir do the real work.
    }
    else
    {
        CSFToolbar::_OnFSNotifyRename(pidlFrom, pidlTo);
    }
}


void CMenuSFToolbar::NegotiateSize()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HWND hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
    if (hwndP && (GetDesktopWindow() != hwndP))
    {
        RECT rc = {0};
        GetClientRect(hwndP, &rc);
        _pcmb->OnPosRectChangeDB(&rc);
    }
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragEnter

       Informs Menuband that a drag has entered it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = TRUE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGENTER, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragLeave

        Informs Menuband that a drag has left it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragLeave(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = FALSE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGLEAVE, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragLeave();
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

         Returns the ID to pass to GetObject.
30
*/
HRESULT CMenuSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR *pdwId, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    TBINSERTMARK tbim;
    DWORD dwFlags = 0;
    BOOL fOnButton = FALSE;

    // If we're in drag and drop, Take UEM out of the picture
    _fSuppressUserMonitor = TRUE;

    // Unlike the CISFBand implementation, we always want to insert 
    // b/t the menu items.  So we return a negative index so the
    // GetObject method will treat all the drops as if we're dropping
    // in b/t the items, even if the cursor is over a menuitem.

    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
            (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
        {
            // Since we've been entered, set the global state as
            // having the drag. If at some point the whole menu
            // heirarchy does not have the drag inside of it, we want to 
            // collapse the menu. This is to prevent the hanging menu syndrome.
            _pcmb->_pmbState->HasDrag(TRUE);
            KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
            GetMessageFilter()->PreventCapture(TRUE);
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        BLOCK
        {
            int iButton = -1;

            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;
            ClientToScreen(_hwndTB, &pt);
            if (WindowFromPoint(pt) == _hwndPager) 
            {
                iButton = IBHT_PAGER;
                tbim.iButton = -1;
                tbim.dwFlags = 0;
            } 
            else 
            {
                // Are we sitting BETWEEN buttons?
                if (ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
                {
                    // Yes.

                    // Is this on the source button?
                    if (!(tbim.dwFlags & TBIMHT_BACKGROUND) && 
                        tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // Yes; don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                }
                // No we're either sitting on a button or the background. Button?
                else if (tbim.iButton != -1 && !(tbim.dwFlags & TBIMHT_BACKGROUND))
                {
                    // On a Button. Cool.
                    iButton = tbim.iButton;
                    fOnButton = TRUE;
                }

                // Can this drop target even accept the drop?
                int idBtn = GetButtonCmd(_hwndTB, tbim.iButton);
                dwFlags = v_GetFlags(idBtn);
                if (_idCmdChevron != idBtn &&
                    !(dwFlags & (SMIF_DROPTARGET | SMIF_DROPCASCADE)) ||
                    ((_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) ||
                    (S_OK == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL))))
                {
                    // No
                    return E_FAIL;
                }
            }
            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // If the dropped occured in this band, then we don't want to collapse the menu
        if (!_fHasDrop)
        {
            // Since we've been left, set the global state. If moving between panes
            // then the pane that will be entered will reset this within the timeout period
            _pcmb->_pmbState->HasDrag(FALSE);
            _SetTimer(MBTIMER_DRAGPOPDOWN);
        }

        // We can take the capture back anytime now
        GetMessageFilter()->PreventCapture(FALSE);

        if (!_fVerticalMB)
        {
            tbim = _tbim;
        }
        else
        {
            // Turn off the insertion mark
            tbim.iButton = -1;
            tbim.dwFlags = 0;
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            UpdateWindow(_hwndTB);
            DAD_ShowDragImage(TRUE);
        }
        break;
    }

    // Did the drop target change?
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        DAD_ShowDragImage(FALSE);
        // Yes

        // If we're sitting on a button, highlight it. Otherwise remove the hightlight.
        //ToolBar_SetHotItem(_hwndTB, fOnButton? tbim.iButton : -1);

        // No.
        // We pop open submenus here during drag and drop.  But only
        // if the button has changed (not the flags).  Otherwise we'd
        // get flashing submenus as the cursor moves w/in a single item.
        if (tbim.iButton != _tbim.iButton)
        {
            _SetTimer(MBTIMER_DRAGOVER);
            BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndTB, FALSE);
            ToolBar_SetHotItem(_hwndTB, -1);
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
            ToolBar_SetAnchorHighlight(_hwndTB, fOldAnchor);
        }

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        // We do not want to display the Insert mark if we do not allow reorder.
        if ((_fFSNotify || _iDragSource >= 0) && (dwFlags & SMIF_DROPTARGET) && _fAllowReorder)
        {
            ToolBar_SetInsertMark(_hwndTB, &tbim);
        }

        if (ppt)
            _tbim = tbim;

        UpdateWindow(_hwndTB);
        DAD_ShowDragImage(TRUE);
    }

    if (!_fVerticalMB && HTDDT_LEAVE == nEvent)
    {
        // Cursor leaving menuband, reset
        _tbim.iButton = -1;
        _iDragSource = -1;
    }

    return S_OK;
}


HRESULT CMenuSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    int nID = (int)dwId;

    *ppvObj = NULL;

    if (nID == IBHT_PAGER)
    {
        SendMessage(_hwndPager, PGM_GETDROPTARGET, 0, (LPARAM)ppvObj);
    }
    // Is the target the source?
    else if (nID >= 0)
    {
        // No; does the shellfolder support IDropTarget?
        PORDERITEM poi = (PORDERITEM)DPA_GetPtr(_hdpa, v_TBIndexToDPAIndex(nID));
        if (poi)
        {
            IShellFolder *psfCVO;
            hr = _GetFolderForCreateViewObject(_IsAboveNSSeparator(poi->pidl), &psfCVO);
            if (SUCCEEDED(hr))
            {
                // We want to pass the subclassed HWND, because all we want the parent of the context menus to be
                // the Subclassed window. This is so we don't loose focus and collapse.
                hr = psfCVO->CreateViewObject(_pcmb->_pmbState->GetWorkerWindow(_hwndMB), riid, ppvObj);
                psfCVO->Release();
            }
        }
    }

    if (*ppvObj)
        hr = S_OK;

    //TraceMsg(TF_BAND, "ISFBand::GetObject(%d) returns %x", dwId, hr);

    return hr;
}

HRESULT CMenuSFToolbar::_GetFolderForCreateViewObject(BOOL fAbove, IShellFolder **ppsf)
{
    HRESULT hr;

    *ppsf = NULL;

    if (!(_dwFlags & SMSET_SEPARATEMERGEFOLDER))
    {
        *ppsf = _psf;
        _psf->AddRef();
        return S_OK;
    }

    //
    //  Is this folder a mix of items above and below the line?
    //
    DWORD dwIndex;
    DWORD dwNSId;
    GUID guid;
    int cAbove = 0;
    int cBelow = 0;
    for (dwIndex = 0; SUCCEEDED(_pasf2->EnumNameSpace(dwIndex, &dwNSId)) &&
                      SUCCEEDED(_pasf2->QueryNameSpace(dwNSId, &guid, NULL));
                      dwIndex++)
    {
        if (IsEqualGUID(guid, _guidAboveSep))
        {
            cAbove++;
        }
        else
        {
            cBelow++;
        }
    }

    if (cAbove == 0 || cBelow == 0)
    {
        // No, it's all above or all below; we can (and indeed must) use it.
        // We must use it because it might be User\Start Menu\Subfolder,
        // but we want it to "realize" that it can accept drops from
        // a common folder and should create All Users\Start Menu\Subfolder
        // as a result.
        *ppsf = _psf;
        _psf->AddRef();
        return S_OK;
    }


    //
    //  Create a subset of the merged shell folder to describe
    //  only the part above or below the line.
    //

    //
    //  Create another instance of whatever shellfolder we have.
    //
    CLSID clsid;
    hr = IUnknown_GetClassID(_psf, &clsid);
    if (FAILED(hr))
    {
        return hr;
    }

    IAugmentedShellFolder *pasfNew;

    hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAugmentedShellFolder, &pasfNew));
    if (SUCCEEDED(hr))
    {

        // See how many namespaces there are...
        hr = _pasf2->EnumNameSpace((DWORD)-1, NULL);
        if (SUCCEEDED(hr))
        {
            // Allocate enough memory to keep track of them...
            DWORD cNamespacesAlloc = HRESULT_CODE(hr);

            // There had better be some namespaces because we don't even get
            // here unless we find one "above" and one "below" namespace.
            ASSERT(cNamespacesAlloc);

            DWORD cNamespaces = 0;
            QUERYNAMESPACEINFO *rgqnsi = new QUERYNAMESPACEINFO[cNamespacesAlloc];
            if (rgqnsi)
            {
                IAugmentedShellFolder3 *pasf3;
                hr = _pasf2->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder3, &pasf3));
                if (SUCCEEDED(hr))
                {
                    // Collect information about them all, keep the ones we like.
                    //
                    // Note that in this loop we do not save the error failure from EnumNameSpace
                    // because we expect it to fail (with NO_MORE_ITEMS) and we don't want
                    // that to cause us to panic and bail out

                    DWORD dwFlagsMissing = ASFF_DEFNAMESPACE_ALL;

                    QUERYNAMESPACEINFO *pqnsi = rgqnsi;
                    for (dwIndex = 0; SUCCEEDED(pasf3->EnumNameSpace(dwIndex, &dwNSId)); dwIndex++)
                    {
                        ASSERT(cNamespaces < cNamespacesAlloc); // if this assert fires, then EnumNameSpace lied to us!

                        pqnsi->cbSize = sizeof(QUERYNAMESPACEINFO);
                        pqnsi->dwMask = ASFQNSI_FLAGS | ASFQNSI_FOLDER | ASFQNSI_GUID | ASFQNSI_PIDL;
                        hr = pasf3->QueryNameSpace2(dwNSId, pqnsi);
                        if (FAILED(hr))
                        {
                            break;              // Fail!
                        }

                        if (BOOLIFY(IsEqualGUID(pqnsi->guidObject, _guidAboveSep)) == fAbove)
                        {
                            dwFlagsMissing &= ~pqnsi->dwFlags;
                            pqnsi++;
                            cNamespaces++;
                        }
                        else
                        {
                            ATOMICRELEASE(pqnsi->psf);
                            ILFree(pqnsi->pidl);
                        }
                    }

                    // Any ASFF_DEFNAMESPACE_* flags that nobody claimed,
                    // give them to the first namespace.
                    if (cNamespaces)
                    {
                        rgqnsi[0].dwFlags |= dwFlagsMissing;
                    }

                    // Add in all the namespaces
                    for (dwIndex = 0; SUCCEEDED(hr) && dwIndex < cNamespaces; dwIndex++)
                    {
                        hr = pasfNew->AddNameSpace(&rgqnsi[dwIndex].guidObject,
                                                   rgqnsi[dwIndex].psf,
                                                   rgqnsi[dwIndex].pidl,
                                                   rgqnsi[dwIndex].dwFlags);
                    }

                    pasf3->Release();
                } // QueryInterface

                //
                //  Now free all the memory we allocated...
                //
                for (dwIndex = 0; dwIndex < cNamespaces; dwIndex++)
                {
                    ATOMICRELEASE(rgqnsi[dwIndex].psf);
                    ILFree(rgqnsi[dwIndex].pidl);
                }
                delete [] rgqnsi;

            }
            else
            {
                hr = E_OUTOFMEMORY; // "new" failed
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppsf = pasfNew;        // transfer ownership to caller
        }
        else
        {
            pasfNew->Release();
        }
    }

    return hr;
}

// S_OK if the drop was handled.  Otherwise S_FALSE.

HRESULT CMenuSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Since the modal drag-drop loop released the capture, take it
    // back so we behave properly.
    KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
    HRESULT hr = S_FALSE;

    // If this drop came from us, but it came from the other side of the
    // separator, then act as if it didn't come from us after all.
    if (_iDragSource >= 0 &&
        (_dwFlags & SMSET_SEPARATEMERGEFOLDER) &&
        _IsBelowNSSeparator(_iDragSource) != _IsBelowNSSeparator(_tbim.iButton))
    {
        _iDragSource = -1; // act as if the object came from somewhere else
    }

    // We need to say that the last drag leave is really the drop.
    _fHasDrop = TRUE;
    _idCmdDragging = -1;
    LockSetForegroundWindow(LSFW_LOCK);

    // Only send an hwnd to the callback if the drop source is external
    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
        (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, (WPARAM)pdtobj,
                           (LPARAM)(_iDragSource < 0 ? GetHWNDForUIObject() : NULL))))
    {
        int iButtonOrig = _tbim.iButton;

        // Removing the separator shuffles the indices around, so compensate for it here
        if (_iDragSource >= 0 && _IsBelowNSSeparator(_iDragSource))
        {
            _iDragSource--;
        }
        if (_tbim.iButton != -1 && _IsBelowNSSeparator(_tbim.iButton))
        {
            _tbim.iButton--;
        }

        _RemoveNSSeparator();
        _RemoveChevron();
        hr = CSFToolbar::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
        _AddChevron();
        _AddNSSeparator();

        _tbim.iButton = iButtonOrig;
    }

    LockSetForegroundWindow(LSFW_UNLOCK);

    return hr;
}

PIBDATA CMenuSFToolbar::_AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb)
{
    PIBDATA pibd = CSFToolbar::_AddOrderItemTB(poi, index, ptbb);
    if (pibd)
    {
        if (pibd->GetFlags() & SMIF_SUBMENU) 
        {
            _fHasSubMenu = TRUE;
        }
    }

    return pibd;
}


BOOL CMenuSFToolbar::_AddPidl(LPITEMIDLIST pidl, DWORD dwFlags, int index)
{
    BOOL bRet;

    // Is this item being added to an empty menu?

    // also, if the pidl is null then that means we're trying to add an "empty"
    // tag.  in that case we don't want to run through the code of preemptively
    // removing the "empty" menu item and then adding it back on failure,
    // so we go right to the else statement.
    if (_fEmpty && pidl)
    {
        // Yes; remove the empty menu item
        InlineDeleteButton(0);
        DPA_DeletePtr(_hdpa, 0);
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;

        bRet = CSFToolbar::_AddPidl(pidl, dwFlags, index);

        // Failed to add new item?
        if (!bRet)
        {
            // Yes; add the empty menu item back
            OrderList_Append(_hdpa, NULL, 0);     // Add a bogus pidl
            _fEmpty = TRUE;
            _fHasDemotedItems = FALSE;
            if (_dwFlags & SMSET_NOEMPTY)
                _fDontShowEmpty = TRUE;
        }
        
    }
    else
        bRet = CSFToolbar::_AddPidl(pidl, dwFlags, index);

    return bRet;
}

BOOL CMenuSFToolbar::_ReBindToFolder(LPCITEMIDLIST pidl)
{

    // We may be able to share this code with the code in _FillToolbar, but the difference is,
    // in Fill Toolbar, the Toolbar Button does not have a Sub Menu. We reinitialize one we save away,
    // and force it back into the child button. Here, we have the luxury of having the Sub Menu still
    // in the toolbar button. I may be able to extract common code into a separate function. Left
    // as an exercise to the reader.

    // Need special Handling for this. We need to free the sub menu and
    // rebind to it ifit's up.
    BOOL fBound = FALSE;
    TBBUTTONINFO tbinfo = {0};
    tbinfo.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    LPITEMIDLIST pidlItem;
    if (SUCCEEDED(_GetButtonFromPidl(ILFindLastID(pidl), &tbinfo, NULL, &pidlItem)))
    {
        CMenuData* pmd = (CMenuData*)tbinfo.lParam;
        if (EVAL(pmd))
        {
            IShellFolderBand* psfb;

            // We have the Toolbar button into, we should see if it has a sub menu associated with it.
            if (SUCCEEDED(pmd->GetSubMenu(&SID_MenuShellFolder, IID_PPV_ARG(IShellFolderBand, &psfb))))
            {
                // It does. Then reuse!
                LPITEMIDLIST pidlFull = NULL;
                IShellFolder* psf = NULL;
                if (_pasf2)
                {
                    LPITEMIDLIST pidlFolder, pidlChild;
                    // Remember: Folder pidls must be unwrapped. 
                    _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlChild, NULL);
                    pidlFull = ILCombine(pidlFolder, pidlChild);
                    ILFree(pidlChild);
                    ILFree(pidlFolder);
                }
                else
                {
                    // Not a wrapped guy, Sweet!
                    pidlFull = ILCombine(_pidl, pidlItem);
                }

                _psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psf));

                if (psf)
                {
                    if (pidlFull)
                    {
                        fBound = SUCCEEDED(psfb->InitializeSFB(psf, pidlFull));
                        if (fBound)
                        {
                            _pcmb->_nItemSubMenu = tbinfo.idCommand;
                        }
                    }

                    psf->Release();
                }
                ILFree(pidlFull);
                psfb->Release();
            }
        }
    }

    return fBound;
}


HRESULT CMenuSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    if (SUCCEEDED(hr))
    {
        switch(lEvent)
        {
        case SHCNE_RENAMEFOLDER:
            if (_IsChildID(pidl2, TRUE))
            {
                _ReBindToFolder(pidl2);
            }
            break;

        case SHCNE_RMDIR:
            if (_IsChildID(pidl1, TRUE))
            {
                _ReBindToFolder(pidl1);
            }
            break;

        case SHCNE_EXTENDED_EVENT:
            {
                SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
                if (_IsChildID(pidl2, TRUE))
                {
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        DWORD dwFlags = SMINV_NOCALLBACK;   // So that we don't doubly increment
                        SMDATA smd = {0};
                        smd.dwMask = SMDM_SHELLFOLDER;
                        smd.pidlFolder = _pidl;
                        smd.pidlItem = ILFindLastID(pidl2);


                        // Syncronize Promotion state.
                        if (pdwidl->dwItem1 == SHCNEE_PROMOTEDITEM)
                        {
                            dwFlags |= SMINV_PROMOTE;
                        }
                        else if (pdwidl->dwItem1 == SHCNEE_DEMOTEDITEM)
                        {
                            dwFlags |= SMINV_DEMOTE;
                        }


                        // Are we actually doing something?
                        if (SMINV_NOCALLBACK != dwFlags)
                        {
                            v_InvalidateItem(&smd, dwFlags);
                        }
                    }
                }
            }
            break;


        default:
            break;
        }
    }

    return hr;
}


// IShellChangeNotify::OnChange

HRESULT CMenuSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_FAIL;

    // If we're in the middle of being destroyed, don't process this.
    if (!_hwndMB)
        return S_OK;

    AddRef();

    _pcmb->_pmbState->PushChangeNotify();

    SMCSHCHANGENOTIFYSTRUCT shns;
    shns.lEvent = lEvent;
    shns.pidl1  = pidl1;
    shns.pidl2  = pidl2;
    CallCB(NULL, SMC_SHCHANGENOTIFY, NULL, (LPARAM)&shns);  // Ignore return value. Notify only.

    // Since we may be removing the selected item, we want the selection to move to the next item
    int iHot = ToolBar_GetHotItem(_hwndMB);

    hr = CSFToolbar::OnChange(lEvent, pidl1, pidl2);

    // Is this a child of this toolbar is some shape or form?
    // 1) The changing pidl is a child of this pane.
    // 2) What the pidl is changing to is in this pane (For renames)
    // 3) Updatedirs. Recursive change notifies must forward update dirs all the way down the chain.
    // 4) EXTENDED events with a pidl2 == NULL. This means Reorder all your items.
    if (_IsChildID(pidl1, FALSE) || 
        _IsChildID(pidl2, FALSE) || 
        lEvent == SHCNE_UPDATEDIR ||
        (lEvent == SHCNE_EXTENDED_EVENT &&
         pidl2 == NULL)) 
    {
        // We need to forward this down then.
        HRESULT hrInner = _pcmb->ForwardChangeNotify(lEvent, pidl1, pidl2);

        // Did either of us handle this change?
        if (SUCCEEDED(hrInner) || SUCCEEDED(hr))
        {
            hr = S_OK;
        }
        else if (lEvent != SHCNE_EXTENDED_EVENT)    // Don't bother with extended events...
        {   
            // Ok so neither of us handled this?
            // Must be the SHChangeNotifyCollapsing code that collapses
            // the Directory Create and item create into a single item create.
            // We need to force an update dir on ourselves so that we get this change.
            hr = CSFToolbar::OnChange(SHCNE_UPDATEDIR, pidl1, pidl2);
        }
    }

    // Set the hot item back, wrapping if necessary.
    if (ToolBar_GetHotItem(_hwndMB) != iHot)
        SetHotItem(1, iHot, -1, 0);

    _pcmb->_pmbState->PopChangeNotify();

    Release();

    return hr;
}

void CMenuSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferredEffect)
{
    // During drag and drop, allow dialogs to collapse menu.
    LockSetForegroundWindow(LSFW_UNLOCK);

    LPCITEMIDLIST pidl = _IDToPidl(iItem, NULL);
    dwPreferredEffect = DROPEFFECT_MOVE;
    CallCB(pidl, SMC_BEGINDRAG, (WPARAM)&dwPreferredEffect, 0);

    CSFToolbar::_OnDragBegin(iItem, dwPreferredEffect);
    if (_fEditMode)
        SetTimer(_hwndTB, MBTIMER_ENDEDIT, MBTIMER_ENDEDITTIME, 0);
}


void CMenuSFToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (fClear)
    {
        // If we're clearing, tell the browser 
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(0, -1), NULL);

    }
    else
    {
        PIBDATA pibdata = _IDToPibData(idCmd);
        LPCITEMIDLIST pidl;
    
        // Only send notifications for non submenu items
        if (EVAL(pibdata) && (pidl = pibdata->GetPidl()))
        {
            CallCB(pidl, SMC_SFSELECTITEM, 0, 0);
            // Don't free Pidl
        }
    }
}    


LRESULT CMenuSFToolbar::_OnGetObject(NMOBJECTNOTIFY* pnmon)
{
    pnmon->hResult = QueryInterface(*pnmon->piid, &pnmon->pObject);
    return 1;
}


LRESULT CMenuSFToolbar::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    LRESULT lres = 0;

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case TBN_DELETINGBUTTON:
        if (_fEmptyingToolbar)
            return 0;
        else
            goto DoDefault;
        break;

    case TBN_GETDISPINFOA:
    case TBN_GETDISPINFOW:
    case NM_CUSTOMDRAW:
        goto DoDefault;
    }

    // Pager notifications MUST be forwarded even when the message hook is disengaged.
    if ((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        goto DoNotify;
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !GetMessageFilter()->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...
        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

DoNotify:
    switch (pnm->code)
    {
    case PGN_SCROLL:
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        if (_pcmb->_fInSubMenu)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

        _fSuppressUserMonitor = TRUE;
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_DRAGOUT:
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            if (!_fEmpty && !_IsSpecialCmd(ptbn->iItem) &&
                !(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
                (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
            {

                // We're now in edit mode
                _fEditMode = TRUE;
                _idCmdDragging = ptbn->iItem;
                _MarkItem(ptbn->iItem);

                lres = 1;       // Allow the drag to occur
                goto DoDefault;
            }
            else
                lres = 0;   // Do not allow the drag out.
        }
        break;
   
    default:
DoDefault:
        lres = CMenuToolbarBase::_OnNotify(pnm);
        if (lres == 0)
        {
            lres = CSFToolbar::_OnNotify(pnm);
        }
        break;
    }

    return lres;
}


HRESULT CMenuSFToolbar::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hr = CSFToolbar::_CreateToolbar(hwndParent);
    if (SUCCEEDED(hr))
    {
        if (_hwndPager)
        {
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_DRAGNDROP, PGS_DRAGNDROP);
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_AUTOSCROLL, PGS_AUTOSCROLL);
            SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_HORZ|PGS_VERT,
               _fVertical ? PGS_VERT : PGS_HORZ);
        }

        _hwndMB = _hwndTB;

        SetWindowTheme(_hwndMB, L"", L"");
        hr = CMenuToolbarBase::CreateToolbar(hwndParent);

        // By "Registering optimized" means that someone else is going to pass the change to us, 
        // we don't need to register for it. This is for the disjoint Fast Items | Programs menu case.
        // We still need top level change notify registration for Favorites, Documents, Printers and Control
        // Panel (Depending on their visibility)
        //

        if (_pcmb->_uId == MNFOLDER_IS_PARENT || 
            (_dwFlags & SMSET_DONTREGISTERCHANGENOTIFY))
            _fRegisterChangeNotify = FALSE;

        // This is a good as spot as any to do this:
        _RegisterToolbar();
    }
    return hr;
}


HKEY CMenuSFToolbar::_GetKey(LPCITEMIDLIST pidl)
{
    HKEY hMenuKey;
    DWORD dwDisp;
    TCHAR szDisplay[MAX_PATH];

    if (!_hKey)
        return NULL;

    _ObtainPIDLName(pidl, szDisplay, ARRAYSIZE(szDisplay));
    // setshellfolder calls need read and write key
    RegCreateKeyEx(_hKey, szDisplay, NULL, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
        NULL, &hMenuKey, &dwDisp);
    TraceMsg(TF_MENUBAND, "%d is setting %s\'s Key to %d", _hKey, szDisplay, hMenuKey);
    return hMenuKey;
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we move idtCmd
// 'down' into CallCB.
HRESULT CMenuSFToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hr = E_FAIL;
    CMenuData* pdata;
    LPITEMIDLIST pidl = NULL;

    psmd->dwMask = SMDM_SHELLFOLDER;

    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndTB, ToolBar_GetHotItem(_hwndTB));

    pdata = (CMenuData*)_IDToPibData(idtCmd);
    if (EVAL(pdata))
    {
        pidl = pdata->GetPidl();
        ASSERT(IS_VALID_PIDL(pidl));
    }

    if (pidl)
    {
        if (_pasf2 && S_OK == _pasf2->UnWrapIDList(pidl, 1, &psmd->psf, &psmd->pidlFolder, &psmd->pidlItem, NULL))
        {
            /*NOTHING*/
            ;
        }
        else
        {
            // Then it must be a straight ShellFolder.
            psmd->psf = _psf;
            if (EVAL(psmd->psf))
                psmd->psf->AddRef();
            psmd->pidlFolder = ILClone(_pidl);
            psmd->pidlItem = ILClone(ILFindLastID(pidl));
        }

        psmd->uIdParent = _pcmb->_uId;
        psmd->punk = SAFECAST(_pcmb, IShellMenu*);
        psmd->punk->AddRef();

        hr = S_OK;
    }

    return hr;
}

HRESULT CMenuSFToolbar::CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hr = S_FALSE;
    BOOL fDestroy = FALSE;

    // todo: call v_GetState (but need idCmd for pidl)
    smd.dwMask = SMDM_SHELLFOLDER;

    if (pidl)
    {
        // We used to unwrap the pidl here in the case of AUGMISF, but why? In the Callback, we only
        // needed the Full pidl for Executing and for Darwin. The unwrap is an expensive call that in
        // the majority case wasn't even used. Put it on the client to unwrap it. Start Menu is the
        // only user of Augmented shell folders anyway....
        smd.psf = _psf;
        smd.pidlFolder = _pidl;
        smd.pidlItem = (LPITEMIDLIST)pidl;
    }
    else
    {
        // Null pidl means tell the callback about me...
        smd.pidlItem = ILClone(ILFindLastID(_pidl));
        smd.pidlFolder = ILClone(_pidl);
        ILRemoveLastID(smd.pidlFolder);
        smd.psf = NULL; // Incase bind fails.
        IEBindToObject(smd.pidlFolder, &smd.psf);
        fDestroy = TRUE;
    }

    smd.uIdParent = _pcmb->_uId;
    smd.uIdAncestor = _pcmb->_uIdAncestor;

    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hr = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    if (fDestroy)
    {
        ATOMICRELEASE(smd.psf);
        ILFree(smd.pidlFolder);
        ILFree(smd.pidlItem);
    }
    
    return hr;
}

HRESULT CMenuSFToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPCITEMIDLIST pidl = NULL;
    CMenuData* pdata = NULL;

    // Optimization: 
    if (uMsg == SMC_CUSTOMDRAW)
    {
        NMCUSTOMDRAW * pnmcd = (NMCUSTOMDRAW *)lParam;
        if (pnmcd ->dwDrawStage & CDDS_ITEM)
        {
            pdata = (CMenuData*)pnmcd ->lItemlParam;
            ASSERT(pdata);
        }
    }
    else
    {
        pdata = (CMenuData*)_IDToPibData(idtCmd); 
        ASSERT(pdata);
    }

    if (pdata)
    {
        ASSERT(pdata->GetPidl() == NULL || IS_VALID_PIDL(pdata->GetPidl()));
        pidl = pdata->GetPidl();
    }

    return CallCB(pidl, uMsg, wParam, lParam);
}

HRESULT CMenuSFToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hr;

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    if (pdata && pdata->GetFlags() & SMIF_SUBMENU)
    {
        hr = pdata->GetSubMenu(pguidService, riid, (void**)ppvObj);
        if (FAILED(hr) && IsEqualGUID(riid, IID_IShellMenu))
        {
            hr = CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);
            if (SUCCEEDED(hr))
            {
                BOOL fCache = TRUE;
                if (S_OK != hr)
                {
                    hr = E_FAIL;
                    IShellMenu* psm = (IShellMenu*) new CMenuBand();
                    if (psm)
                    {
                        IShellFolder* psf = NULL;
                        LPITEMIDLIST pidlItem = pdata->GetPidl();
                        LPITEMIDLIST pidlFolder = _pidl;
                        BOOL fDestroy = FALSE;
                        IShellMenuCallback* psmcb;

                        // Ask the callback if they want to supply a different callback
                        // object for this sub menu. If they do, then use what they 
                        // pass back NOTE: If they pass back S_OK, it's perfectly Ok,
                        // for them to pass back a NULL psmcb. This means, I don't want
                        // my child to have a callback. Use the default.
                        // If they don't handle it, then use their pointer.
                        if (S_FALSE == CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, 
                            (WPARAM)&IID_IShellMenuCallback, (LPARAM)&psmcb))
                        {
                            psmcb = _pcmb->_psmcb;
                            if (psmcb)
                                psmcb->AddRef();
                        }


                        // This has to be before the unwrap because it does name resolution through
                        // the Augmented ISF.
                        HKEY hMenuKey = _GetKey(pidlItem);
                        
                        if (_pasf2)
                        {
                            if (S_OK == _pasf2->UnWrapIDList(pdata->GetPidl(), 1, &psf, &pidlFolder, &pidlItem, NULL))
                            {
                                psf->Release(); // I don't need this
                                psf = NULL;
                                fDestroy = TRUE;
                            }

                            _pasf2->BindToObject(pdata->GetPidl(), NULL, IID_PPV_ARG(IShellFolder, &psf));
                        }

                        // Inherit the flags from the parent...
                        DWORD dwFlags = SMINIT_VERTICAL | 
                            (_pcmb->_dwFlags & (SMINIT_RESTRICT_CONTEXTMENU | 
                                                SMINIT_RESTRICT_DRAGDROP    | 
                                                SMINIT_MULTICOLUMN));

                        LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidlItem);
                        if (psf == NULL)
                        {
                            hr = _psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psf));
                        }

                        LPCITEMIDLIST pidlWrappedItem = pdata->GetPidl();
                        // _psf can be an augmented shell folder. Use the wrapped item....
                        DWORD dwAttrib = SFGAO_LINK | SFGAO_FOLDER;
                        if (SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlWrappedItem, &dwAttrib)) &&
                            (dwAttrib & (SFGAO_LINK | SFGAO_FOLDER)) == (SFGAO_LINK | SFGAO_FOLDER))
                        {
                            // folder shortcuts, We're not going to persist anything
                            RegCloseKey(hMenuKey);
                            hMenuKey = NULL;
                            psmcb = NULL;   // We're not going to pass a callback. NOTE: We don't need to release this
                            dwFlags &= ~SMINIT_MULTICOLUMN; // No multi on FShortcut...
                            fCache = FALSE;
                        }
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        psm->Initialize(psmcb, MNFOLDER_IS_PARENT, uIdAncestor, dwFlags);
                        
                        if (psf)
                        {
                            hr = psm->SetShellFolder(psf, pidlFull, hMenuKey, 
                                   _dwFlags & (SMSET_HASEXPANDABLEFOLDERS | SMSET_USEBKICONEXTRACTION));
                            if (SUCCEEDED(hr))
                            {
                                hr = psm->QueryInterface(riid, ppvObj);
                            }
                            psf->Release();
                        }
                        ILFree(pidlFull);

                        _SetMenuBand(psm);

                        psm->Release();
                        if (psmcb)
                            psmcb->Release();

                        if (fDestroy)
                        {
                            ILFree(pidlFolder);
                            ILFree(pidlItem);
                        }
                    }
                }

                if (*ppvObj)
                {
                    if (fCache)
                    {
                        pdata->SetSubMenu((IUnknown*)*ppvObj);
                    }

                    VARIANT Var;
                    Var.vt = VT_UNKNOWN;
                    Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);

                    // Set the CMenuBandMetrics into the new menuband
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                    // Set the CMenuBandState  into the new menuband
                    Var.vt = VT_INT_PTR;
                    Var.byref = _pcmb->_pmbState;
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


DWORD CMenuSFToolbar::v_GetFlags(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of background erase
    if (pdata)
        return pdata->GetFlags();
    else
        return 0;
}


// This is to tell all other clients that we updated the promotion state of something.
void CMenuSFToolbar::BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted)
{
    LPITEMIDLIST pidlFolder;
    LPITEMIDLIST pidlItemUnwrapped;
    LPITEMIDLIST pidlFull;

    if (_pasf2 && S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
    {

        pidlFull = ILCombine(pidlFolder, pidlItemUnwrapped);
        ILFree(pidlFolder);
        ILFree(pidlItemUnwrapped);
    }
    else
    {

        pidlFull = ILCombine(_pidl, pidlItem);
    }

    SHSendChangeMenuNotify(this,
                           fPromoted ? SHCNEE_PROMOTEDITEM : SHCNEE_DEMOTEDITEM,
                           0, pidlFull);

    ILFree(pidlFull);

}

STDAPI SHInvokeCommandWithFlags(HWND hwnd, IShellFolder* psf, LPCITEMIDLIST pidlItem, DWORD dwFlags, LPCSTR lpVerb)
{
    HRESULT hr = E_FAIL;
    if (psf)
    {
        IContextMenu *pcm;
        if (SUCCEEDED(psf->GetUIObjectOf(hwnd, 1, &pidlItem, IID_X_PPV_ARG(IContextMenu, 0, &pcm))))
        {
            dwFlags |= IsOS(OS_WHISTLERORGREATER) ? CMIC_MASK_FLAG_LOG_USAGE : 0;
            hr = SHInvokeCommandsOnContextMenu(hwnd, NULL, pcm, dwFlags, lpVerb ? &lpVerb : NULL, lpVerb ? 1 : 0);
            pcm->Release();
        }
    }
    return hr;
}

HRESULT CMenuSFToolbar::v_ExecItem(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hr = E_FAIL;
    if (pdata && !_fEmpty && !(_IsSpecialCmd(idCmd)))
    {
        // STRESS: pdata was becomming 0x8 for some reason after the InvokeDefault.
        // I assume that this call was causing a flush, which frees our list of pidls.
        // So, I'm cloning it. I also changed the order, so that we'll just fire the
        // UEM event.

        LPITEMIDLIST pidl = ILClone(pdata->GetPidl());
        if (pidl)
        {
            ASSERT(IS_VALID_PIDL(pidl));

            SMDATA smd;
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = _pidl;
            smd.pidlItem = pidl;
            // SMINV_FORCE here also tells the Start Menu that the invoke
            // came from an Exec
            v_InvalidateItem(&smd, SMINV_PROMOTE | SMINV_FORCE);

            hr = CallCB(pidl, SMC_SFEXEC, 0, 0);

            // Did the Callback handle this execute for us?
            if (hr == S_FALSE) 
            {
                // No, Ok, do it ourselves.
                hr = SHInvokeCommandWithFlags(_hwndTB, _psf, pidl, CMIC_MASK_ASYNCOK, NULL);
            }

            ILFree(pidl);
        }

    }

    return hr;
}

HRESULT CMenuSFToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hr = E_FAIL;

    if (_fEmpty || !pdata)
        return hr;

    // make a copy of the pidl that we're using, since we can get reentered in the sendmessage
    // and free the data from the dpa.
    LPITEMIDLIST pidlCopy = ILClone(pdata->GetPidl());
    // dont worry about failure -- pdata->GetPidl() can be NULL anyway,
    // in which case ILClone will return NULL, and CallCB and GetInfoTip already have NULL checks.

    hr = CallCB(pidlCopy, SMC_GETSFINFOTIP, (WPARAM)psz, (LPARAM)cch);
    
    if (S_FALSE == hr)
    {
        hr = E_FAIL;
        if (GetInfoTip(_psf, pidlCopy, psz, cch))
        {
            hr = S_OK;
        }
    }

    ILFree(pidlCopy);

    return hr;
}


void CMenuSFToolbar::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    HWND    hwndFwd;
    
    // These are in screen coords
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    hwndFwd = _hwndPager ? _hwndPager : _hwndTB;
    GetWindowRect(hwndFwd, &rc);

    if (PtInRect(&rc, pt))
    {
        MapWindowPoints(NULL, hwndFwd, &pt, 1);
        HWND hwnd = ChildWindowFromPoint(hwndFwd, pt);

        if (hwnd) 
        {
            MapWindowPoints(hwndFwd, hwnd, &pt, 1);
        }
        else
        {
            hwnd = hwndFwd;
        }

        SendMessage(hwnd, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}

HRESULT CMenuSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch(uMsg)
    {
    case WM_SYSCOLORCHANGE:
        if (_hwndPager)
            Pager_SetBkColor(_hwndPager, GetSysColor(COLOR_MENU));

        // Change the color, so that we can see it.
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        break;
    }
    HRESULT hr = CMenuToolbarBase::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    if (hr != S_OK)
        hr = CSFToolbar::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return hr;
}


BOOL CMenuSFToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) 
{ 
    if (uIconSize == -1) 
        uIconSize = _uIconSize; 

    _uIconSizeMB = uIconSize;

    return _UpdateIconSize(_uIconSizeMB, fUpdateButtons); 
}

 
HRESULT CMenuSFToolbar::GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{
    HRESULT hr = E_FAIL;
    *ppvObj = NULL;
    if (_psf)
    {
        hr = _psf->QueryInterface(riid, ppvObj);
    }

    if (SUCCEEDED(hr) && ppidl)
    {
        *ppidl = ILClone(_pidl);
        if (! *ppidl)
        {
            (*(IUnknown**)ppvObj)->Release();
            *ppvObj = NULL;
            
            hr = E_FAIL;
        }
    }

    return hr;
}

LRESULT CMenuSFToolbar::_OnTimer(WPARAM wParam)
{
    switch(wParam)
    {
    case MBTIMER_ENDEDIT:
        KillTimer(_hwndTB, wParam);
        _fEditMode = FALSE;
        break;

    case MBTIMER_CLICKUNHANDLE:
        KillTimer(_hwndTB, wParam);
        _fClickHandled = FALSE;
        break;

    default:
        return CMenuToolbarBase::_OnTimer(wParam);
    }
    return 1;
}


LRESULT CMenuSFToolbar::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0 && _fEditMode)
    {
        // Are we in edit mode?
        if (_fEditMode)
        {
            // Yes, mark the item as the item that is subject to moving
            _MarkItem(pnmtb->iItem);
        }
        return TBDDRET_TREATPRESSED;
    }
    
    return CMenuToolbarBase::_OnDropDown(pnmtb);
}


// In the context of a menuband, marking means putting
//         a black rectangle around the item currently being dragged.

void CMenuSFToolbar::_MarkItem(int idCmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Un-highlight the previously moved button
    if (0 <= _pcmb->_nItemMove)
    {
        // Should item move be a member of SFToolbar?
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, FALSE);
        _pcmb->_nItemMove = -1;
    }
    
    if (_fEditMode)    
    {
        _pcmb->_nItemMove = idCmd;
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, TRUE);
    }
}    


STDMETHODIMP CMenuSFToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if (_hwndTB == hwnd || _hwndPager == hwnd || HWND_BROADCAST == hwnd) 
    {
        return S_OK;
    } 
    else 
    {
        return S_FALSE;
    } 
}


void CMenuSFToolbar::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (!_hwndPager)
    {
        CMenuToolbarBase::SetWindowPos(psize, prc, dwFlags);
        return;
    }
    DWORD rectWidth = RECTWIDTH(*prc);

    TraceMsg(TF_MENUBAND, "CMSFTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
        prc->left, prc->top, prc->right, prc->bottom);

    ShowWindow(_hwndPager, SW_SHOW);
    ::SetWindowPos(_hwndPager, NULL, prc->left, prc->top, 
        rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
    if (psize)
    {
        int cx = psize->cx;
        ToolBar_SetButtonWidth(_hwndTB, cx, cx);
    }

    SendMessage(_hwndPager, PGMP_RECALCSIZE, 0L, 0L);
}


void CMenuSFToolbar::SetParent(HWND hwndParent)
{ 
    int nCmdShow = SW_SHOW;
    if (hwndParent)
    {
        if (!_hwndTB)
            CreateToolbar(hwndParent);
        else
        {
            // make sure width is set correctly . . . 
            SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));
        }
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
        nCmdShow = SW_HIDE;
    }


    HWND hwnd = _hwndPager ? _hwndPager: _hwndTB;
    
    if (IsWindow(hwnd)) // JANK : Fix for bug #98253
    {
       if (nCmdShow == SW_HIDE)
       {
           ShowWindow(hwnd, nCmdShow);
       }

       ::SetParent(hwnd, hwndParent); 
       SendMessage(hwnd, TB_SETPARENT, (WPARAM)hwndParent, NULL);

       if (nCmdShow == SW_SHOW)
       {
           ShowWindow(hwnd, nCmdShow);
       }
    }
}

void CMenuSFToolbar::Expand(BOOL fExpand)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TBBUTTON tbb;

    DAD_ShowDragImage(FALSE);

    // Since we're not sure if the Chevron is going to be visible we should remove it here
    // Later we'll add it back in if it's needed.
    _RemoveNSSeparator();
    _RemoveChevron();

    // Loop through and apply the fExpand
    int iNumButtons = ToolBar_ButtonCount(_hwndTB);

    // We reset these when iterating.
    _cPromotedItems = 0;
    _fHasDemotedItems = FALSE;

    int iHotItem = ToolBar_GetHotItem(_hwndMB);

//    SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

    for (int i = 0; i < iNumButtons; i++)
    {
        if (!ToolBar_GetButton(_hwndMB, i, &tbb))
            continue;

        CMenuData* pmd = (CMenuData*)tbb.dwData;

        // Get the toolbar state. Toolbar can set things like
        // TBSTATE_WRAP that we would go nuke.
        DWORD dwState = tbb.fsState;
        DWORD dwFlags = pmd ? pmd->GetFlags() : 0;

        if (dwFlags & SMIF_DEMOTED)
        {
            // Are we expanding?
            if (fExpand)
            {
                //Yes; Enable the button and remove the hidden state
                dwState |= TBSTATE_ENABLED;
                dwState &= ~TBSTATE_HIDDEN;
            }
            else
            {
                //No; Remove the Enabled state and hide the button
                dwState |= TBSTATE_HIDDEN;
                dwState &= ~TBSTATE_ENABLED;
            }

            _fHasDemotedItems = TRUE;
        }
        else if (dwFlags & SMIF_HIDDEN)
        {
            dwState |= TBSTATE_HIDDEN;
            dwState &= ~TBSTATE_ENABLED;
        }
        else if (tbb.idCommand != _idCmdChevron)
        {
            dwState |= TBSTATE_ENABLED;
            dwState &= ~TBSTATE_HIDDEN;
            _cPromotedItems++;
        }

        // If the state has changed, then set it into the toolbar.
        if (dwState != tbb.fsState)
            ToolBar_SetState(_hwndTB, tbb.idCommand, dwState);
    }

    // _fExpand means "Draw as Expanded". We do not want to 
    // draw expanded when we have no demoted items.

    _pcmb->_fExpanded = _fHasDemotedItems? fExpand : FALSE;

    if (fExpand)
    {
        if (_pcmb->_pmbState)
        {
            _pcmb->_pmbState->SetExpand(TRUE);
            _pcmb->_pmbState->HideTooltip(TRUE);
        }
    }
    else
    {
        _AddChevron();
    }

    _AddNSSeparator();

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_SETEXPAND, _fHasDemotedItems?(int)_pcmb->_pmbState->GetExpand():FALSE, NULL, NULL);

//    SendMessage(_hwndMB, WM_SETREDRAW, TRUE, 0);
    _ToolbarChanged();
    ToolBar_SetHotItem(_hwndMB, iHotItem);
    if (_hwndPager)
        UpdateWindow(_hwndPager);
    UpdateWindow(_hwndTB);
    DAD_ShowDragImage(TRUE);
}


void CMenuSFToolbar::GetSize(SIZE* psize)
{
    CMenuToolbarBase::GetSize(psize);

    if (_fEmpty && _fDontShowEmpty)
    {
        psize->cy = 0;
        TraceMsg(TF_MENUBAND, "CMSFT::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}

void CMenuSFToolbar::_RefreshInfo()
{
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (!_IsSpecialCmd(idCmd))
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                SMINFO sminfo;
                sminfo.dwMask = SMIM_FLAGS;
                if (SUCCEEDED(_GetInfo(pmd->GetPidl(), &sminfo)))
                {
                    pmd->SetFlags(sminfo.dwFlags);
                }
            }
        }
    }
}

void CMenuSFToolbar::_FindMinPromotedItems(BOOL fSetOrderStream)
{
    // We need to iterate through the buttons and set the Promoted flag.
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (!_IsSpecialCmd(idCmd))
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                PORDERITEM poi = pmd->GetOrderItem();

                if (fSetOrderStream)
                {
                    DWORD dwFlags = pmd->GetFlags();
                    OrderItem_SetFlags(poi, dwFlags);
                }
                else    // Query the order stream
                {
                    DWORD dwFlags = OrderItem_GetFlags(poi);
                    DWORD dwOldFlags = pmd->GetFlags();

                    // When reading the flags from the registry, we only care about the demote flag.
                    if (dwFlags & SMIF_DEMOTED)
                    {
                        dwOldFlags |= SMIF_DEMOTED;
                    }
                    else if (!(dwOldFlags & SMIF_SUBMENU)) // Don't promote sub menus.
                    {
                        // Force a promote
                        CallCB(pmd->GetPidl(), SMC_PROMOTE, 0, 0);
                        dwOldFlags &= ~SMIF_DEMOTED;
                    }

                    pmd->SetFlags(dwOldFlags);

                }
            }
        }
    }
}

void CMenuSFToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuToolbarBase::v_Show(fShow, fForceUpdate);

    if (fShow)
    {
        BOOL fDirty = _fDirty;
        _fClickHandled = FALSE;
        _RegisterToolbar();

        // this is to flush the whole thing if we got invalidated (like the
        // darwin hack makes us do).  if we don't clear out, then some
        // stale data is left in and _FillToolbar doesn't flush it any more.
        if (fDirty)
        {
            EmptyToolbar();
        }

        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndTB, -1);

        if (_fEmpty && (_dwFlags & SMSET_NOEMPTY))
        {
            _fDontShowEmpty = TRUE;
        }
        else if (_fRefreshInfo && !fDirty)         // Do we need to refresh our information?
        {
            // Yes;
            _RefreshInfo();
        }

        // HACKHACK (lamadio) : There is a sizing issue, where the sizing between the
        // toolbars gets preemted by a resize of the menubar before the size calculation completes.
        // So:
        //  ShowDW  -   Asks each toolbar to calc it's width
        //  CMenuSFToolbar::v_Show - Does a _FillToolbar. Since (in this senario) an item
        //              Has been added, it calls _ToolbarChanged
        //  _ToolbarChanged -   This says to the menubar, I've changed sizes, recalc.
        //  ResizeMenuBar   - In the depths, it eventually calls OnPosRectChanged, which asks each
        //              Toolbar what it's size is. Since the menu portion has not calculated it yet,
        //              It has the old size which is has the old size of the sftoolbar. So everything
        //              Gets reset to that size.
        //

        // We only want to Call expand if we are dirty or the expand state has changed. We
        // call for the Dirty case, because Expand does some neat stuff in calculating the
        // number of promoted items. If the state has changed, we want to reflect that.
        BOOL fExpand = _pcmb->_pmbState ? _pcmb->_pmbState->GetExpand() : FALSE;
        if ((BOOL)_pcmb->_fExpanded != fExpand || fDirty || _fRefreshInfo)
        {
            fForceUpdate = TRUE;
            Expand(fExpand);
        }

        // Only do this in the beginning.
        if (_fFirstTime)
        {
            CallCB(NULL, SMC_GETMINPROMOTED, 0, (LPARAM)&_cMinPromotedItems);

            if (_cPromotedItems < _cMinPromotedItems)
            {
                _FindMinPromotedItems(FALSE);
                Expand(fExpand);
            }
        }

        // Have the menubar think about changing its height
        // we need to do this here because the menubar may have changed it's
        // expand state independant of the pane.
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);
    
        // If we're dirty, have our parent consider promoting itself if there
        // are promoted items in the menu, or demoting itself if there arn't.
        // Don't worry, the parent won't do anything if it's already in that state.
        if (fDirty)
        {
            IUnknown_RefreshParent(_pcmb->_punkSite, _pidl,
            ((_cPromotedItems == 0)? SMINV_DEMOTE : SMINV_PROMOTE) | SMINV_NEXTSHOW);
        }


        // If it is empty, we want to auto expand.
        // We have to do this before the update buttons, so that the size is calculate correctly.
        if (_cPromotedItems == 0 && !_pcmb->_fExpanded)
            Expand(TRUE);

        if (fForceUpdate)
            _UpdateButtons();

        if (_fHasDemotedItems)
        {
            if (S_OK == CallCB(NULL, SMC_DISPLAYCHEVRONTIP, 0, 0))
            {
                _FlashChevron();
            }
        }

        _fFirstTime = FALSE;
        _fRefreshInfo = FALSE;
    }
    else
    {
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    }
    _fShowMB = _fShow = fShow;


    // Reset these so we don't have stale information for the next drag drop cycle. NT #287914 (lamadio) 3.22.99
    _tbim.iButton = -1;
    _tbim.dwFlags = 0;

    _idCmdDragging = -1;

    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}


void CMenuSFToolbar::v_UpdateButtons(BOOL fNegotiateSize) 
{
    CSFToolbar::_UpdateButtons();
    if (_hwndTB && fNegotiateSize && _fVerticalMB)
        NegotiateSize();
}


// this method invalidates a single item in the toolbar
HRESULT CMenuSFToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Default to not not handling this event.
    HRESULT hr = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            _Refresh();
            hr = S_OK;
        }
    }
    else if (psmd->dwMask & SMDM_SHELLFOLDER)
    {
        // Yes;
        int i;
        LPITEMIDLIST pidlButton = NULL;
        SMINFO sminfo;
        sminfo.dwMask = SMIM_FLAGS;

        // Since this pidl is comming from an outside source, 
        // we may need to translate it to a wrapped pidl.

        // Do we have a pidl Translator?
        if (_ptscn)
        {
            // Yes; 
            LPITEMIDLIST pidlTranslated;
            LPITEMIDLIST pidlDummy = NULL;
            LPITEMIDLIST pidlToTranslate = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlToTranslate)
            {
                LONG lEvent = 0, lEvent2;
                LPITEMIDLIST pidlDummy1, pidlDummy2;
                if (SUCCEEDED(_ptscn->TranslateIDs(&lEvent, pidlToTranslate, NULL, &pidlTranslated, &pidlDummy,
                                                   &lEvent2, &pidlDummy1, &pidlDummy2)))
                {
                    // Get the button in the toolbar that corresponds to this pidl.
                    _GetButtonFromPidl(ILFindLastID(pidlTranslated), NULL, &i, &pidlButton);

                    // if pidl does not get translated TranslateIDs returns the same pidl passed
                    // to the function
                    if (pidlTranslated != pidlToTranslate)
                        ILFree(pidlTranslated);
                    // Don't need to delete pidlDummy because it's not set.
                    ASSERT(pidlDummy == NULL);
                    ASSERT(pidlDummy1 == NULL);
                    ASSERT(pidlDummy2 == NULL);
                }

                ILFree(pidlToTranslate);
            }
        }

        // Did we come from a non-augmented shell folder, or
        // did the caller pass a wrapped pidl? 
        if (!pidlButton)
        {
            // Seems like it, we'll try to find the pidl they passed in

            // Get the button in the toolbar that corresponds to this pidl.
            _GetButtonFromPidl(psmd->pidlItem, NULL, &i, &pidlButton);
        }

        // Did we find this pidl in the toolbar?
        if (pidlButton)
        {

            int idCmd = GetButtonCmd(_hwndTB, v_DPAIndexToTBIndex(i));

            // Yes, Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                BOOL fRefresh = FALSE;
                DWORD dwFlagsUp = dwFlags;
                DWORD dwOldItemFlags = pmd->GetFlags();
                DWORD dwNewItemFlags = dwOldItemFlags;
                if ((dwFlags & SMINV_DEMOTE) && 
                    (!(dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_DEMOTE, 0, 0);
                        BroadcastIntelliMenuState(pidlButton, FALSE);
                    }
                    dwNewItemFlags |= SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_DEMOTE;
                }
                else if ((dwFlags & SMINV_PROMOTE) && 
                         ((dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_PROMOTE, dwFlags, 0);
                        BroadcastIntelliMenuState(pidlButton, TRUE);
                    }

                    dwNewItemFlags &= ~SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_PROMOTE;
                }

                // Was it promoted and now Demoted or
                // Was it demoted and now promoted
                if ((dwNewItemFlags & SMIF_DEMOTED) ^
                     (dwOldItemFlags & SMIF_DEMOTED))
                {
                    fRefresh = TRUE;
                    if (dwNewItemFlags & SMIF_DEMOTED)
                    {
                        // Yes; Then decrement the Promoted count
                        _cPromotedItems--;

                        // If we're decementing, then we not have a demoted item.
                        _fHasDemotedItems = TRUE;

                        // Have we dropped off the face of the earth?
                        if (_cPromotedItems == 0)
                        {
                            dwFlagsUp |= SMINV_DEMOTE;
                            Expand(TRUE);
                        }
                        else
                        {
                            fRefresh = FALSE;
                        }
                    }
                    else
                    {
                        int cButtons = ToolBar_ButtonCount(_hwndMB);
                        _cPromotedItems++;
                        if (cButtons == _cPromotedItems)
                        {

                            // if the button count is the number of promoted items,
                            // then we can't have any demoted items
                            // then we need to reset the _fHasDemotedItems flag so that
                            // we don't get a chevron and stuff...

                            _fHasDemotedItems = FALSE;
                        }

                        dwFlagsUp |= SMINV_PROMOTE;
                        fRefresh = TRUE;
                    }

                }

                if (fRefresh || dwFlags & SMINV_FORCE)
                    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, dwFlagsUp);

                if (dwOldItemFlags != dwNewItemFlags || dwFlags & SMINV_FORCE)
                {
                    if (dwFlags & SMINV_NEXTSHOW || !_fShow)
                    {
                        _fRefreshInfo = TRUE;
                    }
                    else
                    {
                        // Since we updated the flags, set them into the cache
                        pmd->SetFlags(dwNewItemFlags);

                        // Based on the new flags, do we enable?
                        DWORD dwState = ToolBar_GetState(_hwndTB, idCmd);
                        dwState |= TBSTATE_ENABLED;
                        if (dwNewItemFlags & SMIF_DEMOTED &&
                            !_pcmb->_fExpanded)
                        {
                            // No; We're not expanded and this is a demoted item
                            dwState |= TBSTATE_HIDDEN;
                            dwState &= ~TBSTATE_ENABLED;
                            _fHasDemotedItems = TRUE;

                            // Just in case the chevron is not there, we should
                            // try and add it. This call will never add more than 1
                            _AddChevron();
                        }
                        else if (!_fHasDemotedItems)
                        {
                            _RemoveChevron();
                        }

                        // Also recalculate the NS separator
                        _RemoveNSSeparator();
                        _AddNSSeparator();


                        // Adjust the state of the button in the toolbar.
                        ToolBar_SetState(_hwndTB, idCmd, dwState);

                        _ToolbarChanged();
                    }
                }
            }
        }

        // We handled this one.
        hr = S_OK;
    }

    return hr;
}


LRESULT CMenuSFToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;
    }

    return CSFToolbar::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}

void CMenuSFToolbar::_SetFontMetrics()
{
    CMenuToolbarBase::_SetFontMetrics();

    if (_hwndPager && _pcmb->_pmbm)
        Pager_SetBkColor(_hwndPager, _pcmb->_pmbm->_clrBackground);
}

int CMenuSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iIcon = -1;


    // If we don't have a pibdata, or we can't get an icon return.
    if (!pibdata || pibdata->GetNoIcon())
        return -1;

    if (_dwFlags & SMSET_USEBKICONEXTRACTION)
    {
        LPITEMIDLIST pidlItem = pibdata->GetPidl();
        // If the caller is using background icon extraction, we need them to provide a
        // default icon that we are going to display until we get the real one. This is 
        // specifically to make favorites fast.
        if (_iDefaultIconIndex == -1)
        {
            TCHAR szIconPath [MAX_PATH];

            if (S_OK == CallCB(NULL, SMC_DEFAULTICON, (WPARAM)szIconPath, (LPARAM)&iIcon))
            {
                _iDefaultIconIndex = Shell_GetCachedImageIndex(szIconPath, iIcon, 0);
            }
        }

        iIcon = _iDefaultIconIndex;

        DWORD dwAttrib = SFGAO_FOLDER;

        if (pidlItem && SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib)))
        {
            if (dwAttrib & SFGAO_FOLDER)
                iIcon = II_FOLDER;
        }

        IShellTaskScheduler* pScheduler = _pcmb->_pmbState->GetScheduler();

        if (pScheduler)
        {
            IShellFolder* psf = NULL;
            LPITEMIDLIST pidlFolder = _pidl;
            LPITEMIDLIST pidlItemUnwrapped;

            // Since this can be an augmented shell folder, we should do the correct thing so that
            // the icon extraction with the full pidl takes place correctly. 
            if (_pasf2 && 
                S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
            {

                pidlItem = ILCombine(pidlFolder, pidlItemUnwrapped);
                ILFree(pidlFolder);
                ILFree(pidlItemUnwrapped);
            }
            else
            {
                psf = _psf;
            }

            // AddIconTask takes ownership of the pidl when psf is NULL and will free it.
            HRESULT hr = AddIconTask(pScheduler, psf, pidlFolder, pidlItem, 
                s_IconCallback, (void *)_hwndTB, iCommandID, NULL);

            pScheduler->Release();

            if (FAILED(hr))
            {
                // If that call failed for some reason, default to the shell32 impl.
                goto DoSyncMap;
            }
        }
        else
            goto DoSyncMap;

    }
    else
    {
DoSyncMap:
        iIcon = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);
    }

    return iIcon;
} 

void CMenuSFToolbar::s_IconCallback(void * pvData, UINT uId, UINT iIconIndex)
{
    HWND hwnd = (HWND)pvData;
    if (hwnd && IsWindow(hwnd))
    {
        DAD_ShowDragImage(FALSE);
        SendMessage(hwnd, TB_CHANGEBITMAP, uId, iIconIndex);
        DAD_ShowDragImage(TRUE);
    }

}

HWND CMenuSFToolbar::GetHWNDForUIObject()   
{ 
    HWND hwnd = _pcmb->_pmbState->GetWorkerWindow(_hwndMB);
    if (hwnd)
        ::SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);
    return hwnd;
}

HWND CMenuSFToolbar::CreateWorkerWindow()
{ 
    return GetHWNDForUIObject();
}

LRESULT CMenuSFToolbar::v_OnCustomDraw(NMCUSTOMDRAW * pnmcd)
{
    LRESULT lRes = CMenuToolbarBase::v_OnCustomDraw(pnmcd);

#ifdef FLATMENU_ICONBAR
    // We may have a background banner in Flat Menu Mode.
    UINT cBits = GetDeviceCaps(pnmcd->hdc, BITSPIXEL);

    if (pnmcd->dwDrawStage == CDDS_PREERASE &&
        _pcmb->_pmbm->_fFlatMenuMode &&                 // Only in flat mode
        _uIconSizeMB != ISFBVIEWMODE_LARGEICONS &&      // And designers didn't like it in the large icon mode
        cBits > 8)                                      // and only if we're in 16 bit color
    {

        RECT rcClient;
        GetClientRect(_hwndMB, &rcClient);
        rcClient.right = GetTBImageListWidth(_hwndMB) + ICONBACKGROUNDFUDGE;

        SHFillRectClr(pnmcd->hdc, &rcClient, _pcmb->_pmbm->_clrMenuGrad);
    }
#endif
    return lRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnfolder.h ===
#ifndef MENUSF
#define MENUSF

#include "mnbase.h"
#include "sftbar.h"

class CMenuData : public IBDATA
{
protected:
    IUnknown* _punkSubmenu;

public:
    CMenuData(PORDERITEM poi) : IBDATA(poi) {};
    virtual ~CMenuData();

    void SetSubMenu(IUnknown* pmb2);
    HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void**);
};

class CMenuBand;

class CMenuSFToolbar :  public CSFToolbar,
                        public CMenuToolbarBase
{
public:

    // *** IUnknown (override) ***
    //   This deliberately forwards AddRef and Release to CMenuToolbarBase, and
    //   forwards QI separately to CSFToolbar.
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // *** CDelegateDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // Other public methods
    virtual HWND v_GetHWND() 
        { return _hwndTB; };

    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu()  { return (BOOL) ( _pcm2 ? 1 : 0 );}; // Win64: should be ok since _pcm2 used as boolean in all contexts
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Close();
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);
    virtual void NegotiateSize();
    virtual void Expand(BOOL fExpand);

    virtual void GetSize(SIZE* size);
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual HRESULT CreateToolbar(HWND hwndParent);

    virtual void    SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    inline virtual BOOL ShowAmpersand()   { return TRUE; }

    // Change HKEY to IStream*
    CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags);

protected:
    ~CMenuSFToolbar();

    // Window Proc Overrides
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferredEffect);
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl, DWORD dwFlags, int nIndex);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    virtual void _NotifyBulkOperation(BOOL fStart);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual LRESULT v_OnCustomDraw(NMCUSTOMDRAW * pnmcd);

    virtual void _FillToolbar();
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual void    _SetToolbarState()
        { CMenuToolbarBase::_SetToolbarState(); };

    virtual void EmptyToolbar()
        { CMenuToolbarBase::EmptyToolbar(); };

    virtual int  v_GetDragOverButton()
        { return _tbim.iButton; };

    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj);
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);

    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh() 
        { _Refresh(); };
    virtual void v_CalcWidth(int* pcxMin, int* pcxMax) 
        { CMenuToolbarBase::v_CalcWidth(pcxMin, pcxMax); };

    // Utility Functions
    virtual BOOL _AddPidl(LPITEMIDLIST pidl, DWORD dwFlags, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, DWORD * pdwStyle, 
        DWORD* pdwState, DWORD * pdwFlags,int* piIcon);

    virtual void _ToolbarChanged();
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual BOOL _FilterPidl(LPCITEMIDLIST pidl);
    virtual void _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual void v_NewItem(LPCITEMIDLIST pidl);
    virtual void _SetDirty(BOOL fDirty);
    virtual void _SetFontMetrics();
    virtual int  _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual HWND GetHWNDForUIObject();
    virtual HWND CreateWorkerWindow();
    virtual int v_TBIndexToDPAIndex(int iTBIndex);
    virtual int v_DPAIndexToTBIndex(int iIndex);

    static  void s_IconCallback(LPVOID pvData, UINT uId, UINT iIconIndex);

    void _AddChevron();
    void _RemoveChevron();
    void _AddNSSeparator();
    void _RemoveNSSeparator();
    void _RefreshInfo();

    BOOL _IsSpecialCmd(int cmd) { return cmd == _idCmdChevron || cmd == _idCmdSep; }
    BOOL _IsAboveNSSeparator(LPCITEMIDLIST pidl);
    BOOL _IsBelowNSSeparator(int iIndex);
    int  _GetNSSeparatorPlacement();
    HRESULT _GetFolderForCreateViewObject(BOOL fAbove, IShellFolder **ppsf);

    void BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted);

    BOOL _ReBindToFolder(LPCITEMIDLIST pidl);
    
    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();

    virtual HRESULT _AfterLoad();
    HRESULT _GetInfo(LPCITEMIDLIST pidl, SMINFO* pmbiinfo);
    HRESULT CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam);
    HKEY _GetKey(LPCITEMIDLIST pidl);
    void _MarkItem(int idCmd);
    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    void _FindMinPromotedItems(BOOL fSetOrderStream);


    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);

    virtual HRESULT v_CreateTrackPopup(int, REFIID, void**) 
        { AssertMsg(0, TEXT("MenuSF trying to get a TrackPopup")); return E_FAIL; };

    virtual PIBDATA _CreateItemData(PORDERITEM poi);

    // Member Variables
    HKEY    _hKey;
    BITBOOL _fPreventToolbarChange: 1;

    IAugmentedShellFolder2* _pasf2;

    int     _iDefaultIconIndex;

    int     _cMinPromotedItems;
    int     _idCmdSep;              // -1 if no artificial separator
    GUID    _guidAboveSep;          // The namespace guid that goes ahead of the separator
};

#define MNFOLDER_NORODER   -5       // Some random negative number to denote there is no order
#define MNFOLDER_IS_PARENT -1       // -1 is passed to the child as uIdParent so that 
                                    // it knows it's not rooted at a static menu
#endif  // MENUSF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\mnstatic.h ===
#ifndef MENUST
#define MENUST

#include "mnbase.h"
#include "cwndproc.h"
#include "droptgt.h"
#include "CommonControls.h"

#define IBHT_PAGER          (-32766)

class CMenuBand;

class CMenuStaticToolbar : public CMenuToolbarBase,
                           public CDelegateDropTarget,
                           public CNotifySubclassWndProc
{
public:

    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** CDelegateDropTarget Methods ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    //*** IWinEventHandler (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods
    virtual void GetSize(SIZE* psize);

    virtual LRESULT v_OnCustomDraw(NMCUSTOMDRAW* pnm);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu();
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT CreateToolbar(HWND hwndParent);

    virtual void v_Close(); // override
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);

    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    inline virtual BOOL ShowAmpersand()   { return FALSE; }

    virtual void SetParent(HWND hwndParent);
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);

    CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags);

protected:
    class CMenuStaticData
    {
    public:
        ~CMenuStaticData();
        void SetSubMenu(IUnknown* punk);
        HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj);
        IUnknown*   _punkSubMenu;
        DWORD       _dwFlags;
    };

    HWND    _hwndMenuOwner;
    HWND    _hwndDD;
    HWND    _hwndPager;
    HMENU   _hmenu;
    UINT    _idCmd;
    int     _iDragOverButton;
    IContextMenu* _pcm;

    BITBOOL _fHasTopSep: 1;
    BITBOOL _fHasBottomSep: 1;
    BITBOOL _fTopSepRemoved: 1;
    BITBOOL _fBottomSepRemoved: 1;
    BITBOOL _fDirty: 1;

    IImageList* _piml;

    LRESULT _OnAccelerator(NMCHAR* pnmChar);
    LRESULT (*_lpfnWndProc)(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMenuStaticData* _IDToData(int idCmd);
    HRESULT CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam);

protected:
    virtual ~CMenuStaticToolbar();

    // Window Proc and message handlers
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);

    virtual int  v_GetDragOverButton()
        { return _iDragOverButton; };

    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh();
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** ppvObj);
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj);
    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    LRESULT _OnHotItemChange(NMTBHOTITEM * pnm);
    void _FillToolbar();
    void _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    void _Insert(int iIndex, MENUITEMINFO* pmii);
    void _CheckSeparators();
    HWND _CreatePager(HWND hwndParent);
};


#endif // MENUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\sftbar.cpp ===
#include "shellprv.h"
#include "common.h"

#include "sftbar.h"
#include "resource.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include <iimgctx.h>
#include "uemapp.h"
#include "util.h"
#include "brutil.h"
#include "dobjutil.h"
#include "idlcomm.h"

extern UINT g_idFSNotify;

#define TF_SFTBAR   TF_MENUBAND

#define PGMP_RECALCSIZE  200

CSFToolbar::CSFToolbar()
{
#ifdef CASCADE_DEBUG
    _fCascadeFolder = TRUE;
#endif
    _dwStyle = TBSTYLE_TOOLTIPS;
    _fDirty = TRUE; // we havn't enumerated, so our state is dirty
    _fRegisterChangeNotify = TRUE;
    _fAllowReorder = TRUE;

    _tbim.iButton = -1;
    _iDragSource = -1;
    _lEvents = SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|
               SHCNE_DELETE|SHCNE_RMDIR|SHCNE_RENAMEITEM|SHCNE_RENAMEFOLDER|
               SHCNE_MEDIAINSERTED|SHCNE_MEDIAREMOVED|SHCNE_NETUNSHARE|SHCNE_NETSHARE|
               SHCNE_UPDATEITEM|SHCNE_UPDATEIMAGE|SHCNE_ASSOCCHANGED|
               SHCNE_UPDATEDIR|SHCNE_EXTENDED_EVENT;
#define SHCNE_PIDL1ISCHILD \
              (SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|\
               SHCNE_DELETE|SHCNE_RMDIR|SHCNE_NETUNSHARE|SHCNE_NETSHARE|\
               SHCNE_UPDATEITEM)

}

CSFToolbar::~CSFToolbar()
{
    ATOMICRELEASE(_pcmSF);
    ATOMICRELEASE(_piml);

    _ReleaseShellFolder();

    ILFree(_pidl);

    OrderList_Destroy(&_hdpa);

    if (_hwndWorkerWindow)
        DestroyWindow(_hwndWorkerWindow);

    OrderList_Destroy(&_hdpaOrder);
}

HRESULT CSFToolbar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSFToolbar, IWinEventHandler),
        QITABENT(CSFToolbar, IShellChangeNotify),
        QITABENT(CSFToolbar, IDropTarget),
        QITABENT(CSFToolbar, IContextMenu),
        QITABENT(CSFToolbar, IShellFolderBand),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;
    // Save the old values
    LPITEMIDLIST pidlSave = _pidl;
    IShellFolder *psfSave = _psf;
    ITranslateShellChangeNotify *ptscnSave = _ptscn;

    _psf = NULL;
    _pidl = NULL;
    _ptscn = NULL;
    
    ASSERT(NULL == psf || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (psf || pidl)
    {
        if (psf)
        {
            _psf = psf;
            _psf->AddRef();

            _psf->QueryInterface(IID_PPV_ARG(ITranslateShellChangeNotify, &_ptscn));
        }
            
        if (pidl)
            _pidl = ILClone(pidl);
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        ILFree(pidlSave);
        if (psfSave)
            psfSave->Release();
        if (ptscnSave)
            ptscnSave->Release();
    }
    else
    {
        ASSERT(_psf == NULL);
        ASSERT(_pidl == NULL);
        ASSERT(_ptscn == NULL);
        // we failed -- restore the old values
        _psf = psfSave;
        _pidl = pidlSave;
        _ptscn = ptscnSave;
    }

    // This code is here for ShellFolderToolbar reuse. When setting a new shell folder
    // into an existing band, we will refresh. Note that this is a noop on a new band.

    _RememberOrder();
    _SetDirty(TRUE);
    if (_fShow)
        _FillToolbar();
    return hr;
}

HWND CSFToolbar::_CreatePager(HWND hwndParent)
{
    if (!_fMulticolumn)
    {
        _hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL,
                                 WS_CHILD | WS_TABSTOP |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (_hwndPager)
        {
            hwndParent = _hwndPager;
        }
    }

    return hwndParent;
}

HRESULT CSFToolbar::_CreateToolbar(HWND hwndParent)
{
    if (!_hwndTB)
    {

        hwndParent = _CreatePager(hwndParent);

        _hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE | _dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (!_hwndTB)
        {
            TraceMsg(TF_ERROR, "_hwndTB failed");
            return HRESULT_FROM_WIN32(GetLastError());
        }
        
        if (_hwndPager)
            SendMessage(_hwndPager, PGM_SETCHILD, 0, (LPARAM)_hwndTB);

        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndTB, DLL_IS_UNICODE);
        if (_hwndPager)
        {
            // Set the format to ANSI or UNICODE as appropriate.
            ToolBar_SetUnicodeFormat(_hwndPager, DLL_IS_UNICODE);
        }
        
        // Make sure we're on the same wavelength.
        SendMessage(_hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DOUBLEBUFFER, TBSTYLE_EX_DOUBLEBUFFER);

        RECT rc;
        SIZE size;

        SystemParametersInfoA(SPI_GETWORKAREA, sizeof(RECT), &rc, FALSE);
        if (!_hwndPager)
        {
            size.cx = RECTWIDTH(rc);
            size.cy = GetSystemMetrics(SM_CYSCREEN) - (2 * GetSystemMetrics(SM_CYEDGE));    // Need to subrtact off the borders
        }
        else
        {
            //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
            size.cx = RECTWIDTH(rc);
            size.cy = 32000;
        }
        ToolBar_SetBoundingSize(_hwndTB, &size);

        if (!_SubclassWindow(_hwndTB))
        {
            _fRegisterChangeNotify = FALSE;
        }
    }
    else
    {
        if (_hwndPager && GetParent(_hwndPager) != hwndParent)
            SetParent(_hwndPager, hwndParent);
    }

    if (FAILED(_GetTopBrowserWindow(&_hwndDD)))
        _hwndDD = GetParent(_hwndTB);

    return S_OK;
}


#define MAX_COMMANDID 0xFFFF // We're allowed one word of command ids (tested at 5)
int  CSFToolbar::_GetCommandID()
{
    int id = -1;

    if (!_fCheckIds)
    {
        id = _nNextCommandID++;
    }
    else
    {
        // We are reusing command ids and must verify that
        // the current one is not in use. This is slow, but
        // I assume the number of buttons on one of these
        // bands is relatively few.
        //
        for (int i = 0 ; i <= MAX_COMMANDID ; i++)
        {
            TBBUTTONINFO tbbiDummy;

            tbbiDummy.cbSize = sizeof(tbbiDummy);
            tbbiDummy.dwMask = 0; // we don't care about data, just existence

            if (-1 != ToolBar_GetButtonInfo(_hwndTB, _nNextCommandID, &tbbiDummy))
            {
                // A button by this id wasn't found, so the id must be free
                //
                id = _nNextCommandID++;
                break;
            }

            _nNextCommandID++;
            _nNextCommandID %= MAX_COMMANDID;
        }
    }

    if (_nNextCommandID > MAX_COMMANDID)
    {
        _nNextCommandID = 0;
        _fCheckIds = TRUE;
    }

    return id;
}

/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwTBStyle is set.

*/
HRESULT CSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, DWORD *pdwTBStyle, DWORD *pdwTBState, DWORD *pdwMIFFlags, int* piIcon)
{
    DWORD dwStyle = TBSTYLE_BUTTON;
    if (!_fAccelerators)
        dwStyle |= TBSTYLE_NOPREFIX;

    *pdwMIFFlags = 0;
    *pdwTBStyle = dwStyle;
    *piIcon = -1;
    *pdwTBState = TBSTATE_ENABLED;

    return S_FALSE;
}


PIBDATA CSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return new IBDATA(poi);
}


//
//  poiOrIndex can be...
//
//  A valid pointer (which will be treated as a PORDERITEM)
//  A MAKEINTRESOURCE value (which will be treated as a sentinel value)
//
PIBDATA CSFToolbar::_AddOrderItemTB(PORDERITEM poiOrIndex, int index, TBBUTTON* ptbb)
{
    TCHAR szName[MAX_PATH];

    LPCITEMIDLIST pidlOI;
    PORDERITEM poi;
    if (IS_INTRESOURCE(poiOrIndex))
    {
        poi = NULL;
        pidlOI = (LPCITEMIDLIST)poiOrIndex;
    }
    else
    {
        poi = poiOrIndex;
        pidlOI = poi->pidl;
    }


    // We need to do this even for NULL because _ObtainPIDLName cooks
    // up the word "(Empty)" as necessary.
    _ObtainPIDLName(pidlOI, szName, SIZECHARS(szName));

    TBBUTTON tbb = {0};
    DWORD dwMIFFlags;
    DWORD dwStyle;
    DWORD dwState;
    int iIcon;
    int iCommandID = _GetCommandID();
    BOOL bNoIcon = FALSE;

    if (!ptbb)
        ptbb = &tbb;

    if (S_OK == _TBStyleForPidl(pidlOI, &dwStyle, &dwState, &dwMIFFlags,&iIcon) &&
        !(dwMIFFlags & SMIF_ICON))
    {
        bNoIcon = TRUE;
    }

    PIBDATA pibdata = _CreateItemData(poi);
    if (pibdata)
    {
        pibdata->SetFlags(dwMIFFlags);
        pibdata->SetNoIcon(bNoIcon);

        if (!bNoIcon && iIcon != -1)
            ptbb->iBitmap = iIcon;
        else
            ptbb->iBitmap = I_IMAGECALLBACK;

        ptbb->idCommand = iCommandID;
        ptbb->fsState = (BYTE)dwState;
        ptbb->fsStyle = (BYTE)dwStyle;
        ptbb->dwData = (DWORD_PTR)pibdata;
        ptbb->iString = (INT_PTR)szName;

        // Disregard variablewidth if we are vertical
        if (_fVariableWidth && !_fVertical)
            ptbb->fsStyle |= TBSTYLE_AUTOSIZE;

        if (ptbb->idCommand != -1)
        {
            if (SendMessage(_hwndTB, TB_INSERTBUTTON, index, (LPARAM)ptbb))
            {
                TraceMsg(TF_BAND, "SFToolbar::_AddPidl %d 0x%x [%s]", ptbb->idCommand, ptbb->dwData, ptbb->iString);                                    
            } 
            else 
            {
                delete pibdata;
                pibdata = NULL;
            }
        }

    }

    return pibdata;
}

void CSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    DisplayNameOf(_psf, pidl, SHGDN_NORMAL, psz, cchMax);
}

int CSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;

    if (_fNoIcons || !pibdata || pibdata->GetNoIcon())
    {
        iBitmap = -1;
    }
    else
    {
        iBitmap = OrderItem_GetSystemImageListIndex(pibdata->GetOrderItem(), _psf, fUseCache);
    }

    return iBitmap;
}

void CSFToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;
    PIBDATA pibdata = (PIBDATA)pdi->lParam;
    if (pdi->dwMask & TBNF_IMAGE) 
    {
        pdi->iImage = _GetBitmap(pdi->idCommand, pibdata, TRUE);
    }
    
    if (pdi->dwMask & TBNF_TEXT)
    {
        if (pdi->pszText)
        {
            if (fUnicode)
            {
                pdi->pszText[0] = TEXT('\0');
            }
            else
            {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;
}


// Adds pidl as a new button, handles ILFree(pidl) for the caller
//
BOOL CSFToolbar::_AddPidl(LPITEMIDLIST pidl, DWORD dwFlags, int index)
{
    if (_hdpa)
    {
        PORDERITEM poi = OrderItem_Create(pidl, index);
        if (poi)
        {
            int iPos = DPA_InsertPtr(_hdpa, index, poi);
            if (-1 != iPos)
            {
                // If we did not load an order, then new items should
                // show up alphabetically in the list, not at the bottom.
                if (!_fHasOrder && !(dwFlags & FSNA_BULKADD))
                {
                    // Sort by name
                    _SortDPA(_hdpa);

                    // Find the index of the order item. We use this index as
                    // the toolbar insert index.
                    index = DPA_GetPtrIndex(_hdpa, poi);
                }

                if (_AddOrderItemTB(poi, index, NULL))
                {
                    return TRUE;
                }
                
                DPA_DeletePtr(_hdpa, iPos);
            }

            OrderItem_Free(poi);

            return FALSE;
        }
    }

    ILFree(pidl);

    return FALSE;
}

BOOL CSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    return FALSE;
}

void CSFToolbar::s_NewItem(void *pvParam, LPCITEMIDLIST pidl)
{
    CSFToolbar* psft = (CSFToolbar*)pvParam;
    psft->v_NewItem(pidl);
}

HRESULT CSFToolbar::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    return IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
}

void CSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    IEnumIDList* penum;
    int cItems = 0;

    if (!_psf)
        return;

    if (S_OK == _GetIEnumIDList(dwEnumFlags, &penum))
    {
        LPITEMIDLIST pidl;
        ULONG ul;

        while (S_OK == penum->Next(1, &pidl, &ul))
        {
            cItems++;
            if (_FilterPidl(pidl) || !OrderList_Append(hdpa, pidl, -1))
            {
                TraceMsg(TF_MENUBAND, "SFToolbar (0x%x)::_FillDPA : Did not Add Pidl (0x%x).", this, pidl);
                ILFree(pidl);
            }
        }

        penum->Release();
    }

    ORDERINFO   oinfo;
    int iInsertIndex = _tbim.iButton + 1;               // This is the button where the cursor sat. 
                                                        // So, We want to insert after that
    if (iInsertIndex >= ToolBar_ButtonCount(_hwndTB))   // But, if it's at the end,
        iInsertIndex = -1;                              // Convert the insert to an append.
                                                        //      - Comments in rhyme by lamadio

    oinfo.psf = _psf;
    (oinfo.psf)->AddRef();
    oinfo.dwSortBy = (_fHasOrder || _fDropping)? ((_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME)): OI_MERGEBYNAME;
    OrderList_Merge(hdpa, hdpaSort, _fDropping ? iInsertIndex : _DefaultInsertIndex(), (LPARAM) &oinfo,
        s_NewItem, (void *)this);
    ATOMICRELEASE(oinfo.psf);
}

// This function re-enumerates the IShellFolder, keeping things ordered correctly.
//
void CSFToolbar::_FillToolbar()
{
    HDPA hdpaSort;
    HDPA hdpa;

    if (!_fDirty || !_psf)
        return;
    
    // If we have an order array, use that, otherwise
    // use the currently viewed items

    // remove the ref for the member variable since we can get reentered
    // this would be better with real refcounting but this'll do

    BOOL fTakeOrderRef = FALSE;
    if (_hdpaOrder)
    {
        hdpaSort = _hdpaOrder; // already sorted by name
        // we set it to null, so we have complete ownership of it.
        // at the end we're going to nuke _hdpaOrder anyway in _RememberOrder.
        _hdpaOrder = NULL;
        fTakeOrderRef = TRUE;
    }
    else
    {
        hdpaSort = _hdpa;
        _SortDPA(hdpaSort);
    }

    hdpa = DPA_Create(hdpaSort ? DPA_GetPtrCount(hdpaSort) : 12);
    if (hdpa)
    {
        _FillDPA(hdpa, hdpaSort, SHCONTF_FOLDERS|SHCONTF_NONFOLDERS);

        HDPA hdpaToRemove = DPA_Create(4);
        if (hdpaToRemove)
        {
            HDPA hdpaToAdd = DPA_Create(4);
            if (hdpaToAdd)
            {
                int i, j;
                BOOL fReleaseAdd = TRUE;

                if (_hdpa)
                {
                    // if there isn't anything in the hdpaSort list (which is all the stuff that's already there),
                    // add a null element.  this is so it'll generate a "remove this null element" later.
                    // otherwise, we might end up with an (Empty) item left over.
                    if (DPA_GetPtrCount(hdpaSort) == 0)
                    {
                        OrderList_Append(hdpaSort, NULL, 0);
                    }

                    ORDERINFO oi = {0};
                    oi.dwSortBy = OI_SORTBYNAME;
                    oi.psf = _psf;
                    _psf->AddRef();

                    DPA_Sort(hdpaSort, OrderItem_Compare, (LPARAM) &oi);
                    DPA_Sort(hdpa, OrderItem_Compare, (LPARAM) &oi);

                    i = 0;
                    j = 0;
                    while ((i < DPA_GetPtrCount(hdpaSort)) && (j < DPA_GetPtrCount(hdpa)))
                    {
                        void *pv1 = DPA_FastGetPtr(hdpaSort, i);
                        void *pv2 = DPA_FastGetPtr(hdpa, j);
                        int nCmp = OrderItem_Compare(pv1, pv2, (LPARAM) &oi);
                        if (nCmp > 0)
                        {
                            DPA_AppendPtr(hdpaToAdd, pv2);
                            j++;
                        }
                        else if (nCmp < 0)
                        {
                            DPA_AppendPtr(hdpaToRemove, pv1);
                            i++;
                        }
                        else
                        {
                            i++;
                            j++;
                        }
                    }

                    while (i < DPA_GetPtrCount(hdpaSort))
                    {
                        DPA_AppendPtr(hdpaToRemove, DPA_FastGetPtr(hdpaSort, i));
                        i++;
                    }
                    while (j < DPA_GetPtrCount(hdpa))
                    {
                        DPA_AppendPtr(hdpaToAdd, DPA_FastGetPtr(hdpa, j));
                        j++;
                    }

                    _psf->Release();
                }
                else
                {
                    DPA_Destroy(hdpaToAdd);
                    hdpaToAdd = hdpa;
                    fReleaseAdd = FALSE;
                    _hdpa = DPA_Create(DPA_GetPtrCount(hdpa));
                }

                SendMessage(_hwndTB, WM_SETREDRAW, FALSE, 0);

                if (_hdpa)
                {
                    _NotifyBulkOperation(TRUE);
                    // add buttons back in
                    for (i = 0; i < DPA_GetPtrCount(hdpaToAdd); i++)
                    {
                        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpaToAdd, i);
                        _OnFSNotifyAdd(poi->pidl, FSNA_BULKADD, poi->nOrder);
                    }

                    // remove buttons that die
                    for (i = 0; i < DPA_GetPtrCount(hdpaToRemove); i++)
                    {
                        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpaToRemove, i);
                        _OnFSNotifyRemove(poi->pidl);
                    }
                    _NotifyBulkOperation(FALSE);
                }

                if (fReleaseAdd)
                {
                    DPA_Destroy(hdpaToAdd);
                }
            }
            DPA_Destroy(hdpaToRemove);
        }

        OrderList_Destroy(&hdpa);
    }

    SendMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);

    if (fTakeOrderRef)
    {
        OrderList_Destroy(&hdpaSort);
    }
    _RememberOrder();

    _UpdateButtons();
    _SetDirty(FALSE);

    if (!SHIsTempDisplayMode())
    {
        _ToolbarChanged();
    }

    TraceMsg(TF_BAND, "SFToolbar::_FillToolbar found %d items", DPA_GetPtrCount(_hdpa));
}

void CSFToolbar::EmptyToolbar()
{
    if (_hwndTB)
    {
        TraceMsg(TF_BAND, "SFToolbar::EmptyToolbar %d items", _hdpa ? DPA_GetPtrCount(_hdpa) : 0);

        while (InlineDeleteButton(0))
        {
            // delete the buttons
        }
    }

    OrderList_Destroy(&_hdpa);

    _fDirty = TRUE;
    
    _nNextCommandID = 0;
}

void CSFToolbar::_SetDirty(BOOL fDirty)
{
    _fDirty = fDirty;
}

UINT CSFToolbar::_IndexToID(int iTBIndex)
{
    TBBUTTON tbb;

    if (SendMessage(_hwndTB, TB_GETBUTTON, iTBIndex, (LPARAM)&tbb))
    {
        return tbb.idCommand;
    }
    return (UINT)-1;
}

// if ptbbi is specified, dwMask must be filled in
//
// if pIndex is specified, it receives the DPA index, not the toolbar index

HRESULT CSFToolbar::_GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    if (!_hdpa)
        return E_FAIL;

    for (int i = DPA_GetPtrCount(_hdpa) - 1 ; i >= 0 ; i--)
    {
        HRESULT hr;
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);

        ASSERT(poi);
        if (pidl == poi->pidl)
        {
            hr = 0;
        }
        else
        {
            hr = (!pidl || !poi->pidl) ? E_FAIL : _psf->CompareIDs(0, pidl, poi->pidl);
        }

        if (ResultFromShort(0) == hr)
        {
            if (pIndex)
                *pIndex = i;

            if (ptbbi)
            {
                int id = _IndexToID(v_DPAIndexToTBIndex(i));

                if (id != -1)
                {
                    ptbbi->cbSize = sizeof(*ptbbi);
                    if (-1 == ToolBar_GetButtonInfo(_hwndTB, id, ptbbi))
                    {
                        ZeroMemory(ptbbi, sizeof(*ptbbi));
                    }
                }
                else
                {
                    ZeroMemory(ptbbi, sizeof(*ptbbi));
                }
            }

            if (ppidlOut)
                *ppidlOut = poi->pidl;
            return S_OK;
        }
    }

    return E_FAIL;
}

// On an add, tack the new button on the end
void CSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl, DWORD dwFlags, int nIndex)
{
    // be paranoid and make sure we don't duplicate an item
    //
    if ((dwFlags & FSNA_BULKADD) || FAILED(_GetButtonFromPidl(pidl, NULL, NULL, NULL)))
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn && pidl && !(dwFlags & FSNA_BULKADD))
        {
            if (FAILED(SHGetRealIDL(_psf, pidl, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = pidl ? ILClone(pidl) : NULL;
        }

        if ((dwFlags & FSNA_BULKADD) || !_FilterPidl(pidlNew))
        {
            int index = (dwFlags & FSNA_ADDDEFAULT) ? _DefaultInsertIndex() : nIndex;

            if (_fDropping)
            {
                if (-1 == _tbim.iButton)
                    index = 0; // if qlinks has no items, _tbim.iButton is -1, but you can't insert there...
                else if (_tbim.dwFlags & TBIMHT_AFTER)
                    index = _tbim.iButton + 1;
                else
                    index = _tbim.iButton;

                // We need to store this as the new order because a drag and drop has occured.
                // We will store this order and use it until the end of time.
                _fHasOrder = TRUE;
                _fChangedOrder = TRUE;
            }

            _AddPidl(pidlNew, dwFlags, index);

            if (!(dwFlags & FSNA_BULKADD))
            {
                OrderList_Reorder(_hdpa);
            }
   
            if (_fDropping)
            {
                _Dropped(index, FALSE);
                _fDropping = FALSE;
            }
            // NOTE: i'm nuking this call to SetDirty as it doesn't seem
            // necessary and we don't have a matching call to _SetDirty(FALSE);
            // mismatch of those calls causes nt5 bug #173868.  [tjgreen 5-15-98]
            //_SetDirty(TRUE);
        }
        else
        {
            ILFree(pidlNew);
        }
    }
}


// This function syncronously removes the button, and deletes it's contents.
// iTBIndex is a toolbar index, not a DPA index.
// This avoids Reentrancy problems, as well as Leaks caused by unhooked toolbars
BOOL_PTR CSFToolbar::InlineDeleteButton(int iTBIndex)
{
    BOOL_PTR fRet = FALSE;
    TBBUTTONINFO tbbi = {0};
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(_hwndTB, iTBIndex, &tbbi) >= 0)
    {
        PIBDATA pibdata = (PIBDATA)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndTB, iTBIndex, &tbbi);

        fRet = SendMessage(_hwndTB, TB_DELETEBUTTON, iTBIndex, 0);

        if (pibdata)
            delete pibdata;
    }

    return fRet;
}

// On a remove, rip out the old button and adjust existing ones
void CSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    int i;
    LPITEMIDLIST pidlButton;
    if (SUCCEEDED(_GetButtonFromPidl(pidl, NULL, &i, &pidlButton)))
    {
        // remove it from the DPA before nuking the button. There is a rentrancy issue here.
        DPA_DeletePtr(_hdpa, i);
        InlineDeleteButton(v_DPAIndexToTBIndex(i));
        ILFree(pidlButton);
        _fChangedOrder = TRUE;
    }
}

// On a rename, just change the text of the old button
//
void CSFToolbar::_OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    TBBUTTONINFO tbbi;
    LPITEMIDLIST pidlButton;
    int i;

    tbbi.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    if (SUCCEEDED(_GetButtonFromPidl(pidlFrom, &tbbi, &i, &pidlButton)))
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn)
        {
            if (FAILED(SHGetRealIDL(_psf, pidlTo, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = ILClone(pidlTo);
        }

        if (pidlNew)
        {
            LPITEMIDLIST pidlFree = pidlNew;
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
            if (EVAL(poi))
            {
                pidlFree = poi->pidl;
                poi->pidl = pidlNew;
            
                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(_psf, pidlNew, SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
                {
                    // _GetButtonFromPidl filled in tbbi.cbSize and tbbi.idCommand
                    //
                    PIBDATA pibdata = (PIBDATA)tbbi.lParam;
                    if (pibdata)
                        pibdata->SetOrderItem(poi);

                    tbbi.dwMask = TBIF_TEXT;
                    tbbi.pszText = szName;
                    EVAL(ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi));
                    // Just so that it's new location gets persisted
                    _fChangedOrder = TRUE;

                    // sync up the orderlist right now so if an updatedir comes in
                    // it won't think the renamed pidl is new
                    _RememberOrder();
                }
            }

            ILFree(pidlFree);
        }
    }
}

// On a complete update remove the old button and add it again
//
void CSFToolbar::_OnFSNotifyUpdate(LPCITEMIDLIST pidl)
{
    TBBUTTONINFO tbbi;

    tbbi.dwMask = TBIF_COMMAND;
    LPITEMIDLIST pidlButton;
    if (SUCCEEDED(_GetButtonFromPidl(pidl, &tbbi, NULL, &pidlButton)))
    {
        TCHAR szName[MAX_PATH];

        if (SUCCEEDED(DisplayNameOf(_psf, pidlButton, SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
        {
            int iBitmap = _GetBitmap(tbbi.idCommand, _IDToPibData(tbbi.idCommand, NULL), FALSE);
            if (iBitmap >= 0)
            {
                tbbi.dwMask = TBIF_IMAGE | TBIF_TEXT;
                tbbi.iImage = iBitmap;
                tbbi.pszText = szName;

                ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi);
            }
        }
    }
}

void CSFToolbar::_Refresh()
{
    if (!_hdpa)
        return;

    _RememberOrder();

    EmptyToolbar();
    if (_fShow)
    {
        _FillToolbar();
    }
}

LRESULT CSFToolbar::_OnTimer(WPARAM wParam)
{
    return 0;
}

LRESULT CSFToolbar::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_INITMENUPOPUP:
    case WM_MENUSELECT:
        if (_pcm2)
            _pcm2->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_MENUCHAR:
        {
            LRESULT lres = 0;
            IContextMenu3* pcm3;
            if (_pcm2 && SUCCEEDED(_pcm2->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3))))
            {
                pcm3->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
                pcm3->Release();
            }
            return lres;
        }
        break;
    
    case WM_TIMER:
        if (_OnTimer(wParam)) 
        {
            return 1;
        }
        break;
    }
    
    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose:
For future use. when renaming a parent of this shell folder
 we should rebind to it and refill us.

S_OK    Indicates successful handling of this notification
S_FALSE Indicates the notification is not a handled situation.
        The caller should handle the notification in this case.
Other   Failure code indicates a problem.  Caller should abort
        operation or handle the notification itself.

*/
HRESULT CSFToolbar::_OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return S_FALSE;
}

HRESULT CSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidlOrg1, LPCITEMIDLIST pidlOrg2)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl1 = (LPITEMIDLIST)pidlOrg1;
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)pidlOrg2;
    LPITEMIDLIST pidl1ToFree = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidl2ToFree = NULL;
    LPITEMIDLIST pidlOut1Event2 = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidlOut2Event2 = NULL;
    LONG lEvent2 = (LONG)-1;

    AddRef();	    // This object could be released during this call

    if (_ptscn)
    {
        hr = _ptscn->TranslateIDs(&lEvent, pidlOrg1, pidlOrg2, &pidl1, &pidl2,
                                    &lEvent2, &pidlOut1Event2, &pidlOut2Event2);
            
	if (SUCCEEDED(hr))
        {
            // if pidl1 doesn't equal pidlOrg1, then pidl1 was allocated and needs to be freed.
            pidl1ToFree = ((pidlOrg1 == pidl1) ? NULL : pidl1);
            pidl2ToFree = ((pidlOrg2 == pidl2) ? NULL : pidl2);

	    ASSERT(NULL == pidl1 || IS_VALID_PIDL(pidl1));
	    ASSERT(NULL == pidl2 || IS_VALID_PIDL(pidl2));
	}
    }

    if (SUCCEEDED(hr))
    {
	hr = OnTranslatedChange(lEvent, pidl1, pidl2);

	// Do we have a second event to process?
	if (SUCCEEDED(hr) && lEvent2 != (LONG)-1)
	{
	    // Yes, then go do it.
	    hr = OnTranslatedChange(lEvent2, pidlOut1Event2, pidlOut2Event2);
	}
	ILFree(pidlOut1Event2);
	ILFree(pidlOut2Event2);
	ILFree(pidl1ToFree);
	ILFree(pidl2ToFree);
    }

    Release();

    return hr;
}

#ifdef DEBUG
void DBPrPidl(LPCSTR szPre, LPCITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];

    szName[0] = '\0';
    if (pidl)
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, SIZECHARS(szName), NULL);

    TraceMsg(TF_WARNING, "%hs%s", szPre, szName);
    return;
}
#endif

HRESULT CSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = S_OK;
    BOOL fSizeChanged = FALSE;

    TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: lEvent=%x", lEvent);

    // If we weren't given a pidl we won't register for
    // SHChangeNotify calls, but our IShellChange interface
    // can still be QI()d so someone could errantly call us.
    //
    // If we change to using QS() for IShellChange interface
    // then we can put this check there...
    //
    if (NULL == _pidl)
    {
        // HACKHACK (scotth): resource-based menus (CMenuISF) don't set _pidl.
        //                    Right now allow SHCNE_UPDATEDIR thru...
        if (SHCNE_UPDATEDIR == lEvent)
            goto HandleUpdateDir;

        TraceMsg(TF_WARNING, "CSFToolbar::OnChange - _pidl is NULL");
        hr = E_FAIL;
        goto CleanUp;
    }

    if (lEvent & SHCNE_PIDL1ISCHILD)
    {
        // We only handle notifications for immediate kids. (except SHCNE_RENAMEFOLDER)
        //
        
        if (!_IsChildID(pidl1, TRUE))
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Not a child. Bailing");
            hr = E_FAIL;
            goto CleanUp;
        }
    }

    // Have we been shown yet?
    if (_hdpa == NULL)
    {
        // No. Well, then punt this. We'll catch it on the first enum.
        hr = E_FAIL;
        goto CleanUp;
    }

    switch (lEvent)
    {
    case SHCNE_EXTENDED_EVENT:
        {
            SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
            if (pdwidl->dwItem1 == SHCNEE_ORDERCHANGED)
            {
                TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Reorder event");

                // Do this first so that we can say "We can handle it". This prevents the 
                // mnfolder code that works around a bug in some installers where they don't
                // send a Create Folder before the create item in that folder. It causes an
                // update dir...
                if (!pidl2 || ILIsEqual(_pidl, pidl2))
                {
                    // if this reorder came from us, blow it off
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        // load new order stream
                        _LoadOrderStream();

                        // rebuild toolbar
                        _SetDirty(TRUE);
                        if (_fShow)
                            _FillToolbar();
                    }
                    hr = S_OK;
                }
            }
        }
        break;

    case SHCNE_DRIVEADD:
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Adding item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyAdd(pidl1, FSNA_ADDDEFAULT, 0);
        _RememberOrder();
        fSizeChanged = TRUE;
        break;

    case SHCNE_DRIVEREMOVED:
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Removing item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyRemove(pidl1);
        _RememberOrder();
        fSizeChanged = TRUE;
        break;

    case SHCNE_RENAMEFOLDER:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder");
        // Break if notif is handled or if this is not for our kid.
        //
        hr = _OnRenameFolder(pidl1, pidl2);
        if (S_OK == hr)
        {
            fSizeChanged = TRUE;
            break;
        }

        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder Falling through to RenameItem");
        // fall through
    case SHCNE_RENAMEITEM:
    {
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameItem");
        BOOL fOurKid1, fOurKid2;
        LPCITEMIDLIST p1 = pidl1;
        LPCITEMIDLIST p2 = pidl2;

        pidl1 = ILFindLastID(pidl1);
        pidl2 = ILFindLastID(pidl2);

        // An item can be renamed out of this folder.
        // Convert that into a remove.
        //

        fOurKid1 = _IsChildID(p1, TRUE);
        fOurKid2 = _IsChildID(p2, TRUE);
        if (fOurKid1 && fOurKid2)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Both are children");
            _OnFSNotifyRename(pidl1, pidl2);
            fSizeChanged = TRUE;
            hr = S_OK;
            break;
        }
        else if (fOurKid1)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Removing pidl 1");
            _OnFSNotifyRemove(pidl1);
            fSizeChanged = TRUE;
            break;
        }
        else if (fOurKid2)
        {
            // An item can be renamed into this folder.
            // Convert that into an add.
            //
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Adding pidl2");
            _OnFSNotifyAdd(pidl2, FSNA_ADDDEFAULT, 0);
            fSizeChanged = TRUE;
            break;
        }
        else 
        {
            // (we get here for guys below us who we don't care about,
            // and also for the fallthru from SHCNE_RENAMEFOLDER)
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Not our children");
            /*NOTHING*/
            hr = E_FAIL;
        }
        break;
    }

    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_NETUNSHARE:
        if (_IsEqualID(pidl1))
            goto HandleUpdateDir;

    case SHCNE_NETSHARE:
    case SHCNE_UPDATEITEM:        
        if (_IsChildID(pidl1, TRUE)) 
        {
            pidl1 = ILFindLastID(pidl1);

            _OnFSNotifyUpdate(pidl1);
            fSizeChanged = TRUE;
        }
        break;

    case SHCNE_UPDATEDIR:
        // in OnChange we picked off update dir notify and we didn't translate ids
        // now we can use ILIsEqual -- translate ids won't translate pidls in case
        // of update dir because it looks for immediate child of its, and fails when
        // it receives its own pidl

        // NOTE: When sftbar is registered recursivly, we only get the pidl of the
        // top pane. It is forwarded down to the children. Since this is now a "Child"
        // of the top pane, we check to see if this pidl is a child of that pidl, hence the
        // ILIsParent(pidl1, _pidl)
        // HACKHACK, HUGE HACK: normaly w/ update dir pidl2 is NULL but in start menu
        // augmergeisf can change some other notify (e.g. rename folder) to update dir
        // in which case pidl2 is not null and we have to see if it is our child to do the
        // update (11/18/98) reljai
        if (_IsEqualID(pidl1) ||                    // Calling UpdateDir on _THIS_ folder
            _IsChildID(pidl1, FALSE) ||             // FEATURE (lamadio) Is this needed?
            _IsChildID(pidl2, FALSE) ||             // A changed to update (see comment)
            _IsParentID(pidl1))                     // Some parent in the chain (because it's recursive)
        {
HandleUpdateDir:
            // NOTE: if a series of UPDATEIMAGE notifies gets
            //       translated to UPDATEDIR and we flicker-perf
            //       _FillToolbar, we may lose image updates
            //       (in which case, _Refresh would fix it)
            //
            _SetDirty(TRUE);
            _FillToolbar();
        }
        break;

    case SHCNE_ASSOCCHANGED:
        IEInvalidateImageList();    // We may need to use different icons.
        _Refresh(); // full refresh for now.
        break;

    case SHCNE_UPDATEIMAGE: // global
        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if (pidl2)
            {
                iImage = SHHandleUpdateImage(pidl2);
                if (iImage == -1)
                {
                    break;
                }
            }
            
            if (iImage == -1 || TBHasImage(_hwndTB, iImage))
            {
                _UpdateIconSize(_uIconSize, TRUE);
                _Refresh();
            }
            fSizeChanged = TRUE;
        }
        else
        {
            _Refresh();
        }
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if (fSizeChanged)
    {
        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        _ToolbarChanged();
    }

CleanUp:
    return hr;
}

BOOL TBHasImage(HWND hwnd, int iImageIndex)
{
    BOOL fRefresh = FALSE;
    for (int i = ToolBar_ButtonCount(hwnd) - 1 ; i >= 0 ; i--)
    {
        TBBUTTON tbb;
        if (SendMessage(hwnd, TB_GETBUTTON, i, (LPARAM)&tbb)) 
        {
            if (tbb.iBitmap == iImageIndex) 
            {
                fRefresh = TRUE;
                break;
            }
        }
    }

    return fRefresh;
}

void CSFToolbar::_SetToolbarState()
{
    SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_LIST, 
                  (_uIconSize != ISFBVIEWMODE_SMALLICONS || _fNoShowText) ? 0 : TBSTYLE_LIST);
}

int CSFToolbar::_DefaultInsertIndex()
{
    return DA_LAST;
}

BOOL CSFToolbar::_IsParentID(LPCITEMIDLIST pidl)
{
    // Is the pidl passed in a parent of one of the IDs in the namespace
    // or the only one i've got?
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(NULL, pidl);
    else
        return ILIsParent(pidl, _pidl, FALSE);
}

BOOL CSFToolbar::_IsEqualID(LPCITEMIDLIST pidl)
{
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(pidl, NULL);
    else
        return ILIsEqual(_pidl, pidl);
}

BOOL CSFToolbar::_IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate)
{
    BOOL fRet = FALSE;
    if (pidlChild)
    {
        if (_ptscn)
            fRet = S_OK == _ptscn->IsChildID(pidlChild, fImmediate);
        else
            fRet = ILIsParent(_pidl, pidlChild, fImmediate);
    }
    return fRet;
}

void CSFToolbar::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));
    // Calculate a decent button width given current state
    HIMAGELIST himl;
    int cxMax = 0;
    int cxMin = 0;

    himl = (HIMAGELIST)SendMessage(_hwndTB, TB_GETIMAGELIST, 0, 0);
    if (himl)
    {
        int cy;
        // Start with the width of the button
        ImageList_GetIconSize(himl, &cxMax, &cy);

        // We want at least a bit of space around the icon
        if (_uIconSize != ISFBVIEWMODE_SMALLICONS)
            cxMax += 20;
        else 
            cxMax += 4 * GetSystemMetrics(SM_CXEDGE);

    }

    // Add in any additional space needed
    // Text takes up a bit more space
    if (!_fNoShowText)
    {
        cxMax += 20;

        // Horizontal text takes up a lot
        // if we're smallicon with text (horizontal button)
        // mode, use the minimized metric to mimic the taskbar
        if (_uIconSize == ISFBVIEWMODE_SMALLICONS)
            cxMax = GetSystemMetrics(SM_CXMINIMIZED);
    }

    *pcxMin = cxMin;
    *pcxMax = cxMax;
}

// Adjust buttons based on current state.
//
void CSFToolbar::_UpdateButtons()
{
    if (_hwndTB)
    {
        // set "list" (text on right) or not (text underneath)
        // NOTE: list mode always displays some text, don't do it if no text
        _SetToolbarState();

        v_CalcWidth(&_cxMin, &_cxMax);

        SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));

        // We just changed the layout
        //
        SendMessage(_hwndTB, TB_AUTOSIZE, 0, 0);
        if (_hwndPager)
        {
            LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0);
            Pager_SetScrollInfo(_hwndPager, 50, 1, HIWORD(lButtonSize));
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        }
    }
}

/*----------------------------------------------------------
Purpose: Helper function that calls IShellFolder::GetUIObjectOf().

Returns: pointer to the requested interface
         NULL if failed
*/
void *CSFToolbar::_GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid)
{
    LPCITEMIDLIST * apidl = &pidl;
    void *pv;
    if (FAILED(_psf->GetUIObjectOf(GetHWNDForUIObject(), 1, apidl, riid, 0, &pv)))
    {
        pv = NULL;
    }

    return pv;
}

INT_PTR CALLBACK CSFToolbar::_RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        ASSERT(lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_NAME);
        HWND hwndEdit = GetDlgItem(hDlg, IDD_NAME);
        SendMessage(hwndEdit, EM_LIMITTEXT, MAX_PATH - 1, 0);

        TCHAR szText[MAX_PATH + 80];
        TCHAR szTemplate[80];
        HWND hwndLabel = GetDlgItem(hDlg, IDD_PROMPT);
        GetWindowText(hwndLabel, szTemplate, ARRAYSIZE(szTemplate));
        StringCchPrintf(szText, ARRAYSIZE(szText), szTemplate, lParam); // ok to truncate
        SetWindowText(hwndLabel, szText);
        SetWindowText(hwndEdit, (LPTSTR)lParam);
        break;
    }

    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_NAME:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
            {
                LPTSTR lpstrName = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
                EnableOKButtonFromID(hDlg, IDD_NAME);
                GetDlgItemText(hDlg, IDD_NAME, lpstrName, MAX_PATH);
            }
            break;
        }

        case IDOK:
        {
            TCHAR  szTmp[MAX_PATH];

            HRESULT hr = StringCchCopy(szTmp, ARRAYSIZE(szTmp), (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER));
            if (SUCCEEDED(hr))
            {
                if (PathCleanupSpec(NULL,szTmp))
                {
                   HWND hwnd;

                   ShellMessageBox(HINST_THISDLL, hDlg,
                                   MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                                   MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES), MB_OK | MB_ICONHAND);
                   hwnd = GetDlgItem(hDlg, IDD_NAME);
                   SetWindowText(hwnd, TEXT("\0"));
                   EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                   SetFocus(hwnd);
                   break;
                }
            }
        }
        // fall through

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


// This window proc is used for a temporary worker window that is used to position dialogs 
// as well as maintain the correct Z-Order
// NOTE: This is used in mnfolder as well.
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        // Make sure activation tracks back to the parent.
    case WM_ACTIVATE:
        {
            if (WA_ACTIVE != LOWORD(wParam))
                goto DefWnd;

            SetActiveWindow(GetParent(hwnd));
            return FALSE;
        }

    case WM_WINDOWPOSCHANGING:
        {
            WINDOWPOS* pwp = (WINDOWPOS*)lParam;
            pwp->flags |= SWP_NOOWNERZORDER;
        }
        break;
    }

DefWnd:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);

}

HWND CSFToolbar::CreateWorkerWindow()
{
    if (!_hwndWorkerWindow)
    {
        _hwndWorkerWindow = SHCreateWorkerWindow(HiddenWndProc, GetHWNDForUIObject(), WS_EX_TOOLWINDOW /*| WS_EX_TOPMOST */, WS_POPUP, 0, _hwndTB);
    }

    return _hwndWorkerWindow;
}

HRESULT CSFToolbar::_OnRename(POINT *ppt, int id)
{
    ASSERT(_psf);
    
    TCHAR szName[MAX_PATH];
    LPITEMIDLIST pidl = ILClone(_IDToPidl(id));
    if (!pidl)
        return E_OUTOFMEMORY;
        
    _ObtainPIDLName(pidl, szName, ARRAYSIZE(szName));

    // create a temp window so that placement of the dialog will be close to the point.
    // do this so that we'll use USER's code to get placement correctly w/ respect to multimon and work area
    _hwndWorkerWindow = CreateWorkerWindow();

    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

    // Now the horrible work of disabling our UI parent window so we can go modal.
    // In an ideal world, we would pass our true parent window and USER will do
    // all the work of modality, but we have to use our worker window thingie
    // to get the dialog positioned correctly with respect to multimon,
    // so we have to find the modal parent and disable him the hard way.
    //
    IUnknown *punkSite;
    IUnknown *punkTLB;

    // Doesn't matter what we SAFECAST "this" to; just pick something to keep the compiler happy
    IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_PPV_ARG(IUnknown, &punkSite));
    IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IUnknown, &punkTLB));

    // Tell OLE to go modal
    HRESULT hrModeless = IUnknown_EnableModless(punkTLB, FALSE);

    // Tell USER to go modal
    HWND hwndDisable;
    IUnknown_GetWindow(punkTLB, &hwndDisable);
    BOOL bPrevEnabled = FALSE;
    while (hwndDisable && (GetWindowLong(hwndDisable, GWL_STYLE) & WS_CHILD))
        hwndDisable = GetParent(hwndDisable);
    if (hwndDisable)
        bPrevEnabled = !EnableWindow(hwndDisable, FALSE);   // return value of EnableWindow needs to be negated.

    while (1) 
    {
        if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_ISFBANDRENAME), _hwndWorkerWindow, _RenameDlgProc, (LPARAM)szName) != IDOK)
            break;

        WCHAR wsz[MAX_PATH];
        SHTCharToUnicode(szName, wsz, ARRAYSIZE(wsz));

        // Must re-assert TOPMOSTness so SetNameOf UI will be visible.
        // (We lose it when the user dismisses the dialog box above.)
        // Curiously, the worker window is owned by the app's window, not the
        // menu, so the worker window ends up fighting with the menu to see who is on top
        SetWindowPos(_hwndWorkerWindow, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOOWNERZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        if (SUCCEEDED(_psf->SetNameOf(_hwndWorkerWindow, pidl, wsz, 0, NULL))) 
        {
            SHChangeNotifyHandleEvents();
            _SaveOrderStream();
            break;
        }
    }

    // (must undo modality in reverse order)

    // Tell USER to return to modeless (as appropriate)
    if (hwndDisable)
        EnableWindow(hwndDisable, bPrevEnabled);

    // Tell OLE to return to modeless (as appropriate)
    if (SUCCEEDED(hrModeless))
        IUnknown_EnableModless(punkTLB, TRUE);

    ATOMICRELEASE(punkTLB);
    ATOMICRELEASE(punkSite);

    ILFree(pidl);

    return S_OK;
}


BOOL CSFToolbar::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);
    
    _uIconSize = uIconSize;

    TraceMsg(TF_BAND, "ISFBand::_UpdateIconSize going %hs", (_uIconSize == ISFBVIEWMODE_LARGEICONS ? "LARGE" : (_uIconSize == ISFBVIEWMODE_SMALLICONS ? "SMALL" : "LOGOS")));

    if (_hwndTB)
    {
        ATOMICRELEASE(_piml);
        
        if (!_fNoIcons)
        {
            int iImageList = (_uIconSize == ISFBVIEWMODE_LARGEICONS) ? SHIL_LARGE : SHIL_SYSSMALL;
            SHGetImageList(iImageList, IID_PPV_ARG(IImageList, &_piml));
        }

        // sending a null himl is significant..  it means no image list
        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)_piml);
                
        if (fUpdateButtons)
            _UpdateButtons();
    }
    
    return fChanged;
}

HMENU CSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        UINT fFlags = CMF_CANRENAME;
        if (0 > GetKeyState(VK_SHIFT))
            fFlags |= CMF_EXTENDEDVERBS;

        pcm->QueryContextMenu(hmenu, 0, *pid, CONTEXTMENU_IDCMD_LAST, fFlags);
    }
    return hmenu;
}

void CSFToolbar::_OnDefaultContextCommand(int idCmd)
{
}

HRESULT CSFToolbar::_GetTopBrowserWindow(HWND* phwnd)
{
    IUnknown * punkSite;

    HRESULT hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_PPV_ARG(IUnknown, &punkSite));
    if (SUCCEEDED(hr))
    {
        hr = SHGetTopBrowserWindow(punkSite, phwnd);
        punkSite->Release();
    }

    return hr;
}

HRESULT CSFToolbar::_OnOpen(int id, BOOL fExplore)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidl = _IDToPidl(id);
    if (pidl)
    {
        IUnknown* punkSite;

        hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_PPV_ARG(IUnknown, &punkSite));
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = SBSP_DEFBROWSER | SBSP_DEFMODE;
            if (fExplore)
                dwFlags |= SBSP_EXPLOREMODE;

            hr = SHNavigateToFavorite(_psf, pidl, punkSite, dwFlags);

            punkSite->Release();
        }
    }

    return hr;
}

HRESULT CSFToolbar::_HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd)
{
    TCHAR szCommandString[40];

    HRESULT hr = ContextMenu_GetCommandStringVerb(pcm, idCmd, szCommandString, ARRAYSIZE(szCommandString));
    if (SUCCEEDED(hr))
    {
        if (lstrcmpi(szCommandString, TEXT("rename")) == 0)
            return _OnRename(ppt, id);
        else if (lstrcmpi(szCommandString, TEXT("open")) == 0)
            return _OnOpen(id, FALSE);
        else if (lstrcmpi(szCommandString, TEXT("explore")) == 0)
            return _OnOpen(id, TRUE);
    }

    return S_FALSE;
}

LRESULT CSFToolbar::_DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude)
{
    LRESULT lres = 0;
    int idCmdFirst = CONTEXTMENU_IDCMD_FIRST;
    HMENU hmContext = _GetContextMenu(pcm, &idCmdFirst);
    if (hmContext)
    {
        int idCmd;

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, FALSE, 0L);

        TPMPARAMS tpm;
        TPMPARAMS * ptpm = NULL;

        if (prcExclude)
        {
            tpm.cbSize = sizeof(tpm);
            tpm.rcExclude = *((LPRECT)prcExclude);
            ptpm = &tpm;
        }
        idCmd = TrackPopupMenuEx(hmContext,
            TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            ppt->x, ppt->y, _hwndTB, ptpm);

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, TRUE, 0L);
        
        if (idCmd)
        {
            // FUSION: When we call out to 3rd party code we want it to use 
            // the process default context. This means that the 3rd party code will get
            // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
            // then the 3rd party code will still get v6. 
            ULONG_PTR cookie = 0;
            ActivateActCtx(NULL, &cookie); 

            if (idCmd < idCmdFirst)
            {
                _OnDefaultContextCommand(idCmd);
            }
            else
            {
                idCmd -= idCmdFirst;

                if (_HandleSpecialCommand(pcm, ppt, id, idCmd) != S_OK)
                {
                    _hwndWorkerWindow = CreateWorkerWindow();

                    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

                    CMINVOKECOMMANDINFO ici = {
                        sizeof(CMINVOKECOMMANDINFO),
                        0,
                        _hwndWorkerWindow,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    pcm->InvokeCommand(&ici);
                }
            }
            if (cookie != 0)
            {
                DeactivateActCtx(0, cookie);
            }
        }

        // if we get this far
        // we need to return handled so that WM_CONTEXTMENU doesn't come through
        lres = 1;
        
        DestroyMenu(hmContext);
    }

    return lres;
}


LRESULT CSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    RECT rc;
    LPRECT prcExclude = NULL;
    POINT pt;
    int i;

    if (lParam != (LPARAM)-1)
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        POINT pt2 = pt;
        MapWindowPoints(HWND_DESKTOP, _hwndTB, &pt2, 1);

        i = ToolBar_HitTest(_hwndTB, &pt2);
    }
    else
    {
        // keyboard context menu.
        i = (int)SendMessage(_hwndTB, TB_GETHOTITEM, 0, 0);
        if (i >= 0)
        {
            SendMessage(_hwndTB, TB_GETITEMRECT, i, (LPARAM)&rc);
            MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
            pt.x = rc.left;
            pt.y = rc.bottom;
            prcExclude = &rc;
        }
    }

    TraceMsg(TF_BAND, "NM_RCLICK %d,%d = %d", pt.x, pt.y, i);

    if (i >= 0)
    {
        UINT id = _IndexToID(i);
        if (-1 != id)
        {
            LPCITEMIDLIST pidl = _IDToPidl(id, NULL);
            if (pidl)
            {
                LPCONTEXTMENU pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
                if (pcm)
                {
                    // grab pcm2 for owner draw support
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2));

                    ToolBar_MarkButton(_hwndTB, id, TRUE);

                    lres = _DoContextMenu(pcm, &pt, id, prcExclude);

                    ToolBar_MarkButton(_hwndTB, id, FALSE);

                    if (lres)
                        _FlushNotifyMessages(_hwndTB);

                    ATOMICRELEASE(_pcm2);
                    pcm->Release();
                }
            }
        }
    }

    return lres;
}


LRESULT CSFToolbar::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    return CDRF_DODEFAULT;
}

void CSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferredEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_SetHotItem(_hwndTB, _iDragSource);

    if (_hwndTB && pidl)
        DragDrop(_hwndTB, _psf, pidl, dwPreferredEffect, NULL);
    
    _iDragSource = -1;
}

LRESULT CSFToolbar::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;

    if (_hwndPager && (lpnmhi->dwFlags & (HICF_ARROWKEYS | HICF_ACCELERATOR)))
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;            
        
        int iSelected = lpnmhi->idNew;        
        iOldPos = (int)SendMessage(_hwndPager, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);
        
        if (rc.top < iOldPos) 
        {
             iNewPos =rc.top;
        }
        
        GetClientRect(_hwndPager, &rcPager);
        heightPager = RECTHEIGHT(rcPager);
        
        if (rc.top >= iOldPos + heightPager)  
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }
        
        if (iNewPos != iOldPos)
            SendMessage(_hwndPager, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }

    return 0;
}

void CSFToolbar::_OnToolTipsCreated(NMTOOLTIPSCREATED* pnm)
{
    _hwndToolTips = pnm->hwndToolTips;
    SHSetWindowBits(_hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX);

    // set the AutoPopTime (the duration of showing the tooltip) to a large value
    SendMessage(_hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);
}

LRESULT CSFToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    //The following statement traps all pager control notification messages.
    if ((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        return SendMessage(_hwndTB, WM_NOTIFY, (WPARAM)0, (LPARAM)pnm);
    }

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
    {
        TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
        _OnDragBegin(ptbn->iItem, 0);
        lres = 1;
        break;
    }
    
    case TBN_HOTITEMCHANGE:
        _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;


    case TBN_GETINFOTIP:
    {
        LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
        UINT uiCmd = pnmTT->iItem;
        DWORD dwFlags = _fNoShowText ? QITIPF_USENAME | QITIPF_LINKNOTARGET : QITIPF_LINKNOTARGET;

        if (!GetInfoTipEx(_psf, dwFlags, _IDToPidl(uiCmd), pnmTT->pszText, pnmTT->cchTextMax))
        {
            TBBUTTONINFO tbbi;
    
            tbbi.cbSize = sizeof(tbbi);
            tbbi.dwMask = TBIF_TEXT;
            tbbi.pszText = pnmTT->pszText;
            tbbi.cchText = pnmTT->cchTextMax;
    
            lres = (-1 != ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi));
        }
        break;
    }

    //WARNING: Right now I am calling the same function for both A and W version if this notification supports 
    // Strings then  it needs to thunk. Right now its only used for image
    case  TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    case  TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;
        
    case NM_TOOLTIPSCREATED:
        _OnToolTipsCreated((NMTOOLTIPSCREATED*)pnm);
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case NM_CUSTOMDRAW:
        return _OnCustomDraw((NMCUSTOMDRAW*)pnm);

    }

    return lres;
}

DWORD CSFToolbar::_GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    if (FAILED(_psf->GetAttributesOf(1, &pidl, &dwAttribs)))
        dwAttribs = 0;

    return dwAttribs;
}

PIBDATA CSFToolbar::_IDToPibData(UINT uiCmd, int * piPos)
{
    PIBDATA pibdata = NULL;

    // Initialize to NULL in case the GetButtonInfo Fails.
    TBBUTTONINFO tbbi = {0};

    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    int iPos = ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi);
    if (iPos >= 0)
        pibdata = (PIBDATA)tbbi.lParam;

    if (piPos)
        *piPos = iPos;

    return pibdata;
}    


LPCITEMIDLIST CSFToolbar::_IDToPidl(UINT uiCmd, int *piPos)
{
    LPCITEMIDLIST pidl;
    PIBDATA pibdata = _IDToPibData(uiCmd, piPos);

    if (pibdata)
        pidl = pibdata->GetPidl();
    else
        pidl = NULL;

    return pidl;
}

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
HRESULT CSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    *plres = 0;
    // We are addref'n here because during the course of the
    // Context menu, the view could be changed which free's the menu.
    // We will release after we're sure the this pointer is no longer needed.
    AddRef();
    
    switch (uMsg)
    {
    case WM_SYSCOLORCHANGE:
        SendMessage(_hwndTB, uMsg, wParam, lParam);
        InvalidateRect(_hwndTB, NULL, TRUE);
        break;

    case WM_PALETTECHANGED:
        InvalidateRect(_hwndTB, NULL, FALSE);
        SendMessage(_hwndTB, uMsg, wParam, lParam);
        break;
        
    case WM_COMMAND:
        *plres = _OnCommand(wParam, lParam);
        break;
        
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_CONTEXTMENU:
        *plres = _OnContextMenu(wParam, lParam);
        break;
    }

    Release();
    return S_OK;
} 


// Map the information loaded (or ctor) into _psf, [_pidl]
//
HRESULT CSFToolbar::_AfterLoad()
{
    HRESULT hr = S_OK;

    // if we have a pidl then we need to get ready
    // for notifications...
    //
    if (_pidl)
    {
        // pidls must be rooted off the desktop
        //
        _fFSNotify = TRUE;

        // shortcut -- just specifying a pidl is good enough
        //
        if (!_psf)
        {
            _fPSFBandDesktop = TRUE;
            hr = IEBindToObject(_pidl, &_psf);
        }
    }

    return hr;
}

// IDropTarget implementation

HRESULT CSFToolbar::GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll)
{
    *phwndLock = _hwndTB;
    *phwndScroll = _hwndTB;
    return S_OK;
}

HRESULT CSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    TBINSERTMARK tbim;

    switch (nEvent)
    {
    case HTDDT_ENTER:
        return S_OK;

    case HTDDT_OVER:
        {
            int iButton = IBHT_BACKGROUND; // assume we hit the background

            // if we're the source, this may be a move operation
            //
            *pdwEffect = (_iDragSource >= 0) ? DROPEFFECT_MOVE : DROPEFFECT_NONE;
            if (!ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
            {
                if (tbim.dwFlags & TBIMHT_BACKGROUND)
                {
                    RECT rc;
                    GetClientRect(_hwndTB, &rc);

                    // are we outside the toolbar window entirely?
                    if (!PtInRect(&rc, *ppt))
                    {
                        // rebar already did the hittesting so we are on the rebar
                        // but not the toolbar => we are in the title part
                        if (!_AllowDropOnTitle())
                        {
                            // yes; don't allow drop here
                            iButton = IBHT_OUTSIDEWINDOW;
                            *pdwEffect = DROPEFFECT_NONE;
                        }

                        // set tbim.iButton to invalid value so we don't draw insert mark
                        tbim.iButton = -1;
                    }
                }
                else
                {
                    // nope, we hit a real button
                    //
                    if (tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                    tbim.iButton = IBHT_BACKGROUND;

                    // we never force a move operation if we're on a real button
                    *pdwEffect = DROPEFFECT_NONE;
                }
            }

            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // Reset
        tbim.iButton = IBHT_BACKGROUND;
        tbim.dwFlags = 0;
        break;

    default:
        return E_INVALIDARG;
    }

    // update ui
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        if (ppt)
            _tbim = tbim;

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        //
        if (_fFSNotify || _iDragSource >= 0)
        {
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            DAD_ShowDragImage(TRUE);
        }
    }

    return S_OK;
}

HRESULT CSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;

    if ((IBHT_SOURCE == dwId) || (IBHT_OUTSIDEWINDOW == dwId))
    {
        // do nothing
    }
    else if (IBHT_BACKGROUND == dwId)
    {
        // nash:41937: not sure how, but _psf can be NULL...
        if (EVAL(_psf))
            hr = _psf->CreateViewObject(_hwndTB, riid, ppvObj);
    }
    else
    {
        LPCITEMIDLIST pidl = _IDToPidl((UINT)dwId, NULL);

        if (pidl)
        {
            *ppvObj = _GetUIObjectOfPidl(pidl, riid);

            if (*ppvObj)
                hr = S_OK;
        }
    }

    //TraceMsg(TF_BAND, "SFToolbar::GetObject(%d) returns %x", dwId, hr);

    return hr;
}

HRESULT CSFToolbar::_SaveOrderStream()
{
    if (_fChangedOrder)
    {
        // Notify everyone that the order changed
        SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, _pidl);
        _fChangedOrder = FALSE;
        return S_OK;
    }
    else
        return S_FALSE;
}

void CSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    _fDropped = TRUE;
    _fChangedOrder = TRUE;

    // Save new order stream
    _SaveOrderStream();

    if (fDroppedOnSource)
        _FlushNotifyMessages(_hwndTB);
}

/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Are we NOT the drag source? 
    if (_iDragSource == -1)
    {
        // No, we're not. Well, then the source may be the chevron menu
        // representing the hidden items in this menu. Let's check
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHPidlFromDataObject2(pdtobj, &pidl)))
        {
            // We've got a pidl, Are we the parent? Do we have a button?
            int iIndex;
            if (ILIsParent(_pidl, pidl, TRUE) &&
                SUCCEEDED(_GetButtonFromPidl(ILFindLastID(pidl), NULL, &iIndex, NULL)))
            {
                // We are the parent! Then let's copy that down and set it
                // as the drag source so that down below we reorder.
                _iDragSource = iIndex;
            }
            ILFree(pidl);
        }
    }

    if (_iDragSource >= 0)
    {
        if (_fAllowReorder)
        {
            TraceMsg(TF_BAND, "SFToolbar::OnDrop reorder %d to %d %s", _iDragSource, _tbim.iButton, _tbim.dwFlags & TBIMHT_AFTER ? "A" : "B");

            int iNewLocation = _tbim.iButton;
            if (_tbim.dwFlags & TBIMHT_AFTER)
                iNewLocation++;

            if (iNewLocation > _iDragSource)
                iNewLocation--;

            if (ToolBar_MoveButton(_hwndTB, _iDragSource, iNewLocation))
            {
                PORDERITEM poi = (PORDERITEM)DPA_DeletePtr(_hdpa, v_TBIndexToDPAIndex(_iDragSource));
                if (poi)
                {
                    DPA_InsertPtr(_hdpa, v_TBIndexToDPAIndex(iNewLocation), poi);

                    OrderList_Reorder(_hdpa);

                    // If we're dropping again, then we don't need the _hdpaOrder...
                    OrderList_Destroy(&_hdpaOrder);

                    // A reorder has occurred. We need to use the order stream as the order...
                    _fHasOrder = TRUE;
                    _fDropping = TRUE;
                    _Dropped(iNewLocation, TRUE);     
                    _fDropping = FALSE;
                    _RememberOrder();
                    _SetDirty(TRUE);
                }
            }
        }

        // Don't forget to reset this!
        _iDragSource = -1;

        DragLeave();
    }
    else
    {
        // We want to override the default to be LINK (SHIFT+CONTROL)
        if (0 == DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, 0))
        {
            if (!(*pgrfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT)))
            {
                // NOTE: not all data objects will allow us to call SetData()
                DataObj_SetDWORD(pdtobj, g_cfPreferredDropEffect, DROPEFFECT_LINK);
            }
        }

        _fDropping = TRUE;
        return S_OK;
    }

    return S_FALSE;
}

void CSFToolbar::_SortDPA(HDPA hdpa)
{
    // If we don't have a _psf, then we certainly can't sort it
    // If we don't have a hdpa, then we certainly can't sort it
    // If the hdpa is empty, then there's no point in sorting it
    if (_psf && hdpa && DPA_GetPtrCount(hdpa))
    {
        ORDERINFO oinfo;
        oinfo.psf = _psf;
        oinfo.psf->AddRef();
        oinfo.dwSortBy = (_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME);
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);
        oinfo.psf->Release();
    }
}

void CSFToolbar::_RememberOrder()
{
    OrderList_Destroy(&_hdpaOrder);

    if (_hdpa)
    {
        _hdpaOrder = OrderList_Clone(_hdpa);
        _SortDPA(_hdpaOrder);
    }
}

HMENU CSFToolbar::_GetBaseContextMenu()
{
    HMENU hmenu = SHLoadMenuPopup(HINST_THISDLL, MENU_ISFBAND);
    // no logo view, remove the menu item...
    HMENU hView = GetSubMenu(hmenu, 0);
    DeleteMenu(hView, ISFBIDM_LOGOS, MF_BYCOMMAND);
    return hmenu;
}

HMENU CSFToolbar::_GetContextMenu()
{
    HMENU hmenuSrc = _GetBaseContextMenu();
    if (hmenuSrc)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        mii.fState = MF_CHECKED;

        UINT uCmdId = ISFBIDM_LOGOS;
        if (_uIconSize != ISFBVIEWMODE_LOGOS)
            uCmdId = (_uIconSize == ISFBVIEWMODE_LARGEICONS ? ISFBIDM_LARGE : ISFBIDM_SMALL);
            
        SetMenuItemInfo(hmenuSrc, uCmdId, MF_BYCOMMAND, &mii);
        if (!_fNoShowText)
            SetMenuItemInfo(hmenuSrc, ISFBIDM_SHOWTEXT, MF_BYCOMMAND, &mii);
        
        if (!_fFSNotify || !_pidl || ILIsEmpty(_pidl))
            DeleteMenu(hmenuSrc, ISFBIDM_OPEN, MF_BYCOMMAND);

        HMENU hView = GetSubMenu(hmenuSrc, 0);
        DeleteMenu(hView, ISFBIDM_LOGOS, MF_BYCOMMAND);
    }

    return hmenuSrc;
}
// IContextMenu implementation
//
HRESULT CSFToolbar::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HMENU hmenuSrc = _GetContextMenu();
    int i = 0;
    if (hmenuSrc)
    {
        i += Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, 0);
        DestroyMenu(hmenuSrc);
    }
    
    if (!_pcmSF && _fAllowRename && _psf)
    {
        _psf->CreateViewObject(_hwndTB, IID_PPV_ARG(IContextMenu, &_pcmSF));
    }
    
    if (_pcmSF)
    {
        _idCmdSF = i - idCmdFirst;
        HRESULT hrT = _pcmSF->QueryContextMenu(hmenu, indexMenu + i, i, 0x7fff, CMF_BANDCMD);
        if (SUCCEEDED(hrT))
            i += HRESULT_CODE(hrT);
    }
    
    return i;
}

BOOL CSFToolbar::_UpdateShowText(BOOL fNoShowText)
{
    BOOL fChanged = (!_fNoShowText != !fNoShowText);
        
    _fNoShowText = (fNoShowText != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateShowText turning text %hs", _fNoShowText ? "OFF" : "ON");

    if (_hwndTB)
    {
        SendMessage(_hwndTB, TB_SETMAXTEXTROWS, _fNoShowText ? 0 : 1, 0L);

        _UpdateButtons();
    }
    
    return fChanged;
}

HRESULT CSFToolbar::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);

    switch (idCmd)
    {
    case ISFBIDM_REFRESH:
        _Refresh();
        break;
        
    case ISFBIDM_OPEN:
        OpenFolderPidl(_pidl);
        break;
                
    case ISFBIDM_LARGE:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_LARGEICONS, TRUE);
        break;
    case ISFBIDM_SMALL:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_SMALLICONS, TRUE);
        break;

    case ISFBIDM_SHOWTEXT:
        fChanged = _UpdateShowText(!_fNoShowText);
        break;
        
    default:
        if (_pcmSF && idCmd >= _idCmdSF)
        {
            LPCSTR  lpOldVerb = lpici->lpVerb;
            
            lpici->lpVerb = MAKEINTRESOURCEA(idCmd -= _idCmdSF);
            
            _pcmSF->InvokeCommand(lpici);
            _FlushNotifyMessages(_hwndTB);

            lpici->lpVerb = lpOldVerb;
        }
        else
            TraceMsg(TF_BAND, "SFToolbar::InvokeCommand %d not handled", idCmd);
        break;
    }
    
    // Our minimum sizes have changed, notify the bandsite
    //
    if (fChanged)
        _ToolbarChanged();

    return S_OK;
}

HRESULT CSFToolbar::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

void CSFToolbar::_RegisterToolbar()
{
    // Since _SubclassWindow protects against multiply subclassing, 
    // This call is safe, and ensures that the toolbar is subclassed before
    // even trying to register it for change notify.
    if (_hwndTB && _fRegisterChangeNotify)
        _RegisterChangeNotify();
    CDelegateDropTarget::Init();
}

void CSFToolbar::_UnregisterToolbar()
{
    if (_hwndTB)
    {
        if (_fRegisterChangeNotify) 
            _UnregisterChangeNotify();
        _UnsubclassWindow(_hwndTB);
    }
}

void CSFToolbar::_RegisterChangeNotify()
{
    // Since we want to register for change notify ONLY once,
    // and only if this is a file system toolbar.
    if (!_fFSNRegistered && _fFSNotify)
    {
        if (_ptscn)
            _ptscn->Register(_hwndTB, g_idFSNotify, _lEvents);
        else
            _RegisterWindow(_hwndTB, _pidl, _lEvents);

        _fFSNRegistered = TRUE;
    }
}

void CSFToolbar::_UnregisterChangeNotify()
{
    // Only unregister if we have been registered.
    if (_hwndTB && _fFSNRegistered && _fFSNotify)
    {
        _fFSNRegistered = FALSE;
        if (_ptscn)
            _ptscn->Unregister();
        else
            _UnregisterWindow(_hwndTB);
    }
}

void CSFToolbar::_ReleaseShellFolder()
{
    if (_psf)
    {
        IUnknown_SetOwner(_psf, NULL);
        ATOMICRELEASE(_psf);
    }
    ATOMICRELEASE(_ptscn);
}    

// IWinEventHandler::IsWindowOwner

HRESULT CSFToolbar::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwndTB ||
        hwnd == _hwndToolTips ||
        hwnd == _hwndPager)
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\tbmenu.cpp ===
#include "shellprv.h"
#include "resource.h"
#include "tbmenu.h"
#include "isfband.h"
#include "util.h"
#include <uxtheme.h>

#define SUPERCLASS CMenuToolbarBase

CToolbarMenu::CToolbarMenu(DWORD dwFlags, HWND hwndTB) :
   CMenuToolbarBase(NULL, dwFlags),
   _hwndSubject(hwndTB)  // this is the toolbar that we are customizing
{
}

void CToolbarMenu::GetSize(SIZE* psize)
{
    ASSERT(_hwndMB);

    if (SendMessage(_hwndMB, TB_GETTEXTROWS, 0, 0) == 0)
    {
        // no text labels, so set a min width to make menu look 
        // pretty.  use min width of 5 * button width.
        // if < 5 buttons, use button count * button width
        int cButtons = ToolBar_ButtonCount(_hwndMB);
        cButtons = min(5, cButtons);
        LRESULT lButtonSize = SendMessage(_hwndMB, TB_GETBUTTONSIZE, 0, 0);
        LONG cxMin = cButtons * LOWORD(lButtonSize);
        psize->cx = max(psize->cx, cxMin);
    }
    SUPERCLASS::GetSize(psize);
}

void CToolbarMenu::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    if (fShow)
    {
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndMB, -1);
        if (fForceUpdate)
            v_UpdateButtons(TRUE);
    }
}

void CToolbarMenu::v_Close()
{
    if (_hwndMB)
        _UnsubclassWindow(_hwndMB);

    SUPERCLASS::v_Close();
}


void CToolbarMenu::v_UpdateButtons(BOOL fNegotiateSize)
{
}


HRESULT CToolbarMenu::v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (_pcmb->_psmcb)
    {
        SMDATA smd = {0};

        smd.dwMask = SMDM_TOOLBAR;
        smd.uId = idtCmd;
        smd.uIdParent = _pcmb->_uId;
        smd.uIdAncestor = _pcmb->_uIdAncestor;
        smd.punk = SAFECAST(_pcmb, IShellMenu*);
        smd.pvUserData = _pcmb->_pvUserData;
        smd.hwnd = _hwndMB;

        return _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);
    }    

    return S_FALSE;
}

HRESULT CToolbarMenu::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT CToolbarMenu::v_ExecItem(int idCmd)
{
    HRESULT hres = E_FAIL;
    TraceMsg(TF_TBMENU, "CToolbarMenu::v_ExecItem \tidCmd: %d", idCmd);
    return hres;
}

HRESULT CToolbarMenu::CreateToolbar(HWND hwndParent)
{
    HRESULT hr = S_OK;
    if (!_hwndMB)
    {
        DWORD dwStyle = (WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                         WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | 
                         CCS_NOPARENTALIGN | CCS_NORESIZE  | TBSTYLE_REGISTERDROP | TBSTYLE_TOOLTIPS);

        INT_PTR nRows = SendMessage(_hwndSubject, TB_GETTEXTROWS, 0, 0);

        if (nRows > 0)
        {
            // We have text labels; make it TBSTYLE_LIST.  The base class will
            // set TBSTYLE_EX_VERTICAL for us.
            ASSERT(_fHorizInVerticalMB == FALSE);
            dwStyle |= TBSTYLE_LIST;
        }
        else
        {
            // No text labels; make it horizontal and TBSTYLE_WRAPABLE.  Set
            // _fHorizInVerticalMB so that the base class does not try and set
            // TBSTYLE_EX_VERTICAL.
            _fHorizInVerticalMB = TRUE;
            dwStyle |= TBSTYLE_WRAPABLE;
        }

        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"), dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) FCIDM_TOOLBAR, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_TBMENU, "CToolbarMenu::CreateToolbar: Failed to Create Toolbar");
            return HRESULT_FROM_WIN32(GetLastError());
        }

        HWND hwndTT = (HWND)SendMessage(_hwndMB, TB_GETTOOLTIPS, 0, 0);
        SHSetWindowBits(hwndTT, GWL_STYLE, TTS_ALWAYSTIP, TTS_ALWAYSTIP);
        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndMB, TB_SETMAXTEXTROWS, nRows, 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        SendMessage(_hwndMB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        int cPimgs = (int)SendMessage(_hwndSubject, TB_GETIMAGELISTCOUNT, 0, 0);
        for (int i = 0; i < cPimgs; i++)
        {
            HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETIMAGELIST, i, (LPARAM)himl);
            HIMAGELIST himlHot = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETHOTIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETHOTIMAGELIST, i, (LPARAM)himlHot);
        }

        _SubclassWindow(_hwndMB);

        // Set the format to ANSI
        ToolBar_SetUnicodeFormat(_hwndMB, 0);

        SetWindowTheme(_hwndMB, L"", L"");
        hr = CMenuToolbarBase::CreateToolbar(hwndParent);
    }
    else if (GetParent(_hwndMB) != hwndParent)
    {
        ::SetParent(_hwndMB, hwndParent);
    }

    return hr;
}


LRESULT CToolbarMenu::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = CMenuToolbarBase::_DefWindowProcMB(hwnd, uMessage, wParam, lParam);

    if (lRes == 0)
        lRes = CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);

    return lRes;
}

#define MAXLEN 256

BYTE ToolBar_GetStateByIndex(HWND hwnd, INT_PTR iIndex)
{
    TBBUTTONINFO tbb;
    tbb.cbSize = sizeof(TBBUTTONINFO);
    tbb.dwMask = TBIF_STATE | TBIF_BYINDEX;
    ToolBar_GetButtonInfo(hwnd, iIndex, &tbb);
    return tbb.fsState;
}

void CToolbarMenu::_FillToolbar()
{
    RECT rcTB;
    TCHAR pszBuf[MAXLEN+1];
    LPTSTR psz;
    TBBUTTON tb;
    INT_PTR i, iCount;

    iCount = SendMessage(_hwndSubject, TB_BUTTONCOUNT, 0, 0L);
    GetClientRect(_hwndSubject, &rcTB);

    for (i = 0; i < iCount; i++)
    {
        if (SHIsButtonObscured(_hwndSubject, &rcTB, i) ||
            ((ToolBar_GetStateByIndex(_hwndSubject, i) & (TBSTATE_HIDDEN | TBSTATE_ENABLED)) ==
                (TBSTATE_HIDDEN | TBSTATE_ENABLED)))
        {
            SendMessage(_hwndSubject, TB_GETBUTTON, i, (LPARAM)&tb);
            if (!(tb.fsStyle & BTNS_SEP))
            {
                // autosize buttons look ugly here
                tb.fsStyle &= ~BTNS_AUTOSIZE;

                // need to rip off wrap bit; new toolbar will
                // figure out where wrapping should happen
                // also rip off hidden bit
                tb.fsState &= ~(TBSTATE_WRAP | TBSTATE_HIDDEN);

                if (tb.iString == -1)
                {
                    // no string
                    psz = NULL;
                }
                else if (HIWORD(tb.iString))
                {
                    // it's a string pointer
                    psz = (LPTSTR) tb.iString;
                }
                else
                {
                    // it's an index into toolbar string array
                    SendMessage(_hwndSubject, TB_GETSTRING, MAKELONG(MAXLEN, tb.iString), (LPARAM)pszBuf);
                    psz = pszBuf;
                }
                if (psz)
                    tb.iString = (INT_PTR)psz;
                else
                    tb.iString = -1;

                if (tb.iBitmap == -1)
                {
                    int id = GetDlgCtrlID(_hwndSubject);

                    NMTBDISPINFO  tbgdi = {0};
                    tbgdi.hdr.hwndFrom  = _hwndSubject;
                    tbgdi.hdr.idFrom    = id;
                    tbgdi.hdr.code      = TBN_GETDISPINFO;
                    tbgdi.dwMask        = TBNF_IMAGE;
                    tbgdi.idCommand     = tb.idCommand;
                    tbgdi.iImage        = 0;
                    tbgdi.lParam        = tb.dwData;

                    SendMessage(GetParent(_hwndSubject), WM_NOTIFY, (WPARAM)id, (LPARAM)&tbgdi);

                    if(tbgdi.dwMask & TBNF_DI_SETITEM)
                        tb.iBitmap = tbgdi.iImage;
                }

                SendMessage(_hwndMB, TB_ADDBUTTONS, 1, (LPARAM)&tb);
            }
        }
    }
}

STDMETHODIMP CToolbarMenu::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB) 
        return S_OK;
    else 
        return S_FALSE; 
}

void CToolbarMenu::_CancelMenu()
{
    IMenuPopup* pmp;
    if (EVAL(SUCCEEDED(_pcmb->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp)))))
    {
        // tell menuband it's time to die
        pmp->OnSelect(MPOS_FULLCANCEL);
        pmp->Release();
    }
}

STDMETHODIMP CToolbarMenu::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_FALSE;
    ASSERT(plres);

    switch (uMsg)
    {
    case WM_COMMAND:
        PostMessage(GetParent(_hwndSubject), WM_COMMAND, wParam, (LPARAM)_hwndSubject);
        _CancelMenu();
        hres = S_OK;
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case TBN_DROPDOWN:
                _fTrackingSubMenu = TRUE;
                pnmh->hwndFrom = _hwndSubject;
                MapWindowPoints(_hwndMB, _hwndSubject, (LPPOINT) &((LPNMTOOLBAR)pnmh)->rcButton, 2);
                *plres = SendMessage(GetParent(_hwndSubject), WM_NOTIFY, wParam, (LPARAM)pnmh);
                _CancelMenu();
                hres = S_OK;
                _fTrackingSubMenu = FALSE;
                break;

            default:
                goto DoDefault;
            }
        }
        break;

DoDefault:
    default:
        hres = SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    return hres;
}

CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd)
{
    return new CToolbarMenu(0, hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\qlink.cpp ===
#include "shellprv.h"
#include "common.h"
#include "resource.h"
#include "dpastuff.h"

#include "bands.h"
#include "isfband.h"
#include "legacy.h"
#include "uemapp.h"

#define SUPERCLASS CISFBand

#define DM_PERSIST      DM_TRACE        // trace IPS::Load, ::Save, etc.


class CQuickLinks : public CISFBand
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CISFBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CISFBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pstm, BOOL fClearDirty);
    
    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw) { return CISFBand::CloseDW(dw); };
    
    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite) { return CISFBand::SetSite(punkSite); };

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IDelegateDropTarget ***
    virtual HRESULT OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);
protected:    
    CQuickLinks();
    virtual ~CQuickLinks();

    HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);
    HRESULT _InternalInit(void);

    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return TRUE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

private:    
    BITBOOL    _fIsInited :1;
    BITBOOL    _fSingleLine :1;

    friend HRESULT CQuickLinks_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);    // for ctor
};

#define MAX_QL_SITES            5   // Number of Sites on the quick link bar

#define SZ_REGKEY_SPECIALFOLDERS  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

HRESULT SHGetSpecialFolderPathEx(LPTSTR pszPath, DWORD cchSize, DWORD dwCSIDL, LPCTSTR pszFolderName)
{
    HRESULT hr = S_OK;
    
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_FAVORITES | CSIDL_FLAG_CREATE, NULL, 0, pszPath)))
        return hr;

    cchSize *= sizeof(TCHAR);   // Count of chars to count of bytes.
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_SPECIALFOLDERS, pszFolderName, NULL, pszPath, &cchSize))
        hr = E_FAIL;

    TraceMsg(TF_BAND|TF_GENERAL, "CQuickLinks SHGetSpecialFolderPath(CSIDL_FAVORITES), Failed so getting Fav dir from registry. Path=%s; hr=%#8lx", pszPath, hr);
    
    return hr;
}

#define LINKS_FOLDERNAME_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar")
#define LINKS_FOLDERNAME_VALUE TEXT("LinksFolderName")

// _GetTitleW and QuickLinks_GetFolder call this. 
// if we ever go back to ANSI days we'll get a build break
// right now we are saving some space by not having A version that's not used
void QuickLinks_GetName(LPTSTR pszName, DWORD cchSize, BOOL bSetup)
{
    DWORD cb = cchSize * SIZEOF(TCHAR);
    // try to get the name of the folder from the registry (in case of upgrade to a different
    // language we cannot use the resource)
    if (SHGetValue(HKEY_CURRENT_USER, LINKS_FOLDERNAME_KEY, LINKS_FOLDERNAME_VALUE, NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
    {
        // no luck, try the HKLM if we are doing per user registration, maybe setup stored the old links folder name there
        cb = cchSize * SIZEOF(TCHAR);
        if (!bSetup || SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), TEXT("LinkFolderName"), NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
        {
            // if everything else fails load it from the resource
            LoadString(HINST_THISDLL, IDS_QLINKS, pszName, cchSize);
        }
    }
}

HRESULT QuickLinks_GetFolder(LPTSTR pszPath, DWORD cchSize, BOOL bSetup = FALSE)
{
    TCHAR szQuickLinks[MAX_PATH];

    if ((cchSize >= MAX_PATH) &&
        SUCCEEDED(SHGetSpecialFolderPathEx(pszPath, cchSize, CSIDL_FAVORITES, TEXT("Favorites"))))
    {
        QuickLinks_GetName(szQuickLinks, ARRAYSIZE(szQuickLinks), bSetup);
        PathCombine(pszPath, pszPath, szQuickLinks);
        return S_OK;
    }    
    
    return E_FAIL;
}

// Length of the text under each quick links
#define MAX_QL_TEXT_LENGTH      256
#define MAX_QL_WIDTH            92

#define QL_BUFFER (MAX_QL_TEXT_LENGTH + MAX_URL_STRING + MAX_TOOLTIP_STRING + 3)

HRESULT CQuickLinks::_InternalInit(void)
{
    if (!_fIsInited && !_psf)
    {
        LPITEMIDLIST pidlQLinks;
        TCHAR szPath[MAX_PATH];

        QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (!PathFileExists(szPath))
            CreateDirectory(szPath, NULL);
        if (SUCCEEDED(IECreateFromPath(szPath, &pidlQLinks)))
        {
            InitializeSFB(NULL, pidlQLinks);
            ILFree(pidlQLinks);
        }
    }
    _fIsInited = TRUE;

    return S_OK;
}

CQuickLinks::CQuickLinks() :
    SUPERCLASS()
{
    
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in CQuickLinks ctor");
        DEBUG_BREAK;
    }
#endif
    
    ASSERT(!_fIsInited);
    _fCascadeFolder = TRUE;
    _fVariableWidth = TRUE;

    _pguidUEMGroup = &UEMIID_BROWSER;
    
}

CQuickLinks::~CQuickLinks()
{
}

HRESULT CQuickLinks_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;
    CQuickLinks *pObj = new CQuickLinks();
    if (pObj) 
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hr;
}

HRESULT CQuickLinks::_LoadOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && _psf)
    {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_READ);

        if (pstm)
        {
            OrderList_Destroy(&_hdpaOrder);

            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            pstm->Release();
        }
    }

    return hr;
}

HRESULT CQuickLinks::_SaveOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && (_hdpa || _hdpaOrder))
    {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_CREATE | STGM_WRITE);

        if (pstm)
        {
            hr = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);

            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
        hr = SUPERCLASS::_SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    HRESULT hres;
    
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    hres = IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
    // we could have failed because our folder does not exist
    // that can happen if someone delted/renamed links while there is 
    // stream in the registry that saves the pidl - we get the pidl and
    // bind to it (bind does not hit the disk so it succeeds even though
    // the file does not exist
    if (FAILED(hres) && hres != E_OUTOFMEMORY)
    {
        TCHAR szPath[MAX_PATH];

        ASSERT(_pidl);
        if (SHGetPathFromIDList(_pidl, szPath) && !PathFileExists(szPath))
        {
            LPITEMIDLIST pidlQLinks;
            
            QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
            if (!PathFileExists(szPath))
                CreateDirectory(szPath, NULL);
            if (SUCCEEDED(IECreateFromPath(szPath, &pidlQLinks)))
            {
                if (SUCCEEDED(InitializeSFB(NULL, pidlQLinks)))
                {
                    hres = _psf->EnumObjects(NULL, dwEnumFlags, ppenum);
                }
                ILFree(pidlQLinks);
            }
        }
    }
    return hres;
}

//*** CQuickLinks::IPersistStream
HRESULT CQuickLinks::Load(IStream *pstm)
{
    HRESULT hr = S_OK;

    hr = SUPERCLASS::Load(pstm);

    // This forces a refresh
    _fIsInited = FALSE;
    ATOMICRELEASE(_psf);
    _InternalInit();



    // if we are on our first run through (i.e. this reg key exists)
    // we load the order stream from our old location (used in ie4) and avoid overwriting it w/ favorites stream
    // so user can have their custom order preserved on upgrade (they are more likely to customize links bar 
    // order then favorites/links so we picked that one)
    if (SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), 
                   TEXT("SaveLinksOrder"), NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        SHDeleteValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), TEXT("SaveLinksOrder"));
        // must persist old order stream in the new location (fav/links)
        _SaveOrderStream();
    }
    else
    {
        _LoadOrderStream();
    }

    return hr;
}

HRESULT CQuickLinks::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hr = SUPERCLASS::Save(pstm, fClearDirty);

    _SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_QuickLinks;
    return S_OK;
}

// *** IUnknown Interface ***
HRESULT CQuickLinks::QueryInterface(REFIID riid, void **ppvObj)
{
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}

// command target
STDMETHODIMP CQuickLinks::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = S_FALSE;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(*pguidCmdGroup, CLSID_QuickLinks)) 
        {
            switch (nCmdID) 
            {
            case QLCMD_SINGLELINE:
                _fSingleLine = (nCmdexecopt == 1);
                return S_OK;
            }
        }
        else if (IsEqualGUID(*pguidCmdGroup, CGID_ISFBand))
        {
            switch(nCmdID)
            {
            case ISFBID_SETORDERSTREAM:
                hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                _SaveOrderStream();
                break;
            }
        }
    }

    if (hres ==  S_FALSE)
        hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}

// *** IDockingWindow Interface ***
HRESULT CQuickLinks::ShowDW(BOOL fShow)
{
    if (fShow)
        _InternalInit();

    return SUPERCLASS::ShowDW(fShow);
}

    
HRESULT CQuickLinks::_GetTitleW(LPWSTR pwzTitle, DWORD cchSize)
{
    QuickLinks_GetName(pwzTitle, cchSize, FALSE);
    return S_OK;
}


HRESULT CQuickLinks::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
   HRESULT hres = SUPERCLASS::GetBandInfo(dwBandID, fViewMode, pdbi);
   
   if (_hwndTB && _fSingleLine)
   {
       LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L);
       pdbi->ptMinSize.y = HIWORD(lButtonSize);
       
       pdbi->dwModeFlags &= ~DBIMF_VARIABLEHEIGHT;
   }
   return hres;
    
}

HRESULT CQuickLinks::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;
    BOOL    fIsSafe = TRUE;

    // if we are not the source of the drop and the Links folder does not exist we need to create it
    if (_iDragSource == -1)
    {
        TCHAR szPath[MAX_PATH];

        QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (!PathFileExists(szPath))
            CreateDirectory(szPath, NULL);

        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fIsSafe = IEIsLinkSafe(_hwnd, pidl, ILS_LINK);
            ILFree(pidl);
        }

    }

    if (fIsSafe)
    {
        hr = SUPERCLASS::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\track.cpp ===
#include "shellprv.h"
#include "tbmenu.h"
#include "isfband.h"
#include "isfmenu.h"

#include "mluisupp.h"
#define SMFORWARD(x) if (!_psm) { return E_FAIL; } else return _psm->x

class CTrackShellMenu : public ITrackShellMenu,
                        public IShellMenu2,
                        public IObjectWithSite,
                        public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** ITrackShellMenu methods ***
    virtual STDMETHODIMP SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags);
    virtual STDMETHODIMP Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID ridd, void** ppvObj) { *ppvObj = NULL; return E_NOTIMPL; };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    CTrackShellMenu();
private:
    virtual ~CTrackShellMenu();

    IShellMenu*     _psmClient;
    IShellMenu*     _psm;
    IShellMenu2*    _psm2;
    IUnknown*       _punkSite;
    int             _cRef;
    HMENU           _hmenu;
    BITBOOL         _fDestroyTopLevel : 1;
};


typedef struct
{
    WNDPROC pfnOriginal;
    IMenuBand* pmb;
} MENUHOOK;

#define SZ_MENUHOOKPROP TEXT("MenuHookProp")

LRESULT CALLBACK MenuHookWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);

    if (pmh)
    {
        MSG msg;
        LRESULT lres;

        msg.hwnd = hwnd;
        msg.message = uMsg;
        msg.wParam = wParam;
        msg.lParam = lParam;

        if (pmh->pmb->TranslateMenuMessage(&msg, &lres) == S_OK)
            return lres;

        wParam = msg.wParam;
        lParam = msg.lParam;
        return CallWindowProc(pmh->pfnOriginal, hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

HRESULT HookMenuWindow(HWND hwnd, IMenuBand* pmb)
{
    HRESULT hres = E_FAIL;

    ASSERT(IsWindow(hwnd));

    // make sure we haven't already hooked this window
    if (GetProp(hwnd, SZ_MENUHOOKPROP) == NULL)
    {
        MENUHOOK* pmh = new MENUHOOK;
        if (pmh)
        {
            pmh->pfnOriginal = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            pmh->pmb = pmb;

            SetProp(hwnd, SZ_MENUHOOKPROP, pmh);

            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MenuHookWndProc);

            hres = S_OK;
        }
    }
    return hres;
}

void UnHookMenuWindow(HWND hwnd)
{

    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);
    if (pmh)
    {
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pmh->pfnOriginal);
        SetProp(hwnd, SZ_MENUHOOKPROP, NULL);
        delete pmh;
    }

}


// This class is here to implement a "Menu Filter". We need this because the old style of 
// implementing obscured Menus does not work because user munges the WM_INITMENUPOPUP information
// based on the relative position within the HMENU. So here we keep that information, we just hide the item.

class CShellMenuCallbackWrapper : public IShellMenuCallback,
                                  public CObjectWithSite
{
    int _cRef;
    IShellMenuCallback* _psmc;
    HWND    _hwnd;
    RECT    _rcTB;
    ~CShellMenuCallbackWrapper()
    {
        ATOMICRELEASE(_psmc);
    }

public:
    CShellMenuCallbackWrapper(HWND hwnd, IShellMenuCallback* psmc) : _cRef(1)
    {
        _psmc = psmc;
        if (_psmc)
            _psmc->AddRef();
        _hwnd = hwnd;
        GetClientRect(_hwnd, &_rcTB);
    }

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj)
    {
        static const QITAB qit[] = 
        {
            QITABENT(CShellMenuCallbackWrapper, IShellMenuCallback),
            QITABENT(CShellMenuCallbackWrapper, IObjectWithSite),
            { 0 },
        };

        return QISearch(this, qit, riid, ppvObj);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        _cRef++;
        return _cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT(_cRef > 0);
        _cRef--;

        if (_cRef > 0)
            return _cRef;

        delete this;
        return 0;
    }

    // *** CObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk)            {   IUnknown_SetSite(_psmc, punk); return S_OK;  }
    STDMETHODIMP GetSite(REFIID riid, void** ppObj) {   return IUnknown_GetSite(_psmc, riid, ppObj); }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        HRESULT hres = S_FALSE;
        
        if (_psmc)
            hres = _psmc->CallbackSM(psmd, uMsg, wParam, lParam);

        if (uMsg == SMC_GETINFO)
        {
            SMINFO* psminfo = (SMINFO*)lParam;
            int iPos = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, psmd->uId, 0);

            if (psminfo->dwMask & SMIM_FLAGS &&
                iPos >= 0 && 
                !SHIsButtonObscured(_hwnd, &_rcTB, iPos))
            {
                psminfo->dwFlags |= SMIF_HIDDEN;
                hres = S_OK;
            }
        }

        return hres;
    }
};

STDAPI  CTrackShellMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv)
{
    HRESULT hres = E_OUTOFMEMORY;
    CTrackShellMenu* pObj = new CTrackShellMenu();
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }

    return hres;
}


CTrackShellMenu::CTrackShellMenu() : _cRef(1)
{ 
    if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &_psm))))
    {
        _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &_psm2));
    }
}

CTrackShellMenu::~CTrackShellMenu()
{
    ATOMICRELEASE(_psm2);
    ATOMICRELEASE(_psm);
    ATOMICRELEASE(_psmClient);
    ASSERT(!_punkSite);     // else someone neglected to call matching SetSite(NULL)
}

ULONG CTrackShellMenu::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTrackShellMenu::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTrackShellMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CTrackShellMenu, IShellMenu, ITrackShellMenu),
        QITABENT(CTrackShellMenu, ITrackShellMenu),
        QITABENT(CTrackShellMenu, IShellMenu2),
        QITABENT(CTrackShellMenu, IObjectWithSite),
        QITABENT(CTrackShellMenu, IServiceProvider),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    return hres;
}

// *** IServiceProvider methods ***
HRESULT CTrackShellMenu::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_psm, guidService, riid, ppvObj);
}

// *** IShellMenu methods ***
STDMETHODIMP CTrackShellMenu::Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{ SMFORWARD(Initialize(psmc, uId, uIdAncestor, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags)
{ SMFORWARD(GetMenuInfo(ppsmc, puId, puIdAncestor, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags)
{ SMFORWARD(SetShellFolder(psf, pidlFolder, hkey, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{ SMFORWARD(GetShellFolder(pdwFlags, ppidl, riid, ppvObj)); }

STDMETHODIMP CTrackShellMenu::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{ SMFORWARD(SetMenu(hmenu, hwnd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{ SMFORWARD(GetMenu(phmenu, phwnd, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{ SMFORWARD(InvalidateItem(psmd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetState(LPSMDATA psmd)
{ SMFORWARD(GetState(psmd)); }

STDMETHODIMP CTrackShellMenu::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{ SMFORWARD(SetMenuToolbar(punk, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj)
{
    if (_psm2)
    {
        return _psm2->GetSubMenu(idCmd, riid, ppvObj);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetToolbar([in] HWND hwnd, [in] DWORD dwFlags)
{
    if (_psm2)
    {
        return _psm2->SetToolbar(hwnd, dwFlags);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetMinWidth([in] int cxMenu)
{
    if (_psm2)
    {
        return _psm2->SetMinWidth(cxMenu);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetNoBorder([in] BOOL fNoBorder)
{
    if (_psm2)
    {
        return _psm2->SetNoBorder(fNoBorder);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetTheme([in] LPCWSTR pszTheme)
{
    if (_psm2)
    {
        return _psm2->SetTheme(pszTheme);
    }
    else
    {
        return E_NOTIMPL;
    }
}

// *** ITrackShellMenu methods ***
HRESULT CTrackShellMenu::SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Make sure we created the Inner Shell Menu
    if (!_psm)
        return hr;

    if (punkBand && 
        SUCCEEDED(punkBand->QueryInterface(IID_PPV_ARG(IShellMenu, &_psmClient))))
    {
        UINT uId, uIdAncestor;
        DWORD dwFlags;
        IShellMenuCallback* psmcb;

        hr = _psmClient->GetMenuInfo(&psmcb, &uId, &uIdAncestor, &dwFlags);
        if (SUCCEEDED(hr))
        {
            IShellMenuCallback* psmcbClone = NULL;
            if (psmcb)
            {
                if (S_FALSE == psmcb->CallbackSM(NULL, SMC_GETOBJECT, 
                    (WPARAM)&IID_IShellMenuCallback,
                    (LPARAM)(LPVOID*)&psmcbClone))
                {
                    psmcbClone = psmcb;
                    psmcbClone->AddRef();
                }
            }

            dwFlags &= ~SMINIT_HORIZONTAL;

            CShellMenuCallbackWrapper* psmcw = new CShellMenuCallbackWrapper(hwndTB, psmcbClone);

            // We want the bands to think it is:
            // Top level - because it has no menuband parent
            // Vertical  - because it's not a menubar
            dwFlags |= SMINIT_TOPLEVEL | SMINIT_VERTICAL;
            hr = _psm->Initialize(psmcw, uId, ANCESTORDEFAULT, dwFlags);

            if (SUCCEEDED(hr))
            {
                HWND hwndOwner;
                HMENU hmenuObscured;
                hr = _psmClient->GetMenu(&hmenuObscured, &hwndOwner, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = _psm->SetMenu(hmenuObscured, hwndOwner, dwSMSetFlags | SMSET_DONTOWN);   // Menuband takes ownership;
                }
            }

            if (psmcb)
                psmcb->Release();

            if (psmcbClone)
                psmcbClone->Release();

            if (psmcw)
                psmcw->Release();

        }
    }
    else
    {
        IShellMenu2 *psm2;
        hr = _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2));
        if (SUCCEEDED(hr))
        {
            hr = psm2->SetToolbar(hwndTB, dwSMSetFlags);
            psm2->Release();
        }
    }

    return hr;
}

HRESULT CTrackShellMenu::Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags)
{
    IMenuBand* pmb;
    HRESULT hres = E_INVALIDARG;


    if (!_psm)
        return hres;

    hres = _psm->QueryInterface(IID_PPV_ARG(IMenuBand, &pmb));
    if (FAILED(hres))
        return hres;

    HWND hwndParent = GetTopLevelAncestor(hwnd);

    // Did the user set a menu into the Shell Menu?
    HWND hwndSubclassed = NULL;
    GetMenu(NULL, &hwndSubclassed, NULL);
    if (hwndSubclassed == NULL)
    {
        // No; We need to artificially set one so that the message filtering and stuff works
        SetMenu(NULL, hwndParent, 0);
    }

    SetForegroundWindow(hwndParent);

    IMenuPopup* pmp;
    hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hres))
    {
        IBandSite* pbs;
        hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs));
        if (SUCCEEDED(hres)) 
        {
            hres = pmp->SetClient(pbs);
            if (SUCCEEDED(hres)) 
            {
                IDeskBand* pdb;
                hres = _psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
                if (SUCCEEDED(hres)) 
                {
                    hres = pbs->AddBand(pdb);
                    pdb->Release();
                }
            }
            pbs->Release();
        }

        // If we've got a site ourselves, have MenuDeskBar use that.
        if (_punkSite)
            IUnknown_SetSite(pmp, _punkSite);

        if (SUCCEEDED(hres))
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            void* pvContext = GetMessageFilter()->GetContext();
            hres = HookMenuWindow(hwndParent, pmb);
            if (SUCCEEDED(hres))
            {
                // This collapses any modal menus before we proceed. When switching between
                // Chevron menus, we need to collapse the previous menu. Refer to the comment
                // at the function definition.
                pmf->ForceModalCollapse();

                pmp->Popup(ppt, (LPRECTL)prcExclude, dwFlags);

                pmf->SetModal(TRUE);

                MSG msg;
                while (GetMessage(&msg, NULL, 0, 0)) 
                {
                    HRESULT hres = pmb->IsMenuMessage(&msg);
                    if (hres == E_FAIL)
                    {
                        // menuband says it's time to pack up and go home.
                        // re-post this message so that it gets handled after
                        // we've cleaned up the menu (avoid re-entrancy issues &
                        // let rebar restore state of chevron button to unpressed)
                        PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                        break;
                    }
                    else if (hres != S_OK) 
                    {
                        // menuband didn't handle this one
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                hres = S_OK;
                UnHookMenuWindow(hwndParent);
                // We cannot change the context when modal, so unset the modal flag so that we can undo the context block.
                pmf->SetModal(FALSE); 
                pmf->SetContext(pvContext, TRUE);
            }
            pmb->Release();
        }

        if (_psmClient)
        {
            // This is to fix a bug where if there is a cached ISHellMenu in the submenu,
            // and you share the callback (For example, Broweser menu callback and the
            // favorites menu being shared between the browser bar and the chevron menu)
            // when on menu collapsed, we were destroying the sub menu by doing a set site.
            // since we no longer do the set site on the sub menu, we need a way to say "Reset
            // your parent". and this is the best way.
            IUnknown_Exec(_psmClient, &CGID_MenuBand, MBANDCID_REFRESH, 0, NULL, NULL);
        }

        // This call is required regardless of whether we had a _punkSite above;
        // MenuDeskBar does its cleanup on SetSite(NULL).
        IUnknown_SetSite(pmp, NULL);
        pmp->Release();
    }

    return hres;
}

// *** IObjectWithSite methods ***
HRESULT CTrackShellMenu::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    ATOMICRELEASE(_punkSite);

    _punkSite = punkSite;

    if (punkSite)
        punkSite->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\util.cpp ===
#include "shellprv.h"
#include "util.h"
#include "idlcomm.h"
#include <uxtheme.h>
#include <tmschema.h>

// shdocvw and browseui share brutil and menubands need it too
// unfortunately shell32 isnt set up quite like shdocvw and browseui so
// these have to be hacked in a little
#define MAX_BROWSER_WINDOW_TITLE   128
#define g_fRunningOnNT TRUE
#define InitClipboardFormats IDLData_InitializeClipboardFormats
#define g_cfFileDescA g_cfFileGroupDescriptorA
#define g_cfFileDescW g_cfFileGroupDescriptorW
#define g_cfURL g_cfShellURL
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)
#define NO_MLUI_IN_SHELL32
#include "..\inc\brutil.cpp"
const VARIANT c_vaEmpty = {0};


HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    HRESULT hr = E_FAIL;

    if (ppbp)
    {
        if (NULL == (*ppbp))
            hr = IUnknown_QueryService(punkParent, SID_IBandProxy, IID_PPV_ARG(IBandProxy, ppbp));

        if (*ppbp && ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);        // They already have the object.
    }


    return hr;
}

HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    ASSERT(ppbp);

    HRESULT hr = CoCreateInstance(CLSID_BandProxy, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandProxy, ppbp));
    if (SUCCEEDED(hr))
    {
        // Set the site
        ASSERT(*ppbp);
        (*ppbp)->SetSite(punkParent);

        if (ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (ppvObj)
            *ppvObj = NULL;
    }
    return hr;
}

typedef struct tagINIPAIR
{
    DWORD dwFlags;
    LPCTSTR pszSection;
}
INIPAIR;

const INIPAIR c_aIniPairs[] =
{
    EICH_KINET,          TEXT("Software\\Microsoft\\Internet Explorer"),
    EICH_KINETMAIN,      TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
    EICH_KWIN,           TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
    EICH_KWINEXPLORER,   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
    EICH_KWINEXPLSMICO,  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SmallIcons"),
    EICH_KWINPOLICY,     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
    EICH_SSAVETASKBAR,   TEXT("SaveTaskbar"),
    EICH_SWINDOWMETRICS, TEXT("WindowMetrics"),
    EICH_SSHELLMENU,     TEXT("ShellMenu"),
    EICH_SPOLICY,        TEXT("Policy"),
    EICH_SWINDOWS,       TEXT("Windows"),
};

DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam)
{
    DWORD dwFlags = 0;

    if (lParam == 0)
    {
        if (wParam == 0)
        {
            dwFlags = EICH_UNKNOWN;
        }
    }
    else
    {
        //
        // In the wacky world of browseui, UNICODE-ANSI doesn't vary from
        // window to window.  Instead, on NT browseui registers all windows
        // UNICODE, while on 9x user browseui registers all windows ANSI.
        //
        LPCTSTR pszSection = (LPCWSTR)lParam;

        for (int i = 0; !dwFlags && i < ARRAYSIZE(c_aIniPairs); i++)
        {
            if (StrCmpI(pszSection, c_aIniPairs[i].pszSection) == 0)
            {
                dwFlags = c_aIniPairs[i].dwFlags;
            }
        }
    }

    return dwFlags;
}

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne;

    uFlags |= SHCNRF_NewDelivery;

    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;
    return SHChangeNotifyRegister(hwnd, uFlags, dwEvents, nMsg, 1, &fsne);
}

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    BOOL fRet = FALSE;

    *pszText = 0;   // empty for failure

    if (pidl)
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IQueryInfo, NULL, &pqi))))
        {
            WCHAR *pwszTip;
            pqi->GetInfoTip(dwFlags, &pwszTip);
            if (pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
    }
    return fRet;
}

BOOL GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    return GetInfoTipEx(psf, 0, pidl, pszText, cchTextMax);
}

// does filename based lookup to see if a file is browsable or not.
// this is probably vulnerable to ::$DATA stuff so DO NOT use it for deciding whether to
// shellexecute or something.
// right now all its used for is if a menu should cascade on the file.
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl)
{
    DWORD    cb;
    LPCTSTR pszExt;
    TCHAR   szFile[MAX_PATH];
    TCHAR   szProgID[80];   // From ..\shell32\fstreex.c
    TCHAR   szCLSID[GUIDSTR_MAX], szCATID[GUIDSTR_MAX];
    TCHAR   szKey[GUIDSTR_MAX * 4];
    HKEY    hkeyProgID = NULL;
    BOOL    fRet = FALSE;

    for (;;)
    {
        // Make sure we have a file extension
        if  (
            !SHGetPathFromIDList(pidl, szFile)
            ||
            ((pszExt = PathFindExtension(szFile)) == NULL)
            ||
            (pszExt[0] != TEXT('.'))
           )
        {
            break;
        }

        // Get the ProgID.
        cb = sizeof(szProgID);
        if  (
            (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) != ERROR_SUCCESS)
            ||
            (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProgID, 0, KEY_READ, &hkeyProgID) != ERROR_SUCCESS)
           )
        {
            break;
        }

        // From the ProgID, get the CLSID.
        cb = sizeof(szCLSID);
        if (SHGetValue(hkeyProgID, TEXT("CLSID"), NULL, NULL, szCLSID, &cb) != ERROR_SUCCESS)
            break;

        // Construct the registry key that detects if
        // a CLSID is a member of a CATID.
        SHStringFromGUID(CATID_BrowsableShellExt, szCATID, ARRAYSIZE(szCATID));
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\Implemented Categories\\%s"),
                 szCLSID, szCATID);

        // See if it's there.
        cb = 0;
        if (SHGetValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL, NULL, &cb) != ERROR_SUCCESS)
            break;

        fRet = TRUE;
        break;
    }

    if (hkeyProgID != NULL)
        RegCloseKey(hkeyProgID);

    return fRet;
}


void OpenFolderPidl(LPCITEMIDLIST pidl)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;
    shei.lpIDList   = (LPITEMIDLIST)pidl;
    // callers are responsible -- this is called only from sftbar in response to invokecommand
    ShellExecuteEx(&shei);
}

// As perf, share IShellLink implementations between bands and ask
// the bandsite for an implementation. Don't rely on the bandsite
// because you never know who will host us in the future. (And bandsite
// can change to not have us hosted at save/load time. Ex: it doesn't
// set our site before loading us from the stream, which sounds buggy.)
//
HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    IShellLinkA* psl;

    if (punkSite)
        hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            ASSERT(pidl);
            psl->SetIDList(pidl);

            hr = pps->Save(pstm, FALSE);
            pps->Release();
        }
        psl->Release();
    }
    return hr;
}

HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl)
{
    IShellLinkA* psl;
    HRESULT hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            // link responsible for loading correctly
            hr = pps->Load(pstm);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = psl->GetIDList(ppidl);

                // Don't make me resolve the link because it's soo slow because
                // it often loads 80k of networking dlls.
                if (!EVAL(SUCCEEDED(hr)))
                {
                    hr = psl->Resolve(NULL, SLR_NOUPDATE | SLR_NO_UI);
                    if (EVAL(SUCCEEDED(hr)))
                        hr = psl->GetIDList(ppidl);
                }

                hr = *ppidl ? S_OK : E_FAIL;
            }
            pps->Release();
        }
        psl->Release();
    }
    return hr;
}


// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}


// Can we browse or navigate to this pidl?  If not, need
BOOL ILIsBrowsable(LPCITEMIDLIST pidl, BOOL *pfIsFolder)
{
    if (!pidl)
        return FALSE;
    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_BROWSABLE;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);

    if (pfIsFolder && SUCCEEDED(hr))
        *pfIsFolder = dwAttributes & SFGAO_FOLDER;

    return SUCCEEDED(hr) && (dwAttributes & (SFGAO_FOLDER | SFGAO_BROWSABLE));
}

// gets a target pidl given a name space item. typically this is a .lnk or .url file
//
//  in:
//        psf         shell folder for item
//        pidl        item relative to psf, single level
//
//  in/out
//        pdwAttribs  [optional] attributes mask to filter on (returned).
//        must be initalized
//
//
//  returns
//        *ppidl      the target pidl
//        *pdwAttribs [optional] attributes of the source object

STDAPI SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs)
{
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(NULL == pdwAttribs || IS_VALID_WRITE_PTR(pdwAttribs, DWORD));
    ASSERT(ILFindLastID(pidl) == pidl);   // must be single level PIDL

    *ppidl = NULL;      // assume failure

    DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_LINK | SFGAO_BROWSABLE;

    if (pdwAttribs)
        dwAttribs |= *pdwAttribs;

    HRESULT hr = psf->GetAttributesOf(1, &pidl, &dwAttribs);
    if (SUCCEEDED(hr))
    {
        // first try the most efficient way
        IShellLinkA *psl;       // "A" so this works on Win95
        hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLinkA, NULL, &psl));
        if (SUCCEEDED(hr))
        {
            hr = psl->GetIDList(ppidl);
            psl->Release();
        }

        // this is for .lnk and .url files that don't register properly
        if (FAILED(hr) && (dwAttribs & (SFGAO_FILESYSTEM | SFGAO_LINK)) == (SFGAO_FILESYSTEM | SFGAO_LINK))
        {
            TCHAR szPath[MAX_PATH];

            hr = GetPathForItem(psf, pidl, szPath, NULL);
            if (SUCCEEDED(hr))
                hr = GetLinkTargetIDList(szPath, NULL, 0, ppidl);
        }

        // .doc or .html. return the pidl for this.
        // (fully qualify against the folder pidl)
        if (FAILED(hr) && (dwAttribs & SFGAO_BROWSABLE))
        {
            LPITEMIDLIST pidlFolder;
            hr = SHGetIDListFromUnk(psf, &pidlFolder);
            if (SUCCEEDED(hr))
            {
                *ppidl = ILCombine(pidlFolder, pidl); // navigate to this thing...
                hr = *ppidl ? S_OK : E_OUTOFMEMORY;
                ILFree(pidlFolder);
            }
        }

        // Callers of SHGetNavigateTarget assume that the returned pidl
        // is navigatable (SFGAO_FOLDER or SFGAO_BROWSER), which isn't
        // the case for a link (it could be a link to an exe).
        //
        if (SUCCEEDED(hr) && !ILIsBrowsable(*ppidl, NULL))
        {
            ILFree(*ppidl);
            *ppidl = NULL;
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr) && pdwAttribs)
            *pdwAttribs = dwAttribs;
    }
    return hr;
}

STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags)
{
    HRESULT hr = S_FALSE;

    TCHAR szPath[MAX_PATH];

    // Can we navigate to this favorite?
    BOOL fNavigateDone = SUCCEEDED(GetPathForItem(psf, pidl, szPath, NULL)) &&
                         SUCCEEDED(NavFrameWithFile(szPath, punkSite));
    if (fNavigateDone)
        return S_OK;

    LPITEMIDLIST pidlGoto;

    ASSERT(!(dwFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)));
    
    if (SUCCEEDED(SHGetNavigateTarget(psf, pidl, &pidlGoto, NULL)))
    {
        IShellBrowser* psb;
        if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser,
            IID_PPV_ARG(IShellBrowser, &psb))))
        {
            hr = psb->BrowseObject(pidlGoto, dwFlags | SBSP_SAMEBROWSER);
            psb->Release();
        }
        ILFree(pidlGoto);
    }
    return hr;
}

STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd)
{
    IOleWindow* pOleWindow;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
    if (SUCCEEDED(hr))
    {
        hr = pOleWindow->GetWindow(phwnd);
        pOleWindow->Release();
    }
    return hr;
}

void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr)
{
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, cr);
    
    //top
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->top + 1;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //left
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->left + 1;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //right
    rc.left = prc->right - 1;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    // bottom
    rc.left = prc->left;
    rc.top = prc->bottom - 1;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    SetBkColor(hdc, clrSave);
}

STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl)
{
    ASSERT(pwb);
    ASSERT(pidl);

    VARIANT varThePidl;
    HRESULT hr = InitVariantFromIDList(&varThePidl, pidl);
    if (SUCCEEDED(hr))
    {
        hr = pwb->Navigate2(&varThePidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
        VariantClear(&varThePidl);       // Needed to free the copy of the PIDL in varThePidl.
    }
    return hr;
}

HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace)
{
    HRESULT hr;
    IWebBrowser2* pwb;

    if (fInPlace) 
    {
        ASSERT(ppwb && *ppwb != NULL);
        pwb = *ppwb;
        hr = S_OK;
    }
    else 
    {
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb));
    }
    
    if (SUCCEEDED(hr))
    {
        // Don't special case full-screen mode for channels post IE4.  Use the
        // browser's full screen setting.
        // 
        //BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Channels"),
        BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                                            TEXT("FullScreen"), FALSE, FALSE);
        pwb->put_TheaterMode( fTheater ? VARIANT_TRUE : VARIANT_FALSE);
        pwb->put_Visible(VARIANT_TRUE);


        if (!SHRestricted2(REST_NoChannelUI, NULL, 0))
        {
            SA_BSTRGUID  strGuid;
            VARIANT      vaGuid;

            InitFakeBSTR(&strGuid, CLSID_FavBand);

            vaGuid.vt = VT_BSTR;
            vaGuid.bstrVal = strGuid.wsz;

            pwb->ShowBrowserBar(&vaGuid, PVAREMPTY, PVAREMPTY);
        }
        
        // don't release, we're going to return pwb.
    }
    
    if (ppwb)
        *ppwb = pwb;
    else if (pwb)
        pwb->Release();
    
    return hr;
}

//
//  Just like TB_GETBUTTONSIZE except that theme borders are subtracted out.
//
LRESULT TB_GetButtonSizeWithoutThemeBorder(HWND hwndTB, HTHEME hThemeParent)
{
    LRESULT lButtonSize = SendMessage(hwndTB, TB_GETBUTTONSIZE, 0, 0L);
    if (hThemeParent)
    {
        HTHEME hTheme = OpenThemeData(hwndTB, L"Toolbar");
        if (hTheme)
        {
            RECT rc = { 0, 0, 0, 0 };
            if (SUCCEEDED(GetThemeBackgroundExtent(hTheme, NULL, TP_BUTTON, TS_NORMAL, &rc, &rc)))
            {
                lButtonSize = MAKELONG(LOWORD(lButtonSize) - RECTWIDTH(rc),
                                       HIWORD(lButtonSize) - RECTHEIGHT(rc));
            }
            CloseThemeData(hTheme);
        }
    }
    return lButtonSize;
}

#ifdef DEBUG

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg)
{
    ASSERT(IS_VALID_STRING_PTR(pszLabel, -1));
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYUP:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_KEYDOWN);
                STRING_CASE(WM_SYSKEYDOWN);
                STRING_CASE(WM_KEYUP);
                STRING_CASE(WM_SYSKEYUP);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            vk = %#04lx  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_CHAR);
                STRING_CASE(WM_SYSCHAR);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            char = '%c'  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_MOUSEMOVE:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MOUSEMOVE hwnd = %#08lx  x=%d  y=%d",
                 pszLabel, pmsg->hwnd, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
#endif
        break;

    case WM_TIMER:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
#endif
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        if (WM_USER > pmsg->message)
        {
            TraceMsg(TF_ALWAYS, "%s: msg = %#04lx    hwnd=%#04lx wP=%#08lx lP=%#08lx",
                     pszLabel, pmsg->message, pmsg->hwnd, pmsg->wParam, pmsg->lParam);
        }
        break;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\sftbar.h ===
#ifndef CSFTOOLBAR
#define CSFTOOLBAR

#include "bands.h"
#include "cwndproc.h"
#include "droptgt.h"
#include "CommonControls.h"

// Each CISFBand toolbar button lParam points to one of these.
class IBDATA
{
protected:

    DWORD        _dwFlags;      // Class specific flags
    BITBOOL      _fNoIcon:1;
    PORDERITEM   _poi;

public:
    IBDATA(PORDERITEM poi)                  { _poi = poi; }
    virtual ~IBDATA()                       { /* Don't Delete Me */ }

    LPITEMIDLIST GetPidl()                  { return _poi ? _poi->pidl : NULL; }
    void         SetOrderItem(PORDERITEM poi) { _poi = poi; }
    DWORD        GetFlags()                 { return _dwFlags; }
    void         SetFlags(DWORD dwFlags)    { _dwFlags = dwFlags; }
    BOOL         GetNoIcon()                { return _fNoIcon; }
    void         SetNoIcon(BOOL b)          { _fNoIcon = BOOLIFY(b); }
    PORDERITEM   GetOrderItem()             { return _poi ; }
};

typedef IBDATA * PIBDATA;

// Special HitTest results
#define IBHT_SOURCE         (-32768)
#define IBHT_BACKGROUND     (-32767)
#define IBHT_PAGER          (-32766)
#define IBHT_OUTSIDEWINDOW  (-32765)

// Flags for _OnFSNotifyAdd and _AddPidl
#define FSNA_BULKADD        0x0001  // This is a bulk add - don't recalc needlessly
#define FSNA_ADDDEFAULT     0x0002  // Add the item at the default position (overrides nIndex)

class CSFToolbar :  public IWinEventHandler,
                    public IShellChangeNotify, 
                    public CDelegateDropTarget, 
                    public IContextMenu, 
                    public IShellFolderBand,
                    public CNotifySubclassWndProc
{
public:
    // *** IUnknown methods (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** CDelegateDropTarget ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IContextMenu methods ***
    virtual STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    virtual STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // *** IShellFolderBand ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl) { return SetShellFolder(psf, pidl); };
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };

    // Toolbar Management
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    virtual void    EmptyToolbar();

protected:
    CSFToolbar();
    virtual    ~CSFToolbar();

    virtual    HRESULT _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);
    void    _DestroyToolbar();
    virtual void    _FillToolbar();
    void    _UnregisterToolbar();
    void    _RegisterToolbar();
    void    _RegisterChangeNotify();
    void    _UnregisterChangeNotify();      // Unregisters 

    void    _Refresh();
    void    _ReleaseShellFolder();

    virtual BOOL _AddPidl(LPITEMIDLIST pidl, DWORD dwFlags, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual PIBDATA _CreateItemData(PORDERITEM poi);
    virtual HWND GetHWNDForUIObject() { return _hwndTB; };
    virtual HRESULT _LoadOrderStream() { return E_NOTIMPL; };
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return FALSE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

    LPITEMIDLIST    _pidl;
    IShellFolder*    _psf;
    ITranslateShellChangeNotify*    _ptscn;

    HWND            _hwndPager;
    HWND            _hwndTB;
    HWND            _hwndToolTips;

    DWORD           _dwStyle;           // style bits to be ORd in when _hwndTB is created
    TBINSERTMARK    _tbim;
    int             _iDragSource;
    HDPA            _hdpaOrder;         // current order list (if non-default)
    HDPA            _hdpa;              // current set of items, mirrors _hwndTB content
    long            _lEvents;

    int             _iButtonCur;
    IContextMenu    *_pcmSF;
    IContextMenu2 * _pcm2;

    IImageList*     _piml;

    int             _nNextCommandID;
    int             _idCmdSF;
    int             _cxMin;
    int             _cxMax;
    HWND            _hwndDD;
    HWND            _hwndWorkerWindow;

    // Flags
    BITBOOL         _fNoShowText :1;    // TRUE iff no text with icon
    BITBOOL         _fShow :1;          // TRUE when ShowDW has happened
    BITBOOL         _fDirty :1;         // TRUE iff hidden contents modified
    BITBOOL         _fCheckIds :1;      // TRUE iff _GetCommandID has wrapped
    BITBOOL         _fFSNotify :1;      // TRUE to receive FS Notifications
    BITBOOL         _fFSNRegistered :1; // are we already registered?
    BITBOOL         _fAccelerators :1;  // whether to show & as accel or as &
    BITBOOL         _fAllowRename :1;   // TRUE to query _psf for IContextMenu of _pidl
    BITBOOL         _fDropping :1;      // TRUE while doing drop.
    BITBOOL         _fDropped :1;       // TRUE if we have reordered, _hdpaOrder may not have been created yet
    BITBOOL         _fNoNameSort :1;    // TRUE if band should _not_ sort icons by name
    BITBOOL         _fVariableWidth :1; 
    BITBOOL         _fNoIcons :1;       // turns off icons
    BITBOOL         _fVertical :1;      // TRUE: band is displayed vertically
    BITBOOL         _fMulticolumn : 1;
    BITBOOL         _fHasOrder: 1;
    BITBOOL         _fPSFBandDesktop :1;// TRUE iff _psfBand came from desktop
                                            //          this implies psfDesktop->BindToObject(_pidl)
                                            //          results in the correct ISF
    BITBOOL         _fRegisterChangeNotify: 1;  // TRUE: We will register for change notify.
    BITBOOL         _fAllowReorder: 1;
    BITBOOL         _fChangedOrder: 1;      // Only send change notifies if we actually changed the order
    UINT            _uIconSize : 2;     // Large/Small/Logo


    // Virtual Function Overrides for Window Subclass
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferredEffect);
    virtual void _OnToolTipsCreated(NMTOOLTIPSCREATED* pnm);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam) { return 0; };
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl, DWORD dwFlags, int nIndex);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    virtual void _OnFSNotifyUpdate(LPCITEMIDLIST pidl);
    virtual void _NotifyBulkOperation(BOOL fStart) { }
    virtual HRESULT _OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    
    // Helper Functions
    int     _GetCommandID();
    virtual void    _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    BOOL    _IsParentID(LPCITEMIDLIST pidl);
    BOOL    _IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate);
    BOOL    _IsEqualID(LPCITEMIDLIST pidl);
    LPVOID  _GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid);
    HMENU   _GetBaseContextMenu();
    HRESULT _GetTopBrowserWindow(HWND* phwnd);
    HRESULT _OnOpen(int id, BOOL fExplore);
    HRESULT _HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd);
    LRESULT _DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude);
    void _SortDPA(HDPA hdpa);
    virtual HWND CreateWorkerWindow();

    BOOL_PTR InlineDeleteButton(int iTBIndex);

    static INT_PTR CALLBACK _RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _OnRename(LPPOINT ppt, int id);
    UINT    _IndexToID(int iTBIndex);
    LPCITEMIDLIST _IDToPidl(UINT uiCmd, int *piPos = NULL);
    PIBDATA _IDToPibData(UINT uiCmd, int * piPos = NULL);
    void    _RememberOrder();
    void    _UpdateButtons();
    void    _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    HRESULT _GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex, LPITEMIDLIST *ppidlOut);
    DWORD   _GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs);
    BOOL    _UpdateShowText(BOOL fNoShowText);



    // Virtual Helper Functions
    virtual int     _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual void    _SetDirty(BOOL fDirty);
    virtual HMENU   _GetContextMenu();
    virtual BOOL    _UpdateIconSize(UINT uIconSize, BOOL fUpdateButton);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);
    virtual BOOL    _FilterPidl(LPCITEMIDLIST pidl);
    virtual int     _DefaultInsertIndex();
    virtual void    _ToolbarChanged() { };
    virtual void    _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _AfterLoad();
    virtual void    v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual void    _SetToolbarState();
    virtual void    v_NewItem(LPCITEMIDLIST pidl) {};
    virtual int     v_TBIndexToDPAIndex(int iTBIndex) { return iTBIndex; }
    virtual int     v_DPAIndexToTBIndex(int iIndex) { return iIndex; }

    static void s_NewItem(LPVOID pvParam, LPCITEMIDLIST pidl);
};

BOOL TBHasImage(HWND hwnd, int iImageIndex);
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\tbmenu.h ===
#ifndef CToolbarMenu_H
#define CToolbarMenu_H

#include "menuband.h"
#include "mnbase.h"
#include "cwndproc.h"

#define TF_TBMENU   0

class CToolbarMenu :    public CMenuToolbarBase,
                        public CNotifySubclassWndProc
                    
{

public:
    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj) { return CMenuToolbarBase::QueryInterface(riid, ppvObj); };

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

       virtual BOOL v_TrackingSubContextMenu() { return _fTrackingSubMenu; };
    
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate) ;
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) { return FALSE; };
    virtual void v_UpdateButtons(BOOL fNegotiateSize) ;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) {return E_FAIL;};
    virtual HRESULT v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam) ;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd) { return 0; };
    virtual void v_Close(); // override

    virtual int  v_GetDragOverButton() { ASSERT(0); return 0;};
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) {return E_NOTIMPL;};
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) {ASSERT(0); return E_NOTIMPL;};
    virtual void v_Refresh() {/*ASSERT(0);*/};
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) {};
    
    CToolbarMenu(DWORD dwFlags, HWND hwndTB);


protected:

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { return E_NOTIMPL;    }
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);


    virtual HRESULT CreateToolbar(HWND hwndParent);
    virtual void GetSize(SIZE* psize);

    void _CancelMenu();
    void _FillToolbar();

    HWND _hwndSubject;
    BITBOOL _fTrackingSubMenu:1;

    friend CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\menuband\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

int IsVK_TABCycler(MSG *pMsg);
HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl);
HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl);
HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl);
DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam);
void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr);
STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags);
STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd);
void OpenFolderPidl(LPCITEMIDLIST pidl);
ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
BOOL GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
STDAPI SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);


extern const VARIANT c_vaEmpty;
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace);
LRESULT TB_GetButtonSizeWithoutThemeBorder(HWND hwndTB, HTHEME hThemeParent);

extern const GUID CGID_PrivCITCommands;

// raymondc's futile attempt to reduce confusion
//
// EICH_KBLAH = a registry key named blah
// EICH_SBLAH = a win.ini section named blah

#define EICH_UNKNOWN        0xFFFFFFFF
#define EICH_KINET          0x00000002
#define EICH_KINETMAIN      0x00000004
#define EICH_KWIN           0x00000008
#define EICH_KWINPOLICY     0x00000010
#define EICH_KWINEXPLORER   0x00000020
#define EICH_SSAVETASKBAR   0x00000040
#define EICH_SWINDOWMETRICS 0x00000080
#define EICH_SPOLICY        0x00000100
#define EICH_SSHELLMENU     0x00000200
#define EICH_KWINEXPLSMICO  0x00000400
#define EICH_SWINDOWS       0x00000800

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sddebug.cpp ===
#include "precomp.h"
#pragma  hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shell32"
#define SZ_MODULE           "SHELL32"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\resource.h ===
// copied from shdocvw\resource.h
// values adjusted to not conflict with shell32\ids.h
//

// IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_NEXTCTL       (FCIDM_BROWSERFIRST + 0x30) // explorer browseui shell32

// IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDFILES     (FCIDM_BROWSERFIRST + 0x85)

// These numbers are for CShellDispatch (sdmain.cpp) to send
// messages to the tray.

//The following value is taken from  shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST+0x0060)
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)        
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)

#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_SELECTALL         (FCIDM_BROWSER_EDIT+0x0004)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut
#define FCIDM_EDITPAGE          (FCIDM_BROWSER_EDIT+0x0006)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdflditm.cpp ===
#include "precomp.h"
#include "prop.h" // For ParseSCIDString()
#pragma hdrstop

#define TF_SHELLAUTO TF_CUSTOM1

#define DEFINE_FLOAT_STUFF  // Do this because DATE is being used below

class CFolderItemVerbs;
class CEnumFolderItemVerbs;
class CFolderItemVerb;

class CFolderItemVerbs : public FolderItemVerbs,
                         public CObjectSafety,
                         protected CImpIDispatch,
                         protected CObjectWithSite
{
friend class CEnumFolderItemVerbs;
friend class CFolderItemVerb;

public:
    CFolderItemVerbs(IContextMenu *pcm);
    BOOL Init(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // FolderItemVerbs
    STDMETHODIMP        get_Application(IDispatch **ppid);
    STDMETHODIMP        get_Parent(IDispatch **ppid);
    STDMETHODIMP        get_Count(long *plCount);
    STDMETHODIMP        Item(VARIANT, FolderItemVerb**);
    STDMETHODIMP        _NewEnum(IUnknown **);

private:
    ~CFolderItemVerbs(void);
    HRESULT _SecurityCheck();
    LONG _cRef;
    HMENU _hmenu;
    IContextMenu *_pcm;
};

class CEnumFolderItemVerbs : public IEnumVARIANT,
                             public CObjectSafety
{
public:
    CEnumFolderItemVerbs(CFolderItemVerbs *psdfiv);
    BOOL Init();

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumFORMATETC
    STDMETHODIMP Next(ULONG, VARIANT *, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumVARIANT **);

private:
    ~CEnumFolderItemVerbs();
    LONG _cRef;
    int _iCur;
    CFolderItemVerbs *_psdfiv;
};

HRESULT CFolderItemVerb_Create(CFolderItemVerbs *psdfivs, UINT id, FolderItemVerb **pfiv);

class CFolderItemVerb : 
    public FolderItemVerb,
    public CObjectSafety,
    protected CImpIDispatch
{

friend class CFolderItemVerbs;

public:
    CFolderItemVerb(CFolderItemVerbs *psdfivs, UINT id);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // FolderItemVerb
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);
    STDMETHODIMP get_Name(BSTR *pbs);
    STDMETHODIMP DoIt();

private:
    ~CFolderItemVerb(void);

    LONG _cRef;
    CFolderItemVerbs *_psdfivs;
    UINT _id;
};


// in:
//      psdf    folder that contains pidl
//      pidl    pidl retlative to psdf (the item in this folder)

HRESULT CFolderItem_Create(CFolder *psdf, LPCITEMIDLIST pidl, FolderItem **ppid)
{
    *ppid = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CFolderItem* psdfi = new CFolderItem();
    if (psdfi)
    {
        hr = psdfi->Init(psdf, pidl);
        if (SUCCEEDED(hr))
            hr = psdfi->QueryInterface(IID_PPV_ARG(FolderItem, ppid));
        psdfi->Release();
    }
    return hr;
}

STDAPI CFolderItem_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;

    CFolderItem *pfi = new CFolderItem();
    if (pfi)
    {
        hr = pfi->QueryInterface(riid, ppv);
        pfi->Release();
    }

    return hr;
}

// in:
//      pidl    fully qualified pidl
//      hwnd    hacks

HRESULT CFolderItem_CreateFromIDList(HWND hwnd, LPCITEMIDLIST pidl, FolderItem **ppfi)
{
    LPITEMIDLIST pidlParent;
    HRESULT hr = SHILClone(pidl, &pidlParent);
    if (SUCCEEDED(hr))
    {
        ILRemoveLastID(pidlParent);

        CFolder *psdf;
        hr = CFolder_Create2(hwnd, pidlParent, NULL, &psdf);
        if (SUCCEEDED(hr))
        {
            hr = CFolderItem_Create(psdf, ILFindLastID(pidl), ppfi);
            psdf->Release();
        }
        ILFree(pidlParent);
    }
    return hr;
}

CFolderItem::CFolderItem() :
    _cRef(1), _psdf(NULL), _pidl(NULL),
    CImpIDispatch(SDSPATCH_TYPELIB, IID_FolderItem2)
{
    DllAddRef();
}


CFolderItem::~CFolderItem(void)
{
    if (_pidl)
        ILFree(_pidl);
    if (_psdf)
        _psdf->Release();
    DllRelease();
}

HRESULT GetItemFolder(CFolder *psdfRoot, LPCITEMIDLIST pidl, CFolder **ppsdf)
{
    HRESULT hr = S_OK;
    
    ASSERT(psdfRoot);
    
    if (ILFindLastID(pidl) != pidl)
    {
        LPITEMIDLIST pidlIn = ILClone(pidl);

        hr = E_OUTOFMEMORY;
        if (pidlIn && ILRemoveLastID(pidlIn))
        {
            LPITEMIDLIST pidlParent; 
            LPITEMIDLIST pidlFolder = NULL;
            
            hr = psdfRoot->GetCurFolder(&pidlFolder);
            if (SUCCEEDED(hr))
            {
                pidlParent = ILCombine(pidlFolder, pidlIn);
                if (pidlParent)
                {
                    hr = CFolder_Create2(NULL, pidlParent, NULL, ppsdf);
                    ILFree(pidlParent);
                }
                ILFree(pidlFolder);
            }
        }
        ILFree(pidlIn);// ilfree does null check
    }
    else
    {
        *ppsdf = psdfRoot;
        psdfRoot->AddRef();
    }
    return hr;
}

HRESULT CFolderItem::Init(CFolder *psdf, LPCITEMIDLIST pidl)
{    
    HRESULT hr = GetItemFolder(psdf, pidl, &_psdf);

    if (SUCCEEDED(hr))    
    {
        hr = SHILClone(ILFindLastID(pidl), &_pidl);
    }
    return hr;
}

STDMETHODIMP CFolderItem::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderItem, FolderItem2),
        QITABENTMULTI(CFolderItem, FolderItem, FolderItem2),
        QITABENTMULTI(CFolderItem, IDispatch, FolderItem2),
        QITABENTMULTI(CFolderItem, IPersist, IPersistFolder2),
        QITABENTMULTI(CFolderItem, IPersistFolder, IPersistFolder2),
        QITABENT(CFolderItem, IPersistFolder2),
        QITABENT(CFolderItem, IObjectSafety),
        QITABENT(CFolderItem, IParentAndItem),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && IsEqualGUID(CLSID_ShellFolderItem, riid))
    {
        *ppv = (CFolderItem *)this; // unrefed
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CFolderItem::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderItem::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//The FolderItem implementation
STDMETHODIMP CFolderItem::get_Application(IDispatch **ppid)
{
    // Let the folder object handle security and reference counting of site, etc
    return _psdf->get_Application(ppid);
}

STDMETHODIMP CFolderItem::get_Parent(IDispatch **ppid)
{
    // Assume that the Folder object is the parent of this object...
    HRESULT hr = _psdf->QueryInterface(IID_PPV_ARG(IDispatch, ppid));
    if (SUCCEEDED(hr) && _dwSafetyOptions)
        hr = MakeSafeForScripting((IUnknown**)ppid);
    return hr;
}

HRESULT CFolderItem::_ItemName(UINT dwFlags, BSTR *pbs)
{
    HRESULT hr;
    STRRET strret;
    if (SUCCEEDED(_psdf->_psf->GetDisplayNameOf(_pidl, dwFlags, &strret)))
    {
        hr = StrRetToBSTR(&strret, _pidl, pbs);
    }
    else
    {
        *pbs = SysAllocString(L"");
        hr = (*pbs) ? S_FALSE : E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_Name(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _ItemName(SHGDN_INFOLDER, pbs);
    }
    return hr;
}

STDMETHODIMP CFolderItem::put_Name(BSTR bs)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlOut;
        hr = _psdf->_psf->SetNameOf(_psdf->_hwnd, _pidl, bs, SHGDN_INFOLDER, &pidlOut);
        if (SUCCEEDED(hr))
        {
            ILFree(_pidl);
            _pidl = pidlOut;
        }
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_Path(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _ItemName(SHGDN_FORPARSING, pbs);
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_GetLink(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = CShortcut_CreateIDispatch(_psdf->_hwnd, _psdf->_psf, _pidl,  ppid);
        if (SUCCEEDED(hr) && _dwSafetyOptions)
        {
            hr = MakeSafeForScripting((IUnknown**)ppid);
        }
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_GetFolder(IDispatch **ppid)
{
    *ppid = NULL;

    // If in Safe mode we fail this one...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = SHILCombine(_psdf->_pidl, _pidl, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = CFolder_Create(NULL, pidl, NULL, IID_PPV_ARG(IDispatch, ppid));
            if (SUCCEEDED(hr))
            {
                if (_dwSafetyOptions)
                {
                    // note, this is created without a site so script safety checks will fail
                    hr = MakeSafeForScripting((IUnknown**)ppid);
                }
            }
            ILFree(pidl);
        }
    }
    return hr;
}


HRESULT CFolderItem::_CheckAttribute(ULONG ulAttrIn, VARIANT_BOOL * pb)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        ULONG ulAttr = ulAttrIn;
        hr = _psdf->_psf->GetAttributesOf(1, (LPCITEMIDLIST*)&_pidl, &ulAttr);
        *pb = (SUCCEEDED(hr) && (ulAttr & ulAttrIn)) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return hr;
}

HRESULT CFolderItem::_GetUIObjectOf(REFIID riid, void **ppv)
{
    return _psdf->_psf->GetUIObjectOf(_psdf->_hwnd, 1, (LPCITEMIDLIST*)&_pidl, riid, NULL, ppv);
}


HRESULT CFolderItem::_SecurityCheck()
{
    if (!_dwSafetyOptions)
        return S_OK;
    
    return _psdf->_SecurityCheck();
}

// allow friend classes to get the IDList for a CFolderItem automation object

LPCITEMIDLIST CFolderItem::_GetIDListFromVariant(const VARIANT *pv)
{
    LPCITEMIDLIST pidl = NULL;
    if (pv)
    {
        VARIANT v;

        if (pv->vt == (VT_BYREF | VT_VARIANT) && pv->pvarVal)
            v = *pv->pvarVal;
        else
            v = *pv;

        switch (v.vt)
        {
        case VT_DISPATCH | VT_BYREF:
            if (v.ppdispVal == NULL)
                break;

            v.pdispVal = *v.ppdispVal;

            // fall through...

        case VT_DISPATCH:
            CFolderItem *pfi;
            if (v.pdispVal && SUCCEEDED(v.pdispVal->QueryInterface(CLSID_ShellFolderItem, (void **)&pfi)))
            {
                pidl = pfi->_pidl; // alias
            }
            break;
        }
    }
    return pidl;
}


STDMETHODIMP CFolderItem::get_IsLink(VARIANT_BOOL * pb)
{
    return _CheckAttribute(SFGAO_LINK, pb);
}

STDMETHODIMP CFolderItem::get_IsFolder(VARIANT_BOOL * pb)
{
    return _CheckAttribute(SFGAO_FOLDER, pb);
}

STDMETHODIMP CFolderItem::get_IsFileSystem(VARIANT_BOOL * pb)
{
    return _CheckAttribute(SFGAO_FILESYSTEM, pb);
}

STDMETHODIMP CFolderItem::get_IsBrowsable(VARIANT_BOOL * pb)
{
    return _CheckAttribute(SFGAO_BROWSABLE, pb);
}

STDMETHODIMP CFolderItem::get_ModifyDate(DATE *pdt)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATA finddata;
        if (SUCCEEDED(SHGetDataFromIDList(_psdf->_psf, _pidl, SHGDFIL_FINDDATA, &finddata, sizeof(finddata))))
        {
            WORD wDosDate, wDosTime;
            FILETIME filetime;
            FileTimeToLocalFileTime(&finddata.ftLastWriteTime, &filetime);
            FileTimeToDosDateTime(&filetime, &wDosDate, &wDosTime);
            DosDateTimeToVariantTime(wDosDate, wDosTime, pdt);
        }
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CFolderItem::put_ModifyDate(DATE dt)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        SYSTEMTIME st;
        FILETIME ftLocal, ft;
        BSTR bstrPath;
    
        if (SUCCEEDED(VariantTimeToSystemTime(dt, &st)) && SystemTimeToFileTime(&st, &ftLocal)
                && LocalFileTimeToFileTime(&ftLocal, &ft) && SUCCEEDED(get_Path(&bstrPath)))
        {
            TCHAR szPath[MAX_PATH];
        
            SHUnicodeToTChar(bstrPath, szPath, ARRAYSIZE(szPath));
            SysFreeString(bstrPath);
            HANDLE hFile = CreateFile(szPath, GENERIC_READ | FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OPEN_NO_RECALL, NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (SetFileTime(hFile, NULL, NULL, &ft))
                {
                    hr = S_OK;
                }
                CloseHandle(hFile);
            }
        }
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_Size(LONG *pul)
{
    HRESULT hr =_SecurityCheck();
    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATA finddata;
        if (SUCCEEDED(SHGetDataFromIDList(_psdf->_psf, _pidl, SHGDFIL_FINDDATA, &finddata, sizeof(finddata))))
        {
            *pul = (LONG)finddata.nFileSizeLow;
        }
        else
        {
            *pul = 0L;
        }
        hr = S_OK; // Scripts don't like error return values
    }
    return hr;
}

STDMETHODIMP CFolderItem::get_Type(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_EMPTY;
        if (SUCCEEDED(ExtendedProperty(L"Type", &var)) && (var.vt == VT_BSTR))
        {
            *pbs = SysAllocString(var.bstrVal);
        }
        else
        {
            *pbs = SysAllocString(L"");
        }
        VariantClear(&var);
        hr = *pbs ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}


STDMETHODIMP CFolderItem::ExtendedProperty(BSTR bstrPropName, VARIANT* pvRet)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        VariantInit(pvRet);

        // currently, MCNL is 80, guidstr is 39, and 6 is the width of an int
        if (StrCmpIW(bstrPropName, L"infotip") == 0)
        {
            // They want the info tip for the item.
            if (_pidl && _psdf)
            {
                TCHAR szInfo[INFOTIPSIZE];
                GetInfoTipHelp(_psdf->_psf, _pidl, szInfo, ARRAYSIZE(szInfo));
                hr = InitVariantFromStr(pvRet, szInfo);
            }
        }
        else if (_psdf->_psf2)
        {
            SHCOLUMNID scid;
            TCHAR szTemp[128];

            SHUnicodeToTChar(bstrPropName, szTemp, ARRAYSIZE(szTemp));

            if (ParseSCIDString(szTemp, &scid, NULL))
            {
                // Note that GetDetailsEx expects an absolute pidl
                hr = _psdf->_psf2->GetDetailsEx(_pidl, &scid, pvRet);
            }
        }
        hr = FAILED(hr) ? S_FALSE : hr;   // Java scripts barf on error values
    }
    return hr;
}


STDMETHODIMP CFolderItem::Verbs(FolderItemVerbs **ppfic)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
    
        IContextMenu *pcm;
        if (SUCCEEDED(_GetUIObjectOf(IID_PPV_ARG(IContextMenu, &pcm))))
        {
            hr = CFolderItemVerbs_Create(pcm, ppfic);
            if (SUCCEEDED(hr) && _dwSafetyOptions)
            {
                hr = MakeSafeForScripting((IUnknown**)ppfic);
            
                if (SUCCEEDED(hr))
                {
                    // Set the folder's site to FolderItemVerbs
                    IUnknown_SetSite(*ppfic, _psdf->_punkSite);
                }
            }
            pcm->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFolderItem::InvokeVerbEx(VARIANT vVerb, VARIANT vArgs)
{
    // security check handled by _psdf
    return _psdf->InvokeVerbHelper(vVerb, vArgs, (LPCITEMIDLIST *)&_pidl, 1, _dwSafetyOptions);
}

STDMETHODIMP CFolderItem::InvokeVerb(VARIANT vVerb)
{
    VARIANT vtEmpty = {VT_EMPTY};
    return InvokeVerbEx(vVerb, vtEmpty);
}

STDMETHODIMP CFolderItem::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ShellFolderItem;
    return E_NOTIMPL;
}

// IPersistFolder
// note, this duplicates some of CFolderItem::Init() functionality

STDMETHODIMP CFolderItem::Initialize(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlParent;
    HRESULT hr = SHILClone(pidl, &pidlParent);
    if (SUCCEEDED(hr))
    {
        ASSERT(_pidl == NULL);
        hr = SHILClone(ILFindLastID(pidlParent), &_pidl);
        if (SUCCEEDED(hr))
        {
            // Chop off the filename and get the folder that contains
            // this FolderItem.
            ILRemoveLastID(pidlParent);

            ASSERT(_psdf == NULL);
            hr = CFolder_Create2(NULL, pidlParent, NULL, &_psdf);
        }
        ILFree(pidlParent);
    }
    return hr;
}

STDMETHODIMP CFolderItem::GetCurFolder(LPITEMIDLIST *ppidl)
{
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetIDListFromUnk(_psdf->_psf, &pidlFolder);
    if (S_OK == hr)
    {
        hr = SHILCombine(pidlFolder, _pidl, ppidl);
        ILFree(pidlFolder);
    }
    else
        hr = E_FAIL;
    return hr;
}

// IParentAndItem
STDMETHODIMP CFolderItem::SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolderItem::GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl)
{
    if (ppidlParent)
    {
        *ppidlParent = _psdf->_pidl ? ILClone(_psdf->_pidl) : NULL;
    }
    
    if (ppsf)
    {
        *ppsf = NULL;
        if (_psdf && _psdf->_psf)
            _psdf->_psf->QueryInterface(IID_PPV_ARG(IShellFolder, ppsf));
    }

    if (ppidl)
        *ppidl = ILClone(_pidl);


    if ((ppidlParent && !*ppidlParent)
    ||  (ppsf && !*ppsf)
    ||  (ppidl && !*ppidl))
    {
        //  this is failure
        //  but we dont know what failed
        if (ppsf && *ppsf)
            (*ppsf)->Release();
        if (ppidlParent)
            ILFree(*ppidlParent);
        if (ppidl)
            ILFree(*ppidl);

        return E_OUTOFMEMORY;
    }
            
    return S_OK;
}

HRESULT CFolderItemVerbs_Create(IContextMenu *pcm, FolderItemVerbs ** ppid)
{
    *ppid = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    CFolderItemVerbs* pfiv = new CFolderItemVerbs(pcm);
    if (pfiv)
    {
        if (pfiv->Init())
            hr = pfiv->QueryInterface(IID_PPV_ARG(FolderItemVerbs, ppid));
        pfiv->Release();
    }
    return hr;
}

CFolderItemVerbs::CFolderItemVerbs(IContextMenu *pcm) :
    _cRef(1), _hmenu(NULL),
    _pcm(pcm), CImpIDispatch(SDSPATCH_TYPELIB, IID_FolderItemVerbs)
{
    DllAddRef();
    _pcm->AddRef();
}

CFolderItemVerbs::~CFolderItemVerbs(void)
{
    DllRelease();

    if (_pcm)
        _pcm->Release();

    if (_hmenu)
        DestroyMenu(_hmenu);
}

BOOL CFolderItemVerbs::Init()
{
    TraceMsg(TF_SHELLAUTO, "CFolderItemVerbs::Init called");

    // Start of only doing default verb...
    if (_pcm)
    {
        _hmenu = CreatePopupMenu();
        if (FAILED(_pcm->QueryContextMenu(_hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, CMF_CANRENAME|CMF_NORMAL)))
            return FALSE;
    }
    else
        return FALSE;

    // Just for the heck of it, remove junk like sepearators from the menu...
    for (int i = GetMenuItemCount(_hmenu) - 1; i >= 0; i--)
    {
        MENUITEMINFO mii;
        TCHAR szText[80];    // should be big enough for this

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.dwTypeData = szText;
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.cch = ARRAYSIZE(szText);
        mii.fType = MFT_SEPARATOR;                // to avoid ramdom result.
        mii.dwItemData = 0;
        GetMenuItemInfo(_hmenu, i, TRUE, &mii);
        if (mii.fType & MFT_SEPARATOR)
            DeleteMenu(_hmenu, i, MF_BYPOSITION);
    }
    return TRUE;
}

STDMETHODIMP CFolderItemVerbs::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderItemVerbs, FolderItemVerbs),
        QITABENT(CFolderItemVerbs, IObjectSafety),
        QITABENTMULTI(CFolderItemVerbs, IDispatch, FolderItemVerbs),
        QITABENT(CFolderItemVerbs, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderItemVerbs::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderItemVerbs::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFolderItemVerbs::get_Application(IDispatch **ppid)
{
    *ppid = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CFolderItemVerbs::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    return E_NOTIMPL;
}


HRESULT CFolderItemVerbs::_SecurityCheck()
{
    return (!_dwSafetyOptions || (IsSafePage(_punkSite) == S_OK)) ? S_OK : E_ACCESSDENIED;
}


STDMETHODIMP CFolderItemVerbs::get_Count(long *plCount)
{
    *plCount = 0;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        *plCount = GetMenuItemCount(_hmenu);
    }
    return hr;
}

STDMETHODIMP CFolderItemVerbs::Item(VARIANT index, FolderItemVerb **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (index.vt == (VT_BYREF | VT_VARIANT) && index.pvarVal)
            index = *index.pvarVal;

        switch (index.vt)
        {
        case VT_ERROR:
            QueryInterface(IID_PPV_ARG(FolderItemVerb, ppid));
            break;

        case VT_I2:
            index.lVal = (long)index.iVal;
            // And fall through...

        case VT_I4:
            if ((index.lVal >= 0) && (index.lVal <= GetMenuItemCount(_hmenu)))
            {
                CFolderItemVerb_Create(this, GetMenuItemID(_hmenu, index.lVal), ppid);
            }

            break;

        default:
            hr = E_NOTIMPL;
        }

        if (*ppid && _dwSafetyOptions)
        {
            hr = MakeSafeForScripting((IUnknown**)ppid);
        }
        else if (hr != E_NOTIMPL)
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CFolderItemVerbs::_NewEnum(IUnknown **ppunk)
{
    *ppunk = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        CEnumFolderItemVerbs *pNew = new CEnumFolderItemVerbs(SAFECAST(this, CFolderItemVerbs*));
        if (pNew)
        {
            if (pNew->Init())
                hr = pNew->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
            pNew->Release();
        }
        if (SUCCEEDED(hr) && _dwSafetyOptions)
            hr = MakeSafeForScripting(ppunk);
    }
    return hr;
}

CEnumFolderItemVerbs::CEnumFolderItemVerbs(CFolderItemVerbs *pfiv) :
    _cRef(1), _iCur(0), _psdfiv(pfiv)
{
    _psdfiv->AddRef();
    DllAddRef();
}


CEnumFolderItemVerbs::~CEnumFolderItemVerbs(void)
{
    DllRelease();
    _psdfiv->Release();
}

BOOL CEnumFolderItemVerbs::Init()
{
    return TRUE;    // Currently no initialization needed
}

STDMETHODIMP CEnumFolderItemVerbs::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumFolderItemVerbs, IEnumVARIANT),
        QITABENT(CEnumFolderItemVerbs, IObjectSafety),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CEnumFolderItemVerbs::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CEnumFolderItemVerbs::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CEnumFolderItemVerbs::Next(ULONG cVar, VARIANT *pVar, ULONG *pulVar)
{
    ULONG cReturn = 0;
    HRESULT hr;

    if (!pulVar)
    {
        if (cVar != 1)
            return E_POINTER;
    }
    else
        *pulVar = 0;

    if (!pVar || _iCur >= GetMenuItemCount(_psdfiv->_hmenu))
        return S_FALSE;

    while (_iCur < GetMenuItemCount(_psdfiv->_hmenu) && cVar > 0)
    {
	    FolderItemVerb *pidv;
        hr = CFolderItemVerb_Create(_psdfiv, GetMenuItemID(_psdfiv->_hmenu, _iCur), &pidv);

        if (SUCCEEDED(hr) && _dwSafetyOptions)
            hr = MakeSafeForScripting((IUnknown**)&pidv);

        _iCur++;
        if (SUCCEEDED(hr))
        {
            pVar->pdispVal = pidv;
            pVar->vt = VT_DISPATCH;
            pVar++;
            cReturn++;
            cVar--;
        }
    }

    if (pulVar)
        *pulVar = cReturn;

    return S_OK;
}

STDMETHODIMP CEnumFolderItemVerbs::Skip(ULONG cSkip)
{
    if ((int)(_iCur + cSkip) >= GetMenuItemCount(_psdfiv->_hmenu))
        return S_FALSE;

    _iCur += cSkip;
    return S_OK;
}

STDMETHODIMP CEnumFolderItemVerbs::Reset(void)
{
    _iCur = 0;
    return S_OK;
}

STDMETHODIMP CEnumFolderItemVerbs::Clone(IEnumVARIANT **ppEnum)
{
    *ppEnum = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CEnumFolderItemVerbs *pNew = new CEnumFolderItemVerbs(_psdfiv);
    if (pNew)
    {
        if (pNew->Init())
            hr = pNew->QueryInterface(IID_PPV_ARG(IEnumVARIANT, ppEnum));
        pNew->Release();
    }

    if (SUCCEEDED(hr) && _dwSafetyOptions)
        hr = MakeSafeForScripting((IUnknown**)ppEnum);

    return hr;
}

HRESULT CFolderItemVerb_Create(CFolderItemVerbs *psdfivs, UINT id, FolderItemVerb **ppid)
{
    *ppid = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CFolderItemVerb* psdfiv = new CFolderItemVerb(psdfivs, id);
    if (psdfiv)
    {
        hr = psdfiv->QueryInterface(IID_PPV_ARG(FolderItemVerb, ppid));
        psdfiv->Release();
    }

    return hr;
}

CFolderItemVerb::CFolderItemVerb(CFolderItemVerbs *psdfivs, UINT id) :
    _cRef(1), _psdfivs(psdfivs), _id(id),
    CImpIDispatch(SDSPATCH_TYPELIB, IID_FolderItemVerb)
{
    _psdfivs->AddRef();
    DllAddRef();
}

CFolderItemVerb::~CFolderItemVerb(void)
{
    DllRelease();
    _psdfivs->Release();
}

STDMETHODIMP CFolderItemVerb::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderItemVerb, FolderItemVerb),
        QITABENT(CFolderItemVerb, IObjectSafety),
        QITABENTMULTI(CFolderItemVerb, IDispatch, FolderItemVerb),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderItemVerb::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderItemVerb::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CFolderItemVerb::get_Application(IDispatch **ppid)
{
    // _psdfivs returns E_NOTIMPL
    return _psdfivs->get_Application(ppid);
}

STDMETHODIMP CFolderItemVerb::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    return E_NOTIMPL;
}


STDMETHODIMP CFolderItemVerb::get_Name(BSTR *pbs)
{
    TCHAR szMenuText[MAX_PATH];
    // Warning: did not check security here as could not get here if unsafe...
    GetMenuString(_psdfivs->_hmenu, _id, szMenuText, ARRAYSIZE(szMenuText), MF_BYCOMMAND);
    *pbs = SysAllocStringT(szMenuText);

    return *pbs ? S_OK : E_OUTOFMEMORY;
}


STDMETHODIMP CFolderItemVerb::DoIt()
{
    CMINVOKECOMMANDINFO ici = {
        sizeof(CMINVOKECOMMANDINFO),
        0L,
        NULL,
        NULL,
        NULL, NULL,
        SW_SHOWNORMAL,
    };
    // Warning: did not check security here as could not get here if unsafe...
    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(_id - CONTEXTMENU_IDCMD_FIRST);
    return _psdfivs->_pcm->InvokeCommand(&ici);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\precomp.h ===
#undef WINVER
#define WINVER 0x0400

#define _SHELL32_

#include <windows.h>
#include <ole2.h>
#include <shlguid.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include <shlobj.h>
#include <shlobjp.h>
#undef SHGetDataFromIDListW
#undef SHCreatePropertyBag

STDAPI SHGetDataFromIDListW(IShellFolder *psf, LPCITEMIDLIST pidl, int nFormat, void *pv, int cb);
STDAPI SHCreatePropertyBag(REFIID riid, void **ppv);

#include <objsafe.h>
#include <mshtmdid.h>
#include <mshtml.h>
#include <comcat.h>
#include <wininet.h>

#include "debug.h"

#include "ccstock.h"
#include "cobjsafe.h"
#include "cowsite.h"
#include "dspsprt.h"
#include "expdsprt.h"
#include "resource.h"
#include "sdspatch.h"
#include "shdguid.h"    // IID_IShellService
#include "shellp.h"
#include "shguidp.h"    // IID_IExpDispSupport
#include "ieguidp.h"
#include "shsemip.h"    // SHRunControlPanel
#include "varutil.h"

#define BOOL_PTR            INT_PTR

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

// these don't do anything since shell32 does not support unload, but use this
// for code consistency with dlls that do support this
#define DllAddRef()
#define DllRelease()

EXTERN_C BOOL g_bBiDiPlatform;
STDAPI IsSafePage(IUnknown *punkSite);
STDAPI_(LONG) GetOfflineShareStatus(LPCTSTR pcszPath);
STDAPI_(BOOL) NT5_GlobalMemoryStatusEx(LPMEMORYSTATUSEX pmsex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdfldits.cpp ===
#include "precomp.h"
#include "shconv.h"
#pragma hdrstop


class CEnumFolderItems;

class CFolderItems : public FolderItems3,
                     public IPersistFolder,
                     public CObjectSafety,
                     public CObjectWithSite,
                     protected CImpIDispatch
{
    friend CEnumFolderItems;

public:
    CFolderItems(CFolder *psdf, BOOL fSelected);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // FolderItems
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent (IDispatch **ppid);
    STDMETHODIMP get_Count(long *pCount);
    STDMETHODIMP Item(VARIANT, FolderItem**);
    STDMETHODIMP _NewEnum(IUnknown **);

    // FolderItems2
    STDMETHODIMP InvokeVerbEx(VARIANT vVerb, VARIANT vArgs);

    // FolderItems3
    STDMETHODIMP Filter(long grfFlags, BSTR bstrFilter);
    STDMETHODIMP get_Verbs(FolderItemVerbs **ppfic);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

protected:
    HDPA _GetHDPA();
    UINT _GetHDPACount();
    BOOL_PTR _CopyItem(UINT iItem, LPCITEMIDLIST pidl);

    LONG _cRef;
    CFolder *_psdf;
    HDPA _hdpa;
    BOOL _fSelected;
    BOOL _fGotAllItems;
    IEnumIDList *_penum;
    UINT _cNumEnumed;
    LONG _grfFlags;
    LPTSTR _pszFileSpec;

    HRESULT _SecurityCheck();
    void _ResetIDListArray();
    virtual ~CFolderItems(void);
    BOOL _IncludeItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    virtual HRESULT _EnsureItem(UINT iItemNeeded, LPCITEMIDLIST *ppidl);
    STDMETHODIMP _GetUIObjectOf(REFIID riid, void ** ppv);
};

// CFolderItemsF(rom)D(ifferent)F(olders)
class CFolderItemsFDF : public CFolderItems,
                        public IInsertItem
{
public:
    // TODO: add callback pointer to constructor
    CFolderItemsFDF(CFolder *psdf);

    // IUnknown override
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)(void) {return CFolderItems::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CFolderItems::Release();};

    // IInsertItem
    STDMETHOD(InsertItem)(LPCITEMIDLIST pidl);
protected:
    virtual HRESULT _EnsureItem(UINT iItemNeeded, LPCITEMIDLIST *ppidl);
};

//Enumerator of whatever is held in the collection
class CEnumFolderItems : public IEnumVARIANT
{
public:
    CEnumFolderItems(CFolderItems *pfdritms);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumFORMATETC
    STDMETHODIMP Next(ULONG, VARIANT *, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumVARIANT **);

private:
    ~CEnumFolderItems();

    LONG _cRef;
    CFolderItems *_pfdritms;
    UINT _iCur;
};

HRESULT CFolderItems_Create(CFolder *psdf, BOOL fSelected, FolderItems **ppitems)
{
    *ppitems = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    CFolderItems* psdfi = new CFolderItems(psdf, fSelected);
    if (psdfi)
    {
        hr = psdfi->QueryInterface(IID_PPV_ARG(FolderItems, ppitems));
        psdfi->Release();
    }
    return hr;
}

CFolderItems::CFolderItems(CFolder *psdf, BOOL fSelected) :
    _cRef(1), 
    _psdf(psdf), 
    _fSelected(fSelected),
    _grfFlags(SHCONTF_FOLDERS | SHCONTF_NONFOLDERS),
    CImpIDispatch(SDSPATCH_TYPELIB, IID_FolderItems3)
{
    DllAddRef();

    if (_psdf)
        _psdf->AddRef();

    ASSERT(_hdpa == NULL);
    ASSERT(_pszFileSpec == NULL);
}

HRESULT CFolderItems::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_FolderItemsFDF;
    return S_OK;
}

HRESULT CFolderItems::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(_psdf == NULL);
    return CFolder_Create2(NULL, pidl, NULL, &_psdf);
}

int FreePidlCallBack(void *pv, void *)
{
    ILFree((LPITEMIDLIST)pv);
    return 1;
}

HRESULT CFolderItems::_SecurityCheck()
{
    if (!_dwSafetyOptions)
        return S_OK;
    
    return _psdf->_SecurityCheck();
}

void CFolderItems::_ResetIDListArray(void)
{
    // destory the DPA, and lets reset the counters and pointers

    if (_hdpa)
    {
        DPA_DestroyCallback(_hdpa, FreePidlCallBack, 0);
        _hdpa = NULL;
    }

    _fGotAllItems = FALSE;
    _cNumEnumed = 0;

    ATOMICRELEASE(_penum);  // may be NULL
}

CFolderItems::~CFolderItems(void)
{
    _ResetIDListArray();
    Str_SetPtr(&_pszFileSpec, NULL);

    if (_psdf)
        _psdf->Release();

    DllRelease();
}

HDPA CFolderItems::_GetHDPA()
{
    if (NULL == _hdpa)
        _hdpa = ::DPA_Create(0);
    return _hdpa;
}

UINT CFolderItems::_GetHDPACount()
{
    UINT count = 0;
    HDPA hdpa = _GetHDPA();
    if (hdpa)
        count = DPA_GetPtrCount(hdpa);
    return count;
}

BOOL_PTR CFolderItems::_CopyItem(UINT iItem, LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlT = ILClone(pidl);
    if (pidlT)
    {
        if ( -1 == ::DPA_InsertPtr(_hdpa, iItem, pidlT) )
        {
            ILFree(pidlT);
            pidlT = NULL;   // failure
        }
    }
    return (BOOL_PTR)pidlT;
}


// check the item name against the file spec and see if we should include it

BOOL CFolderItems::_IncludeItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL fInclude = TRUE;       // by default include it...

    if ( _pszFileSpec )
    {
        // see if we can resolve the link on this object

        LPITEMIDLIST pidlFromLink = NULL;    
        IShellLink *psl;

        if ( SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_IShellLink, NULL, (void **)&psl)) )
        {
            psl->GetIDList(&pidlFromLink);
            psl->Release();
            pidl = pidlFromLink;
        }

        // then apply the file spec

        TCHAR szName[MAX_PATH];
        SHGetNameAndFlags(pidl, SHGDN_INFOLDER|SHGDN_FORPARSING, szName, ARRAYSIZE(szName), NULL); 
        fInclude = PathMatchSpec(szName, _pszFileSpec);

        ILFree(pidlFromLink);
    }

    return fInclude;
}


// in:
//      iItemNeeded     zero based index
//          
//
// returns:
//      S_OK        in range value
//      S_FALSE     out of range value
//

HRESULT CFolderItems::_EnsureItem(UINT iItemNeeded, LPCITEMIDLIST *ppidlItem)
{
    HRESULT hr = S_FALSE;   // assume out of range

    if (_GetHDPA())
    {
        LPCITEMIDLIST pidl = (LPCITEMIDLIST)DPA_GetPtr(_hdpa, iItemNeeded);
        if (pidl)
        {
            if (ppidlItem)
                *ppidlItem = pidl;
            hr = S_OK;
        }
        else if (!_fGotAllItems)
        {
            IShellFolderView *psfv;
            if (SUCCEEDED(_psdf->GetShellFolderView(&psfv)))
            {
                if (_fSelected)
                {
                    // we can only request the entire selection, therefore
                    // do so and populate our array with those.

                    UINT cItems;
                    LPCITEMIDLIST *ppidl = NULL;
                    if (SUCCEEDED(psfv->GetSelectedObjects(&ppidl, &cItems)) && ppidl)
                    {
                        for (UINT i = 0; i < cItems; i++)
                            _CopyItem(i, ppidl[i]);

                        LocalFree(ppidl);
                    }
                    _fGotAllItems = TRUE;
                    hr = _EnsureItem(iItemNeeded, ppidlItem);
                }
                else
                {
                    UINT cItems;
                    if (SUCCEEDED(psfv->GetObjectCount(&cItems)))
                    {
                        // if there is no file spec then we can just request the item
                        // that we want, otherwise we must collect them all 
                        // from the view.

                        if (iItemNeeded < cItems)
                        {
                            LPCITEMIDLIST pidl;
                            if (SUCCEEDED(GetObjectSafely(psfv, &pidl, iItemNeeded)))
                            {
                                if (_CopyItem(iItemNeeded, pidl))
                                {
                                    hr = _EnsureItem(iItemNeeded, ppidlItem);
                                }
                            }
                        }
                    }
                }
                psfv->Release();
            }
            else
            {
                // we don't have an enumerator, so lets request it

                if (NULL == _penum)
                    _psdf->_psf->EnumObjects(NULL, _grfFlags, &_penum);

                if (NULL == _penum)
                {
                    _fGotAllItems = TRUE;   // enum empty, we are done
                }
                else 
                {
                    // get more while our count is less than the index
                    while (_cNumEnumed <= iItemNeeded)
                    {
                        LPITEMIDLIST pidl;
                        if (S_OK == _penum->Next(1, &pidl, NULL))
                        {
                            if ( _IncludeItem(_psdf->_psf, pidl) && 
                                    (-1 != ::DPA_AppendPtr(_hdpa, pidl)) )
                            {
                                _cNumEnumed++;
                            }
                            else
                            {
                                ILFree(pidl);
                            }
                        }
                        else
                        {
                            ATOMICRELEASE(_penum);
                            _fGotAllItems = TRUE;
                            break;
                        }
                    }
                }
                hr = _EnsureItem(iItemNeeded, ppidlItem);
            }
        }
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CFolderItems::QueryInterface(REFIID riid, void ** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderItems, FolderItems3),
        QITABENTMULTI(CFolderItems, FolderItems, FolderItems3),
        QITABENTMULTI(CFolderItems, IDispatch, FolderItems3),
        QITABENT(CFolderItems, IObjectSafety),
        QITABENT(CFolderItems, IPersistFolder),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderItems::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderItems::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// FolderItems implementation

STDMETHODIMP CFolderItems::get_Application(IDispatch **ppid)
{
    // let the folder object do the work...
    return _psdf->get_Application(ppid);
}

STDMETHODIMP CFolderItems::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CFolderItems::get_Count(long *pCount)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        IShellFolderView *psfv = NULL;

        // get the items from the view, we can do this if we don't have
        // a spec.

        if ( !_pszFileSpec )
        {
            hr = _psdf->GetShellFolderView(&psfv);
            if (SUCCEEDED(hr))
            {
                UINT cCount;
                hr = _fSelected ? psfv->GetSelectedCount(&cCount) : psfv->GetObjectCount(&cCount);
                *pCount = cCount;
                psfv->Release();
            }
        }

        // either we failed to get to the view, or the file spec won't allow us
    
        if ( _pszFileSpec || FAILED(hr) )
        {
            // Well it looks like we need to finish the iteration now to get this!
            *pCount = SUCCEEDED(_EnsureItem(-1, NULL)) ? _GetHDPACount() : 0;
            hr = S_OK;
        }
    }
    return hr;
}

// Folder.Items.Item(1)
// Folder.Items.Item("file name")
// Folder.Items.Item()      - same as Folder.Self

STDMETHODIMP CFolderItems::Item(VARIANT index, FolderItem **ppid)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        *ppid = NULL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (index.vt == (VT_BYREF | VT_VARIANT) && index.pvarVal)
            index = *index.pvarVal;

        switch (index.vt)
        {
        case VT_ERROR:
            {
                // No Parameters, generate a folder item for the folder itself...
                Folder * psdfParent;
                hr = _psdf->get_ParentFolder(&psdfParent);
                if (SUCCEEDED(hr) && psdfParent)
                {
                    hr = CFolderItem_Create((CFolder*)psdfParent, ILFindLastID(_psdf->_pidl), ppid);
                    psdfParent->Release();
                }
            }
            break;

        case VT_I2:
            index.lVal = (long)index.iVal;
            // And fall through...

        case VT_I4:
            {
                LPCITEMIDLIST pidl;
                hr = _EnsureItem(index.lVal, &pidl);      // Get the asked for item...
                if (S_OK == hr)
                    hr = CFolderItem_Create(_psdf, pidl, ppid);
            }
            break;

        case VT_BSTR:
            {
                LPITEMIDLIST pidl;
                hr = _psdf->_psf->ParseDisplayName(NULL, NULL, index.bstrVal, NULL, &pidl, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = CFolderItem_Create(_psdf, pidl, ppid);
                    ILFree(pidl);
                }
            }
            break;

        default:
            return E_NOTIMPL;
        }

        if (hr != S_OK)   // Error values cause problems in Java script
        {
            *ppid = NULL;
            hr = S_FALSE;
        }
        else if (ppid && _dwSafetyOptions)
        {
            hr = MakeSafeForScripting((IUnknown**)ppid);
        }
    }
    return hr;
}

STDMETHODIMP CFolderItems::InvokeVerbEx(VARIANT vVerb, VARIANT vArgs)
{
    long cItems;
    // Note: if not safe, we'll fail in get_Count with E_ACCESSDENIED
    HRESULT hr = get_Count(&cItems);
    if (SUCCEEDED(hr) && cItems)
    {
        LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, SIZEOF(*ppidl) * cItems);
        if (ppidl)
        {
            for (int i = 0; i < cItems; i++)
            {
                _EnsureItem(i, &ppidl[i]);
            }

            hr = _psdf->InvokeVerbHelper(vVerb, vArgs, ppidl, cItems, _dwSafetyOptions);

            LocalFree(ppidl);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


//
// fIncludeFolders => includ folders in the enumeration (TRUE by default)
// bstrFilter = filespec to apply while enumerating
//

STDMETHODIMP CFolderItems::Filter(LONG grfFlags, BSTR bstrFileSpec)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        _grfFlags = grfFlags;
        Str_SetPtr(&_pszFileSpec, bstrFileSpec);
        _ResetIDListArray();
    }
    return hr;
}

STDMETHODIMP CFolderItems::_GetUIObjectOf(REFIID riid, void ** ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;
    
    long cItems;
    if (SUCCEEDED(get_Count(&cItems)) && cItems)
    {
        LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, SIZEOF(*ppidl) * cItems);
        if (ppidl)
        {
            for (int i = 0; i < cItems; i++)
            {
                _EnsureItem(i, &ppidl[i]);
            }

            hr = _psdf->_psf->GetUIObjectOf(_psdf->_hwnd, cItems, ppidl, riid, NULL, ppv);

            LocalFree(ppidl);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFolderItems::get_Verbs(FolderItemVerbs **ppfic)
{
    *ppfic = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
    
        IContextMenu *pcm;
        if (SUCCEEDED(_GetUIObjectOf(IID_PPV_ARG(IContextMenu, &pcm))))
        {
            hr = CFolderItemVerbs_Create(pcm, ppfic);
            if (SUCCEEDED(hr) && _dwSafetyOptions)
            {
                hr = MakeSafeForScripting((IUnknown**)ppfic);
            
                if (SUCCEEDED(hr))
                {
                    // Set the folder's site to FolderItemVerbs
                    IUnknown_SetSite(*ppfic, _psdf->_punkSite);
                }
            }
            pcm->Release();
        }
    }
    return hr;
}

// supports VB "For Each" statement

STDMETHODIMP CFolderItems::_NewEnum(IUnknown **ppunk)
{
    *ppunk = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        CEnumFolderItems *pNew = new CEnumFolderItems(this);
        if (pNew)
        {
            hr = pNew->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
            pNew->Release();

            if (SUCCEEDED(hr) && _dwSafetyOptions)
            {
                hr = MakeSafeForScripting(ppunk);
            }
        }
    }
    return hr;
}

STDAPI CFolderItemsFDF_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppv = NULL;

    CFolderItemsFDF *pfi = new CFolderItemsFDF(NULL);
    if (pfi)
    {
        hr = pfi->QueryInterface(riid, ppv);
        pfi->Release();
    }

    return hr;
}

CFolderItemsFDF::CFolderItemsFDF(CFolder *psdf) : CFolderItems(psdf, FALSE)
{
}

HRESULT CFolderItemsFDF::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr = CFolderItems::QueryInterface(riid, ppv);

    if (FAILED(hr))
    {
        static const QITAB qit[] = {
            QITABENT(CFolderItemsFDF, IInsertItem),
            { 0 },
        };
    
        hr = QISearch(this, qit, riid, ppv);
    }
    return hr;
}

HRESULT CFolderItemsFDF::InsertItem(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;

    if (_GetHDPA())
    {
        LPITEMIDLIST pidlTemp;
        
        hr = SHILClone(pidl, &pidlTemp);
        if (SUCCEEDED(hr))
        {
            if (DPA_AppendPtr(_hdpa, pidlTemp) == -1)
            {
                ILFree(pidlTemp);
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

HRESULT CFolderItemsFDF::_EnsureItem(UINT iItemNeeded, LPCITEMIDLIST *ppidlItem)
{
    HRESULT hr = S_FALSE;   // assume out of range

    if (ppidlItem)
        *ppidlItem = NULL;

    if (_GetHDPA())
    {
        LPCITEMIDLIST pidl = (LPCITEMIDLIST)DPA_GetPtr(_hdpa, iItemNeeded);
        if (pidl)
        {
            if (ppidlItem)
                *ppidlItem = pidl;
            hr = S_OK;
        }
    }
    return hr;
}

// CEnumFolderItems implementation of IEnumVARIANT

CEnumFolderItems::CEnumFolderItems(CFolderItems *pfdritms) :
    _cRef(1), 
    _pfdritms(pfdritms), 
    _iCur(0)
{
    _pfdritms->AddRef();
    DllAddRef();
}


CEnumFolderItems::~CEnumFolderItems(void)
{
    _pfdritms->Release();
    DllRelease();
}

STDMETHODIMP CEnumFolderItems::QueryInterface(REFIID riid, void ** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumFolderItems, IEnumVARIANT),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG) CEnumFolderItems::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CEnumFolderItems::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CEnumFolderItems::Next(ULONG cVar, VARIANT *pVar, ULONG *pulVar)
{
    ULONG cReturn = 0;
    HRESULT hr = S_OK;

    if (!pulVar && (cVar != 1))
        return E_POINTER;

    while (cVar)
    {
        LPCITEMIDLIST pidl;
        
        if (S_OK == _pfdritms->_EnsureItem(_iCur + cVar - 1, &pidl))
        {
            FolderItem *pid;

            hr = CFolderItem_Create(_pfdritms->_psdf, pidl, &pid);
            _iCur++;

            if (_pfdritms->_dwSafetyOptions && SUCCEEDED(hr))
                hr = MakeSafeForScripting((IUnknown**)&pid);

            if (SUCCEEDED(hr))
            {
                pVar->pdispVal = pid;
                pVar->vt = VT_DISPATCH;
                pVar++;
                cReturn++;
                cVar--;
            }
            else
                break;
        }
        else
            break;
    }

    if (SUCCEEDED(hr))
    {
        if (pulVar)
            *pulVar = cReturn;
        hr = cReturn ? S_OK : S_FALSE;
    }

    return hr;
}

STDMETHODIMP CEnumFolderItems::Skip(ULONG cSkip)
{
    if ((_iCur + cSkip) >= _pfdritms->_GetHDPACount())
        return S_FALSE;

    _iCur += cSkip;
    return NOERROR;
}

STDMETHODIMP CEnumFolderItems::Reset(void)
{
    _iCur = 0;
    return NOERROR;
}

STDMETHODIMP CEnumFolderItems::Clone(IEnumVARIANT **ppenum)
{
    *ppenum = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    CEnumFolderItems *pNew = new CEnumFolderItems(_pfdritms);
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_PPV_ARG(IEnumVARIANT, ppenum));
        pNew->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdfolder.cpp ===
#include "precomp.h"
#pragma hdrstop

#include <dobjutil.h>
#include <regstr.h>
#include <strsafe.h>
#include "cputil.h"
#include <strsafe.h>

#define REGSTR_EXPLORER_ADVANCED (REGSTR_PATH_EXPLORER TEXT("\\Advanced"))

HRESULT CFolder_Create2(HWND hwnd, LPCITEMIDLIST pidl, IShellFolder *psf, CFolder **ppsdf)
{
    HRESULT hr;
    CFolder *psdf = new CFolder(hwnd);
    if (psdf)
    {
        hr = psdf->Init(pidl, psf);
        if (SUCCEEDED(hr))
            *ppsdf = psdf;
        else
        {
            psdf->Release();
            psdf = NULL;
        }
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CFolder_Create(HWND hwnd, LPCITEMIDLIST pidl, IShellFolder *psf, REFIID riid, void **ppv)
{
    *ppv = NULL;

    CFolder *psdf;
    HRESULT hr = CFolder_Create2(hwnd, pidl, psf, &psdf);
    if (SUCCEEDED(hr))
    {
        hr = psdf->QueryInterface(riid, ppv);
        psdf->Release();
    }
    return hr;
}

// HRESULT CFolder_Create(HWND hwnd, LPITEMIDLIST pidl, IShellFolder *psf, CFolder **ppsdf)

CFolder::CFolder(HWND hwnd) :
    _cRef(1), _hwnd(hwnd), _pidl(NULL), _psf(NULL), _psf2(NULL),
    CImpIDispatch(SDSPATCH_TYPELIB, IID_Folder3)
{
    _fmt = 0;

    // Be sure that the OS is supporting the flags DATE_LTRREADING and DATE_RTLREADING
    if (g_bBiDiPlatform)
    {
        // Get the date format reading order
        LCID locale = GetUserDefaultLCID();
        if (   (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC))
        {
            //Get the real list view windows ExStyle.
            // [msadek]; we shouldn't check for either WS_EX_RTLREADING OR RTL_MIRRORED_WINDOW
            // on localized builds we have both of them to display dirve letters,..etc correctly
            // on enabled builds we have none of them. let's check on RTL_MIRRORED_WINDOW only
            
            DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);
            if (dwExStyle & RTL_MIRRORED_WINDOW)
                _fmt = LVCFMT_RIGHT_TO_LEFT;
            else
                _fmt = LVCFMT_LEFT_TO_RIGHT;
        }
    }

    DllAddRef();
}

CFolder::~CFolder(void)
{
    ATOMICRELEASE(_psd);
    ATOMICRELEASE(_psf2);
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_punkOwner);

    if (_pidl)
        ILFree(_pidl);

    // If we created an Application object release its site object...
    if (_pidApp)
    {
        IUnknown_SetSite(SAFECAST(_pidApp, IUnknown*), NULL);
        _pidApp->Release();
    }

    DllRelease();
}

STDMETHODIMP CFolder::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(SAFECAST(_pidApp, IUnknown*), punkSite);
    return CObjectWithSite::SetSite(punkSite);
}

STDMETHODIMP CFolder::SetOwner(IUnknown* punkOwner)
{
    IUnknown_Set(&_punkOwner, punkOwner);
    return S_OK;
}

HRESULT CFolder::Init(LPCITEMIDLIST pidl, IShellFolder *psf)
{
    HRESULT hr = SHILClone(pidl, &_pidl);
    if (SUCCEEDED(hr))
    {
        _psf = psf;
        if (_psf)
            _psf->AddRef();
        else
            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, _pidl, &_psf));
        if (_psf)
            _psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf2));
    }
    return hr;
}

STDMETHODIMP CFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolder, Folder3),
        QITABENTMULTI(CFolder, Folder, Folder3),
        QITABENTMULTI(CFolder, Folder2, Folder3),
        QITABENTMULTI(CFolder, IDispatch, Folder3),
        QITABENTMULTI(CFolder, IPersist, IPersistFolder2),
        QITABENTMULTI(CFolder, IPersistFolder, IPersistFolder2),
        QITABENT(CFolder, IPersistFolder2),
        QITABENT(CFolder, IObjectSafety),
        QITABENT(CFolder, IObjectWithSite),
        QITABENT(CFolder, IShellService),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolder::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolder::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFolder::_Application(IDispatch **ppid)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = CShellDispatch_CreateInstance(NULL, IID_PPV_ARG(IDispatch, ppid));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(*ppid, _punkSite);

            if (_dwSafetyOptions)
                hr = MakeSafeForScripting((IUnknown**)ppid);
        }
    }
    return hr;
}

// Folder implementation
STDMETHODIMP CFolder::get_Application(IDispatch **ppid)
{
    *ppid = NULL;

    if (!_pidApp)
        _Application(&_pidApp);

    return _pidApp ? _pidApp->QueryInterface(IID_PPV_ARG(IDispatch, ppid)) : E_FAIL;
}

STDMETHODIMP CFolder::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    return E_NOTIMPL;
}

// returns:
//      S_OK    - success
//      S_FALSE - failure, but not a script error
    
STDMETHODIMP CFolder::_ParentFolder(Folder **ppdf)
{
    *ppdf = NULL;   // assume error

    if (ILIsEmpty(_pidl))
        return S_FALSE;     // automation compat, let script check error

    LPITEMIDLIST pidl;
    HRESULT hr = SHILClone(_pidl, &pidl);
    if (SUCCEEDED(hr))
    {
        ILRemoveLastID(pidl);
        hr = CFolder_Create(_hwnd, pidl, NULL, IID_PPV_ARG(Folder, ppdf));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(*ppdf, _punkSite);
            if (_dwSafetyOptions)
            {
                hr = MakeSafeForScripting((IUnknown**)ppdf);
            }
        }
        ILFree(pidl);
    }
    return hr;
}

HRESULT CFolder::_SecurityCheck()
{
    return (!_dwSafetyOptions || (IsSafePage(_punkSite) == S_OK)) ? S_OK : E_ACCESSDENIED;
}

STDMETHODIMP CFolder::get_ParentFolder(Folder **ppdf)
{
    *ppdf = NULL;   // assume error
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _ParentFolder(ppdf);
    }
    return hr;
}

STDMETHODIMP CFolder::get_Title(BSTR *pbs)
{
    *pbs = NULL;

    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        SHFILEINFO sfi;
        if (SHGetFileInfo((LPCTSTR)_pidl, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_PIDL))
            *pbs = SysAllocStringT(sfi.szDisplayName);
        hr = S_OK;
    }
    return hr;
}

IShellDetails * CFolder::_GetShellDetails(void)
{
    if (!_psd)
    {
        if (_psf)
            _psf->CreateViewObject(_hwnd, IID_PPV_ARG(IShellDetails, &_psd));
    }
    return _psd;
}

STDMETHODIMP CFolder::Items(FolderItems **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = CFolderItems_Create(this, FALSE, ppid);
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(*ppid, _punkSite);
            if (_dwSafetyOptions)
            {
                hr = MakeSafeForScripting((IUnknown**)ppid);
            }
        }
    }
    return hr;
}

STDMETHODIMP CFolder::ParseName(BSTR bName, FolderItem **ppfi)
{
    *ppfi = NULL;

    // lets be strict here and not allow them to do much...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        ULONG chEaten;
        LPITEMIDLIST pidl;
        hr = _psf->ParseDisplayName(_hwnd, NULL, bName, &chEaten, &pidl, NULL);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlLast = ILFindLastID(pidl);
            if (pidlLast == pidl)
            {
                hr = CFolderItem_Create(this, pidl, ppfi);
            }
            else
            {
                LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
                if (pidlFull)
                {
                    CFolderItem_CreateFromIDList(_hwnd, pidlFull, ppfi);
                    ILFree(pidlFull);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            ILFree(pidl);
        }
        if (hr != S_OK)   // Scripts barf on errors returned
        {
            ppfi = NULL;
            hr = S_FALSE;
        }
    }
    return hr;
}

STDMETHODIMP CFolder::NewFolder(BSTR bName, VARIANT vOptions)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {  
        IStorage *pstg;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IStorage, _pidl, &pstg));
        if (SUCCEEDED(hr))
        {
            IStorage *pstgNew;
            hr = pstg->CreateStorage(bName, STGM_FAILIFTHERE, 0, 0, &pstgNew);
            if (SUCCEEDED(hr))
            {
                pstgNew->Release();
            }
            else if (STG_E_FILEALREADYEXISTS == hr)
            {
                hr = S_OK;
            }
            pstg->Release();
        }
    }
    return hr;
}

STDMETHODIMP CFolder::MoveHere(VARIANT vItem, VARIANT vOptions)
{
    return _MoveOrCopy(TRUE, vItem, vOptions);
}

STDMETHODIMP CFolder::CopyHere(VARIANT vItem, VARIANT vOptions)
{
    return _MoveOrCopy(FALSE, vItem, vOptions);
}

// get the IDList for an item from a VARIANT that is a FolderItem dispatch object

STDMETHODIMP CFolder::GetDetailsOf(VARIANT vItem, int iColumn, BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szBuf[INFOTIPSIZE];

        szBuf[0] = 0;

        LPCITEMIDLIST pidl = CFolderItem::_GetIDListFromVariant(&vItem); // returns an ALIAS

        if (iColumn == -1)  // infotip for the item
        {
            if (pidl)
                GetInfoTipHelp(_psf, pidl, szBuf, ARRAYSIZE(szBuf));
        }
        else
        {
            BOOL bUseDetails;
            SHELLDETAILS sd;

            sd.fmt = _fmt;
            sd.str.uType = STRRET_CSTR;
            sd.str.cStr[0] = 0;

            if (_psf2)
                bUseDetails = (E_NOTIMPL == _psf2->GetDetailsOf(pidl, iColumn, &sd));
            else
                bUseDetails = TRUE;

            if (bUseDetails)
            {
                IShellDetails* psd = _GetShellDetails();
                if (psd)
                    psd->GetDetailsOf(pidl, iColumn, &sd);
            }

            StrRetToBuf(&sd.str, pidl, szBuf, ARRAYSIZE(szBuf));
        }

        *pbs = SysAllocStringT(szBuf);
        hr = *pbs ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CFolder::get_Self(FolderItem **ppfi)
{
    *ppfi = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        Folder *psdf;
        if (ILIsEmpty(_pidl))
        {
            psdf = this;
            psdf->AddRef();
            hr = S_OK;
        }
        else
            hr = _ParentFolder(&psdf);
        
        if (SUCCEEDED(hr))
        {
            hr = CFolderItem_Create((CFolder*)psdf, ILFindLastID(_pidl), ppfi);
            if (SUCCEEDED(hr) && _dwSafetyOptions)
                hr = MakeSafeForScripting((IUnknown**)ppfi);
            psdf->Release();
        }
        else
            *ppfi = NULL;
    }
    return hr;
}

BOOL _VerifyUNC(LPTSTR psz, ULONG cch)
{
    if (PathIsUNC(psz))
    {
        return TRUE;
    }
    else if (psz[1] == TEXT(':'))
    {
        TCHAR szLocalName[3] = { psz[0], psz[1], TEXT('\0') };

        // Call GetDriveType before WNetGetConnection, to avoid loading
        // MPR.DLL unless absolutely necessary.
        if (DRIVE_REMOTE == GetDriveType(szLocalName) &&
            S_OK == WNetGetConnection(szLocalName, psz, &cch))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT GetSharePath(LPCITEMIDLIST pidl, LPTSTR psz, ULONG cch)
{
    HRESULT hr = E_FAIL;
    
    if (SHGetPathFromIDList(pidl, psz))
    {
        if (_VerifyUNC(psz, cch))
            hr = S_OK;
        else 
        {
            // check for folder shortcuts.
            IShellFolder *psf;
            if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf))))
            {
                IShellLink *psl;
                if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellLink, &psl))))
                {
                    if (SUCCEEDED(psl->GetPath(psz, cch, NULL, 0))
                    &&  _VerifyUNC(psz, cch))
                        hr = S_OK;
                    psl->Release();
                }
                psf->Release();
            }
        }
        if (SUCCEEDED(hr))
            PathStripToRoot(psz);
    }       

    return hr;
}

#include <cscuiext.h>

STDMETHODIMP CFolder::get_OfflineStatus(LONG *pul)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szShare[MAX_PATH];

        *pul = OFS_INACTIVE;  // default

        // Make sure we have a UNC \\server\share path.  Do this before
        // checking whether CSC is enabled, to avoid loading CSCDLL.DLL
        // unless absolutely necessary.
        if (SUCCEEDED(GetSharePath(_pidl, szShare, ARRAYSIZE(szShare))))
        {
            *pul = GetOfflineShareStatus(szShare);
        }
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CFolder::Synchronize(void)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        HWND hwndCSCUI = FindWindow(STR_CSCHIDDENWND_CLASSNAME, NULL);
        if (hwndCSCUI)
            PostMessage(hwndCSCUI, CSCWM_SYNCHRONIZE, 0, 0);
        hr = S_OK;
    }
    return hr;
}

#define REGSTR_WEBVIEW_BARRICADEDFOLDERS    (REGSTR_PATH_EXPLORER TEXT("\\WebView\\BarricadedFolders"))
#define REGSTR_VALUE_BARRICADE              TEXT("WebViewBarricade")

#define SHELL_ENTIRENET TEXT("shell:EntireNetwork")
#define SHELL_SYSROOT   TEXT("shell:SystemDriveRootFolder")
#define SHELL_CPLFLDR   TEXT("shell:ControlPanelFolder")

BOOL GetBarricadeValueNameFromPidl(LPCITEMIDLIST pidl, LPTSTR pszValueName, UINT cch)
{
    ASSERT(cch > (UINT)lstrlen(SHELL_ENTIRENET) &&
           cch > (UINT)lstrlen(SHELL_SYSROOT) &&
           cch > (UINT)lstrlen(SHELL_CPLFLDR));

    pszValueName[0] = TEXT('\0');
    
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
    {
        if (!MakeShellURLFromPath(szPath, pszValueName, cch))
        {
            HRESULT hr;
            if (lstrcmp(szPath, TEXT("EntireNetwork")) == 0)
            {
                hr = StringCchCopy(pszValueName, cch, SHELL_ENTIRENET);
                if (FAILED(hr))
                {
                    pszValueName[0] = '\0';
                }
            }
            else if (PathIsRoot(szPath))
            {
                TCHAR szSystemDir[MAX_PATH];
                szSystemDir[0] = TEXT('\0');
                GetWindowsDirectory(szSystemDir, ARRAYSIZE(szSystemDir));
                if (PathIsSameRoot(szPath, szSystemDir))
                {
                    hr = StringCchCopy(pszValueName, cch, SHELL_SYSROOT);
                    if (FAILED(hr))
                    {
                        pszValueName[0] = '\0';
                    }
                }
            }
            else
            {
                LPITEMIDLIST pidlTemp = NULL;
                if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlTemp)))
                {
                    if (ILIsEqual(pidl, pidlTemp))
                    {
                        hr = StringCchCopy(pszValueName, cch, SHELL_CPLFLDR);
                        if (FAILED(hr))
                        {
                            pszValueName[0] = '\0';
                        }
                    }
                    ILFree(pidlTemp);
                }
            }
        }
    }
    return BOOLIFY(pszValueName[0]);
}

BOOL IsBarricadeGloballyOff()
{
    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VALUE_BARRICADE, FALSE, FALSE);
}

VARIANT_BOOL GetBarricadeStatus(LPCTSTR pszValueName)
{
    VARIANT_BOOL bShowBarricade;

    if (!SHRegGetBoolUSValue(REGSTR_WEBVIEW_BARRICADEDFOLDERS, pszValueName, FALSE, TRUE))
    {
        bShowBarricade = VARIANT_FALSE; // ==> Don't show the barricade
    }
    else
    {
        bShowBarricade = VARIANT_TRUE;
    }
    return bShowBarricade;
}

STDMETHODIMP CFolder::get_ShowWebViewBarricade(VARIANT_BOOL *pbShowWebViewBarricade)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL bShowBarricade = VARIANT_FALSE;
        //
        // Control panel is a special case.
        // The barricade is used to represent 'category view' which can
        // be turned on/off by the user and also by global webview settings.
        // To determine the true barricade status, we ask the control panel 
        // code if the new 'category' view is active.
        //
        BOOL bIsControlPanel = FALSE;
        LPITEMIDLIST pidlControlPanel;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlControlPanel)))
        {
            bIsControlPanel = ILIsEqual(_pidl, pidlControlPanel);
            ILFree (pidlControlPanel);
        }
        if (bIsControlPanel)
        {
            //
            // When someone wants' to know if control panel's barricade is on,
            // they really want to know if it's configured for 'category' view.
            //
            if (CPL::CategoryViewIsActive(NULL))
            {
                bShowBarricade = VARIANT_TRUE;
            }
        }
        else
        {
            TCHAR szValueName[MAX_PATH];
            if (GetBarricadeValueNameFromPidl(_pidl, szValueName, ARRAYSIZE(szValueName)))
            {
                bShowBarricade = GetBarricadeStatus(szValueName);
            }
        }
        *pbShowWebViewBarricade = bShowBarricade;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CFolder::get_HaveToShowWebViewBarricade(VARIANT_BOOL *pbHaveToShowWebViewBarricade)
{
    return get_ShowWebViewBarricade(pbHaveToShowWebViewBarricade);
}

HRESULT SetBarricadeStatus(LPCTSTR pszValueName, VARIANT_BOOL bShowBarricade)
{
    HRESULT hr = E_FAIL;
    DWORD dwBarricade = (bShowBarricade == VARIANT_FALSE) ? 0 : 1;
    
    if (dwBarricade)
    {
        DWORD dw = 0;   // Unset "Barricade off for all folders" key
        SHRegSetUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VALUE_BARRICADE, REG_DWORD, (void *)&dw, sizeof(dw), SHREGSET_FORCE_HKCU);
    }

    if (SHRegSetUSValue(REGSTR_WEBVIEW_BARRICADEDFOLDERS, pszValueName, REG_DWORD, (void *)&dwBarricade, sizeof(dwBarricade), SHREGSET_FORCE_HKCU) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CFolder::put_ShowWebViewBarricade(VARIANT_BOOL bShowWebViewBarricade)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        // First, see if it is the root of the system drive
        TCHAR szValueName[MAX_PATH];
        if (GetBarricadeValueNameFromPidl(_pidl, szValueName, ARRAYSIZE(szValueName)))
        {
            SetBarricadeStatus(szValueName, bShowWebViewBarricade);
        }
    }
    return hr;
}

STDMETHODIMP CFolder::DismissedWebViewBarricade()
{
    return put_ShowWebViewBarricade(VARIANT_FALSE);
}

HRESULT GetUIObjectFromVariant(VARIANT vItems, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;

    LPITEMIDLIST pidl = VariantToIDList(&vItems);
    if (pidl)
    {
        hr = SHGetUIObjectFromFullPIDL(pidl, hwnd, riid, ppv);
        ILFree(pidl);
    }
    else
    {
        if (vItems.vt == (VT_BYREF | VT_VARIANT) && vItems.pvarVal)
             vItems = *vItems.pvarVal;

        FolderItems *pfis;
        if ((VT_DISPATCH == vItems.vt) && vItems.pdispVal && 
            SUCCEEDED(vItems.pdispVal->QueryInterface(IID_PPV_ARG(FolderItems, &pfis))))
        {
            long cItems;
            if (S_OK == pfis->get_Count(&cItems) && cItems)
            {
                LPITEMIDLIST *ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(*ppidl) * cItems);
                if (ppidl)
                {
                    IShellFolder *psf = NULL;

                    VARIANT v = {VT_I4};
                    for (v.lVal = 0; v.lVal < cItems; v.lVal++)
                    {
                        FolderItem *pfi;
                        if (SUCCEEDED(pfis->Item(v, &pfi)) && pfi)
                        {
                            IParentAndItem *pfai;
                            if (SUCCEEDED(pfi->QueryInterface(IID_PPV_ARG(IParentAndItem, &pfai))))
                            {
                                pfai->GetParentAndItem(NULL, 0 == v.lVal ? &psf : NULL, &(ppidl[v.lVal]));
                                pfai->Release();
                            }
                            pfi->Release();
                        }
                    }
                    
                    if (psf)
                    {
                        hr = psf->GetUIObjectOf(hwnd, cItems, (LPCITEMIDLIST *)ppidl, riid, NULL, ppv);
                        psf->Release();
                    }

                    for (v.lVal = 0; v.lVal < cItems; v.lVal++)
                    {
                        ILFree(ppidl[v.lVal]);
                    }
                    LocalFree(ppidl);
                }
            }
            pfis->Release();
        }
    }
    return hr;
}

DWORD VariantToDWORD(VARIANT vOptions)
{
    DWORD dw = 0;

    if (vOptions.vt == (VT_BYREF | VT_VARIANT) && vOptions.pvarVal)
         vOptions = *vOptions.pvarVal;

     // We need to get the source files out of the variant.
     // Currently support string, or IDispatch (Either FolderItem or FolderItems)
    switch (vOptions.vt)
    {
    case VT_I2:
        dw = (FILEOP_FLAGS)vOptions.iVal;
        break;

    case VT_I4:
        dw = (FILEOP_FLAGS)vOptions.lVal;
        break;
    }
    return dw;
}


// Main function to do Move or Copy
HRESULT CFolder::_MoveOrCopy(BOOL bMove, VARIANT vItems, VARIANT vOptions)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        IDropTarget *pdtgt;
        hr = _psf->CreateViewObject(_hwnd, IID_PPV_ARG(IDropTarget, &pdtgt));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(pdtgt, _punkSite);

            IDataObject *pdtobj;
            hr = GetUIObjectFromVariant(vItems, _hwnd, IID_PPV_ARG(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                FILEOP_FLAGS fof = (FILEOP_FLAGS)VariantToDWORD(vOptions);
                if (fof)
                {
                    static UINT s_cfFileOpFlags = 0;
                    if (0 == s_cfFileOpFlags)
                        s_cfFileOpFlags = RegisterClipboardFormat(TEXT("FileOpFlags"));

                    DataObj_SetDWORD(pdtobj, s_cfFileOpFlags, fof);
                }

                DWORD grfKeyState = bMove ? MK_SHIFT | MK_LBUTTON : MK_CONTROL | MK_LBUTTON;
                hr = SHSimulateDrop(pdtgt, pdtobj, grfKeyState, NULL, NULL);
                pdtobj->Release();
            }

            IUnknown_SetSite(pdtgt, NULL);
            pdtgt->Release();
        }
        hr = SUCCEEDED(hr) ? S_OK : S_FALSE;
    }
    return hr;
}

STDMETHODIMP CFolder::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolder::Initialize(LPCITEMIDLIST pidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return SHILClone(_pidl, ppidl);
}

HRESULT CFolder::InvokeVerbHelper(VARIANT vVerb, VARIANT vArgs, LPCITEMIDLIST *ppidl, int cItems, DWORD dwSafetyOptions)
{
    if (!dwSafetyOptions || (_SecurityCheck() == S_OK))
    {
        BOOL fDefaultVerb = TRUE;
        TCHAR szCmd[128];

        switch (vVerb.vt)
        {
        case VT_BSTR:
            fDefaultVerb = FALSE;
            SHUnicodeToTChar(vVerb.bstrVal, szCmd, ARRAYSIZE(szCmd));
            break;
        }

        HRESULT hr = S_OK;
        IContextMenu *pcm;
        if (SUCCEEDED(_psf->GetUIObjectOf(_hwnd, cItems, ppidl, IID_PPV_ARG_NULL(IContextMenu, &pcm))))
        {
            IShellFolderView *psfv;
            if (SUCCEEDED(GetShellFolderView(&psfv)))
            {
                IUnknown_SetSite(pcm, psfv);
            }
            else
            {
                ASSERT(NULL == psfv);
            }

            MENUITEMINFO mii;

            HMENU hmenu = CreatePopupMenu();
            if (NULL != hmenu)
            {
                pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fDefaultVerb ? CMF_DEFAULTONLY : CMF_CANRENAME);
                int idCmd = 0;

                if (fDefaultVerb)
                    idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                else
                {
                    // REVIEW: this should never have been done this way.  Can we rip it out?
                    //
                    // find a verb that matches name by display name (ugly)
                    for (int i = GetMenuItemCount(hmenu) - 1; i >= 0; i--)
                    {
                        TCHAR szText[128];    // should be big enough for this
                        mii.cbSize = sizeof(MENUITEMINFO);
                        mii.dwTypeData = szText;
                        mii.fMask = MIIM_ID | MIIM_TYPE;
                        mii.cch = ARRAYSIZE(szText);
                        mii.fType = MFT_SEPARATOR;                // to avoid ramdom result.
                        mii.dwItemData = 0;
                        GetMenuItemInfo(hmenu, i, TRUE, &mii);

                        if (lstrcmpi(szText, szCmd) == 0)
                        {
                            idCmd = mii.wID;
                            break;
                        }
                    }
                }
                if (!idCmd)
                {
                    // that didn't work, find it the right way by the canonical verb name
                    int iItem = GetMenuIndexForCanonicalVerb(hmenu, pcm, CONTEXTMENU_IDCMD_FIRST, vVerb.bstrVal);
                    if (-1 != iItem)
                    {
                        mii.cbSize = sizeof(MENUITEMINFO);
                        mii.fMask = MIIM_ID;

                        if (GetMenuItemInfo(hmenu, iItem, MF_BYPOSITION, &mii))
                            idCmd = mii.wID;
                    }
                }

                if (idCmd)
                {
                    CMINVOKECOMMANDINFO ici = {
                        sizeof(CMINVOKECOMMANDINFO),
                        0L,
                        _hwnd,
                        NULL,
                        NULL, NULL,
                        SW_SHOWNORMAL,
                    };

                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);

                    char szArgs[MAX_PATH];       // max size we will currently use.

                    // See if we are supposed to pass any arguments on the command line
                    switch (vArgs.vt)
                    {
                    case VT_BSTR:
                        SHUnicodeToAnsi(vArgs.bstrVal, szArgs, ARRAYSIZE(szArgs));
                        ici.lpParameters =  szArgs;
                        break;
                    }

                    // Finally invoke the command
                    pcm->InvokeCommand(&ici);
                }

                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (psfv)
            {
                IUnknown_SetSite(pcm, NULL);
                psfv->Release();
            }

            pcm->Release();
        }
        return hr;
    }
    return E_ACCESSDENIED;
} 

HRESULT CFolder::GetShellFolderView(IShellFolderView **ppsfv)
{
    return IUnknown_QueryService(_punkOwner, SID_DefView, IID_PPV_ARG(IShellFolderView, ppsfv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdlink.cpp ===
#include "precomp.h"
#pragma hdrstop


class CShortcut : 
    public IShellLinkDual2, 
    public CObjectSafety, 
    protected CImpIDispatch
{

public:
    CShortcut();
    HRESULT Init(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IShellLinkDual
    STDMETHODIMP get_Path(BSTR *pbs);
    STDMETHODIMP put_Path(BSTR bs);
    STDMETHODIMP get_Description(BSTR *pbs);
    STDMETHODIMP put_Description(BSTR bs);
    STDMETHODIMP get_WorkingDirectory(BSTR *pbs);
    STDMETHODIMP put_WorkingDirectory(BSTR bs);
    STDMETHODIMP get_Arguments(BSTR *pbs);
    STDMETHODIMP put_Arguments(BSTR bs);
    STDMETHODIMP get_Hotkey(int *piHK);
    STDMETHODIMP put_Hotkey(int iHK);
    STDMETHODIMP get_ShowCommand(int *piShowCommand);
    STDMETHODIMP put_ShowCommand(int iShowCommand);

    STDMETHODIMP Resolve(int fFlags);
    STDMETHODIMP GetIconLocation(BSTR *pbs, int *piIcon);
    STDMETHODIMP SetIconLocation(BSTR bs, int iIcon);
    STDMETHODIMP Save(VARIANT vWhere);

    // IShellLinkDual2
    STDMETHODIMP get_Target(FolderItem **ppfi);

private:
    ~CShortcut();
    HRESULT _SecurityCheck();

    LONG            _cRef;
    HWND            _hwnd;              // Hwnd of the main folder window
    IShellLink      *_psl;
};

HRESULT CShortcut_CreateIDispatch(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl, IDispatch ** ppid)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppid = NULL;

    CShortcut* psdf = new CShortcut();
    if (psdf)
    {
        hr = psdf->Init(hwnd, psf, pidl);
        if (SUCCEEDED(hr))
             hr = psdf->QueryInterface(IID_IDispatch, (void **)ppid);
        psdf->Release();
    }
    return hr;
}

CShortcut::CShortcut() :
        CImpIDispatch(SDSPATCH_TYPELIB, IID_IShellLinkDual2)
{
    DllAddRef();
    _cRef = 1;
    _hwnd = NULL;
    _psl = NULL;
}


CShortcut::~CShortcut(void)
{
    if (_psl)
        _psl->Release();

    DllRelease();
}

HRESULT CShortcut::Init(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    _hwnd = hwnd;
    return psf->GetUIObjectOf(hwnd, 1, &pidl, IID_IShellLink, NULL, (void **)&_psl);
}

STDMETHODIMP CShortcut::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CShortcut, IShellLinkDual2),
        QITABENTMULTI(CShortcut, IShellLinkDual, IShellLinkDual2),
        QITABENTMULTI(CShortcut, IDispatch, IShellLinkDual2),
        QITABENT(CShortcut, IObjectSafety),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShortcut::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShortcut::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// returns:
//      TRUE    - every thing OK
//      FALSE   - don't do it
HRESULT CShortcut::_SecurityCheck()
{
    return (_dwSafetyOptions == 0) ? S_OK : E_ACCESSDENIED; // || (IsSafePage(_punkSite) == S_OK);
}


HRESULT _TCharToBSTR(LPCTSTR psz, BSTR *pbs)
{
    *pbs = SysAllocStringT(psz);
    return *pbs ? S_OK : E_OUTOFMEMORY;
}

LPCTSTR _BSTRToTChar(BSTR bs, TCHAR *psz, UINT cch)
{
    if (bs)
        SHUnicodeToTChar(bs, psz, cch);
    else
        psz = NULL;
    return psz;
}

STDMETHODIMP CShortcut::get_Path(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = _psl->GetPath(szPath, ARRAYSIZE(szPath), NULL, 0);
        if (SUCCEEDED(hr))
            hr = _TCharToBSTR(szPath, pbs);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_Path(BSTR bs)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = _psl->SetPath(_BSTRToTChar(bs, szPath, ARRAYSIZE(szPath)));
    }
    return hr;
}

STDMETHODIMP CShortcut::get_Description(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szDescription[MAX_PATH];
        hr = _psl->GetDescription(szDescription, ARRAYSIZE(szDescription));
        if (SUCCEEDED(hr))
            hr = _TCharToBSTR(szDescription, pbs);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_Description(BSTR bs)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szDesc[MAX_PATH];
        hr = _psl->SetDescription(_BSTRToTChar(bs, szDesc, ARRAYSIZE(szDesc)));
    }
    return hr;
}

STDMETHODIMP CShortcut::get_WorkingDirectory(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szWorkingDir[MAX_PATH];
        hr = _psl->GetWorkingDirectory(szWorkingDir, ARRAYSIZE(szWorkingDir));
        if (SUCCEEDED(hr))
            hr = _TCharToBSTR(szWorkingDir, pbs);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_WorkingDirectory(BSTR bs)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szWorkingDir[MAX_PATH];
        hr = _psl->SetWorkingDirectory(_BSTRToTChar(bs, szWorkingDir, ARRAYSIZE(szWorkingDir)));
    }
    return hr;
}

STDMETHODIMP CShortcut::get_Arguments(BSTR *pbs)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szArgs[MAX_PATH];
        hr = _psl->GetArguments(szArgs, ARRAYSIZE(szArgs));
        if (SUCCEEDED(hr))
            hr = _TCharToBSTR(szArgs, pbs);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_Arguments(BSTR bs)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szArgs[MAX_PATH];
        hr = _psl->SetArguments(_BSTRToTChar(bs, szArgs, ARRAYSIZE(szArgs)));
    }
    return hr;
}

STDMETHODIMP CShortcut::get_Hotkey(int *piHK)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _psl->GetHotkey((WORD*)piHK);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_Hotkey(int iHK)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _psl->SetHotkey((WORD)iHK);
    }
    return hr;
}

STDMETHODIMP CShortcut::get_ShowCommand(int *piShowCommand)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _psl->GetShowCmd(piShowCommand);
    }
    return hr;
}

STDMETHODIMP CShortcut::put_ShowCommand(int iShowCommand)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _psl->SetShowCmd(iShowCommand);
    }
    return hr;
}

STDMETHODIMP CShortcut::get_Target(FolderItem **ppfi)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        if (S_OK == _psl->GetIDList(&pidl))
        {
            hr = CFolderItem_CreateFromIDList(NULL, pidl, ppfi);
            if (SUCCEEDED(hr) && _dwSafetyOptions)
                hr = MakeSafeForScripting((IUnknown**)ppfi);
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CShortcut::Resolve(int fFlags)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = _psl->Resolve(_hwnd, (DWORD)fFlags);
    }
    return hr;
}

STDMETHODIMP CShortcut::GetIconLocation(BSTR *pbs, int *piIcon)
{
    *pbs = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szIconPath[MAX_PATH];
        hr = _psl->GetIconLocation(szIconPath, ARRAYSIZE(szIconPath), piIcon);
        if (SUCCEEDED(hr))
            hr = _TCharToBSTR(szIconPath, pbs);
    }
    return hr;
}

STDMETHODIMP CShortcut::SetIconLocation(BSTR bs, int iIcon)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szArgs[MAX_PATH];
        hr = _psl->SetIconLocation(_BSTRToTChar(bs, szArgs, ARRAYSIZE(szArgs)), iIcon);
    }
    return hr;
}

STDMETHODIMP CShortcut::Save(VARIANT vWhere)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;

        hr = _psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
        if (SUCCEEDED(hr))
        {
            hr = ppf->Save(VariantToStrCast(&vWhere), TRUE);
            ppf->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\admoveri.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <initguid.h>

const IID IID_IDeskMovr = {0x72267F69,0xA6F9,0x11D0,{0xBC,0x94,0x00,0xC0,0x4F,0xB6,0x78,0x63}};
const IID IID_IDeskSizr = {0x72267F6C,0xA6F9,0x11D0,{0xBC,0x94,0x00,0xC0,0x4F,0xB6,0x78,0x63}};
const IID LIBID_ADMOVERLib = {0x72267F5C,0xA6F9,0x11D0,{0xBC,0x94,0x00,0xC0,0x4F,0xB6,0x78,0x63}};
const CLSID CLSID_DeskMovr = {0x72267F6A,0xA6F9,0x11D0,{0xBC,0x94,0x00,0xC0,0x4F,0xB6,0x78,0x63}};
const CLSID CLSID_DeskSizr = {0x72267F6D,0xA6F9,0x11D0,{0xBC,0x94,0x00,0xC0,0x4F,0xB6,0x78,0x63}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdwindow.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "stdenum.h"

#define DM_SDFOLDER 0

class CShellFolderView :  public IShellFolderViewDual2,
                          public IShellService,
                          public IServiceProvider,
                          public CObjectSafety,
                          public CObjectWithSite, 
                          protected CImpIConnectionPointContainer,
                          protected CImpIExpDispSupport,
                          protected CImpIDispatch
{
public:
    CShellFolderView(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // IShellFolderViewDual2
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);

    STDMETHODIMP get_Folder(Folder **ppid);
    STDMETHODIMP SelectedItems(FolderItems **ppid);
    STDMETHODIMP get_FocusedItem(FolderItem **ppid);
    STDMETHODIMP SelectItem(VARIANT *pvfi, int dwFlags);
    STDMETHODIMP PopupItemMenu(FolderItem * pfi, VARIANT vx, VARIANT vy, BSTR * pbs);
    STDMETHODIMP get_Script(IDispatch **ppid);
    STDMETHODIMP get_ViewOptions(long *plSetting);
    STDMETHODIMP get_CurrentViewMode(UINT *pViewMode);
    STDMETHODIMP put_CurrentViewMode(UINT ViewMode);
    STDMETHODIMP SelectItemRelative(int iRelative);

    // IShellService
    STDMETHODIMP SetOwner(IUnknown* punkOwner);

    // CImpIConnectionPoint
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);

    // CObjectWithSite overriding
    STDMETHODIMP SetSite(IUnknown *punkSite);

private:
    HRESULT _IsSafe() 
    {
        return (0 == _dwSafetyOptions) ? S_OK : IsSafePage(_punkSite);
    }

    ~CShellFolderView(void);
    HRESULT _GetFolder();
    // CImpIExpDispSupport
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);

    LONG _cRef;
    CFolder *_psdf;                // The shell folder we talk to ...
    IUnknown *_punkOwner;          // back link to defview (owner object of us...)
    IShellFolderView *_psfvOwner;  // The owners Shell folder view...
    HWND _hwnd;                    // the hwnd for the window...

    // Embed our Connection Point object - implmentation in cnctnpt.cpp
    CConnectionPoint _cpEvents;
};

// implementation of CLSID_ShellFolderView, class factory is in shell32 (and was in mars, but that project is dead)

STDAPI CShellFolderView_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    CShellFolderView* psfv = new CShellFolderView();
    if (psfv) 
    {
        hr = psfv->QueryInterface(riid, ppvOut);
        psfv->Release();
    }
    return hr;
}

CShellFolderView::CShellFolderView(void) :
        CImpIDispatch(SDSPATCH_TYPELIB, IID_IShellFolderViewDual2), _cRef(1), _psdf(NULL)
{
    DllAddRef();
    _cpEvents.SetOwner((IUnknown*)SAFECAST(this, IShellFolderViewDual2*), &DIID_DShellFolderViewEvents);
}

CShellFolderView::~CShellFolderView(void)
{
    // if we ever grabbed a shell folder for this window release it also
    if (_psdf)
    {
        _psdf->SetSite(NULL);
        _psdf->SetOwner(NULL);
        _psdf->Release();
    }

    ASSERT(_punkOwner == NULL);
    ASSERT(_psfvOwner == NULL);
    ASSERT(_punkSite == NULL);

    DllRelease();
}

STDMETHODIMP CShellFolderView::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CShellFolderView, IShellFolderViewDual),
        QITABENT(CShellFolderView, IShellFolderViewDual2),
        QITABENTMULTI(CShellFolderView, IDispatch, IShellFolderViewDual),
        QITABENTMULTI(CShellFolderView, IDispatch, IShellFolderViewDual2),
        QITABENT(CShellFolderView, IShellService),
        QITABENT(CShellFolderView, IConnectionPointContainer),
        QITABENT(CShellFolderView, IExpDispSupport),
        QITABENT(CShellFolderView, IObjectSafety),
        QITABENT(CShellFolderView, IObjectWithSite),
        QITABENT(CShellFolderView, IServiceProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellFolderView::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellFolderView::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//The ShellWindow implementation
// let folder we have handle this.  Probably won't work for webviews as this object
// is not secure...

STDMETHODIMP CShellFolderView::get_Application(IDispatch **ppid)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hres = _GetFolder();
    if (SUCCEEDED(hres))
        hres = _psdf->get_Application(ppid);
    return hres;
}

STDMETHODIMP CShellFolderView::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    return E_FAIL;
}

HRESULT CShellFolderView::_GetFolder()
{
    if (_psdf)
        return S_OK;

    HRESULT hr;

    LPITEMIDLIST pidl = NULL;
    IShellFolder *psf = NULL;

    if (_psfvOwner)
    {
        IFolderView *pfv;
        if (SUCCEEDED(_psfvOwner->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
        {
            if (SUCCEEDED(pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf))))
            {
                if (SHGetIDListFromUnk(psf, &pidl) != S_OK)
                {
                    psf->Release();
                    psf = NULL;
                }
            }
            pfv->Release();
        }

        if (!pidl)
        {
            LPCITEMIDLIST pidlT;
            // dsheldon - the -42 is a hack that says "give me the folder pidl"
            hr = GetObjectSafely(_psfvOwner, &pidlT, (UINT)-42);
            if (SUCCEEDED(hr))
            {
                pidl = ILClone(pidlT);
            }
        }
    }

    if (pidl)
    {
        hr = CFolder_Create2(_hwnd, pidl, psf, &_psdf);
        if (SUCCEEDED(hr))
        {
            _psdf->SetSite(_punkSite);
            _psdf->SetOwner(_punkOwner);
            if (_dwSafetyOptions)
                hr = MakeSafeForScripting((IUnknown**)&_psdf);
        }

        if (psf)
            psf->Release();
        ILFree(pidl);
    }
    else
        hr = E_FAIL;

    return hr;
}

STDMETHODIMP CShellFolderView::SetSite(IUnknown *punkSite)
{
    if (_psdf)
        _psdf->SetSite(punkSite);
    return CObjectWithSite::SetSite(punkSite);
}

STDMETHODIMP CShellFolderView::get_Folder(Folder **ppid)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    *ppid = NULL;

    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psdf->QueryInterface(IID_PPV_ARG(Folder, ppid));
    return hr;
}

STDMETHODIMP CShellFolderView::SelectedItems(FolderItems **ppid)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
    {
        hr = CFolderItems_Create(_psdf, TRUE, ppid);

        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(*ppid, _punkSite);

            if (_dwSafetyOptions)
            {
                hr = MakeSafeForScripting((IUnknown**)ppid);
            }
        }
    }
    return hr;
}

// NOTE: this returns an alias pointer, it is not allocated

HRESULT GetObjectSafely(IShellFolderView *psfv, LPCITEMIDLIST *ppidl, UINT iType)
{
    // cast needed because GetObject() returns an alias!
    HRESULT hr = psfv->GetObject((LPITEMIDLIST *)ppidl, iType);
    if (SUCCEEDED(hr))
    {
        // On the off chance this is coppied across process boundries...
        __try
        {
            // force a full deref this PIDL to generate a fault if cross process
            if (ILGetSize(*ppidl) > 0)
                hr = S_OK;
            // Don't free it as it was not cloned...
        }
        __except(SetErrorMode(SEM_NOGPFAULTERRORBOX), UnhandledExceptionFilter(GetExceptionInformation()))
        {
            *ppidl = NULL;
            hr = E_FAIL;
        }
    }
    return hr;
}

STDMETHODIMP CShellFolderView::get_FocusedItem(FolderItem **ppid)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
    {
        *ppid = NULL;
        hr = S_FALSE;

        if (_psfvOwner)
        {
            // Warning:
            //   It is common for the following function to fail (which means no item has the focus).
            // So, do not save the return code from GetObjectSafely() into "hr" that will ruin the
            // S_FALSE value already stored there and result in script errors. (Bug #301306)
            //
            LPCITEMIDLIST pidl;
            // dsheldon - the -2 is a hack that says "give me the selected pidl"
            if (SUCCEEDED(GetObjectSafely(_psfvOwner, &pidl, (UINT)-2)))
            {
                hr = CFolderItem_Create(_psdf, pidl, ppid);

                if (_dwSafetyOptions && SUCCEEDED(hr))
                    hr = MakeSafeForScripting((IUnknown**)ppid);
            }
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

STDMETHODIMP CShellFolderView::get_CurrentViewMode(UINT *pViewMode)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = S_FALSE;
    IFolderView *pfv;
    if (_punkOwner && SUCCEEDED(_punkOwner->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
    {
        hr = pfv->GetCurrentViewMode(pViewMode);
        pfv->Release();
    }
    return hr;
}

STDMETHODIMP CShellFolderView::put_CurrentViewMode(UINT ViewMode)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = S_FALSE;
    IFolderView *pfv;
    if (_punkOwner && SUCCEEDED(_punkOwner->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
    {
        hr = pfv->SetCurrentViewMode(ViewMode);
        pfv->Release();
    }
    return hr;
}

STDMETHODIMP CShellFolderView::SelectItemRelative(int iRelative)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = S_FALSE;
    IFolderView *pfv;
    if (_punkOwner && SUCCEEDED(_punkOwner->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
    {
        int iCurrent, cItems;
        if (SUCCEEDED(pfv->ItemCount(SVGIO_ALLVIEW, &cItems)) && (cItems > 1) &&
            SUCCEEDED(pfv->GetSelectionMarkedItem(&iCurrent)))
        {
            int iToSelect = iCurrent + iRelative;
            if (iToSelect < 0)
                iToSelect = 0;
            else if (iToSelect > cItems - 1)
                iToSelect = cItems - 1;

            hr = pfv->SelectItem(iToSelect, SVSI_SELECTIONMARK | SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS);
        }
        pfv->Release();
    }
    return hr;
}

// pvfi should be a "FolderItem" IDispatch

STDMETHODIMP CShellFolderView::SelectItem(VARIANT *pvfi, int dwFlags)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl = VariantToIDList(pvfi);
    // if pvfi is NULL that means all items in the folder...
    if (pidl || (pvfi && pvfi->vt == VT_NULL))
    {
        IShellView *psv;    // use this to select the item...
        if (_punkOwner && SUCCEEDED(_punkOwner->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
        {
            // ILFindLastID checks for NULL...
            hr = psv->SelectItem(ILFindLastID(pidl), dwFlags);
            psv->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CShellFolderView::PopupItemMenu(FolderItem *pfi, VARIANT vx, VARIANT vy, BSTR * pbs)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellFolderView::get_Script(IDispatch **ppid)
{
    *ppid = NULL;   // Say that we got nothing...

    if (!_punkOwner)
        return S_FALSE;

    IShellView *psv;
    HRESULT hres = _punkOwner->QueryInterface(IID_PPV_ARG(IShellView, &psv));
    if (SUCCEEDED(hres))
    {
        // lets see if there is a IHTMLDocument that is below us now...
        IHTMLDocument *phtmld;
        hres = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IHTMLDocument, &phtmld));
        if (SUCCEEDED(hres))
        {
            if (_dwSafetyOptions)
                hres = MakeSafeForScripting((IUnknown **)&phtmld);

            if (SUCCEEDED(hres))
            {
                hres = phtmld->get_Script(ppid);
            }
            phtmld->Release();
        }
        psv->Release();
    }

    return hres;
}

// Helper function that can be used to get the current view options...
// (ripped out of dvoc.cpp)
DWORD GetViewOptionsForDispatch()
{
    SHELLSTATE ss = {0};
    DWORD dwSetting = 0;

    // Get the view options to return...

    SHGetSetSettings(&ss, 
        SSF_SHOWALLOBJECTS|SSF_SHOWEXTENSIONS|SSF_SHOWCOMPCOLOR|
            SSF_SHOWSYSFILES|SSF_DOUBLECLICKINWEBVIEW|SSF_DESKTOPHTML|SSF_WIN95CLASSIC,
        FALSE);

    // Aarg: mnuch the Bool:1 fields into a dword...
    if (ss.fShowAllObjects) dwSetting |= SFVVO_SHOWALLOBJECTS;
    if (ss.fShowExtensions) dwSetting |= SFVVO_SHOWEXTENSIONS;
    if (ss.fShowCompColor) dwSetting |= SFVVO_SHOWCOMPCOLOR;
    if (ss.fShowSysFiles) dwSetting |= SFVVO_SHOWSYSFILES;
    if (ss.fDoubleClickInWebView) dwSetting |= SFVVO_DOUBLECLICKINWEBVIEW;
    if (ss.fDesktopHTML) dwSetting |= SFVVO_DESKTOPHTML;
    if (ss.fWin95Classic) dwSetting |= SFVVO_WIN95CLASSIC;
    
    return dwSetting;
}

STDMETHODIMP CShellFolderView::get_ViewOptions(long *plSetting)
{
    if (S_OK != _IsSafe())
        return E_ACCESSDENIED;

    *plSetting = (LONG)GetViewOptionsForDispatch();
    return S_OK;
}

STDMETHODIMP CShellFolderView::SetOwner(IUnknown* punkOwner)
{
    if (_psdf)
        _psdf->SetOwner(punkOwner);

    IUnknown_Set((IUnknown **)&_psfvOwner, NULL);        // free cached interface
    IUnknown_Set(&_punkOwner, punkOwner);   // hold this guy

    if (_punkOwner)
    {
        _punkOwner->QueryInterface(IID_PPV_ARG(IShellFolderView, &_psfvOwner));

        if (!_hwnd)
        {
            IShellView *psv;

            // this is gross, until we can merge the two models, create one of our
            // Window objects.
            if (SUCCEEDED(_punkOwner->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
            {
                HWND hwndFldr;
                psv->GetWindow(&hwndFldr);

                // Really gross, but assume parent HWND is the HWND we are after...
                _hwnd = GetParent(hwndFldr);
                psv->Release();
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CShellFolderView::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1, _cpEvents.CastToIConnectionPoint());
}

CConnectionPoint* CShellFolderView::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    if (IsEqualIID(iid, DIID_DShellFolderViewEvents) || (fdisp && IsEqualIID(iid, IID_IDispatch)))
        return &_cpEvents;

    return NULL;
}

HRESULT CShellFolderView::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr;

    if (dispidMember == DISPID_READYSTATE)
        return DISP_E_MEMBERNOTFOUND;   // perf: what typeinfo would return.

    if (dispidMember == DISPID_WINDOWOBJECT) 
    {
        IDispatch *pdisp;
        if (SUCCEEDED(get_Script(&pdisp))) 
        {
            hr = pdisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            pdisp->Release();
        } 
        else 
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }
    else
        hr = CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    return hr;
}

HRESULT CShellFolderView::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = IUnknown_QueryService(_punkOwner, guidService, riid, ppv);
    if (FAILED(hr))
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdmain.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "cmnquery.h"
#include "dsquery.h"
#include "startids.h"
#include "dsgetdc.h"
#include "lm.h"
#include "winldap.h"
#include "activeds.h"
#include "shconv.h"

// This is the implementation for the Shell Application level IDispatch
// Currently we will try to maintain only one object per process.
// Note: these define's must match those in explorer\rcids.h

#define IDM_SYSBUTTON   300
#define IDM_FINDBUTTON  301
#define IDM_HELPBUTTON  302
#define IDM_FILERUN                 401
#define IDM_CASCADE                 403
#define IDM_HORIZTILE               404
#define IDM_VERTTILE                405
#define IDM_DESKTOPARRANGEGRID      406
#define IDM_TOGGLEDESKTOP           407
#define IDM_SETTIME                 408
#define IDM_SUSPEND                 409
#define IDM_EJECTPC                 410
#define IDM_TASKLIST                412
#define IDM_TRAYPROPERTIES          413
#define IDM_EDITSTARTMENU           414
#define IDM_MINIMIZEALL             415
#define IDM_UNDO                    416
#define IDM_RETURN                  417
#define IDM_PRINTNOTIFY_FOLDER      418
#define IDM_MINIMIZEALLHOTKEY       419
#define IDM_SHOWTASKMAN             420
#define IDM_RECENT              501
#define IDM_FIND                502
#define IDM_PROGRAMS            504
#define IDM_CONTROLS            505
#define IDM_EXITWIN             506
// #define IDM_FONTS            509
#define IDM_PRINTERS            510
#define IDM_STARTMENU           511
#define IDM_MYCOMPUTER          512
#define IDM_PROGRAMSINIT        513
#define IDM_RECENTINIT          514
#define IDM_MENU_FIND           520
#define TRAY_IDM_FINDFIRST      521  // this range
#define TRAY_IDM_FINDLAST       550  // is reserved for find command
#define IDM_RECENTLIST          650
#define IDM_QUICKTIPS   800
#define IDM_HELPCONT    801
#define IDM_WIZARDS     802
#define IDM_USEHELP     803             // REVIEW: probably won't be used
#define IDM_TUTORIAL    804
#define IDM_ABOUT       805
#define IDM_LAST_MENU_ITEM   IDM_ABOUT
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST
//#define FCIDM_FINDFILES         (FCIDM_BROWSER_TOOLS+0x0005)
#define FCIDM_FINDCOMPUTER      (FCIDM_BROWSER_TOOLS+0x0006)

//============================================================================

class CShellDispatch : public IShellDispatch4, 
                       public CObjectSafety,
                       protected CImpIDispatch,
                       public CObjectWithSite
{
    friend class CAdviseRouter;
    friend HRESULT GetApplicationObject(DWORD dwSafetyOptions, IUnknown *punkSite, IDispatch **ppid);
    
public:
    // Non-delegating object IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch members
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IShellDispatch
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent (IDispatch **ppid);
    STDMETHOD(Open)(THIS_ VARIANT vDir);
    STDMETHOD(Explore)(THIS_ VARIANT vDir);
    STDMETHOD(NameSpace)(THIS_ VARIANT vDir, Folder **ppsdf);
    STDMETHODIMP BrowseForFolder(long hwnd, BSTR Title, long Options, VARIANT vRoot, Folder **ppsdf);
    STDMETHODIMP ControlPanelItem(BSTR szDir);
    STDMETHODIMP MinimizeAll(void);
    STDMETHODIMP UndoMinimizeALL(void);
    STDMETHODIMP FileRun(void);
    STDMETHODIMP CascadeWindows(void);
    STDMETHODIMP TileVertically(void);
    STDMETHODIMP TileHorizontally(void);
    STDMETHODIMP ShutdownWindows(void);
    STDMETHODIMP Suspend(void);
    STDMETHODIMP EjectPC(void);
    STDMETHODIMP SetTime(void);
    STDMETHODIMP TrayProperties(void);
    STDMETHODIMP Help(void);
    STDMETHODIMP FindFiles(void);
    STDMETHODIMP FindComputer(void);
    STDMETHODIMP RefreshMenu(void);
    STDMETHODIMP Windows(IDispatch **ppid);
    STDMETHODIMP get_ObjectCount(int *pcObjs);
    STDMETHODIMP IsRestricted(BSTR Group, BSTR Restriction, long * lpValue);
    STDMETHODIMP ShellExecute(BSTR File, VARIANT vArgs, VARIANT vDir, VARIANT vOperation, VARIANT vShow);
    STDMETHODIMP FindPrinter(BSTR name, BSTR location, BSTR model);
    STDMETHODIMP GetSystemInformation(BSTR name, VARIANT * pvOut);
    STDMETHODIMP ServiceStart(BSTR ServiceName, VARIANT Persistent, VARIANT *pSuccess);
    STDMETHODIMP ServiceStop(BSTR ServiceName, VARIANT Persistent, VARIANT *pSuccess);
    STDMETHODIMP IsServiceRunning(BSTR ServiceName, VARIANT *pRunning);
    STDMETHODIMP CanStartStopService(BSTR ServiceName, VARIANT *pCanStartStop);
    STDMETHODIMP ShowBrowserBar(BSTR bstrClsid, VARIANT bShow, VARIANT *pSuccess);

    // IShellDispatch3
    STDMETHODIMP AddToRecent(VARIANT varFile, BSTR bstrCategory);

    // IShellDispatch4
    STDMETHODIMP WindowsSecurity();
    STDMETHODIMP ToggleDesktop();
    STDMETHODIMP ExplorerPolicy(BSTR bstrName, VARIANT *pValue);
    STDMETHODIMP GetSetting(long lSetting, VARIANT_BOOL *pValue);

    // Constructor and the like.. 
    CShellDispatch(void);
protected:
    LONG           _cRef;

    ~CShellDispatch(void);
    HRESULT         _SecurityCheck(void);   // Check if we are in paranoid mode...
    HRESULT         _TrayCommand(UINT idCmd);
    HRESULT         ExecuteFolder(VARIANT vDir, LPCTSTR pszVerb);
    VARIANT_BOOL    _ServiceStartStop(BSTR ServiceName, BOOL fStart, BOOL fPersist);
    HWND _GetWindow();
};


STDAPI CShellDispatch_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppvOut = NULL;

    // aggregation checking is handled in class factory
    CShellDispatch * pshd = new CShellDispatch();
    if (pshd)
    {
        hr = pshd->QueryInterface(riid, ppvOut);
        pshd->Release();
    }
    return hr;
}

CShellDispatch::CShellDispatch(void) : _cRef(1), CImpIDispatch(SDSPATCH_TYPELIB, IID_IShellDispatch4)
{
    DllAddRef();
}

CShellDispatch::~CShellDispatch(void)
{
    DllRelease();
}

HRESULT CShellDispatch::_SecurityCheck(void)
{
    return (!_dwSafetyOptions || (IsSafePage(_punkSite) == S_OK)) ? S_OK : E_ACCESSDENIED;
}

STDMETHODIMP CShellDispatch::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CShellDispatch, IShellDispatch4),
        QITABENTMULTI(CShellDispatch, IShellDispatch3, IShellDispatch4),
        QITABENTMULTI(CShellDispatch, IShellDispatch2, IShellDispatch4),
        QITABENTMULTI(CShellDispatch, IShellDispatch, IShellDispatch4),
        QITABENTMULTI(CShellDispatch, IDispatch, IShellDispatch4),
        QITABENT(CShellDispatch, IObjectSafety),
        QITABENT(CShellDispatch, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CShellDispatch::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellDispatch::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// Helper function to process commands to the tray.
HRESULT CShellDispatch::_TrayCommand(UINT idCmd)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {

        // APPHACK!  221008 DesktopX creates their own window with class
        // name "Shell_TrayWnd", so if we're not careful we will end
        // posting the messages to the wrong window.  They create their
        // window with the title "CTrayServer"; ours has a null title.
        // Use the null title to find the correct window.

        HWND hwndTray = FindWindowA(WNDCLASS_TRAYNOTIFY, "");
        if (hwndTray)
            PostMessage(hwndTray, WM_COMMAND, idCmd, 0);

        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP CShellDispatch::get_Application(IDispatch **ppid)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppid));
}

STDMETHODIMP CShellDispatch::get_Parent(IDispatch **ppid)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppid));
}

HRESULT CShellDispatch::ExecuteFolder(VARIANT vDir, LPCTSTR pszVerb)
{
    // Check to see if we allow the user to do this...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        SHELLEXECUTEINFO sei = { sizeof(sei), 0 };
        sei.lpIDList = (void *)VariantToIDList(&vDir);
        if (sei.lpIDList)
        {
            // Everything should have been initialize to 0
            // BUGBUG:: Should be invoke idlist but that is failing when
            // explore
            sei.fMask = SEE_MASK_IDLIST;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpVerb = pszVerb;

            hr = ShellExecuteEx(&sei) ? NOERROR : S_FALSE;

            ILFree((LPITEMIDLIST)sei.lpIDList);
        }
        else
        {
            hr = S_FALSE; // bad dir
        }
    }
    return hr;
}


STDMETHODIMP CShellDispatch::Open(VARIANT vDir)
{
    return ExecuteFolder(vDir, NULL);
}

STDMETHODIMP CShellDispatch::Explore(VARIANT vDir)
{
    return ExecuteFolder(vDir, TEXT("explore"));
}

STDMETHODIMP CShellDispatch::NameSpace(VARIANT vDir, Folder **ppsdf)
{
    *ppsdf = NULL;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = VariantToIDList(&vDir);
        if (pidl)
        {
            hr = CFolder_Create(NULL, pidl, NULL, IID_PPV_ARG(Folder, ppsdf));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(*ppsdf, _punkSite);
                if (_dwSafetyOptions)
                {
                    hr = MakeSafeForScripting((IUnknown**)ppsdf);
                }
            }
            ILFree(pidl);
        }
        else
            hr = S_FALSE; // bad dir
    }
    return hr;
}

STDMETHODIMP CShellDispatch::IsRestricted(BSTR Group, BSTR Restriction, long * lpValue)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        if (lpValue) 
            *lpValue = SHGetRestriction(NULL, Group, Restriction);
    }
    return hr;
}

STDMETHODIMP CShellDispatch::ShellExecute(BSTR File, VARIANT vArgs, VARIANT vDir, VARIANT vOperation, VARIANT vShow)
{
    SHELLEXECUTEINFO sei = {sizeof(SHELLEXECUTEINFO)};  
    TCHAR szFile[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szOper[128];  // don't think any verb longer than this...

    // Check to see if we allow the user to do this...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        // Initialize the shellexecute structure...

        sei.nShow = SW_SHOWNORMAL;

        // Ok setup the FileName.
        SHUnicodeToTChar(File, szFile, ARRAYSIZE(szFile));
        sei.lpFile = szFile;

        // Now the Args
        sei.lpParameters = VariantToStr(&vArgs, NULL, 0);
        sei.lpDirectory = VariantToStr(&vDir, szDir, ARRAYSIZE(szDir));
        sei.lpVerb = VariantToStr(&vOperation, szOper, ARRAYSIZE(szOper));

        // Finally the show -- Could use convert, but that takes 3 calls...
        if (vShow.vt == (VT_BYREF|VT_VARIANT) && vShow.pvarVal)
            vShow = *vShow.pvarVal;
        switch (vShow.vt)
        {
        case VT_I2:
            sei.nShow = (int)vShow.iVal;
            break;

        case VT_I4:
            sei.nShow = (int)vShow.lVal;
        }

        hr = ShellExecuteEx(&sei) ? NOERROR : S_FALSE;

        // Cleanup anything we allocated
        if (sei.lpParameters)
            LocalFree((HLOCAL)sei.lpParameters);
    }
    return hr;
}

//
// These next few methods deal with NT services in general, and the
// Content Indexing Service in particular, so they're stubbed out
// to return E_NOTIMPL on Win9x.
//

//
// Helper function for ServiceStart and ServiceStop
//
VARIANT_BOOL CShellDispatch::_ServiceStartStop(BSTR ServiceName, BOOL fStart, BOOL fPersistent)
{
    VARIANT_BOOL fRetVal = VARIANT_FALSE;
#ifdef WINNT
    SC_HANDLE hSc = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSc) 
    {
        SC_HANDLE hSvc = OpenServiceW(hSc, ServiceName, 
            (fStart ? SERVICE_START : SERVICE_STOP) | (fPersistent ? SERVICE_CHANGE_CONFIG : 0));
        if (hSvc) 
        {
            if (fPersistent) 
            {
                ChangeServiceConfig(hSvc, SERVICE_NO_CHANGE,
                    (fStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START),
                    SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            }

            if (fStart) 
            {
                if (StartService(hSvc, 0, NULL))
                    fRetVal = VARIANT_TRUE;
            }
            else 
            {
                SERVICE_STATUS ServiceStatus;
                if (ControlService(hSvc, SERVICE_CONTROL_STOP, &ServiceStatus))
                    fRetVal = VARIANT_TRUE;
            }
            CloseServiceHandle(hSvc);
        }
        CloseServiceHandle(hSc);
    }
#endif  // WINNT
    return fRetVal;
}

STDMETHODIMP CShellDispatch::ServiceStart(BSTR ServiceName, VARIANT Persistent, VARIANT *pSuccess)
{
    // Check to see if we allow the user to do this...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        if (VT_BOOL != Persistent.vt)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            VariantClear(pSuccess);
            pSuccess->vt = VT_BOOL;
            pSuccess->boolVal = _ServiceStartStop(ServiceName, TRUE, Persistent.boolVal);
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::ServiceStop(BSTR ServiceName, VARIANT Persistent, VARIANT *pSuccess)
{
    // Check to see if we allow the user to do this...
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        if (VT_BOOL != Persistent.vt)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            VariantClear(pSuccess);
            pSuccess->vt = VT_BOOL;
            pSuccess->boolVal = _ServiceStartStop(ServiceName, FALSE, Persistent.boolVal);
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::IsServiceRunning(BSTR ServiceName, VARIANT *pIsRunning)
{
    VariantClear(pIsRunning);

    pIsRunning->vt = VT_BOOL;
    pIsRunning->boolVal = VARIANT_FALSE;

    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        SC_HANDLE hSc = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (hSc) 
        {
            SC_HANDLE hSvc = OpenService(hSc, ServiceName, SERVICE_QUERY_STATUS);
            if (hSvc) 
            {
                SERVICE_STATUS ServiceStatus;

                if (QueryServiceStatus(hSvc, &ServiceStatus)) 
                {
                    switch (ServiceStatus.dwCurrentState) 
                    {
                    case SERVICE_START_PENDING:
                    case SERVICE_RUNNING:
                    case SERVICE_CONTINUE_PENDING:
                        pIsRunning->boolVal = VARIANT_TRUE;
                        break;
                    }
                }
                CloseServiceHandle(hSvc);
            }
            CloseServiceHandle(hSc);
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::CanStartStopService(BSTR ServiceName, VARIANT *pCanStartStop)
{
    VariantClear(pCanStartStop);

    pCanStartStop->vt = VT_BOOL;
    pCanStartStop->boolVal = VARIANT_FALSE;

    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        SC_HANDLE hSc = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (hSc) 
        {
            SC_HANDLE hSvc = OpenService(hSc, ServiceName, SERVICE_START | SERVICE_STOP | SERVICE_CHANGE_CONFIG);
            if (hSvc) 
            {
                pCanStartStop->boolVal = VARIANT_TRUE;
                CloseServiceHandle(hSvc);
            }
            else
            {
                DWORD dwErr = GetLastError();
            }
            CloseServiceHandle(hSc);
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::ShowBrowserBar(BSTR bstrClsid, VARIANT varShow, VARIANT *pSuccess)
{
    if (!(bstrClsid && *bstrClsid && pSuccess))
        return E_INVALIDARG ;

    pSuccess->vt      = VT_BOOL ;
    pSuccess->boolVal = VARIANT_FALSE ;

    IWebBrowser2* pb2;
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_QueryServiceForWebBrowserApp(_punkSite, IID_PPV_ARG(IWebBrowser2, &pb2));
        if (SUCCEEDED(hr))
        {
            VARIANT varGuid;
            VARIANT varNil = {0};
    
            varGuid.vt      = VT_BSTR ;
            varGuid.bstrVal = bstrClsid ;

            hr = pb2->ShowBrowserBar(&varGuid, &varShow, &varNil) ;
        
            if (SUCCEEDED(hr)) 
                pSuccess->boolVal = VARIANT_TRUE;
    
            pb2->Release();
        }
    }
    return hr;
}

HWND CShellDispatch::_GetWindow()
{
    HWND hwnd = NULL;

    // NOTE: very container specific, but works in .HTM pages. generalize for other
    // containers. note that this is not a OLE Control, so we don't have a client
    // site. jscript is typically the provider of _punkSite.

    IShellBrowser* psb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb)))) 
    {
        IUnknown_GetWindow(psb, &hwnd);
        psb->Release();
    }
    return hwnd;
}

// NOTICE:
//      the hwnd param is bogus, no script/vb client has access to this. pass 0 and this
//      code will compute this from the site.

STDMETHODIMP CShellDispatch::BrowseForFolder(long hwnd, BSTR Title, long Options, 
        VARIANT vRoot, Folder **ppsdf)
{
    *ppsdf = NULL;

    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        BROWSEINFO bi = {0};

        TCHAR szTitle[MAX_PATH];
        SHUnicodeToTChar(Title, szTitle, ARRAYSIZE(szTitle));
        bi.lpszTitle = szTitle;
        bi.hwndOwner = hwnd ? (HWND)LongToHandle(hwnd) : _GetWindow();
        bi.ulFlags = (ULONG)Options | BIF_NEWDIALOGSTYLE | BIF_NOTRANSLATETARGETS;
        bi.pidlRoot = VariantToIDList(&vRoot);

        // REVIEW: need to do IUnknown_EnableModeless() around here
        LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
        if (pidl)
        {
            hr = CFolder_Create(NULL, pidl, NULL, IID_PPV_ARG(Folder, ppsdf));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(*ppsdf, _punkSite);
                if (_dwSafetyOptions)
                {
                    hr = MakeSafeForScripting((IUnknown**)ppsdf);
                }
            }
            ILFree(pidl);
        }
        else
            hr = S_FALSE;     // Not a strong error (might be user cancel)

        ILFree((LPITEMIDLIST)bi.pidlRoot);  // NULL accepted
    }

    return hr;
}

STDMETHODIMP CShellDispatch::ControlPanelItem(BSTR bszDir)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        SHRunControlPanel(bszDir, NULL);
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP CShellDispatch::MinimizeAll(void)
{
    return _TrayCommand(IDM_MINIMIZEALL);
}

STDMETHODIMP CShellDispatch::UndoMinimizeALL(void)
{
    return _TrayCommand(IDM_UNDO);
}

STDMETHODIMP CShellDispatch::FileRun(void)
{
    return _TrayCommand(IDM_FILERUN);
}

STDMETHODIMP CShellDispatch::CascadeWindows(void)
{
    return _TrayCommand(IDM_CASCADE);
}

STDMETHODIMP CShellDispatch::TileVertically(void)
{
    return _TrayCommand(IDM_VERTTILE);
}

STDMETHODIMP CShellDispatch::TileHorizontally(void)
{
    return _TrayCommand(IDM_HORIZTILE);
}

STDMETHODIMP CShellDispatch::ShutdownWindows(void)
{
    return _TrayCommand(IDM_EXITWIN);
}

STDMETHODIMP CShellDispatch::Suspend(void)
{
    return _TrayCommand(IDM_SUSPEND);
}

STDMETHODIMP CShellDispatch::EjectPC(void)
{
    return _TrayCommand(IDM_EJECTPC);
}

STDMETHODIMP CShellDispatch::SetTime(void)
{
    return _TrayCommand(IDM_SETTIME);
}

STDMETHODIMP CShellDispatch::TrayProperties(void)
{
    return _TrayCommand(IDM_TRAYPROPERTIES);
}

STDMETHODIMP CShellDispatch::Help(void)
{
    return _TrayCommand(IDM_HELPSEARCH);
}

STDMETHODIMP CShellDispatch::FindFiles(void)
{
    return _TrayCommand(FCIDM_FINDFILES);
}

STDMETHODIMP CShellDispatch::FindComputer(void)
{
    return _TrayCommand(FCIDM_FINDCOMPUTER);
}

STDMETHODIMP CShellDispatch::RefreshMenu(void)
{
    return _TrayCommand(FCIDM_REFRESH);
}

STDMETHODIMP CShellDispatch::ToggleDesktop(void)
{
    return _TrayCommand(IDM_TOGGLEDESKTOP);
}


STDMETHODIMP CShellDispatch::Windows(IDispatch **ppid)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        // Note: CLSID_ShellWindows does not support IObjectSafety.
        hr = CoCreateInstance(CLSID_ShellWindows, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IDispatch, ppid));
    }
    return hr;
}


//
// the "FindPrinter" method on the application object invokes the DS query to find a printer given
// the name, location and model.  Because the query UI is a blocking API we spin this onto a seperate
// thread before calling "OpenQueryWindow".
//

typedef struct 
{
    LPWSTR pszName;
    LPWSTR pszLocation;
    LPWSTR pszModel;
} FINDPRINTERINFO;

void _FreeFindPrinterInfo(FINDPRINTERINFO *pfpi)
{
    if (pfpi)
    {
        Str_SetPtrW(&pfpi->pszName, NULL);
        Str_SetPtrW(&pfpi->pszLocation, NULL);
        Str_SetPtrW(&pfpi->pszModel, NULL);
        LocalFree(pfpi);               // free the parameters we were given
    }
}

HRESULT _GetPrintPropertyBag(FINDPRINTERINFO *pfpi, IPropertyBag **pppb)
{
    HRESULT hr = S_OK;
    IPropertyBag *ppb = NULL;

    // if we have properties that need to be passed then lets package them up
    // into a property bag.

    if (pfpi->pszName || pfpi->pszLocation || pfpi->pszModel)
    {
        hr = SHCreatePropertyBag(IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            if (pfpi->pszName)
                hr = SHPropertyBag_WriteStr(ppb, L"printName", pfpi->pszName);

            if (pfpi->pszLocation && SUCCEEDED(hr))
                hr = SHPropertyBag_WriteStr(ppb, L"printLocation", pfpi->pszLocation);

            if (pfpi->pszModel && SUCCEEDED(hr))
                hr = SHPropertyBag_WriteStr(ppb, L"printModel", pfpi->pszModel);
        }
    }

    if (FAILED(hr) && ppb)
        ppb->Release();
    else
        *pppb = ppb;

    return hr;
}

DWORD WINAPI _FindPrinterThreadProc(void *ptp)
{
    FINDPRINTERINFO *pfpi = (FINDPRINTERINFO*)ptp;

    ICommonQuery *pcq;
    if (SUCCEEDED(CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICommonQuery, &pcq))))
    {
        OPENQUERYWINDOW oqw = { 0 };

        oqw.cbStruct = sizeof(oqw);
        oqw.dwFlags = OQWF_DEFAULTFORM | OQWF_REMOVEFORMS | OQWF_PARAMISPROPERTYBAG;
        oqw.clsidHandler = CLSID_DsQuery;
        oqw.clsidDefaultForm = CLSID_DsFindPrinter;
    
        if (SUCCEEDED(_GetPrintPropertyBag(pfpi, &oqw.ppbFormParameters)))
            pcq->OpenQueryWindow(NULL, &oqw, NULL);

        if (oqw.pFormParameters)
            oqw.ppbFormParameters->Release();

        pcq->Release();
    }

    _FreeFindPrinterInfo(pfpi);

    return 0;
}

STDMETHODIMP CShellDispatch::FindPrinter(BSTR name, BSTR location, BSTR model)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        // bundle the parameters to pass over to the bg thread which will issue the query

        FINDPRINTERINFO *pfpi = (FINDPRINTERINFO*)LocalAlloc(LPTR, sizeof(FINDPRINTERINFO));
        if (!pfpi)
            return E_OUTOFMEMORY;

        if (Str_SetPtrW(&pfpi->pszName, name) && 
             Str_SetPtrW(&pfpi->pszLocation, location) && 
             Str_SetPtrW(&pfpi->pszModel, model))
        {
            if (SHCreateThread(_FindPrinterThreadProc, pfpi, CTF_PROCESS_REF | CTF_COINIT, NULL))
            {
                pfpi = NULL;            // thread owns
            }
        }

        // either close the thread handle, or release the parameter block.   we assume
        // that if the thread was created it will handle discarding the block.

        if (pfpi)
            _FreeFindPrinterInfo(pfpi);
    }
    return hr;
}

STDMETHODIMP CShellDispatch::GetSystemInformation(BSTR bstrName, VARIANT * pvOut)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        SHUnicodeToTChar(bstrName, szName, ARRAYSIZE(szName));

        if (!lstrcmpi(szName, TEXT("DirectoryServiceAvailable")))
        {
            pvOut->vt = VT_BOOL;
            V_BOOL(pvOut) = GetEnvironmentVariable(TEXT("USERDNSDOMAIN"), NULL, 0) > 0;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("DoubleClickTime")))
        {
            pvOut->vt = VT_UI4;
            V_UI4(pvOut) = GetDoubleClickTime();
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("ProcessorLevel")))
        {
            SYSTEM_INFO info;
            GetSystemInfo(&info);
            pvOut->vt = VT_I4;
            V_UI4(pvOut) = info.wProcessorLevel;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("ProcessorSpeed")))
        {
            HKEY hkey;
            if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                              TEXT("Hardware\\Description\\System\\CentralProcessor\\0"), 
                                              0, KEY_QUERY_VALUE, &hkey))
            {
                hr = E_FAIL;
            }
            else
            {
                DWORD dwValue = 0;
                DWORD cb = sizeof(dwValue);

                if (ERROR_SUCCESS != SHQueryValueEx(hkey, TEXT("~Mhz"), NULL, NULL, (LPBYTE) &dwValue, &cb) == ERROR_SUCCESS) 
                {       
                    RegCloseKey(hkey);
                    hr = E_FAIL;
                }
                else
                {
                    RegCloseKey(hkey);
                    pvOut->vt = VT_I4;
                    V_UI4(pvOut) = dwValue;
                    hr = S_OK;
                }
            }
        }
        else if (!lstrcmpi(szName, TEXT("ProcessorArchitecture")))
        {
            SYSTEM_INFO info;
            GetSystemInfo(&info);
            pvOut->vt = VT_I4;
            V_UI4(pvOut) = info.wProcessorArchitecture;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("PhysicalMemoryInstalled")))
        {
            MEMORYSTATUSEX MemoryStatus;
            MemoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
            GlobalMemoryStatusEx(&MemoryStatus);
            pvOut->vt = VT_R8;
            V_R8(pvOut) = (double)(signed __int64) MemoryStatus.ullTotalPhys;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("IsOS_Professional"))) 
        {
            pvOut->vt = VT_BOOL;
            V_BOOL(pvOut) = IsOS(OS_PROFESSIONAL) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("IsOS_Personal")))
        {
            pvOut->vt = VT_BOOL;
            V_BOOL(pvOut) = IsOS(OS_PERSONAL) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else if (!lstrcmpi(szName, TEXT("IsOS_DomainMember")))
        {
            pvOut->vt = VT_BOOL;
            V_BOOL(pvOut) = IsOS(OS_DOMAINMEMBER) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::AddToRecent(VARIANT varFile, BSTR bstrCategory)
{
    // BUGBUG: ignore bstrCategory (daviddv 8/20/99)
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = VariantToIDList(&varFile);
        if (!pidl)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            SHAddToRecentDocs(SHARD_PIDL, pidl);
            ILFree(pidl);
        }
    }
    return hr;
}

STDMETHODIMP CShellDispatch::WindowsSecurity()
{
    return _TrayCommand(IDM_MU_SECURITY);
}


#define REGSTR_POLICIES_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

STDMETHODIMP CShellDispatch::ExplorerPolicy(BSTR bstrName, VARIANT *pValue)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        DWORD dwType;
        TCHAR szName[MAX_PATH];
        BYTE abData[MAX_PATH];
        DWORD cbData = ARRAYSIZE(abData);
    
        SHUnicodeToTChar(bstrName, szName, ARRAYSIZE(szName));

        if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_POLICIES_EXPLORER,
                                             szName,
                                             &dwType,
                                             (LPVOID) abData,
                                             &cbData,
                                             FALSE,
                                             (LPVOID) NULL,
                                             0))
        {                                         
            switch(dwType)
            {
                case REG_SZ:
                case REG_EXPAND_SZ:
                    hr = InitVariantFromStr(pValue, (LPCTSTR) abData);
                    break;
            
                case REG_DWORD:
                    pValue->vt = VT_I4; // 4 byte integer
                    pValue->lVal = *((LONG *) abData);
                    hr = S_OK;
                    break;
            }        
        }
    }
    return hr;    
}

//
//  Mapping between settings and corresponding bitfields.
//
typedef struct SETTINGMAPPING {
    LONG    lSetting;               // SSF_* flag
    LONG    lFlag;                  // bit position
    SIZE_T  cbOffset;               // offset to bit
} SETTINGMAPPING;
typedef const SETTINGMAPPING *PCSETTINGMAPPING;

//
//  Most annoying: Our bitfields are split in two groups.
//
#define GROUP0              0
#define GROUP1              (FIELD_OFFSET(SHELLSTATE, uNotUsed) + sizeof(UINT))

//
//  This table is generated by hand by counting up the BITBOOL's in the
//  SHELLSTATE structure.  Be careful, since they don't agree with the
//  BITBOOLs in the SHELLFLAGSTATE structure, nor do they even agree
//  with the SSF_ values themselves!  Since this so error-prone, there
//  is bonus code in DEBUG to verify that the values are correct.
//
const SETTINGMAPPING c_rglSettingMapping[] = {
    {   SSF_SHOWALLOBJECTS         ,0x00000001 ,GROUP0      },
    {   SSF_SHOWEXTENSIONS         ,0x00000002 ,GROUP0      },
//      SSF_HIDDENFILEEXTS                                      -- not supported
    {   SSF_SHOWCOMPCOLOR          ,0x00000010 ,GROUP0      },
//      SSF_SORTCOLUMNS                                         -- not supported
    {   SSF_SHOWSYSFILES           ,0x00000008 ,GROUP0      },
    {   SSF_DOUBLECLICKINWEBVIEW   ,0x00000020 ,GROUP0      },
    {   SSF_SHOWATTRIBCOL          ,0x00000200 ,GROUP0      },
    {   SSF_DESKTOPHTML            ,0x00000040 ,GROUP0      },
    {   SSF_WIN95CLASSIC           ,0x00000080 ,GROUP0      },
    {   SSF_DONTPRETTYPATH         ,0x00000100 ,GROUP0      },
    {   SSF_SHOWINFOTIP            ,0x00000800 ,GROUP0      },
    {   SSF_MAPNETDRVBUTTON        ,0x00000400 ,GROUP0      },
    {   SSF_NOCONFIRMRECYCLE       ,0x00000004 ,GROUP0      },
    {   SSF_HIDEICONS              ,0x00001000 ,GROUP0      },
    {   SSF_FILTER                 ,0x00004000 ,GROUP0      },
    {   SSF_WEBVIEW                ,0x00002000 ,GROUP0      },
    {   SSF_SHOWSUPERHIDDEN        ,0x00008000 ,GROUP0      },
    {   SSF_SEPPROCESS             ,0x00000001 ,GROUP1      },
    {   SSF_NONETCRAWLING          ,0x00010000 ,GROUP0      },
    {   SSF_STARTPANELON           ,0x00000002 ,GROUP1      },
    {   SSF_SHOWSTARTPAGE          ,0x00000004 ,GROUP1      },
};

#ifdef DEBUG
//  Verify that the above table is correct

STDAPI_(void) _SetSettingFlag(SHELLSTATE *pss, LONG ssf)
{
    int i;
    for (i = 0; i < ARRAYSIZE(c_rglSettingMapping); i++)
    {
        if (c_rglSettingMapping[i].lSetting == ssf) {
            LPDWORD pdw = (LPDWORD)((LPBYTE)pss + c_rglSettingMapping[i].cbOffset);
            // Flag shouldn't be set yet; if it is, then there is a conflict in the table
            ASSERT(!(*pdw & c_rglSettingMapping[i].lFlag));
            *pdw |= c_rglSettingMapping[i].lFlag;
            return;
        }
    }

    TraceMsg(TF_ERROR, "SSF flag %08x not in c_rglSettingMapping table", ssf);
}

#define _CheckSetting(ssf, field) \
    ASSERT(!ss.field);            \
    _SetSettingFlag(&ss, ssf);    \
    ASSERT(ss.field);             \

STDAPI_(void) _VerifyDispatchGetSetting()
{
    // Make sure the group offsets are DWORD-aligned since we use them
    // to suck out a dword.  If these asserts fire, then you will have to
    // change the table to use bytes instead of dwords.
    COMPILETIME_ASSERT(GROUP0 % sizeof(DWORD) == 0);
    COMPILETIME_ASSERT(GROUP1 % sizeof(DWORD) == 0);

    SHELLSTATE ss = { 0 };
    _CheckSetting(SSF_SHOWALLOBJECTS,       fShowAllObjects);
    _CheckSetting(SSF_SHOWEXTENSIONS,       fShowExtensions);
    _CheckSetting(SSF_SHOWCOMPCOLOR,        fShowCompColor);
    _CheckSetting(SSF_SHOWSYSFILES,         fShowSysFiles);
    _CheckSetting(SSF_DOUBLECLICKINWEBVIEW, fDoubleClickInWebView);
    _CheckSetting(SSF_SHOWATTRIBCOL,        fShowAttribCol);
    _CheckSetting(SSF_DESKTOPHTML,          fDesktopHTML);
    _CheckSetting(SSF_WIN95CLASSIC,         fWin95Classic);
    _CheckSetting(SSF_DONTPRETTYPATH,       fDontPrettyPath);
    _CheckSetting(SSF_SHOWINFOTIP,          fShowInfoTip);
    _CheckSetting(SSF_MAPNETDRVBUTTON,      fMapNetDrvBtn);
    _CheckSetting(SSF_NOCONFIRMRECYCLE,     fNoConfirmRecycle);
    _CheckSetting(SSF_HIDEICONS,            fHideIcons);
    _CheckSetting(SSF_FILTER,               fFilter);
    _CheckSetting(SSF_WEBVIEW,              fWebView);
    _CheckSetting(SSF_SHOWSUPERHIDDEN,      fShowSuperHidden);
    _CheckSetting(SSF_SEPPROCESS,           fSepProcess);
    _CheckSetting(SSF_NONETCRAWLING,        fNoNetCrawling);
    _CheckSetting(SSF_STARTPANELON,         fStartPanelOn);
    _CheckSetting(SSF_SHOWSTARTPAGE,        fShowStartPage);

    // Now make sure that every setting was checked
    int i;
    for (i = 0; i < ARRAYSIZE(c_rglSettingMapping); i++)
    {
        LPDWORD pdw = (LPDWORD)((LPBYTE)&ss + c_rglSettingMapping[i].cbOffset);
        ASSERT(*pdw & c_rglSettingMapping[i].lFlag);
    }
}

#undef _CheckSetting
#endif // DEBUG


STDMETHODIMP CShellDispatch::GetSetting(long lSetting, VARIANT_BOOL *pValue)
{
    HRESULT hr = _SecurityCheck();
    if (SUCCEEDED(hr))
    {
        BOOL bDone = FALSE;
        int i;
        for (i = 0; i < ARRAYSIZE(c_rglSettingMapping); i++)
        {
            if (lSetting == c_rglSettingMapping[i].lSetting)
            {
                SHELLSTATE ss = { 0 };
                SHGetSetSettings(&ss, lSetting, FALSE);
                LPDWORD pdw = (LPDWORD)((LPBYTE)&ss + c_rglSettingMapping[i].cbOffset);
                *pValue = (*pdw & c_rglSettingMapping[i].lFlag) ? VARIANT_TRUE : VARIANT_FALSE;
                bDone = TRUE;
                break;
            }
        }

        if (!bDone)
        {
            if (lSetting == SSF_SERVERADMINUI)
            {
                *pValue = IsOS(OS_SERVERADMINUI) ? VARIANT_TRUE : VARIANT_FALSE;
            }
            else
            {
                // Unsupported settings result in VARIANT_FALSE for forwards compatibility
                *pValue = VARIANT_FALSE;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\admovr2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Apr 03 11:59:43 1997
 */
/* Compiler settings for ADMover.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ADMover_h__
#define __ADMover_h__

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ADMOVERLib_LIBRARY_DEFINED__
#define __ADMOVERLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ADMOVERLib
 * at Thu Apr 03 11:59:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 

#ifdef __cplusplus
class DECLSPEC_UUID("72267F6A-A6F9-11D0-BC94-00C04FB67863")
DeskMovr;
#endif


#endif /* __ADMOVERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#ifndef __ADMOVR2__
#define __ADMOVR2__

#include "mshtml.h"
#include "mshtmdid.h"

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#ifdef __cplusplus

#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp

#define NEW_HIT_TEST

interface DECLSPEC_UUID("72267F69-A6F9-11D0-BC94-00C04FB67863")
IDeskMovr : public IUnknown
{
public:        
};
    
#endif

#define OLEMISMOVR (OLEMISC_ALWAYSRUN|OLEMISC_NOUIACTIVATE|OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT)
EXTERN_C void PersistTargetPosition( IHTMLElement *pielem,
                            int left,
                            int top,
                            int width,
                            int height,
                            int zIndex,
                            BOOL fSaveRestore,
                            BOOL fSaveOriginal,
                            DWORD dwNewState);

#endif // __ADMOVR2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\adjust.cpp ===
#include "stdafx.h"
#pragma hdrstop

//  98/10/02 vtan: Multiple monitor bug fixes.

//  Given an old monitor layout, a new monitor layout and a component
//  this function makes sure that it is in the new layout using a
//  monitor relative scheme. It tries to preserve the position
//  relatively within a given monitor. If the resolution of the monitor
//  changes then this needs to be accounted for also.

//  Preserve the component within a given monitor if the monitor is the
//  same HMONITOR but the GDI co-ordinates change.

//  If the same monitor cannot be located then move the component to the
//  nearest monitor and position it as best on that monitor.

//  If all else fails then use the default component positioning
//  algorithm. This should never happen.

//  Preserve the component within a given monitor if the resolution
//  changes. Preserve the size of the component by MOVING the component
//  in the X and Y axis until the left or the top of the monitor is
//  reached. When either axis reaches 0 then reduce the size of the
//  component until it fits within the given new resolution.

static  const   int     kNameSize = 16;

typedef struct
{
    HMONITOR    miHMONITOR;
    RECT        miDisplayAreaRect,
                miWorkAreaRect;
} tMonitorInfoRec, *tMonitorInfoPtr;

typedef struct
{
    int                 miaCount, miaIndex;
    RECT                miaVirtualScreen;
    tMonitorInfoRec     miaMonitors[1];
} tMonitorInfoArrayRec, *tMonitorInfoArrayPtr;

typedef struct
{
    BOOL            ciValidData, ciVisible, ciRepositioned;
    TCHAR           ciName[kNameSize];      // this is not excessive but limited
    DWORD           ciItemState;
    int             ciType;
    COMPPOS         ciPosition;
    COMPSTATEINFO   ciStateInfo;
} tComponentInfoRec, *tComponentInfoPtr;

static  tMonitorInfoArrayPtr    gOldMonitorArray = NULL;
static  tMonitorInfoArrayPtr    gNewMonitorArray = NULL;

//  Functions located in Dutil.cpp used for co-ordinate mapping.

void    SetPt (POINT& pt, LONG x, LONG y);
void    OffsetPt (POINT& pt, LONG dh, LONG dv);
void    CalculateVirtualScreen (RECT& virtualScreen);

//  Local function prototypes.

BOOL    CALLBACK    MonitorCountEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data);
BOOL    CALLBACK    MonitorCalculateEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data);
HRESULT CalculateCurrentMonitorArray(void);
void    ApplyCurrentMonitorArray (void);
int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, HMONITOR hMonitor);
int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, POINT& pt);
int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, RECT& rc);
BOOL    RepositionDesktopRect (RECT& rcComponent, tMonitorInfoArrayPtr oldMonitorArray, tMonitorInfoArrayPtr newMonitorArray);
BOOL    RepositionDesktopComponent (COMPPOS& componentPosition, COMPSTATEINFO& componentStateInfo, DWORD dwItemState);
BOOL    ReadAllComponents (HKEY hKeyDesktop, tComponentInfoPtr& pComponentInfo, DWORD& dwComponentCount);
void    WriteAllComponents (HKEY hKeyDesktop, tComponentInfoPtr pComponentInfo, DWORD dwComponentCount);

BOOL    CALLBACK    MonitorCountEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data)

//  Count the number of monitors attached to the system.

{
    int     *iCounter;

    iCounter = reinterpret_cast<int*>(data);
    ++(*iCounter);
    return(TRUE);
}

BOOL    CALLBACK    MonitorCalculateEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data)

//  Store each monitor HMONITOR and dimensions in the array.

{
    tMonitorInfoArrayPtr    monitorArray;
    MONITORINFO             monitorInfo;

    monitorArray = reinterpret_cast<tMonitorInfoArrayPtr>(data);
    monitorInfo.cbSize = sizeof(monitorInfo);
    // adding monitors in the space of a few nanoseconds isnt a real attack vector, but double-check
    // against the size of the array we allocated
    if ((GetMonitorInfo(hMonitor, &monitorInfo) != 0) && (monitorArray->miaIndex < monitorArray->miaCount))
    {
        tMonitorInfoPtr     pMI;

        pMI = &monitorArray->miaMonitors[monitorArray->miaIndex++];
        pMI->miHMONITOR = hMonitor;
        TBOOL(CopyRect(&pMI->miDisplayAreaRect, &monitorInfo.rcMonitor));
        TBOOL(CopyRect(&pMI->miWorkAreaRect, &monitorInfo.rcWork));
    }
    return(TRUE);
}

HRESULT CalculateCurrentMonitorArray(void)

//  Allocate and fill the monitor rectangle array.

{
    HRESULT hr = E_OUTOFMEMORY;
    int     iCount;

    iCount = 0;
    TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCountEnumProc, reinterpret_cast<LPARAM>(&iCount)));
    gNewMonitorArray = reinterpret_cast<tMonitorInfoArrayPtr>(LocalAlloc(LMEM_FIXED, sizeof(tMonitorInfoArrayRec) + ((iCount - 1) * sizeof(tMonitorInfoRec))));

    if (gNewMonitorArray)
    {
        gNewMonitorArray->miaCount = iCount;
        gNewMonitorArray->miaIndex = 0;
        CalculateVirtualScreen(gNewMonitorArray->miaVirtualScreen);
        TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCalculateEnumProc, reinterpret_cast<LPARAM>(gNewMonitorArray)));

        hr = S_OK;
    }

    return hr;
}

void    ApplyCurrentMonitorArray (void)

//  Discard the old and save the new as current monitor
//  rectangle array for the next time the function is called.

{
    if (gOldMonitorArray != NULL)
        (HLOCAL)LocalFree(gOldMonitorArray);
    gOldMonitorArray = gNewMonitorArray;
    gNewMonitorArray = NULL;
}

//  These functions determine the index into the monitor
//  rectangle array of a given HMONITOR, POINT or RECT.

int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, HMONITOR hMonitor)

{
    int                 i, iLimit, iResult;
    tMonitorInfoPtr     pMI;

    iResult = -1;
    for (i = 0, iLimit = pMIA->miaCount, pMI = pMIA->miaMonitors; i < iLimit; ++i, ++pMI)
    {
        if (pMI->miHMONITOR == hMonitor)
        {
            iResult = i;
            break;
        }
    }
    return(iResult);
}

//  Note that the functions that take a POINT or RECT
//  require the co-ordinates to be in TRIDENT co-ordinates.

int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, POINT& pt)

{
    int                 i, iLimit, iResult;
    tMonitorInfoPtr     pMI;
    POINT               ptLocal;

    ptLocal = pt;
    OffsetPt(ptLocal, +pMIA->miaVirtualScreen.left, +pMIA->miaVirtualScreen.top);
    iResult = -1;
    for (i = 0, iLimit = pMIA->miaCount, pMI = pMIA->miaMonitors; i < iLimit; ++i, ++pMI)
    {
        if (PtInRect(&pMI->miDisplayAreaRect, ptLocal) != 0)
        {
            iResult = i;
            break;
        }
    }
    return(iResult);
}

int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, RECT& rc)

{
    int     iResult;
    POINT   pt;

    // 99/05/12 #338446 vtan: Try all four corners of the rectangle
    // to find a match.

    pt.x = rc.left;
    pt.y = rc.top;
    iResult = IndexOfMonitor(pMIA, pt);
    if (iResult < 0)
    {
        pt.x = rc.left;
        pt.y = rc.bottom;
        iResult = IndexOfMonitor(pMIA, pt);
        if (iResult < 0)
        {
            pt.x = rc.right;
            pt.y = rc.top;
            iResult = IndexOfMonitor(pMIA, pt);
            if (iResult < 0)
            {
                pt.x = rc.right;
                pt.y = rc.bottom;
                iResult = IndexOfMonitor(pMIA, pt);
            }
        }
    }
    return(iResult);
}

int     IndexOfMonitor (tMonitorInfoArrayPtr pMIA, COMPPOS& componentPosition)

{
    RECT    rcComponent;

    TBOOL(SetRect(&rcComponent, componentPosition.iLeft, componentPosition.iTop, componentPosition.iLeft + componentPosition.dwWidth, componentPosition.iTop + componentPosition.dwHeight));
    return(IndexOfMonitor(pMIA, rcComponent));
}

BOOL    RepositionDesktopRect (RECT& rcComponent, tMonitorInfoArrayPtr oldMonitorArray, tMonitorInfoArrayPtr newMonitorArray)

//  Reposition the component's RECT based on the logic at the
//  top of the source file. Used for both the component's
//  current position and the restored position.

{
    BOOL    bRepositionedComponent;
    int     iOldMonitorIndex, iNewMonitorIndex;

    // This is for future expansion. The components are always
    // deemed to be repositioned if this function is called.

    bRepositionedComponent = TRUE;

    // Find out if the monitor which the component was on is still
    // present. To do this find the index of the component in the
    // old monitor array, get the HMONITOR and find that in the new
    // monitor array.

    iOldMonitorIndex = IndexOfMonitor(oldMonitorArray, rcComponent);
    if (iOldMonitorIndex >= 0)
    {
        RECT    *prcOldMonitor, *prcNewMonitor;

        iNewMonitorIndex = IndexOfMonitor(newMonitorArray, oldMonitorArray->miaMonitors[iOldMonitorIndex].miHMONITOR);
        if (iNewMonitorIndex < 0)
        {
            HMONITOR    hMonitor;

            // The component is on a monitor that no longer exists. The only
            // thing to do in this case is to find the nearest monitor based
            // on the GDI co-ordinates and position it on that monitor.

            hMonitor = MonitorFromRect(&rcComponent, MONITOR_DEFAULTTONEAREST);
            iNewMonitorIndex = IndexOfMonitor(newMonitorArray, hMonitor);
            ASSERT(iNewMonitorIndex >= 0);
        }

        // If iNewMonitorIndex was already positive then the monitor which
        // the component was on still exists and simply mapping GDI
        // co-ordinates will work. Otherwise we found the nearest monitor
        // and mapping GDI co-ordinates also works!

        // This maps from the component's OLD co-ordinates in trident
        // co-ordinates to GDI co-ordinates. Then it maps from the GDI
        // co-ordinates to an OLD monitor relative co-ordinate. Then it
        // maps from the OLD monitor relative co-ordinates to the NEW
        // monitor GDI co-ordinates.

        prcOldMonitor = &oldMonitorArray->miaMonitors[iOldMonitorIndex].miDisplayAreaRect;
        prcNewMonitor = &newMonitorArray->miaMonitors[iNewMonitorIndex].miDisplayAreaRect;
        TBOOL(OffsetRect(&rcComponent, +oldMonitorArray->miaVirtualScreen.left, +oldMonitorArray->miaVirtualScreen.top));
        TBOOL(OffsetRect(&rcComponent, -prcOldMonitor->left, -prcOldMonitor->top));
        TBOOL(OffsetRect(&rcComponent, +prcNewMonitor->left, +prcNewMonitor->top));
    }
    else
    {

        // Component exists at an invalid location in the old monitor
        // layout. It may be valid in the new layout. Try this. If that
        // doesn't work then it doesn't exist in the old nor the new
        // layout. It was in no-man's land. Position it using the default
        // positioning system.

        iNewMonitorIndex = IndexOfMonitor(newMonitorArray, rcComponent);
        if (iNewMonitorIndex < 0)
        {
            POINT       ptOrigin;
            COMPPOS     componentPosition;

            GetNextComponentPosition(&componentPosition);
            IncrementComponentsPositioned();
            TBOOL(SetRect(&rcComponent, componentPosition.iLeft, componentPosition.iTop, componentPosition.iLeft + componentPosition.dwWidth, componentPosition.iTop + componentPosition.dwHeight));

            // Get the primary monitor index in our monitor rectangle array.

            SetPt(ptOrigin, 0, 0);
            iNewMonitorIndex = IndexOfMonitor(newMonitorArray, MonitorFromPoint(ptOrigin, MONITOR_DEFAULTTOPRIMARY));
            ASSERT(iNewMonitorIndex >= 0);
        }
    }

    // At this stage the component position is in GDI co-ordinates.
    // Convert from GDI co-ordinates back to trident co-ordinates.

    TBOOL(OffsetRect(&rcComponent, -newMonitorArray->miaVirtualScreen.left, -newMonitorArray->miaVirtualScreen.top));

    return(bRepositionedComponent);
}

BOOL    RepositionDesktopComponent (COMPPOS& componentPosition, COMPSTATEINFO& componentStateInfo, DWORD dwItemState, int iComponentType)

{
    BOOL                    bRepositionedComponent;
    tMonitorInfoArrayPtr    oldMonitorArray, newMonitorArray;
    RECT                    rcComponent;

    // Check if the monitor layout has changed. If unchanged then
    // there is no need to move the components.

    oldMonitorArray = gOldMonitorArray;
    newMonitorArray = gNewMonitorArray;
    if (oldMonitorArray == NULL)
    {
        oldMonitorArray = newMonitorArray;
    }

    TBOOL(SetRect(&rcComponent, componentPosition.iLeft, componentPosition.iTop, componentPosition.iLeft + componentPosition.dwWidth, componentPosition.iTop + componentPosition.dwHeight));
    bRepositionedComponent = RepositionDesktopRect(rcComponent, oldMonitorArray, newMonitorArray);
    componentPosition.iLeft = rcComponent.left;
    componentPosition.iTop = rcComponent.top;
    componentPosition.dwWidth = rcComponent.right - rcComponent.left;
    componentPosition.dwHeight = rcComponent.bottom - rcComponent.top;
    ValidateComponentPosition(&componentPosition, dwItemState, iComponentType, NULL, NULL);

    // If the component is zoomed also reposition the restored
    // COMPSTATEINFO.

    if (IsZoomedState(dwItemState))
    {
        COMPPOS     restoredCompPos;

        TBOOL(SetRect(&rcComponent, componentStateInfo.iLeft, componentStateInfo.iTop, componentStateInfo.iLeft + componentStateInfo.dwWidth, componentStateInfo.iTop + componentStateInfo.dwHeight));
        bRepositionedComponent = RepositionDesktopRect(rcComponent, oldMonitorArray, newMonitorArray) || bRepositionedComponent;
        restoredCompPos.iLeft       = componentStateInfo.iLeft      = rcComponent.left;
        restoredCompPos.iTop        = componentStateInfo.iTop       = rcComponent.top;
        restoredCompPos.dwWidth     = componentStateInfo.dwWidth    = rcComponent.right - rcComponent.left;
        restoredCompPos.dwHeight    = componentStateInfo.dwHeight   = rcComponent.bottom - rcComponent.top;
        ZoomComponent(&componentPosition, dwItemState, FALSE);
        restoredCompPos.dwSize = sizeof(restoredCompPos);
        ValidateComponentPosition(&restoredCompPos, IS_NORMAL, iComponentType, NULL, NULL);
    }

    return(bRepositionedComponent);
}

BOOL    ReadAllComponents (HKEY hKeyDesktop, tComponentInfoPtr& pComponentInfo, DWORD& dwComponentCount)

{
    tComponentInfoPtr   pCI;

    if (RegQueryInfoKey(hKeyDesktop, NULL, NULL, NULL, &dwComponentCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        dwComponentCount = 0;
    if (dwComponentCount > 0)
    {

        // 99/08/09 #383184: STRESS fix. Allocate the whole block of
        // memory required for the components but allocate one extra
        // entry. advapi32!RegEnumKeyEx will try to access the memory
        // before determining that there is a failure condition. With
        // pageheap on (and the block allocated at the end of the page)
        // this causes an access violation. The simplest fix is to add
        // an extra entry.

        pComponentInfo = pCI = reinterpret_cast<tComponentInfoPtr>(LocalAlloc(LPTR, (dwComponentCount + 1) * sizeof(*pCI)));      // LMEM_FIXED | LMEM_ZEROINIT
        if (pCI != NULL)
        {
            DWORD   dwIndex, dwSize;

            // Enumerate all the desktop components.

            dwIndex = 0;
            dwSize = sizeof(pCI->ciName);
            while (RegEnumKeyEx(hKeyDesktop, dwIndex, pCI->ciName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                CRegKey     regKeyComponent;

                if (regKeyComponent.Open(hKeyDesktop, pCI->ciName, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
                {
                    DWORD   dwType, cbData;

                    // Read the Position value.

                    cbData = sizeof(pCI->ciPosition);
                    if (SHQueryValueEx(regKeyComponent, REG_VAL_COMP_POSITION, NULL, &dwType, &pCI->ciPosition, &cbData) == ERROR_SUCCESS)
                    {
                        DWORD   dwFlags;

                        pCI->ciValidData = TRUE;
                        if (SHQueryValueEx(regKeyComponent, REG_VAL_COMP_FLAGS, NULL, &dwType, &dwFlags, &cbData) == ERROR_SUCCESS)
                        {
                            pCI->ciVisible = ((dwFlags & COMP_SELECTED) != 0);
                            pCI->ciType = (dwFlags & COMP_TYPE_MASK);
                        }
                        else
                        {
                            pCI->ciVisible = FALSE;
                            pCI->ciType = COMP_TYPE_WEBSITE;
                        }
                        pCI->ciItemState = IS_NORMAL;        // if missing (IE4 machine) or error the assume normal
                        cbData = sizeof(pCI->ciItemState);
                        if ((SHQueryValueEx(regKeyComponent, REG_VAL_COMP_CURSTATE, NULL, &dwType, &pCI->ciItemState, &cbData) == ERROR_SUCCESS))
                        {

                            // If the component is zoomed also read in the COMPSTATEINFO.

                            if (IsZoomedState(pCI->ciItemState))
                            {
                                cbData = sizeof(pCI->ciStateInfo);
                                TW32(SHQueryValueEx(regKeyComponent, REG_VAL_COMP_RESTOREDSTATEINFO, NULL, &dwType, &pCI->ciStateInfo, &cbData));
                            }
                        }
                    }
                }
                ++pCI;
                ++dwIndex;
                dwSize = sizeof(pCI->ciName);
            }
        }
    }
    return((dwComponentCount != 0) && (pComponentInfo != NULL));
}

int     IndexOfComponent (tComponentInfoPtr pComponentInfo, DWORD dwComponentCount, LPCTSTR pcszName)

{
    int     iResult, i;

    for (iResult = -1, i = 0; (iResult < 0) && (i < static_cast<int>(dwComponentCount)); ++i)
    {
        if (lstrcmp(pComponentInfo[i].ciName, pcszName) == 0)
            iResult = i;
    }
    return(iResult);
}

void    WriteAllComponents (HKEY hKeyDesktop, tComponentInfoPtr pComponentInfo, DWORD dwComponentCount)

{
    TCHAR   szSubKeyName[kNameSize];
    DWORD   dwSubKeyIndex, dwSubKeySize;

    // Enumerate all the desktop components.

    dwSubKeyIndex = 0;
    dwSubKeySize = ARRAYSIZE(szSubKeyName);
    while (RegEnumKeyEx(hKeyDesktop, dwSubKeyIndex, szSubKeyName, &dwSubKeySize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        CRegKey     regKeyComponent;

        if (regKeyComponent.Open(hKeyDesktop, szSubKeyName, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
        {
            int     i;

            i = IndexOfComponent(pComponentInfo, dwComponentCount, szSubKeyName);
            if ((i >= 0) && pComponentInfo[i].ciRepositioned)
            {
                TW32(RegSetValueEx(regKeyComponent, REG_VAL_COMP_POSITION, 0, REG_BINARY, reinterpret_cast<const unsigned char*>(&pComponentInfo[i].ciPosition), sizeof(pComponentInfo[i].ciPosition)));
                TW32(RegSetValueEx(regKeyComponent, REG_VAL_COMP_CURSTATE, NULL, REG_BINARY, reinterpret_cast<const unsigned char*>(&pComponentInfo[i].ciItemState), sizeof(pComponentInfo[i].ciItemState)));

                // If the component is zoomed also write out the COMPSTATEINFO.

                if (IsZoomedState(pComponentInfo[i].ciItemState))
                {
                    TW32(RegSetValueEx(regKeyComponent, REG_VAL_COMP_RESTOREDSTATEINFO, 0, REG_BINARY, reinterpret_cast<const unsigned char*>(&pComponentInfo[i].ciStateInfo), sizeof(pComponentInfo[i].ciStateInfo)));
                }
            }
        }
        ++dwSubKeyIndex;
        dwSubKeySize = ARRAYSIZE(szSubKeyName);
    }
}

BOOL    AdjustDesktopComponents (LPCRECT arectNew,
                                 int crectNew,
                                 LPCRECT arectOldMonitors,
                                 LPCRECT arectOld,
                                 int crectOld)

{
    static  const   int kMaximumMonitorCount = 16;
    HRESULT                 hr;
    BOOL                    bRepositionedComponent;
    int                     zoomedComponentIndices[kMaximumMonitorCount];        // 16 monitors limitation here - make dynamic if required
    int                     i;
    tMonitorInfoArrayPtr    oldMonitorArray;
    CRegKey                 regKeyDesktop;
    TCHAR                   szDeskcomp[MAX_PATH];

    for (i = 0; i < kMaximumMonitorCount; ++i)
        zoomedComponentIndices[i] = -1;

    bRepositionedComponent = FALSE;
    hr = CalculateCurrentMonitorArray();
    if (SUCCEEDED(hr))
    {
        oldMonitorArray = gOldMonitorArray;
        if (oldMonitorArray == NULL)
            oldMonitorArray = gNewMonitorArray;
        
        GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);            
        
        if (ERROR_SUCCESS == regKeyDesktop.Open(HKEY_CURRENT_USER, szDeskcomp, KEY_READ))
        {
            DWORD               dwComponentCount;
            tComponentInfoPtr   pComponentInfo;

            // Enumerate all the desktop components.

            if (ReadAllComponents(regKeyDesktop, pComponentInfo, dwComponentCount))
            {
                tComponentInfoPtr   pCI;

                for (pCI = pComponentInfo, i = 0; i < static_cast<int>(dwComponentCount); ++pCI, ++i)
                {
                    int     iPreviousMonitorIndexOfComponent;

                    // Calculate the previous monitor position BEFORE the component
                    // gets repositioned.

                    iPreviousMonitorIndexOfComponent = IndexOfMonitor(oldMonitorArray, pCI->ciPosition);
                    if (RepositionDesktopComponent(pCI->ciPosition, pCI->ciStateInfo, pCI->ciItemState, pCI->ciType))
                    {
                        int     iCurrentMonitorIndexOfComponent;

                        pCI->ciRepositioned = bRepositionedComponent = TRUE;
                        iCurrentMonitorIndexOfComponent = IndexOfMonitor(gNewMonitorArray, pCI->ciPosition);
                        if (iCurrentMonitorIndexOfComponent >= 0)
                        {

                            // 99/05/12 #338446 vtan: Only use a zero or positive index into the
                            // monitor array. -1 is invalid and will cause an AV. This should NEVER
                            // happen but rather than assert this condition is handled.

                            if (IsZoomedState(pCI->ciItemState) && (zoomedComponentIndices[iCurrentMonitorIndexOfComponent] >= 0))
                            {
                                tComponentInfoPtr   pCIToRestore;

                                // This component is zoomed on a monitor that already has a zoomed
                                // component. Compare this component and the component already on the
                                // monitor. The one that was there before is the one that stays. The one
                                // that shouldn't be there is the one that gets restored.

                                if ((iPreviousMonitorIndexOfComponent == iCurrentMonitorIndexOfComponent) && pCI->ciVisible)
                                    pCIToRestore = pComponentInfo + zoomedComponentIndices[iCurrentMonitorIndexOfComponent];
                                else
                                    pCIToRestore = pCI;
                                pCIToRestore->ciPosition.iLeft     = pCIToRestore->ciStateInfo.iLeft;
                                pCIToRestore->ciPosition.iTop      = pCIToRestore->ciStateInfo.iTop;
                                pCIToRestore->ciPosition.dwWidth   = pCIToRestore->ciStateInfo.dwWidth;
                                pCIToRestore->ciPosition.dwHeight  = pCIToRestore->ciStateInfo.dwHeight;
                                pCIToRestore->ciPosition.izIndex   = COMPONENT_TOP;
                                pCIToRestore->ciItemState = IS_NORMAL;
                            }

                            // If the component is zoomed also write out the COMPSTATEINFO.

                            if (IsZoomedState(pCI->ciItemState))
                            {
                                zoomedComponentIndices[iCurrentMonitorIndexOfComponent] = i;
                            }
                        }
                    }
                }
                WriteAllComponents(regKeyDesktop, pComponentInfo, dwComponentCount);
                LocalFree(pComponentInfo);
            }

            if (bRepositionedComponent)
            {
                SHELLSTATE  ss;

                SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);
                SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);

                // Refresh only if AD is turned on.

                if(ss.fDesktopHTML)
                {

                    // 98/09/22 #182982 vtan: Use dynamic HTML by default to refresh.
                    // Only disallow usage when specifically told to by a flag.

                    PokeWebViewDesktop(AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH);
                }
            }
        }
        ApplyCurrentMonitorArray();
    }
    
    return bRepositionedComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\sdspatch\sdspatch.h ===
#ifndef __SHDISP_H__
#define __SHDISP_H__

#ifdef __cplusplus

EXTERN_C GUID g_guidLibSdspatch;
EXTERN_C USHORT g_wMajorVerSdspatch;
EXTERN_C USHORT g_wMinorVerSdspatch;

#define SDSPATCH_TYPELIB g_guidLibSdspatch, g_wMajorVerSdspatch, g_wMinorVerSdspatch

HRESULT MakeSafeForScripting(IUnknown** ppDisp);

class CImpConPtCont;
typedef CImpConPtCont *PCImpConPtCont;

class CConnectionPoint;
typedef CConnectionPoint *PCConnectionPoint;

class CImpISupportErrorInfo;
typedef CImpISupportErrorInfo *PCImpISupportErrorInfo;

class CFolder;

HRESULT GetItemFolder(CFolder *psdfRoot, LPCITEMIDLIST pidl, CFolder **ppsdf);
HRESULT GetObjectSafely(IShellFolderView *psfv, LPCITEMIDLIST *ppidl, UINT iType);

STDAPI CShellDispatch_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);

HRESULT CFolder_Create(HWND hwnd, LPCITEMIDLIST pidl, IShellFolder *psf, REFIID riid, void **ppv);
HRESULT CFolder_Create2(HWND hwnd, LPCITEMIDLIST pidl, IShellFolder *psf, CFolder **psdf);

HRESULT CFolderItems_Create(CFolder *psdf, BOOL fSelected, FolderItems **ppitems);
HRESULT CFolderItemsFDF_Create(CFolder *psdf, FolderItems **ppitems);
HRESULT CFolderItem_Create(CFolder *psdf, LPCITEMIDLIST pidl, FolderItem **ppid);
HRESULT CFolderItem_CreateFromIDList(HWND hwnd, LPCITEMIDLIST pidl, FolderItem **ppid);
HRESULT CShortcut_CreateIDispatch(HWND hwnd, IShellFolder *psf, LPCITEMIDLIST pidl, IDispatch **ppid);
HRESULT CSDWindow_Create(HWND hwndFldr, IDispatch ** ppsw);
HRESULT CFolderItemVerbs_Create(IContextMenu *pcm, FolderItemVerbs **ppid);

//==================================================================
// Folder items need a way back to the folder object so define folder
// object in header file...

class CFolderItem;
class CFolderItems;

class CFolder : public Folder3,
                public IPersistFolder2,
                public CObjectSafety,
                public IShellService,
                protected CImpIDispatch,
                protected CObjectWithSite
{
    friend class CFolderItem;
    friend class CFolderItems;
    friend class CShellFolderView;

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // Folder
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);
    STDMETHODIMP get_ParentFolder(Folder **ppdf);

    STDMETHODIMP get_Title(BSTR * pbs);

    STDMETHODIMP Items(FolderItems **ppid);
    STDMETHODIMP ParseName(BSTR bName, FolderItem **ppid);

    STDMETHODIMP NewFolder(BSTR bName, VARIANT vOptions);
    STDMETHODIMP MoveHere(VARIANT vItem, VARIANT vOptions);
    STDMETHODIMP CopyHere(VARIANT vItem, VARIANT vOptions);
    STDMETHODIMP GetDetailsOf(VARIANT vItem, int iColumn, BSTR * pbs);

    // Folder2
    STDMETHODIMP get_Self(FolderItem **ppfi);
    STDMETHODIMP get_OfflineStatus(LONG *pul);
    STDMETHODIMP Synchronize(void);
    STDMETHODIMP get_HaveToShowWebViewBarricade(VARIANT_BOOL *pbHaveToShowWebViewBarricade);
    STDMETHODIMP DismissedWebViewBarricade();

    // Folder3
    STDMETHODIMP get_ShowWebViewBarricade(VARIANT_BOOL *pbShowWebViewBarricade);
    STDMETHODIMP put_ShowWebViewBarricade(VARIANT_BOOL bShowWebViewBarricade);
    
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // CObjectWithSite overriding
    STDMETHODIMP SetSite(IUnknown *punkSite);

    // IShellService
    STDMETHODIMP SetOwner(IUnknown* punkOwner);

    CFolder(HWND hwnd);
    HRESULT Init(LPCITEMIDLIST pidl, IShellFolder *psf);
    HRESULT InvokeVerbHelper(VARIANT vVerb, VARIANT vArgs, LPCITEMIDLIST *ppidl, int cItems, DWORD dwSafetyOptions);
    HRESULT GetShellFolderView(IShellFolderView **ppsfv);

private:

    LONG            _cRef;
    IShellFolder   *_psf;
    IShellFolder2  *_psf2;
    IShellDetails  *_psd;
    LPITEMIDLIST    _pidl;
    IDispatch      *_pidApp;   // cache app object
    int             _fmt;
    HWND            _hwnd;
    IUnknown        *_punkOwner; // shell objects above this, defview

    ~CFolder();

    // Helper functions, not exported by interface
    STDMETHODIMP _ParentFolder(Folder **ppdf);
    HRESULT _MoveOrCopy(BOOL bMove, VARIANT vItem, VARIANT vOptions);
    IShellDetails *_GetShellDetails(void);
    LPCITEMIDLIST _FolderItemIDList(const VARIANT *pv);
    HRESULT _Application(IDispatch **ppid);
    BOOL _GetBarricadeValueName(LPTSTR pszValueName, UINT cch);
    HRESULT _SecurityCheck();
};

class CFolderItemVerbs;

class CFolderItem : public FolderItem2,
                    public IPersistFolder2,
                    public CObjectSafety,
                    public IParentAndItem,
                    protected CImpIDispatch
{
    friend class CFolderItemVerbs;
public:

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // FolderItem
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);
    STDMETHODIMP get_Name(BSTR *pbs);
    STDMETHODIMP put_Name(BSTR bs);
    STDMETHODIMP get_Path(BSTR *bs);
    STDMETHODIMP get_GetLink(IDispatch **ppid);
    STDMETHODIMP get_GetFolder(IDispatch **ppid);
    STDMETHODIMP get_IsLink(VARIANT_BOOL * pb);
    STDMETHODIMP get_IsFolder(VARIANT_BOOL * pb);
    STDMETHODIMP get_IsFileSystem(VARIANT_BOOL * pb);
    STDMETHODIMP get_IsBrowsable(VARIANT_BOOL * pb);
    STDMETHODIMP get_ModifyDate(DATE *pdt);
    STDMETHODIMP put_ModifyDate(DATE dt);
    STDMETHODIMP get_Size(LONG *pdt);
    STDMETHODIMP get_Type(BSTR *pbs);
    STDMETHODIMP Verbs(FolderItemVerbs **ppfic);
    STDMETHODIMP InvokeVerb(VARIANT vVerb);

    // FolderItem2
    STDMETHODIMP InvokeVerbEx(VARIANT vVerb, VARIANT vArgs);
    STDMETHODIMP ExtendedProperty(BSTR bstrPropName, VARIANT *pvRet);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IParentAndItem
    STDMETHODIMP SetParentAndItem(LPCITEMIDLIST pidlParent, IShellFolder *psf,  LPCITEMIDLIST pidl);
    STDMETHODIMP GetParentAndItem(LPITEMIDLIST *ppidlParent, IShellFolder **ppsf, LPITEMIDLIST *ppidl);

    // publics, non interface methods
    CFolderItem();
    HRESULT Init(CFolder *psdf, LPCITEMIDLIST pidl);
    static LPCITEMIDLIST _GetIDListFromVariant(const VARIANT *pv);

private:
    HRESULT _CheckAttribute(ULONG ulAttr, VARIANT_BOOL *pb);
    HRESULT _GetUIObjectOf(REFIID riid, void **ppvOut);
    HRESULT _ItemName(UINT dwFlags, BSTR *pbs);
    HRESULT _SecurityCheck();

    ~CFolderItem();

    LONG _cRef;
    CFolder *_psdf;             // The folder we came from...
    LPITEMIDLIST _pidl;
};


#define CMD_ID_FIRST    1
#define CMD_ID_LAST     0x7fff


#endif // __cplusplus

#endif // __SHDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\advanced.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

//
// ADVANCED.C - "Advanced" Property Sheet
//

//
//  This is a registry driven UI that walk through the part of the
//  registry tree and convert it into a tree view list.
//  Note that registry values can be localized, so internation versions
//  have to localize the INF file so that setup will set the registry
//  with the right text.
//
//  Here is how the registry key looks like,
//
//  HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\AdvancedOptions\
//      GroupKey1\
//          Type="group"
//          Text="text to display"
//          DefaultImage="somedll.dll,icon_index", (optional).
//
//          RadioKey1.1\
//              Type="radio"
//              Text="text to display"
//   (optional) HKeyRoot=any one of the pre-defined root HKEY in DWORD,
//                  ; default to HKEY_CURRENT_USER.
//   (optional) RegPath="path to the key where the setting value is stored."
//                  ; default to Software\Microsoft\Windows\CurrentVersion\Explorer\AdvancedOptions
//              ValueName="reg value name."
//              CheckedValue=...    ; value for this radio button,
//                  ; if the value is platform dependent, use one of the following two instead
//              CheckedValueNT=...  ; if the value is platform dependent
//              CheckedValueW95=... ; if the value is platform dependent
//              DefaultValue=...
//   (optional) SPIAction=uiAction param to SystemParametersInfo in DWORD
//   (optional) SPIParamON=uiParam param to SystemParametersInfo for this radio button in DWORD
//   (optional) Mask=...          ; mask for the bitfield 1's for the bits we want to be able to set/clear
//              
//          RadioKey1.2\
//              Type="radio"
//              Text="text to display"
//   (optional) HKeyRoot=any one of the pre-defined root HKEY in DWORD,
//                  ; default to HKEY_CURRENT_USER.
//   (optional) RegPath="path to the key where the setting value is stored."
//                  ; default to Software\Microsoft\Windows\CurrentVersion\Explorer\AdvancedOptions
//              ValueName="reg value name."
//              CheckedValue=...    ; value for this checkbox if it's checked
//                  ; if the value is platform dependent, use one of the following two instead
//              CheckedValueNT=...  ; if the value is platform dependent
//              CheckedValueW95=... ; if the value is platform dependent
//              UncheckedValue=...  ; value for this checkbox if it's unchecked
//              DefaultValue=...
//   (optional) SPIAction=uiAction param to SystemParametersInfo in DWORD
//   (optional) SPIParamON=uiParam param to SystemParametersInfo if checked in DWORD
//   (optional) SPIParamOFF=uiParam param to SystemParametersInfo if checked in DWORD
//   (optional) Mask=...          ; mask for the bitfield 1's for the bits we want to be able to set/clear
//
//          CheckBoxKey1.1\
//              ...
//          GroupKey1.1\
//              ...
//      GroupKey2\
//          ...
//          CheckBoxKey2.1\
//              ...
//          CheckBoxKey2.2\
//              ...
//
//
//  Notes:
//      1. All the settings are store in HKCU\...\Explorer\Settings key,
//          code can be added to support any random absolute reg path for
//          the settings.
//

#include "stdafx.h"
#include "utils.h"
#pragma hdrstop

void Cabinet_StateChanged(void);

//
// Private Calls and structures
//
//

typedef struct {
    HWND hDlg;              // handle of our dialog
    HWND hwndTree;          // handle to the treeview
    IRegTreeOptions *pTO;    // pointer to RegTreeOptions interface
    CFolderOptionsPsx *ppsx;    // to talk to our propsheet sibling
    BOOL    fDirty;          // Dirty bit to detect if anything changed.
} ADVANCEDPAGE, *LPADVANCEDPAGE;

#define ENABLEAPPLY(hDlg) SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L)

//
// Initializes Advanced property sheet
//
// History:
void Install_AdvancedShellSettings(SHELLSTATE * pss);

BOOL AdvancedDlgInit(HWND hDlg, LPARAM lParam)
{
    HRESULT hr;
    LPADVANCEDPAGE  pAdv = (LPADVANCEDPAGE)LocalAlloc(LPTR, sizeof(*pAdv));
    if (!pAdv)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // We expose some of SHGetSetSettings in the advanced settings section,
    // so we need to migrate these PER-USER settings from the SHELLSTATE
    // structure into the registry tree structure once per user.  Since we
    // don't have a per-user install section, do it here on demand.
    // We don't have to do it every time, but that's easier...
    Install_AdvancedShellSettings(NULL);
    
    // tell dialog where to get info
    SetWindowPtr(hDlg, DWLP_USER, pAdv);

    PROPSHEETPAGE *pps = (PROPSHEETPAGE *)lParam;

    pAdv->ppsx = (CFolderOptionsPsx *)pps->lParam;

    //Check if we have pointer to Shell Browser
    if (!pAdv->ppsx->HasBrowserService())
    {
        //Hey ! we dont have pointer to Shell Browser so we must have been
        //invoked through a global Folder Options . In this case it doesn't 
        //make sense to  say "You can make all your folders look the same Like Current Folder"
        //because we dont have a current folder so let just disable the button "Like Current Folder"
        EnableWindow(GetDlgItem(hDlg, IDC_ADVO_USECURRENTFOLDER), FALSE);
    }

    // save dialog handle
    pAdv->hDlg = hDlg;
    pAdv->hwndTree = GetDlgItem(pAdv->hDlg, IDC_ADVO_ADVANCEDTREE);
    DWORD dwServerType = CLSCTX_INPROC_SERVER;

    hr = CoCreateInstance(CLSID_CRegTreeOptions, NULL, dwServerType,
                          IID_IRegTreeOptions, (LPVOID *)&(pAdv->pTO));
    if (SUCCEEDED(hr))
    {
        // HACK - IRegTreeOptions is ANSI, so we temporarily turn off UNICODE
        #undef TEXT
        #define TEXT(s) s
        hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, REGSTR_EXPLORER_ADVANCED, NULL);
        #undef TEXT
        #define TEXT(s) __TEXT(s)
    }
    
    // find the first root and make sure that it is visible
    TreeView_EnsureVisible(pAdv->hwndTree, TreeView_GetRoot(pAdv->hwndTree));

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

void Tree_OnNotify(LPADVANCEDPAGE pAdv)
{
    TV_HITTESTINFO ht;

    GetCursorPos(&ht.pt);                         // get where we were hit

    ScreenToClient(pAdv->hwndTree, &ht.pt);       // translate it to our window

    // retrieve the item hit
    // IRegTreeOptions might fail to cocreate under stress conditions and
    // low memory, in which case we would fault here if we dont check for
    // pTO. Bug # 211108 - ramkumar
    if (pAdv->pTO)
    {
        pAdv->pTO->ToggleItem(TreeView_HitTest(pAdv->hwndTree, &ht));
        ENABLEAPPLY(pAdv->hDlg);
        pAdv->fDirty = TRUE;
    }
} // Tree_OnNotify


//
// AdvancedDlgOnNotify()
//
// Handles Advanced property sheets WM_NOTIFY messages
//
//
void AdvancedDlgOnNotify(LPADVANCEDPAGE pAdv, LPNMHDR psn)
{
    SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, 0); // handled

    switch (psn->code)
    {
    case TVN_KEYDOWN:
    {
        TV_KEYDOWN *pnm = (TV_KEYDOWN*)psn;
        if (pnm->wVKey == VK_SPACE)
        {
            pAdv->pTO->ToggleItem((HTREEITEM)SendMessage(pAdv->hwndTree, TVM_GETNEXTITEM, TVGN_CARET, NULL));
            ENABLEAPPLY(pAdv->hDlg);
            pAdv->fDirty = TRUE;
            // Specify that we handled the key, so we don't beep
            SetWindowLongPtr(pAdv->hDlg, DWLP_MSGRESULT, TRUE);
        }
        break;
    }

    case NM_CLICK:
    case NM_DBLCLK:
        // is this click in our tree?
        if (psn->idFrom == IDC_ADVO_ADVANCEDTREE)
        {
            // yes...
            Tree_OnNotify(pAdv);
        }
        break;

    case PSN_APPLY:
        if (pAdv->fDirty) //We will save these only if something changed.
        {
            pAdv->pTO->WalkTree(WALK_TREE_SAVE);

            CABINETSTATE cs;
            ReadCabinetState(&cs, sizeof(cs));   // refresh the global CABINETSTATE
            WriteCabinetState(&cs);              // and make sure we commit to the bitfield.
        
            // We should only notify if needed.

            SHRefreshSettings();        // refresh the SHELLSTATE structure

            SHSettingsChanged(0, 0);    // invalidate the restrictions

            // Let everybody know about the new settings
            SendNotifyMessage(HWND_BROADCAST, WM_WININICHANGE, 0, 0);

            // Okay now tell all Cabinets to refresh
            Cabinet_RefreshAll(Cabinet_RefreshEnum, (LPARAM)0L);
        }
        break;
    }
}

const static DWORD aAdvOptsHelpIDs[] = {  // Context Help IDs
    IDC_ADVO_GROUPBOX,               IDH_COMM_GROUPBOX,
    IDC_ADVO_ADVANCEDTEXT,       IDH_GROUPBOX,
    IDC_ADVO_ADV_RESTORE_DEF,    IDH_RESTORE_DEFAULT,
    IDC_ADVO_RESETTOORIGINAL,    IDH_RESET_TO_ORIGINAL,
    IDC_ADVO_USECURRENTFOLDER,   IDH_USE_CURRENT_FOLDER,
    IDC_ADVO_IMAGEFOLDER,       -1,        //Suppress help for this item.
    IDC_ADVO_STATICTEXT,        -1,        //Suppress help for this item.
    0, 0
};


//
// AdvancedDlgProc
//
// History:
//
//
BOOL_PTR CALLBACK AdvancedOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADVANCEDPAGE pAdv = (LPADVANCEDPAGE)GetWindowPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        // Initialize Dialog controls
        return AdvancedDlgInit(hDlg, lParam);
    }

    if (pAdv)
    {
        switch (uMsg)
        {

        case WM_NOTIFY:
            AdvancedDlgOnNotify(pAdv, (LPNMHDR)lParam);
            return TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_ADVO_ADV_RESTORE_DEF:
                pAdv->pTO->WalkTree(WALK_TREE_RESTORE);
                ENABLEAPPLY(hDlg);
                pAdv->fDirty = TRUE;
                break;

            case IDC_ADVO_USECURRENTFOLDER:
                if (ShellMessageBox(HINST_THISDLL, hDlg,
                                    MAKEINTRESOURCE(IDS_LIKECURRENT_TEXT),
                                    MAKEINTRESOURCE(IDS_FOLDERVIEWS),
                                    MB_YESNO | MB_ICONINFORMATION) == IDYES)
                {
                    pAdv->ppsx->SetAsDefFolderSettings();
                    pAdv->ppsx->SetNeedRefresh(TRUE);
                    pAdv->fDirty = TRUE;
                }
                break;

            case IDC_ADVO_RESETTOORIGINAL:
                if (ShellMessageBox(HINST_THISDLL, hDlg,
                                    MAKEINTRESOURCE(IDS_RESETALL_TEXT),
                                    MAKEINTRESOURCE(IDS_FOLDERVIEWS),
                                    MB_YESNO | MB_ICONINFORMATION) == IDYES)
                {
                    pAdv->ppsx->ResetDefFolderSettings();
                    pAdv->ppsx->SetNeedRefresh(TRUE);
                    pAdv->fDirty = TRUE;
                }
            
                break;
            }
            break;

        case WM_HELP:                   // F1
        {
            HELPINFO *phi = (HELPINFO *)lParam;

            //if the help is for one of the command buttons then call winhelp 
            if (phi->iCtrlId != IDC_ADVO_ADVANCEDTREE)
            {
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, TEXT(SHELL_HLP),
                             HELP_WM_HELP, (DWORD_PTR)(LPSTR)aAdvOptsHelpIDs);
            }
            else 
            {
                //Help is for the tree item so we need to do some special processing
                
                HTREEITEM hItem;

                // Is this help invoked throught F1 key
                if (GetAsyncKeyState(VK_F1) < 0)                
                {
                    // Yes. WE need to give help for the currently selected item
                    hItem = TreeView_GetSelection(pAdv->hwndTree);
                }
                else 
                {
                    //No, We need to give help for the item at the cursor position 
                    TV_HITTESTINFO ht;
                    ht.pt = phi->MousePos;
                    ScreenToClient(pAdv->hwndTree, &ht.pt); // Translate it to our window
                    hItem = TreeView_HitTest(pAdv->hwndTree, &ht);
                }

                if (FAILED(pAdv->pTO->ShowHelp(hItem, HELP_WM_HELP)))
                {
                    WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL,
                                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aAdvOptsHelpIDs);
                }
            }
            break; 
        }

        case WM_CONTEXTMENU:        // right mouse click
        {
            HTREEITEM hti;

            if ((LPARAM)-1 == lParam)
            {
                hti = TreeView_GetSelection(pAdv->hwndTree);
            }
            else
            {
                TV_HITTESTINFO ht;

                ht.pt.x = GET_X_LPARAM(lParam);
                ht.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(pAdv->hwndTree, &ht.pt);

                hti = TreeView_HitTest(pAdv->hwndTree, &ht);
            }

            // retrieve the item hit
            if (FAILED(pAdv->pTO->ShowHelp(hti, HELP_CONTEXTMENU)))
            {           
                WinHelp((HWND) wParam, TEXT(SHELL_HLP),
                            HELP_CONTEXTMENU, (ULONG_PTR)(LPSTR)aAdvOptsHelpIDs);
            }
            break; 
        }

        case WM_DESTROY:
            // free the tree
            if (pAdv->pTO)
            {
                pAdv->pTO->WalkTree(WALK_TREE_DELETE);
                ATOMICRELEASE(pAdv->pTO);
            }

            LocalFree(pAdv);
            // make sure we don't re-enter
            SetWindowPtr(hDlg, DWLP_USER, NULL);
            break; // WM_DESTORY
        }
    }
    return FALSE; // not handled
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\advanced.h ===
#ifndef _ADVANCED_H_
#define _ADVANCED_H_

BOOL_PTR CALLBACK AdvancedOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dbackp.h ===
#ifndef _DBACKP_H_
#define _DBACKP_H_

#define BP_NEWPAT           0x00000001
#define BP_NEWWALL          0x00000002
#define BP_TILE             0x00000004
#define BP_REINIT           0x00000008
#define BP_EXTERNALWALL     0x00000010
#define BP_STRETCH          0x00000020

#define WM_SETBACKINFO  (WM_USER+1)

BOOL RegisterBackPreviewClass();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dback.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "..\\deskfldr.h"
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN

#pragma hdrstop

const TCHAR c_szSetup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
const TCHAR c_szSharedDir[] = TEXT("SharedDir");

BOOL g_fDirtyAdvanced;
BOOL g_fLaunchGallery;      // If true, we launched the gallery, so close the dialog.
DWORD g_dwApplyFlags = (AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);

// used to indicate if desktop cleanup settings have changes
extern int g_iRunDesktopCleanup = BST_INDETERMINATE; // indicates uninitilized value.
STDAPI ApplyDesktopCleanupSettings();

BOOL _IsNonEnumPolicySet(const CLSID *pclsid);

static const LPCTSTR c_rgpszWallpaperExt[] = {
    TEXT("BMP"), TEXT("GIF"),
    TEXT("JPG"), TEXT("JPE"),
    TEXT("JPEG"),TEXT("DIB"),
    TEXT("PNG"), TEXT("HTM"),
    TEXT("HTML"),
};

const static DWORD aBackHelpIDs[] = {
    IDC_BACK_SELECT,    IDH_DISPLAY_BACKGROUND_WALLPAPERLIST,
    IDC_BACK_WPLIST,    IDH_DISPLAY_BACKGROUND_WALLPAPERLIST,
    IDC_BACK_BROWSE,    IDH_DISPLAY_BACKGROUND_BROWSE_BUTTON,
    IDC_BACK_WEB,       IDH_DISPLAY_BACKGROUND_DESKTOP_ITEMS,
    IDC_BACK_DISPLAY,   IDH_DISPLAY_BACKGROUND_PICTUREDISPLAY,
    IDC_BACK_WPSTYLE,   IDH_DISPLAY_BACKGROUND_PICTUREDISPLAY,
    IDC_BACK_PREVIEW,   IDH_DISPLAY_BACKGROUND_MONITOR,
    IDC_BACK_COLORPICKERLABEL, IDH_DISPLAY_BACKGROUND_BACKGROUND_COLOR,
    IDC_BACK_COLORPICKER, IDH_DISPLAY_BACKGROUND_BACKGROUND_COLOR,
    0, 0
};

#define SZ_HELPFILE_DESKTOPTAB           TEXT("display.hlp")



#define SZ_REGKEY_PROGRAMFILES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define SZ_REGKEY_PLUS95DIR             TEXT("Software\\Microsoft\\Plus!\\Setup")         // PLUS95_KEY
#define SZ_REGKEY_PLUS98DIR             TEXT("Software\\Microsoft\\Plus!98")          // PLUS98_KEY
#define SZ_REGKEY_KIDSDIR               TEXT("Software\\Microsoft\\Microsoft Kids\\Kids Plus!")   // KIDS_KEY
#define SZ_REGKEY_WALLPAPER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Wallpaper")
#define SZ_REGKEY_WALLPAPERMRU          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Wallpaper\\MRU")
#define SZ_REGKEY_LASTTHEME             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\LastTheme")

#define SZ_REGVALUE_PLUS95DIR           TEXT("DestPath")                // PLUS95_PATH
#define SZ_REGVALUE_PLUS98DIR           TEXT("Path")                    // PLUS98_PATH
#define SZ_REGVALUE_KIDSDIR             TEXT("InstallDir")              // KIDS_PATH
#define SZ_REGVALUE_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define SZ_REGVALUE_PROGRAMFILESDIR     TEXT("ProgramFilesDir")
#define SZ_REGVALUE_USETILE             TEXT("UseTile")                 // If it's not a watermark background, does the user want to default to "Center" or "Stretch".  Different users like different settings.
#define SZ_REGVALUE_LASTSCAN            TEXT("LastScan")                // When was the last time we scanned the file sizes?


#ifndef RECTHEIGHT
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define RECTWIDTH(rc) ((rc).right - (rc).left)
#endif


//===========================
// *** Class Internals & Helpers ***
//===========================

int GetGraphicFileIndex(LPCTSTR pszFile)
{
    int iGraphicFileIndex = -1;

    if (pszFile && *pszFile)
    {
        LPCTSTR pszExt = PathFindExtension(pszFile);
        if (*pszExt == TEXT('.'))
        {
            pszExt++;

            for (int iRet = 0; iRet < ARRAYSIZE(c_rgpszWallpaperExt); iRet++)
            {
                if (StrCmpIC(pszExt, c_rgpszWallpaperExt[iRet]) == 0)
                {
                    iGraphicFileIndex = iRet;
                }
            }
        }
    }

    return iGraphicFileIndex;
}

BOOL IsGraphicsFile(LPCTSTR pszFile)
{
    return GetGraphicFileIndex(pszFile) >= 0;
}

HRESULT CBackPropSheetPage::_LoadState(void)
{
    HRESULT hr = S_OK;

    if (!_fStateLoaded)
    {
        hr = _LoadIconState();
        if (SUCCEEDED(hr))
        {
            hr = _LoadDesktopOptionsState();
            if (SUCCEEDED(hr))
            {
                _fStateLoaded = TRUE;
            }
        }
    }

    return hr;
}

#define SZ_ICON_DEFAULTICON               L"DefaultValue"
HRESULT CBackPropSheetPage::_GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN BOOL fOldIcon, IN LPWSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    if (!StrCmpIW(SZ_ICON_DEFAULTICON, pszName))
    {
        pszName = L"";
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        if (IsEqualCLSID(*(c_aIconRegKeys[nIndex].pclsid), clsid) &&
            !StrCmpIW(pszName, c_aIconRegKeys[nIndex].szIconValue))
        {
            // We found it.
            if (fOldIcon)
            {
                hr = StringCchPrintfW(pszPath, cchSize, L"%s,%d", _IconData[nIndex].szOldFile, _IconData[nIndex].iOldIndex);
            }
            else
            {
                hr = StringCchPrintfW(pszPath, cchSize, L"%s,%d", _IconData[nIndex].szNewFile, _IconData[nIndex].iNewIndex);
            }

            break;
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    if (!StrCmpIW(SZ_ICON_DEFAULTICON, pszName))
    {
        pszName = L"";
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        if (IsEqualCLSID(*(c_aIconRegKeys[nIndex].pclsid), clsid) &&
            !StrCmpIW(pszName, c_aIconRegKeys[nIndex].szIconValue))
        {
            TCHAR szTemp[MAX_PATH];

            if (!pszPath || !pszPath[0])
            {
                // The caller didn't specify an icon so use the default values.
                if (!SHExpandEnvironmentStrings(c_aIconRegKeys[nIndex].pszDefault, szTemp, ARRAYSIZE(szTemp)))
                {
                    StringCchCopy(szTemp, ARRAYSIZE(szTemp), c_aIconRegKeys[nIndex].pszDefault);
                }

                pszPath = szTemp;
                nResourceID = c_aIconRegKeys[nIndex].nDefaultIndex;
            }

            // We found it.
            StringCchCopy(_IconData[nIndex].szNewFile, ARRAYSIZE(_IconData[nIndex].szNewFile), pszPath);
            _IconData[nIndex].iNewIndex = nResourceID;

            hr = S_OK;
            break;
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_LoadIconState(void)
{
    HRESULT hr = S_OK;

    // load the icons and add them to the image lists
    // get the icon files and indexes from the registry, including for the Default recycle bin
    for (int nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        TCHAR szTemp[MAX_PATH];

        szTemp[0] = 0;
        IconGetRegIconString(c_aIconRegKeys[nIndex].pclsid, c_aIconRegKeys[nIndex].szIconValue, szTemp, ARRAYSIZE(szTemp));
        int iIndex = PathParseIconLocation(szTemp);

        // store the icon information
        StringCchCopy(_IconData[nIndex].szOldFile, ARRAYSIZE(_IconData[nIndex].szOldFile), szTemp);
        StringCchCopy(_IconData[nIndex].szNewFile, ARRAYSIZE(_IconData[nIndex].szNewFile), szTemp);
        _IconData[nIndex].iOldIndex = iIndex;
        _IconData[nIndex].iNewIndex = iIndex;
    }

    return hr;
}


HRESULT CBackPropSheetPage::_LoadDesktopOptionsState(void)
{
    HRESULT hr = S_OK;

    int iStartPanel;
    TCHAR   szRegPath[MAX_PATH];

    // i = 0 is for StartPanel off and i = 1 is for StartPanel ON!    
    for(iStartPanel = 0; iStartPanel <= 1; iStartPanel++)
    {
        int iIndex;
        //Get the proper registry path based on if StartPanel is ON/OFF
        StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, c_apstrRegLocation[iStartPanel]);

        //Load the settings for all icons we are interested in.
        for(iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
        {
            TCHAR szValueName[MAX_GUID_STRING_LEN];
            SHUnicodeToTChar(c_aDeskIconId[iIndex].pwszCLSID, szValueName, ARRAYSIZE(szValueName));
            //Read the setting from the registry!
            _aHideDesktopIcon[iStartPanel][iIndex].fHideIcon = SHRegGetBoolUSValue(szRegPath, szValueName, FALSE, /* default */FALSE);
            _aHideDesktopIcon[iStartPanel][iIndex].fDirty = FALSE;

            //Update the NonEnum attribute data.
            if((c_aDeskIconId[iIndex].fCheckNonEnumAttrib) && (iStartPanel == 1))
            {
                TCHAR   szAttriRegPath[MAX_PATH];
                DWORD   dwSize = sizeof(_aDeskIconNonEnumData[iIndex].rgfAttributes);
                ULONG   rgfDefault = 0; //By default the SFGAO_NONENUMERATED bit if off!
                
                StringCchPrintf(szAttriRegPath, ARRAYSIZE(szAttriRegPath), REGSTR_PATH_EXP_SHELLFOLDER, szValueName);
                //Read the attributes.
                SHRegGetUSValue(szAttriRegPath, REGVAL_ATTRIBUTES, 
                                        NULL, 
                                        &(_aDeskIconNonEnumData[iIndex].rgfAttributes),
                                        &dwSize,
                                        FALSE,
                                        &rgfDefault,
                                        sizeof(rgfDefault));

                //If SHGAO_NONENUMERATED bit is ON, then we need to hide the checkboxes in both modes.
                if(_aDeskIconNonEnumData[iIndex].rgfAttributes & SFGAO_NONENUMERATED)
                {
                    //Overwrite what we read earlier! These icons are hidden in both modes!
                    _aHideDesktopIcon[0][iIndex].fHideIcon = TRUE;
                    _aHideDesktopIcon[1][iIndex].fHideIcon = TRUE;
                }
            }

            //Check the policy if needed!
            if((c_aDeskIconId[iIndex].fCheckNonEnumPolicy) && (iStartPanel == 1))
            {
                if(_IsNonEnumPolicySet(c_aDeskIconId[iIndex].pclsid))
                {
                    //Remember that this policy is set. So that we can disable these controls in UI.
                    _aDeskIconNonEnumData[iIndex].fNonEnumPolicySet = TRUE;
                    //Remember to hide these icons in both modes!
                    _aHideDesktopIcon[0][iIndex].fHideIcon = TRUE;
                    _aHideDesktopIcon[1][iIndex].fHideIcon = TRUE;
                }
            }
        } //for (all desktop items)
    } //for both the modes (StartPanel off and On)

    return hr;
}


HRESULT CBackPropSheetPage::_SaveIconState(void)
{
    HRESULT hr = S_OK;
    BOOL fDorked = FALSE;

    if (_fStateLoaded)
    {
        int nIndex;

        // Change the system icons

        for(nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
        {
            if ((lstrcmpi(_IconData[nIndex].szNewFile, _IconData[nIndex].szOldFile) != 0) ||
                (_IconData[nIndex].iNewIndex != _IconData[nIndex].iOldIndex))
            {
                TCHAR szTemp[MAX_PATH];

                if (SUCCEEDED(StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s,%d"), _IconData[nIndex].szNewFile, _IconData[nIndex].iNewIndex)))
                {
                    IconSetRegValueString(c_aIconRegKeys[nIndex].pclsid, TEXT("DefaultIcon"), c_aIconRegKeys[nIndex].szIconValue, szTemp);

                    // Next two lines necessary if the user does an Apply as opposed to OK
                    StringCchCopy(_IconData[nIndex].szOldFile, ARRAYSIZE(_IconData[nIndex].szOldFile), _IconData[nIndex].szNewFile);
                    _IconData[nIndex].iOldIndex = _IconData[nIndex].iNewIndex;
                    fDorked = TRUE;
                }
            }
        }
    }

    // Make the system notice we changed the system icons
    if (fDorked)
    {
        SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL); // should do the trick!
        SHUpdateRecycleBinIcon();
    }

    return hr;
}


HRESULT CBackPropSheetPage::_SaveDesktopOptionsState(void)
{
    HRESULT hr = S_OK;

    int iStartPanel;
    TCHAR   szRegPath[MAX_PATH];
    BOOL    fUpdateDesktop = FALSE;

    // i = 0 is for StartPanel off and i = 1 is for StartPanel ON!    
    for(iStartPanel = 0; iStartPanel <= 1; iStartPanel++)
    {
        int iIndex;
        //Get the proper registry path based on if StartPanel is ON/OFF
        StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, c_apstrRegLocation[iStartPanel]);

        //Load the settings for all icons we are interested in.
        for(iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
        {
            //Update the registry only if the particular icon entry is dirty.
            if(_aHideDesktopIcon[iStartPanel][iIndex].fDirty)
            {
                TCHAR szValueName[MAX_GUID_STRING_LEN];
                SHUnicodeToTChar(c_aDeskIconId[iIndex].pwszCLSID, szValueName, ARRAYSIZE(szValueName));
                //Write the setting to the registry!
                SHRegSetUSValue(szRegPath, szValueName, REG_DWORD, 
                                &(_aHideDesktopIcon[iStartPanel][iIndex].fHideIcon),
                                sizeof(_aHideDesktopIcon[iStartPanel][iIndex].fHideIcon), 
                                SHREGSET_FORCE_HKCU);
                _aHideDesktopIcon[iStartPanel][iIndex].fDirty = FALSE;

                fUpdateDesktop = TRUE; //Desktop window needs to be refreshed.

                // Note this will be done only once per index because SFGAO_NONENUMERATED bit is
                // reset in rgfAttributes.
                if((c_aDeskIconId[iIndex].fCheckNonEnumAttrib) && 
                   (_aDeskIconNonEnumData[iIndex].rgfAttributes & SFGAO_NONENUMERATED) &&
                   (_aHideDesktopIcon[iStartPanel][iIndex].fHideIcon == FALSE))
                {
                    TCHAR   szAttriRegPath[MAX_PATH];
                    
                    StringCchPrintf(szAttriRegPath, ARRAYSIZE(szAttriRegPath), REGSTR_PATH_EXP_SHELLFOLDER, szValueName);
                    //We need to remove the SFGAO_NONENUMERATED attribute bit!
                    
                    //We assume here is that when we save to registry, we save the same value
                    //for both the modes.
                    ASSERT(_aHideDesktopIcon[0][iIndex].fHideIcon == _aHideDesktopIcon[1][iIndex].fHideIcon);

                    //Strip out the NonEnum attribute!
                    _aDeskIconNonEnumData[iIndex].rgfAttributes &= ~SFGAO_NONENUMERATED;
                    //And save it in the registry!
                    SHRegSetUSValue(szAttriRegPath, REGVAL_ATTRIBUTES, 
                                    REG_DWORD, 
                                    &(_aDeskIconNonEnumData[iIndex].rgfAttributes),
                                    sizeof(_aDeskIconNonEnumData[iIndex].rgfAttributes),
                                    SHREGSET_FORCE_HKCU);
                }
            }
        }
    }

    if(fUpdateDesktop)
        PostMessage(GetShellWindow(), WM_COMMAND, FCIDM_REFRESH, 0L); //Refresh desktop!

    _fHideDesktopIconDirty = FALSE;  //We just saved. So, reset the dirty bit!
    
    return hr;
}


int CBackPropSheetPage::_AddAFileToLV(LPCTSTR pszDir, LPTSTR pszFile, UINT nBitmap)
{
    int index = -1;
    LPTSTR pszParam;
    const DWORD cchParam = MAX_PATH;  // PathAppend args must be MAX_PATH...no more - no less

    pszParam = (LPTSTR) LocalAlloc( LPTR, cchParam * sizeof(*pszParam) );
    if ( NULL != pszParam )
    {
        if (pszDir)
        {
            StringCchCopy(pszParam, cchParam, pszDir);
            if (!PathAppend(pszParam, pszFile))
            {
                *pszParam = TEXT('\0');
            }
        }
        else if (pszFile && *pszFile && (lstrcmpi(pszFile, g_szNone) != 0))
        {
            StringCchCopy(pszParam, cchParam, pszFile);
        }
        else
        {
            *pszParam = TEXT('\0');
        }

        TCHAR szLVIText[MAX_PATH];

        StringCchCopy(szLVIText, ARRAYSIZE(szLVIText), PathFindFileName(pszFile));
        PathRemoveExtension(szLVIText);
        PathMakePretty(szLVIText);

        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM | (nBitmap != -1 ? LVIF_IMAGE : 0);
        lvi.iItem = 0x7FFFFFFF;
        lvi.pszText = szLVIText;
        lvi.iImage = nBitmap;
        lvi.lParam = (LPARAM) pszParam;

        index = ListView_InsertItem(_hwndLV, &lvi);

        if (index == -1)
        {
            LocalFree(pszParam);
        }
        else
        {
            ListView_SetColumnWidth(_hwndLV, 0, LVSCW_AUTOSIZE);
        }
    }

    return index;
}

int CBackPropSheetPage::_FindWallpaper(LPCTSTR pszFile)
{
    int nItems = ListView_GetItemCount(_hwndLV);
    int i;

    for (i=0; i<nItems; i++)
    {
        LV_ITEM lvi = {0};

        lvi.iItem = i;
        lvi.mask = LVIF_PARAM;
        ListView_GetItem(_hwndLV, &lvi);
        if (StrCmpIC(pszFile, (LPCTSTR)lvi.lParam) == 0)
        {
            return i;
        }
    }

    return -1;
}

void CBackPropSheetPage::_UpdatePreview(IN WPARAM flags, IN BOOL fUpdateThemePage)
{
    WALLPAPEROPT wpo;

    wpo.dwSize = sizeof(WALLPAPEROPT);

    g_pActiveDesk->GetWallpaperOptions(&wpo, 0);
    if (wpo.dwStyle & WPSTYLE_TILE)
    {
        flags |= BP_TILE;
    }
    else if(wpo.dwStyle & WPSTYLE_STRETCH)
    {
        flags |= BP_STRETCH;
    }
    
    WCHAR wszWallpaper[INTERNET_MAX_URL_LENGTH];
    g_pActiveDesk->GetWallpaper(wszWallpaper, ARRAYSIZE(wszWallpaper), 0);

    HRESULT hr = S_OK;
    if (!_pThemePreview)
    {
        hr = CoCreateInstance(CLSID_ThemePreview, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemePreview, &_pThemePreview));
        if (SUCCEEDED(hr) && _punkSite)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                HWND hwndPlaceHolder = GetDlgItem(_hwnd, IDC_BACK_PREVIEW);
                if (hwndPlaceHolder)
                {
                    RECT rcPreview;
                    GetClientRect(hwndPlaceHolder, &rcPreview);
                    MapWindowPoints(hwndPlaceHolder, _hwnd, (LPPOINT)&rcPreview, 2);

                    hr = _pThemePreview->CreatePreview(_hwnd, TMPREV_SHOWMONITOR | TMPREV_SHOWBKGND, WS_VISIBLE | WS_CHILDWINDOW | WS_OVERLAPPED, 0, rcPreview.left, rcPreview.top, rcPreview.right - rcPreview.left, rcPreview.bottom - rcPreview.top, pPropertyBag, IDC_BACK_PREVIEW);
                    if (SUCCEEDED(hr))
                    {
                        // If we succeeded, remove the dummy window.
                        DestroyWindow(hwndPlaceHolder);
                        hr = SHPropertyBag_WritePunk(pPropertyBag, SZ_PBPROP_PREVIEW2, _pThemePreview);
                        _fThemePreviewCreated = TRUE;
                    }
                }

                pPropertyBag->Release();
            }
        }
    }

    if (_punkSite)
    {
        IThemeUIPages * pThemeUIPages;

        HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
        if (SUCCEEDED(hr))
        {
            hr = pThemeUIPages->UpdatePreview(0);
            pThemeUIPages->Release();
        }

        if (fUpdateThemePage)
        {
            IPropertyBag * pPropertyBag;

            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                // Tell the theme that we have customized the values.
                hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
                pPropertyBag->Release();
            }
        }
    }

    if (!_fThemePreviewCreated)
    {
        HWND hwndOldPreview = GetDlgItem(_hwnd, IDC_BACK_PREVIEW);
        if (hwndOldPreview)
        {
            SendDlgItemMessage(_hwnd, IDC_BACK_PREVIEW, WM_SETBACKINFO, flags, 0);
        }
    }
}

void CBackPropSheetPage::_EnableControls(void)
{
    BOOL fEnable;

    WCHAR wszWallpaper[INTERNET_MAX_URL_LENGTH];
    LPTSTR pszWallpaper;

    g_pActiveDesk->GetWallpaper(wszWallpaper, ARRAYSIZE(wszWallpaper), 0);
    pszWallpaper = (LPTSTR)wszWallpaper;
    BOOL fIsPicture = IsWallpaperPicture(pszWallpaper);

    // Style combo only enabled if a non-null picture
    // is being viewed.
    fEnable = _fAllowChanges && fIsPicture && (*pszWallpaper) && (!_fPolicyForStyle);
    EnableWindow(GetDlgItem(_hwnd, IDC_BACK_WPSTYLE), fEnable);

//  98/09/10 vtan #209753: Also remember to disable the corresponding
//  text item with the keyboard shortcut. Not disabling this will
//  allow the shortcut to be invoked but will cause the incorrect
//  dialog item to be "clicked".
    (BOOL)EnableWindow(GetDlgItem(_hwnd, IDC_BACK_DISPLAY), fEnable);
}

int CBackPropSheetPage::_GetImageIndex(LPCTSTR pszFile)
{
    int iRet = 0;

    if (pszFile && *pszFile)
    {
        LPCTSTR pszExt = PathFindExtension(pszFile);
        if (*pszExt == TEXT('.'))
        {
            pszExt++;
            for (iRet=0; iRet<ARRAYSIZE(c_rgpszWallpaperExt); iRet++)
            {
                //  We want ASCII comparison.  On Turkish systems
                //  .GIF and .Gif will not compare with lstrcmpi.
                if (StrCmpIC(pszExt, c_rgpszWallpaperExt[iRet]) == 0)
                {
                    //
                    // Add one because 'none' took the 0th slot.
                    //
                    iRet++;
                    return(iRet);
                }
            }
            //
            // If we fell off the end of the for loop here,
            // this is a file with unknown extension. So, we assume that
            // it is a normal wallpaper and it gets the Bitmap's icon
            //
            iRet = 1;
        }
        else
        {
            //
            // Unknown files get Bitmap's icon.
            //
            iRet = 1;
        }
    }

    return iRet;
}


// This function is called when another tab is trying to change our
// Tile mode.  This means that our tab may not have been activated yet
// and may not activate until later.
HRESULT CBackPropSheetPage::_SetNewWallpaperTile(IN DWORD dwMode, IN BOOL fUpdateThemePage)
{
    HRESULT hr = E_UNEXPECTED;

    AssertMsg((NULL != g_pActiveDesk), TEXT("We need g_pActiveDesk or we can't change the background"));
    if (g_pActiveDesk)
    {
        WALLPAPEROPT wpo;

        wpo.dwSize = sizeof(wpo);
        g_pActiveDesk->GetWallpaperOptions(&wpo, 0);
        wpo.dwStyle = dwMode;
        hr = g_pActiveDesk->SetWallpaperOptions(&wpo, 0);
    }

    if (_hwndWPStyle)
    {
        ComboBox_SetCurSel(_hwndWPStyle, dwMode);
        _UpdatePreview(0, fUpdateThemePage);
    }

    return hr;
}


HRESULT CBackPropSheetPage::_SetNewWallpaper(LPCTSTR pszFileIn, IN BOOL fUpdateThemePageIn)
{
    HRESULT hr = S_OK;
    WCHAR szFile[MAX_PATH];
    WCHAR szTemp[MAX_PATH];

    LPWSTR pszFile = szFile;
    DWORD  cchFile = ARRAYSIZE(szFile);
    LPWSTR pszTemp = szTemp;
    DWORD  cchTemp = ARRAYSIZE(szTemp);

    //
    // Make a copy of the file name.
    //

    DWORD cchFileIn = lstrlen(pszFileIn) + 1;
    if ( cchFileIn > cchFile )
    {
        cchFile = cchFileIn;
        pszFile = (LPWSTR) LocalAlloc(LPTR, cchFile * sizeof(WCHAR));
        if (NULL == pszFile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    StringCchCopy(pszFile, cchFile, pszFileIn);

    //
    //  Replace all "(none)" with empty strings.
    //

    if (lstrcmpi(pszFile, g_szNone) == 0)
    {
        pszFile[0] = TEXT('\0');
    }

    //
    // Replace net drives with UNC names.
    //

    if( pszFile[1] == TEXT(':') )
    {
        DWORD dwErr;
        TCHAR szDrive[3];

        //
        //  Copy just the drive letter and see if it maps to a network drive.
        //

        StringCchCopy(szDrive, ARRAYSIZE(szDrive), pszFile);
        dwErr = SHWNetGetConnection(szDrive, pszTemp, &cchTemp );

        //
        //  See if our buffer was too small. If so, make it bigger and try
        //  again.
        //

        if ( ERROR_MORE_DATA == dwErr )
        {
            //  Add the size of the rest of the filepath to the UNC path.
            cchTemp += cchFile; 

            pszTemp = (LPWSTR) LocalAlloc( LPTR, cchTemp * sizeof(WCHAR) );
            if ( NULL == pszTemp )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            dwErr = SHWNetGetConnection(szDrive, pszTemp, &cchTemp );
        }
        
        //
        //  If it maps to a network location, replace the network drive letter
        //  with the UNC path.
        //

        if ( NO_ERROR == dwErr )
        {
            if (pszTemp[0] == TEXT('\\') && pszTemp[1] == TEXT('\\'))
            {
                DWORD cchLen;

                StringCchCat(pszTemp, cchTemp, pszFile + 2);

                //
                //  See if the new string will fit into our file buffer.
                //

                cchLen = wcslen(pszTemp) + 1;
                if ( cchLen > cchFile )
                {
                    if ( szFile != pszFile )
                    {
                        LocalFree( pszFile );
                    }

                    cchFile = cchLen;
                    pszFile = (LPWSTR) LocalAlloc(LPTR, cchFile * sizeof(WCHAR) );
                    if ( NULL == pszFile )
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                }

                StringCchCopy(pszFile, cchFile, pszTemp);
            }
        }
    }

    //
    //  If necessary, update the desk state object.
    //

    hr = g_pActiveDesk->GetWallpaper(pszTemp, cchTemp, 0);
    if (FAILED(hr))
        goto Cleanup;

    //
    //  If we need more room, allocate it on the heap and try again.
    //

    if ( MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_MORE_DATA ) == hr )
    {
        if ( szTemp != pszTemp )
        {
            LocalFree( pszTemp );
        }

        cchTemp = INTERNET_MAX_URL_LENGTH;
        pszTemp = (LPWSTR) LocalAlloc( LPTR, cchTemp * sizeof(WCHAR) );
        if ( NULL == pszTemp )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = g_pActiveDesk->GetWallpaper(pszTemp, cchTemp, 0);
        if (S_OK != hr)
            goto Cleanup;
    }

    //
    //  Make sure the old background doesn't equal the new background.
    //

    if (StrCmpIC(pszTemp, pszFile) != 0)
    {
        //
        //  Did they choose something other than a .bmp?  
        //  And is ActiveDesktop off?
        //

        if (!IsNormalWallpaper(pszFileIn))
        {
            Str_SetPtr(&_pszOriginalFile, pszFileIn);
        }
        else
        {
            // We may not need to have a temp file.
            Str_SetPtr(&_pszOriginalFile, NULL);
        }

        Str_SetPtr(&_pszLastSourcePath, pszFile);
        hr = g_pActiveDesk->SetWallpaper(pszFile, 0);
        if (SUCCEEDED(hr))
        {
            if (fUpdateThemePageIn)
            {
                _SetNewWallpaperTile(_GetStretchMode(pszFile), fUpdateThemePageIn);
            }
        }
    }

    //
    //  Update the preview picture of the new wallpaper.
    //

    _UpdatePreview(0, fUpdateThemePageIn);

    //
    // If the wallpaper does not have a directory specified, (this may happen if other apps. change this value),
    // we have to figure it out.
    //

    if (!GetWallpaperWithPath(pszFile, pszTemp, cchTemp))
    {
        hr = E_FAIL;
    }
    else
    {
        LPTSTR pszFileForList = (_pszOriginalFile ? _pszOriginalFile : pszTemp);

        int iSelectionNew = (pszFileForList[0] ? _FindWallpaper(pszFileForList) : 0);
        if (iSelectionNew == -1)
        {
            iSelectionNew = _AddAFileToLV(NULL, pszFileForList, _GetImageIndex(pszFileForList));
        }

        _fSelectionFromUser = FALSE;        // disable

        //
        //  If necessary, select the item in the listview.
        //

        int iSelected = ListView_GetNextItem(_hwndLV, -1, LVNI_SELECTED);
        if (iSelected != iSelectionNew)
        {
            ListView_SetItemState(_hwndLV, iSelectionNew, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        }

        //
        //  Put all controls in correct enabled state.
        //

        _EnableControls();

        //
        // Make sure the selected item is visible.
        //

        ListView_EnsureVisible(_hwndLV, iSelectionNew, FALSE);

        _fSelectionFromUser = TRUE;         // re-enable
    }

Cleanup:
    if ( szFile != pszFile && NULL != pszFile )
    {
        LocalFree( pszFile );
    }
    if ( szTemp != pszTemp && NULL != pszTemp )
    {
        LocalFree( pszTemp );
    }

    return hr;
}

int CALLBACK CBackPropSheetPage::_SortBackgrounds(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    TCHAR szFile1[MAX_PATH], szFile2[MAX_PATH];
    LPTSTR lpszFile1, lpszFile2;

    StringCchCopy(szFile1, ARRAYSIZE(szFile1), (LPTSTR)lParam1);
    lpszFile1 = PathFindFileName(szFile1);
    PathRemoveExtension(lpszFile1);
    PathMakePretty(lpszFile1);

    StringCchCopy(szFile2, ARRAYSIZE(szFile2), (LPTSTR)lParam2);
    lpszFile2 = PathFindFileName(szFile2);
    PathRemoveExtension(lpszFile2);
    PathMakePretty(lpszFile2);

    return StrCmpIC(lpszFile1, lpszFile2);
}


HRESULT CBackPropSheetPage::_GetPlus95ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (sizeof(pszPath[0]) * cchSize);

    HRESULT hr = HrSHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS95DIR, SZ_REGVALUE_PLUS95DIR, &dwType, pszPath, &cbSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LPTSTR pszFile = PathFindFileName(pszPath);
        if (pszFile)
        {
            // Plus!95 DestPath has "Plus!.dll" on the end so get rid of that.
            pszFile[0] = 0;
        }

        // Tack on a "Themes" onto the path
        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        if (!PathAppend(pszPath, szSubDir))
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_GetPlus98ThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (sizeof(pszPath[0]) * cchSize);

    HRESULT hr = HrSHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_PLUS98DIR, SZ_REGVALUE_PLUS98DIR, &dwType, pszPath, &cbSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
        if (!PathAppend(pszPath, szSubDir))
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_GetKidsThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (sizeof(pszPath[0]) * cchSize);

    HRESULT hr = HrSHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_KIDSDIR, SZ_REGVALUE_KIDSDIR, &dwType, pszPath, &cbSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        // Tack a "\Plus! for Kids\Themes" onto the path
        if (PathAppend(pszPath, TEXT("Plus! for Kids")))
        {
            LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
            if (!PathAppend(pszPath, szSubDir))
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_GetHardDirThemesDir(LPTSTR pszPath, DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (sizeof(pszPath[0]) * cchSize);

    HRESULT hr = HrSHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_PROGRAMFILES, SZ_REGVALUE_PROGRAMFILESDIR, &dwType, pszPath, &cbSize);
    if (SUCCEEDED(hr))
    {
        TCHAR szSubDir[MAX_PATH];

        // Tack a "\Plus! for Kids\Themes" onto the path
        if (PathAppend(pszPath, TEXT("Plus!")))
        {
            LoadString(HINST_THISDLL, IDS_THEMES_SUBDIR, szSubDir, ARRAYSIZE(szSubDir));
            if (!PathAppend(pszPath, szSubDir))
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
    }

    return hr;
}


BOOL CBackPropSheetPage::_DoesDirHaveMoreThanMax(LPCTSTR pszPath, int nMax)
{
    _nFileCount = 0;
    _nFileMax = nMax;
    _AddPicturesFromDirRecursively(pszPath, TRUE, _fAllowHtml);

    return (nMax < _nFileCount);
}


#define MAX_PICTURES_TOSTOPRECURSION            100     // PERF: If the directory (My Pictures) has more than this many pictures, only add the pictures in the top level.

HRESULT CBackPropSheetPage::_AddFilesToList(void)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    // Get the directory with the wallpaper files.
    if (!GetStringFromReg(HKEY_LOCAL_MACHINE, c_szSetup, c_szSharedDir, szPath, ARRAYSIZE(szPath)))
    {
        if (!GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            szPath[0] = 0;
        }
    }

    // Add only the *.BMP files in the windows directory.
    _AddPicturesFromDir(szPath, FALSE, FALSE);

    // Get the wallpaper Directory name
    if (!GetWallpaperDirName(szPath, ARRAYSIZE(szPath)))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;

        // Add all pictures from Wallpaper directory to the list!
        _AddPicturesFromDir(szPath, FALSE, _fAllowHtml);

        // Get the path to the "My Pictures" folder
        // NOTE: don't create the My Pictures directory -- if it doesn't exist, we won't find anything there anyway!
        if (S_OK == SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, 0, szPath))
        {
            // Add all pictures in "My Pictures" directory to the list!
            if (!_DoesDirHaveMoreThanMax(szPath, MAX_PICTURES_TOSTOPRECURSION))
            {
                hr = _AddPicturesFromDirRecursively(szPath, FALSE, _fAllowHtml);
            }
        }
        
        //Get the path to the common "%UserProfile%\Application Data\" folder
        if (S_OK == SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPath))
        {
            // Add all pictures in common "%UserProfile%\Application Data\Microsoft Internet Explorer\" so we get the user's
            // "Internet Explorer Wallpaper.bmp" file.
            if (PathAppend(szPath, TEXT("Microsoft\\Internet Explorer")))
            {
                _AddPicturesFromDir(szPath, FALSE, _fAllowHtml);
            }
        }


        // Add pictures from Theme Directories
        // The follwoing directories can contain themes:
        //   Plus!98 Install Path\Themes
        //   Plus!95 Install Path\Themes
        //   Kids for Plus! Install Path\Themes
        //   Program Files\Plus!\Themes
        if (SUCCEEDED(_GetPlus98ThemesDir(szPath, ARRAYSIZE(szPath))))
        {
            _AddPicturesFromDirRecursively(szPath, FALSE, _fAllowHtml);
        }
        else if (SUCCEEDED(_GetPlus95ThemesDir(szPath, ARRAYSIZE(szPath))))
        {
            _AddPicturesFromDirRecursively(szPath, FALSE, _fAllowHtml);
        }
        else if (SUCCEEDED(_GetKidsThemesDir(szPath, ARRAYSIZE(szPath))))
        {
            _AddPicturesFromDirRecursively(szPath, FALSE, _fAllowHtml);
        }
        else if (SUCCEEDED(_GetHardDirThemesDir(szPath, ARRAYSIZE(szPath))))
        {
            _AddPicturesFromDirRecursively(szPath, FALSE, _fAllowHtml);
        }
    }

    return hr;
}


#define SZ_ALL_FILTER           TEXT("*.*")

HRESULT CBackPropSheetPage::_AddPicturesFromDirRecursively(IN LPCTSTR pszDirName, BOOL fCount, BOOL fShouldAllowHTML)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA findFileData;
    TCHAR szSearchPath[MAX_PATH];

    // Note that we use the passed in fShouldAllowHTML rather than the member var _fAllowHtml for cases where
    // we want to restrict to *.BMP regardless.

    _AddPicturesFromDir(pszDirName, fCount, fShouldAllowHTML);
    StringCchCopy(szSearchPath, ARRAYSIZE(szSearchPath), pszDirName);
    if (PathAppend(szSearchPath, SZ_ALL_FILTER))
    {
        HANDLE hFindFiles = FindFirstFile(szSearchPath, &findFileData);
        if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
        {
            while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles) &&
                !(fCount && (_nFileMax < _nFileCount)))
            {
                if ((FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes) &&
                    !PathIsDotOrDotDot(findFileData.cFileName))
                {
                    TCHAR szSubDir[MAX_PATH];

                    StringCchCopy(szSubDir, ARRAYSIZE(szSubDir), pszDirName);
                    if (PathAppend(szSubDir, findFileData.cFileName))
                    {
                        hr = _AddPicturesFromDirRecursively(szSubDir, fCount, fShouldAllowHTML);
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }

                if (!FindNextFile(hFindFiles, &findFileData))
                {
                    break;
                }
            }

            FindClose(hFindFiles);
        }
    }
    else
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }

    return hr;
}



void CBackPropSheetPage::_AddPicturesFromDir(LPCTSTR pszDirName, BOOL fCount, BOOL fShouldAllowHTML)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    TCHAR szBuf[MAX_PATH];

    // Note that we use the passed in fShouldAllowHTML rather than the member var _fAllowHtml for cases where
    // we want to restrict to *.BMP regardless.

    StringCchCopy(szBuf, ARRAYSIZE(szBuf), pszDirName);

    //  If we know we're not looking for web files, then limit the file spec to bitmaps.
    if (PathAppend(szBuf, fShouldAllowHTML ? TEXT("*.*") : TEXT("*.bmp")))
    {
        h = FindFirstFile(szBuf, &fd);
        if (h != INVALID_HANDLE_VALUE)
        {
            do
            {
                // Skip files that are "Super-hidden" like "Winnt.bmp" and "Winnt256.bmp"
                if ((fd.dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)) != (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)) 
                {
                    //  If it's any file, look it up, otherwise we know it is a BMP since we set the
                    //  FindFirst filter above.
                    int iIndex = fShouldAllowHTML ? GetGraphicFileIndex(fd.cFileName) : 0;

                    if (iIndex >= 0)
                    {
                        if (!fCount)
                        {
                            _AddAFileToLV(pszDirName, fd.cFileName, iIndex + 1);
                        }
                        else
                        {
                            _nFileCount++;
                        
                            if (_nFileMax > _nFileCount)
                            {
                                //  No reason to continue at this point
                                break;
                            }
                        }
                    }
                }
            }
            while (FindNextFile(h, &fd));

            FindClose(h);
        }
    }
}


HRESULT GetActiveDesktop(IActiveDesktop ** ppActiveDesktop)
{
    HRESULT hr = S_OK;

    if (!*ppActiveDesktop)
    {
        IActiveDesktopP * piadp;

        if (SUCCEEDED(hr = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&piadp, IID_IActiveDesktopP)))
        {
            WCHAR wszScheme[MAX_PATH];
            DWORD dwcch = ARRAYSIZE(wszScheme);

            // Get the global "edit" scheme and set ourselves us to read from and edit that scheme
            if (SUCCEEDED(piadp->GetScheme(wszScheme, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
            {
                piadp->SetScheme(wszScheme, SCHEME_LOCAL);
                
            }
            hr = piadp->QueryInterface(IID_PPV_ARG(IActiveDesktop, ppActiveDesktop));
            piadp->Release();
        }
    }
    else
    {
        (*ppActiveDesktop)->AddRef();
    }

    return hr;
}


HRESULT ReleaseActiveDesktop(IActiveDesktop ** ppActiveDesktop)
{
    HRESULT hr = S_OK;

    if (*ppActiveDesktop)
    {
        if((*ppActiveDesktop)->Release() == 0)
            *ppActiveDesktop = NULL;
    }

    return hr;
}


#define SZ_REGKEY_CONTROLPANEL_DESKTOP      TEXT("Control Panel\\Desktop")
#define SZ_REGVALUE_CP_PATTERN              TEXT("pattern")
#define SZ_REGVALUE_CP_PATTERNUPGRADE       TEXT("Pattern Upgrade")
#define SZ_REGVALUE_CONVERTED_WALLPAPER     TEXT("ConvertedWallpaper")
#define SZ_REGVALUE_ORIGINAL_WALLPAPER      TEXT("OriginalWallpaper")               // We store this to find when someone changed the wallpaper around us
#define SZ_REGVALUE_CONVERTED_WP_LASTWRITE  TEXT("ConvertedWallpaper Last WriteTime")

HRESULT CBackPropSheetPage::_LoadTempWallpaperSettings(IN LPCWSTR pszWallpaperFile)
{
    // When we converted a non-.BMP wallpaper to a .bmp temp file,
    // we keep the name of the original wallpaper path stored in _pszOriginalFile.
    // We need to load that in now.
    TCHAR szTempWallPaper[MAX_PATH];
    DWORD dwType;
    DWORD cbSize = sizeof(szTempWallPaper);

    // ISSUE: CONVERTED and ORIGINAL are backwards, but we shipped beta1 like this so we can't change it... blech
    DWORD dwError = SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WALLPAPER, &dwType, (void *) szTempWallPaper, &cbSize);
    HRESULT hr = HRESULT_FROM_WIN32(dwError);

    if (SUCCEEDED(hr) && szTempWallPaper[0] && !_fWallpaperChanged)
    {
        TCHAR szOriginalWallPaper[MAX_PATH];

        cbSize = sizeof(szOriginalWallPaper);
        DWORD dwError = SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_ORIGINAL_WALLPAPER, &dwType, (void *) szOriginalWallPaper, &cbSize);

        // It's possible that someone changed the wallpaper externally (IE's "Set as Wallpaper").
        // We need to detect this and ignore the converted wallpaper regkey (SZ_REGVALUE_CONVERTED_WALLPAPER).
        if ((ERROR_SUCCESS == dwError) && !StrCmpI(szOriginalWallPaper, pszWallpaperFile))
        {
            Str_SetPtr(&_pszOriginalFile, szTempWallPaper);
            Str_SetPtr(&_pszOrigLastApplied, szTempWallPaper);
        }
    }
    Str_SetPtrW(&_pszWallpaperInUse, pszWallpaperFile);

    cbSize = sizeof(_ftLastWrite);
    dwError = SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WP_LASTWRITE, &dwType, (void *) &_ftLastWrite, &cbSize);

    return S_OK;    // Ignore the hr because it's fine if the value wasn't found.
}


#define POLICY_DISABLECOLORCUSTOMIZATION_ON            0x00000001

HRESULT CBackPropSheetPage::_LoadBackgroundColor(IN BOOL fInit)
{
    HRESULT hr = E_INVALIDARG;

    if (_punkSite)
    {
        IPropertyBag * pPropertyBag;

        hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            _rgbBkgdColor = 0x00000000;

            hr = SHPropertyBag_ReadDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_COLOR, &_rgbBkgdColor);
            if (fInit)
            {
                // Check the policy.
                if (POLICY_DISABLECOLORCUSTOMIZATION_ON == SHRestricted(REST_NODISPLAYAPPEARANCEPAGE))
                {
                    // We need to disable and hide the windows.  We need to disable them so they can't get
                    // focus or accessibility.
                    EnableWindow(GetDlgItem(_hwnd, IDC_BACK_COLORPICKER), FALSE);
                    EnableWindow(GetDlgItem(_hwnd, IDC_BACK_COLORPICKERLABEL), FALSE);

                    ShowWindow(GetDlgItem(_hwnd, IDC_BACK_COLORPICKER), SW_HIDE);
                    ShowWindow(GetDlgItem(_hwnd, IDC_BACK_COLORPICKERLABEL), SW_HIDE);
                }
                else
                {
                    _colorControl.Initialize(GetDlgItem(_hwnd, IDC_BACK_COLORPICKER), _rgbBkgdColor);
                }
            }
            else
            {
                _colorControl.SetColor(_rgbBkgdColor);
            }

            pPropertyBag->Release();
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_Initialize(void)
{
    HRESULT hr = S_OK;

    if (!_fInitialized && g_pActiveDesk)
    {
        WCHAR szPath[MAX_PATH];

        // Add & select the current setting.
        hr = g_pActiveDesk->GetWallpaper(szPath, ARRAYSIZE(szPath), 0);
        if (SUCCEEDED(hr))
        {
            hr = _LoadTempWallpaperSettings(szPath);
            _fInitialized = TRUE;
        }
    }

    return hr;
}


void CBackPropSheetPage::_OnInitDialog(HWND hwnd)
{
    int i;
    TCHAR szBuf[MAX_PATH];

    _Initialize();

    _colorControl.ChangeTheme(hwnd);

    // Upgrade the pattern setting.  Since we got rid of the UI, we want to
    // get rid of the setting on upgrade.  We only want to do this once since
    // if the user added it back, we don't want to redelete it.
    if (FALSE == SHRegGetBoolUSValue(SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CP_PATTERNUPGRADE, FALSE, FALSE))
    {
        SHDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CP_PATTERN);
        SHSetValue(HKEY_CURRENT_USER,  SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CP_PATTERNUPGRADE, REG_SZ, TEXT("TRUE"), ((lstrlen(TEXT("TRUE")) + 1) * sizeof(TCHAR)));
    }

    //
    // Set some member variables.
    //
    _hwnd = hwnd;
    _hwndLV = GetDlgItem(hwnd, IDC_BACK_WPLIST);
    _hwndWPStyle = GetDlgItem(hwnd, IDC_BACK_WPSTYLE);
    HWND hWndPrev = GetDlgItem(hwnd, IDC_BACK_PREVIEW);
    if (hWndPrev)
    {
        SetWindowBits(hWndPrev, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
    }
    _UpdatePreview(0, FALSE);

    InitDeskHtmlGlobals();

    if (!g_pActiveDesk)
    {
        return;
    }

    //
    // Read in the restrictions.
    //
    _fForceAD = SHRestricted(REST_FORCEACTIVEDESKTOPON);
    _fAllowAD = _fForceAD || !PolicyNoActiveDesktop();
    
    if (_fAllowAD == FALSE)
    {
        _fAllowHtml = FALSE;
    }
    else
    {
        _fAllowHtml = !SHRestricted(REST_NOHTMLWALLPAPER);
    }

    //
    // Check to see if there is a policy for Wallpaper name and wallpaper style.
    //
    _fPolicyForWallpaper = ReadPolicyForWallpaper(NULL, 0);
    _fPolicyForStyle = ReadPolicyForWPStyle(NULL);

    //
    // Get the images into the listview.
    //
    HIMAGELIST himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON), ILC_MASK | ILC_COLOR32, ARRAYSIZE(c_rgpszWallpaperExt),
        ARRAYSIZE(c_rgpszWallpaperExt));
    if (himl)
    {
        SHFILEINFO sfi;

        // Add the 'None' icon.
        HICON hIconNone = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_BACK_NONE),
            IMAGE_ICON, GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), 0);
        ImageList_AddIcon(himl, hIconNone);

        const int iPrefixLen = ARRAYSIZE("foo.") - 1; // -1 means lose the NULL char
        StringCchCopy(szBuf, ARRAYSIZE(szBuf), TEXT("foo.")); //Pass "foo.bmp" etc., to SHGetFileInfo instead of ".bmp"
        for (i=0; i<ARRAYSIZE(c_rgpszWallpaperExt); i++)
        {
            StringCchCopy(szBuf + iPrefixLen, ARRAYSIZE(szBuf) - iPrefixLen, c_rgpszWallpaperExt[i]);

            if (SHGetFileInfo(szBuf, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES))
            {
                ImageList_AddIcon(himl, sfi.hIcon);
                DestroyIcon(sfi.hIcon);
            }
        }
        ListView_SetImageList(_hwndLV, himl, LVSIL_SMALL);
    }

    // Add the single column that we want.
    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;
    ListView_InsertColumn(_hwndLV, 0, &lvc);

    // Add 'none' option.
    _AddAFileToLV(NULL, g_szNone, 0);

    // Add the rest of the files.
    _AddFilesToList();

    // Sort the standard items.
    ListView_SortItems(_hwndLV, _SortBackgrounds, 0);

    WCHAR   wszBuf[MAX_PATH];
    LPTSTR  pszBuf;

    // Add & select the current setting.
    g_pActiveDesk->GetWallpaper(wszBuf, ARRAYSIZE(wszBuf), 0);

    //Convert wszBuf to szBuf.
    pszBuf = (LPTSTR)wszBuf;

    if (!_fAllowHtml && !IsNormalWallpaper(pszBuf))
    {
        *pszBuf = TEXT('\0');
    }
    _SetNewWallpaper(pszBuf, FALSE);

    int iEndStyle = WPSTYLE_STRETCH;
    for (i=0; i<= iEndStyle; i++)
    {
        LoadString(HINST_THISDLL, IDS_WPSTYLE+i, szBuf, ARRAYSIZE(szBuf));
        ComboBox_AddString(_hwndWPStyle, szBuf);
    }
    WALLPAPEROPT wpo;
    wpo.dwSize = sizeof(wpo);
    g_pActiveDesk->GetWallpaperOptions(&wpo, 0);

    ComboBox_SetCurSel(_hwndWPStyle, wpo.dwStyle);

    // Adjust various UI components.
    if (!_fAllowChanges)
    {
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_DISPLAY), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_WPSTYLE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_BROWSE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_WPLIST), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_SELECT), FALSE);
    }

    // Disable controls based on the policies
    if(_fPolicyForWallpaper)
    {
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_BROWSE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_WPLIST), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_SELECT), FALSE);
    }

    if(_fPolicyForStyle)
    {
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_WPSTYLE), FALSE);
        EnableWindow(GetDlgItem(_hwnd, IDC_BACK_DISPLAY), FALSE);
    }
    
    COMPONENTSOPT co;
    co.dwSize = sizeof(COMPONENTSOPT);
    g_pActiveDesk->GetDesktopItemOptions(&co, 0);

    //if activedesktop is forced to be on, this overrides the NOACTIVEDESKTOP restriction
    if (_fForceAD)
    {
        if(!co.fActiveDesktop)
        {
            co.fActiveDesktop = TRUE;
            g_pActiveDesk->SetDesktopItemOptions(&co, 0);
        }
    }
    else
    {
        //See if Active Desktop is to be turned off by restriction.
        if (!_fAllowAD)
        {
            if (co.fActiveDesktop)
            {
                co.fActiveDesktop = FALSE;
                g_pActiveDesk->SetDesktopItemOptions(&co, 0);
            }
        }
    }

    _EnableControls();

    _LoadBackgroundColor(TRUE);
    if (_fOpenAdvOnInit)
    {
        // Tell the Advanced dialog to open.
        PostMessage(_hwnd, WM_COMMAND, (WPARAM)IDC_BACK_WEB, (LPARAM)GetDlgItem(_hwnd, IDC_BACK_WEB));
    }

    _StartSizeChecker();
}


// This function checks to see if the currently selected wallpaper is a HTML wallpaper
// and if so, it makes sure that the active desktop is enabled. If it is disabled
// then it prompts the user asking a question to see if the user wants to enable it.
//
void EnableADifHtmlWallpaper(HWND hwnd)
{
    if(!g_pActiveDesk)
    {
        return;
    }

    // turn active desktop on or off, depending on background
    ActiveDesktop_ApplyChanges();
}


void CBackPropSheetPage::_OnNotify(LPNMHDR lpnm)
{
    //
    //  Start with a small stack allocation.
    //

    WCHAR   wszBuf[MAX_PATH];
    LPWSTR  pszBuf = wszBuf;
    DWORD   cchBuf = ARRAYSIZE(wszBuf);
    
    switch (lpnm->code)
    {
    case PSN_SETACTIVE:
        {
            HRESULT hr;

            //
            // Make sure the correct wallpaper is selected.
            //

            hr = g_pActiveDesk->GetWallpaper(pszBuf, cchBuf, 0);
            if (FAILED(hr))
                break;

            //
            //  If we need more room, allocate it on the heap and try again.
            //

            if ( MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_MORE_DATA ) == hr )
            {
                cchBuf = INTERNET_MAX_URL_LENGTH;
                pszBuf = (LPWSTR) LocalAlloc( LPTR, cchBuf * sizeof(WCHAR) );
                if ( NULL == pszBuf )
                    break;

                hr = g_pActiveDesk->GetWallpaper(pszBuf, cchBuf, 0);
                if (S_OK != hr)
                    break;
            }

            _LoadBackgroundColor(FALSE);
            _SetNewWallpaper(pszBuf, FALSE);

            if (g_pActiveDesk)
            {
                WALLPAPEROPT wpo;
                wpo.dwSize = sizeof(wpo);
                g_pActiveDesk->GetWallpaperOptions(&wpo, 0);
                ComboBox_SetCurSel(_hwndWPStyle, wpo.dwStyle);
            }
        }
        break;

    case PSN_APPLY:
        _OnApply();
        break;

    case LVN_ITEMCHANGED:
        NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)lpnm;
        if ((pnmlv->uChanged & LVIF_STATE) &&
            (pnmlv->uNewState & LVIS_SELECTED))
        {
            LV_ITEM lvi = {0};

            lvi.iItem = pnmlv->iItem;
            lvi.mask = LVIF_PARAM;
            ListView_GetItem(_hwndLV, &lvi);
            LPCTSTR pszSelectedNew = (LPCTSTR)lvi.lParam;

            //
            // Make sure the correct wallpaper is selected.
            //

            HRESULT hr = g_pActiveDesk->GetWallpaper(pszBuf, cchBuf, 0);
            if (FAILED(hr))
                break;

            //
            //  If we need more room, allocate it on the heap and try again.
            //

            if ( MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_MORE_DATA ) == hr )
            {
                cchBuf = INTERNET_MAX_URL_LENGTH;
                pszBuf = (LPWSTR) LocalAlloc( LPTR, cchBuf * sizeof(WCHAR) );
                if ( NULL == pszBuf )
                    break;

                hr = g_pActiveDesk->GetWallpaper(pszBuf, cchBuf, 0);
                if (S_OK != hr)
                    break;
            }

            if (lstrcmp(pszSelectedNew, pszBuf) != 0)
            {
                _SetNewWallpaper(pszSelectedNew, _fSelectionFromUser);
                EnableApplyButton(_hwnd);
            }
        }
        break;
    }

    //
    //  Free heap allocation (if any)
    //

    if ( wszBuf != pszBuf && NULL != pszBuf )
    {
        LocalFree( pszBuf );
    }
}



#define MAX_PAGES                   12

// Parameters:
// hwnd: We parent our UI on this hwnd.
// dwPage: Which page does the caller want to come up as default?
//         Use ADP_DEFAULT if they don't care
// Return: S_OK if the user closed the dialog with OK.
//         HRESULT_FROM_WIN32(ERROR_CANCELLED) will be returned
//         if the user clicked the cancel button.
HRESULT CBackPropSheetPage::_LaunchAdvancedDisplayProperties(HWND hwnd)
{
    HRESULT hr = E_OUTOFMEMORY;
    CCompPropSheetPage * pWebDialog = new CCompPropSheetPage();

    if (pWebDialog)
    {
        BOOL fEnableApply = FALSE;

        IUnknown_SetSite(SAFECAST(pWebDialog, IObjectWithSite *), SAFECAST(this, IObjectWithSite *));
        hr = pWebDialog->DisplayAdvancedDialog(_hwnd, SAFECAST(this, IPropertyBag *), &fEnableApply);
        if (SUCCEEDED(hr) && (fEnableApply || _fHideDesktopIconDirty))
        {
            EnableApplyButton(_hwnd);
        }

        IUnknown_SetSite(SAFECAST(pWebDialog, IObjectWithSite *), NULL);
        pWebDialog->Release();
    }

    return hr;
}

void CBackPropSheetPage::_OnCommand(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WORD wNotifyCode = HIWORD(wParam);
    WORD wID = LOWORD(wParam);
    HWND hwndCtl = (HWND)lParam;

    switch (wID)
    {
    case IDC_BACK_WPSTYLE:
        switch (wNotifyCode)
        {
        case CBN_SELCHANGE:
            WALLPAPEROPT wpo;

            wpo.dwSize = sizeof(WALLPAPEROPT);
            g_pActiveDesk->GetWallpaperOptions(&wpo, 0);
            wpo.dwStyle = ComboBox_GetCurSel(_hwndWPStyle);
            g_pActiveDesk->SetWallpaperOptions(&wpo, 0);

            _EnableControls();
            _UpdatePreview(0, TRUE);
            EnableApplyButton(_hwnd);
            break;
        }
        break;

    case IDC_BACK_BROWSE:
        _BrowseForBackground();
        break;

    case IDC_BACK_WEB:
        _LaunchAdvancedDisplayProperties(_hwnd);
        break;

    case IDC_BACK_COLORPICKER:
        {
            COLORREF rbgColorNew;

            if (SUCCEEDED(_colorControl.OnCommand(hdlg, uMsg, wParam, lParam)) &&
                SUCCEEDED(_colorControl.GetColor(&rbgColorNew)) &&
                (rbgColorNew != _rgbBkgdColor))
            {
                _rgbBkgdColor = rbgColorNew;
                if (_punkSite)
                {
                    IPropertyBag * pPropertyBag;

                    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag))))
                    {
                        SHPropertyBag_WriteDWORD(pPropertyBag, SZ_PBPROP_BACKGROUND_COLOR, _rgbBkgdColor);
                        pPropertyBag->Release();
                    }
                }
                EnableApplyButton(_hwnd);
                _UpdatePreview(0, TRUE);
            }
        }
        break;
    }
}

HRESULT CBackPropSheetPage::_BrowseForBackground(void)
{
    HRESULT hr;
    WCHAR wszFileName[INTERNET_MAX_URL_LENGTH];

    hr = g_pActiveDesk->GetWallpaper(wszFileName, ARRAYSIZE(wszFileName), 0);
    if (SUCCEEDED(hr))
    {
        WCHAR szTestPath[MAX_PATH];
        WCHAR szPath[MAX_PATH];

        // Default to the directory that contains the current wallpaper
        StringCchCopy(szPath, ARRAYSIZE(szPath), wszFileName);
        PathRemoveFileSpec(szPath);

        // However, if it's one of the boring directories, then use the
        // "My Pictures" folder instead (if available).

        BOOL fBoring = FALSE;

        if (!szPath[0]) // null string is boring
        {
            fBoring = TRUE;
        }
        else if (GetWindowsDirectory(szTestPath, ARRAYSIZE(szTestPath)) &&
            !StrCmpIW(szTestPath, szPath)) // %windir% is boring
        {
            fBoring = TRUE;
        }
        else if (GetSystemDirectory(szTestPath, ARRAYSIZE(szTestPath)) &&
            !StrCmpIW(szTestPath, szPath)) // %windir%\system32 is boring
        {
            fBoring = TRUE;
        }
        else if (GetWindowsDirectory(szTestPath, ARRAYSIZE(szTestPath)) &&
                 PathAppendW(szTestPath, L"Web\\Wallpaper") &&
                 !StrCmpIW(szTestPath, szPath)) // %windir%\web\wallpape ris boring
        {
            fBoring = TRUE;
        }

        hr = S_OK;

        if (fBoring)
        {
            // Switch to CSIDL_MYPICTURES or CSIDL_PERSONAL if available
            if (SHGetSpecialFolderPath(NULL, szTestPath, CSIDL_MYPICTURES, FALSE) ||
                SHGetSpecialFolderPath(NULL, szTestPath, CSIDL_PERSONAL, FALSE))
            {
                StringCchCopy(wszFileName, ARRAYSIZE(wszFileName), szTestPath);
                if (!PathAddBackslash(wszFileName))
                {
                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                }
            }
        }
    }
    else
    {
        hr = S_OK;
        // No current wallpaper.  Use CSIDL_MYPICTURES if available; otherwise,
        // use CSIDL_PERSONAL instead. If that doesn't work either, the code
        // further below will fall back to %windir%.
        if (SHGetSpecialFolderPath(NULL, wszFileName, CSIDL_MYPICTURES, FALSE) ||
            SHGetSpecialFolderPath(NULL, wszFileName, CSIDL_PERSONAL, FALSE))
        {
            if (!PathAddBackslash(wszFileName))
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
    }


    if (SUCCEEDED(hr))
    {
        DWORD adwFlags[] =  { GFN_PICTURE,        GFN_PICTURE,        0, 0};
        int   aiTypes[]  =  { IDS_BACK_FILETYPES, IDS_ALL_PICTURES,   0, 0};

        if (_fAllowHtml)
        {
            SetFlag(adwFlags[0], GFN_LOCALHTM);
            SetFlag(adwFlags[2], GFN_LOCALHTM);
            aiTypes[2] = IDS_HTMLDOC;
        }

        if (wszFileName[0] == TEXT('\0'))
        {
            if (!GetWindowsDirectory(wszFileName, ARRAYSIZE(wszFileName)))
            {
                wszFileName[0] = 0;
            }

            // GetFileName breaks up the string into a directory and file
            // component, so we append a slash to make sure everything
            // is considered part of the directory.
            StringCchCat(wszFileName, ARRAYSIZE(wszFileName), TEXT("\\"));
        }

        if (GetFileName(_hwnd, wszFileName, ARRAYSIZE(wszFileName), aiTypes, adwFlags) &&
            ValidateFileName(_hwnd, wszFileName, IDS_BACK_TYPE1))
        {
            if (_fAllowHtml || IsNormalWallpaper(wszFileName))
            {
                _SetNewWallpaper(wszFileName, TRUE);
                EnableApplyButton(_hwnd);
            }
        }
    }

    return hr;
}

void CBackPropSheetPage::_OnDestroy()
{
}


INT_PTR CALLBACK CBackPropSheetPage::BackgroundDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CBackPropSheetPage * pThis = (CBackPropSheetPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pThis = (CBackPropSheetPage *)pPropSheetPage->lParam;
        }
    }

    if (pThis)
        return pThis->_BackgroundDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


BOOL_PTR CBackPropSheetPage::_BackgroundDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDialog(hdlg);
        break;

    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        _OnCommand(hdlg, uMsg, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
    case WM_SETTINGCHANGE:
    case WM_DISPLAYCHANGE:
    case WM_QUERYNEWPALETTE:
    case WM_PALETTECHANGED:
        SHPropagateMessage(hdlg, uMsg, wParam, lParam, TRUE);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_DESKTOPTAB, HELP_WM_HELP, (ULONG_PTR)aBackHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, SZ_HELPFILE_DESKTOPTAB, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aBackHelpIDs);
        break;

    case WM_DESTROY:
        {
            TCHAR szFileName[MAX_PATH];

            //Delete the tempoaray HTX file created for non-HTML wallpaper preview.
            GetTempPath(ARRAYSIZE(szFileName), szFileName);
            if (PathAppend(szFileName, PREVIEW_PICTURE_FILENAME))
            {
                DeleteFile(szFileName);
            }

            _OnDestroy();
        }
        break;

    case WM_DRAWITEM:
        switch (wParam)
        {
            case IDC_BACK_COLORPICKER:
                _colorControl.OnDrawItem(hdlg, uMsg, wParam, lParam);
                return TRUE;
        }
        break;

    case WM_THEMECHANGED:
        _colorControl.ChangeTheme(hdlg);
        break;
    }

    return FALSE;
}


HRESULT CBackPropSheetPage::_OnApply(void)
{
    // Our parent dialog will be notified of the Apply event and will call our
    // IBasePropPage::OnApply() to do the real work.
    return S_OK;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will start a background thread which will make sure our
    MRU of pictures in the Wallpaper list have been checked.  They will be checked
    to verify that we know their width & height.  This way, when we choose a wallpaper, we can quickly
    see if it should use "Stretch" or "Tile".  We want to tile if they are very
    small, indicating that they are probably watermark in nature.
\*****************************************************************************/
#define TIME_SCANFREQUENCY          (8 * 60 /*Secs*/)      // We don't want to rescan the files more than once per 8 minutes

HRESULT CBackPropSheetPage::_StartSizeChecker(void)
{
    HRESULT hr = S_OK;
    BOOL fSkipCheck = FALSE;
    DWORD dwType;
    FILETIME ftLastScan;
    FILETIME ftCurrentTime;
    SYSTEMTIME stCurrentTime;
    DWORD cbSize = sizeof(ftLastScan);

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &ftCurrentTime);

    // If we have recently scanned, skip the scan.
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_WALLPAPER, SZ_REGVALUE_LASTSCAN, &dwType, (LPBYTE) &ftLastScan, &cbSize)) &&
        (REG_BINARY == dwType) &&
        (sizeof(ftLastScan) == cbSize))
    {
        ULARGE_INTEGER * pulLastScan = (ULARGE_INTEGER *)&ftLastScan;
        ULARGE_INTEGER * pulCurrent = (ULARGE_INTEGER *)&ftCurrentTime;
        ULARGE_INTEGER ulDelta;

        ulDelta.QuadPart = (pulCurrent->QuadPart - pulLastScan->QuadPart);
        ulDelta.QuadPart /= 10000000;      //  units in a second
        if (ulDelta.QuadPart < TIME_SCANFREQUENCY)
        {
            fSkipCheck = TRUE;
        }
    }

    if (!fSkipCheck)
    {
        AddRef();
        if (!SHCreateThread(CBackPropSheetPage::SizeCheckerThreadProc, this, (CTF_COINIT | CTF_FREELIBANDEXIT | CTF_PROCESS_REF), NULL))
        {
            hr = E_FAIL;
            Release();
        }

        SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_WALLPAPER, SZ_REGVALUE_LASTSCAN, REG_BINARY, (LPCBYTE) &ftCurrentTime, sizeof(ftLastScan));
    }

    return hr;
}


typedef struct
{
    TCHAR szPath[MAX_PATH];
    DWORD dwSizeX;
    DWORD dwSizeY;
    FILETIME ftLastModified;
} WALLPAPERSIZE_STRUCT;

#define MAX_WALLPAPERSIZEMRU            500

HRESULT CBackPropSheetPage::_GetMRUObject(IMruDataList ** ppSizeMRU)
{
    HRESULT hr = CoCreateInstance(CLSID_MruLongList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMruDataList, ppSizeMRU));

    if (SUCCEEDED(hr))
    {
        hr = (*ppSizeMRU)->InitData(MAX_WALLPAPERSIZEMRU, MRULISTF_USE_STRCMPIW, HKEY_CURRENT_USER, SZ_REGKEY_WALLPAPERMRU, NULL);
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppSizeMRU);
        }
    }

    return hr;
}

HRESULT CBackPropSheetPage::_CalcSizeForFile(IN LPCTSTR pszPath, IN WIN32_FIND_DATA * pfdFile, IN OUT DWORD * pdwAdded)
{
    HRESULT hr = S_OK;

    if (!_pSizeMRUBk)
    {
        hr = _GetMRUObject(&_pSizeMRUBk);
    }

    if (SUCCEEDED(hr))
    {
        WALLPAPERSIZE_STRUCT wallpaperSize;
        int nIndex;

        StringCchCopy(wallpaperSize.szPath, ARRAYSIZE(wallpaperSize.szPath), pszPath);

        // Let's see if it's already in the MRU.
        hr = _pSizeMRUBk->FindData((LPCBYTE) &wallpaperSize, sizeof(wallpaperSize), &nIndex);
        if (SUCCEEDED(hr))
        {
            // If so, let's see if it's been modified since.
            hr = _pSizeMRUBk->GetData(nIndex, (LPBYTE) &wallpaperSize, sizeof(wallpaperSize));
            if (SUCCEEDED(hr))
            {
                if (CompareFileTime(&wallpaperSize.ftLastModified, &pfdFile->ftLastWriteTime))
                {
                    // We want to delete this index because it would colide with the name of
                    // the new entry we are going to add below.
                    _pSizeMRUBk->Delete(nIndex);
                    hr = E_FAIL;        // We need to rescan.
                }
                else
                {
                    (*pdwAdded)++;          // We are only going to check the first 500 files.  We don't want to waste too much time on this heuristical feature.
                }
            }
        }

        if (FAILED(hr))
        {
            (*pdwAdded)++;          // We are only going to check the first 500 files.  We don't want to waste too much time on this heuristical feature.

            hr = S_OK;
            // We didn't find it so we need to add it.
            if (!_pImgFactBk)
            {
                hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &_pImgFactBk));
            }

            if (SUCCEEDED(hr))
            {
                IShellImageData* pImage;

                hr = _pImgFactBk->CreateImageFromFile(pszPath, &pImage);
                if (SUCCEEDED(hr))
                {
                    hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
                    if (SUCCEEDED(hr))
                    {
                        SIZE size;

                        hr = pImage->GetSize(&size);
                        if (SUCCEEDED(hr) && size.cx && size.cy)
                        {
                            DWORD dwSlot = 0;

                            StringCchCopy(wallpaperSize.szPath, ARRAYSIZE(wallpaperSize.szPath), pszPath);
                            wallpaperSize.dwSizeX = size.cx;
                            wallpaperSize.dwSizeY = size.cy;
                            wallpaperSize.ftLastModified = pfdFile->ftLastWriteTime;

                            hr = _pSizeMRUBk->AddData((LPCBYTE) &wallpaperSize, sizeof(wallpaperSize), &dwSlot);
                        }
                    }

                    pImage->Release();
                }
            }
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::_CalcSizeFromDir(IN LPCTSTR pszPath, IN OUT DWORD * pdwAdded, IN BOOL fRecursive)
{
    HRESULT hr = S_OK;

    if (MAX_WALLPAPERSIZEMRU > *pdwAdded)
    {
        WIN32_FIND_DATA findFileData;
        TCHAR szSearchPath[MAX_PATH];

        StringCchCopy(szSearchPath, ARRAYSIZE(szSearchPath), pszPath);
        if (PathAppend(szSearchPath, SZ_ALL_FILTER))
        {
            HANDLE hFindFiles = FindFirstFile(szSearchPath, &findFileData);
            if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
            {
                while (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles) &&
                        (MAX_WALLPAPERSIZEMRU > *pdwAdded))
                {
                    if (!PathIsDotOrDotDot(findFileData.cFileName))
                    {
                        if (FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes)
                        {
                            if (fRecursive)
                            {
                                TCHAR szSubDir[MAX_PATH];

                                StringCchCopy(szSubDir, ARRAYSIZE(szSubDir), pszPath);
                                if(PathAppend(szSubDir, findFileData.cFileName))
                                {
                                    hr = _CalcSizeFromDir(szSubDir, pdwAdded, fRecursive);
                                }
                                else
                                {
                                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                                }
                            }
                        }
                        else
                        {
                            if (IsGraphicsFile(findFileData.cFileName))
                            {
                                TCHAR szPath[MAX_PATH];

                                StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath);
                                if (PathAppend(szPath, findFileData.cFileName))
                                {
                                    hr = _CalcSizeForFile(szPath, &findFileData, pdwAdded);
                                }
                                else
                                {
                                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                                }
                            }
                        }
                    }

                    if (!FindNextFile(hFindFiles, &findFileData))
                    {
                        break;
                    }
                }

                FindClose(hFindFiles);
            }
        }
        else
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will create or update the sizes of the files we have in the
    wallpaper list.  We can later use this to decide if we want to select "Tile"
    vs. "Stretch".

    PERF:
        We don't track more than 500 files because we want to keep the MRU from
    growing too much.  Users shouldn't have more than that many files normally.
    And if so, they won't get this feature.
    Max 500 Files: First scan will take ~35 seconds on a 300MHz 128MB machine.
    Max 500 Files: Update scan will take ~3 seconds on a 300MHz 128MB machine.
\*****************************************************************************/
DWORD CBackPropSheetPage::_SizeCheckerThreadProc(void)
{
    HRESULT hr;
    DWORD dwAdded = 0;
    TCHAR szPath[MAX_PATH];

    //  We want to make our priority low so we don't slow down the UI.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    // Get the directory with the wallpaper files.
    if (!GetStringFromReg(HKEY_LOCAL_MACHINE, c_szSetup, c_szSharedDir, szPath, ARRAYSIZE(szPath)))
    {
        if (!GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            szPath[0] = 0;
        }
    }

    // Add only the *.BMP files in the windows directory.
    _CalcSizeFromDir(szPath, &dwAdded, FALSE);

    // Get the wallpaper Directory name
    szPath[0] = 0;
    GetWallpaperDirName(szPath, ARRAYSIZE(szPath));

    if (szPath[0])
    {
        // Add all pictures from Wallpaper directory to the list!
        _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }

    //Get the path to the "My Pictures" folder; do not autocreate
    if (S_OK == SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, 0, szPath))
    {
        // Add all pictures in "My Pictures" directory to the list!
        hr = _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }

    //Get the path to the common "My Pictures" folder; do not autocreate
    if (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_PICTURES, NULL, 0, szPath))
    {
        // Add all pictures in common "My Pictures" directory to the list!
        hr = _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }

    // Add pictures from Theme Directories
    // The follwoing directories can contain themes:
    //   Plus!98 Install Path\Themes
    //   Plus!95 Install Path\Themes
    //   Kids for Plus! Install Path\Themes
    //   Program Files\Plus!\Themes
    if (SUCCEEDED(_GetPlus98ThemesDir(szPath, ARRAYSIZE(szPath))))
    {
        _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }
    else if (SUCCEEDED(_GetPlus95ThemesDir(szPath, ARRAYSIZE(szPath))))
    {
        _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }
    else if (SUCCEEDED(_GetKidsThemesDir(szPath, ARRAYSIZE(szPath))))
    {
        _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }
    else if (SUCCEEDED(_GetHardDirThemesDir(szPath, ARRAYSIZE(szPath))))
    {
        _CalcSizeFromDir(szPath, &dwAdded, TRUE);
    }

    ATOMICRELEASE(_pSizeMRUBk);
    ATOMICRELEASE(_pImgFactBk);
    _fScanFinished = TRUE;

    Release();
    return 0;
}


// We decide to use tile mode if the width and height of the
// picture are 256x256 or smaller.  Anything this small is most
// likely a watermark.  Besides, it will always look bad stretched
// or centered.
// We make exceptions for the following wallpaper that we ship
// that is watermark:
// "Boiling Point.jpg", which is 163x293.
// "Fall Memories.jpg", which is 210x185.
// "Fly Away.jpg", which is 210x185.
// "Prairie Wind.jpg", which is 255x255.
// "Santa Fe Stucco.jpg", which is 256x256.
// "Soap Bubbles.jpg", which is 256x256.
// "Water Color.jpg", which is 218x162.
#define SHOULD_USE_TILE(xPicture, yPicture, xMonitor, yMonitor)     ((((((LONG)(xPicture) * 6) < (xMonitor)) && (((LONG)(yPicture) * 6) < (yMonitor)))) ||  \
     (((xPicture) <= 256) && ((yPicture) <= 256)) ||  \
     (((xPicture) == 163) && ((yPicture) == 293)))

DWORD CBackPropSheetPage::_GetStretchMode(IN LPCTSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD dwStretchMode = WPSTYLE_STRETCH;  // Default to Stretch.

    if (_fScanFinished)
    {
        // If we just finished the Scan, we want to release _pSizeMRU and get a new one.
        // The object will cache the registry state so it may have none or very few of the results
        // because it was obtained before the background thread did all it's work.
        ATOMICRELEASE(_pSizeMRU);
        _fScanFinished = FALSE;
    }

    if (!_pSizeMRU)
    {
        hr = _GetMRUObject(&_pSizeMRU);
    }

    if (SUCCEEDED(hr))
    {
        WALLPAPERSIZE_STRUCT wallpaperSize;
        int nIndex;

        StringCchCopy(wallpaperSize.szPath, ARRAYSIZE(wallpaperSize.szPath), pszPath);

        // Let's see if it's already in the MRU.
        hr = _pSizeMRU->FindData((LPCBYTE) &wallpaperSize, sizeof(wallpaperSize), &nIndex);
        if (SUCCEEDED(hr))
        {
            // If so, let's see if it's been modified since.
            hr = _pSizeMRU->GetData(nIndex, (LPBYTE) &wallpaperSize, sizeof(wallpaperSize));
            if (SUCCEEDED(hr))
            {
                WIN32_FIND_DATA findFileData;

                HANDLE hFindFiles = FindFirstFile(pszPath, &findFileData);
                if (hFindFiles && (INVALID_HANDLE_VALUE != hFindFiles))
                {
                    // Yes, the value exists and is up to date.
                    if (!CompareFileTime(&wallpaperSize.ftLastModified, &findFileData.ftLastWriteTime))
                    {
                        RECT rc;
                        GetMonitorRects(GetPrimaryMonitor(), &rc, 0);

                        // We decide to use tile mode if the width and height of the
                        // picture are 1/6th the size of the default monitor.
                        if (SHOULD_USE_TILE(wallpaperSize.dwSizeX, wallpaperSize.dwSizeY, RECTWIDTH(rc), RECTHEIGHT(rc)))
                        {
                            dwStretchMode = WPSTYLE_TILE;
                        }
                        else
                        {
                            double dWidth = ((double)wallpaperSize.dwSizeX * ((double)RECTHEIGHT(rc) / ((double)RECTWIDTH(rc))));

                            // We want to use WPSTYLE_CENTER if it's more than 7% off of a 4x3 aspect ratio.
                            // We do this to prevent it from looking bad because it's stretched too much in
                            // one direction.  The reason we use 7% is because some common screen solutions
                            // (1280 x 1024) aren't 4x3, but they are under 7% of that.
                            if (dWidth <= (wallpaperSize.dwSizeY * 1.07) && (dWidth >= (wallpaperSize.dwSizeY * 0.92)))
                            {
                                dwStretchMode = WPSTYLE_STRETCH;    // This is within 4x3
                            }
                            else
                            {
                                dwStretchMode = WPSTYLE_CENTER;
                            }
                        }
                    }

                    FindClose(hFindFiles);
                }
            }
        }
    }

    return dwStretchMode;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CBackPropSheetPage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;

        hr = _LoadState();
        if (SUCCEEDED(hr))
        {
            CCompPropSheetPage * pThis = new CCompPropSheetPage();

            if (pThis)
            {
                hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
                pThis->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}


HRESULT CBackPropSheetPage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if (PPOAACTION_CANCEL != oaAction)
    {
        if (_fAllowChanges)
        {
            // The user clicked Okay in the dialog so merge the dirty state from the
            // advanced dialog into the base dialog.
            EnableADifHtmlWallpaper(_hwnd);
            SetSafeMode(SSM_CLEAR);

            g_pActiveDesk->SetWallpaper(_pszOriginalFile, 0);
            SetSafeMode(SSM_CLEAR);
            EnableADifHtmlWallpaper(_hwnd);
            if (g_pActiveDesk)
            {
                g_pActiveDesk->ApplyChanges(g_dwApplyFlags);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = _SaveIconState();
            if (SUCCEEDED(hr))
            {
                hr = _SaveDesktopOptionsState();
            }
        }

        if (g_iRunDesktopCleanup != BST_INDETERMINATE)
        {
            ApplyDesktopCleanupSettings(); // ignore return value, as nobody cares about it
        }


        SetWindowLongPtr(_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
    }

    return hr;
}


BOOL IsIconHeaderProperty(IN LPCOLESTR pszPropName)
{
    return (!StrCmpNIW(SZ_ICONHEADER, pszPropName, ARRAYSIZE(SZ_ICONHEADER) - 1) &&
                 ((ARRAYSIZE(SZ_ICONHEADER) + MAX_GUID_STRING_LEN - 1) < lstrlenW(pszPropName)));
}

BOOL IsShowDeskIconProperty(IN LPCOLESTR pszPropName)
{
    return ((!StrCmpNIW(STARTPAGE_ON_PREFIX, pszPropName, LEN_PROP_PREFIX) ||
            !StrCmpNIW(STARTPAGE_OFF_PREFIX, pszPropName, LEN_PROP_PREFIX) ||
            !StrCmpNIW(POLICY_PREFIX, pszPropName, LEN_PROP_PREFIX)) &&
            ((LEN_PROP_PREFIX + MAX_GUID_STRING_LEN - 1) <= lstrlenW(pszPropName)));
}


//===========================
// *** IPropertyBag Interface ***
//===========================
HRESULT CBackPropSheetPage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        VARTYPE vtDesired = pVar->vt;

        if (!StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_PATH))       // Get the real current wallpaper (after conversion to .bmp)
        {
            WCHAR szPath[MAX_PATH];

            hr = g_pActiveDesk->GetWallpaper(szPath, ARRAYSIZE(szPath), 0);
            if (SUCCEEDED(hr))
            {
                WCHAR szFullPath[MAX_PATH];

                // The string may come back with environment variables.
                if (0 == SHExpandEnvironmentStrings(szPath, szFullPath, ARRAYSIZE(szFullPath)))
                {
                    StringCchCopy(szFullPath, ARRAYSIZE(szFullPath), szPath);  // We failed so use the original.
                }

                hr = InitVariantFromStr(pVar, szFullPath);
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_BACKGROUNDSRC_PATH))   // Get the original wallpaper (before convertion to .bmp)
        {
            WCHAR szPath[MAX_PATH];

            hr = _Initialize();
            if (SUCCEEDED(hr))
            {
                if (_pszLastSourcePath)
                {
                    hr = InitVariantFromStr(pVar, _pszLastSourcePath);
                }
                else if (_pszOrigLastApplied)
                {
                    hr = InitVariantFromStr(pVar, _pszOrigLastApplied);
                }
                else
                {
                    hr = g_pActiveDesk->GetWallpaper(szPath, ARRAYSIZE(szPath), 0);
                    if (SUCCEEDED(hr))
                    {
                        hr = InitVariantFromStr(pVar, szPath);
                    }
                }
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_TILE))
        {
            if (g_pActiveDesk)
            {
                WALLPAPEROPT wpo;

                wpo.dwSize = sizeof(wpo);
                hr = g_pActiveDesk->GetWallpaperOptions(&wpo, 0);
                if (SUCCEEDED(hr))
                {
                    pVar->ulVal = wpo.dwStyle;
                    pVar->vt = VT_UI4;
                }
            }
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_WEBCOMPONENTS))
        {
            if (g_pActiveDesk)
            {
                g_pActiveDesk->AddRef();
                pVar->punkVal = g_pActiveDesk;
                pVar->vt = VT_UNKNOWN;
                hr = S_OK;
            }
        }
        else if (IsIconHeaderProperty(pszPropName))
        {
            // The caller can pass us the string in the following format:
            // pszPropName="CLSID\{<CLSID>}\DefaultIcon:<Item>" = "<FilePath>,<ResourceIndex>"
            // For example:
            // pszPropName="CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon:DefaultValue" = "%WinDir%SYSTEM\COOL.DLL,16"
            hr = _LoadState();
            if (SUCCEEDED(hr))
            {
                CLSID clsid;
                WCHAR szTemp[MAX_PATH];

                // Get the CLSID
                StringCchCopy(szTemp, ARRAYSIZE(szTemp), &(pszPropName[ARRAYSIZE(SZ_ICONHEADER) - 2]));
                hr = SHCLSIDFromString(szTemp, &clsid);
                if (SUCCEEDED(hr))
                {
                    // Get the name of the icon type.  Normally this is "DefaultIcon", but it can be several states, like
                    // "full" and "empty" for the recycle bin.
                    LPCWSTR pszToken = StrChrW((pszPropName + ARRAYSIZE(SZ_ICONHEADER)), L':');
                    BOOL fOldIcon = FALSE;

                    // If they use a ";" instead of a ":" then they want the old icon.
                    if (!pszToken)
                    {
                        pszToken = StrChrW((pszPropName + ARRAYSIZE(SZ_ICONHEADER)), L';');
                        fOldIcon = TRUE;
                    }

                    hr = E_FAIL;
                    if (pszToken)
                    {
                        TCHAR szIconPath[MAX_PATH];

                        pszToken++;
                        hr = _GetIconPath(clsid, pszToken, FALSE, szIconPath, ARRAYSIZE(szIconPath));
                        if (SUCCEEDED(hr))
                        {
                            hr = InitVariantFromStr(pVar, szIconPath);
                        }
                    }
                }
            }
        }
        else if(IsShowDeskIconProperty(pszPropName))
        {
            int iStartPaneOn = (int)(StrCmpNIW(pszPropName, STARTPAGE_ON_PREFIX, LEN_PROP_PREFIX) == 0);
            for(int iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
            {
                if(lstrcmpiW(pszPropName+LEN_PROP_PREFIX, c_aDeskIconId[iIndex].pwszCLSID) == 0)
                {
                    BOOL    fBoolValue = FALSE;
                    pVar->vt = VT_BOOL;
                    //Check if we are looking for the POLICY or for Show/Hide
                    if(!StrCmpNIW(POLICY_PREFIX, pszPropName, LEN_PROP_PREFIX))
                    {
                        //We are reading "whether-the-POLICY-is-set" property!
                        fBoolValue = _aDeskIconNonEnumData[iIndex].fNonEnumPolicySet;
                    }
                    else
                    {
                        //We are reading the fHideIcon property.
                        fBoolValue = _aHideDesktopIcon[iStartPaneOn][iIndex].fHideIcon;
                    }
                    
                    pVar ->boolVal = fBoolValue ? VARIANT_TRUE : VARIANT_FALSE;
                    hr = S_OK;
                    break; //break out of the loop!
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = VariantChangeTypeForRead(pVar, vtDesired);
    }

    return hr;
}


HRESULT CBackPropSheetPage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if ((VT_UI4 == pVar->vt) &&
            _fAllowChanges &&
            !StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_TILE))
        {
            hr = _SetNewWallpaperTile(pVar->ulVal, FALSE);
        }
        if (!StrCmpW(pszPropName, SZ_PBPROP_OPENADVANCEDDLG) &&
                (VT_BOOL == pVar->vt))
        {
            _fOpenAdvOnInit = (VARIANT_TRUE == pVar->boolVal);
            hr = S_OK;
        }
        else if (!StrCmpW(pszPropName, SZ_PBPROP_WEBCOMPONENTS) &&
                (VT_UNKNOWN == pVar->vt))
        {
            IUnknown_Set((IUnknown **) &g_pActiveDesk, pVar->punkVal);
            hr = S_OK;
        }
        else if (VT_BSTR == pVar->vt)
        {
            if (_fAllowChanges && !StrCmpW(pszPropName, SZ_PBPROP_BACKGROUND_PATH))
            {
                _fWallpaperChanged = TRUE;
                hr = _SetNewWallpaper(pVar->bstrVal, FALSE);
            }
            else if (IsIconHeaderProperty(pszPropName))
            {
                // The caller can pass us the string in the following format:
                // pszPropName="CLSID\{<CLSID>}\DefaultIcon:<Item>" = "<FilePath>,<ResourceIndex>"
                // For example:
                // pszPropName="CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon:DefaultValue" = "%WinDir%SYSTEM\COOL.DLL,16"
                hr = _LoadState();
                if (SUCCEEDED(hr))
                {
                    CLSID clsid;
                    WCHAR szTemp[MAX_PATH];

                    // Get the CLSID
                    StringCchCopy(szTemp, ARRAYSIZE(szTemp), &(pszPropName[ARRAYSIZE(SZ_ICONHEADER) - 2]));
                    hr = SHCLSIDFromString(szTemp, &clsid);
                    if (SUCCEEDED(hr))
                    {
                        // Get the name of the icon type.  Normally this is "DefaultIcon", but it can be several states, like
                        // "full" and "empty" for the recycle bin.
                        LPCWSTR pszToken = StrChrW((pszPropName + ARRAYSIZE(SZ_ICONHEADER)), L':');

                        hr = E_FAIL;
                        if (pszToken)
                        {
                            pszToken++;

                            StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszToken);

                            // Now the pVar->bstrVal is the icon path + "," + resourceID.  Separate those two.
                            WCHAR szPath[MAX_PATH];

                            StringCchCopy(szPath, ARRAYSIZE(szPath), pVar->bstrVal);

                            int nResourceID = PathParseIconLocationW(szPath);
                            hr = _SetIconPath(clsid, szTemp, szPath, nResourceID);
                        }
                    }
                }
            }
        }
        else if((VT_BOOL == pVar->vt) && (IsShowDeskIconProperty(pszPropName)))
        {
            int iStartPaneOn = (int)(StrCmpNIW(pszPropName, STARTPAGE_ON_PREFIX, LEN_PROP_PREFIX) == 0);
            for(int iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
            {
                if(lstrcmpiW(pszPropName+LEN_PROP_PREFIX, c_aDeskIconId[iIndex].pwszCLSID) == 0)
                {
                    BOOL fNewHideIconStatus = (VARIANT_TRUE == pVar->boolVal);

                    //check if the new hide icon status is different from the old one.
                    if(_aHideDesktopIcon[iStartPaneOn][iIndex].fHideIcon != fNewHideIconStatus)
                    {
                        _aHideDesktopIcon[iStartPaneOn][iIndex].fHideIcon = fNewHideIconStatus;
                        _aHideDesktopIcon[iStartPaneOn][iIndex].fDirty = TRUE;
                        _fHideDesktopIconDirty = TRUE; 
                    }
                        
                    hr = S_OK;
                    break; //break out of the loop!
                }
            }
        }
    }

    return hr;
}





//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CBackPropSheetPage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;
    PROPSHEETPAGE psp = {0};

    // If classic shell is forced, then we desk.cpl will put-up the old background page
    // So, we should not replace that with this new background page.
    // (Note: All other ActiveDesktop restrictions are checked in dcomp.cpp to prevent
    // the web tab from appearing there).
    if (SHRestricted(REST_CLASSICSHELL))
    {
        // It's restricted, so don't add this page.
        hr = E_ACCESSDENIED;
    }
    else
    {
        // Initialize a bunch of propsheetpage variables.
        psp.dwSize = sizeof(psp);
        psp.hInstance = HINST_THISDLL;
        psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
        psp.lParam = (LPARAM) this;

        // psp.hIcon = NULL; // unused (PSP_USEICON is not set)
        // psp.pszTitle = NULL; // unused (PSP_USETITLE is not set)
        // psp.lParam   = 0;     // unused
        // psp.pcRefParent = NULL;

        psp.pszTemplate = MAKEINTRESOURCE(IDD_BACKGROUND);
        psp.pfnDlgProc = CBackPropSheetPage::BackgroundDlgProc;

        HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            if (pfnAddPage(hpsp, lParam))
            {
                hr = S_OK;
            }
            else
            {
                DestroyPropertySheetPage(hpsp);
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CBackPropSheetPage::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CBackPropSheetPage::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


HRESULT CBackPropSheetPage::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CBackPropSheetPage, IObjectWithSite),
        QITABENT(CBackPropSheetPage, IBasePropPage),
        QITABENT(CBackPropSheetPage, IPersist),
        QITABENT(CBackPropSheetPage, IPropertyBag),
        QITABENTMULTI(CBackPropSheetPage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



//===========================
// *** Class Methods ***
//===========================
CBackPropSheetPage::CBackPropSheetPage(void) : CObjectCLSID(&PPID_Background)
{
    _cRef = 1;
    _punkSite = NULL;

    _pszOriginalFile = NULL;
    _pszLastSourcePath = NULL;
    _pszOrigLastApplied = NULL;
    _pszWallpaperInUse = NULL;
    _pImgFactBk = NULL;
    _pSizeMRU = NULL;
    _pSizeMRUBk = NULL;
    _fThemePreviewCreated = FALSE;
    _pThemePreview = NULL;

    _fWallpaperChanged = FALSE;
    _fSelectionFromUser = TRUE;
    _fStateLoaded = FALSE;
    _fOpenAdvOnInit = FALSE;
    _fScanFinished = FALSE;
    _fInitialized = FALSE;

    _fAllowChanges = (!SHRestricted(REST_NOCHANGINGWALLPAPER) && !IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) && !IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper));
    g_dwApplyFlags = (AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
    GetActiveDesktop(&g_pActiveDesk);
}


CBackPropSheetPage::~CBackPropSheetPage(void)
{
    ASSERT(!_pSizeMRUBk);       // Should have been released by the background thread.
    ASSERT(!_pImgFactBk);       // Should have been released by the background thread.

    Str_SetPtr(&_pszOriginalFile, NULL);
    Str_SetPtrW(&_pszOrigLastApplied, NULL);
    Str_SetPtrW(&_pszWallpaperInUse, NULL);
    Str_SetPtrW(&_pszLastSourcePath, NULL);

    if (_pSizeMRU)
    {
        _pSizeMRU->Release();
        _pSizeMRU = NULL;
    }

    if (_pThemePreview)
    {
        _pThemePreview->Release();
        _pThemePreview = NULL;
    }
    ReleaseActiveDesktop(&g_pActiveDesk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\colorctrl.cpp ===
/*****************************************************************************\
    FILE: ColorCtrl.cpp

    DESCRIPTION:
        This code will display a ColorPicking control.  It will preview a color
    and have a drop down arrow.  When dropped down, it will show 16 or so common
    colors with a "Other..." option for a full color picker.

    BryanSt 7/25/2000    Converted from the Display Control Panel.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"
#include "utils.h"
#include "ColorCtrl.h"

#include "uxtheme.h"
#include "tmschema.h"

#pragma hdrstop



//============================================================================================================
// *** Globals ***
//============================================================================================================
#define WM_USER_STARTCAPTURE_COLORPICKER            (WM_APP+1)

#define CPI_VGAONLY 0x0001
#define CPI_PALETTEOK   0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

#define ZERO_DIV_PROTECT(number)            (((number) == 0) ? 1 : (number))

// Macro to replace MAKEPOINT() since points now have 32 bit x & y
#define LPARAM2POINT( lp, ppt )         ((ppt)->x = (int)(short)LOWORD(lp), (ppt)->y = (int)(short)HIWORD(lp))




//===========================
// *** Class Internals & Helpers ***
//===========================
/////////////////////////////////////////////////////////////////////
// Palette Helpers
/////////////////////////////////////////////////////////////////////
COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}


BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}


HRESULT CColorControl::_InitColorAndPalette(void)
{
    HDC hdc = GetDC(NULL);

    m_fPalette = FALSE;
    if (hdc)
    {
        m_fPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
        ReleaseDC(NULL, hdc);
    }

    // always make a palette even on non-pal device
    DWORD pal[21];
    HPALETTE hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    pal[1]  = RGB(255, 255, 255);
    pal[2]  = RGB(0,   0,   0  );
    pal[3]  = RGB(192, 192, 192);
    pal[4]  = RGB(128, 128, 128);
    pal[5]  = RGB(255, 0,   0  );
    pal[6]  = RGB(128, 0,   0  );
    pal[7]  = RGB(255, 255, 0  );
    pal[8]  = RGB(128, 128, 0  );
    pal[9]  = RGB(0  , 255, 0  );
    pal[10] = RGB(0  , 128, 0  );
    pal[11] = RGB(0  , 255, 255);
    pal[12] = RGB(0  , 128, 128);
    pal[13] = RGB(0  , 0,   255);
    pal[14] = RGB(0  , 0,   128);
    pal[15] = RGB(255, 0,   255);
    pal[16] = RGB(128, 0,   128);

    GetPaletteEntries(hpal, 11, 1, (LPPALETTEENTRY)&pal[17]);
    pal[0]  = MAKELONG(0x300, 17);
    m_hpalVGA = CreatePalette((LPLOGPALETTE)pal);

    // get magic colors
    GetPaletteEntries(hpal, 8,  4, (LPPALETTEENTRY)&pal[17]);

    pal[0]  = MAKELONG(0x300, 20);
    m_hpal3D = CreatePalette((LPLOGPALETTE)pal);

    return S_OK;
}


#define RGB_PALETTE 0x02000000

//  make the color a solid color if it needs to be.
//  on a palette device make is a palette relative color, if we need to.
COLORREF CColorControl::_NearestColor(COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    // if we are on a palette device, we need to do special stuff...
    if (m_fPalette)
    {
        if (IsPaletteColor(m_hpal3D, rgb))
            rgb |= RGB_PALETTE;

        else if (IsPaletteColor((HPALETTE)GetStockObject(DEFAULT_PALETTE), rgb))
            rgb ^= 0x000001;    // force a dither
    }

    return rgb;
}


HRESULT CColorControl::_SaveCustomColors(void)
{
    HRESULT hr = E_FAIL;
    HKEY hkAppear;

    // save out possible changes to custom color table
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_WRITE, &hkAppear) == ERROR_SUCCESS)
    {
        DWORD dwError = RegSetValueEx(hkAppear, REGSTR_VAL_CUSTOMCOLORS, 0L, REG_BINARY, (LPBYTE)m_rbgCustomColors, sizeof(m_rbgCustomColors));
        hr = HRESULT_FROM_WIN32(dwError);

        RegCloseKey(hkAppear);
    }

    return hr;
}

void CColorControl::_DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled)
{
    HBRUSH hbr;
    int x, y;

    x = lprc->right - m_cxEdgeSM - 5;
    y = lprc->top + ((lprc->bottom - lprc->top)/2 - 1);

    if (bDisabled)
    {
        hbr = GetSysColorBrush(COLOR_3DHILIGHT);
        hbr = (HBRUSH) SelectObject(hdc, hbr);

        x++;
        y++;
        PatBlt(hdc, x, y, 5, 1, PATCOPY);
        PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
        PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

        SelectObject(hdc, hbr);
        x--;
        y--;
    }
    hbr = GetSysColorBrush(bDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    PatBlt(hdc, x, y, 5, 1, PATCOPY);
    PatBlt(hdc, x+1, y+1, 3, 1, PATCOPY);
    PatBlt(hdc, x+2, y+2, 1, 1, PATCOPY);

    SelectObject(hdc, hbr);
    lprc->right = x;
}


BOOL CColorControl::_UseColorPicker(void)
{
    CHOOSECOLOR cc = {0};

    cc.lStructSize = sizeof(cc);
    cc.hwndOwner = m_hwndParent;
    cc.hInstance = NULL;
    cc.rgbResult = m_rbgColorTemp;
    cc.lpCustColors = m_rbgCustomColors;
    cc.Flags = CC_RGBINIT | m_dwFlags;
    cc.lCustData = 0L;
    cc.lpfnHook = NULL;
    cc.lpTemplateName = NULL;

    if (ChooseColor(&cc))
    {
        SetColor(cc.rgbResult);          // Replace m_rbgColor with our new color.
        return TRUE;
    }

    return FALSE;
}


void CColorControl::_DrawColorSquare(HDC hdc, int iColor)
{
    RECT rc;
    COLORREF rgb;
    HPALETTE hpalOld = NULL;
    HBRUSH hbr;

    // custom color
    if (iColor == m_iNumColors)
    {
        rc.left = 0;
        rc.top = 0;
        rgb = m_rbgColorTemp;
    }
    else
    {
        rc.left = (iColor % NUM_COLORSPERROW) * m_dxColor;
        rc.top = (iColor / NUM_COLORSPERROW) * m_dyColor;
        rgb = m_rbgColors[iColor];
    }
    rc.right = rc.left + m_dxColor;
    rc.bottom = rc.top + m_dyColor;

    // focused one
    if (iColor == m_nCurColor)
    {
        PatBlt(hdc, rc.left, rc.top, m_dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.bottom - 3, m_dxColor, 3, BLACKNESS);
        PatBlt(hdc, rc.left, rc.top + 3, 3, m_dyColor - 6, BLACKNESS);
        PatBlt(hdc, rc.right - 3, rc.top + 3, 3, m_dyColor - 6, BLACKNESS);
        InflateRect(&rc, -1, -1);
        HBRUSH hBrushWhite = (HBRUSH) GetStockObject(WHITE_BRUSH);
        if (hBrushWhite)
        {
            FrameRect(hdc, &rc, hBrushWhite);
        }
        InflateRect(&rc, -2, -2);
    }
    else
    {
        // clean up possible focus thing from above
        FrameRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

        InflateRect(&rc, -m_cxEdgeSM, -m_cyEdgeSM);
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
    }

    if ((m_dwFlags & CC_SOLIDCOLOR) && !(rgb & 0xFF000000))
        rgb = GetNearestColor(hdc, rgb);

    hbr = CreateSolidBrush(rgb);
    if (m_hpal3D)
    {
        hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
        RealizePalette(hdc);
    }
    hbr = (HBRUSH) SelectObject(hdc, hbr);
    PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
    hbr = (HBRUSH) SelectObject(hdc, hbr);

    if (hpalOld)
    {
        hpalOld = SelectPalette(hdc, hpalOld, TRUE);
        RealizePalette(hdc);
    }

    if (hbr)
    {
        DeleteObject(hbr);
    }
}


// set the focus to the given color.
// in the process, also take the focus off of the old focus color.
void CColorControl::_FocusColor(HWND hDlg, int iNewColor)
{
    int i;
    HDC hdc = NULL;
    HWND hwnd;

    if (iNewColor == m_nCurColor)
        return;

    i = m_nCurColor;
    m_nCurColor = iNewColor;

    // unfocus the old one
    if (i >= 0)
    {
        if (i == m_iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        if (hdc)
        {
            _DrawColorSquare(hdc, i);
            ReleaseDC(hwnd, hdc);
        }
    }

    // focus the new one
    if (iNewColor >= 0)
    {
        if (iNewColor == m_iNumColors)
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
        else
            hwnd = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
        hdc = GetDC(hwnd);
        if (hdc)
        {
            _DrawColorSquare(hdc, iNewColor);
            ReleaseDC(hwnd, hdc);
        }
    }
}


void CColorControl::_TrackMouse(HWND hDlg, POINT pt)
{
    HWND hwndKid;
    int id;

    hwndKid = ChildWindowFromPoint(hDlg, pt);
    if (hwndKid == NULL || hwndKid == hDlg)
        return;

    id = GetWindowLong(hwndKid, GWL_ID);
    switch (id)
    {
        case IDC_CPDLG_16COLORS:
            MapWindowPoints(hDlg, GetDlgItem(hDlg, IDC_CPDLG_16COLORS), &pt, 1);
            pt.x /= ZERO_DIV_PROTECT(m_dxColor);
            pt.y /= ZERO_DIV_PROTECT(m_dyColor);
            _FocusColor(hDlg, pt.x + (pt.y * NUM_COLORSPERROW));
            break;

        case IDC_CPDLG_COLORCUST:
            if (IsWindowVisible(hwndKid))
                _FocusColor(hDlg, m_iNumColors);
            break;

        case IDC_CPDLG_COLOROTHER:
            _FocusColor(hDlg, -1);
            break;
    }
}


void CColorControl::_DrawItem(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    int i;

    if (lpdis->CtlID == IDC_CPDLG_COLORCUST)
    {
        _DrawColorSquare(lpdis->hDC, m_iNumColors);
    }
    else
    {
        for (i = 0; i < m_iNumColors; i++)
        {
            _DrawColorSquare(lpdis->hDC, i);
        }
    }
}

/*
** init the mini-color-picker
**
** the dialog is pretending to be a menu, so figure out where to pop
** it up so that it is visible all around.
**
** also because this dialog is pretty darn concerned with its look,
** hand-align the components in pixel units.  THIS IS GROSS!
*/
void CColorControl::_InitDialog(HWND hDlg)
{
    RECT rcOwner;
    RECT rc, rc2;
    int dx, dy;
    int x, y;
    int i;
    HWND hwndColors, hwnd;
    HWND hwndEtch, hwndCust;
    int  width, widthCust, widthEtch;
    HPALETTE hpal = m_hpal3D;
    MONITORINFO mi;
    TCHAR szBuf[50];
    LONG cbBuf = ARRAYSIZE(szBuf);
    HDC hDC;
    SIZE size;

    m_fCapturing = FALSE;
    m_fJustDropped = TRUE;

    if (hpal == NULL)
        hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    m_iNumColors = 0;
    GetObject(hpal, sizeof(int), &m_iNumColors);

    if (m_iNumColors > NUM_COLORSMAX)
        m_iNumColors = NUM_COLORSMAX;

    GetPaletteEntries(hpal,0, m_iNumColors, (LPPALETTEENTRY)m_rbgColors);
    for (i = 0; i < m_iNumColors; i++)
    {
        m_rbgColors[i] &= 0x00FFFFFF;
        m_rbgColors[i] |= 0x02000000;
    }

    for (i = 0; i < m_iNumColors; i++)
    {
        if ((m_rbgColors[i] & 0x00FFFFFF) == (m_rbgColorTemp & 0x00FFFFFF))
        {
            ShowWindow(GetDlgItem(hDlg, IDC_CPDLG_COLORCUST), SW_HIDE);
            break;
        }
    }
    // current is either one of 16 or the custom color (== m_iNumColors
    m_nCurColor = i;

    // size the 16 colors to be square
    hwndColors = GetDlgItem(hDlg, IDC_CPDLG_16COLORS);
    GetClientRect(hwndColors, &rc);

    // To make localization easy..
    //
    hwndEtch=GetDlgItem(hDlg, IDC_CPDLG_COLORETCH);
    GetClientRect(hwndEtch, &rc2);
    widthEtch = rc2.right-rc2.left;

    hwndCust=GetDlgItem(hDlg, IDC_CPDLG_COLORCUST);
    GetClientRect(hwndCust, &rc2);
    widthCust = rc2.right-rc2.left;

    hwnd = GetDlgItem(hDlg, IDC_CPDLG_COLOROTHER);
    GetWindowRect(hwnd, &rc2); // we must initialize rc2 with this control.

    // Make sure the button is big enough to contain its text
    width = rc.right - rc.left;
    if( GetDlgItemText( hDlg, IDC_CPDLG_COLOROTHER, szBuf, cbBuf ) )
    {
        RECT rcTemp;
        int iRet;
        HFONT hfont, hfontOld;  

        // Get the font for the button
        hDC = GetDC(hwnd);
        if (hDC)
        {
            hfont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
            ASSERT(hfont);
            hfontOld = (HFONT) SelectObject( hDC, hfont );

            // Get the size of the text
            iRet = DrawTextEx( hDC, szBuf, lstrlen(szBuf), &rcTemp, DT_CALCRECT | DT_SINGLELINE, NULL );
            ASSERT( iRet );
            size.cx = rcTemp.right - rcTemp.left + 7;  //account for the button border
            size.cy = rcTemp.bottom - rcTemp.top;

            // Adjust the button size if the text needs more space
            if( size.cx > width )
            {              
                rc2.right = rc2.left + size.cx;
                rc2.bottom = rc2.top + size.cy;
                MoveWindow( hwnd, rc2.left, rc2.top, rc2.right - rc2.left, rc2.bottom - rc2.top, FALSE );
            }
            SelectObject( hDC, hfontOld );
            ReleaseDC( hwnd, hDC );
        }
    }

    // Take possible biggest width to calculate sels
    //
    width = (widthEtch > widthCust+(rc2.right-rc2.left)) ? widthEtch : widthCust+(rc2.right-rc2.left);
    width = (width > rc.right-rc.left) ? width: rc.right-rc.left;

#define NUM_COLORSPERCOL (m_iNumColors / NUM_COLORSPERROW)

    m_dxColor = m_dyColor
    = ((rc.bottom - rc.top) / NUM_COLORSPERCOL > width / NUM_COLORSPERROW )
      ?  (rc.bottom - rc.top) / NUM_COLORSPERCOL : width / NUM_COLORSPERROW;

    // Make sure custum color can fit
    //
    if (m_dxColor*(NUM_COLORSPERROW-1) < rc2.right-rc2.left )
    {
        m_dxColor = m_dyColor = (rc2.right-rc2.left)/(NUM_COLORSPERROW-1);
    }

    // make each color square's width the same as the height
    SetWindowPos(hwndColors, NULL, 0, 0, m_dxColor * NUM_COLORSPERROW,
                 m_dyColor * NUM_COLORSPERCOL,
                 SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER |  SWP_NOREDRAW);
    rc.right = rc.left + m_dxColor * NUM_COLORSPERROW;
    rc.bottom = rc.top + m_dyColor * NUM_COLORSPERCOL;

    MapWindowPoints(hwndColors, hDlg, (LPPOINT)(LPRECT)&rc, 2);

    // move/size the etch to the right place
    // (compensate for the colors being "inset" by one)
    MoveWindow(hwndEtch, rc.left + 1, rc.bottom + m_cyEdgeSM, rc.right - rc.left - 2, m_cyEdgeSM, FALSE);

    y = rc.bottom + 3 * m_cyEdgeSM;

    // size the custom color to the same square and right-align
    MoveWindow(hwndCust, rc.right - m_dxColor, y, m_dxColor, m_dyColor, FALSE);

    // do same for button
    MapWindowPoints(NULL, hDlg, (LPPOINT)(LPRECT)&rc2, 2);
    // base the width of the custom button on the remaining space to 
    // the left of the custom color.  Also move the custom button one pix right
    // of the left edge.  This only is done if a custom color is selected...
    if (m_nCurColor != m_iNumColors)
    {
        // no custom color
        MoveWindow(hwnd, rc2.left, y, rc2.right-rc2.left, m_dyColor, FALSE);
    }
    else
    {
        // custom color, adjust the Other... button
        dx = rc2.right - rc2.left++;
        if (rc2.left + dx >= rc.right - m_dxColor - 2) 
            MoveWindow(hwnd, rc2.left, y, rc.right - m_dxColor - 2 , m_dyColor, FALSE);
        else 
            MoveWindow(hwnd, rc2.left, y, dx, m_dyColor, FALSE);
    }

    // now figure out the size for the dialog itself
    rc.left = rc.top = 0;
    rc.right = rc.left + m_dxColor * NUM_COLORSPERROW;
    // (compensate for the colors being "inset" by one)
    rc.bottom = y + m_dyColor + 1;

    AdjustWindowRect(&rc, GetWindowLong(hDlg, GWL_STYLE), FALSE);
    dx = rc.right - rc.left;
    dy = rc.bottom - rc.top;

    GetWindowRect(_hwnd, &rcOwner);

    // Make sure the window is entirely on the monitor
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(MonitorFromRect(&rcOwner, MONITOR_DEFAULTTONEAREST), &mi);

    if (rcOwner.left < mi.rcMonitor.left)
    { // overlap left side
        x = mi.rcMonitor.left;
    }
    else if (rcOwner.left + dx >= mi.rcMonitor.right)
    { // overlap right side
        x = mi.rcMonitor.right  - dx - 1;
    }
    else
    {                                  // no overlap
        x = rcOwner.left;
    }

    if (rcOwner.top < mi.rcMonitor.top)
    {   // overlap top side
        y = rcOwner.bottom;
    }
    else if (rcOwner.bottom + dy >= mi.rcMonitor.bottom)
    {// overlap bottom side
        y = rcOwner.top  - dy;
    }
    else
    {                                  // no overlap
        y = rcOwner.bottom;
    }
    MoveWindow(hDlg, x, y, dx, dy, FALSE);

    SetFocus(GetDlgItem(hDlg, IDC_CPDLG_16COLORS));

    // post self a message to setcapture after painting
    PostMessage(hDlg, WM_USER_STARTCAPTURE_COLORPICKER, 0, 0L);
}



INT_PTR CALLBACK CColorControl::ColorPickDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CColorControl * pThis = (CColorControl *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CColorControl *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_ColorPickDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CColorControl::_ColorPickDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND hwndKid;
    int wRet;
    int id;
    POINT pt;
    BOOL fEnd = FALSE;

    switch(message)
    {
        case WM_INITDIALOG:
            _InitDialog(hDlg);
            return FALSE;

        case WM_USER_STARTCAPTURE_COLORPICKER:
            if (m_fCursorHidden)
            {
                ShowCursor(TRUE);
                m_fCursorHidden = FALSE;
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            m_fCapturing = TRUE;
            SetCapture(hDlg);
            m_fCapturing = FALSE;
            break;

        case WM_DESTROY:
            break;

        case WM_CAPTURECHANGED:
            if (m_fCapturing)
                return TRUE;   // ignore if we're doing this on purpose

            // if this wasn't a button in the dialog, dismiss ourselves
            if (!m_fJustDropped || (HWND)lParam == NULL || GetParent((HWND)lParam) != hDlg)
            {
                EndDialog(hDlg, IDCANCEL);
                return TRUE;
            }
            break;

        case WM_MOUSEMOVE:
            LPARAM2POINT(lParam, &pt );
            _TrackMouse(hDlg, pt);
            break;

        // if button up is on the parent, leave picker up and untrammeled.
        // otherwise, we must have "menu-tracked" to get here, so select.
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            LPARAM2POINT(lParam, &pt);
            MapWindowPoints(hDlg, _hwnd, &pt, 1);
            if (ChildWindowFromPoint(_hwnd, pt))
                return 0;
            m_fCapturing = TRUE;
            m_fJustDropped = FALSE;  // user could not be dragging from owner
            ReleaseCapture();
            m_fCapturing = FALSE;
            fEnd = TRUE;
        // || fall    ||
        // || through ||
        // \/         \/
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            LPARAM2POINT(lParam, &pt);
            hwndKid = ChildWindowFromPoint(hDlg, pt);
            // assume it's a dismissal if we're going to close...
            wRet = IDCANCEL;

            // if not on parent, dismiss picker
            if (hwndKid != NULL && hwndKid != hDlg)
            {
                id = GetWindowLong(hwndKid, GWL_ID);
                switch (id)
                {
                    case IDC_CPDLG_16COLORS:
                        // make sure that iCurColor is valid
                        _TrackMouse(hDlg, pt);
                        m_rbgColorTemp = m_rbgColors[m_nCurColor] & 0x00FFFFFF;

                        wRet = IDOK;
                        break;

                    case IDC_CPDLG_COLOROTHER:
                        _FocusColor(hDlg, -1);
                        wRet = id;   // this will fall thru to use the picker
                        fEnd = TRUE; // we have capture, the button won't click
                        break;

                    default:
                        // if this is a down, we will track until the up
                        // if this is an up, we will close with no change
                        break;
                }
            }

            if( fEnd )
            {
                EndDialog(hDlg, wRet);
                return TRUE;
            }

            // make sure we have the capture again since we didn't close
            m_fCapturing = TRUE;
            SetCapture(hDlg);
            m_fCapturing = FALSE;
            break;

        case WM_DRAWITEM:
            _DrawItem(hDlg, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_COMMAND:
            // all commands close the dialog
            // note IDC_CPDLG_COLOROTHER will fall through to the caller...
            // cannot pass ok with no color selected
            if ((LOWORD(wParam) == IDOK) && (m_nCurColor < 0))
            {
                *((WORD *)(&wParam)) = IDCANCEL;
            }

            EndDialog(hDlg, LOWORD(wParam));
            break;

    }
    return FALSE;
}


BOOL CColorControl::_ChooseColorMini(void)
{
    ShowCursor(FALSE);
    m_fCursorHidden = TRUE;

    m_hwndParent = GetParent(GetParent(_hwnd));          // Property Sheet
    m_rbgColorTemp = m_rbgColor;
    INT_PTR iAnswer = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_COLORPICK), _hwnd, ColorPickDlgProc, (LPARAM)this);

    if (m_fCursorHidden)
    {
        ShowCursor(TRUE);
        m_fCursorHidden = FALSE;
    }

    switch (iAnswer)
    {
        case IDC_CPDLG_COLOROTHER:  // the user picked the "Other..." button
            return _UseColorPicker();

        case IDOK:            // the user picked a color in our little window
            SetColor(m_rbgColorTemp);
            return TRUE;

        default:
            break;
    }

    return FALSE;
}


//===========================
// *** IColorControl Interface ***
//===========================
HRESULT CColorControl::Initialize(IN HWND hwnd, IN COLORREF rgbColor)
{
    HRESULT hr = E_INVALIDARG;

    if (hwnd)
    {
        _hwnd = hwnd;
        hr = SetColor(rgbColor);
    }

    return hr;
}


HRESULT CColorControl::GetColor(IN COLORREF * pColor)
{
    HRESULT hr = E_INVALIDARG;

    if (pColor)
    {
        *pColor = m_rbgColor;
        hr = S_OK;
    }

    return hr;
}


HRESULT CColorControl::SetColor(IN COLORREF rgbColor)
{
    m_rbgColor = rgbColor;

    if (_hwnd)
    {
        if (m_brColor)
        {
            DeleteObject(m_brColor);
        }

        m_brColor = CreateSolidBrush(_NearestColor(rgbColor));

        m_rbgColorTemp = m_rbgColor;
        InvalidateRect(_hwnd, NULL, FALSE);
        UpdateWindow(_hwnd);
    }

    return S_OK;
}


HRESULT CColorControl::OnCommand(IN HWND hDlg, IN UINT message, IN WPARAM wParam, IN LPARAM lParam)
{
    HRESULT hr = S_OK;
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    if (wEvent == BN_CLICKED)
    {
        m_dwFlags = CC_RGBINIT | CC_FULLOPEN;

        _ChooseColorMini();
    }

    return S_OK;
}



HRESULT CColorControl::OnDrawItem(IN HWND hDlg, IN UINT message, IN WPARAM wParam, IN LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;

    if (lpdis && m_brColor)
    {
        SIZE thin = { m_cxEdgeSM / 2, m_cyEdgeSM / 2 };
        RECT rc = lpdis->rcItem;
        HDC hdc = lpdis->hDC;
        BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) && !(lpdis->itemState & ODS_DISABLED));

        if (!thin.cx) thin.cx = 1;
        if (!thin.cy) thin.cy = 1;

        if (!m_hTheme)
        {
            if (lpdis->itemState & ODS_SELECTED)
            {
                DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
                OffsetRect(&rc, 1, 1);
            }
            else
            {
                DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
            }

            FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
        }
        else
        {
            int iStateId;

            if (lpdis->itemState & ODS_SELECTED)
            {
                iStateId = PBS_PRESSED;
            }
            else if (lpdis->itemState & ODS_HOTLIGHT)
            {
                iStateId = PBS_HOT;
            }
            else if (lpdis->itemState & ODS_DISABLED)
            {
                iStateId = PBS_DISABLED;
            }
            else if (lpdis->itemState & ODS_FOCUS)
            {
                iStateId = PBS_DEFAULTED;
            }
            else
            {
                iStateId = PBS_NORMAL;
            }

            DrawThemeBackground(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, 0);
            GetThemeBackgroundContentRect(m_hTheme, hdc, BP_PUSHBUTTON, iStateId, &rc, &rc);
        }

        if (bFocus)
        {
            InflateRect(&rc, -thin.cx, -thin.cy);
            DrawFocusRect(hdc, &rc);
            InflateRect(&rc, thin.cx, thin.cy);
        }

        InflateRect(&rc, 1-thin.cx, -m_cyEdgeSM);

        rc.left += m_cxEdgeSM;
        _DrawDownArrow(hdc, &rc, lpdis->itemState & ODS_DISABLED);

        InflateRect(&rc, -thin.cx, 0);
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RIGHT);

        rc.right -= ( 2 * m_cxEdgeSM ) + thin.cx;

        // color sample
        if ( !(lpdis->itemState & ODS_DISABLED) )
        {
            HPALETTE hpalOld = NULL;

            FrameRect(hdc, &rc, GetSysColorBrush(COLOR_BTNTEXT));
            InflateRect(&rc, -thin.cx, -thin.cy);

            if (m_hpal3D)
            {
                hpalOld = SelectPalette(hdc, m_hpal3D, FALSE);
                RealizePalette(hdc);
            }

            if (m_brColor)
            {
                HBRUSH brOldBrush = (HBRUSH) SelectObject(hdc, m_brColor);
                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
                SelectObject(hdc, brOldBrush);
            }
        
            if (hpalOld)
            {
                SelectPalette(hdc, hpalOld, TRUE);
                RealizePalette(hdc);
            }
        }
    }

    return hr;
}

HRESULT CColorControl::ChangeTheme(IN HWND hDlg)
{
    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
    }

    m_hTheme = OpenThemeData(GetDlgItem(hDlg, IDC_BACK_COLORPICKER), WC_BUTTON);

    return S_OK;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CColorControl::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CColorControl::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    // We do this because we want to make this class a member variable of another class.
    // We should move this file to comctl32 and make it a real control in the future.
    // In that case, we could make it a full com object.
//    delete this;      // We currently need our destructor called.
    return 0;
}


HRESULT CColorControl::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CColorControl, IObjectWithSite),
        QITABENT(CColorControl, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CColorControl::CColorControl() : m_cRef(1)
{
    DllAddRef();

    m_hwndParent = NULL;
    m_brColor = NULL;
    m_rbgColor = RGB(255, 255, 255);    // Default to white

    m_cxEdgeSM = GetSystemMetrics(SM_CXEDGE);
    m_cyEdgeSM = GetSystemMetrics(SM_CYEDGE);

    HKEY hkSchemes;

    // if no colors are there, initialize to all white
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_rbgCustomColors); nIndex++)
    {
        m_rbgCustomColors[nIndex] = RGB(255, 255, 255);
    }

    // select the current scheme
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_QUERY_VALUE, &hkSchemes) == ERROR_SUCCESS)
    {
        // also, since this key is already open, get the custom colors
        DWORD dwSize = sizeof(m_rbgCustomColors);
        DWORD dwType = REG_BINARY;

        // It's okay if this call fails.  We handle the case where the user
        // didn't create custom colors.
        RegQueryValueEx(hkSchemes, REGSTR_VAL_CUSTOMCOLORS, NULL, &dwType, (LPBYTE)m_rbgCustomColors, &dwSize);
        RegCloseKey(hkSchemes);
    }

    _InitColorAndPalette();
}


CColorControl::~CColorControl()
{
    // We ignore the return value for _SaveCustomColors() because
    // we don't want to fail the changing of the color if the user can't
    // save the customized palette.
    _SaveCustomColors();

    if (m_brColor)
    {
        DeleteObject(m_brColor);
    }

    if (m_hpal3D)
    {
        DeleteObject(m_hpal3D);
        m_hpal3D = NULL;
    }

    if (m_hpalVGA)
    {
        DeleteObject(m_hpalVGA);
        m_hpalVGA = NULL;
    }

    if (m_hTheme)
    {
        CloseThemeData(m_hTheme);
        m_hTheme = NULL;
    }

    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dbackp.cpp ===
/*  DBACKP.CPP
**
**  Copyright (C) Microsoft, 1997, All Rights Reserved.
**
**  window class to display a preview of the screen background,
**  complete with rudimentary palette handling and stretching
**  of bitmaps to fit the preview screen.
**
**  this can be replaced with a static bitmap control only
**  if palettes can also be handled by the control.
**
*/

#include "stdafx.h"
#include "strsafe.h"
#pragma hdrstop

#define GWW_INFO        0

#define CXYDESKPATTERN 8

BOOL g_bInfoSet = FALSE;

HBITMAP g_hbmPreview = NULL;    // the bitmap used for previewing

HBITMAP  g_hbmDefault = NULL;   // default bitmap
HBITMAP  g_hbmWall = NULL;      // bitmap image of wallpaper
HDC      g_hdcWall = NULL;      // memory DC with g_hbmWall selected
HDC      g_hdcMemory = NULL;    // memory DC
HPALETTE g_hpalWall = NULL;     // palette that goes with hbmWall bitmap
HBRUSH   g_hbrBack = NULL;      // brush for the desktop background
IThumbnail *g_pthumb = NULL;    // Html to Bitmap converter
DWORD    g_dwWallpaperID = 0;   // ID to identify which bitmap we received

#define WM_HTML_BITMAP  (WM_USER + 100)
#define WM_ASYNC_BITMAP (WM_HTML_BITMAP + 1)


HPALETTE PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    adw[0] = MAKELONG(0x300, n);

    for (i=1; i<=n; i++)
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

    if (n == 0)
        return NULL;
    else
        return CreatePalette((LPLOGPALETTE)&adw[0]);
}

typedef struct{
    HWND hwnd;
    HBITMAP hbmp;
    DWORD id;
    WPARAM flags;
    TCHAR szFile[MAX_PATH];
} ASYNCWALLPARAM, * PASYNCWALLPARAM;

DWORD CALLBACK UpdateWallProc(LPVOID pv)
{
    ASSERT(pv);
    PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
    pawp->hbmp = (HBITMAP)LoadImage(NULL, pawp->szFile,
                                      IMAGE_BITMAP, 0, 0,
                                      LR_LOADFROMFILE|LR_CREATEDIBSECTION);

    if (pawp->hbmp)
    {
        // if all is good, then the window will handle cleaning up
        if (IsWindow(pawp->hwnd) && PostMessage(pawp->hwnd, WM_ASYNC_BITMAP, 0, (LPARAM)pawp))
            return TRUE;

        DeleteObject(pawp->hbmp);
    }

    LocalFree(pawp);

    return TRUE;
}

const GUID CLSID_HtmlThumbnailExtractor = {0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3};

DWORD CALLBACK UpdateWallProcHTML(LPVOID pv)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        ASSERT(pv);
        if (pv)
        {
            PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) pv;
            IPersistFile *ppf;
            HRESULT hr = CoCreateInstance(CLSID_HtmlThumbnailExtractor, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pawp->szFile, STGM_READ);
                if (SUCCEEDED(hr))
                {
                    IExtractImage *pei= NULL;
                    hr = ppf->QueryInterface(IID_PPV_ARG(IExtractImage, &pei));
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwPriority = 0;
                        DWORD dwFlags = IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
                        WCHAR szLocation[MAX_PATH];
                        SIZEL rgSize = {MON_DX, MON_DY};
                        
                        hr = pei->GetLocation(szLocation, ARRAYSIZE(szLocation), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
                        if (SUCCEEDED(hr))
                        {
                            HBITMAP hbm;
                            hr = pei->Extract(&hbm);
                            if (SUCCEEDED(hr))
                            {
                                if (!SendMessage(pawp->hwnd, WM_HTML_BITMAP, pawp->id, (LPARAM)hbm))
                                {
                                    DeleteObject(hbm);
                                }
                            }
                        }
                        pei->Release();
                    }
                }
                ppf->Release();
            }
     
            LocalFree(pawp);
        }
        CoUninitialize();
    }

    return TRUE;
}

void LoadWallpaperAsync(LPCTSTR pszFile, HWND hwnd, DWORD dwID, WPARAM flags, BOOL bHTML)
{
    PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) LocalAlloc(LPTR, SIZEOF(ASYNCWALLPARAM));

    if (pawp)
    {
        pawp->hwnd = hwnd;
        pawp->flags = flags;
        pawp->id = dwID;
        if (SUCCEEDED(StringCchCopy(pawp->szFile, ARRAYSIZE(pawp->szFile), pszFile)))
        {
            if (!bHTML)
            {
                if (!SHQueueUserWorkItem(UpdateWallProc, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                {
                    LocalFree(pawp);
                }
            }
            else
            {
                if (!SHQueueUserWorkItem(UpdateWallProcHTML, pawp, 0, (DWORD_PTR)0, (DWORD_PTR *)NULL, NULL, 0))
                {
                    LocalFree(pawp);
                }
            }
        }
    }
}

void _InitPreview(void)
{
    if( g_hbmPreview )
        DeleteObject( g_hbmPreview );

    g_hbmPreview = LoadMonitorBitmap();
}

void _BuildPattern(void)
{
    WCHAR wszBuf[MAX_PATH];
    HBITMAP hbmTemp;
    COLORREF clrOldBk, clrOldText;
    HBRUSH hbr = NULL;
    WORD patbits[CXYDESKPATTERN] = {0, 0, 0, 0, 0, 0, 0, 0};


    // get rid of old brush if there was one
    if (g_hbrBack)
        DeleteObject(g_hbrBack);

    g_pActiveDesk->GetPattern(wszBuf, ARRAYSIZE(wszBuf), 0);
    if (wszBuf[0] != 0L)
    {
        LPTSTR   pszPatternBuf;
#ifndef UNICODE
        CHAR    szTemp[MAX_PATH];
        SHUnicodeToAnsi(wszBuf, szTemp, ARRAYSIZE(szTemp));
        pszPatternBuf = szTemp;
#else
        pszPatternBuf = wszBuf;
#endif
        PatternToWords(pszPatternBuf, patbits);
        hbmTemp = CreateBitmap(8, 8, 1, 1, patbits);
        if (hbmTemp)
        {
            g_hbrBack = CreatePatternBrush(hbmTemp);
            DeleteObject(hbmTemp);
        }
    }
    else
    {
        g_hbrBack = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND));
    }
    if (!g_hbrBack)
    {
        g_hbrBack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    }

    clrOldText = SetTextColor(g_hdcMemory, GetSysColor(COLOR_BACKGROUND));
    clrOldBk = SetBkColor(g_hdcMemory, GetSysColor(COLOR_WINDOWTEXT));

    hbr = (HBRUSH)SelectObject(g_hdcMemory, g_hbrBack);
    PatBlt(g_hdcMemory, MON_X, MON_Y, MON_DX, MON_DY, PATCOPY);
    SelectObject(g_hdcMemory, hbr);

    SetTextColor(g_hdcMemory, clrOldText);
    SetBkColor(g_hdcMemory, clrOldBk);
}

void _InitWall(void)
{
    if (g_hbmWall)
    {
        SelectObject(g_hdcWall, g_hbmDefault);
        DeleteObject(g_hbmWall);
        g_hbmWall = NULL;

        if (g_hpalWall)
        {
            DeleteObject(g_hpalWall);
            g_hpalWall = NULL;
        }
    }
}

void _GetWallpaperAsync(HWND hwnd, WPARAM flags)
{
    WCHAR wszWallpaper[INTERNET_MAX_URL_LENGTH];
    LPTSTR pszWallpaper;
    int cchWallpaper = ARRAYSIZE(wszWallpaper);

    g_pActiveDesk->GetWallpaper(wszWallpaper, ARRAYSIZE(wszWallpaper), 0);
#ifndef UNICODE
    CHAR  szWallpaper[ARRAYSIZE(wszWallpaper)];
    SHUnicodeToAnsi(wszWallpaper, szWallpaper, ARRAYSIZE(szWallpaper));
    pszWallpaper = szWallpaper;
#else
    pszWallpaper = wszWallpaper;
#endif

    g_dwWallpaperID++;

    if (!*pszWallpaper || !lstrcmpi(pszWallpaper, g_szNone))
        return;

    {
        if (IsNormalWallpaper(pszWallpaper))
        {
            LoadWallpaperAsync(pszWallpaper, hwnd, g_dwWallpaperID, flags, FALSE);
        }
        else
        {
            if(IsWallpaperPicture(pszWallpaper))
            {
                // This is a picture (GIF, JPG etc.,)
                // We need to generate a small HTML file that has this picture
                // as the background image.
                //
                // Compute the filename for the Temporary HTML file.
                //
                GetTempPath(ARRAYSIZE(wszWallpaper), pszWallpaper);
                if (SUCCEEDED(StringCchCat(pszWallpaper, cchWallpaper, PREVIEW_PICTURE_FILENAME)))
                {
    #ifndef UNICODE
                    SHAnsiToUnicode(szWallpaper, wszWallpaper, ARRAYSIZE(wszWallpaper));
    #endif
                    //
                    // Generate the preview picture html file.
                    //
                    g_pActiveDesk->GenerateDesktopItemHtml(wszWallpaper, NULL, 0);
                }
            }

            //
            // Will cause a WM_HTML_BITMAP to get sent to us.
            //
            LoadWallpaperAsync(pszWallpaper, hwnd, g_dwWallpaperID, flags, TRUE);
        }
    }
}

void _DrawWall(HBITMAP hbm, WPARAM flags)
{
    int     dxWall;          // size of wallpaper
    int     dyWall;
    BITMAP bm;

    //  init the global
    g_hbmWall = hbm;


    SelectObject(g_hdcWall, g_hbmWall); // bitmap stays in this DC
    GetObject(g_hbmWall, sizeof(bm), &bm);
    TraceMsg(TF_ALWAYS, "for bitmap %08X we have bpp=%d and planes=%d", g_hbmWall, bm.bmBitsPixel, bm.bmPlanes);

    if (GetDeviceCaps(g_hdcMemory, RASTERCAPS) & RC_PALETTE)
    {
        if (bm.bmBitsPixel * bm.bmPlanes > 8)
            g_hpalWall = CreateHalftonePalette(g_hdcMemory);
        else if (bm.bmBitsPixel * bm.bmPlanes == 8)
            g_hpalWall = PaletteFromDS(g_hdcWall);
        else
            g_hpalWall = NULL;  //!!! assume 1 or 4bpp images dont have palettes
    }

    GetObject(g_hbmWall, sizeof(bm), &bm);

    if(flags & BP_EXTERNALWALL)
    {
        //For external wallpapers, we ask the image extractor to generate
        // bitmaps the size that we want to show (NOT the screen size).
        dxWall = MON_DX;
        dyWall = MON_DY;
    }
    else
    {
        dxWall = MulDiv(bm.bmWidth, MON_DX, GetDeviceCaps(g_hdcMemory, HORZRES));
        dyWall = MulDiv(bm.bmHeight, MON_DY, GetDeviceCaps(g_hdcMemory, VERTRES));
    }

    if (dxWall < 1) dxWall = 1;
    if (dyWall < 1) dyWall = 1;

    if (g_hpalWall)
    {
        SelectPalette(g_hdcMemory, g_hpalWall, TRUE);
        RealizePalette(g_hdcMemory);
    }

    IntersectClipRect(g_hdcMemory, MON_X, MON_Y, MON_X + MON_DX, MON_Y + MON_DY);
    SetStretchBltMode(g_hdcMemory, COLORONCOLOR);

    if (flags & BP_TILE)
    {
        int i;
        StretchBlt(g_hdcMemory, MON_X, MON_Y, dxWall, dyWall,
            g_hdcWall, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

        for (i = MON_X+dxWall; i < (MON_X + MON_DX); i+= dxWall)
            BitBlt(g_hdcMemory, i, MON_Y, dxWall, dyWall, g_hdcMemory, MON_X, MON_Y, SRCCOPY);

        for (i = MON_Y; i < (MON_Y + MON_DY); i += dyWall)
            BitBlt(g_hdcMemory, MON_X, i, MON_DX, dyWall, g_hdcMemory, MON_X, MON_Y, SRCCOPY);
    }
    else
    {
        //We want to stretch the Bitmap to the preview monitor size ONLY for new platforms.
        if (flags & BP_STRETCH)
        {
            //Stretch the bitmap to the whole preview monitor.
            dxWall = MON_DX;
            dyWall = MON_DY;
        }
        //Center the bitmap in the preview monitor
        StretchBlt(g_hdcMemory, MON_X + (MON_DX - dxWall)/2, MON_Y + (MON_DY - dyWall)/2,
                dxWall, dyWall, g_hdcWall, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    }

    // restore dc
    SelectPalette(g_hdcMemory, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    SelectClipRgn(g_hdcMemory, NULL);
}
/*--------------------------------------------------------------------
** Build the preview bitmap.
**
** both the pattern and the bitmap are drawn each time, but
** if the flags dictate the need, new pattern and bitmap
** globals are built as needed.
**--------------------------------------------------------------------*/
void NEAR PASCAL BuildPreviewBitmap(HWND hwnd, HBITMAP hbmp, WPARAM flags)
{
    _InitPreview();

    HBITMAP hbmOld = (HBITMAP)SelectObject(g_hdcMemory, g_hbmPreview);

    _BuildPattern();

    _InitWall();
    /*
    ** now, position the wallpaper appropriately
    */
    if (hbmp)
    {
        //  use the one that was passed in
        _DrawWall(hbmp, flags);

    }
    else
    {
        //  this means that we need to set up the stuff
        //  to get the bmp ASYNC

        _GetWallpaperAsync(hwnd, flags);
    }

    SelectObject(g_hdcMemory, hbmOld);
}


BOOL NEAR PASCAL BP_CreateGlobals(HWND hwnd)
{
    HDC hdc;

    hdc = GetDC(NULL);
    g_hdcWall = CreateCompatibleDC(hdc);
    g_hdcMemory = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);
    g_hbmPreview = LoadMonitorBitmap();

    HBITMAP hbm;
    hbm = CreateBitmap(1, 1, 1, 1, NULL);
    g_hbmDefault = (HBITMAP)SelectObject(g_hdcMemory, hbm);
    SelectObject(g_hdcMemory, g_hbmDefault);
    DeleteObject(hbm);

    HRESULT hr = E_FAIL;

    hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&g_pthumb);
    if(SUCCEEDED(hr))
    {
        g_pthumb->Init(hwnd, WM_HTML_BITMAP);
    }


    if (!g_hdcWall || !g_hbmPreview || !SUCCEEDED(hr))
        return FALSE;
    else
        return TRUE;
}

void NEAR PASCAL BP_DestroyGlobals(void)
{
    if (g_hbmPreview)
    {
        DeleteObject(g_hbmPreview);
        g_hbmPreview = NULL;
    }
    if (g_hbmWall)
    {
        SelectObject(g_hdcWall, g_hbmDefault);
        DeleteObject(g_hbmWall);
        g_hbmWall = NULL;
    }
    if (g_hpalWall)
    {
        SelectPalette(g_hdcWall, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
        DeleteObject(g_hpalWall);
        g_hpalWall = NULL;
    }
    if (g_hdcWall)
    {
        DeleteDC(g_hdcWall);
        g_hdcWall = NULL;
    }
    if (g_hbrBack)
    {
        DeleteObject(g_hbrBack);
        g_hbrBack = NULL;
    }
    if (g_hdcMemory)
    {
        DeleteDC(g_hdcMemory);
        g_hdcMemory = NULL;
    }
    if (g_hbmDefault)
    {
        DeleteObject(g_hbmDefault);
        g_hbmDefault = NULL;
    }
    if (g_pthumb)
    {
        g_pthumb->Release();
        g_pthumb = NULL;
    }
}

void InvalidateBackPrevContents(HWND hwnd)
{
    BITMAP bm;
    RECT rc;

    //
    // Only invalidate the "screen" part of the monitor bitmap.
    //
    GetObject(g_hbmPreview, SIZEOF(bm), &bm);
    GetClientRect(hwnd, &rc);
    rc.left = ( rc.right - bm.bmWidth ) / 2 + MON_X;
    rc.top = ( rc.bottom - bm.bmHeight ) / 2 + MON_Y;
    rc.right = rc.left + MON_DX;
    rc.bottom = rc.top + MON_DY;

    InvalidateRect(hwnd, &rc, FALSE);
}

LRESULT BackPreviewWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;
    BITMAP          bm;
    RECT            rc;
    HBITMAP         hbmOld;
    HPALETTE        hpalOld;

    switch(message)
    {
        case WM_CREATE:
            if (!BP_CreateGlobals(hWnd))
                return -1L;
            break;

        case WM_DESTROY:
            MSG msg;
            BP_DestroyGlobals();
            while (PeekMessage(&msg, hWnd, WM_HTML_BITMAP, WM_ASYNC_BITMAP, PM_REMOVE))
            {
                if ( msg.lParam )
                {
                    if (msg.message == WM_ASYNC_BITMAP)
                    {
                        //  clean up these objects
                        DeleteObject(((PASYNCWALLPARAM)(msg.lParam))->hbmp);
                        LocalFree((PASYNCWALLPARAM)(msg.lParam));
                    }
                    else // WM_HTML_BITMAP
                        DeleteObject((HBITMAP)msg.lParam);
                }
            }

            break;

        case WM_SETBACKINFO:
            if (g_hbmPreview)
            {
                BuildPreviewBitmap(hWnd, NULL, wParam);
                g_bInfoSet = TRUE;

                InvalidateBackPrevContents(hWnd);
            }
            break;

        case WM_ASYNC_BITMAP:
            if (lParam)
            {
                PASYNCWALLPARAM pawp = (PASYNCWALLPARAM) lParam;
                ASSERT(pawp->hbmp);
                if (pawp->id == g_dwWallpaperID)
                {
                    BuildPreviewBitmap(hWnd, pawp->hbmp, pawp->flags);
                    InvalidateBackPrevContents(hWnd);
                }
                else
                {
                    //  clean up this object
                    DeleteObject(pawp->hbmp);
                    LocalFree(pawp);
                }
            }
            break;


        case WM_HTML_BITMAP:
            {
                // may come through with NULL if the image extraction failed....
                if (wParam == g_dwWallpaperID && lParam)
                {
                    BuildPreviewBitmap(hWnd, (HBITMAP)lParam, BP_EXTERNALWALL);
                    InvalidateBackPrevContents(hWnd);
                    // Take ownership of bitmap
                    return 1;
                }
                
                // Bitmap for something no longer selected
                return 0;
            }

        case WM_PALETTECHANGED:
            if ((HWND)wParam == hWnd)
                break;
            //fallthru
        case WM_QUERYNEWPALETTE:
            if (g_hpalWall)
                InvalidateRect(hWnd, NULL, FALSE);
            break;

        case WM_PAINT:
            BeginPaint(hWnd,&ps);
            if (g_hbmPreview && g_bInfoSet)
            {
                hbmOld = (HBITMAP)SelectObject(g_hdcMemory, g_hbmPreview);
                if (g_hpalWall)
                {
                    hpalOld = SelectPalette(ps.hdc, g_hpalWall, FALSE);
                    RealizePalette(ps.hdc);
                }

                GetObject(g_hbmPreview, sizeof(bm), &bm);
                GetClientRect(hWnd, &rc);
                rc.left = ( rc.right - bm.bmWidth ) / 2;
                rc.top = ( rc.bottom - bm.bmHeight ) / 2;
                BitBlt(ps.hdc, rc.left, rc.top, bm.bmWidth, bm.bmHeight, g_hdcMemory,
                    0, 0, SRCCOPY);

                if (g_hpalWall)
                {
                    SelectPalette(ps.hdc, hpalOld, TRUE);
                    RealizePalette(ps.hdc);
                }
                SelectObject(g_hdcMemory, hbmOld);
            }
            EndPaint(hWnd,&ps);
            return 0;
    }
    return DefWindowProc(hWnd,message,wParam,lParam);
}

BOOL RegisterBackPreviewClass()
{
    WNDCLASS wc;

    if (!GetClassInfo(HINST_THISDLL, c_szBackgroundPreview2, &wc)) 
    {
        wc.style = 0;
        wc.lpfnWndProc = BackPreviewWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = HINST_THISDLL;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szBackgroundPreview2;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\colorctrl.h ===
/*****************************************************************************\
    FILE: ColorCtrl.h

    DESCRIPTION:
        This code will display a ColorPicking control.  It will preview a color
    and have a drop down arrow.  When dropped down, it will show 16 or so common
    colors with a "Other..." option for a full color picker.

    BryanSt 7/25/2000    Converted from the Display Control Panel.

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _COLORCONTROL_H
#define _COLORCONTROL_H

#include <cowsite.h>

#define NUM_COLORSMAX    64
#define NUM_COLORSPERROW 4


class CColorControl             : public CObjectWithSite
                                , public CObjectWindow
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IColorControl ***
    virtual STDMETHODIMP Initialize(IN HWND hwnd, IN COLORREF rgbColor);
    virtual STDMETHODIMP GetColor(IN COLORREF * pColor);
    virtual STDMETHODIMP SetColor(IN COLORREF color);
    virtual STDMETHODIMP OnCommand(IN HWND hDlg, IN UINT message, IN WPARAM wParam, IN LPARAM lParam);
    virtual STDMETHODIMP OnDrawItem(IN HWND hDlg, IN UINT message, IN WPARAM wParam, IN LPARAM lParam);
    virtual STDMETHODIMP ChangeTheme(IN HWND hDlg);

    CColorControl();
    virtual ~CColorControl(void);
protected:

private:

    // Private Member Variables
    int                     m_cRef;

    COLORREF                m_rbgColor;                             // Our current color
    HBRUSH                  m_brColor;                              // Our brush in our color that we use to paint the control.
    int                     m_cxEdgeSM;                             // Cached SM_CXEDGE system metric
    int                     m_cyEdgeSM;                             // Cached SM_CYEDGE system metric

    HTHEME                  m_hTheme;                               // theme the ownerdrawn color picker button

    // Used when display the control UI.
    HWND                    m_hwndParent;
    COLORREF                m_rbgCustomColors[16];                  // This is the user customized palette.
    BOOL                    m_fCursorHidden;                        // Did we hide the cursor?
    BOOL                    m_fCapturing;                           // Are we capturing the mouse?
    BOOL                    m_fJustDropped;                         // 
    int                     m_iNumColors;
    COLORREF                m_rbgColors[NUM_COLORSMAX];
    int                     m_dxColor;
    int                     m_dyColor;
    int                     m_nCurColor;
    DWORD                   m_dwFlags;
    COLORREF                m_rbgColorTemp;                         // The color we may start to use

    BOOL                    m_fPalette;
    HPALETTE                m_hpalVGA;                              // only exist if palette device
    HPALETTE                m_hpal3D;                               // only exist if palette device

    // Private Member Functions
    void _InitDialog(HWND hDlg);
    HRESULT _SaveCustomColors(void);

    BOOL _UseColorPicker(void);
    BOOL _ChooseColorMini(void);

    HRESULT _InitColorAndPalette(void);
    COLORREF _NearestColor(COLORREF rgb);

    void _TrackMouse(HWND hDlg, POINT pt);
    void _FocusColor(HWND hDlg, int iNewColor);
    void _DrawColorSquare(HDC hdc, int iColor);
    void _DrawItem(HWND hDlg, LPDRAWITEMSTRUCT lpdis);
    void _DrawDownArrow(HDC hdc, LPRECT lprc, BOOL bDisabled);

    INT_PTR _ColorPickDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    static INT_PTR CALLBACK ColorPickDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};




#endif // _COLORCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dback.h ===
#ifndef _DBACK_H_
#define _DBACK_H_

#include <shimgdata.h>
#include "theme.h"
#include "dcomp.h"
#include "colorctrl.h"

#define SZ_ICONHEADER           L"CLSID\\{"

HRESULT GetActiveDesktop(IActiveDesktop ** ppActiveDesktop);
HRESULT ReleaseActiveDesktop(IActiveDesktop ** ppActiveDesktop);

EXTERN_C BOOL g_fDirtyAdvanced;
EXTERN_C BOOL g_fLaunchGallery;

typedef struct  tagDESKICONDATA {
    BOOL    fHideIcon;  //To hide the icon on desktop?
    BOOL    fDirty;     //Has this entry been modified and we not yet saved.
} DESKICONDATA;

typedef struct tagDeskIconNonEnumData {

    ULONG       rgfAttributes;           // ShellFolder\Attributes are saved here.
    BOOL        fNonEnumPolicySet;       // Disable the control because of policy Set.
  
} DESKICON_NONENUMDATA;

class CBackPropSheetPage : public CObjectWithSite
                         , public CObjectCLSID
                         , public IBasePropPage
                         , public IPropertyBag
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}


    CBackPropSheetPage(void);
    virtual ~CBackPropSheetPage(void);

protected:
    ICONDATA _IconData[NUM_ICONS];

    DESKICONDATA  _aHideDesktopIcon[2][NUM_DESKICONS];
    BOOL          _fHideDesktopIconDirty;
    DESKICON_NONENUMDATA _aDeskIconNonEnumData[NUM_DESKICONS];

    BOOL _fStateLoaded;         // Have we loaded the state yet?
    BOOL _fOpenAdvOnInit;       // Does the caller want us to open the Advanced dialog when we initialize?
    HWND _hwnd;                 // This is the hwnd of the property page.
    HWND _hwndLV;
    HWND _hwndWPStyle;
    BOOL _fAllowHtml;
    BOOL _fAllowAD;
    BOOL _fAllowChanges;
    BOOL _fPolicyForWallpaper;  //Is there a policy for wallpaper?
    BOOL _fPolicyForStyle;      //Is there a policy for Wallpaper style?
    BOOL _fForceAD;             //Is there a policy to force Active desktop to be ON?
    BOOL _fSelectionFromUser;   // Is the user making the selection?
    DWORD _dwApplyFlags;             //Is there a policy to force Active desktop to be ON?
    CColorControl _colorControl;
    COLORREF _rgbBkgdColor;

    void _AddPicturesFromDir(LPCTSTR pszDirName, BOOL fCount, BOOL fShouldAllowHTML);
    int _AddAFileToLV(LPCTSTR pszDir, LPTSTR pszFile, UINT nBitmap);
    int _FindWallpaper(LPCTSTR pszFile);
    HRESULT _SetNewWallpaper(IN LPCTSTR pszFile, IN BOOL fUpdateThemePage);
    void _UpdatePreview(IN WPARAM flags, IN BOOL fUpdateThemePage);
    void _EnableControls(void);
    int _GetImageIndex(LPCTSTR pszFile);
    static int CALLBACK _SortBackgrounds(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

    HRESULT _LoadState(void);
    HRESULT _LoadIconState(void);
    HRESULT _LoadDesktopOptionsState(void);
    HRESULT _SaveIconState(void);
    HRESULT _SaveDesktopOptionsState(void);
    HRESULT _GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN BOOL fOldIcon, IN LPWSTR pszPath, IN DWORD cchSize);
    HRESULT _SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID);

    void _OnInitDialog(HWND hwnd);
    void _OnNotify(LPNMHDR lpnm);
    void _OnCommand(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnDestroy(void);

    HRESULT _OnApply(void);
    HRESULT _AddFilesToList(void);
    HRESULT _AddPicturesFromDirRecursively(IN LPCTSTR pszDirName, BOOL fCount, BOOL fShouldAllowHTML);
    HRESULT _GetHardDirThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetKidsThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetPlus95ThemesDir(LPTSTR pszPath, DWORD cchSize);
    HRESULT _GetPlus98ThemesDir(LPTSTR pszPath, DWORD cchSize);

    HRESULT _StartSizeChecker(void);
    DWORD _SizeCheckerThreadProc(void);
    static DWORD CALLBACK SizeCheckerThreadProc(LPVOID pvThis) { return ((CBackPropSheetPage *) pvThis)->_SizeCheckerThreadProc(); };

private:
    UINT _cRef;     // Reference count
    BOOL  _fThemePreviewCreated;
    IThemePreview* _pThemePreview;
    LPTSTR _pszOriginalFile;        // If we are using a temp file, this is the original file selected. (non-.bmp).  This updates as the user selects different files.
    LPTSTR _pszOrigLastApplied;     // Same as _pszOriginalFile except it doesn't change until apply is pressed.
    LPWSTR _pszWallpaperInUse;      // If using a temp file, keep the name in use so we don't stomp it while the user is previewing other files.
    LPWSTR _pszLastSourcePath;      // This will always be the last wallpaper set and it will be the pre-converted path.

    FILETIME _ftLastWrite;          // The date that the original file was last written to.
    BOOL _fWallpaperChanged;        // Did another tab change the wallpaper?
    IMruDataList * _pSizeMRU;       // MRU of Background wallpapers.
    BOOL _fScanFinished;            // Did we finish the background scan?
    BOOL _fInitialized;             // 
    int _nFileCount;                // This is used when counting how many pictures are in the "My Pictures" folder.
    int _nFileMax;                  // This is used when counting how many pictures are in the "My Pictures" folder.

    // These objects are owned by the background thread.
    IMruDataList * _pSizeMRUBk;     // WARNING: Owned by SizeCheckerThreadProc background thread.
    IShellImageDataFactory * _pImgFactBk; // Image factory used to compute size of background image to decide to default to tile or stretch

    // Private Member Functions
    HRESULT _LoadTempWallpaperSettings(IN LPCWSTR pszWallpaperFile);
    HRESULT _LaunchAdvancedDisplayProperties(HWND hwnd);
    INT_PTR _BackgroundDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNewWallpaperTile(IN DWORD dwMode, IN BOOL fUpdateThemePage);
    HRESULT _BrowseForBackground(void);
    HRESULT _LoadBackgroundColor(IN BOOL fInit);
    HRESULT _Initialize(void);

    BOOL _DoesDirHaveMoreThanMax(LPCTSTR pszPath, int nMax);
    DWORD _GetStretchMode(IN LPCTSTR pszPath);
    HRESULT _GetMRUObject(IMruDataList ** ppSizeMRU);
    HRESULT _CalcSizeFromDir(IN LPCTSTR szPath, IN OUT DWORD * pdwAdded, IN BOOL fRecursive);
    HRESULT _CalcSizeForFile(IN LPCTSTR pszPath, IN WIN32_FIND_DATA * pfdFile, IN OUT DWORD * pdwAdded);

    static INT_PTR CALLBACK BackgroundDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\cpymovto.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "datautil.h"

#include "_security.h"
#include <urlmon.h>

#define COPYMOVETO_REGKEY   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define COPYMOVETO_SUBKEY   TEXT("CopyMoveTo")
#define COPYMOVETO_VALUE    TEXT("LastFolder")

class CCopyMoveToMenu   : public IContextMenu3
                        , public IShellExtInit
                        , public CObjectWithSite
                        , public IFolderFilter
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    // IFolderFilter
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);
    
private:
    BOOL    m_bMoveTo;
    LONG    m_cRef;
    HMENU   m_hmenu;
    UINT    m_idCmdFirst;
    BOOL    m_bFirstTime;
    LPITEMIDLIST m_pidlSource;
    IDataObject * m_pdtobj;

    CCopyMoveToMenu(BOOL bMoveTo = FALSE);
    ~CCopyMoveToMenu();
    
    HRESULT _DoDragDrop(LPCMINVOKECOMMANDINFO pici, LPCITEMIDLIST pidlFolder);
    void _GenerateDialogTitle(LPTSTR szTitle, int nBuffer);

    friend HRESULT CCopyToMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);
    friend HRESULT CMoveToMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);
};

CCopyMoveToMenu::CCopyMoveToMenu(BOOL bMoveTo) : m_cRef(1), m_bMoveTo(bMoveTo)
{
    DllAddRef();

    // Assert that the member variables are zero initialized during construction
    ASSERT(!m_pidlSource);
}

CCopyMoveToMenu::~CCopyMoveToMenu()
{
    Pidl_Set(&m_pidlSource, NULL);
    ATOMICRELEASE(m_pdtobj);

    DllRelease();
}

HRESULT CCopyToMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    CCopyMoveToMenu *pcopyto = new CCopyMoveToMenu();
    if (pcopyto)
    {
        HRESULT hres = pcopyto->QueryInterface(riid, ppvOut);
        pcopyto->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CMoveToMenu_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    CCopyMoveToMenu *pmoveto = new CCopyMoveToMenu(TRUE);
    if (pmoveto)
    {
        HRESULT hres = pmoveto->QueryInterface(riid, ppvOut);
        pmoveto->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CCopyMoveToMenu::QueryInterface(REFIID riid, void **ppvObj)
{

    static const QITAB qit[] = {
        QITABENT(CCopyMoveToMenu, IContextMenu3),
        QITABENTMULTI(CCopyMoveToMenu, IContextMenu, IContextMenu3),
        QITABENTMULTI(CCopyMoveToMenu, IContextMenu2, IContextMenu3),
        QITABENT(CCopyMoveToMenu, IShellExtInit),
        QITABENT(CCopyMoveToMenu, IObjectWithSite),
        QITABENT(CCopyMoveToMenu, IFolderFilter),
        { 0 },                             
    };
    
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CCopyMoveToMenu::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CCopyMoveToMenu::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CCopyMoveToMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // if they want the default menu only (CMF_DEFAULTONLY) OR 
    // this is being called for a shortcut (CMF_VERBSONLY)
    // we don't want to be on the context menu
    
    if (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY))
        return NOERROR;

    UINT  idCmd = idCmdFirst;
    TCHAR szMenuItem[80];

    m_idCmdFirst = idCmdFirst;
    LoadString(g_hinst, m_bMoveTo? IDS_CMTF_MOVETO: IDS_CMTF_COPYTO, szMenuItem, ARRAYSIZE(szMenuItem));

    InsertMenu(hmenu, indexMenu++, MF_BYPOSITION, idCmd++, szMenuItem);

    return ResultFromShort(idCmd-idCmdFirst);
}

struct BROWSEINFOINITSTRUCT
{
    LPITEMIDLIST *ppidl;
    BOOL          bMoveTo;
    IDataObject  *pdtobj;
    CCopyMoveToMenu *pCMTM;
    LPITEMIDLIST *ppidlSource;
};

int BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    int idResource = 0;

    switch (msg)
    {
    case BFFM_IUNKNOWN:
        // Try to get an IFolderFilterSite from the lParam, so we can set ourselves as the filter.
        if (lParam)
        {
            IFolderFilterSite *pFilterSite;
            HRESULT hr = ((IUnknown*)lParam)->QueryInterface(IID_PPV_ARG(IFolderFilterSite, &pFilterSite));
            if (SUCCEEDED(hr))
            {
                IUnknown *pUnk = NULL;
                if (SUCCEEDED(((BROWSEINFOINITSTRUCT *)lpData)->pCMTM->QueryInterface(IID_PPV_ARG(IUnknown, &pUnk))))
                {
                    pFilterSite->SetFilter(pUnk);
                    pUnk->Release();
                }
                pFilterSite->Release();
            }
        }
        break;

    case BFFM_INITIALIZED:
        {
            BROWSEINFOINITSTRUCT* pbiis = (BROWSEINFOINITSTRUCT*)lpData;
            // Set the caption. ('Select a destination')
            TCHAR szTitle[100];
            if (LoadString(g_hinst, pbiis->bMoveTo ? IDS_CMTF_CAPTION_MOVE : IDS_CMTF_CAPTION_COPY, szTitle, ARRAYSIZE(szTitle)))
            {
                SetWindowText(hwnd, szTitle);
            }

            // Set the text of the Ok Button.
            SendMessage(hwnd, BFFM_SETOKTEXT, 0, (LPARAM)MAKEINTRESOURCE((pbiis->bMoveTo) ? IDS_MOVE : IDS_COPY));

            // Set My Computer expanded.
            // NOTE: If IShellNameSpace is made public, we can get this from IObjectWithSite on the IUnknown
            // passed to us by BFFM_IUNKNOWN. Then we can call Expand() on IShellNameSpace instead.
            LPITEMIDLIST pidlMyComputer;
            HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
            if (SUCCEEDED(hr))
            {
                SendMessage(hwnd, BFFM_SETEXPANDED, FALSE, (LPARAM)pidlMyComputer);

                ILFree(pidlMyComputer);
            }

            // Set the default selected pidl
            SendMessage(hwnd, BFFM_SETSELECTION, FALSE, (LPARAM)*(((BROWSEINFOINITSTRUCT *)lpData)->ppidl));

            break;
        }
    case BFFM_VALIDATEFAILEDW:
        idResource = IDS_PathNotFoundW;
        // FALL THRU...
    case BFFM_VALIDATEFAILEDA:
        if (0 == idResource)    // Make sure we didn't come from BFFM_VALIDATEFAILEDW
            idResource = IDS_PathNotFoundA;

        ShellMessageBox(g_hinst, hwnd,
            MAKEINTRESOURCE(idResource),
            MAKEINTRESOURCE(IDS_CMTF_COPYORMOVE_DLG_TITLE),
            MB_OK|MB_ICONERROR, (LPVOID)lParam);
        return 1;   // 1:leave dialog up for another try...
        /*NOTREACHED*/

    case BFFM_SELCHANGED:
        if (lParam)
        {
            // Here, during a move operation, we want to disable the move (ok) button when the destination
            // folder is the same as the source.
            // During a move or copy operation, we want to disable the move/copy (ok) button when the
            // destination is not a drop target.
            // In all other cases, we enable the ok/move/copy button.

            BROWSEINFOINITSTRUCT *pbiis = (BROWSEINFOINITSTRUCT *)lpData;
            if (pbiis)
            {
                BOOL bEnableOK = FALSE;
                IShellFolder *psf;

                if ((!pbiis->bMoveTo || !ILIsEqual(*pbiis->ppidlSource, (LPITEMIDLIST)lParam)) &&
                    (SUCCEEDED(SHBindToObjectEx(NULL, (LPITEMIDLIST)lParam, NULL, IID_PPV_ARG(IShellFolder, &psf)))))
                {
                    IDropTarget *pdt;
                    
                    if (SUCCEEDED(psf->CreateViewObject(hwnd, IID_PPV_ARG(IDropTarget, &pdt))))
                    {
                        POINTL pt = {0, 0};
                        DWORD  dwEffect;
                        DWORD  grfKeyState;

                        if (pbiis->bMoveTo)
                        {
                            dwEffect = DROPEFFECT_MOVE;
                            grfKeyState = MK_SHIFT | MK_LBUTTON;
                        }
                        else
                        {
                            dwEffect = DROPEFFECT_COPY;
                            grfKeyState = MK_CONTROL | MK_LBUTTON;
                        }

                        if (SUCCEEDED(pdt->DragEnter(pbiis->pdtobj, grfKeyState, pt, &dwEffect)))
                        {
                            if (dwEffect)
                            {
                                bEnableOK = TRUE;
                            }
                            pdt->DragLeave();
                        }
                        pdt->Release();
                    }
                    psf->Release();
                }
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)bEnableOK);
            }
        }
        break;
    }

    return 0;
}


HRESULT CCopyMoveToMenu::_DoDragDrop(LPCMINVOKECOMMANDINFO pici, LPCITEMIDLIST pidlFolder)
{
    // This should always succeed because the caller (SHBrowseForFolder) should
    // have weeded out the non-folders.
    IShellFolder *psf;
    HRESULT hr = SHBindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        IDropTarget *pdrop;
        hr = psf->CreateViewObject(pici->hwnd, IID_PPV_ARG(IDropTarget, &pdrop));
        if (SUCCEEDED(hr))    // Will fail for some targets. (Like Nethood->Entire Network)
        {
            DWORD grfKeyState;
            DWORD dwEffect;

            if (m_bMoveTo)
            {
                grfKeyState = MK_SHIFT | MK_LBUTTON;
                dwEffect = DROPEFFECT_MOVE;
            }
            else
            {
                grfKeyState = MK_CONTROL | MK_LBUTTON;
                dwEffect = DROPEFFECT_COPY;
            }

            hr = SimulateDropWithPasteSucceeded(pdrop, m_pdtobj, grfKeyState, NULL, dwEffect, NULL, FALSE);
            
            pdrop->Release();
        }

        psf->Release();
    }

    if (FAILED_AND_NOT_CANCELED(hr))
    {
        // Go modal during the UI.
        IUnknown_EnableModless(_punkSite, FALSE);
        ShellMessageBox(g_hinst, pici->hwnd, MAKEINTRESOURCE(IDS_CMTF_ERRORMSG),
                        MAKEINTRESOURCE(IDS_CABINET), MB_OK|MB_ICONEXCLAMATION);
        IUnknown_EnableModless(_punkSite, TRUE);
    }

    return hr;
}


void CCopyMoveToMenu::_GenerateDialogTitle(LPTSTR szTitle, int nBuffer)
{
    szTitle[0] = 0;

    if (m_pdtobj)
    {
        int nItemCount = DataObj_GetHIDACount(m_pdtobj);
        TCHAR szDescription[200];

        if (nItemCount > 1)
        {
            DWORD_PTR rg[1];
            rg[0] = (DWORD_PTR)nItemCount;
            // More than one item is selected. Don't bother listing all items.
            DWORD dwMessageId = m_bMoveTo ? IDS_CMTF_MOVE_MULTIPLE_DLG_TITLE2 : IDS_CMTF_COPY_MULTIPLE_DLG_TITLE2;                
            if (LoadString(g_hinst, dwMessageId, szDescription, ARRAYSIZE(szDescription)) > 0)
                FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szDescription, 0, 0, szTitle, nBuffer, (va_list*)rg);
        }
        else if (nItemCount == 1)
        {
            // We have only one item selected. Use its name.
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(m_pdtobj, &medium);
            if (pida)
            {
                LPITEMIDLIST pidlFull = IDA_FullIDList(pida, 0);

                if (pidlFull)
                {
                    TCHAR szItemName[MAX_PATH];
                    HRESULT hres = SHGetNameAndFlags(pidlFull, SHGDN_INFOLDER, szItemName, ARRAYSIZE(szItemName), NULL);
                    if (SUCCEEDED(hres))
                    {
                        DWORD_PTR rg[1];
                        rg[0] = (DWORD_PTR)szItemName;
                        DWORD dwMessageId = m_bMoveTo ? IDS_CMTF_MOVE_DLG_TITLE2 : IDS_CMTF_COPY_DLG_TITLE2;
                        if (LoadString(g_hinst, dwMessageId, szDescription, ARRAYSIZE(szDescription)))
                            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szDescription, 0, 0, szTitle, nBuffer, (va_list*)rg);
                    }

                    ILFree(pidlFull);
                }

                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        else
        {
            // no HIDA, just default to something.
            DWORD dwMessageId = m_bMoveTo ? IDS_CMTF_MOVE_DLG_TITLE : IDS_CMTF_COPY_DLG_TITLE;
            LoadString(g_hinst, dwMessageId, szTitle, nBuffer);
        }
    }
}


/**
 * Determines if the pidl still exists.  If it does not, if frees it
 * and replaces it with a My Documents pidl
 */
void _BFFSwitchToMyDocsIfPidlNotExist(LPITEMIDLIST *ppidl)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SHBindToIDListParent(*ppidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        DWORD dwAttr = SFGAO_VALIDATE;
        if (FAILED(psf->GetAttributesOf(1, &pidlChild, &dwAttr)))
        {
            // This means the pidl no longer exists.  
            // Use my documents instead.
            LPITEMIDLIST pidlMyDocs;
            if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidlMyDocs)))
            {
                // Good.  Now we can get rid of the old pidl and use this one.
                ILFree(*ppidl);
                *ppidl = pidlMyDocs;
            }
        }
        psf->Release();
    }
}

HRESULT CCopyMoveToMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hres;
    
    if (m_pdtobj)
    {
        HKEY         hkey    = NULL;
        IStream      *pstrm  = NULL;
        LPITEMIDLIST pidlSelectedFolder = NULL;
        LPITEMIDLIST pidlFolder = NULL;
        TCHAR        szTitle[MAX_PATH + 200];
        BROWSEINFOINITSTRUCT biis =
        {   // passing the address of pidl because it is not init-ed yet
            // but it will be before call to SHBrowseForFolder so save one assignment
            &pidlSelectedFolder,
            m_bMoveTo,
            m_pdtobj,
            this,
            &m_pidlSource
        };

        BROWSEINFO   bi =
        {
            pici->hwnd, 
            NULL,
            NULL, 
            szTitle,
            BIF_VALIDATE | BIF_NEWDIALOGSTYLE | BIF_UAHINT | BIF_NOTRANSLATETARGETS, 
            BrowseCallback,
            (LPARAM)&biis
        };

        _GenerateDialogTitle(szTitle, ARRAYSIZE(szTitle));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, COPYMOVETO_REGKEY, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey))
        {
            pstrm = OpenRegStream(hkey, COPYMOVETO_SUBKEY, COPYMOVETO_VALUE, STGM_READWRITE);
            if (pstrm)  // OpenRegStream will fail if the reg key is empty.
                ILLoadFromStream(pstrm, &pidlSelectedFolder);

            // This will switch the pidl to My Docs if the pidl does not exist.
            // This prevents us from having My Computer as the default (that's what happens if our
            // initial set selected call fails).
            // Note: ideally, we would check in BFFM_INITIALIZED, if our BFFM_SETSELECTION failed
            // then do a BFFM_SETSELECTION on My Documents instead.  However, BFFM_SETSELECTION always
            // returns zero (it's doc'd to do this to, so we can't change).  So we do the validation
            // here instead.  There is still a small chance that this folder will be deleted in between our
            // check here, and when we call BFFM_SETSELECTION, but oh well.
            _BFFSwitchToMyDocsIfPidlNotExist(&pidlSelectedFolder);
        }

        // Go modal during the UI.
        IUnknown_EnableModless(_punkSite, FALSE);
        pidlFolder = SHBrowseForFolder(&bi);
        IUnknown_EnableModless(_punkSite, TRUE);
        if (pidlFolder)
        {
            hres = _DoDragDrop(pici, pidlFolder);
        }
        else
            hres = E_FAIL;

        if (pstrm)
        {
            if (S_OK == hres)
            {
                TCHAR szFolder[MAX_PATH];
                
                if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szFolder, ARRAYSIZE(szFolder), NULL))
                    && !PathIsRemote(szFolder))
                {
                    ULARGE_INTEGER uli;

                    // rewind the stream to the beginning so that when we
                    // add a new pidl it does not get appended to the first one
                    pstrm->Seek(g_li0, STREAM_SEEK_SET, &uli);
                    ILSaveToStream(pstrm, pidlFolder);

#if DEBUG
                    // pfortier 3/23/01:
                    // We've been seeing a problem where the result of this is the My Computer folder.
                    // Since we can never copy there, that doesn't make any sense.
                    // ASSERT that this isn't true!
                    LPITEMIDLIST pidlMyComputer;
                    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer)))
                    {
                        ASSERTMSG(!ILIsEqual(pidlMyComputer, pidlFolder), "SHBrowseForFolder returned My Computer as a copyto destination!");
                        ILFree(pidlMyComputer);
                    }
#endif

                }
            }

            pstrm->Release();
        }

        if (hkey)
        {
            RegCloseKey(hkey);
        }

        ILFree(pidlFolder); // ILFree() works for NULL pidls.
        ILFree(pidlSelectedFolder); // ILFree() works for NULL pidls.
    }
    else
        hres = E_INVALIDARG;

    return hres;
}

HRESULT CCopyMoveToMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

HRESULT CCopyMoveToMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

HRESULT CCopyMoveToMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    //case WM_INITMENUPOPUP:
    //    break;

    case WM_DRAWITEM:
    {
        DRAWITEMSTRUCT * pdi = (DRAWITEMSTRUCT *)lParam;
    
        if (pdi->CtlType == ODT_MENU && pdi->itemID == m_idCmdFirst) 
        {
            FileMenu_DrawItem(NULL, pdi);
        }
        break;
    }

    case WM_MEASUREITEM:
    {
        MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
    
        if (pmi->CtlType == ODT_MENU && pmi->itemID == m_idCmdFirst) 
        {
            FileMenu_MeasureItem(NULL, pmi);
        }
        break;
    }

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plres)
        *plres = 0;

    return hr;
}

HRESULT CCopyMoveToMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    HRESULT hres = S_OK;

    if (!pdtobj)
        return E_INVALIDARG;

    IUnknown_Set((IUnknown **) &m_pdtobj, (IUnknown *) pdtobj);
    ASSERT(m_pdtobj);

    // (jeffreys) pidlFolder is now NULL when pdtobj is non-NULL
    // See comments above the call to HDXA_AppendMenuItems2 in
    // defcm.cpp!CDefFolderMenu::QueryContextMenu.  Raid #232106
    if (!pidlFolder)
    {
        hres = PidlFromDataObject(m_pdtobj, &m_pidlSource);
        if (SUCCEEDED(hres))
        {
            // Make it the parent pidl of this pidl
            if (!ILRemoveLastID(m_pidlSource))
            {
                hres = E_INVALIDARG;
            }
        }
    }
    else if (!Pidl_Set(&m_pidlSource, pidlFolder))
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

HRESULT CCopyMoveToMenu::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    LPITEMIDLIST pidlNotShown;
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlFolderActual; // Why is pidlFolder is NULL???
    if (SUCCEEDED(SHGetIDListFromUnk(psf, &pidlFolderActual)))
    {
        LPITEMIDLIST pidlFull = ILCombine(pidlFolderActual, pidlItem);
        if (pidlFull)
        {
            // Filter out control panel and recycle bin.
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlNotShown)))
            {
                if (ILIsEqual(pidlFull, pidlNotShown))
                    hr = S_FALSE;

                ILFree(pidlNotShown);
            }

            if ((hr == S_OK) && (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidlNotShown))))
            {
                if (ILIsEqual(pidlFull, pidlNotShown))
                    hr = S_FALSE;

                ILFree(pidlNotShown);
            }
            

            ILFree(pidlFull);
        }
        ILFree(pidlFolderActual);
    }
    return hr;
}


HRESULT CCopyMoveToMenu::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    // Only want drop targets - this doesn't appear to work.
    *pgrfFlags |= SFGAO_DROPTARGET;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dcomp.cpp ===
#include "stdafx.h"
#pragma hdrstop

#define _BROWSEUI_      // Make functions exported from browseui as stdapi (as they are delay loaded)
#include "iethread.h"
#include "browseui.h"
#include "securent.h"
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN

static void EmptyListview(IActiveDesktop * pActiveDesktop, HWND hwndLV);

#define DXA_GROWTH_CONST 10
 
#define COMP_CHECKED    0x00002000
#define COMP_UNCHECKED  0x00001000

#define GALRET_NO       0x00000001
#define GALRET_NEVER    0x00000002

#define CCompPropSheetPage CCompPropSheetPage

const static DWORD aDesktopItemsHelpIDs[] = {  // Context Help IDs
    IDC_COMP_DESKTOPWEBPAGES_TITLE1, IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST,
    IDC_COMP_LIST,       IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST,
    IDC_COMP_NEW,        IDH_DISPLAY_WEB_NEW_BUTTON,
    IDC_COMP_DELETE,     IDH_DISPLAY_WEB_DELETE_BUTTON,
    IDC_COMP_PROPERTIES, IDH_DISPLAY_WEB_PROPERTIES_BUTTON,
    IDC_COMP_SYNCHRONIZE,IDH_DISPLAY_WEB_SYNCHRONIZE_BUTTON,

    IDC_COMP_DESKTOPICONS_GROUP,        IDH_DESKTOPITEMS_DESKTOPICONS_GROUP,
    IDC_DESKTOP_ICON_MYDOCS,            IDH_DESKTOPITEMS_DESKTOPICONS_GROUP,
    IDC_DESKTOP_ICON_MYCOMP,            IDH_DESKTOPITEMS_DESKTOPICONS_GROUP,
    IDC_DESKTOP_ICON_MYNET,             IDH_DESKTOPITEMS_DESKTOPICONS_GROUP,
    IDC_DESKTOP_ICON_IE,                IDH_DESKTOPITEMS_DESKTOPICONS_GROUP,
    IDC_COMP_CHANGEDESKTOPICON_LABEL,   IDH_DESKTOPITEMS_ICONS,
    IDC_DESKTOP_ICONS,                  IDH_DESKTOPITEMS_ICONS,                 // List of icons
    IDC_CHANGEICON2,                    IDH_DESKTOPITEMS_CHANGEICON2,           // Change Icon Button
    IDC_ICONDEFAULT,                    IDH_DESKTOPITEMS_ICONDEFAULT,           // Default Icon Button
    IDC_COMP_DESKTOPWEBPAGES_LABEL,     IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST,
    IDC_DESKCLNR_CHECK,                 IDH_DESKTOPITEMS_DESKCLNR_CHECK,
    IDC_DESKCLNR_MOVEUNUSED,            IDH_DESKTOPITEMS_DESKCLNR_CHECK,
    IDC_DESKCLNR_RUNWIZARD,             IDH_DESKTOPITEMS_DESKCLNR_RUNNOW,
    IDC_COMP_DESKTOPWEBPAGES_CHECK,     IDH_DESKTOPITEMS_LOCKDESKITEMS_CHECK,
    IDC_COMP_DESKTOPWEBPAGES_TITLE2,    IDH_DESKTOPITEMS_LOCKDESKITEMS_CHECK,
    0, 0
};


#define SZ_HELPFILE_DESKTOPITEMS           TEXT("display.hlp")

// registry paths defined in shell\applet\cleanup\fldrclnr\cleanupwiz.h
#define REGSTR_DESKTOP_CLEANUP  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\CleanupWiz")
#define REGSTR_VAL_DONTRUN      TEXT("NoRun")

extern int g_iRunDesktopCleanup;

typedef struct
{
    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    SUBSCRIPTIONINFO si;
} BACKUPSUBSCRIPTION;


const LPCWSTR s_Icons[] =
{
    L"CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon:DefaultValue",       // My Computer
    L"CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon:DefaultValue",       // My Documents
    L"CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon:DefaultValue",       // My Network Places
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:full",               // Recycle Bin (Full)
    L"CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon:empty",              // Recycle Bin (Empty)
};


IActiveDesktop * g_pActiveDeskAdv = NULL;          // We need to keep a different copy than g_pActiveDesk
extern DWORD g_dwApplyFlags;


//  Extract Icon from a file in proper Hi or Lo color for current system display
//
// from FrancisH on 6/22/95 with mods by TimBragg
HRESULT ExtractPlusColorIcon(LPCTSTR szPath, int nIndex, HICON *phIcon, UINT uSizeLarge, UINT uSizeSmall)
{
    IShellLink * psl;
    HRESULT hres;
    HICON hIcons[2];    // MUST! - provide for TWO return icons

    *phIcon = NULL;
    if (SUCCEEDED(hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl))))
    {
        if (SUCCEEDED(hres = psl->SetIconLocation(szPath, nIndex)))
        {
            IExtractIcon *pei;
            if (SUCCEEDED(hres = psl->QueryInterface(IID_PPV_ARG(IExtractIcon, &pei))))
            {
                if (SUCCEEDED(hres = pei->Extract(szPath, nIndex, &hIcons[0], &hIcons[1], (UINT)MAKEWPARAM((WORD)uSizeLarge, (WORD)uSizeSmall))))
                {
                    DestroyIcon(hIcons[1]);
                    *phIcon = hIcons[0];    // Return first icon to caller
                }

                pei->Release();
            }
        }

        psl->Release();
    }

    return hres;
}   // end ExtractPlusColorIcon()


BOOL AreEditAndDisplaySchemesDifferent(IActiveDesktop * pActiveDesktop)
{
    BOOL fAreDifferent = FALSE;
    IActiveDesktopP * piadp;

    if (SUCCEEDED(pActiveDesktop->QueryInterface(IID_PPV_ARG(IActiveDesktopP, &piadp))))
    {
        WCHAR wszEdit[MAX_PATH];
        WCHAR wszDisplay[MAX_PATH];
        DWORD dwcch = ARRAYSIZE(wszEdit);

        // If the edit scheme and display scheme are different, then we need to make
        // sure we force an update.
        if (SUCCEEDED(piadp->GetScheme(wszEdit, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
        {
            dwcch = ARRAYSIZE(wszDisplay);
            if (SUCCEEDED(piadp->GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)))
            {
                if (StrCmpW(wszDisplay, wszEdit))
                {
                    fAreDifferent = TRUE;
                }
            }            
        }

        piadp->Release();
    }

    return fAreDifferent;
}

HRESULT ActiveDesktop_CopyDesktopComponentsState(IN IActiveDesktop * pADSource, IN IActiveDesktop * pADDest)
{
    int nCompCount;
    int nIndex;
    COMPONENT comp = {sizeof(comp)};
    IPropertyBag  *iPropBag = NULL;

    if(SUCCEEDED(pADDest->QueryInterface(IID_PPV_ARG(IPropertyBag, &iPropBag))))
    {
        //Inform the AD object to ignore policies. Otherwise, the following Remove and AddDesktopItem
        //calls will generate error messages if those policies were in effect.
        SHPropertyBag_WriteBOOL(iPropBag, c_wszPropName_IgnorePolicies, TRUE);
    }

    // Remove the desktop components from g_pActiveDesk because they will be replaced
    // with the ones from g_pActiveDeskAdv.
    pADDest->GetDesktopItemCount(&nCompCount, 0);
    for (nIndex = (nCompCount - 1); nIndex >= 0; nIndex--)
    {
        if (SUCCEEDED(pADDest->GetDesktopItem(nIndex, &comp, 0)))
        {
            pADDest->RemoveDesktopItem(&comp, 0);
        }
    }

    // Now copy the Desktop Components from g_pActiveDeskAdv to g_pActiveDesk.
    pADSource->GetDesktopItemCount(&nCompCount, 0);
    for (nIndex = 0; nIndex < nCompCount; nIndex++)
    {
        if (SUCCEEDED(pADSource->GetDesktopItem(nIndex, &comp, 0)))
        {
            pADDest->AddDesktopItem(&comp, 0);
        }
    }

    if(iPropBag)
    {
        //We have removed and added all the desktop items. We are done manipulating the AD object.
        // Now, signal the AD object to reset the policies bit.
        SHPropertyBag_WriteBOOL(iPropBag, c_wszPropName_IgnorePolicies, FALSE);
        iPropBag->Release();
    }

    return S_OK;
}


HRESULT ActiveDesktop_CopyComponentOptionsState(IN IActiveDesktop * pADSource, IN IActiveDesktop * pADDest)
{
    HRESULT hr;
    COMPONENTSOPT co;

    // Copy over the on or off state of ActiveDesktop
    co.dwSize = sizeof(COMPONENTSOPT);
    hr = pADSource->GetDesktopItemOptions(&co, 0);
    if (SUCCEEDED(hr))
    {
        hr = pADDest->SetDesktopItemOptions(&co, 0);
    }

    return hr;
}


// In ActiveDesktop_CopyState, we try to do as much as we can.  If we fail, we keep going,
//   but we still have to return E_FAIL if any part of our work failed.
HRESULT ActiveDesktop_CopyState(IN IActiveDesktop * pADSource, IN IActiveDesktop * pADDest)
{
    HRESULT hr = S_OK;

    WCHAR szPath[MAX_PATH];
    WALLPAPEROPT wallPaperOtp = {0};

    // The Advanced page allowed the user to change the state.  We need to merge
    // the state from g_pActiveDeskAdv back into g_pActiveDesk
    if (FAILED(ActiveDesktop_CopyDesktopComponentsState(pADSource, pADDest)))
    {
        hr = E_FAIL;
    }

    if (FAILED(ActiveDesktop_CopyComponentOptionsState(pADSource, pADDest)))
    {
        hr = E_FAIL;
    }

    if (FAILED(pADSource->GetWallpaper(szPath, ARRAYSIZE(szPath), 0)) ||
        FAILED(pADDest->SetWallpaper(szPath, 0)))
    {
        hr = E_FAIL;
    }


    if (FAILED(pADSource->GetPattern(szPath, ARRAYSIZE(szPath), 0)) ||
        FAILED(pADDest->SetPattern(szPath, 0)))
    {
        hr = E_FAIL;
    }

    wallPaperOtp.dwSize = sizeof(wallPaperOtp);
    if (FAILED(pADSource->GetWallpaperOptions(&wallPaperOtp, 0)) ||
        FAILED(pADDest->SetWallpaperOptions(&wallPaperOtp, 0)))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT MergeState()
{
    // The Advanced page allowed the user to change the state.  We need to merge
    // the state from g_pActiveDeskAdv back into g_pActiveDesk
    ActiveDesktop_CopyDesktopComponentsState(g_pActiveDeskAdv, g_pActiveDesk);

    // Copy over the on or off state of ActiveDesktop
    COMPONENTSOPT co;

    co.dwSize = sizeof(COMPONENTSOPT);
    g_pActiveDeskAdv->GetDesktopItemOptions(&co, 0);
    BOOL fActiveDesktop = co.fActiveDesktop;

    g_pActiveDesk->GetDesktopItemOptions(&co, 0);
    co.fActiveDesktop = fActiveDesktop;         // Replace only this option.
    g_pActiveDesk->SetDesktopItemOptions(&co, 0);

    // If the edit scheme and display scheme are different, then we need to make
    // sure we force an update.
    if (AreEditAndDisplaySchemesDifferent(g_pActiveDeskAdv))
    {
        g_dwApplyFlags |= AD_APPLY_FORCE;
    }

    return S_OK;
}



HRESULT SHPropertyBag_ReadIcon(IN IPropertyBag * pAdvPage, IN BOOL fOldIcon, IN int nIndex, IN LPWSTR pszPath, IN DWORD cchSize, IN int * pnIcon)
{
    HRESULT hr = E_INVALIDARG;

    if (nIndex < ARRAYSIZE(s_Icons))
    {
        WCHAR szPropName[MAX_URL_STRING];

        hr = StringCchCopy(szPropName, ARRAYSIZE(szPropName), s_Icons[nIndex]);
        if (SUCCEEDED(hr))
        {
            if (fOldIcon)
            {
                // Indicate we want the old icon
                LPWSTR pszToken = StrChrW(szPropName, L':');
                if (pszToken)
                {
                    pszToken[0] = L';';
                }
            }

            hr = SHPropertyBag_ReadStr(pAdvPage, szPropName, pszPath, cchSize);
            if (SUCCEEDED(hr))
            {
                *pnIcon= PathParseIconLocation(pszPath);
            }
        }
    }

    return hr;
}


HRESULT SHPropertyBag_WriteIcon(IN IPropertyBag * pAdvPage, IN int nIndex, IN LPCWSTR pszPath, IN int nIcon)
{
    HRESULT hr;

    if (nIndex >= ARRAYSIZE(s_Icons))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR szPathAndIcon[MAX_PATH];

        hr = StringCchPrintf(szPathAndIcon, ARRAYSIZE(szPathAndIcon), L"%s,%d", pszPath, nIcon);
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_WriteStr(pAdvPage, s_Icons[nIndex], szPathAndIcon);
        }
    }

    return hr;
}


HRESULT CCompPropSheetPage::_LoadIconState(IN IPropertyBag * pAdvPage)
{
    HRESULT hr = S_OK;
    int nIndex;

    // Move the values to the base dialog
    for (nIndex = 0; SUCCEEDED(hr) && (nIndex < ARRAYSIZE(_IconData)); nIndex++)
    {
        hr = SHPropertyBag_ReadIcon(pAdvPage, TRUE, nIndex, _IconData[nIndex].szOldFile, ARRAYSIZE(_IconData[nIndex].szOldFile), &_IconData[nIndex].iOldIndex);
        if (SUCCEEDED(hr))
        {
            hr = SHPropertyBag_ReadIcon(pAdvPage, FALSE, nIndex, _IconData[nIndex].szNewFile, ARRAYSIZE(_IconData[nIndex].szNewFile), &_IconData[nIndex].iNewIndex);
        }
    }

    return hr;
}

HRESULT CCompPropSheetPage::_LoadDeskIconState(IN IPropertyBag * pAdvPage)
{
    HRESULT hr = S_OK;

    // Copy the values from the base dialog
    for (int iStartPanel = 0; iStartPanel <= 1; iStartPanel++)
    {
        WCHAR   wszPropName[MAX_GUID_STRING_LEN + 20];
        for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < NUM_DESKICONS); nIndex++)
        {
            // set defaults in case we fail the printfs
            _afHideIcon[iStartPanel][nIndex] = FALSE;
            if (iStartPanel == 1)
            {
                _afDisableCheckBox[nIndex] = FALSE;
            }

            hr = StringCchPrintf(wszPropName, ARRAYSIZE(wszPropName), c_wszPropNameFormat, c_awszSP[iStartPanel], c_aDeskIconId[nIndex].pwszCLSID);
            if (SUCCEEDED(hr))
            {
                _afHideIcon[iStartPanel][nIndex] = SHPropertyBag_ReadBOOLDefRet(pAdvPage, wszPropName, FALSE);

                if(iStartPanel == 1)
                {
                    hr = StringCchPrintf(wszPropName, ARRAYSIZE(wszPropName), c_wszPropNameFormat, POLICY_PREFIX, c_aDeskIconId[nIndex].pwszCLSID);
                    if (SUCCEEDED(hr))
                    {
                        _afDisableCheckBox[nIndex] = SHPropertyBag_ReadBOOLDefRet(pAdvPage, wszPropName, FALSE);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CCompPropSheetPage::_MergeDeskIconState(IN IPropertyBag * pAdvPage)
{
    HRESULT hr = S_OK;
    
    // Move the values to the base dialog
    for (int iStartPanel = 0; SUCCEEDED(hr) && iStartPanel <= 1; iStartPanel++)
    {
        WCHAR   wszPropName[MAX_GUID_STRING_LEN + 20];
        for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < NUM_DESKICONS); nIndex++)
        {
            hr = StringCchPrintf(wszPropName, ARRAYSIZE(wszPropName), c_wszPropNameFormat, c_awszSP[iStartPanel], c_aDeskIconId[nIndex].pwszCLSID);
            if (SUCCEEDED(hr))
            {
                // Check if any icons have changed.
                hr = SHPropertyBag_WriteBOOL(pAdvPage, wszPropName, _afHideIcon[iStartPanel][nIndex]);
            }
        }
    }
    return hr;
}

HRESULT CCompPropSheetPage::_MergeIconState(IN IPropertyBag * pAdvPage)
{
    HRESULT hr = S_OK;
    BOOL fHasIconsChanged = FALSE;
    int nIndex;

    // Move the values to the base dialog
    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        // Check if any icons have changed.
        if ((_IconData[nIndex].iNewIndex != _IconData[nIndex].iOldIndex) ||
            StrCmpI(_IconData[nIndex].szNewFile, _IconData[nIndex].szOldFile))
        {
            hr = SHPropertyBag_WriteIcon(pAdvPage, nIndex, _IconData[nIndex].szNewFile, _IconData[nIndex].iNewIndex);

            fHasIconsChanged = TRUE;
        }
    }

    // Only switch to "Custom" if the icons changed.
    if (_punkSite && fHasIconsChanged)
    {
        // We need to tell the Theme tab to customize the theme.
        IPropertyBag * pPropertyBag;
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            // Tell the theme that we have customized the values.
            hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
            pPropertyBag->Release();
        }
    }

    return hr;
}


void CCompPropSheetPage::_AddComponentToLV(COMPONENTA *pcomp)
{
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH + 40];

    if (SUCCEEDED(StringCchCopy(szBuf, ARRAYSIZE(szBuf), 
                                pcomp->szFriendlyName[0] ? pcomp->szFriendlyName : pcomp->szSource)))
    {
        //
        // Construct the listview item.
        //
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0x7FFFFFFF;
        lvi.pszText = szBuf;
        lvi.lParam = pcomp->dwID;

        int index = ListView_InsertItem(_hwndLV, &lvi);
        if (index != -1)
        {
            ListView_SetItemState(_hwndLV, index, pcomp->fChecked ? COMP_CHECKED : COMP_UNCHECKED, LVIS_STATEIMAGEMASK);
            ListView_SetColumnWidth(_hwndLV, 0, LVSCW_AUTOSIZE);
        }
    }
}

void CCompPropSheetPage::_SetUIFromDeskState(BOOL fEmpty)
{
    //
    // Disable redraws while we mess repeatedly with the listview contents.
    //
    SendMessage(_hwndLV, WM_SETREDRAW, FALSE, 0);

    if (fEmpty)
    {
        EmptyListview(g_pActiveDeskAdv, _hwndLV);
    }

    //
    // Add each component to the listview.
    //
    int cComp;
    g_pActiveDeskAdv->GetDesktopItemCount(&cComp, 0);
    for (int i=0; i<cComp; i++)
    {
        COMPONENT comp;
        comp.dwSize = sizeof(comp);

        if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItem(i, &comp, 0)))
        {
            COMPONENTA compA;
            compA.dwSize = sizeof(compA);
            WideCompToMultiComp(&comp, &compA);
            _AddComponentToLV(&compA);
        }
    }

    _fInitialized = TRUE;
    //
    // Reenable redraws.
    //
    SendMessage(_hwndLV, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(_hwndLV, NULL, TRUE);
}

void CCompPropSheetPage::_EnableControls(HWND hwnd)
{
    BOOL fEnable;
    COMPONENT comp = { sizeof(comp) };
    BOOL fHaveSelection = FALSE;
    BOOL fSpecialComp = FALSE;  //Is this a special component that can't be deleted?
    LPTSTR  pszSource = NULL;

    // Read in the information about the selected component (if any).
    int iIndex = ListView_GetNextItem(_hwndLV, -1, LVNI_SELECTED);
    if (iIndex > -1)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iIndex;
        ListView_GetItem(_hwndLV, &lvi);

        if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItemByID( lvi.lParam, &comp, 0)))
        {
            fHaveSelection = TRUE;
            //Check if this is a special component.
#ifdef UNICODE
            pszSource = (LPTSTR)comp.wszSource;
#else
            SHUnicodeToAnsi(comp.wszSource, szCompSource, ARRAYSIZE(szCompSource));
            pszSource = szCompSource;
#endif
            fSpecialComp = !lstrcmpi(pszSource, MY_HOMEPAGE_SOURCE);
        }
    }

//  98/08/19 vtan #142332: If there was a previously selected item
//  then reselect it and mark that there is now no previously selected
//  item.

    else if (_iPreviousSelection > -1)
    {
        ListView_SetItemState(_hwndLV, _iPreviousSelection, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        _iPreviousSelection = -1;
        // The above ListView_SetItemState results in LVN_ITEMCHANGED notification to _onNotify
        // function which inturn calls this _EnableControls again (recursively) and that call
        // enables/disables the buttons properly because now an item is selected. Nothing more
        // to do and hence this return.
        // This is done to fix Bug #276568.
        return;
    }

    EnableWindow(GetDlgItem(hwnd, IDC_COMP_NEW), _fAllowAdd);

    //
    // Delete button only enabled when an item is selected AND if it is NOT a special comp.
    //
    fEnable = _fAllowDel && fHaveSelection && !fSpecialComp;
    EnableWindow(GetDlgItem(hwnd, IDC_COMP_DELETE), fEnable);

    //
    // Properties button only enabled on URL based pictures
    // and websites.
    //
    fEnable = FALSE;
    if (_fAllowEdit && fHaveSelection)
    {
        switch (comp.iComponentType)
        {
            case COMP_TYPE_PICTURE:
            case COMP_TYPE_WEBSITE:
                //pszSource is already initialized if fHaveSelection is TRUE.
                if (PathIsURL(pszSource))
                {
                    fEnable = TRUE;
                }
                break;
        }
    }
    EnableWindow(GetDlgItem(hwnd, IDC_COMP_PROPERTIES), fEnable);
   
    // initialize the Lock Desktop Items button
    CheckDlgButton(hwnd, IDC_COMP_DESKTOPWEBPAGES_CHECK, _fLockDesktopItems);
}

HWND CCompPropSheetPage::_CreateListView(HWND hWndParent)
{
    LV_ITEM lvI;            // List view item structure
    TCHAR   szTemp[MAX_PATH];
    BOOL bEnable = FALSE;
#ifdef JIGGLE_FIX
    RECT rc;
#endif
    UINT flags = ILC_MASK | ILC_COLOR32;
    // Create a device independant size and location
    LONG lWndunits = GetDialogBaseUnits();
    int iWndx = LOWORD(lWndunits);
    int iWndy = HIWORD(lWndunits);
    int iX = ((11 * iWndx) / 4);
    int iY = ((15 * iWndy) / 8);
    int iWidth = ((163 * iWndx) / 4);
    int iHeight = ((40 * iWndy) / 8);
    int nIndex;

    // Ensure that the common control DLL is loaded.
    InitCommonControls();

    // Get the list view window
    _hWndList = GetDlgItem(hWndParent, IDC_DESKTOP_ICONS);
    if(_hWndList == NULL)
        return NULL;
    if(IS_WINDOW_RTL_MIRRORED(hWndParent))
    {
        flags |= ILC_MIRROR;
    }
    // initialize the list view window
    // First, initialize the image lists we will need
    _hIconList = ImageList_Create(32, 32, flags, ARRAYSIZE(c_aIconRegKeys), 0 );   // create an image list for the icons

    // load the icons and add them to the image lists
    // get the icon files and indexes from the registry, including for the Default recycle bin
    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        HICON hIcon = NULL;

        ExtractPlusColorIcon(_IconData[nIndex].szNewFile, _IconData[nIndex].iNewIndex, &hIcon, 0, 0);

        // Added this "if" to fix bug 2831.  We want to use SHELL32.DLL
        // icon 0 if there is no icon in the file specified in the
        // registry (or if the registry didn't specify a file).
        if(hIcon == NULL)
        {
            if (GetSystemDirectory(szTemp, ARRAYSIZE(szTemp)) &&
                PathAppend(szTemp, TEXT("shell32.dll")) &&
                SUCCEEDED(StringCchCopy(_IconData[nIndex].szOldFile, ARRAYSIZE(_IconData[nIndex].szOldFile), szTemp)) &&
                SUCCEEDED(StringCchCopy(_IconData[nIndex].szNewFile, ARRAYSIZE(_IconData[nIndex].szNewFile), szTemp)))
            {
                _IconData[nIndex].iOldIndex = _IconData[nIndex].iNewIndex = 0;

                ExtractPlusColorIcon(szTemp, 0, &hIcon, 0, 0);
            }
        }

        if (hIcon)
        {
            DWORD dwResult = ImageList_AddIcon(_hIconList, hIcon);

            // ImageList_AddIcon() does not take ownership of the icon, so we need to free it.
            DestroyIcon(hIcon);

            if (-1 == dwResult)
            {
                ImageList_Destroy(_hIconList);
                _hIconList = NULL;
                return NULL;
            }
        }
    }

    // Make sure that all of the icons were added
    if (ImageList_GetImageCount(_hIconList) < ARRAYSIZE(c_aIconRegKeys))
    {
        ImageList_Destroy(_hIconList);
        _hIconList = NULL;
        return FALSE;
    }

    ListView_SetImageList(_hWndList, _hIconList, LVSIL_NORMAL);

    // Make sure the listview has WS_HSCROLL set on it.
    DWORD dwStyle = GetWindowLong(_hWndList, GWL_STYLE);
    SetWindowLong(_hWndList, GWL_STYLE, (dwStyle & (~WS_VSCROLL)) | WS_HSCROLL);

    // Finally, let's add the actual items to the control.  Fill in the LV_ITEM
    // structure for each of the items to add to the list.  The mask specifies
    // the the .pszText, .iImage, and .state members of the LV_ITEM structure are valid.
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    for(nIndex = 0; nIndex < ARRAYSIZE(c_aIconRegKeys); nIndex++ )
    {
        TCHAR szAppend[64];
        BOOL bRet = FALSE;

        if (IsEqualCLSID(*c_aIconRegKeys[nIndex].pclsid, CLSID_MyDocuments))
        {
            LPITEMIDLIST pidl;
            HRESULT hr = SHGetSpecialFolderLocation(_hWndList, CSIDL_PERSONAL, &pidl);

            // Treat "My Files" differently because we will probably customize the "My" at run time.
            if (SUCCEEDED(hr))
            {
                hr = SHGetNameAndFlags(pidl, SHGDN_INFOLDER, szTemp, ARRAYSIZE(szTemp), NULL);
                if (SUCCEEDED(hr))
                {
                    bRet = TRUE;
                }

                ILFree(pidl);
            }
        }
        else
        {
            bRet = IconGetRegNameString(c_aIconRegKeys[nIndex].pclsid, szTemp, ARRAYSIZE(szTemp));
        }

        // if the title string was in the registry, else we have to use the default in our resources
        if( (bRet) && (lstrlen(szTemp) > 0))
        {
            if( LoadString(HINST_THISDLL, c_aIconRegKeys[nIndex].iTitleResource, szAppend, ARRAYSIZE(szAppend)) != 0)
            {
                StringCchCat(szTemp, ARRAYSIZE(szTemp), szAppend); // display string, truncation ok
            }
        }
        else
        {
            LoadString(HINST_THISDLL, c_aIconRegKeys[nIndex].iDefaultTitleResource, szTemp, ARRAYSIZE(szTemp));
        }

        lvI.iItem = nIndex;
        lvI.iSubItem = 0;
        lvI.pszText = szTemp;
        lvI.iImage = nIndex;

        if(ListView_InsertItem(_hWndList, &lvI) == -1)
            return NULL;

    }
#ifdef JIGGLE_FIX
    // To fix long standing listview bug, we need to "jiggle" the listview
    // window size so that it will do a recompute and realize that we need a
    // scroll bar...
    GetWindowRect(_hWndList, &rc);
    MapWindowPoints( NULL, hWndParent, (LPPOINT)&rc, 2 );
    MoveWindow(_hWndList, rc.left, rc.top, rc.right - rc.left+1, rc.bottom - rc.top, FALSE );
    MoveWindow(_hWndList, rc.left, rc.top, rc.right - rc.left,   rc.bottom - rc.top, FALSE );
#endif
    // Set First item to selected
    ListView_SetItemState (_hWndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    // Get Selected item
    for (m_nIndex = 0; m_nIndex < ARRAYSIZE(c_aIconRegKeys); m_nIndex++)
    {
        if (ListView_GetItemState(_hWndList, m_nIndex, LVIS_SELECTED))
        {
            bEnable = TRUE;
            break;
        }
    }

    if (m_nIndex >= ARRAYSIZE(c_aIconRegKeys))
    {
        m_nIndex = -1;
    }

    EnableWindow(GetDlgItem(hWndParent, IDC_CHANGEICON2), bEnable);
    EnableWindow(GetDlgItem(hWndParent, IDC_ICONDEFAULT), bEnable);

    return _hWndList;
}

#define CUSTOMIZE_DLGPROC       1
#define CUSTOMIZE_WEB_DLGPROC   2

void CCompPropSheetPage::_OnInitDialog(HWND hwnd, INT iPage)
{
    if (FAILED(GetActiveDesktop(&g_pActiveDeskAdv)))
    {
        return;
    }

    switch (iPage)
    {
    case CUSTOMIZE_DLGPROC :
        {
            //
            // Read in the restrictions.
            //
            // Init the Icon UI
            // Create our list view and fill it with the system icons
            
            m_nIndex = 0;
            _CreateListView(hwnd);
            
            _OnInitDesktopOptionsUI(hwnd);

            //
            // Enable the Desktop Cleanup Wizard if we are on the right version 
            // of the OS and the DesktopCleanup NoRun policy is not set
            //
            //
            BOOL fCleanupEnabled = (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL)) && 
                                   !IsUserAGuest() && 
                                   !SHRestricted(REST_NODESKTOPCLEANUP);

            if (fCleanupEnabled)
            {
                if (BST_INDETERMINATE == g_iRunDesktopCleanup)
                {
                    DWORD dwData = 0;
                    DWORD dwType;
                    DWORD cch = sizeof (DWORD);

                    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_DESKTOP_CLEANUP,REGSTR_VAL_DONTRUN, 
                                                            &dwType, &dwData, &cch, FALSE, NULL, 0) &&
                        dwData != 0)
                    {
                        g_iRunDesktopCleanup = BST_UNCHECKED;
                    }
                    else
                    {
                        g_iRunDesktopCleanup = BST_CHECKED;                    
                    }
                }
                CheckDlgButton(hwnd, IDC_DESKCLNR_CHECK, g_iRunDesktopCleanup);
            }    
            else
            {
                ShowWindow(GetDlgItem(hwnd, IDC_COMP_CLEANUP_GROUP), FALSE);
                ShowWindow(GetDlgItem(hwnd, IDC_DESKCLNR_MOVEUNUSED), FALSE);
                ShowWindow(GetDlgItem(hwnd, IDC_DESKCLNR_CHECK), FALSE);
                ShowWindow(GetDlgItem(hwnd, IDC_DESKCLNR_RUNWIZARD), FALSE);
            }
        }
        break;
    case CUSTOMIZE_WEB_DLGPROC:
        {
            _fLaunchGallery = FALSE;
            _fAllowAdd = !SHRestricted(REST_NOADDDESKCOMP);
            _fAllowDel = !SHRestricted(REST_NODELDESKCOMP);
            _fAllowEdit = !SHRestricted(REST_NOEDITDESKCOMP);
            _fAllowClose = !SHRestricted(REST_NOCLOSEDESKCOMP);
            _fAllowReset = _fAllowAdd && _fAllowDel && _fAllowEdit &&
                            _fAllowClose && !SHRestricted(REST_NOCHANGINGWALLPAPER);
            _fForceAD = SHRestricted(REST_FORCEACTIVEDESKTOPON);


            _hwndLV = GetDlgItem(hwnd, IDC_COMP_LIST);

            EnableWindow(GetDlgItem(hwnd, IDC_COMP_NEW), _fAllowAdd);
            EnableWindow(GetDlgItem(hwnd, IDC_COMP_DELETE), _fAllowDel);
            EnableWindow(GetDlgItem(hwnd, IDC_COMP_PROPERTIES), _fAllowEdit);
            EnableWindow(GetDlgItem(hwnd, IDC_COMP_SYNCHRONIZE), _fAllowEdit);
            if (_fAllowClose)
            {
                ListView_SetExtendedListViewStyle(_hwndLV, LVS_EX_CHECKBOXES);
            }

            //
            // Add the single column that we want.
            //
            LV_COLUMN lvc;
            lvc.mask = LVCF_FMT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;
            ListView_InsertColumn(_hwndLV, 0, &lvc);

            
            //
            // Now make the UI match the g_pActiveDeskAdv object.
            //
            _SetUIFromDeskState(FALSE);

            //
            // Select the first item, if it exists.
            //
            int cComp;
            g_pActiveDeskAdv->GetDesktopItemCount(&cComp, 0);
            if (cComp)
            {
                ListView_SetItemState(_hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
            }

            _EnableControls(hwnd);
            
        }
        break;
    }

}

HRESULT CCompPropSheetPage::_OnInitDesktopOptionsUI(HWND hwnd)
{
    SHELLSTATE  ss = {0};
    SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!

    _iStartPanelOn = ss.fStartPanelOn ? 1 : 0; //Remember this in the class!

    // Check or uncheck the various icons based on whether they are on/off now.
    _UpdateDesktopIconsUI(hwnd);

    return S_OK;
}

HRESULT CCompPropSheetPage::_UpdateDesktopIconsUI(HWND hwnd)
{
    // Check or uncheck the various icons based on whether they are on/off now.
    for (int iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
    {
        // If HideDeskIcon[][] is true, uncheck the checkbox!  If it is FALSE, check the checkbox.
        CheckDlgButton(hwnd, c_aDeskIconId[iIndex].iDeskIconDlgItemId, !_afHideIcon[_iStartPanelOn][iIndex]);
        // If the policy is set, disable this CheckBox!
        EnableWindow(GetDlgItem(hwnd, c_aDeskIconId[iIndex].iDeskIconDlgItemId), !_afDisableCheckBox[iIndex]);
    }

    return S_OK;
}

void CCompPropSheetPage::_OnNotify(HWND hwnd, WPARAM wParam, LPNMHDR lpnm)
{
   switch (wParam)
   {
   case IDC_COMP_DESKTOPWEBPAGES_CHECK:
       _fLockDesktopItems = IsDlgButtonChecked(hwnd, IDC_COMP_DESKTOPWEBPAGES_CHECK);
       break;
   case IDC_DESKTOP_ICONS:
        {
            switch (lpnm->code)
            case LVN_ITEMCHANGED:
            {
                BOOL fSomethingSelected = FALSE;

                // Find out who's selected now
                for( m_nIndex = 0; m_nIndex < ARRAYSIZE(c_aIconRegKeys); m_nIndex++)
                {
                    if( ListView_GetItemState(_hWndList, m_nIndex, LVIS_SELECTED))
                    {
                        fSomethingSelected = TRUE;
                        break;
                    }
                }

                if (m_nIndex >= ARRAYSIZE(c_aIconRegKeys))
                {
                    m_nIndex = -1;
                }

                EnableWindow(GetDlgItem(hwnd, IDC_CHANGEICON2), fSomethingSelected);
                EnableWindow(GetDlgItem(hwnd, IDC_ICONDEFAULT), fSomethingSelected);
            }
        }
        break;
    case IDC_COMP_LIST:
        {
            switch (lpnm->code)
            {
                case LVN_ITEMCHANGED:
                NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)lpnm;

                if ((pnmlv->uChanged & LVIF_STATE) &&
                    ((pnmlv->uNewState ^ pnmlv->uOldState) & COMP_CHECKED))
                {
                    LV_ITEM lvi = {0};
                    lvi.iItem = pnmlv->iItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem(_hwndLV, &lvi);

                    COMPONENT comp;
                    comp.dwSize = sizeof(COMPONENT);
                    if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItemByID(lvi.lParam, &comp, 0)))
                    {
                        comp.fChecked = (pnmlv->uNewState & COMP_CHECKED) != 0;
                        g_pActiveDeskAdv->ModifyDesktopItem(&comp, COMP_ELEM_CHECKED);
                    }

                    if (_fInitialized)
                    {
                        g_fDirtyAdvanced = TRUE;
                    }
                }

                if ((pnmlv->uChanged & LVIF_STATE) &&
                    ((pnmlv->uNewState ^ pnmlv->uOldState) & LVIS_SELECTED))
                {
                    _EnableControls(hwnd); // toggle delete, properties
                }
                break;
            }
        }
        break;
    default:
        {
            switch (lpnm->code)
            {
            case PSN_APPLY:
                {
                    // store desktop flags
                    DWORD dwFlags, dwFlagsPrev;
                    dwFlags = dwFlagsPrev = GetDesktopFlags();
                    if (_fLockDesktopItems)
                    {
                        dwFlags |= COMPONENTS_LOCKED;
                    }
                    else
                    {
                        dwFlags &= ~COMPONENTS_LOCKED;
                    }

                    if (dwFlags != dwFlagsPrev)
                    {
                        g_fDirtyAdvanced = TRUE;
                        SetDesktopFlags(COMPONENTS_LOCKED, dwFlags);
                    }
                    _fCustomizeDesktopOK = TRUE;
                }
                break;
            }
        }
        break;
    }
}

//
// Returns TRUE if the string looks like a candidate for
// getting qualified as "file:".
//
BOOL LooksLikeFile(LPCTSTR psz)
{
    BOOL fRet = FALSE;

    if (psz[0] &&
        psz[1] &&
#ifndef UNICODE
        !IsDBCSLeadByte(psz[0]) &&
        !IsDBCSLeadByte(psz[1]) &&
#endif
        ((psz[0] == TEXT('\\')) ||
         (psz[1] == TEXT(':')) ||
         (psz[1] == TEXT('|'))))
    {
        fRet = TRUE;
    }

    return fRet;
}


#define GOTO_GALLERY    (-2)

BOOL_PTR CALLBACK AddComponentDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTSTR pszSource = (LPTSTR)GetWindowLongPtr(hdlg, DWLP_USER);
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pszSource = (LPTSTR)lParam;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)pszSource);

        SetDlgItemText(hdlg, IDC_CPROP_SOURCE, c_szNULL);
        EnableWindow(GetDlgItem(hdlg, IDOK), FALSE);
        SHAutoComplete(GetDlgItem(hdlg, IDC_CPROP_SOURCE), 0);
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_CPROP_BROWSE:
            {
                GetDlgItemText(hdlg, IDC_CPROP_SOURCE, szBuf, ARRAYSIZE(szBuf));
                if (!LooksLikeFile(szBuf))
                {
                    //
                    // Open the favorites folder when we aren't
                    // looking at a specific file.
                    //
                    SHGetSpecialFolderPath(hdlg, szBuf, CSIDL_FAVORITES, FALSE);

                    //
                    // Append a slash because GetFileName breaks the
                    // string into a file & dir, and we want to make sure
                    // the entire favorites path is treated as a dir.
                    //
                    PathAddBackslash(szBuf);
                }
                else
                {
                    PathRemoveArgs(szBuf);
                }

                DWORD   adwFlags[] = {   
                                        GFN_ALL,            
                                        GFN_PICTURE,       
                                        (GFN_LOCALHTM | GFN_LOCALMHTML | GFN_CDF | GFN_URL), 
                                        0
                                    };
                int     aiTypes[]  = {   
                                        IDS_COMP_FILETYPES, 
                                        IDS_ALL_PICTURES,  
                                        IDS_ALL_HTML, 
                                        0
                                    };

                if (GetFileName(hdlg, szBuf, ARRAYSIZE(szBuf), aiTypes, adwFlags) &&
                    CheckAndResolveLocalUrlFile(szBuf, ARRAYSIZE(szBuf)))
                {
                    SetDlgItemText(hdlg, IDC_CPROP_SOURCE, szBuf);
                }
            }
            break;

        case IDC_CPROP_SOURCE:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                EnableWindow(GetDlgItem(hdlg, IDOK), GetWindowTextLength(GetDlgItem(hdlg, IDC_CPROP_SOURCE)) > 0);
            }
            break;

        case IDOK:
            GetDlgItemText(hdlg, IDC_CPROP_SOURCE, pszSource, INTERNET_MAX_URL_LENGTH);
            ASSERT(pszSource[0]);
            if (ValidateFileName(hdlg, pszSource, IDS_COMP_TYPE1) && 
                CheckAndResolveLocalUrlFile(pszSource, INTERNET_MAX_URL_LENGTH))
            {
                //
                // Qualify non file-protocol strings.
                //
                if (!LooksLikeFile(pszSource))
                {
                    DWORD cchSize = INTERNET_MAX_URL_LENGTH;

                    PathRemoveBlanks(pszSource);
                    ParseURLFromOutsideSource(pszSource, pszSource, &cchSize, NULL);
                }

                EndDialog(hdlg, 0);
            }
            break;

        case IDCANCEL:
            EndDialog(hdlg, -1);
            break;

        case IDC_GOTO_GALLERY:
            EndDialog(hdlg, GOTO_GALLERY);
            break;
        }
        break;
    }

    return FALSE;
}

BOOL IsUrlPicture(LPCTSTR pszUrl)
{
    BOOL fRet = FALSE;

    if(pszUrl[0] == TEXT('\0'))
    {
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszUrl);

        if ((lstrcmpi(pszExt, TEXT(".BMP"))  == 0) ||
            (StrCmpIC(pszExt, TEXT(".GIF"))  == 0) ||  // 368690: Strange, but we must compare 'i' in both caps and lower case.
            (lstrcmpi(pszExt, TEXT(".JPG"))  == 0) ||
            (lstrcmpi(pszExt, TEXT(".JPE"))  == 0) ||
            (lstrcmpi(pszExt, TEXT(".JPEG")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".DIB"))  == 0) ||
            (lstrcmpi(pszExt, TEXT(".PNG"))  == 0))
        {
            fRet = TRUE;
        }
    }

    return(fRet);
}

int GetComponentType(LPCTSTR pszUrl)
{
    return IsUrlPicture(pszUrl) ? COMP_TYPE_PICTURE : COMP_TYPE_WEBSITE;
}

void CreateComponent(COMPONENTA *pcomp, LPCTSTR pszUrl)
{
    pcomp->dwSize = sizeof(*pcomp);
    pcomp->dwID = (DWORD)-1;
    pcomp->iComponentType = GetComponentType(pszUrl);
    pcomp->fChecked = TRUE;
    pcomp->fDirty = FALSE;
    pcomp->fNoScroll = FALSE;
    pcomp->cpPos.dwSize = sizeof(pcomp->cpPos);
    pcomp->cpPos.iLeft = COMPONENT_DEFAULT_LEFT;
    pcomp->cpPos.iTop = COMPONENT_DEFAULT_TOP;
    pcomp->cpPos.dwWidth = COMPONENT_DEFAULT_WIDTH;
    pcomp->cpPos.dwHeight = COMPONENT_DEFAULT_HEIGHT;
    pcomp->cpPos.izIndex = COMPONENT_TOP;
    pcomp->cpPos.fCanResize = TRUE;
    pcomp->cpPos.fCanResizeX = pcomp->cpPos.fCanResizeY = TRUE;
    pcomp->cpPos.iPreferredLeftPercent = pcomp->cpPos.iPreferredTopPercent = 0;
    
    if (FAILED(StringCchCopy(pcomp->szSource, ARRAYSIZE(pcomp->szSource), pszUrl)))
    {
        pcomp->szSource[0] = TEXT('\0');
    }
    
    if (FAILED(StringCchCopy(pcomp->szSubscribedURL, ARRAYSIZE(pcomp->szSubscribedURL), pszUrl)))
    {
        pcomp->szSubscribedURL[0] = TEXT('\0');
    }

    pcomp->szFriendlyName[0] = TEXT('\0');
}

BOOL FindComponent(IN LPCTSTR pszUrl, IN IActiveDesktop * pActiveDesktop)
{
    BOOL    fRet = FALSE;
    int     i, ccomp;
    LPWSTR  pwszUrl;

#ifndef UNICODE
    WCHAR   wszUrl[INTERNET_MAX_URL_LENGTH];

    SHAnsiToUnicode(pszUrl, wszUrl, ARRAYSIZE(wszUrl));
    pwszUrl = wszUrl;
#else
    pwszUrl = (LPWSTR)pszUrl;
#endif

    if (pActiveDesktop)
    {
        pActiveDesktop->GetDesktopItemCount(&ccomp, 0);
        for (i=0; i<ccomp; i++)
        {
            COMPONENT comp;
            comp.dwSize = sizeof(COMPONENT);
            if (SUCCEEDED(pActiveDesktop->GetDesktopItem(i, &comp, 0)))
            {
                if (StrCmpIW(pwszUrl, comp.wszSource) == 0)
                {
                    fRet = TRUE;
                    break;
                }
            }
        }
    }

    return fRet;
}

void EmptyListview(IActiveDesktop * pActiveDesktop, HWND hwndLV)
{
    //
    // Delete all the old components.
    //
    int cComp;
    pActiveDesktop->GetDesktopItemCount(&cComp, 0);
    int i;
    COMPONENT comp;
    comp.dwSize = sizeof(COMPONENT);
    for (i=0; i<cComp; i++)
    {
        ListView_DeleteItem(hwndLV, 0);
    }
}

void CCompPropSheetPage::_SelectComponent(LPWSTR pwszUrl)
{
    //
    // Look for the component with our URL.
    //
    int cComp;
    COMPONENT comp = { sizeof(comp) };
    g_pActiveDeskAdv->GetDesktopItemCount(&cComp, 0);
    for (int i=0; i<cComp; i++)
    {
        if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItem(i, &comp, 0)))
        {
            if (StrCmpW(pwszUrl, comp.wszSource) == 0)
            {
                break;
            }
        }
    }

    //
    // Find the matching listview entry (search for dwID).
    //
    if (i != cComp)
    {
        int nItems = ListView_GetItemCount(_hwndLV);

        for (i=0; i<nItems; i++)
        {
            LV_ITEM lvi = {0};

            lvi.iItem = i;
            lvi.mask = LVIF_PARAM;
            ListView_GetItem(_hwndLV, &lvi);
            if (lvi.lParam == (LPARAM)comp.dwID)
            {
                //
                // Found it, select it and exit.
                //
                ListView_SetItemState(_hwndLV, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                ListView_EnsureVisible(_hwndLV, i, FALSE);
                break;
            }
        }
    }
}

INT_PTR NewComponent(HWND hwndOwner, IActiveDesktop * pad, BOOL fDeferGallery, COMPONENT * pcomp)
{
    HRESULT hrInit = SHCoInitialize();

    TCHAR szSource[INTERNET_MAX_URL_LENGTH];
    COMPONENT comp;
    INT_PTR iChoice = DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_ADDCOMPONENT), hwndOwner, AddComponentDlgProc, (LPARAM)szSource);

    if (!pcomp)
    {
        pcomp = &comp;
        pcomp->dwSize = sizeof(comp);
        pcomp->dwCurItemState = IS_NORMAL;
    }
    
    if (iChoice == GOTO_GALLERY)   // the user wants to launch the gallery
    {
        if (!fDeferGallery)
        {
            WCHAR szGalleryUrl[INTERNET_MAX_URL_LENGTH];
    
            if (SUCCEEDED(URLSubLoadString(HINST_THISDLL, IDS_VISIT_URL, szGalleryUrl, ARRAYSIZE(szGalleryUrl), URLSUB_ALL)))
            {
                NavToUrlUsingIEW(szGalleryUrl, TRUE);
            }
        }
    }
    else if (iChoice >= 0)
    {   // the user has entered a URL address
        WCHAR szSourceW[INTERNET_MAX_URL_LENGTH];
        
        SHTCharToUnicode(szSource, szSourceW, ARRAYSIZE(szSourceW));

        if (!SUCCEEDED(pad->AddUrl(hwndOwner, szSourceW, pcomp, 0)))
            iChoice = -1;
    }

    SHCoUninitialize(hrInit);

    return iChoice;
}

void CCompPropSheetPage::_NewComponent(HWND hwnd)
{
    COMPONENT comp;
    comp.dwSize = sizeof(comp);
    comp.dwCurItemState = IS_NORMAL;
    INT_PTR iChoice = NewComponent(hwnd, g_pActiveDeskAdv, TRUE, &comp);
    
    if (iChoice == GOTO_GALLERY)   // the user wants to launch the gallery
    {
        _fLaunchGallery = TRUE;
        g_fLaunchGallery = TRUE;
        g_fDirtyAdvanced = TRUE;
        PropSheet_PressButton(GetParent(hwnd), PSBTN_OK);
    }
    else
    {
        if (iChoice >= 0) // the user has entered a URL address
        {
            // Add component to listview.
            //
            // Need to reload the entire listview so that it is shown in
            // the correct zorder.
            _SetUIFromDeskState(TRUE);

            // Select the newly added component.
            _SelectComponent(comp.wszSource);
        }

        g_fDirtyAdvanced = TRUE;
    }
}

void CCompPropSheetPage::_EditComponent(HWND hwnd)
{
    int iIndex = ListView_GetNextItem(_hwndLV, -1, LVNI_SELECTED);
    if (iIndex > -1)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iIndex;
        ListView_GetItem(_hwndLV, &lvi);

        COMPONENT comp = { sizeof(comp) };
        if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItemByID(lvi.lParam, &comp, 0)))
        {
            LPTSTR  pszSubscribedURL;
#ifndef UNICODE
            TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];

            SHUnicodeToAnsi(comp.wszSubscribedURL, szSubscribedURL, ARRAYSIZE(szSubscribedURL));
            pszSubscribedURL = szSubscribedURL;
#else
            pszSubscribedURL = (LPTSTR)comp.wszSubscribedURL;
#endif
            if (SUCCEEDED(ShowSubscriptionProperties(pszSubscribedURL, hwnd)))
            {
                g_fDirtyAdvanced = TRUE;
            }
        }
    }
}

void CCompPropSheetPage::_DeleteComponent(HWND hwnd)
{
    int iIndex = ListView_GetNextItem(_hwndLV, -1, LVNI_ALL | LVNI_SELECTED);
    if (iIndex > -1)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iIndex;
        ListView_GetItem(_hwndLV, &lvi);

        COMPONENT comp;
        comp.dwSize = sizeof(COMPONENT);
        if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItemByID(lvi.lParam, &comp, 0)))
        {
            TCHAR szMsg[1024];
            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_COMP_CONFIRMDEL, szMsg, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_TITLE, szTitle, ARRAYSIZE(szTitle));

            if (MessageBox(hwnd, szMsg, szTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
            {
                g_pActiveDeskAdv->RemoveDesktopItem(&comp, 0);

                ListView_DeleteItem(_hwndLV, iIndex);
                int cComp = ListView_GetItemCount(_hwndLV);
                if (cComp == 0)
                {
                    SendMessage(hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDC_COMP_NEW), TRUE);
                }
                else
                {
                    int iSel = (iIndex > cComp - 1 ? cComp - 1 : iIndex);

                    ListView_SetItemState(_hwndLV, iSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                }

                LPTSTR  pszSubscribedURL;
#ifndef UNICODE
                TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];

                SHUnicodeToAnsi(comp.wszSubscribedURL, szSubscribedURL, ARRAYSIZE(szSubscribedURL));
                pszSubscribedURL = szSubscribedURL;
#else
                pszSubscribedURL = comp.wszSubscribedURL;
#endif
                DeleteFromSubscriptionList(pszSubscribedURL);
            }

            g_fDirtyAdvanced = TRUE;
        }
    }
}

//
// Desktop Cleanup stuff 
//

STDAPI ApplyDesktopCleanupSettings()
{
    // set the registry value
    DWORD dwData = (BST_CHECKED == g_iRunDesktopCleanup) ? 0 : 1;
    SHRegSetUSValue(REGSTR_DESKTOP_CLEANUP, REGSTR_VAL_DONTRUN, 
                    REG_DWORD, &dwData, sizeof(dwData), SHREGSET_FORCE_HKCU);
    return S_OK;                    
}

void CCompPropSheetPage::_DesktopCleaner(HWND hwnd)
{
    TCHAR szRunDLL[MAX_PATH];
    if (GetSystemDirectory(szRunDLL, ARRAYSIZE(szRunDLL)) &&
        PathAppend(szRunDLL, TEXT("rundll32.exe")))
    {
        SHELLEXECUTEINFO sei = {0};
        sei.cbSize = sizeof(sei);
        sei.hwnd = hwnd;
        sei.lpFile = szRunDLL;
        sei.lpParameters = TEXT("fldrclnr.dll,Wizard_RunDLL all");
        sei.nShow = SW_SHOWNORMAL;
        ShellExecuteEx(&sei);
    }
}


void CCompPropSheetPage::_SynchronizeAllComponents(IActiveDesktop *pActDesktop)
{
    IADesktopP2* padp2;
    if (SUCCEEDED(pActDesktop->QueryInterface(IID_PPV_ARG(IADesktopP2, &padp2))))
    {
        padp2->UpdateAllDesktopSubscriptions();
        padp2->Release();
    }
}


void CCompPropSheetPage::_OnCommand(HWND hwnd, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL fFocusToList = FALSE;

    switch (wID)
    {
    case IDC_COMP_NEW:
        _NewComponent(hwnd);

        //  98/08/19 vtan #152418: Set the default border to "New". This
        //  will be changed when the focus is changed to the component list
        //  but this allows the dialog handling code to draw the default
        //  border correctly.

        (BOOL)SendMessage(hwnd, WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(GetDlgItem(hwnd, IDC_COMP_NEW)), static_cast<BOOL>(TRUE));
        fFocusToList = TRUE;
        break;

    case IDC_COMP_PROPERTIES:
        _EditComponent(hwnd);

        //  98/08/19 vtan #152418: Same as above.
        (BOOL)SendMessage(hwnd, WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(GetDlgItem(hwnd, IDC_COMP_PROPERTIES)), static_cast<BOOL>(TRUE));
        fFocusToList = TRUE;
        break;

    case IDC_COMP_DELETE:
        _DeleteComponent(hwnd);

        //  98/08/19 vtan #152418: Same as above.

        (BOOL)SendMessage(hwnd, WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(GetDlgItem(hwnd, IDC_COMP_DELETE)), static_cast<BOOL>(TRUE));
        fFocusToList = TRUE;
        break;

    case IDC_DESKCLNR_RUNWIZARD:
        _DesktopCleaner(hwnd);
        break;    
    
    case IDC_DESKCLNR_CHECK:
        // if the button is clicked, update the global
        {
            int iButState = IsDlgButtonChecked(hwnd, IDC_DESKCLNR_CHECK);
            if (iButState != g_iRunDesktopCleanup)
            {
                ASSERT(iButState != BST_INDETERMINATE);
                g_iRunDesktopCleanup = iButState;
                g_fDirtyAdvanced = TRUE;
            }
        }
        break;

    case IDC_COMP_SYNCHRONIZE:
        _SynchronizeAllComponents(g_pActiveDeskAdv);
        break;

    case IDC_CHANGEICON2:
    if (-1 != m_nIndex)
    {
        WCHAR szExp[MAX_PATH];
        INT i = _IconData[m_nIndex].iOldIndex;

        ExpandEnvironmentStringsW(_IconData[m_nIndex].szOldFile, szExp, ARRAYSIZE(szExp));

        if (PickIconDlg(hwnd, szExp, ARRAYSIZE(szExp), &i) == TRUE)
        {
            HICON hIcon;

            if (SUCCEEDED(StringCchCopy(_IconData[m_nIndex].szNewFile, ARRAYSIZE(_IconData[m_nIndex].szNewFile), szExp)))
            {
                _IconData[m_nIndex].iNewIndex = i;
                if (SUCCEEDED(ExtractPlusColorIcon(_IconData[m_nIndex].szNewFile, _IconData[m_nIndex].iNewIndex, &hIcon, 0, 0)))
                {
                    ImageList_ReplaceIcon(_hIconList, m_nIndex, hIcon);
                    ListView_RedrawItems(_hWndList, m_nIndex, m_nIndex);
                }
            }
        }
        SetFocus(_hWndList);
    }
    break;

    case IDC_ICONDEFAULT:
    if (-1 != m_nIndex)
    {
        TCHAR szPath[MAX_PATH];
        HICON hIcon;

        if (!ExpandEnvironmentStrings(c_aIconRegKeys[m_nIndex].pszDefault, szPath, ARRAYSIZE(szPath)) ||
            FAILED(StringCchCopy(szPath, ARRAYSIZE(szPath), c_aIconRegKeys[m_nIndex].pszDefault)))
        {
            break;
        }

        if (SUCCEEDED(StringCchCopy(_IconData[m_nIndex].szNewFile, ARRAYSIZE(_IconData[m_nIndex].szNewFile), szPath)))
        {
            _IconData[m_nIndex].iNewIndex = c_aIconRegKeys[m_nIndex].nDefaultIndex;

            ExtractPlusColorIcon(_IconData[m_nIndex].szNewFile, _IconData[m_nIndex].iNewIndex, &hIcon, 0, 0);

            ImageList_ReplaceIcon(_hIconList, m_nIndex, hIcon);
            ListView_RedrawItems(_hWndList, m_nIndex, m_nIndex);
            SetFocus(_hWndList);
        }
    }
    break;

    case IDC_DESKTOP_ICON_MYDOCS:
    case IDC_DESKTOP_ICON_MYCOMP:
    case IDC_DESKTOP_ICON_MYNET:
    case IDC_DESKTOP_ICON_IE:
    {
        //Get the current button state and save it.
        BOOL fOriginalBtnState = IsDlgButtonChecked(hwnd, wID);
        //Toggle the button from checked to unchecked (or vice-versa).
        CheckDlgButton(hwnd, wID, (fOriginalBtnState ? BST_UNCHECKED : BST_CHECKED));
        
        for(int iIndex = 0; iIndex < NUM_DESKICONS; iIndex++)
        {
            if(wID == c_aDeskIconId[iIndex].iDeskIconDlgItemId)
            {
                // Note#1: The inverse logic is used below. If the originally button is checked, 
                // it means that now it is unchecked, which means that icon should now be hidden;
                // (i.e) the HideDeskIcon[][] should be set to TRUE.
                //
                // Note#2: When the end-user toggles these, we want to set the same setting for
                // both the modes now!
                _afHideIcon[0][iIndex] = _afHideIcon[1][iIndex] = fOriginalBtnState;
            }
        }
    }
    break;
            
    }


    //Set the focus back to the components list, if necessary
    if (fFocusToList)
    {
        int iIndex = ListView_GetNextItem(_hwndLV, -1, LVNI_SELECTED);
        if (iIndex > -1)
        {
            SetFocus(GetDlgItem(hwnd, IDC_COMP_LIST));
        }
    }
}

void CCompPropSheetPage::_OnDestroy(INT iPage)
{
    if (CUSTOMIZE_DLGPROC == iPage)
    {
        ReleaseActiveDesktop(&g_pActiveDeskAdv);

        if (_fLaunchGallery)
        {
            WCHAR szGalleryUrl[INTERNET_MAX_URL_LENGTH];

            if (SUCCEEDED(URLSubLoadString(HINST_THISDLL, IDS_VISIT_URL, szGalleryUrl, ARRAYSIZE(szGalleryUrl), URLSUB_ALL)))
            {
                NavToUrlUsingIEW(szGalleryUrl, TRUE);
            }
        }
    }
}

void CCompPropSheetPage::_OnGetCurSel(int *piIndex)
{
    if (_hwndLV)
    {
        *piIndex = ListView_GetNextItem(_hwndLV, -1, LVNI_ALL | LVNI_SELECTED);
    }
    else
    {
        *piIndex = -1;
    }
}


INT_PTR CCompPropSheetPage::_CustomizeDlgProcHelper(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam, INT iPage)
{
    CCompPropSheetPage * pThis; 

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CCompPropSheetPage *) ((PROPSHEETPAGE*)lParam)->lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM) pThis);
        }
    }
    else
    {
        pThis = (CCompPropSheetPage *)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    if (pThis)
        return pThis->_CustomizeDlgProc(hDlg, wMsg, wParam, lParam, iPage);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}

INT_PTR CALLBACK CCompPropSheetPage::CustomizeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    return _CustomizeDlgProcHelper(hDlg, wMsg, wParam, lParam, CUSTOMIZE_DLGPROC);
}

INT_PTR CALLBACK CCompPropSheetPage::WebDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    return _CustomizeDlgProcHelper(hDlg, wMsg, wParam, lParam, CUSTOMIZE_WEB_DLGPROC);
}


BOOL_PTR CCompPropSheetPage::_CustomizeDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, INT iPage)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDialog(hdlg, iPage);        
        break;

    case WM_NOTIFY:
        _OnNotify(hdlg, wParam, (LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        _OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        break;

    case WM_SETTINGCHANGE:
        //Check if this is a shell StateChange?
        if(lstrcmpi((LPTSTR)(lParam), TEXT("ShellState")) == 0)
        {
            //Check if the StartPanel on/off state has changed.
            SHELLSTATE  ss = {0};
            SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!

            //See if the StartPanel on/off state has changed
            if(BOOLIFY(ss.fStartPanelOn) != BOOLIFY((BOOL)_iStartPanelOn))
            {
                _iStartPanelOn = (ss.fStartPanelOn ? 1 : 0); //Save the new state.
                //Refresh the UI based on the new state.
                _UpdateDesktopIconsUI(hdlg);
            }
        }
        
        // Intentional fallthrough....
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        SHPropagateMessage(hdlg, uMsg, wParam, lParam, TRUE);
        break;

    case WM_DESTROY:
        _OnDestroy(iPage);
        break;

    case WM_COMP_GETCURSEL:
        _OnGetCurSel((int *)lParam);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_DESKTOPITEMS, HELP_WM_HELP, (ULONG_PTR)(void *)aDesktopItemsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, SZ_HELPFILE_DESKTOPITEMS, HELP_CONTEXTMENU, (ULONG_PTR)(void *) aDesktopItemsHelpIDs);
        break;

    }

    return FALSE;
}

HRESULT CCompPropSheetPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = g_fDirtyAdvanced;

        if (!*pIsDirty)
        {
            // Check if any of the icons have changed.
            for (int nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
            {
                if ((_IconData[nIndex].iNewIndex != _IconData[nIndex].iOldIndex) ||
                    (StrCmpI(_IconData[nIndex].szNewFile, _IconData[nIndex].szOldFile)))
                {
                    *pIsDirty = TRUE;
                    break;
                }
            }
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CCompPropSheetPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pAdvPage, IN BOOL * pfEnableApply)
{
    HRESULT hr = S_OK;

    // Load State Into Advanced Dialog 
    *pfEnableApply = FALSE;
    GetActiveDesktop(&g_pActiveDesk);
    GetActiveDesktop(&g_pActiveDeskAdv);
    ActiveDesktop_CopyState(g_pActiveDesk, g_pActiveDeskAdv);
    hr = _LoadIconState(pAdvPage);

    if (SUCCEEDED(hr))
    {
        hr = _LoadDeskIconState(pAdvPage);

        if (SUCCEEDED(hr))
        {
            int iNumberOfPages = 2;

            PROPSHEETPAGE psp = {0};
            psp.dwSize = sizeof(psp);
            psp.hInstance = HINST_THISDLL;
            psp.dwFlags = PSP_DEFAULT;
            psp.lParam = (LPARAM) this;

            psp.pszTemplate = MAKEINTRESOURCE(IDD_CUSTOMIZE);
            psp.pfnDlgProc = CCompPropSheetPage::CustomizeDlgProc;

            HPROPSHEETPAGE rghpsp[2];
            
            rghpsp[0] = CreatePropertySheetPage(&psp);

            // Any of the following policies can disable the Web tab.
            // 1. If no active desktop policy set, don't put up the property page
            // 2. If policy is set to lock down active desktop, don't put up the
            //    property page
            // 3. If policy is set to not allow components, don't put up the
            //    property page
            if (((!SHRestricted(REST_FORCEACTIVEDESKTOPON)) && PolicyNoActiveDesktop())  ||      // 1.
                (SHRestricted(REST_NOACTIVEDESKTOPCHANGES)) ||  // 2.
                (SHRestricted(REST_NODESKCOMP)) ||              // 3.
                (SHRestricted(REST_CLASSICSHELL)))              // 4
            {
                // It's restricted, so don't add Web page.
                iNumberOfPages = 1; //"General" page is the only page in this property sheet!
            }
            else
            {
                // No active desktop restriction! Go ahead and add the "Web" tab!
                psp.pszTemplate = MAKEINTRESOURCE(IDD_CUSTOMIZE_WEB);
                psp.pfnDlgProc = CCompPropSheetPage::WebDlgProc;

                rghpsp[1] = CreatePropertySheetPage(&psp);

                iNumberOfPages = 2; //"General" and "Web" are the two pages in this Property sheet!
            }

            PROPSHEETHEADER psh = {0};
            psh.dwSize = sizeof(psh);
            psh.dwFlags = PSH_NOAPPLYNOW;
            psh.hwndParent = hwndParent;
            psh.hInstance = HINST_THISDLL;

            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_PROPSHEET_TITLE, szTitle, ARRAYSIZE(szTitle));

            psh.pszCaption = szTitle;
            psh.nPages = iNumberOfPages;
            psh.phpage = rghpsp;

            _fCustomizeDesktopOK = FALSE;

            PropertySheet(&psh);

            if (_fCustomizeDesktopOK)
            {
                // The user clicked OK, so merge modified state back into base dialog
                _IsDirty(pfEnableApply);

                // The user clicked Okay in the dialog so merge the dirty state from the
                // advanced dialog into the base dialog.
                MergeState();
                _MergeIconState(pAdvPage);
                _MergeDeskIconState(pAdvPage);
            }

            // If the user selected to open the component gallery in Web->New, then
            // we want to close both the Advanced dlg and the base Dlg with "OK".
            // This way we persist the changes they have made so far, and then the web
            // page will allow them to add more.
            if (TRUE == g_fLaunchGallery)
            {
                IThemeUIPages * pThemeUIPages;
                HWND hwndBasePropDlg = GetParent(hwndParent);

                PropSheet_PressButton(hwndBasePropDlg, PSBTN_OK);
                hr = IUnknown_GetSite(pAdvPage, IID_PPV_ARG(IThemeUIPages, &pThemeUIPages));
                if (SUCCEEDED(hr))
                {
                    // We now want to tell the base dialog to close too.
                    hr = pThemeUIPages->ApplyPressed(TUIAP_CLOSE_DIALOG);
                    pThemeUIPages->Release();
                }
            }
            
        }
    }

    ReleaseActiveDesktop(&g_pActiveDesk);
    ReleaseActiveDesktop(&g_pActiveDeskAdv);

    return hr;
}

ULONG CCompPropSheetPage::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CCompPropSheetPage::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


HRESULT CCompPropSheetPage::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CCompPropSheetPage, IObjectWithSite),
        QITABENT(CCompPropSheetPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

CCompPropSheetPage::CCompPropSheetPage() : _iPreviousSelection(-1), _cRef(1)
{
    _fInitialized = FALSE;    
    _fLaunchGallery = FALSE;
    _punkSite = NULL;
    _hWndList = NULL;
    _hIconList = NULL;

    _fLockDesktopItems = GetDesktopFlags() & COMPONENTS_LOCKED;

    // We don't need to do any work here but it's a good cue to
    // reset our state because the Advance dialog is opening.
    g_fDirtyAdvanced = FALSE;   // The advanced page isn't dirty yet.
    g_fLaunchGallery = FALSE;   // Will be true if they launch the gallery.


    RegisterCompPreviewClass();
}

CCompPropSheetPage::~CCompPropSheetPage()
{
}


//
// The following function updates the registry such that the given icon can be hidden or shown
// on the desktop.
// This function is called from RegFldr.cpp to selectively hide RegItems like MyComputer,
// RecycleBin, MyDocuments and MyNetplaces Icons.
//
HRESULT ShowHideIconOnlyOnDesktop(const CLSID *pclsid, int StartIndex, int EndIndex, BOOL fHide)
{
    HRESULT hr = S_OK;

    int iStartPanel;
    TCHAR   szRegPath[MAX_PATH];
    TCHAR szValueName[MAX_GUID_STRING_LEN];
 
    SHStringFromGUID(*pclsid, szValueName, ARRAYSIZE(szValueName));
        
    // i = 0 is for StartPanel off and i = 1 is for StartPanel ON!    
    for(iStartPanel = StartIndex; SUCCEEDED(hr) && iStartPanel <= EndIndex; iStartPanel++)
    {
        //Get the proper registry path based on if StartPanel is ON/OFF
        hr = StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, c_apstrRegLocation[iStartPanel]);
        if (SUCCEEDED(hr))
        {
            //Write the setting to the registry!
            DWORD dwHide = (DWORD)fHide;
        
            LONG lRet = SHRegSetUSValue(szRegPath, szValueName, REG_DWORD, &dwHide, sizeof(dwHide), SHREGSET_FORCE_HKCU);
            hr = HRESULT_FROM_WIN32(lRet);
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskcls.h ===
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dcompp.h ===
#ifndef _DCOMPP_H_
#define _DCOMPP_H_

#define WM_UPDATEBITMAP  (WM_USER+1)

BOOL RegisterCompPreviewClass();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskcls.cpp ===
#include "stdafx.h"
#include <LMCONS.H>     // 97/07/22 vtan: for UNLEN

#pragma hdrstop

BOOL   OnUpgradeDisableActiveDesktopFeatures();

void CreateMyCurHomeComponent(BOOL fChecked)
{
    // If there is a policy to prevent adding desktop components, then we should not attempt to add.
    // Otherwise, a new user gets an error message when they login for the first time.
    // Bug #21300 -- Fixed on 2/28/2001 -- Sankar
    if (SHRestricted(REST_NOADDDESKCOMP))
        return;
        
    //Add the base components!
    TCHAR szBuf[MAX_PATH];
    ISubscriptionMgr * psm;

    // Add a component that points to "about:home"
    LoadString(HINST_THISDLL, IDS_MY_CURRENT_HOMEPAGE, szBuf, ARRAYSIZE(szBuf));

//  98/07/14 vtan #176721: Changed the following to pass default component
//  positions to AddRemoveDesktopComponentNoUI so that the restored position may
//  be set to the default component position.

    AddRemoveDesktopComponentNoUI(TRUE, AD_APPLY_SAVE, MY_HOMEPAGE_SOURCE, szBuf, COMP_TYPE_WEBSITE, COMPONENT_DEFAULT_LEFT, COMPONENT_DEFAULT_TOP, COMPONENT_DEFAULT_WIDTH, COMPONENT_DEFAULT_HEIGHT, fChecked, IS_SPLIT);
    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
    {
        WCHAR wszName[MAX_PATH];
        //We need to zero init this structure except the cbSize field.
        SUBSCRIPTIONINFO siDefault = {sizeof(SUBSCRIPTIONINFO)};

        SHTCharToUnicode(szBuf, wszName, ARRAYSIZE(wszName));

        //This field is already initialized above.
        //siDefault.cbSize = sizeof(siDefault);
        psm->CreateSubscription(NULL, MY_HOMEPAGE_SOURCEW, wszName, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &siDefault);
        psm->Release();
    }
}

STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg)
{
    HKEY    hKey;
    DWORD   userNameSize;
    TCHAR   szDeskcomp[MAX_PATH];
    TCHAR   userName[UNLEN];

//  98/07/22 vtan #202707: Problem: This code gets called for the first time when NT
//  runs. This sets up the default user profile. Anything that is added to this profile
//  is propagated to any current user when upgrading from NT 4.0 to NT 5.0. This
//  causes the DeskHtmlVersion, DeskHtmlMinorVersion and Component\0 to be replaced
//  with the default component. By replacing the version registry entries any old
//  components will not get correctly upgraded by the component reading code. It also
//  destroys the first component.

//  Solution: Prevent a default component being added at setup time by checking the
//  logged on user is "SYSTEM". If the user is anybody other than system then perform
//  the update or addition of the default component.

    userNameSize = ARRAYSIZE(userName);
    if ((GetUserName(userName, &userNameSize) != 0) && (lstrcmp(userName, TEXT("SYSTEM")) == 0))
        return(S_OK);           // an ungracious exit right here and now!

    if(bReg)
    {
        DWORD dwDisposition;
        DWORD dwDeskHtmlVersion = 0;
        DWORD dwDeskHtmlMinorVersion = 0;
        DWORD dwType;

        GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 
                                            0, NULL, 0, KEY_CREATE_SUB_KEY|KEY_QUERY_VALUE, NULL, &hKey, 
                                            &dwDisposition))
        {
            //Get the version stamp from the registry
            if(dwDisposition == REG_OPENED_EXISTING_KEY)
            {
                DWORD dwDataLength = sizeof(DWORD);
                SHQueryValueEx(hKey, REG_VAL_COMP_VERSION, NULL, &dwType, (LPBYTE)(&dwDeskHtmlVersion), &dwDataLength);
                SHQueryValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, NULL, &dwType, (LPBYTE)(&dwDeskHtmlMinorVersion), &dwDataLength);
            }

            //We need to close this key before we delete it
            RegCloseKey(hKey);

            // If this branch is already there, don't set default comp.
            // Note: The differences between IE4_DESKHTML_VERSION and CUR_DESKHTML_VERSION are 
            // automatically taken care of when we read the components. So, we need to check only
            // for very old versions here.
            if (dwDeskHtmlVersion < IE4_DESKHTML_VERSION)
            {
                //Delete the existing components.
                SHDeleteKey(HKEY_CURRENT_USER, szDeskcomp);

                // Create the default active desktop configuration
                if(RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, NULL, 0,
                            (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    //We need an initial state
                    DWORD dw;

                    dw = CUR_DESKHTML_VERSION;
                    RegSetValueEx(hKey, REG_VAL_COMP_VERSION, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

                    dw = CUR_DESKHTML_MINOR_VERSION;
                    RegSetValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
                    
                    dw = COMPSETTING_ENABLE;
                    RegSetValueEx(hKey, REG_VAL_COMP_SETTINGS, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

                    //Add the home page component
                    CreateMyCurHomeComponent(FALSE); //For millennium we want to disable the component.

                    RegCloseKey(hKey);
                }

                // Create the default active desktop safemode configuration
                if(RegCreateKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_SAFEMODE,
                        0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    DWORD dwDisposition;
                    HKEY hKey2;

                    if(RegCreateKeyEx(hKey, REG_DESKCOMP_GENERAL_SUFFIX, 0, NULL, 0,
                                (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey2, &dwDisposition) == ERROR_SUCCESS)
                    {
                        TCHAR szSafeMode[MAX_PATH];
                        GetWindowsDirectory(szSafeMode, ARRAYSIZE(szSafeMode));

                        HRESULT hr = StringCchCat(szSafeMode, ARRAYSIZE(szSafeMode), DESKTOPHTML_DEFAULT_SAFEMODE);
                        if (SUCCEEDED(hr))
                        {
                            // Show safemode.htx
                            SHRegSetPath(hKey2, NULL, REG_VAL_GENERAL_WALLPAPER, szSafeMode, 0);
                            // Don't bring up the gallery dialog box
                            dwDisposition = 0;
                            RegSetValueEx(hKey2, REG_VAL_GENERAL_VISITGALLERY, 0, REG_DWORD, (LPBYTE)&dwDisposition, sizeof(dwDisposition));
                        }
                        RegCloseKey(hKey2);
                    }
                    
                    RegCloseKey(hKey);
                }

                // Create the default scheme key
                if(RegCreateKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, 0, NULL, 0,
                        (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKey, REG_VAL_SCHEME_EDIT, 0, REG_SZ, (LPBYTE)TEXT(""), sizeof(TCHAR));
                    RegSetValueEx(hKey, REG_VAL_SCHEME_DISPLAY, 0, REG_SZ, (LPBYTE)TEXT(""), sizeof(TCHAR));
                    RegCloseKey(hKey);
                }

                // Set the components to be dirty sothat we re-generate desktop.htm
                // the first boot after installing IE4.0.
                SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

                GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 
                                                    0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hKey, &dwDisposition))
                {
                    RegCloseKey(hKey);
                }
            }
            else
            {
                //See if we are upgrading from an older version like IE4.
                if (dwDeskHtmlVersion < CUR_DESKHTML_VERSION)
                {
                    // If so, save the DESKHTML_VERSION we are upgrading from.
                    // We use this later in SHGetSetSettings to decide if active desktop is ON/OFF.
                    // NOTE: The "UpgradedFrom" value is at "...\Desktop" and NOT at "..\Desktop\Components"
                    // This is because the "Components" key gets destroyed very often.
                    SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP, REG_VAL_COMP_UPGRADED_FROM,
                                REG_DWORD, (LPBYTE)&dwDeskHtmlVersion, sizeof(dwDeskHtmlVersion));
                }
                 // The major version numbers match. So check if the minor version numbers 
                // match too!
                if(dwDeskHtmlMinorVersion < CUR_DESKHTML_MINOR_VERSION)
                {
                    //Update the new Minor version number!
                    if(RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, NULL, 0,
                            (KEY_CREATE_SUB_KEY | KEY_SET_VALUE), NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
                    {
                        DWORD   dw;
                        
                        dw = CUR_DESKHTML_MINOR_VERSION;
                        RegSetValueEx(hKey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
                        
                        RegCloseKey(hKey);
                    }
                    
                    // Add the new home page component
                    if((dwDeskHtmlVersion <= 0x10f) && (dwDeskHtmlMinorVersion <= 0x0001))
                        CreateMyCurHomeComponent(FALSE);

                    // 
                    // If this is an upgrade from W2K or earlier, we need to check if the
                    // active desktop is OFF. If so, we need to turn off all the desktop components
                    // sothat the active desktop continues to be OFF.
                    if((dwDeskHtmlVersion <= NT5_DESKHTML_VERSION) && 
                       (dwDeskHtmlMinorVersion <= NT5_DESKHTML_MINOR_VERSION))
                    {
                        OnUpgradeDisableActiveDesktopFeatures();
                    }
                    
                    // Minor version numbers do not match. So, set the dirty bit to force
                    // the regeneration of desktop.htt later when needed.
                    SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

//  98/07/16 vtan #176721/#202707: Added the following code to delete HKCU\Software\
//  Microsoft\Internet Explorer\Desktop\General\ComponentsPositioned because in NT 4.0
//  with IE 4.0 SP1 this registry entry is incorrectly incremented when the components
//  are iterated rather than when they are positioned. This resets the counter
//  in NT 5.0 where the bug has been fixed.

                    DWORD dw;
                    
                    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);
                    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, 
                                                        NULL, 0, KEY_SET_VALUE, NULL, &hKey, &dw))
                    {
                        (LONG)RegDeleteValue(hKey, REG_VAL_GENERAL_CCOMPPOS);
                        (LONG)RegCloseKey(hKey);
                    }
                }
            }
        }
    }
    else
    {
        SHDeleteKey(HKEY_LOCAL_MACHINE, c_szRegDeskHtmlProp);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_GENERAL_ROOT);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_SAFEMODE);
        SHDeleteKey(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dcomp.h ===
#ifndef _DCOMP_H_
#define _DCOMP_H_

#include <cowsite.h>

EXTERN_C IActiveDesktop * g_pActiveDeskAdv;

//
// Whether a particular desktop icon is shown or not depends on whether start panel is on or off.
// So, the individual preferences are persisted in two different registry locations given below!
#define REGSTR_PATH_HIDDEN_DESKTOP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideDesktopIcons\\%s")
#define REGSTR_VALUE_STARTPANEL     TEXT("NewStartPanel")
#define REGSTR_VALUE_CLASSICMENU    TEXT("ClassicStartMenu")

#define REGSTR_PATH_HIDDEN_MYCOMP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideMyComputerIcons")

#define REGSTR_PATH_EXP_SHELLFOLDER   REGSTR_PATH_EXPLORER TEXT("\\CLSID\\%s\\ShellFolder")
#define REGVAL_ATTRIBUTES       TEXT("Attributes")

// The following array has the two registry sub-locations where the desktop icon on/off data 
// is stored based on whether start panel is off/on.
const LPTSTR  c_apstrRegLocation[] =
{
    REGSTR_VALUE_CLASSICMENU,       // Use this if classic menu is on.
    REGSTR_VALUE_STARTPANEL         // Use this if start panel is on.
};


// Name of the file that holds each icon, and an index for which icon to use in the file
typedef struct tagIconKeys
{
    TCHAR szOldFile[MAX_PATH];
    int   iOldIndex;
    TCHAR szNewFile[MAX_PATH];
    int   iNewIndex;
}ICONDATA;

extern GUID CLSID_EffectsPage;

// Registry Info for the icons
typedef struct tagIconRegKeys
{
    const CLSID* pclsid;
    TCHAR szIconValue[16];
    int  iTitleResource;
    int  iDefaultTitleResource;
    LPCWSTR pszDefault;
    int  nDefaultIndex;
}ICONREGKEYS;

static const ICONREGKEYS c_aIconRegKeys[] =
{
    { &CLSID_MyComputer,    TEXT("\0"),     0,          IDS_MYCOMPUTER,     L"%WinDir%\\explorer.exe",            0},
    { &CLSID_MyDocuments,   TEXT("\0"),     0,          IDS_MYDOCUMENTS2,   L"%WinDir%\\system32\\mydocs.dll",    0},
    { &CLSID_NetworkPlaces, TEXT("\0"),     0,          IDS_NETNEIGHBOUR,   L"%WinDir%\\system32\\shell32.dll",   17},
    { &CLSID_RecycleBin,    TEXT("full"),   IDS_FULL,   IDS_TRASHFULL,      L"%WinDir%\\system32\\shell32.dll",   32},
    { &CLSID_RecycleBin,    TEXT("empty"),  IDS_EMPTY2, IDS_TRASHEMPTY,     L"%WinDir%\\system32\\shell32.dll",   31},
};

#define NUM_ICONS (ARRAYSIZE(c_aIconRegKeys))

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48


typedef struct tagDeskIconId {
    int         iDeskIconDlgItemId;
    LPCWSTR     pwszCLSID;
    const CLSID *pclsid;
    BOOL        fCheckNonEnumAttrib;
    BOOL        fCheckNonEnumPolicy;
} DESKICONID;

// Array if desktop icons we would like to turn-on/off individually
static const DESKICONID c_aDeskIconId[] =
{
    {IDC_DESKTOP_ICON_MYDOCS,   L"{450D8FBA-AD25-11D0-98A8-0800361B1103}", &CLSID_MyDocuments,     TRUE  , TRUE }, // My Documents
    {IDC_DESKTOP_ICON_MYCOMP,   L"{20D04FE0-3AEA-1069-A2D8-08002B30309D}", &CLSID_MyComputer,      FALSE , TRUE }, // My Computer
    {IDC_DESKTOP_ICON_MYNET,    L"{208D2C60-3AEA-1069-A2D7-08002B30309D}", &CLSID_NetworkPlaces,   TRUE  , TRUE }, // Network Places
    {IDC_DESKTOP_ICON_IE,       L"{871C5380-42A0-1069-A2EA-08002B30309D}", &CLSID_Internet,        TRUE  , TRUE }  // Internet Explorer
};


// The sub-string that preceeds the CLSID when passed as the property name.
// For example, when "SP_1{645FF040-5081-101B-9F08-00AA002F954E}" is passed as the property name,
// it refers to the recycle icon when StartPage is ON.
//
static const LPWSTR c_awszSP[] = 
{
    L"SP_0",        //Indicates StartPage Off.
    L"SP_1",        //Indicates StartPage On.
    L"POLI"         //Indicates that we want the policy info!
};

static const LPWSTR c_wszPropNameFormat = L"%s%s";

#define STARTPAGE_ON_PREFIX     c_awszSP[1]          //The prefix string for StartPage_On.
#define STARTPAGE_OFF_PREFIX    c_awszSP[0]          //The prefix string for StartPage_Off.
#define LEN_PROP_PREFIX         lstrlenW(c_awszSP[0]) //Length of the prefix string.
#define POLICY_PREFIX           c_awszSP[2]

#define NUM_DESKICONS   (ARRAYSIZE(c_aDeskIconId))


#ifndef EXCLUDE_COMPPROPSHEET

class CCompPropSheetPage        : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pAdvPage, IN BOOL * pfEnableApply);

    CCompPropSheetPage(void);

protected:
    int  _cRef;

    ICONDATA _IconData[NUM_ICONS];

    HWND _hwndLV;
    BOOL _fAllowAdd;
    BOOL _fAllowDel;
    BOOL _fAllowEdit;
    BOOL _fAllowClose;
    BOOL _fAllowReset;
    BOOL _fLockDesktopItems;
    BOOL _fForceAD;
    BOOL _fLaunchGallery;           // Did we launch the gallery at any time?
    BOOL _fInitialized;             // Did we finished adding the items to the list view?
    HWND _hWndList;          // handle to the list view window
    HIMAGELIST _hIconList;   // handles to image lists for large icons

    BOOL   _fCustomizeDesktopOK; // was OK clicked when the customize desktop property sheet dialog was closed?
    int    _iStartPanelOn;
    BOOL   _afHideIcon[2][NUM_DESKICONS];
    BOOL   _afDisableCheckBox[NUM_DESKICONS];
    
    int  _iPreviousSelection;
    int  m_nIndex;

    void _AddComponentToLV(COMPONENTA *pcomp);
    void _SetUIFromDeskState(BOOL fEmpty);
    void _OnInitDialog(HWND hwnd, INT iPage);
    void _OnNotify(HWND hwnd, WPARAM wParam, LPNMHDR lpnm);
    void _OnCommand(HWND hwnd, WORD wNotifyCode, WORD wID, HWND hwndCtl);
    void _OnDestroy(INT iPage);
    void _OnGetCurSel(int *piIndex);
    void _EnableControls(HWND hwnd);
    BOOL _VerifyFolderOptions(void);
    void _SelectComponent(LPWSTR pwszUrl);

    HRESULT _OnInitDesktopOptionsUI(HWND hwnd);
    HRESULT _LoadIconState(IN IPropertyBag * pAdvPage);
    HWND _CreateListView(HWND hWndParent);

    void _NewComponent(HWND hwnd);
    void _EditComponent(HWND hwnd);
    void _DeleteComponent(HWND hwnd);
    void _SynchronizeAllComponents(IActiveDesktop *pActDesktop);
    void _TryIt(void);

    void _DesktopCleaner(HWND hwnd);

    HRESULT _IsDirty(IN BOOL * pIsDirty);
    HRESULT _MergeIconState(IN IPropertyBag * pAdvPage);
    HRESULT _LoadDeskIconState(IN IPropertyBag * pAdvPage);
    HRESULT _MergeDeskIconState(IN IPropertyBag * pAdvPage);
    HRESULT _UpdateDesktopIconsUI(HWND hwnd);
private:
    virtual ~CCompPropSheetPage(void);

    // Private Member Functions
    INT_PTR _CustomizeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, INT iPage);

    static INT_PTR _CustomizeDlgProcHelper(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam, INT iPage);
    static INT_PTR CALLBACK CustomizeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK WebDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

BOOL FindComponent(IN LPCTSTR pszUrl, IN IActiveDesktop * pActiveDesktop);
void CreateComponent(COMPONENTA *pcomp, LPCTSTR pszUrl);
INT_PTR NewComponent(HWND hwndOwner, IActiveDesktop * pad, BOOL fDeferGallery, COMPONENT * pcomp);
BOOL LooksLikeFile(LPCTSTR psz);
BOOL IsUrlPicture(LPCTSTR pszUrl);

#endif // EXCLUDE_COMPPROPSHEET

#define WM_COMP_GETCURSEL    (WM_USER+1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskhtm.h ===
//
//  This header file contains symbols and typedefs needed by any
//  files that exist outside the deskhtm sub-directory.
//

#ifndef _DESKHTM_H_
#define _DESKHTM_H_

// deskcls.cpp
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);

// dutil.cpp
STDAPI_(BOOL) SetDesktopFlags(DWORD dwMask, DWORD dwNewFlags);
STDAPI_(DWORD)GetDesktopFlags(void);
STDAPI_(VOID) ActiveDesktop_ApplyChanges();

#define COMPONENTS_DIRTY        0x00000001
#define COMPONENTS_LOCKED       0x00000002
#define COMPONENTS_ZOOMDIRTY    0x00000004

STDAPI_(void) RefreshWebViewDesktop(void);
BOOL PokeWebViewDesktop(DWORD dwFlags);
void RemoveDefaultWallpaper(void);
#define REFRESHACTIVEDESKTOP() (PokeWebViewDesktop(AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH))
void OnDesktopSysColorChange(void);


void SetSafeMode(DWORD dwFlags);

// 
// Desk Mover and Sizer stuff
//

EXTERN_C const CLSID CLSID_DeskMovr;
EXTERN_C const IID IID_IDeskMovr;

STDAPI_(BOOL) DeskMovr_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);


#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp

#endif // _DESKHTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dde.cpp ===
// Handle dde conversations.

#include "stdafx.h"
#pragma hdrstop

#include <iethread.h>
#include <browseui.h>
#include <shlexec.h>        // Window_IsLFNAware

STDAPI_(void) ShellExecCommandFile(LPCITEMIDLIST pidl);  // scffile.cpp

// REARCHITECT: should this be done native for each platform?
#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#define DDECONV_NONE                                    0x00000000
#define DDECONV_NO_UNC                                  0x00000001
#define DDECONV_FORCED_CONNECTION                       0x00000002
#define DDECONV_REPEAT_ACKS                             0x00000004
#define DDECONV_FAIL_CONNECTS                           0x00000008
#define DDECONV_MAP_MEDIA_RECORDER                      0x00000010
#define DDECONV_NULL_FOR_STARTUP                        0x00000020
#define DDECONV_ALLOW_INVALID_CL                        0x00000040
#define DDECONV_EXPLORER_SERVICE_AND_TOPIC              0x00000080
#define DDECONV_USING_SENDMSG                           0x00000100
#define DDECONV_NO_INIT                                 0x00000200

// PERF: this data is duplicated in all instances of the
// cabinet but is only used by the first instance!

DWORD g_dwDDEInst = 0L;
HSZ   g_hszTopic = 0;
HSZ   g_hszService = 0;
HSZ   g_hszStar = 0;
HSZ   g_hszShell = 0;
HSZ   g_hszAppProps = 0;
HSZ   g_hszFolders = 0;
BOOL  g_LFNGroups = FALSE;
HWND  g_hwndDde = NULL;
UINT_PTR  g_nTimer = 0;
HWND  g_hwndDDEML = NULL;
HWND  g_hwndClient = NULL;
DWORD g_dwAppFlags = DDECONV_NONE;

// From shell32\nothunk.c
STDAPI_(void) SHGlobalDefect(DWORD dwHnd32);

// From Shell32\shlobjs.c
STDAPI_(void) SHAbortInvokeCommand();

#define IDT_REPEAT_ACKS             10


BOOL Net_DisconnectDrive(TCHAR chDrive)
{
    TCHAR szDrive[3];

    // Disconnect the given drive from it's share.
    szDrive[0] = chDrive;
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');
    return WNetCancelConnection2(szDrive, 0, FALSE) == WN_SUCCESS;
}


//
// Lets define a simple structure that handles the different converstations
// that might be happening concurently, I don't expect many conversations
// to happen at the same time, so this can be rather simple
//
struct _DDECONV;
typedef struct _DDECONV  DDECONV, * PDDECONV;
struct _DDECONV
{
    DWORD       dwFlags;                // Flags.
    PDDECONV    pddecNext;
    LONG        cRef;
    HCONV       hconv;                  // Handle to the conversation;
    BOOL        fDirty;                 // Has any changes been made;
    IShellLink  *psl;                   // temp link to work with
    TCHAR        szGroup[MAX_PATH];     // Group pathname
    TCHAR        szShare[MAX_PATH];      // Used to override UNC connections.
    TCHAR        chDrive;                // Used to override UNC connections.
};

PDDECONV    g_pddecHead = NULL;         // List of current conversations.
LPTSTR      g_pszLastGroupName = NULL;  // Last group name used for items
                                        // that are created by programs
                                        // that do not setup a context

DDECONV *DDEConv_Create(void)
{
    DDECONV *pddec = (DDECONV *) LocalAlloc(LPTR, sizeof(DDECONV));
    if (pddec)
        pddec->cRef = 1;
    return pddec;
}

LONG DDEConv_AddRef(DDECONV *pddec)
{
    LONG cRef = InterlockedIncrement(&pddec->cRef);
    ASSERT( cRef > 1 );
    return cRef;
}

LONG DDEConv_Release(DDECONV *pddec)
{
    ASSERT( 0 != pddec->cRef );
    LONG cRef = InterlockedDecrement(&pddec->cRef);
    if ( 0 == cRef )
    {
        //  this needs to be deleted
        if (pddec->pddecNext)
            DDEConv_Release(pddec->pddecNext);

        ATOMICRELEASE(pddec->psl);
        
        // Were we forced to create a redirected drive?
        if (pddec->dwFlags & DDECONV_FORCED_CONNECTION)
        {
            // Yep. Clean it up now.
            Net_DisconnectDrive(pddec->chDrive);
        }

        if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && g_nTimer)
        {
            KillTimer(NULL, g_nTimer);
            g_nTimer = 0;
        }

        LocalFree(pddec);
    }
    return cRef;
}


typedef BOOL (*DDECOMMAND)(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
typedef struct _DDECOMMANDINFO
{
    LPCTSTR     pszCommand;
    DDECOMMAND lpfnCommand;
} DDECOMMANDINFO;

DWORD GetDDEAppFlagsFromWindow(HWND hwnd);
UINT* GetDDECommands(LPTSTR lpCmd, const DDECOMMANDINFO *lpsCommands, BOOL fLFN);

BOOL DDE_AddShellServices(void);
void DDE_RemoveShellServices(void);

BOOL DDE_CreateGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ShowGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_AddItem(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ExitProgman(LPTSTR, UINT *, PDDECONV);
BOOL DDE_DeleteGroup(LPTSTR, UINT *, PDDECONV);
BOOL DDE_DeleteItem(LPTSTR, UINT *, PDDECONV);
// BOOL NEAR PASCAL DDE_ReplaceItem(LPSTR, UINT *, PDDECONV);
#define DDE_ReplaceItem DDE_DeleteItem
BOOL DDE_Reload(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ViewFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ExploreFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_FindFolder(LPTSTR, UINT *, PDDECONV);
BOOL DDE_OpenFindFile(LPTSTR, UINT *, PDDECONV);
BOOL DDE_ConfirmID(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
BOOL DDE_ShellFile(LPTSTR lpszBuf, UINT * lpwCmd, PDDECONV pddec);
#ifdef DEBUG
BOOL DDE_Beep(LPTSTR, UINT *, PDDECONV);
#endif
void MapGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew);

TCHAR const c_szGroupGroup[] = TEXT("groups");
#define c_szStarDotStar TEXT("*.*")
 CHAR const c_szCRLF[] = "\r\n";

TCHAR const c_szCreateGroup[]   = TEXT("CreateGroup");
TCHAR const c_szShowGroup[]     = TEXT("ShowGroup");
TCHAR const c_szAddItem[]       = TEXT("AddItem");
TCHAR const c_szExitProgman[]   = TEXT("ExitProgman");
TCHAR const c_szDeleteGroup[]   = TEXT("DeleteGroup");
TCHAR const c_szDeleteItem[]    = TEXT("DeleteItem");
TCHAR const c_szReplaceItem[]   = TEXT("ReplaceItem");
TCHAR const c_szReload[]        = TEXT("Reload");
TCHAR const c_szFindFolder[]    = TEXT("FindFolder");
TCHAR const c_szOpenFindFile[]  = TEXT("OpenFindFile");
#define c_szDotPif TEXT(".pif")
TCHAR const c_szTrioDataFax[]   = TEXT("DDEClient");
TCHAR const c_szTalkToPlus[]    = TEXT("ddeClass");
TCHAR const c_szStartUp[]       = TEXT("StartUp");
TCHAR const c_szCCMail[]        = TEXT("ccInsDDE");
TCHAR const c_szBodyWorks[]     = TEXT("BWWFrame");
TCHAR const c_szMediaRecorder[] = TEXT("DDEClientWndClass");
TCHAR const c_szDiscis[]        = TEXT("BACKSCAPE");
TCHAR const c_szMediaRecOld[]   = TEXT("MediaRecorder");
TCHAR const c_szMediaRecNew[]   = TEXT("Media Recorder");
TCHAR const c_szDialog[]        = TEXT("#32770");
TCHAR const c_szJourneyMan[]    = TEXT("Sender");
TCHAR const c_szCADDE[]         = TEXT("CA_DDECLASS");
TCHAR const c_szFaxServe[]      = TEXT("Install");
TCHAR const c_szMakePMG[]       = TEXT("Make Program Manager Group");
TCHAR const c_szViewFolder[]    = TEXT("ViewFolder");
TCHAR const c_szExploreFolder[] = TEXT("ExploreFolder");
TCHAR const c_szRUCabinet[]     = TEXT("ConfirmCabinetID");
 CHAR const c_szNULLA[] = "";
TCHAR const c_szGetIcon[] = TEXT("GetIcon");
TCHAR const c_szGetDescription[] = TEXT("GetDescription");
TCHAR const c_szGetWorkingDir[] = TEXT("GetWorkingDir");

TCHAR const c_szService[] = TEXT("Progman");
TCHAR const c_szTopic[] = TEXT("Progman");
#define c_szShell TEXT("Shell")
TCHAR const c_szFolders[] = TEXT("Folders");
TCHAR const c_szMapGroups[] = REGSTR_PATH_EXPLORER TEXT("\\MapGroups");
#define c_szStar TEXT("*")
TCHAR const c_szAppProps[] = TEXT("AppProperties");
#define c_szDotLnk TEXT(".lnk")
 CHAR const c_szDesktopIniA[] = STR_DESKTOPINIA;
 CHAR const c_szGroupsA[] = "Groups";
 
TCHAR const c_szShellFile[]     = TEXT("ShellFile");

TCHAR const c_szMrPostman[]     = TEXT("setupPmFrame");

#ifdef DEBUG
TCHAR const c_szBeep[]          = TEXT("Beep");
#endif

#define ADDITEM_INDEX 2  // DDE_AddItem must have index equal to 2
DDECOMMANDINFO const c_sDDECommands[] =
{
    { c_szCreateGroup  , DDE_CreateGroup   },
    { c_szShowGroup    , DDE_ShowGroup     },
    { c_szAddItem      , DDE_AddItem       },  // DDE_AddItem must have index equal to 2
    { c_szExitProgman  , DDE_ExitProgman   },
    { c_szDeleteGroup  , DDE_DeleteGroup   },
    { c_szDeleteItem   , DDE_DeleteItem    },
    { c_szReplaceItem  , DDE_ReplaceItem   },
    { c_szReload       , DDE_Reload        },
    { c_szViewFolder   , DDE_ViewFolder    },
    { c_szExploreFolder, DDE_ExploreFolder },
    { c_szFindFolder,    DDE_FindFolder    },
    { c_szOpenFindFile,  DDE_OpenFindFile  },
    { c_szRUCabinet,     DDE_ConfirmID},
    { c_szShellFile,     DDE_ShellFile},
#ifdef DEBUG
    { c_szBeep         , DDE_Beep          },
#endif
    { 0, 0 },
} ;

#define HDDENULL        ((HDDEDATA)NULL)
#define HSZNULL         ((HSZ)NULL)
#define _DdeCreateStringHandle(dwInst, lpsz, nCP)       DdeCreateStringHandle(dwInst, (LPTSTR)lpsz, nCP)
#define _DdeFreeStringHandle(dwInst, hsz)               if (hsz) DdeFreeStringHandle(dwInst, hsz);
#define _LocalReAlloc(h, cb, flags)      (h ? LocalReAlloc(h, cb, flags) : LocalAlloc(LPTR, cb))

//-------------------------------------------------------------------------
#define ITEMSPERROW 7

typedef struct
{
    LPTSTR pszDesc;
    LPTSTR pszCL;
    LPTSTR pszWD;
    LPTSTR pszIconPath;
    int iIcon;
    BOOL fMin;
    WORD wHotkey;
} GROUPITEM, *PGROUPITEM;

STDAPI_(void) OpenGroup(LPCTSTR pszGroup, int nCmdShow)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
    if (piei) 
    {
        ASSERT(*pszGroup);
        piei->pidl = ILCreateFromPath(pszGroup);
        piei->uFlags = COF_NORMAL | COF_WAITFORPENDING;
        piei->nCmdShow = SW_NORMAL;

        SHOpenFolderWindow(piei);
    }
}


//--------------------------------------------------------------------------
// Returns a pointer to the first non-whitespace character in a string.
LPTSTR SkipWhite(LPTSTR lpsz)
    {
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (TUCHAR)*lpsz <= TEXT(' '))
        lpsz++;

    return(lpsz);
    }

//--------------------------------------------------------------------------
// Reads a parameter out of a string removing leading and trailing whitespace.
// Terminated by , or ).  ] [ and ( are not allowed.  Exception: quoted
// strings are treated as a whole parameter and may contain []() and ,.
// Places the offset of the first character of the parameter into some place
// and NULL terminates the parameter.
// If fIncludeQuotes is false it is assumed that quoted strings will contain single
// commands (the quotes will be removed and anything following the quotes will
// be ignored until the next comma). If fIncludeQuotes is TRUE, the contents of
// the quoted string will be ignored as before but the quotes won't be
// removed and anything following the quotes will remain.
LPTSTR GetOneParameter(LPCTSTR lpCmdStart, LPTSTR lpCmd,
    UINT *lpW, BOOL fIncludeQuotes)
    {
    LPTSTR     lpT;

    switch (*lpCmd)
        {
        case TEXT(','):
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
            *lpCmd++ = 0;                /* comma: becomes a NULL string */
            break;

        case TEXT('"'):
            if (fIncludeQuotes)
            {
                TraceMsg(TF_DDE, "GetOneParameter: Keeping quotes.");

                // quoted string... don't trim off "
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                ++lpCmd;
                while (*lpCmd && *lpCmd != TEXT('"'))
                    lpCmd = CharNext(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                lpT = lpCmd;
                ++lpCmd;

                goto skiptocomma;
            }
            else
            {
                // quoted string... trim off "
                ++lpCmd;
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                while (*lpCmd && *lpCmd != TEXT('"'))
                    lpCmd = CharNext(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                *lpCmd++ = 0;
                lpCmd = SkipWhite(lpCmd);

                // If there's a comma next then skip over it, else just go on as
                // normal.
                if (*lpCmd == TEXT(','))
                    lpCmd++;
            }
            break;

        case TEXT(')'):
            return(lpCmd);                /* we ought not to hit this */

        case TEXT('('):
        case TEXT('['):
        case TEXT(']'):
            return(NULL);                 /* these are illegal */

        default:
            lpT = lpCmd;
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
skiptocomma:
            while (*lpCmd && *lpCmd != TEXT(',') && *lpCmd != TEXT(')'))
            {
                /* Check for illegal characters. */
                if (*lpCmd == TEXT(']') || *lpCmd == TEXT('[') || *lpCmd == TEXT('(') )
                    return(NULL);

                /* Remove trailing whitespace */
                /* prevent sign extension */
                if ((TUCHAR)*lpCmd > TEXT(' '))
                    lpT = lpCmd;

                lpCmd = CharNext(lpCmd);
            }

            /* Eat any trailing comma. */
            if (*lpCmd == TEXT(','))
                lpCmd++;

            /* NULL terminator after last nonblank character -- may write over
             * terminating ')' but the caller checks for that because this is
             * a hack.
             */

#ifdef UNICODE
            lpT[1] = 0;
#else
            lpT[IsDBCSLeadByte(*lpT) ? 2 : 1] = 0;
#endif
            break;
        }

    // Return next unused character.
    return(lpCmd);
    }


// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.


LPTSTR GetCommandName(LPTSTR lpCmd, const DDECOMMANDINFO * lpsCommands, UINT *lpW)
    {
    TCHAR chT;
    UINT iCmd = 0;
    LPTSTR lpT;

    /* Eat any white space. */
    lpT = lpCmd = SkipWhite(lpCmd);

    /* Find the end of the token. */
    while (IsCharAlpha(*lpCmd))
        lpCmd = CharNext(lpCmd);

    /* Temporarily NULL terminate it. */
    chT = *lpCmd;
    *lpCmd = 0;

    /* Look up the token in a list of commands. */
    *lpW = (UINT)-1;
    while (lpsCommands->pszCommand)
        {
        if (!lstrcmpi(lpsCommands->pszCommand, lpT))
            {
            *lpW = iCmd;
            break;
            } 
        iCmd++;
        ++lpsCommands;
        }

    *lpCmd = chT;

    return(lpCmd);
    }

/*  Called with: pointer to a string to parse and a pointer to a
 *  list of sz's containing the allowed function names.
 *  The function returns a global handle to an array of words containing
 *  one or more command definitions.  A command definition consists of
 *  a command index, a parameter count, and that number of offsets.  Each
 *  offset is an offset to a parameter in lpCmd which is now zero terminated.
 *  The list of command is terminated with -1.
 *  If there was a syntax error the return value is NULL.
 *  Caller must free block.
 */

#define LIST_INCREMENT 128
UINT* GetDDECommands(LPTSTR lpCmd, const DDECOMMANDINFO * lpsCommands, BOOL fLFN)
{
    UINT cParm, cCmd = 0;
    LPCTSTR lpCmdStart = lpCmd;
    BOOL fIncludeQuotes = FALSE;

    UINT iList = 0; // current index in list
    UINT cListSize = LIST_INCREMENT; // count of UNIT allocated in list
    UINT *prguList = (UINT*)GlobalAlloc(GPTR, cListSize * sizeof(UINT));
    if (!prguList)
        return 0;

    while (*lpCmd)
    {
        /* Skip leading whitespace. */
        lpCmd = SkipWhite(lpCmd);

        /* Are we at a NULL? */
        if (!*lpCmd)
        {
            /* Did we find any commands yet? */
            if (cCmd)
                goto GDEExit;
            else
                goto GDEErrExit;
        }

        /* Each command should be inside square brackets. */
        if (*lpCmd != TEXT('['))
            goto GDEErrExit;
        lpCmd++;

        // Need room for both a Command ID and a Count of parameters
        // Can't be equal to cpWTotal size because we will later terminate the list with a -1
        if (iList + 2 >= cListSize)
        {
            HGLOBAL hGlobalNew = GlobalReAlloc(prguList, (cListSize + LIST_INCREMENT) * sizeof(UINT), GMEM_MOVEABLE);
            if (hGlobalNew == NULL)
            {
                goto GDEErrExit;
            }
            prguList = (UINT*)hGlobalNew;
            cListSize += LIST_INCREMENT;
        }

        /* Get the command name. */
        lpCmd = GetCommandName(lpCmd, lpsCommands, &prguList[iList]);
        if (prguList[iList] == (UINT)-1)
            goto GDEErrExit;

        // We need to leave quotes in for the first param of an AddItem.
        if (fLFN && prguList[iList] == ADDITEM_INDEX)
        {
            TraceMsg(TF_DDE, "GetDDECommands: Potential LFN AddItem command...");
            fIncludeQuotes = TRUE;
        }

        // We added the command index to the list
        iList++;

        /* Start with zero parms. */
        cParm = 0;
        lpCmd = SkipWhite(lpCmd);

        /* Check for opening '(' */
        if (*lpCmd == TEXT('('))
        {
            lpCmd++;

            /* Skip white space and then find some parameters (may be none). */
            lpCmd = SkipWhite(lpCmd);

            while (*lpCmd != TEXT(')'))
            {
                if (!*lpCmd)
                    goto GDEErrExit;

                // Do we need more memory for this parameter? +2 to reserve space for the count and this item
                // Can't be equal to cpWTotal size because we will later terminate the list with a -1
                if (iList + cParm + 2 >= cListSize)
                {
                    HGLOBAL hGlobalNew = GlobalReAlloc(prguList, (cListSize + LIST_INCREMENT) * sizeof(UINT), GMEM_MOVEABLE);
                    if (hGlobalNew == NULL)
                    {
                        goto GDEErrExit;
                    }
                    prguList = (UINT*)hGlobalNew;
                    cListSize += LIST_INCREMENT;
                }

                // Only the first param of the AddItem command needs to
                // handle quotes from LFN guys.
                if (fIncludeQuotes && (cParm != 0))
                    fIncludeQuotes = FALSE;

                // Get the parameter. ++cParm to get beyond the parameter count that will be stored before the parameter offsets in the list
                if (!(lpCmd = GetOneParameter(lpCmdStart, lpCmd, &prguList[iList] + (++cParm), fIncludeQuotes)))
                    goto GDEErrExit;

                /* HACK: Did GOP replace a ')' with a NULL? */
                if (!*lpCmd)
                    break;

                /* Find the next one or ')' */
                lpCmd = SkipWhite(lpCmd);
            }

            // Skip closing bracket.
            lpCmd++;

            /* Skip the terminating stuff. */
            lpCmd = SkipWhite(lpCmd);
        }

        /* Set the count of parameters and then skip the parameters. */
        prguList[iList++] = cParm;
        iList += cParm;

        /* We found one more command. */
        cCmd++;

        /* Commands must be in square brackets. */
        if (*lpCmd != TEXT(']'))
            goto GDEErrExit;
        lpCmd++;
    }

GDEExit:
    /* Terminate the command list with -1. */
    prguList[iList] = (UINT)-1;

    return prguList;

GDEErrExit:
    GlobalFree(prguList);
    return(0);
}


// lpszBuf is the dde command with NULLs between the commands and the
// arguments.
// *lpwCmd is the number of paramaters.
// *(lpwCmd+n) are offsets to those paramters in lpszBuf.




// Make a long group name valid on an 8.3 machine.
// This assumes the name is already a valid LFN.
void _ShortenGroupName(LPTSTR lpName)
{
    LPTSTR pCh = lpName;

    ASSERT(lpName);

    while (*pCh)
    {
        // Spaces?
        if (*pCh == TEXT(' '))
            *pCh = TEXT('_');
        // Next
        pCh = CharNext(pCh);
        // Limit to 8 chars.
        if (pCh-lpName >= 8)
            break;
    }
    // Null term.
    *pCh = TEXT('\0');
}


// This function will convert the name into a valid file name
void FileName_MakeLegal(LPTSTR lpName)
{
    LPTSTR lpT;

    ASSERT(lpName);

    for (lpT = lpName; *lpT != TEXT('\0'); lpT = CharNext(lpT))
    {
        if (!PathIsValidChar(*lpT, g_LFNGroups ? PIVC_LFN_NAME : PIVC_SFN_NAME))
        {
            // Don't Allow invalid chars in names
            *lpT = TEXT('_');
        }
    }

    // Quick check to see if we support long group names.
    if (!g_LFNGroups)
    {
        // Nope, shorten it.
        _ShortenGroupName(lpName);
    }
}


// Given a ptr to a path and a ptr to the start of its filename componenent
// make the filename legal and tack it on the end of the path.
// lpszPath must be >= MAX_PATH
void GenerateGroupName(LPTSTR lpszPath, LPTSTR lpszName)
{
    ASSERT(lpszPath);
    ASSERT(lpszName);

    // Deal with ":" and "\" in the group name before trying to
    // qualify it.
    FileName_MakeLegal(lpszName);
    PathAppend(lpszPath, lpszName);
    PathQualify(lpszPath);
}


// Simple function used by AddItem, DeleteItem, ReplaceItem to make sure
// that our group name has been setup properly.
void _CheckForCurrentGroup(PDDECONV pddec)
{
    // Need a group - if nothing is specified then we default to using
    // the last group name that someone either created or viewed.
    //
    if (!pddec->szGroup[0])
    {
        // We will use the last context that was set...
        // Note: after that point, we will not track the new create
        // groups and the like of other contexts.
        ENTERCRITICAL;
        if (g_pszLastGroupName != NULL) {
            lstrcpyn(pddec->szGroup, g_pszLastGroupName, ARRAYSIZE(pddec->szGroup));
        } else {
            CABINETSTATE cs;
            if (IsUserAnAdmin() &&
                    (ReadCabinetState(&cs, sizeof(cs)), cs.fAdminsCreateCommonGroups)) {
                SHGetSpecialFolderPath(NULL, pddec->szGroup, CSIDL_COMMON_PROGRAMS, TRUE);
            } else {
                SHGetSpecialFolderPath(NULL, pddec->szGroup, CSIDL_PROGRAMS, TRUE);
            }
        }
        LEAVECRITICAL;
    }
}


// For those apps that do not setup their context for where to
// add items during their processing we need to keep the path
// of the last group that was created (in g_pszLastGroupName).
void _KeepLastGroup(LPCTSTR lpszGroup)
{
    LPTSTR lpGroup;

    ENTERCRITICAL;

    lpGroup = (LPTSTR)_LocalReAlloc(g_pszLastGroupName, (lstrlen(lpszGroup) + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
    if (lpGroup != NULL) {
        g_pszLastGroupName = lpGroup;
        // strcpy okay, just allocated
        lstrcpy(g_pszLastGroupName, lpszGroup);
    }

    LEAVECRITICAL;
}


// NB HACK - Lots of setup apps dot lots of Create/Groups and as we're
// more async now we end up showing lots of identical group windows.
// Also, even the time delay in determining that the group is already
// open can cause some setup apps to get confused.
// So, to stop this happening we keep track of the last group created
// or shown and skip the Cabinet_OpenFolder if it's the same guy and we're
// within a X second timeout limit.
BOOL _SameLastGroup(LPCTSTR lpszGroup)
{
    static DWORD dwTimeOut = 0;
    BOOL fRet = FALSE;
    
    if (lpszGroup && g_pszLastGroupName)
    {
        // Too soon?
        if (GetTickCount() - dwTimeOut < 30*1000)
        {
            LPTSTR pszName1 = PathFindFileName(lpszGroup);
            LPTSTR pszName2 = PathFindFileName(g_pszLastGroupName);
            
            // Yep, same group as last time?
            ENTERCRITICAL;
            if (lstrcmpi(pszName1, pszName2) == 0)
            {
                // Yep.
                fRet = TRUE;
            }
            LEAVECRITICAL;
        }
    }
    
    dwTimeOut = GetTickCount();
    return fRet;
}


// Map the group name to a proper path taking care of the startup group and
// app hacks on the way.
// pszPath must be >= MAX_PATH
void GetGroupPath(LPCTSTR pszName, LPTSTR pszPath, DWORD dwFlags, INT iCommonGroup)
{
    TCHAR  szGroup[MAX_PATH];
    BOOL   bCommonGroup;
    BOOL   bFindPersonalGroup = FALSE;

    if (pszPath)
        *pszPath = TEXT('\0');

    if (!pszName)
        return;

    //
    // Determine which type of group to create.
    //
    if (IsUserAnAdmin()) {
        if (iCommonGroup == 0) {
            bCommonGroup = FALSE;

        } else if (iCommonGroup == 1) {
            bCommonGroup = TRUE;

        } else {
            //
            // Administrators get common groups created by default
            // when the setup application doesn't specificly state
            // what kind of group to create.  This feature can be
            // turned off in the cabinet state flags.
            //
            CABINETSTATE cs;
            ReadCabinetState(&cs, sizeof(cs));
            if (cs.fAdminsCreateCommonGroups) {
                bFindPersonalGroup = TRUE;
                bCommonGroup = FALSE;   // This might get turned on later
                                        // if find is unsuccessful
            } else {
                bCommonGroup = FALSE;
            }
        }
    } else {
        //
        // Regular users can't create common group items.
        //
        bCommonGroup = FALSE;
    }

    // Handle NULL groups for certain apps and map Startup (non-localised)
    // to the startup group.
    if (((dwFlags & DDECONV_NULL_FOR_STARTUP) && !*pszName)
        || (lstrcmpi(pszName, c_szStartUp) == 0))
    {
        if (bCommonGroup) {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_STARTUP, TRUE);
        }
    }
    else
    {
        // Hack for Media Recorder.
        if (dwFlags & DDECONV_MAP_MEDIA_RECORDER)
        {
            if (lstrcmpi(pszName, c_szMediaRecOld) == 0)
                lstrcpyn(szGroup, c_szMediaRecNew, ARRAYSIZE(szGroup));
            else
                lstrcpyn(szGroup, pszName, ARRAYSIZE(szGroup));
        }
        else
        {
            // Map group name for FE characters which have identical
            // twins in both DBCS/SBCS. Stolen from grpconv's similar
            // function.

            MapGroupName(pszName, szGroup, ARRAYSIZE(szGroup));
        }

        // Possibly find existing group
        if (bFindPersonalGroup)
        {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_PROGRAMS, TRUE);
            GenerateGroupName(pszPath, szGroup);
            if (PathFileExistsAndAttributes(pszPath, NULL))
            {
                return;
            }
            bCommonGroup = TRUE;
        }

        // Get the first bit of the path for this group.
        if (bCommonGroup) {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_COMMON_PROGRAMS, TRUE);
        } else {
            SHGetSpecialFolderPath(NULL, pszPath, CSIDL_PROGRAMS, TRUE);
        }

        GenerateGroupName(pszPath, szGroup);
    }
}

BOOL IsParameterANumber(LPTSTR lp)
{
  while (*lp) {
      if (*lp < TEXT('0') || *lp > TEXT('9'))
          return(FALSE);
      lp++;
  }
  return(TRUE);
}


// [ CreateGroup ( Group Name [, Group File] [,Common Flag] ) ]
// REVIEW UNDONE Allow the use of a group file to be specified.
BOOL DDE_CreateGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    INT iCommonGroup = -1;
    TCHAR szGroup[MAX_PATH];     // Group pathname

    DBG_ENTER(FTF_DDE, DDE_CreateGroup);

    if ((*lpwCmd > 3) || (*lpwCmd == 0))
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd >= 2) {

        //
        // Need to check for common group flag
        //
        if (*lpwCmd == 3) {
            if (lpszBuf[*(lpwCmd + 3)] == TEXT('1')) {
                iCommonGroup = 1;
            } else {
                iCommonGroup = 0;
            }
        } else if (*lpwCmd == 2 && IsParameterANumber(lpszBuf + *(lpwCmd+2))) {
            if (lpszBuf[*(lpwCmd + 2)] == TEXT('1')) {
                iCommonGroup = 1;
            } else {
                iCommonGroup = 0;
            }
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroup, pddec->dwFlags, iCommonGroup);

    TraceMsg(TF_DDE, "Create Group %s", (LPTSTR) szGroup);

    // Stop creating lots of identical folders.
    if (!_SameLastGroup(szGroup))
    {
        lstrcpyn(pddec->szGroup, szGroup, ARRAYSIZE(pddec->szGroup));    // Now working on this group...

        // If it doesn't exist then create it.
        if (!PathFileExistsAndAttributes(pddec->szGroup, NULL))
        {
            if (CreateDirectory(pddec->szGroup, NULL))
            {
                SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pddec->szGroup, NULL);
            }
            else
            {
                bRet = FALSE;
                goto Leave;
            }
        }

        // Show it.
        OpenGroup(pddec->szGroup, SW_NORMAL);
        _KeepLastGroup(pddec->szGroup);
    }
    else
    {
        TraceMsg(TF_DDE, "Ignoring duplicate CreateGroup");
    }

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_CreateGroup, bRet);

    return bRet;
}


// REVIEW HACK - Don't just caste, call GetConvInfo() to get this.
#define _GetDDEWindow(hconv)    ((HWND)hconv)


// Return the hwnd of the guy we're talking too.
HWND _GetDDEPartnerWindow(HCONV hconv)
{
        CONVINFO ci;

        ci.hwndPartner = NULL;
        ci.cb = sizeof(ci);
        DdeQueryConvInfo(hconv, QID_SYNC, &ci);
        return ci.hwndPartner;
}


// [ ShowGroup (group_name, wShowParm) ]
// REVIEW This sets the default group - not neccessarily what progman
// used to do but probably close enough.
BOOL DDE_ShowGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    int nShowCmd;
    BOOL fUseStartup = FALSE;
    TCHAR szGroup[MAX_PATH];
    INT iCommonGroup = -1;

    DBG_ENTER(FTF_DDE, DDE_ShowGroup);

    if (*lpwCmd < 2 || *lpwCmd > 3)
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd == 3) {

        //
        // Need to check for common group flag
        //

        if (lpszBuf[*(lpwCmd + 3)] == TEXT('1')) {
            iCommonGroup = 1;
        } else {
            iCommonGroup = 0;
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroup, pddec->dwFlags, iCommonGroup);

    // NB VJE-r setup passes an invalid group name to ShowGroup command.
    // Use szGroup and check it before copying it to pddec->szGroup.
    if (!PathFileExistsAndAttributes(szGroup, NULL))
    {
        bRet = FALSE;
        goto Leave;
    }

    // Get the show cmd.
    lpwCmd++;
    nShowCmd = StrToInt(&lpszBuf[*lpwCmd]);
    TraceMsg(TF_DDE, "Showing %s (%d)", (LPTSTR)szGroup, nShowCmd);

    // Stop lots of cabinet windows from appearing without slowing down the dde
    // conversation if we're just doing a ShowNormal/ShowNA of a group we probably
    // just created.
    switch (nShowCmd)
    {
        case SW_SHOWNORMAL:
        case SW_SHOWNOACTIVATE:
        case SW_SHOW:
        case SW_SHOWNA:
        {
            if (_SameLastGroup(szGroup))
            {
                TraceMsg(TF_DDE, "Ignoring duplicate ShowGroup.");
                bRet = TRUE;
                goto Leave;
            }
            break;
        }
        case SW_SHOWMINNOACTIVE:
        {
                nShowCmd = SW_SHOWMINIMIZED;
                break;
        }
    }

    // It's OK to use the new group.
    lstrcpyn(pddec->szGroup, szGroup, ARRAYSIZE(pddec->szGroup));

    // Else
    _KeepLastGroup(pddec->szGroup);

    OpenGroup(pddec->szGroup, nShowCmd);

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_ShowGroup, bRet);

    return bRet;
}



// [ DeleteGroup (group_name) ]
BOOL DDE_DeleteGroup(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    TCHAR  szGroupName[MAX_PATH];
    INT iCommonGroup = -1;

    DBG_ENTER(FTF_DDE, DDE_DeleteGroup);

    if (*lpwCmd < 1 || *lpwCmd > 3)
    {
        bRet = FALSE;
        goto Leave;
    }

    if (*lpwCmd == 2) {
        //
        // Need to check for common group flag
        //

        if (lpszBuf[*(lpwCmd + 2)] == TEXT('1')) {
            iCommonGroup = 1;
        } else {
            iCommonGroup = 0;
        }
    }

    lpwCmd++;

    GetGroupPath(&lpszBuf[*lpwCmd], szGroupName, pddec->dwFlags, iCommonGroup);

    if (!PathFileExistsAndAttributes(szGroupName, NULL))
    {
        bRet = FALSE;
        goto Leave;
    }

    szGroupName[lstrlen(szGroupName) + 1] = TEXT('\0');     // double NULL terminate

    // Now simply try to delete the group!
    // Use copy engine that will actually move to trash can...
    {
        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            szGroupName,
            NULL,
            FOF_RENAMEONCOLLISION | FOF_NOCONFIRMATION | FOF_SILENT,
        } ;

        TraceMsg(TF_DDE, "Deleting group %s.", szGroupName);

        SHFileOperation(&sFileOp);

        TraceMsg(TF_DDE, "Finished deleting");

    }

    // Clear the last group flag so that Create+Delete+Create
    // does the right thing.
    _KeepLastGroup(c_szNULL);
    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_DeleteGroup, bRet);

    return bRet;
}


// Take the filename part of a path, copy it into lpszName and the pretty it
// up so it can be used as a link name.
void BuildDefaultName(LPTSTR lpszName, LPCTSTR lpszPath, UINT cch)
{
    LPTSTR lpszFilename;

    lpszFilename = PathFindFileName(lpszPath);
    lstrcpyn(lpszName, lpszFilename, cch);
    // NB Path remove extension can only remove extensions from filenames
    // not paths.
    PathRemoveExtension(lpszName);
    CharLower(lpszName);
    CharUpperBuff(lpszName, 1);
}


BOOL HConv_PartnerIsLFNAware(HCONV hconv)
{
    HWND hwndPartner = _GetDDEPartnerWindow(hconv);

    // If this is being forwared by the desktop then assume the app isn't
    // LFN aware.
    if (IsDesktopWindow(hwndPartner))
        return FALSE;
    else
        return Window_IsLFNAware(hwndPartner);
}


BOOL PrivatePathStripToRoot(LPTSTR szRoot)
{
    while(!PathIsRoot(szRoot))
    {
        if (!PathRemoveFileSpec(szRoot))
        {
            // If we didn't strip anything off,
            // must be current drive
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL Net_ConnectDrive(LPCTSTR pszShare, TCHAR *pchDrive)
{
    DWORD err;
    NETRESOURCE nr;
    TCHAR szAccessName[MAX_PATH];
    ULONG cbAccessName = sizeof(szAccessName);
    DWORD dwResult;

    // Connect to the given share and return the drive that it's on.
    nr.lpRemoteName = (LPTSTR)pszShare;
    nr.lpLocalName = NULL;
    nr.lpProvider = NULL;
    nr.dwType = RESOURCETYPE_DISK;
    err = WNetUseConnection(NULL, &nr, NULL, NULL, CONNECT_TEMPORARY | CONNECT_REDIRECT,
        szAccessName, &cbAccessName, &dwResult);
    if (err == WN_SUCCESS)
    {
        TraceMsg(TF_DDE, "Net_ConnextDrive: %s %s %x", pszShare, szAccessName, dwResult);
        if (pchDrive)
            *pchDrive = szAccessName[0];
        return TRUE;
    }

    return FALSE;
}


// Convert (\\foo\bar\some\path, X) to (X:\some\path)
void Path_ChangeUNCToDrive(LPTSTR pszPath, TCHAR chDrive, UINT cch)
{
    TCHAR szPath[MAX_PATH];

    if (StringCchCopy(szPath, ARRAYSIZE(szPath), pszPath))
    {
        PrivatePathStripToRoot(szPath);

        LPTSTR pszSpec = pszPath + lstrlen(szPath) + 1;
        TCHAR szSpec[MAX_PATH];
        lstrcpyn(szSpec, pszSpec, ARRAYSIZE(szSpec));

        pszPath[0] = chDrive;
        pszPath[1] = TEXT(':');
        pszPath[2] = TEXT('\\');
        pszPath[3] = 0;
        StrCatBuff(pszPath, szSpec, cch);
    }
}


LPITEMIDLIST Pidl_CreateUsingAppPaths(LPCTSTR pszApp)
{
    TCHAR szSubKey[MAX_PATH];

    TraceMsg(TF_DDE, "Trying app paths...");

    if (SUCCEEDED(StringCchCopy(szSubKey, ARRAYSIZE(szSubKey), REGSTR_PATH_APPPATHS))
        && PathAppend(szSubKey, pszApp))
    {
        TCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        if (SHRegGetValue(HKEY_LOCAL_MACHINE, szSubKey, NULL, SRRF_RT_REG_SZ, NULL, sz, &cb) == ERROR_SUCCESS)
        {
            return ILCreateFromPath(sz);
        }
    }

    return NULL;
}


// [ AddItem (command,name,icopath,index,pointx,pointy, defdir,hotkey,fminimize,fsepvdm) ]
// This adds things to the current group ie what ever's currently in
// the conversations szGroup string
BOOL DDE_AddItem(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;

    TCHAR szTmp[MAX_PATH];
    int nShowCmd;
    BOOL fIconPath = FALSE;

    DBG_ENTER(FTF_DDE, DDE_AddItem);

    // Make sure group name is setup
    _CheckForCurrentGroup(pddec);

    // Only certain param combinations are allowed.
    UINT nParams = *lpwCmd;
    if (nParams < 1 || nParams == 5 || nParams > 10)
    {
        bRet = FALSE;
        goto Leave;
    }

    // Make a copy and do fixup on the command.
    //
    // This fixing up was needed for Norton Utilities 2.0 which passed
    // unquoted long filenames with spaces.
    //
    TCHAR szCL[MAX_PATH*2];     // scratch for path + args.
    szCL[0] = 0;
    lpwCmd++;
    if( lpszBuf && lpszBuf[*lpwCmd] )
    {
        TCHAR szTmp[MAX_PATH * 2];

        lstrcpyn(szTmp, &lpszBuf[*lpwCmd], ARRAYSIZE(szTmp));
        int cch = lstrlen(szTmp);

        // Is this string inside quotes?
        if ((cch > 1) && (szTmp[0] == TEXT('"')) && (szTmp[cch-1] == TEXT('"')))
        {
            // HACKHACK (reinerf)
            // some apps pass us quoted strings that contain both the exe and the args (eg lotus cc:mail 8.0)
            // others apps pass a quoted relative path that does NOT have args, but _does_ contain spaces (eg WSFtpPro6).
            // so we only strip off the outside quotes if one of the characters inside is NOT a legal filename character,
            // indicating that there are args in the string
            for (LPTSTR pszChar = &szTmp[1]; pszChar < &szTmp[cch-1]; pszChar = CharNext(pszChar))
            {
                if (!PathIsValidChar(*pszChar, PIVC_LFN_FULLPATH | PIVC_ALLOW_QUOTE))
                {
                    // we found something that isint a legal path character (eg '/'), so we assume that this 
                    // string has args within the quotes and we strip them off (eg ""c:\foo\bar.exe /s /v:1"")
                    PathUnquoteSpaces(szTmp);
                    break;
                }
            }
        }
        
        if( PathProcessCommand( szTmp, szCL, ARRAYSIZE(szCL),
                                PPCF_ADDQUOTES|PPCF_ADDARGUMENTS|PPCF_LONGESTPOSSIBLE ) <= 0 )
            lstrcpyn( szCL, szTmp, ARRAYSIZE(szCL) ) ;
    }
    
    if( !*szCL )
    {
        bRet = FALSE ;
        goto Leave ;
    } 
                            
#ifdef DEBUG
    // Separate the args.
    if (HConv_PartnerIsLFNAware(pddec->hconv))
    {
        // Quotes will have been left in the string.
        TraceMsg(TF_DDE, "Partner is LFN aware.");
    }
    else
    {
        // Quotes will have been removed from the string.
        TraceMsg(TF_DDE, "Partner is not LFN aware.");
    }
#endif

    // We initialize the IDLIst of this shell link to NULL, such that
    // when we set it later it won't mess around with the working directory
    // we may have set.
    pddec->psl->SetIDList(NULL);

    // NB - This can deal with quoted spaces.
    PathRemoveBlanks(szCL);
    LPTSTR lpszArgs = PathGetArgs(szCL);
    if (*lpszArgs)
        *(lpszArgs-1) = TEXT('\0');

    // Win32/Win4.0 setup apps are allowed to use paths with (quoted)
    // spaces in them so we may need to remove them now.
    PathUnquoteSpaces(szCL);

    pddec->psl->SetArguments(lpszArgs);

    // Special case UNC paths.
    if ((pddec->dwFlags & DDECONV_NO_UNC) && PathIsUNC(szCL))
    {
        TCHAR szShare[MAX_PATH];

        // CL is a UNC but we know this app can't handle UNC's, we'll need to
        // fake up a drive for it.
        TraceMsg(TF_DDE, "Mapping UNC to drive.");

        // Get the server/share name.
        StringCchCopy(szShare, ARRAYSIZE(szShare), szCL);   // truncation ok since we strip to root
        PrivatePathStripToRoot(szShare);
        // Do we already have a cached connection to this server share?
        if (lstrcmpi(szShare, pddec->szShare) == 0)
        {
            // Yes
            TraceMsg(TF_DDE, "Using cached connection.");
            // Mangle the path to use the drive instead of the UNC.
            Path_ChangeUNCToDrive(szCL, pddec->chDrive, ARRAYSIZE(szCL));
        }
        else
        {
            // No
            TraceMsg(TF_DDE, "Creating new connection.");
            // Make a connection.
            TCHAR chDrive;
            if (Net_ConnectDrive(szShare, &chDrive))
            {
                // Store the server/share.
                lstrcpyn(pddec->szShare, szShare, ARRAYSIZE(pddec->szShare));
                // Store the drive.
                pddec->chDrive = chDrive;
                // Set the DDECONV_FORCED_CONNECTION flag so we can cleanup later.
                pddec->dwFlags |= DDECONV_FORCED_CONNECTION;
                // Mangle the path to use the drive instead of the UNC.
                Path_ChangeUNCToDrive(szCL, pddec->chDrive, ARRAYSIZE(szCL));
            }
            else
            {
                TraceMsg(TF_DDE, "Can't create connection.");
            }
        }
        TraceMsg(TF_DDE, "CL changed to %s.", szCL);
    }

    // Is there a name?
    TCHAR szName[MAX_PATH];
    szName[0] = TEXT('\0');
    if (nParams > 1)
    {
        // Yep,
        lpwCmd++;
        lstrcpyn(szName, &lpszBuf[*lpwCmd], ARRAYSIZE(szName));
    }

    // Make absolutely sure we have a name.
    if (!szName[0])
        BuildDefaultName(szName, szCL, ARRAYSIZE(szName));

    // Make it legal.
    FileName_MakeLegal(szName);

    // NB Skip setting the CL until we get the WD, we may need
    // it.

    // Deal with the icon path.
    if (nParams > 2)
    {
        lpwCmd++;
        lstrcpyn(szTmp, &lpszBuf[*lpwCmd], ARRAYSIZE(szTmp));
        if (*szTmp)
        {
            // Some people try to put arguments on the icon path line.
            lpszArgs = PathGetArgs(szTmp);
            if (*lpszArgs)
                *(lpszArgs-1) = TEXT('\0');
            // Save it.
            fIconPath = TRUE;
        }
    }
    else
    {
        szTmp[0] = TEXT('\0');
    }

    UINT iIcon = 0;
    // Icon index
    if (nParams > 3)
    {
        lpwCmd++;
        // They must have had an icon path for this to make sense.
        if (fIconPath)
        {
            iIcon = StrToInt(&lpszBuf[*lpwCmd]);
            // REVIEW Don't support icon indexs > 666 hack anymore.
            // It used to mark this item as the selected one. This
            // won't work in the new shell.
            if (iIcon >= 666)
            {
                iIcon -= 666;
            }
        }
    }

    pddec->psl->SetIconLocation(szTmp, iIcon);

    // Get the point :-)
    // REVIEW UNDONE ForcePt stuff for ReplaceItem.
    if (nParams > 4)
    {
        POINT ptIcon;
        lpwCmd++;
        ptIcon.x = StrToInt(&lpszBuf[*lpwCmd]);
        lpwCmd++;
        ptIcon.y = StrToInt(&lpszBuf[*lpwCmd]);
    }

    // The working dir. Do we need a default one?
    if (nParams > 6)
    {
        lpwCmd++;
        lstrcpyn(szTmp, &lpszBuf[*lpwCmd], ARRAYSIZE(szTmp));
    }
    else
    {
        szTmp[0] = TEXT('\0');
    }

    // If we don't have a default directory, try to derive one from the
    // given CL (unless it's a UNC).
    if (!szTmp[0])
    {
        // Use the command for this.
        // REVIEW UNDONE It would be better fo the WD and the IP to be
        // moveable like the CL.
        lstrcpyn(szTmp, szCL, ARRAYSIZE(szTmp));
        // Remove the last component.
        PathRemoveFileSpec(szTmp);
    }

    // Don't use UNC paths.
    if (PathIsUNC(szTmp))
        pddec->psl->SetWorkingDirectory(c_szNULL);
    else
        pddec->psl->SetWorkingDirectory(szTmp);

    // Now we have a WD we can deal with the command line better.
    LPTSTR dirs[2];
    dirs[0] = szTmp;
    dirs[1] = NULL;
    PathResolve(szCL, (LPCTSTR*)dirs, PRF_TRYPROGRAMEXTENSIONS | PRF_VERIFYEXISTS);

    LPITEMIDLIST pidl = ILCreateFromPath(szCL);
    if (!pidl)
    {
        TraceMsg(TF_DDE, "Can't create IL from path. Using simple idlist.");
        // REVIEW UNDONE Check that the file doesn't exist.
        pidl = SHSimpleIDListFromPath(szCL);
        // The Family Circle Cookbook tries to create a shortcut
        // to wordpad.exe but since that's now not on the path
        // we can't find it. The fix is to do what ShellExec does
        // and check the App Paths section of the registry.
        if (!pidl)
        {
            pidl = Pidl_CreateUsingAppPaths(szCL);
        }
    }

    if (pidl)
    {
        pddec->psl->SetIDList(pidl);
        ILFree(pidl);
    }
    else
    {
        TraceMsg(TF_DDE, "Can't create idlist for %s", szCL);

        if (pddec->dwFlags & DDECONV_ALLOW_INVALID_CL)
            bRet = TRUE;
        else
            bRet = FALSE;

        goto Leave;
    }

    // Hotkey.
    if (nParams > 7)
    {
        WORD wHotkey;
        lpwCmd++;
        wHotkey = (WORD)StrToInt(&lpszBuf[*lpwCmd]);
        pddec->psl->SetHotkey(wHotkey);
    }
    else
    {
        pddec->psl->SetHotkey(0);
    }

    // Show command
    if (nParams > 8)
    {
        lpwCmd++;
        if (StrToInt(&lpszBuf[*lpwCmd]))
            nShowCmd = SW_SHOWMINNOACTIVE;
        else
            nShowCmd = SW_SHOWNORMAL;
        pddec->psl->SetShowCmd(nShowCmd);
    }
    else
    {
        pddec->psl->SetShowCmd(SW_SHOWNORMAL);
    }
    if (nParams > 9)
    {
        lpwCmd++;
        if (StrToInt(&lpszBuf[*lpwCmd]))
        {
            // FEATURE - BobDay - Handle Setup of Seperate VDM flag!
            // pddec->psl->SetSeperateVDM(pddec->psl, wHotkey);
        }
    }

    pddec->fDirty = TRUE;

    PathCombine(szTmp, pddec->szGroup, szName);
    StrCatBuff(szTmp, c_szDotLnk, ARRAYSIZE(szTmp));
    PathQualify(szTmp);

    // We need to handle link duplication problems on SFN drives.
    if (!IsLFNDrive(szTmp) && PathFileExistsAndAttributes(szTmp, NULL))
        PathYetAnotherMakeUniqueName(szTmp, szTmp, NULL, NULL);

    IPersistFile *ppf;
    if (SUCCEEDED(pddec->psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
    {
        // DDE can do anything, so its not a security weakness to use this path directly
        ppf->Save(szTmp, TRUE);
        ppf->Release();
    }

    // REVIEW - Sometimes links don't get the right icons. The theory is that
    // a folder in the process of opening (due to a CreateGroup) will pick
    // up a partially written .lnk file. When the link is finally complete
    // we send a SHCNE_CREATE but this will get ignored if defview already has
    // the incomplete item. To hack around this we generate an update item
    // event to force an incomplete link to be re-read.
    TraceMsg(TF_DDE, "Generating events.");

    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szTmp, NULL);
    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szTmp, NULL);

    bRet = TRUE;

Leave:
    DBG_EXIT_BOOL(FTF_DDE, DDE_AddItem, bRet);

    return bRet;
}




// [ DeleteItem (ItemName)]
// This deletes the specified item from a group
BOOL DDE_DeleteItem(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    BOOL bRet;
    TCHAR szPath[MAX_PATH];

    DBG_ENTER(FTF_DDE, DDE_DeleteItem);

    if (*lpwCmd != 1)
    {
        bRet = FALSE;
    }
    else
    {
        lpwCmd++;

        // Make sure group name is setup
        _CheckForCurrentGroup(pddec);

        pddec->fDirty = TRUE;

        // REVIEW IANEL Hardcoded .lnk and .pif
        PathCombine(szPath, pddec->szGroup, &lpszBuf[*lpwCmd]);
        StrCatBuff(szPath, c_szDotLnk, ARRAYSIZE(szPath));
        bRet = Win32DeleteFile(szPath);

        PathCombine(szPath, pddec->szGroup, &lpszBuf[*lpwCmd]);
        StrCatBuff(szPath, c_szDotPif, ARRAYSIZE(szPath));
        bRet |= DeleteFile(szPath);
    }

    DBG_EXIT_BOOL(FTF_DDE, DDE_DeleteItem, bRet);

    return bRet;
}


// [ ExitProgman (bSaveGroups) ]
// REVIEW This doesn't do anything in the new shell. It's supported to stop
// old installations from barfing.
// REVIEW UNDONE - We should keep track of the groups we've shown
// and maybe hide them now.
BOOL DDE_ExitProgman(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    return TRUE;
}


// [ Reload (???) ]
// REVIEW Just return FALSE
BOOL DDE_Reload(LPTSTR lpszBuf, UINT *lpwCmd, PDDECONV pddec)
{
    return FALSE;
}


PDDECONV DDE_MapHConv(HCONV hconv)
{
    PDDECONV pddec;

    ENTERCRITICAL;
    for (pddec = g_pddecHead; pddec != NULL; pddec = pddec->pddecNext)
    {
        if (pddec->hconv == hconv)
            break;
    }

    if (pddec)
        DDEConv_AddRef(pddec);
        
    LEAVECRITICAL;

    TraceMsg(TF_DDE, "Mapping " SPRINTF_PTR " -> " SPRINTF_PTR , (DWORD_PTR)hconv, (ULONG_PTR)(LPVOID)pddec);
    return(pddec);
}

//
//  This data structure is used to return the error information from
// _GetPIDLFromDDEArgs to its caller. The caller may pop up a message
// box using this information. idMsg==0 indicates there is no such
// information.
//
typedef struct _SHDDEERR {      // sde (Software Design Engineer, Not!)
    UINT idMsg;
    TCHAR szParam[MAX_PATH];
} SHDDEERR, *PSHDDEERR;


// Helper function to convert passed in command parameters into the
// appropriate Id list
LPITEMIDLIST _GetPIDLFromDDEArgs(UINT nArg, LPTSTR lpszBuf, UINT * lpwCmd, PSHDDEERR psde, LPCITEMIDLIST *ppidlGlobal)
{
    LPTSTR lpsz;
    LPITEMIDLIST pidl = NULL;
    
    // Switch from 0-based to 1-based 
    ++nArg;
    if (*lpwCmd < nArg)
    {
        TraceMsg(TF_DDE, "Invalid parameter count of %d", *lpwCmd);
        return NULL;
    }

    // Skip to the right argument
    lpwCmd += nArg;
    lpsz = &lpszBuf[*lpwCmd];

    TraceMsg(TF_DDE, "Converting \"%s\" to pidl", lpsz);
    // REVIEW: all associations will go through here.  this
    // is probably not what we want for normal cmd line type operations

    // A colon at the begining of the path means that this is either
    // a pointer to a pidl (win95 classic) or a handle:pid (all other
    // platforms including win95+IE4).  Otherwise, it's a regular path.

    if (lpsz[0] == TEXT(':'))
    {
        HANDLE hMem;
        DWORD  dwProcId;
        LPTSTR pszNextColon;

        // Convert the string into a pidl.

        hMem =  LongToHandle(StrToLong((LPTSTR)(lpsz+1))) ;
        pszNextColon = StrChr(lpsz+1,TEXT(':'));
        if (pszNextColon)
        {
            LPITEMIDLIST pidlShared;

            dwProcId = (DWORD)StrToLong(pszNextColon+1);
            pidlShared = (LPITEMIDLIST)SHLockShared(hMem,dwProcId);
            if (pidlShared)
            {
                pidl = ILClone(pidlShared);
                SHUnlockShared(pidlShared);
            }
            else
            {
                TraceMsg(TF_WARNING, "DDE SHMem failed - App probably forgot to pass SEE_MASK_FLAG_DDEWAIT");
            }
            SHFreeShared(hMem,dwProcId);
        }
        else if (hMem)
        {
            // this is likely to be browser only mode on win95 with the old pidl arguments which is
            // going to be in shared memory.... (must be cloned into local memory)...
            pidl = ILClone((LPITEMIDLIST) hMem);

            // this will get freed if we succeed.
            ASSERT( ppidlGlobal );
            *ppidlGlobal = (LPITEMIDLIST) hMem;
        }

        return pidl;
    }
    else
    {
        TCHAR tszQual[MAX_PATH];

        // We must copy to a temp buffer because the PathQualify may
        // result in a string longer than our input buffer and faulting
        // seems like a bad way of handling that situation.
        lstrcpyn(tszQual, lpsz, ARRAYSIZE(tszQual));
        lpsz = tszQual;

        // Is this a URL?
        if (!PathIsURL(lpsz))
        {
            // No; qualify it
            PathQualifyDef(lpsz, NULL, PQD_NOSTRIPDOTS);
        }

        pidl = ILCreateFromPath(lpsz);

        if (pidl==NULL && psde) 
        {
            psde->idMsg = IDS_CANTFINDDIR;
            lstrcpyn(psde->szParam, lpsz, ARRAYSIZE(psde->szParam));
        }
        return pidl;
    }
}


LPITEMIDLIST GetPIDLFromDDEArgs(LPTSTR lpszBuf, UINT * lpwCmd, PSHDDEERR psde, LPCITEMIDLIST * ppidlGlobal)
{
    LPITEMIDLIST pidl = _GetPIDLFromDDEArgs(1, lpszBuf, lpwCmd, psde, ppidlGlobal);
    if (!pidl)
    {
        pidl = _GetPIDLFromDDEArgs(0, lpszBuf, lpwCmd, psde, ppidlGlobal);
    }
    
    return pidl;
}

void _FlagsToParams(UINT uFlags, LPTSTR pszParams, UINT cch)
{
    if (uFlags & COF_EXPLORE)
        StrCatBuff(pszParams, TEXT(",/E"), cch);

    if (uFlags & COF_SELECT)
        StrCatBuff(pszParams, TEXT(",/SELECT"), cch);

    if (uFlags & COF_CREATENEWWINDOW)
        StrCatBuff(pszParams, TEXT(",/N"), cch);

    if (uFlags & COF_USEOPENSETTINGS)
        StrCatBuff(pszParams, TEXT(",/S"), cch);
}


#define SZ_EXPLORER_EXE     TEXT("explorer.exe")

HRESULT GetExplorerPath(LPTSTR pszExplorer, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // This process is either iexplore.exe or explorer.exe.
    // If it's explorer.exe, we want to use it's path also.
    if (GetModuleFileName(NULL, pszExplorer, cchSize))
    {
        LPCTSTR pszFileName = PathFindFileName(pszExplorer);

        // This may not be the explorer.exe process.
        if (0 != StrCmpI(pszFileName, SZ_EXPLORER_EXE))
        {
            StrCpyN(pszExplorer, SZ_EXPLORER_EXE, cchSize);
        }
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}


BOOL IsDesktopProcess(HWND hwnd)
{
    DWORD dwProcessID;
    DWORD dwDesktopProcessID;

    if (!hwnd)
        return FALSE;

    GetWindowThreadProcessId(GetShellWindow(), &dwDesktopProcessID);
    GetWindowThreadProcessId(hwnd, &dwProcessID);
    return (dwProcessID == dwDesktopProcessID);
}

// lpszBuf is a multi-string containing the various parameters.  

// lpwCmd is an array of indexes, where the first 
// element is the count of parameters, and each element
// after that is the starting offset into lpszBuf
// for the respective parameter.

BOOL DoDDE_ViewFolder(IShellBrowser* psb, HWND hwndParent, LPTSTR pszBuf, UINT *puCmd, BOOL fExplore, DWORD dwHotKey, HMONITOR hMonitor)
{
    // used to support the older win95 (browser only mode) Global passing of pidl pointers..
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl;
    int nCmdShow;
    SHDDEERR sde = { 0 };
    BOOL fSuccess = TRUE;

    if (*puCmd != 3)
        return FALSE;   // Wrong number of arguments

    // The ShowWindow parameter is the third 
    nCmdShow = StrToLong(&pszBuf[*(puCmd+3)]);

    pidl = GetPIDLFromDDEArgs(pszBuf, puCmd, &sde, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        IETHREADPARAM *pfi = SHCreateIETHREADPARAM(NULL, nCmdShow, NULL, NULL);
        if (pfi)
        {
            pfi->hwndCaller = hwndParent;
            pfi->pidl = ILClone(pidl);
            pfi->wHotkey = (UINT)dwHotKey;
            pfi->uFlags = COF_NORMAL;
            pfi->psbCaller = psb;
            if (psb)
            {
                psb->AddRef();          // for pfi->psbCaller
            }

            psb = NULL;                 // ownership transferred to pfi!

            // Check for a :0 thing. Probably came from the command line.
            if (lstrcmpi(&pszBuf[*(puCmd+2)], TEXT(":0")) != 0)
            {
                // we need to use COF_USEOPENSETTINGS here.  this is where the open
                // from within cabinets happen.  if it's done via the command line
                // then it will esentially turn to COF_NORMAL because the a cabinet
                // window won't be the foreground window.

                pfi->uFlags = COF_USEOPENSETTINGS;
            }

            if (hMonitor != NULL)
            {
                pfi->pidlRoot = reinterpret_cast<LPITEMIDLIST>(hMonitor);
                pfi->uFlags |= COF_HASHMONITOR;
            }

            if (fExplore)
                pfi->uFlags |= COF_EXPLORE;

            // The REST_SEPARATEDESKTOPPROCESS restriction means that all shell windows
            // should be opened in an explorer other then the desktop explorer.exe process.
            // However, shell windows need to be in the same second explorer.exe instance.
            BOOL bSepProcess = FALSE;

            if (IsDesktopProcess(hwndParent))
            {
                bSepProcess = TRUE;

                if (!SHRestricted(REST_SEPARATEDESKTOPPROCESS))
                {
                    SHELLSTATE ss;

                    SHGetSetSettings(&ss, SSF_SEPPROCESS, FALSE);
                    bSepProcess = ss.fSepProcess;
                }
            }
            
            if (bSepProcess)
            {
                TCHAR szExplorer[MAX_PATH];
                TCHAR szCmdLine[MAX_PATH];
                SHELLEXECUTEINFO ei = { sizeof(ei), 0, NULL, NULL, szExplorer, szCmdLine, NULL, SW_SHOWNORMAL};

                DWORD dwProcess = GetCurrentProcessId();
                HANDLE hIdList = NULL;
                
                GetExplorerPath(szExplorer, ARRAYSIZE(szExplorer));
                fSuccess = TRUE;
                if (pfi->pidl)
                {
                    hIdList = SHAllocShared(pfi->pidl, ILGetSize(pfi->pidl), dwProcess);
                    wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("/IDLIST,:%ld:%ld"), hIdList, dwProcess);
                    if (!hIdList)
                        fSuccess = FALSE;
                }
                else
                {
                    lstrcpyn(szCmdLine, TEXT("/IDLIST,:0"), ARRAYSIZE(szCmdLine));
                }

                _FlagsToParams(pfi->uFlags, szCmdLine + lstrlen(szCmdLine), ARRAYSIZE(szCmdLine) - lstrlen(szCmdLine));

                if (fSuccess)
                {
                    fSuccess = ShellExecuteEx(&ei); // if attacker has sent DDE commands we're already in trouble
                }
                if (!fSuccess && hIdList)
                    SHFreeShared(hIdList, dwProcess);

                SHDestroyIETHREADPARAM(pfi);
            }
            else
            {
                //
                // Check if this is a folder or not. If not, we always create
                // a new window (even though we can browse in-place). If you
                // don't like it, please talk to ChristoB. (SatoNa)
                //
                //  I don't like it...  not for the explore case.
                // 
                if (!(pfi->uFlags & COF_EXPLORE))
                {
                    ULONG dwAttr = SFGAO_FOLDER;
                    if (SUCCEEDED(SHGetAttributesOf(pidl, &dwAttr)) && !(dwAttr & SFGAO_FOLDER))
                    {
                        pfi->uFlags |= COF_CREATENEWWINDOW;
                    }
                }
                fSuccess = SHOpenFolderWindow(pfi); // takes ownership of the whole pfi thing
            }

            if (!fSuccess && (GetLastError() == ERROR_OUTOFMEMORY))
                SHAbortInvokeCommand();

            fSuccess = TRUE;    // If we fail we don't want people to try
                                // to create process as this will blow up...
        }
        ILFree(pidl);
    }
    else
    {
        if (sde.idMsg) 
        {
            ShellMessageBox(HINST_THISDLL, hwndParent,
                MAKEINTRESOURCE(sde.idMsg), MAKEINTRESOURCE(IDS_CABINET),
                MB_OK|MB_ICONHAND|MB_SETFOREGROUND, sde.szParam);
        }
        fSuccess = FALSE;
    }

    if (fSuccess)
        ILFree(pidlGlobal);
    
    return fSuccess;
}


BOOL DDE_ViewFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    return DoDDE_ViewFolder(NULL, NULL, lpszBuf, puCmd, FALSE, 0, NULL);
}


// FEATURE ExploreFolder and ViewFolder do the same thing right now, maybe
// they should do something different
BOOL DDE_ExploreFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    return DoDDE_ViewFolder(NULL, NULL, lpszBuf, puCmd, TRUE, 0, NULL);
}


BOOL DDE_FindFolder(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        // A very large hack.  If the pidl is to the network neighborhood,
        // we do a FindComputer instead!
        LPITEMIDLIST pidlNetwork = SHCloneSpecialIDList(NULL, CSIDL_NETWORK, FALSE);
        if (pidlNetwork && ILIsEqual(pidlNetwork, pidl))
            SHFindComputer(pidl, NULL);
        else
            SHFindFiles(pidl, NULL);
        ILFree(pidlNetwork);
        ILFree(pidl);
        ILFree(pidlGlobal);
            
        return TRUE;
    }
    return FALSE;
}



// This processes the Find Folder command.  It is used for both for selecting
// Find on a folders context menu as well as opening a find file.
BOOL DDE_OpenFindFile(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl)
    {
        SHFindFiles(NULL, pidl);
        ILFree( pidlGlobal );
        return TRUE;
    }
    else
        return FALSE;
}


BOOL DDE_ConfirmID(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    BOOL bRet;

    DBG_ENTER(FTF_DDE, DDE_ConfirmID);

    bRet = (*puCmd == 0);

    DBG_EXIT_BOOL(FTF_DDE, DDE_ConfirmID, bRet);
    return bRet;
}


#ifdef DEBUG

BOOL DDE_Beep(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    DWORD dwTime;

    dwTime = GetTickCount();
    TraceMsg(TF_DDE, "Spin...");
    // Spin. Spin. Spin. Huh Huh. Cool.
    while ((GetTickCount()-dwTime) < 4000)
    {
        // Spin.
    }
    TraceMsg(TF_DDE, "Spinning done.");

    return TRUE;
}
#endif


BOOL DDE_ShellFile(LPTSTR lpszBuf, UINT * puCmd, PDDECONV pddec)
{
    LPITEMIDLIST pidlGlobal = NULL;
    LPITEMIDLIST pidl = GetPIDLFromDDEArgs(lpszBuf, puCmd, NULL, (LPCITEMIDLIST*)&pidlGlobal);
    if (pidl) 
    {
        ShellExecCommandFile(pidl);
        
        ILFree(pidl);
        ILFree(pidlGlobal);
        return TRUE;
    }
    return FALSE;
}

VOID CALLBACK TimerProc_RepeatAcks(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    HWND hwndPartner;

    if (g_hwndDde)
    {
        hwndPartner = _GetDDEPartnerWindow((HCONV)g_hwndDde);
        if (hwndPartner)
        {
            TraceMsg(TF_DDE, "DDE partner (%x) appears to be stuck - repeating Ack.", hwndPartner);
            PostMessage(hwndPartner, WM_DDE_ACK, (WPARAM)g_hwndDde, 0);
        }
    }
}


HDDEDATA HandleDDEExecute(HDDEDATA hData, HCONV hconv)
{
    UINT *lpwCmd;
    UINT *lpwCmdTemp;
    UINT wCmd;
    PDDECONV pddec;
    HDDEDATA hddeRet = (HDDEDATA) DDE_FACK;
    UINT nErr;
    LPTSTR pszBuf;
    int cbData;

    DBG_ENTER(FTF_DDE, HandleDDEExecute);

    pddec = DDE_MapHConv(hconv);
    if (pddec == NULL)
    {
        // Could not find conversation
        hddeRet = HDDENULL;
        goto Leave;
    }

    if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && g_nTimer)
    {
        KillTimer(NULL, g_nTimer);
        g_nTimer = 0;
    }

    // NB Living Books Installer cats all their commands together
    // which requires about 300bytes - better just allocate it on
    // the fly.
    cbData = DdeGetData(hData, NULL, 0, 0L);
    if (cbData == 0)
    {
        // No data?
        hddeRet = HDDENULL;
        goto Leave;
    }

    pszBuf = (LPTSTR)LocalAlloc(LPTR, cbData);
    if (!pszBuf)
    {
        TraceMsg(TF_ERROR, "HandleDDEExecute: Can't allocate buffer (%d)", cbData);
        hddeRet = HDDENULL;
        goto Leave;
    }

    cbData = DdeGetData(hData, (LPBYTE)pszBuf, cbData, 0L);
    if (cbData == 0)
    {
        nErr = DdeGetLastError(g_dwDDEInst);
        TraceMsg(TF_ERROR, "HandleDDEExecute: Data invalid (%d).", nErr);
        ASSERT(0);
        LocalFree(pszBuf);
        hddeRet = HDDENULL;
        goto Leave;
    }

#ifdef UNICODE
    //
    // At this point, we may have ANSI data in pszBuf, but we need UNICODE!
    // !!!HACK alert!!! We're going to poke around in the string to see if it is
    // ansi or unicode.  We know that DDE execute commands should only
    // start with " " or "[", so we use that information...
    //
    // By the way, this only really happens when we get an out of order
    // WM_DDE_EXECUTE (app didn't send WM_DDE_INITIATE -- Computer Associate
    // apps like to do this when they setup).  Most of the time DDEML will
    // properly translate the data for us because they correctly determine
    // ANSI/UNICODE conversions from the WM_DDE_INITIATE message.

    if ((cbData>2) &&
        ((*((LPBYTE)pszBuf)==(BYTE)' ') || (*((LPBYTE)pszBuf)==(BYTE)'[')) &&
        (*((LPBYTE)pszBuf+1)!=0 ))
    {
        // We think that pszBuf is an ANSI string, so convert it
        LPTSTR pszUBuf;

        pszUBuf = (LPTSTR)LocalAlloc(LPTR, cbData * sizeof(WCHAR));
        if (pszUBuf)
        {
            // cbData is really cchData
            MultiByteToWideChar( CP_ACP, 0, (LPCSTR)pszBuf, -1, pszUBuf, cbData );
            LocalFree(pszBuf);
            pszBuf = pszUBuf;
        }
        else
        {
            // gotos are weak but i dont really want to rewrite this function
            LocalFree(pszBuf);
            hddeRet = HDDENULL;
            goto Leave;
        }
    }
#endif // UNICODE

    if (pszBuf[0] == TEXT('\0'))
    {
        TraceMsg(TF_ERROR, "HandleDDEExecute: Empty execute command.");
        ASSERT(0);
        LocalFree(pszBuf);

        hddeRet = HDDENULL;
        goto Leave;
    }

    TraceMsg(TF_DDE, "Executing %s", pszBuf);

    lpwCmd = GetDDECommands(pszBuf, c_sDDECommands, HConv_PartnerIsLFNAware(hconv));
    if (!lpwCmd)
    {
#ifdef DEBUG
        // [] is allowed since it means "nop" (used alot in ifexec where we have already 
        // passed the info on cmdline since we had do and exec)
        if (lstrcmpi(pszBuf, TEXT("[]")) != 0)
        {
            ASSERTMSG(FALSE, "HandleDDEExecute: recieved a bogus DDECommand %s", pszBuf);
        }
#endif
        LocalFree(pszBuf);

        // Make sure Discis installers get the Ack they're waiting for.
        if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && !g_nTimer)
        {
            // DebugBreak();
            g_nTimer = SetTimer(NULL, IDT_REPEAT_ACKS, 1000, TimerProc_RepeatAcks);
        }

        hddeRet = HDDENULL;
        goto Leave;
    }

    // Store off lpwCmd so we can free the correect addr later
    lpwCmdTemp = lpwCmd;

    // Execute a command.
    while (*lpwCmd != (UINT)-1)
    {
        wCmd = *lpwCmd++;
        // Subtract 1 to account for the terminating NULL
        if (wCmd < ARRAYSIZE(c_sDDECommands)-1)
        {
            if (!c_sDDECommands[wCmd].lpfnCommand(pszBuf, lpwCmd, pddec))
            {
                hddeRet = HDDENULL;
            }
        }

        // Next command.
        lpwCmd += *lpwCmd + 1;
    }

    // Tidyup...
    GlobalFree(lpwCmdTemp);
    LocalFree(pszBuf);

    // Make sure Discis installers get the Ack they're waiting for.
    if ((pddec->dwFlags & DDECONV_REPEAT_ACKS) && !g_nTimer)
    {
        // DebugBreak();
        g_nTimer = SetTimer(NULL, IDT_REPEAT_ACKS, 1000, TimerProc_RepeatAcks);
    }

Leave:

    if (pddec)
        DDEConv_Release(pddec);

    DBG_EXIT_DWORD(FTF_DDE, HandleDDEExecute, hddeRet);

    return hddeRet;
}


// NOTE: ANSI ONLY

// Used for filtering out hidden, . and .. stuff.

BOOL FindData_FileIsNormalA(WIN32_FIND_DATAA *lpfd)
{
    if ((lpfd->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) ||
        lstrcmpiA(lpfd->cFileName, c_szDesktopIniA) == 0)
    {
        return FALSE;
    }
    else if (lpfd->cFileName[0] == '.')
    {
        if ((lpfd->cFileName[1] == '\0') ||
            ((lpfd->cFileName[1] == '.') && (lpfd->cFileName[2] == '\0')))
        {
            return FALSE;
        }
    }
    return TRUE;
}


HDDEDATA EnumGroups(HSZ hszItem)
{
    TCHAR szGroup[MAX_PATH];
#ifdef UNICODE        
    CHAR  szAGroup[MAX_PATH];
#endif        
    WIN32_FIND_DATAA fd;
    HANDLE hff;
    LPSTR lpszBuf = NULL;
    UINT cbBuf = 0;
    UINT cch;
    HDDEDATA hData;

    // Enumerate all the top level folders in the programs folder.
    SHGetSpecialFolderPath(NULL, szGroup, CSIDL_PROGRAMS, TRUE);
    PathAppend(szGroup, c_szStarDotStar);

    // We do a bunch of DDE work below, all of which is ANSI only.  This is
    // the cleanest point to break over from UNICODE to ANSI, so the conversion
    // is done here.
    // REARCHITECT - BobDay - Is this right? Can't we do all in unicode?

#ifdef UNICODE
    if (0 == WideCharToMultiByte(CP_ACP, 0, szGroup, -1, szAGroup, ARRAYSIZE(szAGroup), NULL, NULL))
    {
        return NULL;
    }
    hff = FindFirstFileA(szAGroup, &fd);
#else
    hff = FindFirstFile(szGroup, &fd);
#endif

    if (hff != INVALID_HANDLE_VALUE)
    {
        do
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (FindData_FileIsNormalA(&fd)))
            {
                LPSTR lpsz;
                // Data is seperated by \r\n.
                cch = lstrlenA(fd.cFileName) + 2;
                lpsz = (LPSTR)_LocalReAlloc(lpszBuf, cbBuf + (cch + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                if (lpsz)
                {
                    // Copy it over.
                    lpszBuf = lpsz;
                    // strcpy/strcat okay, we just allocated it above
                    lstrcpyA(lpszBuf + cbBuf, fd.cFileName);
                    lstrcatA(lpszBuf + cbBuf, c_szCRLF);
                    cbBuf = cbBuf + cch ;
                }
                else
                {
                    cbBuf = 0;
                    break;
                }
            }
        } while (FindNextFileA(hff, &fd));
        FindClose(hff);

        //
        // If the user is an admin, then we need to enumerate
        // the common groups also.
        //

        if (IsUserAnAdmin()) {

            SHGetSpecialFolderPath(NULL, szGroup, CSIDL_COMMON_PROGRAMS, TRUE);
            PathAppend(szGroup, c_szStarDotStar);

#ifdef UNICODE
            if (0 == WideCharToMultiByte(CP_ACP, 0, szGroup, -1, szAGroup, ARRAYSIZE(szAGroup), NULL, NULL))
            {
                return NULL;
            }
            hff = FindFirstFileA(szAGroup, &fd);
#else
            hff = FindFirstFile(szGroup, &fd);
#endif


            if (hff != INVALID_HANDLE_VALUE)
            {
                do
                {
                    if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                            (FindData_FileIsNormalA(&fd)))
                    {
                        LPSTR lpsz;
                         // Data is seperated by \r\n.
                         cch = lstrlenA(fd.cFileName) + 2;
                         lpsz = (LPSTR)_LocalReAlloc(lpszBuf, cbBuf + (cch + 1) * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                         if (lpsz)
                         {
                             // Copy it over.
                             lpszBuf = lpsz;
                             // strcpy/strcat okay, we just allocated it above
                             lstrcpyA(lpszBuf + cbBuf, fd.cFileName);
                             lstrcatA(lpszBuf + cbBuf, c_szCRLF);
                             cbBuf = cbBuf + cch ;
                         }
                         else
                         {
                             cbBuf = 0;
                             break;
                         }
                    }
                } while (FindNextFileA(hff, &fd));
                FindClose(hff);
            }
        }

        // Now package up the data and return.
        if (lpszBuf)
        {
            // Don't stomp on the last crlf, Word hangs while setting up
            // if this isn't present, just stick a null on the end.
            lpszBuf[cbBuf] = TEXT('\0');
            if (hszItem)
            {
                hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)lpszBuf, cbBuf+1, 0, hszItem, CF_TEXT, 0);
            }
            else
            {
                // Handle NULL hszItems (Logitech Fotomans installer does this). We need to create
                // a new hszItem otherwise DDEML gets confused (Null hszItems are only supposed to
                // be for DDE_EXECUTE data handles).
                TraceMsg(TF_WARNING, "EnumGroups: Invalid (NULL) hszItem used in request, creating new valid one.");
                hszItem = _DdeCreateStringHandle(g_dwDDEInst, c_szGroupsA, CP_WINANSI);
                hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)lpszBuf, cbBuf+1, 0, hszItem, CF_TEXT, 0);
                DdeFreeStringHandle(g_dwDDEInst, hszItem);
            }
            LocalFree(lpszBuf);
            return hData;
        }
    }

    // Empty list - Progman returned a single null.

    // (Davepl) I need to cast to LPBYTE since c_szNULLA is const.  If this
    // function doesn't really need to write to the buffer, it should be declared
    // as const.
    // (stephstm) This is a public documented fct, no chance it will change.

    hData = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)c_szNULLA, 1, 0, hszItem, CF_TEXT, 0);
    return hData;
}

// Crossties 1.0 doesn't like an empty icon path (which couldn't happen in 3.1)
// so we make one here.
void ConstructIconPath(LPTSTR pszIP, LPCTSTR pszCL, LPCTSTR pszWD)
{
    TCHAR sz[MAX_PATH];

    lstrcpyn(sz, pszCL, ARRAYSIZE(sz));
    PathRemoveArgs(sz);
    PathUnquoteSpaces(sz);
    FindExecutable(sz, pszWD, pszIP);
}

BOOL GroupItem_GetLinkInfo(LPCTSTR lpszGroupPath, PGROUPITEM pgi, LPCITEMIDLIST pidlLink,
    IShellFolder * psf, IShellLink *psl, IPersistFile *ppf)
{
    BOOL fRet = FALSE;

    ASSERT(pgi);
    ASSERT(pidlLink);
    ASSERT(psf);

    if (SHGetAttributes(psf, pidlLink, SFGAO_LINK))
    {
        TCHAR szName[MAX_PATH];

        // Get the relevant data.
        // Copy it.
        // Stick pointers in pgi.
        if (SUCCEEDED(DisplayNameOf(psf, pidlLink, SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
        {
            TCHAR sz[MAX_PATH], szCL[MAX_PATH];

            TraceMsg(TF_DDE, "Link %s", szName);

            pgi->pszDesc = StrDup(szName);
            PathCombine(sz, lpszGroupPath, szName);
            StrCatBuff(sz, c_szDotLnk, ARRAYSIZE(sz));
            // Read the link.
            // "name","CL",def dir,icon path,x,y,icon index,hotkey,minflag.
            ppf->Load(sz, 0);
            // Copy all the data.
            szCL[0] = TEXT('\0');
            if (SUCCEEDED(psl->GetPath(szCL, ARRAYSIZE(szCL), NULL, SLGP_SHORTPATH)))
            {
                // Valid CL?
                if (szCL[0])
                {
                    int nShowCmd;
                    TCHAR szArgs[MAX_PATH];

                    // Yep, Uses LFN's?
                    szArgs[0] = 0;
                    psl->GetArguments(szArgs, ARRAYSIZE(szArgs));
                    lstrcpyn(sz, szCL, ARRAYSIZE(sz));
                    if (szArgs[0])
                    {
                        StrCatBuff(sz, TEXT(" "), ARRAYSIZE(sz));
                        StrCatBuff(sz, szArgs, ARRAYSIZE(sz));
                    }
                    pgi->pszCL = StrDup(sz);
                    TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: CL %s", sz);
                    // WD
                    sz[0] = TEXT('\0');
                    psl->GetWorkingDirectory(sz, ARRAYSIZE(sz));
                    TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: WD %s", sz);
                    if (sz[0])
                    {
                        TCHAR szShortPath[MAX_PATH];
                        if (GetShortPathName(sz, szShortPath, ARRAYSIZE(szShortPath)))
                            lstrcpyn(sz, szShortPath, ARRAYSIZE(sz));
                    }

                    pgi->pszWD = StrDup(sz);
                    // Now setup the Show Command - Need to map to index numbers...
                    psl->GetShowCmd(&nShowCmd);
                    if (nShowCmd == SW_SHOWMINNOACTIVE)
                    {
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Show min.");
                        pgi->fMin = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Show normal.");
                        pgi->fMin = FALSE;
                    }
                    // Icon path.
                    sz[0] = TEXT('\0');
                    pgi->iIcon = 0;
                    psl->GetIconLocation(sz, ARRAYSIZE(sz), &pgi->iIcon);
                    if (pgi->iIcon < 0)
                        pgi->iIcon = 0;
                    if (sz[0])
                        PathGetShortPath(sz);
                    else
                        ConstructIconPath(sz, pgi->pszCL, pgi->pszWD);
                    TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: IL %s %d", sz, pgi->iIcon);
                    pgi->pszIconPath = StrDup(sz);
                    // Hotkey
                    pgi->wHotkey = 0;
                    psl->GetHotkey(&pgi->wHotkey);
                    // Success.
                    fRet = TRUE;
                }
                else
                {
                    // Deal with links to weird things.
                    TraceMsg(TF_DDE, "GroupItem_GetLinkInfo: Invalid command line.");
                }
            }
        }
    }

    return fRet;
}

int DSA_DestroyGroupCallback(LPVOID p, LPVOID d)
{
    PGROUPITEM pgi = (PGROUPITEM)p;
    LocalFree(pgi->pszDesc);
    LocalFree(pgi->pszCL);
    LocalFree(pgi->pszWD);
    LocalFree(pgi->pszIconPath);
    return 1;
}


// Return the links in a group.
HDDEDATA EnumItemsInGroup(HSZ hszItem, LPCTSTR lpszGroup)
{
    HDDEDATA hddedata = HDDENULL;
    int cItems = 0;

    TraceMsg(TF_DDE, "c.eiig: Enumerating %s.", (LPTSTR)lpszGroup);


    //
    // Get personal group location
    //

    TCHAR sz[MAX_PATH];
    if (!SHGetSpecialFolderPath(NULL, sz, CSIDL_PROGRAMS, FALSE)) {
        return NULL;
    }

    PathAddBackslash(sz);
    StrCatBuff(sz, lpszGroup, ARRAYSIZE(sz));

    //
    // Test if the group exists.
    //

    BOOL bCommon = FALSE;
    WIN32_FIND_DATA fd;
    HANDLE hFile = FindFirstFile (sz, &fd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        if (SHRestricted(REST_NOCOMMONGROUPS))
        {
            return NULL;
        }

        //
        // Personal group doesn't exist.  Try a common group.
        //

        if (!SHGetSpecialFolderPath(NULL, sz, CSIDL_COMMON_PROGRAMS, FALSE))
        {
            return NULL;
        }

        PathAddBackslash(sz);
        StrCatBuff(sz, lpszGroup, ARRAYSIZE(sz));
        bCommon = TRUE;
    }
    else
    {
        FindClose (hFile);
    }

    HDSA hdsaGroup = DSA_Create(sizeof(GROUPITEM), 0);
    if (hdsaGroup)
    {
        BOOL fOK = FALSE;

        // Get the group info.
        LPITEMIDLIST pidlGroup = ILCreateFromPath(sz);
        if (pidlGroup)
        {
            IShellFolder *psf;
            if (SUCCEEDED(SHBindToObjectEx(NULL, pidlGroup, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                LPENUMIDLIST penum;
                if (S_OK == psf->EnumObjects(NULL, SHCONTF_NONFOLDERS, &penum))
                {
                    IShellLink *psl;
                    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl))))
                    {
                        IPersistFile *ppf;
                        if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
                        {
                            LPITEMIDLIST pidl;
                            ULONG celt;
                            while ((penum->Next(1, &pidl, &celt) == NOERROR) && (celt == 1))
                            {
                                GROUPITEM gi;
                                if (GroupItem_GetLinkInfo(sz, &gi, pidl, psf, psl, ppf))
                                {
                                    // Add it to the list
                                    DSA_InsertItem(hdsaGroup, cItems, &gi);
                                    cItems++;
                                }
                                ILFree(pidl);
                            }
                            fOK = TRUE;
                            ppf->Release();
                        }
                        psl->Release();
                    }
                    penum->Release();
                }
                psf->Release();
            }
            ILFree(pidlGroup);
        }
        else
        {
            TraceMsg(DM_ERROR, "c.eiig: Can't create IDList for path..");
        }

        if (fOK)
        {
            // Create dde data.
            TraceMsg(TF_DDE, "c.eiig: %d links", cItems);

            // "Group Name",path,#items,showcmd
            PathGetShortPath(sz);
            TCHAR szLine[MAX_PATH*4];
            wnsprintf(szLine, ARRAYSIZE(szLine), TEXT("\"%s\",%s,%d,%d,%d\r\n"), lpszGroup, sz, cItems, SW_SHOWNORMAL, bCommon);
            UINT cchDDE = lstrlen(szLine)+1;
            LPTSTR pszDDE = (LPTSTR)LocalAlloc(LPTR, cchDDE * sizeof(TCHAR));
            if (pszDDE)
            {
                lstrcpyn(pszDDE, szLine, cchDDE);
                cItems--;
                while (cItems >= 0)
                {
                    PGROUPITEM pgi = (GROUPITEM*)DSA_GetItemPtr(hdsaGroup, cItems);
                    ASSERT(pgi);
                    // Fake up reasonable coords.
                    int x = ((cItems%ITEMSPERROW)*64)+32;
                    int y = ((cItems/ITEMSPERROW)*64)+32;
                    // "name","CL",def dir,icon path,x,y,icon index,hotkey,minflag.
                    wnsprintf(szLine, ARRAYSIZE(szLine), TEXT("\"%s\",\"%s\",%s,%s,%d,%d,%d,%d,%d\r\n"), pgi->pszDesc, pgi->pszCL,
                        pgi->pszWD, pgi->pszIconPath, x, y, pgi->iIcon, pgi->wHotkey, pgi->fMin);
                    cchDDE += lstrlen(szLine) + 1;
                    LPTSTR pszRealloc = (LPTSTR)_LocalReAlloc((HLOCAL)pszDDE, cchDDE * sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
                    if (pszRealloc)
                    {
                        pszDDE = pszRealloc;
                        StrCatBuff(pszDDE, szLine, cchDDE);
                        cItems--;
                    }
                    else
                    {
                        TraceMsg(DM_ERROR, "c.eiig: Unable to realocate DDE line.");
                        break;
                    }
                }

                // Multiply by two, for worst case, where every char was a multibyte char
                int cbADDE = lstrlen(pszDDE) * 2;       // Trying to make an ANSI string!!!
                LPSTR pszADDE = (LPSTR)LocalAlloc(LPTR, cbADDE + 2);
                if (pszADDE)
                {
                    WideCharToMultiByte(CP_ACP, 0, pszDDE, -1, pszADDE, cbADDE, NULL, NULL);

                    hddedata = DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)pszADDE, cbADDE, 0, hszItem, CF_TEXT, 0);
                    LocalFree(pszADDE);
                }
                else
                {
                    TraceMsg(DM_ERROR, "c.eiig: Can't allocate ANSI buffer.");
                }
                LocalFree(pszDDE);
            }
        }
        else
        {
            TraceMsg(DM_ERROR, "c.eiig: Can't create group list.");
        }
        
        DSA_DestroyCallback(hdsaGroup, DSA_DestroyGroupCallback, 0);
    }

    return hddedata;
}


HDDEDATA DDE_HandleRequest(HSZ hszItem, HCONV hconv)
{
    TCHAR szGroup[MAX_PATH];
    PDDECONV pddec;

    TraceMsg(TF_DDE, "DDEML Request(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

    pddec = DDE_MapHConv(hconv);
    if (pddec == NULL)
        return HDDENULL;

    DDEConv_Release(pddec);
    
    DdeQueryString(g_dwDDEInst, hszItem, szGroup, ARRAYSIZE(szGroup), CP_WINNATURAL);

    TraceMsg(TF_DDE, "Request for item %s.", (LPTSTR) szGroup);
    // There's a bug in Progman where null data returns the list of groups.
    // Logitech relies on this behaviour.
    if (szGroup[0] == TEXT('\0'))
    {
        return EnumGroups(hszItem);
    }
    // Special case group names of "Groups" or "Progman" and return the list
    // of groups instead.
    else if (lstrcmpi(szGroup, c_szGroupGroup) == 0 || lstrcmpi(szGroup, c_szTopic) == 0)
    {
        return EnumGroups(hszItem);
    }
    // Special case winoldapp properties.
    else if (lstrcmpi(szGroup, c_szGetIcon) == 0 ||
        lstrcmpi(szGroup, c_szGetDescription) == 0 ||
        lstrcmpi(szGroup, c_szGetWorkingDir) == 0)
    {
        return HDDENULL;
    }
    // Assume it's a group name.
    else
    {
        return EnumItemsInGroup(hszItem, szGroup);
    }
}


// Support Disconnect
void DDE_HandleDisconnect(HCONV hconv)
{
    PDDECONV pddecPrev = NULL;
    PDDECONV pddec;

    TraceMsg(TF_DDE, "DDEML Disconnect(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

    // Find the conversation in the list of them and free it.
    ENTERCRITICAL;
    for (pddec = g_pddecHead; pddec != NULL; pddec = pddec->pddecNext)
    {
        if (pddec->hconv == hconv)
        {
            // Found it, so first unlink it
            // pass the next reference back up the chain.
            if (pddecPrev == NULL)
                g_pddecHead = pddec->pddecNext;
            else
                pddecPrev->pddecNext = pddec->pddecNext;

            pddec->pddecNext = NULL;

            break;

        }
        pddecPrev = pddec;
    }
    LEAVECRITICAL;

    // Now Free it outside of critical section
    if (pddec)
        DDEConv_Release(pddec);

    g_hwndDde = NULL;
}


// Support wildcard topics.
HDDEDATA DDE_HandleWildConnects(void)
{
    HSZPAIR hszpair[4];

    TraceMsg(TF_DDE, "DDEML wild connect.");

    hszpair[0].hszSvc = g_hszService;
    hszpair[0].hszTopic = g_hszTopic;
    hszpair[1].hszSvc = g_hszShell;
    hszpair[1].hszTopic = g_hszAppProps;
    hszpair[2].hszSvc = g_hszFolders;
    hszpair[2].hszTopic = g_hszAppProps;
    hszpair[3].hszSvc = HSZNULL;
    hszpair[3].hszTopic = HSZNULL;

    return DdeCreateDataHandle(g_dwDDEInst, (LPBYTE)&hszpair, sizeof(hszpair), 0, HSZNULL, CF_TEXT, 0);
}


// App hack flags for DDE.
// REVIEW UNDONE - Read these from the registry so we can app hack on the fly.

// Bodyworks.
// Uses PostMessage(-1,...) to talk to the shell and DDEML
// can't handle that level of abuse. By having DDEML ignore the command
// it'll get forwarded through to the desktop which can handle it. Sigh.

// CCMail.
// Can't handle being installed via a UNC but unlike most app that have
// problems with UNC's they appear to set up fine - you'll just have
// lots of problems trying to run the app. We handle this by faking
// up a drive connection for them. We don't want to do this generally
// since the user could easily run out of drive letters.

// Discis. [There are dozens of Discis apps that use the same setup.]
// Can't handle getting activate messages out of order with DDE (which
// happens easily now). They end up spinning in a loop looking for an
// ACK they've already got. We hack around this by detecting them being
// hung and post them another ack. We keep doing that until they wake
// up and start talking to us again.

// Media Recorder.
// Their app wants to be single instance so at init they search for
// windows with the TITLE (!!!) of "MediaRecorder". If you launch
// them from their own folder (which has the title "MediaRecorder" then
// they refuse to run. We fix this by mapping their group name at
// setup time.

// Trio DataFax.
// This app wants to add something to the startup group but doesn't
// know what it's called so it tries to load the Startup string out
// of Progman. If Progman isn't running they try to create a group
// with a NULL title. We detect this case and map them to the new
// startup group name.

// TalkToPlus.
// They try to make a link to Terminal.exe and abort their setup
// if the AddItem fails. We fix this my forcing the AddItem to
// return success.

// Winfax Pro 4.0.
// They use the shell= line in win.ini for the service/topic so
// they end up talking to the shell using Explorer/Explorer!
// They also talk to the LAST responder to the init broadcast
// instead of the first AND they use SendMsg/Free instead of waiting for
// Acks. We fix this by allowing their service/topic to work, and have
// the desktop copy the data before sending it through to DDEML.
// REVIEW We key off the fact that their dde window is a dialog with no
// title - seems a bit broad to me.

// The Journeyman Project.
// This app causes damage to space-time. We fix it by generating a
// small HS-field around their installer.

// CA apps in general.
// Don't bother sending DDE_INIT's before sending the execute commands.
// We fix it by doing the init on the fly if needed.

// Faxserve.
// Broadcasts their EXEC commands. Their class name is "install" which
// is a bit too generic for my liking but since we handle this problem
// by forcing everything to go through the desktop it's not very risky.

struct {
    LPCTSTR pszClass;
    LPCTSTR pszTitle;
    DWORD id;
} const c_DDEApps[] = {
    c_szMrPostman,          NULL,           DDECONV_NO_INIT,
    c_szBodyWorks,          NULL,           DDECONV_FAIL_CONNECTS,
    c_szCCMail,             NULL,           DDECONV_NO_UNC,
    c_szDiscis,             NULL,           DDECONV_REPEAT_ACKS,
    c_szMediaRecorder,      NULL,           DDECONV_MAP_MEDIA_RECORDER,
    c_szTrioDataFax,        NULL,           DDECONV_NULL_FOR_STARTUP,
    c_szTalkToPlus,         NULL,           DDECONV_ALLOW_INVALID_CL,
    c_szDialog,             c_szMakePMG,    DDECONV_REPEAT_ACKS,
    c_szDialog,             c_szNULL,       DDECONV_EXPLORER_SERVICE_AND_TOPIC|DDECONV_USING_SENDMSG,
    c_szJourneyMan,         NULL,           DDECONV_EXPLORER_SERVICE_AND_TOPIC,
    c_szCADDE,              NULL,           DDECONV_NO_INIT,
    c_szFaxServe,           NULL,           DDECONV_FAIL_CONNECTS
};


DWORD GetDDEAppFlagsFromWindow(HWND hwnd)
{
    if (hwnd && !Window_IsLFNAware(hwnd))
    {
        TCHAR szClass[MAX_PATH];

        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
        for (int i = 0; i < ARRAYSIZE(c_DDEApps); i++)
        {
            // NB Keep this case sensative to narrow the scope a bit.
            if (lstrcmp(szClass, c_DDEApps[i].pszClass) == 0)
            {
                // Do we care about the title?
                if (c_DDEApps[i].pszTitle)
                {
                    TCHAR szTitle[MAX_PATH];

                    GetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle));
                    if (lstrcmp(szTitle, c_DDEApps[i].pszTitle) == 0)
                    {
                        TraceMsg(TF_DDE, "App flags 0x%x for %s %s.", c_DDEApps[i].id, c_DDEApps[i].pszClass, c_DDEApps[i].pszTitle);
                        return c_DDEApps[i].id;
                    }
                }
                else
                {
                    // Nope.
                    TraceMsg(TF_DDE, "App flags 0x%x for %s.", c_DDEApps[i].id, c_DDEApps[i].pszClass);
                    return c_DDEApps[i].id;
                }
            }
        }
    }

    return DDECONV_NONE;
}


DWORD GetDDEAppFlags(HCONV hconv)
{
    return GetDDEAppFlagsFromWindow(_GetDDEPartnerWindow(hconv));
}


HDDEDATA DDE_HandleConnect(HSZ hsz1, HSZ hsz2)
{
    if ((hsz1 == g_hszTopic && hsz2 == g_hszService) ||
        (hsz1 == g_hszAppProps && hsz2 == g_hszShell) ||
        (hsz1 == g_hszAppProps && hsz2 == g_hszFolders))
    {
        TraceMsg(TF_DDE, "DDEML Connect.");
        return (HDDEDATA)DDE_FACK;
    }
    else
    {
        // Unknown topic/service.
        TraceMsg(TF_DDE, "DDEML Connect - unknown service/topic.");
        return (HDDEDATA)NULL;
    }
}


// Returns TRUE if the drive where the Programs folder is supports LFNs.
BOOL _SupportLFNGroups(void)
{
    TCHAR szPrograms[MAX_PATH];
    DWORD dwMaxCompLen = 0;
    
    SHGetSpecialFolderPath(NULL, szPrograms, CSIDL_PROGRAMS, TRUE);
    return IsLFNDrive(szPrograms);
}


// REVIEW HACK - Don't just caste, call GetConvInfo() to get this. We can't
// do this as yet because of a bug in the thunk layer.
#define _GetDDEWindow(hconv)    ((HWND)hconv)


HDDEDATA DDE_HandleConnectConfirm(HCONV hconv)
{
    DWORD dwAppFlags = GetDDEAppFlags(hconv);
    PDDECONV pddec;

    if (dwAppFlags & DDECONV_FAIL_CONNECTS)
    {
        DdeDisconnect(hconv);
        return FALSE;
    }

    pddec = DDEConv_Create();
    if (pddec)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&pddec->psl)))
        {
            pddec->hconv = hconv;
            // pddec->szGroup[0] = '\0';   // implicit
            // pddec->fDirty = FALSE;      // implicit
            // protect access to global list
            ENTERCRITICAL;
            pddec->pddecNext = g_pddecHead;
            g_pddecHead = pddec;
            LEAVECRITICAL;

            TraceMsg(TF_DDE, "DDEML Connect_CONFIRM(" SPRINTF_PTR ") - OK.", (DWORD_PTR)hconv);

            // Do we support LFN groups?
            g_LFNGroups = _SupportLFNGroups();
            // Tell the desktops DDE code we're handling things from here.
            g_hwndDde = _GetDDEWindow(hconv);
            // No conversation yet (wild connect?) - signal it with a hwnd -1.
            if (!g_hwndDde)
                g_hwndDde = (HWND)-1;
            // Keep track of the app hacks.
            pddec->dwFlags = dwAppFlags;

            // Success.
            return (HDDEDATA)DDE_FACK;
        }
        TraceMsg(TF_DDE, "Unable to create IShellLink interface.");

        DDEConv_Release(pddec);
    }
    else
    {
        TraceMsg(TF_ERROR, "Unable to allocate memory for tracking dde conversations.");
    }
    return (HDDEDATA)NULL;
}


HDDEDATA CALLBACK DDECallback(UINT type, UINT fmt, HCONV hconv,
        HSZ hsz1, HSZ hsz2,HDDEDATA  hData, ULONG_PTR dwData1, ULONG_PTR dwData2)
{
    switch (type)
    {
    case XTYP_CONNECT:
        return DDE_HandleConnect(hsz1, hsz2);

    case XTYP_WILDCONNECT:
        return DDE_HandleWildConnects();

    case XTYP_CONNECT_CONFIRM:
        return DDE_HandleConnectConfirm(hconv);

    case XTYP_REGISTER:
    case XTYP_UNREGISTER:
        return (HDDEDATA) NULL;

    case XTYP_ADVDATA:
        return (HDDEDATA) DDE_FACK;

    case XTYP_XACT_COMPLETE:
        return (HDDEDATA) NULL;

    case XTYP_DISCONNECT:
        DDE_HandleDisconnect(hconv);
        return (HDDEDATA) NULL;

    case XTYP_EXECUTE:
        return HandleDDEExecute(hData, hconv);

    case XTYP_REQUEST:
        if (hsz1 == g_hszTopic || hsz1 == g_hszAppProps)
        {
            return DDE_HandleRequest(hsz2, hconv);
        }
        else
        {
            TraceMsg(TF_DDE, "DDEML Request - Invalid Topic.");
            return (HDDEDATA) NULL;
        }

    default:
        return (HDDEDATA) NULL;

    }
}

static BOOL s_bDDEInited = FALSE;
ATOM g_aProgman = 0;

void UnInitialiseDDE(void)
{
    if (g_dwDDEInst)
    {
        DDE_RemoveShellServices();

        DdeNameService(g_dwDDEInst, g_hszFolders,  HSZNULL, DNS_UNREGISTER);

        _DdeFreeStringHandle(g_dwDDEInst, g_hszTopic);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszService);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszStar);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszShell);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszAppProps);
        _DdeFreeStringHandle(g_dwDDEInst, g_hszFolders);

        if (!DdeUninitialize(g_dwDDEInst))
        {
            TraceMsg(TF_DDE, "DDE Un-Initialization failure.");
        }

        g_dwDDEInst = 0;
    }

    if (g_aProgman)
    {
        g_aProgman = GlobalDeleteAtom(g_aProgman);
    }

    s_bDDEInited = FALSE;
}


void InitialiseDDE(void)
{
    DBG_ENTER(FTF_DDE, InitialiseDDE);

    if (s_bDDEInited)
    {
        // No need to do this twice
        return;
    }

    // Hack for Alone In the Dark 2.
    // They do a case sensative comparison of the progman atom and they
    // need it to be uppercase.
    g_aProgman = GlobalAddAtom(TEXT("PROGMAN"));

    if (DdeInitialize(&g_dwDDEInst, DDECallback, CBF_FAIL_POKES | CBF_FAIL_ADVISES, 0L) == DMLERR_NO_ERROR)
    {
        g_hszTopic = _DdeCreateStringHandle(g_dwDDEInst, c_szTopic, CP_WINNATURAL);
        g_hszService = _DdeCreateStringHandle(g_dwDDEInst, c_szService, CP_WINNATURAL);
        g_hszStar = _DdeCreateStringHandle(g_dwDDEInst, c_szStar, CP_WINNATURAL);
        g_hszShell = _DdeCreateStringHandle(g_dwDDEInst, c_szShell, CP_WINNATURAL);
        g_hszAppProps = _DdeCreateStringHandle(g_dwDDEInst, c_szAppProps, CP_WINNATURAL);
        g_hszFolders = _DdeCreateStringHandle(g_dwDDEInst, c_szFolders, CP_WINNATURAL);
    
        if (g_hszTopic && g_hszService && g_hszStar && g_hszShell && g_hszAppProps && g_hszFolders)
        {
            if (DdeNameService(g_dwDDEInst, g_hszFolders,  HSZNULL, DNS_REGISTER) &&
                DDE_AddShellServices())
            {
                s_bDDEInited = TRUE;
            }
        }
    }

    if (!s_bDDEInited)
    {
        UnInitialiseDDE();
    }

    DBG_EXIT(FTF_DDE, InitialiseDDE);
}


BOOL DDE_AddShellServices(void)
{
    // Only register these if we are the shell...
    if (DdeNameService(g_dwDDEInst, g_hszService,  HSZNULL, DNS_REGISTER) &&
        DdeNameService(g_dwDDEInst, g_hszShell,  HSZNULL, DNS_REGISTER))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


void DDE_RemoveShellServices(void)
{
    ASSERT(g_dwDDEInst);

    DdeNameService(g_dwDDEInst, g_hszService,  HSZNULL, DNS_UNREGISTER);
    DdeNameService(g_dwDDEInst, g_hszShell,  HSZNULL, DNS_UNREGISTER);
}



BOOL GetGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew)
{
    DWORD dwType;
    DWORD cbNew = cchNew * sizeof(TCHAR);

    return ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szMapGroups, lpszOld, &dwType, (LPVOID)lpszNew, &cbNew);
}

void MapGroupName(LPCTSTR lpszOld, LPTSTR lpszNew, ULONG cchNew)
{
    if (!GetGroupName(lpszOld, lpszNew, cchNew))
    {
        lstrcpyn(lpszNew, lpszOld, cchNew);
    }
}

STDAPI_(BOOL) DDEHandleViewFolderNotify(IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER pnm)
{
    BOOL fRet = FALSE;
    UINT *pwCmd = GetDDECommands(pnm->szCmd, c_sDDECommands, FALSE);

    // -1 means there aren't any commands we understand.  Oh, well
    if (pwCmd && (-1 != *pwCmd))
    {
        UINT *pwCmdSave = pwCmd;
        UINT c = *pwCmd++;

        LPCTSTR pszCommand = c_sDDECommands[c].pszCommand;

        ASSERT(c < ARRAYSIZE(c_sDDECommands));

        if (pszCommand == c_szViewFolder || 
            pszCommand == c_szExploreFolder)
        {
            fRet = DoDDE_ViewFolder(psb, hwnd, pnm->szCmd, pwCmd,
                    pszCommand == c_szExploreFolder, pnm->dwHotKey, pnm->hMonitor);
        }
        else if (pszCommand == c_szShellFile)
        {
            fRet = DDE_ShellFile(pnm->szCmd, pwCmd, 0);
        }

        GlobalFree(pwCmdSave);
    }

    return fRet;
} 

STDAPI_(LPNMVIEWFOLDER) DDECreatePostNotify(LPNMVIEWFOLDER pnm)
{
    LPNMVIEWFOLDER pnmPost = NULL;
    TCHAR szCmd[MAX_PATH * 2];
    StrCpyN(szCmd, pnm->szCmd, ARRAYSIZE(szCmd));
    UINT *pwCmd = GetDDECommands(szCmd, c_sDDECommands, FALSE);

    // -1 means there aren't any commands we understand.  Oh, well
    if (pwCmd && (-1 != *pwCmd))
    {
        LPCTSTR pszCommand = c_sDDECommands[*pwCmd].pszCommand;

        ASSERT(*pwCmd < ARRAYSIZE(c_sDDECommands));

        //
        //  these are the only commands handled by a PostNotify
        if (pszCommand == c_szViewFolder 
        ||  pszCommand == c_szExploreFolder
        ||  pszCommand == c_szShellFile)
        {
            pnmPost = (LPNMVIEWFOLDER)LocalAlloc(LPTR, sizeof(NMVIEWFOLDER));

            if (pnmPost)
                memcpy(pnmPost, pnm, sizeof(NMVIEWFOLDER));
        }

        GlobalFree(pwCmd);
    }

    return pnmPost;
}
   


LRESULT _ForwardDDEMsgs(HWND hwnd, HWND hwndForward, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    TraceMsg(TF_DDE, "c.fdm: Forwarding DDE to %x", hwndForward);

    if (hwndForward && IsWindow(hwndForward))
    {
        TraceMsg(TF_DDE, "c.fdm: %lx %lx %lx", uMsg, (WPARAM)hwnd, lParam);
        if (fSend)
            return SendMessage(hwndForward, uMsg, (WPARAM)hwnd, lParam);
        else
            return PostMessage(hwndForward, uMsg, (WPARAM)hwnd, lParam);
    }
    else
    {
        TraceMsg(TF_DDE, "c.fdm: Invalid DDEML window, Can't forward DDE messages.");
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}


// Set/cleared by dde connect/disconnect.
const TCHAR c_szExplorerTopic[] = TEXT("Explorer");
const TCHAR c_szDMGFrame[] = TEXT("DMGFrame");  // This is the 16-bit/Win95 window class name


// Broadcast to all ddeml server windows.

void DDEML_Broadcast(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd)
    {
        TCHAR szClass[32];
        if (GetClassName(hwnd, szClass, ARRAYSIZE(szClass)))
        {
            if ((lstrcmp(szClass, c_szDMGFrame) == 0) ||
                (lstrcmp(szClass, TEXT("DDEMLMom")) == 0))    // this is the 32-bit NT window class name
                SendMessage(hwnd, uMsg, wParam, lParam);
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
}



LRESULT _HandleDDEInitiateAndAck(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL g_fInInit = FALSE;
    ATOM aProgman;
    TCHAR szService[32];
    TCHAR szTopic[32];
    TCHAR szClass[32];
    WPARAM uHigh, uLow;
    BOOL fForceAccept = FALSE;

    if (uMsg == WM_DDE_INITIATE)
    {
        TraceMsg(TF_DDE, "c.hdi: Init.");

        // Don't handle DDE messages if we're already using DDEML. This happens when apps
        // broadcast DDE_INIT and don't stop on the first reply. Both our DDEML window and
        // the desktop end up replying. Most apps don't care and just talk to the first or
        // the last one but Ventura gets confused and thinks it's finished doing DDE when it
        // gets the second ACK and destroys it's internal DDE window.
        if (g_hwndDde)
        {
            TraceMsg(TF_DDE, "c.fpwp: Not forwarding DDE, DDEML is handing it.");
            KillTimer(hwnd, IDT_DDETIMEOUT);
        }
        // Are we re-cursing?
        else if (!g_fInInit)
        {
            // Nope, Is this for Progman, Progman or Shell, AppProperties?
            if (lParam)
            {
                GlobalGetAtomName(LOWORD(lParam), szService, ARRAYSIZE(szService));
                GlobalGetAtomName(HIWORD(lParam), szTopic, ARRAYSIZE(szTopic));
            }
            else
            {
                // Progman allowed a null Service & a null Topic to imply Progman, Progman.
                szService[0] = TEXT('\0');
                szTopic[0] = TEXT('\0');
                fForceAccept = TRUE;
            }

            // Keep track of hacks, we reset this on the disconnect.
            g_dwAppFlags = GetDDEAppFlagsFromWindow((HWND)wParam);

            // Hacks for WinFax and Journeyman Project.
            if ((g_dwAppFlags & DDECONV_EXPLORER_SERVICE_AND_TOPIC)
                && (lstrcmpi(szTopic, c_szExplorerTopic) == 0)
                && (lstrcmpi(szService, c_szExplorerTopic) == 0))
            {
                fForceAccept = TRUE;
            }

            if (((lstrcmpi(szTopic, c_szTopic) == 0) && (lstrcmpi(szService, c_szService) == 0)) ||
                fForceAccept)
            {
                TraceMsg(TF_DDE, "c.hdi: Init on [Progman,Progman] - needs forwarding.");
                // Nope go find it.
                // NB This will cause an echo on every DDE_INIT for Progman, Progman after booting.
                // It shouldn't be a problem :-)
                // Keep track of who to send Acks back to.
                g_hwndClient = (HWND)wParam;
                // Now find the real shell.
                aProgman = GlobalAddAtom(c_szService);
                TraceMsg(TF_DDE, "c.d_hdm: Finding shell dde handler...");
                g_fInInit = TRUE;
                // SendMessage(HWND_BROADCAST, WM_DDE_INITIATE, (WPARAM)hwnd, MAKELPARAM(aProgman, aProgman));
                DDEML_Broadcast(WM_DDE_INITIATE, (WPARAM)hwnd, MAKELPARAM(aProgman, aProgman));
                g_fInInit = FALSE;
                TraceMsg(TF_DDE, "c.d_hdm: ...Done");
                GlobalDeleteAtom(aProgman);
            }
            else
            {
                TraceMsg(TF_DDE, "c.hdi: Init on something other than [Progman,Progman] - Ignoring");
                KillTimer(hwnd, IDT_DDETIMEOUT);
            }
        }
        else
        {
            TraceMsg(TF_DDE, "c.hdi: Recursing - Init ignored.");
        }
        return 0;
    }
    else if (uMsg == WM_DDE_ACK)
    {
        TraceMsg(TF_DDE, "c.hdi: Ack.");
        // Is this in response to the DDE_Init above?
        if (g_fInInit)
        {
            // Yep, keep track of who we're talking too.
            GetClassName((HWND)wParam, szClass, ARRAYSIZE(szClass));
            TraceMsg(TF_DDE, "c.d_hdm: Init-Ack from %x (%s).", wParam, szClass);
            g_hwndDDEML = (HWND)wParam;
            // The forward it back (send it, don't post it - Breaks Prodogy).
            return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, (WPARAM)hwnd, lParam, TRUE);
        }
        else
        {
            // Nope, just forward it back.

            // Hack for WinFaxPro.
            if (g_dwAppFlags & DDECONV_USING_SENDMSG)
            {
                // We copied the data before sending it on so we can free it here.
                // WinFax ignores the reply so don't bother sending it.
                UnpackDDElParam(uMsg, lParam, &uLow, &uHigh);
                if (uHigh)
                    GlobalFree((HGLOBAL)uHigh);
                return 0;
            }

            return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, (WPARAM)hwnd, lParam, FALSE);
        }
    }
    return 0;
}


LRESULT _HandleDDEForwardBiDi(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if ((HWND)wParam == g_hwndDDEML)
        return _ForwardDDEMsgs(hwnd, g_hwndClient, uMsg, wParam, lParam, FALSE);
    else if ((HWND)wParam == g_hwndClient)
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    else
        return 0;
}


LRESULT _HandleDDETerminate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndClient;

    TraceMsg(DM_TRACE, "c.hddet: Terminate.");

    if ((HWND)wParam == g_hwndDDEML)
    {
        // This should be the last message (a terminate from ddeml to the client).
        // Cleanup now.
        KillTimer(hwnd, IDT_DDETIMEOUT);
        TraceMsg(DM_TRACE, "c.hddet: Cleanup.");
        hwndClient = g_hwndClient;
        g_hwndClient = NULL;
        g_hwndDDEML = NULL;
        g_dwAppFlags = DDECONV_NONE;
        return _ForwardDDEMsgs(hwnd, hwndClient, uMsg, wParam, lParam, FALSE);
    }
    else if ((HWND)wParam == g_hwndClient)
    {
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    }
    else
    {
        return 0;
    }
}


LRESULT _HandleDDEExecute(HWND hwnd, HWND hwndForward, UINT uMsg,
        WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    ATOM aApp, aTopic;
    HANDLE hNew;
    LPTSTR pNew, pOld;

    // NB WinFaxPro does a Send/Free which avoids Users DDE hack
    // and means they get to delete the data while we're in
    // the middle of using it so we must copy it here. We'll
    // clean it up on the Ack.
    // NB WinFaxPro re-uses the same 16bit selector for all their
    // messages which the thunk layer can't handle it. We need to
    // defect the 32bit side (and free it) so the next time they
    // send the 16bit handle through the thunk layer they get a
    // new 32bit version.
    if (g_dwAppFlags & DDECONV_USING_SENDMSG)
    {
        SIZE_T cb = GlobalSize((HGLOBAL)lParam);
        hNew = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cb);
        if (hNew)
        {
            // Copy the old data.
            pNew = (LPTSTR)GlobalLock(hNew);
            pOld = (LPTSTR)GlobalLock((HGLOBAL)lParam);
            hmemcpy(pNew, pOld, cb);
            GlobalUnlock((HGLOBAL)lParam);
            GlobalUnlock(hNew);
            GlobalFree((HGLOBAL)lParam);
            // Use our copy.
            lParam = (LPARAM)hNew;
        }
    }

    // NB CA neglect to send a DDE_INIT, they just start
    // throwing DDE_EXEC's at us so we fake up an init
    // from them to DDEML to get things rolling.
    if (!hwndForward)
    {
        if (!(g_dwAppFlags & DDECONV_NO_INIT))
           g_dwAppFlags = GetDDEAppFlagsFromWindow((HWND)wParam);

        if (g_dwAppFlags & DDECONV_NO_INIT)
        {
            aApp = GlobalAddAtom(c_szService);
            aTopic = GlobalAddAtom(c_szTopic);
            SendMessage(hwnd, WM_DDE_INITIATE, wParam, MAKELPARAM(aApp, aTopic));
            GlobalDeleteAtom(aApp);
            GlobalDeleteAtom(aTopic);
            hwndForward = g_hwndDDEML;
        }
    }

    return _ForwardDDEMsgs(hwnd, hwndForward, uMsg, wParam, lParam, fSend);
}


// hacks to get various apps installed (read: ATM). These are the people
// who do a FindWindow for Progman and then do dde to it directly.
// These people should not be allowed to write code.
STDAPI_(LRESULT) DDEHandleMsgs(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TraceMsg(TF_DDE, "c.fpwp: Forwarding DDE.");

    SetTimer(hwnd, IDT_DDETIMEOUT, 30*1000, NULL);

    switch (uMsg)
    {
    case WM_DDE_INITIATE:
    case WM_DDE_ACK:
        return _HandleDDEInitiateAndAck(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_TERMINATE:
        return _HandleDDETerminate(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_DATA:
        return _HandleDDEForwardBiDi(hwnd, uMsg, wParam, lParam);
        
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
        return _ForwardDDEMsgs(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
        
    case WM_DDE_EXECUTE:
        return _HandleDDEExecute(hwnd, g_hwndDDEML, uMsg, wParam, lParam, FALSE);
    }
    return 0;
}


// Some installers (Wep2) forget to Terminate a conversation so we timeout
// after not getting any dde-messages for a while. If we don't, and you run
// a Wep2 install a second time we think the installer is already talking via
// ddeml so we don't reply from the desktop. Wep2 then thinks Progman isn't
// running, does a WinExec of Progman and hangs waiting to talk to it. Progman
// never replies since it is not the shell. Nasty Nasty Nasty.
STDAPI_(void) DDEHandleTimeout(HWND hwnd)
{
    HWND hwndClient, hwndDDEML;

    TraceMsg(DM_TRACE, "c.hdt: DDE Timeout.");

    KillTimer(hwnd, IDT_DDETIMEOUT);

    // Has everything gone away yet?
    if (g_hwndDDEML && g_hwndClient)
    {
        // Nope. Don't want to forward anymore.
        hwndClient = g_hwndClient;
        hwndDDEML = g_hwndDDEML;
        g_hwndClient = NULL;
        g_hwndDDEML = NULL;
        g_dwAppFlags = DDECONV_NONE;
        // Shutdown our ddeml alter-ego.
        // NB If the client window has already gone away (very likely) it's not a
        // problem, ddeml will skip posting the reply but will still do the
        // disconnect callback.
        PostMessage(hwndDDEML, WM_DDE_TERMINATE, (WPARAM)hwnd, 0);
    }
}





// INTERNAL EXPORT FUNCTION:
// This is for explorer to call to initialize and uninitialize SHELL DDE
// services.
void WINAPI ShellDDEInit(BOOL fInit)
{
    if (fInit)
        InitialiseDDE();
    else
        UnInitialiseDDE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dcompp.cpp ===
#include "stdafx.h"
#pragma hdrstop

class CCompPreview
{
public:
protected:
    HWND _hwnd;
    HBITMAP _hbmMonitor;
    HDC _hdcCompMemory;
    int _iScreenWidth;
    int _iScreenHeight;
    int _iXBorders;
    int _iYBorders;

    static LRESULT CALLBACK CompPreviewWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
    friend BOOL RegisterCompPreviewClass(void);

    LONG _OnCreate(HWND hwnd);
    void _OnDestroy(void);
    void _OnPaint(void);
    void _RecalcMetrics(void);
};

void CCompPreview::_RecalcMetrics(void)
{
    RECT rect;
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, FALSE);
    _iScreenWidth = rect.right - rect.left;
    _iScreenHeight = rect.bottom - rect.top;
    _iXBorders = (2 * GET_CXSIZE);
    _iYBorders = (GET_CYSIZE + GET_CYCAPTION);
}

LONG CCompPreview::_OnCreate(HWND hwnd)
{
    LONG lRet = 0;

    _hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);

    HDC hdc = GetDC(NULL);
    _hdcCompMemory = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    _hbmMonitor = LoadMonitorBitmap();

    if (_hbmMonitor == NULL)
    {
        lRet = -1;
    }

    _RecalcMetrics();  //Initialize the screen width and height etc.,

    return lRet;
}

void CCompPreview::_OnDestroy()
{
    if (_hbmMonitor)
    {
        DeleteObject(_hbmMonitor);
    }
    if (_hdcCompMemory)
    {
        DeleteDC(_hdcCompMemory);
    }
    delete this;
}

void CCompPreview::_OnPaint()
{
    PAINTSTRUCT     ps;
    BITMAP          bm;
    RECT            rc;

    BeginPaint(_hwnd,&ps);
    if (_hbmMonitor)
    {
        DWORD dwDefWidth = (_iScreenWidth / (COMPONENT_PER_ROW + 1)) - _iXBorders;
        DWORD dwDefHeight = (_iScreenHeight / (COMPONENT_PER_COL + 1)) - _iYBorders;

        //
        // Select the monitor bitmap into an hdc.
        //
        HBITMAP hbmOld = (HBITMAP)SelectObject(_hdcCompMemory, _hbmMonitor);

        //
        // Get the size of the bitmap and of our window.
        //
        GetClientRect(_hwnd, &rc);
        GetObject(_hbmMonitor, sizeof(bm), &bm);

        //
        // Center the bitmap in the window.
        //
        rc.left = ( rc.right - bm.bmWidth ) / 2;
        rc.top = ( rc.bottom - bm.bmHeight ) / 2;
        BitBlt(ps.hdc, rc.left, rc.top, bm.bmWidth, bm.bmHeight, _hdcCompMemory,
            0, 0, SRCCOPY);

        SelectObject(_hdcCompMemory, hbmOld);

        //
        // From now on, only paint in the "monitor" area of the bitmap.
        //
        IntersectClipRect(ps.hdc, rc.left + MON_X, rc.top + MON_Y, rc.left + MON_X + MON_DX, rc.top + MON_Y + MON_DY);

        //
        // Determine who the selected component is.
        //
        int iSelectedComponent;
        SendMessage(GetParent(_hwnd), WM_COMP_GETCURSEL, 0, (LPARAM)&iSelectedComponent);

        //
        // Create two new brush/pen combos, and remember the original
        // brush & pen.
        //
        HBRUSH hbrushActComp = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
        HPEN hpenActComp = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_CAPTIONTEXT));

        HBRUSH hbrushComp = CreateSolidBrush(GetSysColor(COLOR_INACTIVECAPTION));
        HPEN hpenComp = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_INACTIVECAPTIONTEXT));

        HBRUSH hbrushOld = (HBRUSH)SelectObject(ps.hdc, hbrushComp);
        HPEN hpenOld = (HPEN)SelectObject(ps.hdc, hpenComp);

        int iPrimaryMonitorX = -GetSystemMetrics(SM_XVIRTUALSCREEN);
        int iPrimaryMonitorY = -GetSystemMetrics(SM_YVIRTUALSCREEN);
        int iPrimaryMonitorCX = GetSystemMetrics(SM_CXSCREEN);
        int iPrimaryMonitorCY = GetSystemMetrics(SM_CYSCREEN);
        //
        // Draw each component in the "monitor" area of the bitmap.
        //
        int i, cComp;
        g_pActiveDeskAdv->GetDesktopItemCount(&cComp, 0);
        for (i=0; i < cComp; i++)
        {
            COMPONENT comp;
            comp.dwSize = sizeof(COMPONENT);
            if (SUCCEEDED(g_pActiveDeskAdv->GetDesktopItem(i, &comp, 0)) && (comp.fChecked))
            {
                // FEATURE: We show only components in the primary monitor in IE v4.01
                if (comp.cpPos.iLeft < iPrimaryMonitorX
                        || comp.cpPos.iLeft > iPrimaryMonitorX + iPrimaryMonitorCX
                        || comp.cpPos.iTop < iPrimaryMonitorY
                        || comp.cpPos.iTop > iPrimaryMonitorY + iPrimaryMonitorCY)
                {
                    continue;
                }

                // If the width or Height is -1, then we don't know what the actual
                // size is going to be. So, we try to give a default size here for comp
                // in the preview bitmap.
                DWORD dwCompWidth = (comp.cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH)? dwDefWidth : comp.cpPos.dwWidth;
                DWORD dwCompHeight = (comp.cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT)? dwDefHeight : comp.cpPos.dwHeight;

                if (i == iSelectedComponent)
                {
                    SelectObject(ps.hdc, hbrushActComp);
                    SelectObject(ps.hdc, hpenActComp);
                }

                int nLeft = rc.left + MON_X + MulDiv(comp.cpPos.iLeft - iPrimaryMonitorX, MON_DX, GetDeviceCaps(_hdcCompMemory, HORZRES));
                int nTop = rc.top + MON_Y + MulDiv(comp.cpPos.iTop - iPrimaryMonitorY, MON_DY, GetDeviceCaps(_hdcCompMemory, VERTRES));
                int nRight = rc.left + MON_X + MulDiv((comp.cpPos.iLeft - iPrimaryMonitorX) + dwCompWidth, MON_DX, GetDeviceCaps(_hdcCompMemory, HORZRES));
                int nBottom = rc.top + MON_Y + MulDiv((comp.cpPos.iTop - iPrimaryMonitorY)+ dwCompHeight, MON_DY, GetDeviceCaps(_hdcCompMemory, VERTRES));

                Rectangle(ps.hdc, nLeft, nTop, nRight, nBottom);

                if (i == iSelectedComponent)
                {
                    SelectObject(ps.hdc, hbrushComp);
                    SelectObject(ps.hdc, hpenComp);
                }
            }
        }

        SelectObject(ps.hdc, hpenOld);
        SelectObject(ps.hdc, hbrushOld);

        DeleteObject(hpenComp);
        DeleteObject(hbrushComp);
        DeleteObject(hpenActComp);
        DeleteObject(hbrushActComp);
    }

    EndPaint(_hwnd,&ps);
}

LRESULT CALLBACK CCompPreview::CompPreviewWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CCompPreview *pcp = (CCompPreview *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(message)
    {
    case WM_CREATE:
        pcp = new CCompPreview();
        return pcp ? pcp->_OnCreate(hwnd) : -1;

    case WM_DESTROY:
        pcp->_OnDestroy();
        break;

    case WM_PAINT:
        pcp->_OnPaint();
        return 0;

    case WM_DISPLAYCHANGE:
    case WM_WININICHANGE:
        pcp->_RecalcMetrics();
        break;

//  98/09/01 vtan #190588: WM_SYSCOLORCHANGE is passed when the desktop
//  background color is changed. This message is passed to the property
//  sheet common control which sends the message through to all the
//  children. The message is now processed here. The old monitor background
//  bitmap is discarded and a new one created with the current (new)
//  setting.

    case WM_SYSCOLORCHANGE:
        if (pcp->_hbmMonitor != NULL)
        {
            DeleteObject(pcp->_hbmMonitor);
            pcp->_hbmMonitor = LoadMonitorBitmap();
        }
        break;
    }
    return DefWindowProc(hwnd,message,wParam,lParam);
}

BOOL RegisterCompPreviewClass(void)
{
    WNDCLASS wc;

    if (!GetClassInfo(HINST_THISDLL, c_szComponentPreview, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = CCompPreview::CompPreviewWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = HINST_THISDLL;
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = c_szComponentPreview;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskhtml.cpp ===
#include "stdafx.h"
#pragma hdrstop

HRESULT CDeskHtmlProp::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CDeskHtmlProp, IObjectWithSite),
        QITABENT(CDeskHtmlProp, IShellExtInit),
        QITABENT(CDeskHtmlProp, IPersist),
        QITABENT(CDeskHtmlProp, IPropertyBag),
        QITABENT(CDeskHtmlProp, IBasePropPage),
        QITABENTMULTI(CDeskHtmlProp, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDeskHtmlProp::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CDeskHtmlProp::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

CDeskHtmlProp::CDeskHtmlProp() : _cRef(1), CObjectCLSID(&PPID_Background)
{
    DllAddRef();
    OleInitialize(NULL);

    _pspseBkgdPage = NULL;
}

CDeskHtmlProp::~CDeskHtmlProp()
{
    ATOMICRELEASE(_pspseBkgdPage);
    OleUninitialize();
    DllRelease();
}


HRESULT CDeskHtmlProp::_InitBackgroundTab(void)
{
    HRESULT hr = S_OK;

    if (!_pspseBkgdPage)
    {
        CBackPropSheetPage * pbpsp = new CBackPropSheetPage();

        hr = E_OUTOFMEMORY;
        if (pbpsp)
        {
            hr = pbpsp->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &_pspseBkgdPage));
            pbpsp->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "DeskHtml - ReplacePage could not create a page");
        }
    }

    return hr;
}


// *** IObjectWithSite ***
HRESULT CDeskHtmlProp::SetSite(IN IUnknown * punkSite)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(_pspseBkgdPage, punkSite);
    }

    return hr;
}


HRESULT CDeskHtmlProp::GetSite(IN REFIID riid, OUT void ** ppvSite)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IObjectWithSite * punk;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IObjectWithSite, &punk));
        if (SUCCEEDED(hr))
        {
            hr = punk->GetSite(riid, ppvSite);
            punk->Release();
        }
    }

    return hr;
}



// *** IShellExtInit ***
HRESULT CDeskHtmlProp::Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj, HKEY hkeyProgID)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - Initialize");
    HRESULT hr = E_INVALIDARG;

    // Forward on to the Background tab (CBackPropSheetPage)
    hr = _InitBackgroundTab();
    if (SUCCEEDED(hr))
    {
        IShellExtInit * pShellExtInt;

        if (SUCCEEDED(_pspseBkgdPage->QueryInterface(IID_PPV_ARG(IShellExtInit, &pShellExtInt))))
        {
            hr = pShellExtInt->Initialize(pidlFolder, pdtobj, hkeyProgID);
            pShellExtInt->Release();
        }
    }

    return hr;
}



// *** IBasePropPage ***
HRESULT CDeskHtmlProp::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    // Forward on to the Background tab (CBackPropSheetPage)
    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;

        hr = _InitBackgroundTab();
        if (SUCCEEDED(hr))
        {
            IBasePropPage * pBasePage;

            hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
            if (SUCCEEDED(hr))
            {
                hr = pBasePage->GetAdvancedDialog(ppAdvDialog);
                pBasePage->Release();
            }
        }
    }

    return hr;
}


HRESULT CDeskHtmlProp::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IBasePropPage * pBasePage;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IBasePropPage, &pBasePage));
        if (SUCCEEDED(hr))
        {
            hr = pBasePage->OnApply(oaAction);
            pBasePage->Release();
        }
    }

    return hr;
}




// *** IPropertyBag ***
HRESULT CDeskHtmlProp::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Read(pszPropName, pVar, pErrorLog);
            pPropertyBag->Release();
        }
    }

    return hr;
}


HRESULT CDeskHtmlProp::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = _InitBackgroundTab();

    if (SUCCEEDED(hr))
    {
        IPropertyBag * pPropertyBag;

        hr = _pspseBkgdPage->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
        if (SUCCEEDED(hr))
        {
            hr = pPropertyBag->Write(pszPropName, pVar);
            pPropertyBag->Release();
        }
    }

    return hr;
}







// *** IShellPropSheetExt ***
HRESULT CDeskHtmlProp::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - ReplacePage");

    RegisterBackPreviewClass();

    HRESULT hr = _InitBackgroundTab();
    if (SUCCEEDED(hr))
    {
        hr = _pspseBkgdPage->AddPages(lpfnAddPage, lParam);
    }

    return hr;
}


typedef struct tagREPLACEPAGE_LPARAM
{
    void * pvDontTouch;
    IThemeUIPages * ptuiPages;
} REPLACEPAGE_LPARAM;

//-----------------------------------------------------------------------------
//
// _PSXACALLINFO
//
// used to forward LPFNADDPROPSHEETPAGE calls with added error checking
//
//-----------------------------------------------------------------------------

typedef struct
{
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM lparam;
    UINT count;
    BOOL allowmulti;
    BOOL alreadycalled;
} _PSXACALLINFO;


HRESULT CDeskHtmlProp::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_OK;
}


HRESULT CDeskHtmlProp_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    TraceMsg(TF_GENERAL, "DeskHtmlProp - CreateInstance");

    CDeskHtmlProp* pdhd = new CDeskHtmlProp();
    if (pdhd) 
    {
        HRESULT hres = pdhd->QueryInterface(riid, ppvOut);
        pdhd->Release();
        return hres;
    }
    
    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskhtml.h ===
#ifndef _DESKHTML_H_
#define _DESKHTML_H_

#include <cowsite.h>

class CDeskHtmlProp     : public CObjectCLSID
                        , public IObjectWithSite
                        , public IShellExtInit
                        , public IBasePropPage
                        , public IPropertyBag
{
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IN IUnknown * punkSite);
    virtual STDMETHODIMP GetSite(IN REFIID riid, OUT void ** ppvSite);

    // *** IShellExtInit ***
    virtual STDMETHODIMP Initialize(IN LPCITEMIDLIST pidlFolder, IN LPDATAOBJECT lpdobj, IN HKEY hkeyProgID);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNADDPROPSHEETPAGE lpfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN UINT uPageID, IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, IN LPARAM lParam);

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);

protected:
    // Constructor / Destructor
    CDeskHtmlProp();
    ~CDeskHtmlProp();

    // Instance creator
    friend HRESULT CDeskHtmlProp_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);

private:
    // Private member variables
    UINT         _cRef;                     // Reference count
    IShellPropSheetExt * _pspseBkgdPage;    // The Background Page


    // Private member functions
    HRESULT _InitBackgroundTab(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskmovr.h ===
// DeskMovr.h : Declaration of the CDeskMovr

#ifndef __DESKMOVR_H_
#define __DESKMOVR_H_

#include "resource.h"       // main symbols

#include "admovr2.h"

#include "stdafx.h"

#define IDR_BOGUS_MOVR_REG  23

// Function prototypes
typedef HRESULT (CALLBACK FAR * LPFNCOMPENUM)(COMPONENT * pComp, LPVOID lpvData, DWORD dwData);
typedef HRESULT (CALLBACK FAR * LPFNELEMENUM)(IHTMLElement * pielem, LPVOID lpvData, LONG lData);

/////////////////////////////////////////////////////////////////////////////
// CDeskMovr
class ATL_NO_VTABLE CDeskMovr :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeskMovr,&CLSID_DeskMovr>,
    public CComControl<CDeskMovr>,
    public IDeskMovr,
    public IOleObjectImpl<CDeskMovr>,
    public IPersistPropertyBag,
    public IOleControlImpl<CDeskMovr>,
    public IOleInPlaceActiveObjectImpl<CDeskMovr>,
    public IViewObjectExImpl<CDeskMovr>,
    public IOleInPlaceObjectWindowlessImpl<CDeskMovr>,
    public IQuickActivateImpl<CDeskMovr>
{
public:
    
    CDeskMovr(void);
    ~CDeskMovr(void);

DECLARE_REGISTRY_RESOURCEID(IDR_BOGUS_MOVR_REG)

DECLARE_WND_CLASS(TEXT("DeskMover"));

BEGIN_COM_MAP(CDeskMovr)
    COM_INTERFACE_ENTRY(IDeskMovr)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDeskMovr)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CDeskMovr)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
ALT_MSG_MAP(1)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
END_MSG_MAP()

    // IOleInPlaceObject
    virtual STDMETHODIMP InPlaceDeactivate(void);

    // IOleObject
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IOleControl method we override to identify a safe time hook up with our partner and
    // party on the Trident OM
    virtual STDMETHODIMP FreezeEvents(BOOL bFreeze);


    // IViewObjectEx
    virtual STDMETHODIMP GetViewStatus(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }


    // IQuickActivate
    virtual STDMETHODIMP QuickActivate(QACONTAINER *pQACont, QACONTROL *pQACtrl);

    void OnKeyboardHook(WPARAM wParam, LPARAM lParam);

public:

    HRESULT OnDraw(ATL_DRAWINFO& di);

    // IPersistPropertyBag
    // IPersist
    virtual STDMETHODIMP GetClassID(CLSID *pClassID)
    {
        *pClassID = CComCoClass<CDeskMovr,&CLSID_DeskMovr>::GetObjectCLSID();
        return S_OK;
    }

    // IPersistPropertyBag
    //
    virtual STDMETHODIMP InitNew()
    {
        ATLTRACE(_T("CDeskMovr::InitNew\n"));
        return S_OK;
    }
    virtual STDMETHODIMP Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    virtual STDMETHODIMP Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, DWORD dwExStyle = 0,
            UINT nID = 0)
    {
        // We override this method inorder to add the WS_CLIPSIBLINGS bit
        // to dwStyle, which is needed to prevent the IFrames from flashing
        // when the windowed control is moved over them.
        ATOM atom = GetWndClassInfo().Register(&m_pfnSuperWindowProc);
        return CWindowImplBase::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle,
            nID, atom);
    }
    HRESULT SmartActivateMovr(HRESULT hrPropagate);

protected:
    void DeactivateMovr(BOOL fDestroy);           // stop timer, release interfaces
    HRESULT ActivateMovr();          // start timer, secure interfaces

    STDMETHODIMP GetOurStyle(void); // get our control extender's style obj

    void _ChangeCapture(BOOL fSet);
    BOOL FFindTargetElement( IHTMLElement *pielem, IHTMLElement **ppielem );

    HRESULT MoveSelfToTarget( IHTMLElement  *pielem, POINT * pptDoc );
    void    TrackTarget(POINT * pptDoc);

    LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMouseUp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnCaptureChanged( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSetCursor( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    HRESULT MoveSelfAndTarget( LONG x, LONG y );

    BOOL TrackCaption( POINT * pptDoc );
    void DrawCaptionButton(HDC hdc, LPRECT lprc, UINT uType, UINT uState, BOOL fErase);
    void DrawCaption(HDC hdc, UINT uDrawFlags, int x, int y);
    void UpdateCaption(UINT uDrawFlags);
    void CheckCaptionState(int x, int y);
    HRESULT _DisplayContextMenu(void);
    HRESULT _GetHTMLDoc(IOleClientSite * pocs, IHTMLDocument2 ** pphd2);
    HRESULT _IsInElement(HWND hwndParent, POINT * ppt, IHTMLElement ** pphe);
    HRESULT _GetZOrderSlot(LONG * plZOrderSlot, BOOL fTop);
    HRESULT _HandleZoom(LONG lCommand);
    HRESULT _EnumComponents(LPFNCOMPENUM lpfn, LPVOID lpvData, DWORD dwData);
    HRESULT _EnumElements(LPFNELEMENUM lpfn, LPVOID lpvData, DWORD dwData);
    HRESULT _TrackElement(POINT * ppt, IHTMLElement * pielem, BOOL * fDidWork);
    void _MapPoints(int * px, int * py);
    int CountActiveCaptions();

    // private state information.
    //
    BOOL m_fEnabled;
    long m_lInterval;
 
    int     m_cxBorder;
    int     m_cyBorder;
    int     m_cyCaption;
    int     m_cySysCaption;
    int     m_cyCaptionShow;
    int     m_cySMBorder;
    int     m_cxSMBorder;

    CContainedWindow m_TimerWnd;    // if we're timer-driven, we need this in case we're windowless

    enum DragMode {
        dmNull = 0,         // no dragable part
        dmMenu,             // caption drop down button for menu
        dmClose,            // caption button for close
        dmRestore,          // caption button for restore
        dmFullScreen,       // caption button for full screen
        dmSplit,            // caption button for split
                            // all gadgets on the caption bar should appear before dmMove!
        dmMove,             // move the component
        dmSizeWHBR,         // resize width and height from bottom right corner
        dmSizeWHTL,         // resize width and height from top left corner
        dmSizeWHTR,         // resize width and height from top right corner
        dmSizeWHBL,         // resize width and height from bottom left corner
        dmSizeTop,          // resize from the top edge
        dmSizeBottom,       // resize from the bottom edge
        dmSizeLeft,         // resize from the left edge
        dmSizeRight,        // resize from the right edge
        cDragModes          // count of drag modes, including dmNull
    };

    BITBOOL  m_fCanResizeX; // Whether this component can be resized in X Direction?
    BITBOOL  m_fCanResizeY; // Whether this component can be resized in Y Direction?

    HRESULT  InitAttributes(IHTMLElement *pielem);
    HRESULT GetParentWindow(void);

    DragMode m_dmCur;         // current drag mode, or dmNull if none.
    DragMode m_dmTrack;       // last drag mode seen by TrackCaption
    RECT     m_rectInner;     // area inside frame, in local coords
    RECT     m_rectOuter;     // outer bounds of mover, in local coords
    RECT     m_rectCaption;   // rect of our pseudo-caption, in local coords
    SIZE     m_sizeCorner;    // size of the corner areas of the frame


    BOOL GetCaptionButtonRect(DragMode dm, LPRECT lprc);
    void  SyncRectsToTarget(void);

    DragMode DragModeFromPoint( POINT pt );

    HCURSOR  CursorFromDragMode( DragMode dm );

    HRESULT SizeSelfAndTarget(POINT ptDoc);
    void DismissSelfNow(void);

    BOOL HandleNonMoveSize(DragMode dm);

    HCURSOR m_hcursor;

    LONG    m_top;
    LONG    m_left;
    LONG    m_width;
    LONG    m_height;

    BOOL    m_fTimer;         // do we have a timer running?
    UINT    m_uiTimerID;
    POINT   m_ptMouseCursor;  // Mouse cursor at timer
    

    BSTR    m_bstrTargetName;   // name attribute on targetted html elements

    IHTMLStyle         *m_pistyle;          // our control's style object
    IHTMLStyle         *m_pistyleTarget;    // The style object of our current target, also how we ID it
    IHTMLElement       *m_pielemTarget;     // This interface on the target is how we move and resize it
    LONG                m_iSrcTarget;       // get_sourceIndex value for the current target

    BOOL    m_fCaptured;    // true if mouse-capture/ move operation in progress
    LONG    m_dx;           // delta from mouse down to corner of active gadget
    LONG    m_dy;           // delta from mouse down to corner of active gadget};
    DWORD   m_CaptionState;
    HWND    m_hwndParent;
    LONG    m_zIndexTop;
    LONG    m_zIndexBottom;
    LONG    m_cSkipTimer;   // Used to allow the dismissal of the mover to take two timer periods.
    DWORD   m_ItemState;
};

// Defines for DrawCaption
#define DMDC_CAPTION    0x0001
#define DMDC_MENU       0x0002
#define DMDC_CLOSE      0x0004
#define DMDC_RESTORE    0x0008
#define DMDC_FULLSCREEN 0x0010
#define DMDC_SPLIT      0x0020
#define DMDC_ALL      (DMDC_CAPTION | DMDC_MENU | DMDC_CLOSE | DMDC_SPLIT | DMDC_FULLSCREEN | DMDC_RESTORE)

// Defines for CaptionState
#define CS_MENUTRACKED          0x00000001
#define CS_MENUPUSHED           0x00000002
#define CS_CLOSETRACKED         0x00000004
#define CS_CLOSEPUSHED          0x00000008
#define CS_RESTORETRACKED       0x00000010
#define CS_RESTOREPUSHED        0x00000020
#define CS_FULLSCREENTRACKED    0x00000040
#define CS_FULLSCREENPUSHED     0x00000080
#define CS_SPLITTRACKED         0x00000100
#define CS_SPLITPUSHED          0x00000200

#endif //__DESKMOVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskmovr.cpp ===
// DeskMovr.cpp : Implementation of CDeskMovr
#include "stdafx.h"
#pragma hdrstop

#include "deskmovr.h"

#define DEFAULT_INTERVAL        200     // check every 1/5th of a second.
#define DEFAULT_ENABLED         TRUE
#define DETECT_TIMER_ID         2323
#ifndef SHDOC401_DLL
#define ANIMATE_TIMER_ID        2324
#define ANIMATE_TIMER_INTERVAL  (60*1000)
#endif

#ifdef DEBUG
const static TCHAR sz_DM1[]  = TEXT("no dragable part");
const static TCHAR sz_DM2[]  = TEXT("caption menu button");
const static TCHAR sz_DM3[]  = TEXT("caption close button");
const static TCHAR sz_DM4[]  = TEXT("move the component");
const static TCHAR sz_DM5[]  = TEXT("resize width and height from bottom right corner");
const static TCHAR sz_DM6[]  = TEXT("resize width and height from top left corner");
const static TCHAR sz_DM7[]  = TEXT("resize width and height from top right corner");
const static TCHAR sz_DM8[]  = TEXT("resize width and height from bottom left corner");
const static TCHAR sz_DM9[]  = TEXT("resize from the top edge");
const static TCHAR sz_DM10[]  = TEXT("resize from the bottom edge");
const static TCHAR sz_DM11[]  = TEXT("resize from the left edge");
const static TCHAR sz_DM12[] = TEXT("resize from the right edge");

const LPCTSTR g_szDragModeStr[] = {
        sz_DM1,
        sz_DM2,
        sz_DM3,
        sz_DM4,
        sz_DM5,
        sz_DM6,
        sz_DM7,
        sz_DM8,
        sz_DM9,
        sz_DM10,
        sz_DM11,
        sz_DM12
    };

#endif // DEBUG

// Globals used to track cdeskmovr instances.  Useful for optimizing the
// detection code so we can turn off the timer when the mouse is not over our
// window.  We track the cdeskmovr instances only on the first thread that instantiates
// us to keep the code simple, this should be the active desktop case.
#define CDESKMOVR_TRACK_COUNT 16    // 2 is what we use now for the active desktop, but we need
                                    // extra slots in the array due to the fact that a new instance
                                    // is created before the old one is destroyed during refresh.
                                    // Make the array large to handle nested refreshes!
HHOOK g_hMouseHook;
HHOOK g_hKeyboardHook;
DWORD g_dwHookThreadId;
#ifndef SHDOC401_DLL
BOOL  g_fAnimTimer = FALSE;
#endif
typedef CDeskMovr *PDM;
PDM g_apDM[CDESKMOVR_TRACK_COUNT];
BOOL CombView_EnableAnimations(BOOL fEnable);


DWORD  g_fIgnoreTimers = 0;
#define IGNORE_CONTEXTMENU_UP 0x0001
#define IGNORE_CAPTURE_SET    0x0002

#define GET_SKIP_COUNT  (2 * ((GetDoubleClickTime() / m_lInterval) + 1))

MAKE_CONST_BSTR(s_sstrNameMember,       L"name");
MAKE_CONST_BSTR(s_sstrHidden,           L"hidden");
MAKE_CONST_BSTR(s_sstrVisible,          L"visible");
MAKE_CONST_BSTR(s_sstrResizeableMember, L"resizeable");

// These were declared in shellprv.h, so use DEFINE instead of MAKE
DEFINE_CONST_BSTR(s_sstrIDMember,         L"id");
DEFINE_CONST_BSTR(s_sstrSubSRCMember,     L"subscribed_url");
DEFINE_CONST_BSTR(s_sstrSRCMember,        L"src");

#define CAPTION_ONLY (m_ItemState & (IS_FULLSCREEN | IS_SPLIT))
#define ISNORMAL (m_ItemState & IS_NORMAL)
#define ISFULLSCREEN (m_ItemState & IS_FULLSCREEN)
#define ISSPLIT (m_ItemState & IS_SPLIT)
#define CAPTIONBAR_HOTAREA(cyDefaultCaption, cyCurrentCaption) (((cyCurrentCaption == 0) && CAPTION_ONLY) ? (cyDefaultCaption / 2) : 3 * cyDefaultCaption)

#define MAX_ID_LENGTH 5

void ObtainSavedStateForElem( IHTMLElement *pielem,
                       LPCOMPSTATEINFO pCompState, BOOL fRestoredState);

DWORD g_aDMtoCSPushed[] = {0, CS_MENUPUSHED, CS_CLOSEPUSHED, CS_RESTOREPUSHED, CS_FULLSCREENPUSHED, CS_SPLITPUSHED};
DWORD g_aDMtoCSTracked[] = {0, CS_MENUTRACKED, CS_CLOSETRACKED, CS_RESTORETRACKED, CS_FULLSCREENTRACKED, CS_SPLITTRACKED};
DWORD g_aDMDCfromDragMode[] = {0, DMDC_MENU, DMDC_CLOSE, DMDC_RESTORE, DMDC_FULLSCREEN, DMDC_SPLIT};
#define PUSHED(dm) (g_aDMtoCSPushed[(dm)])
#define TRACKED(dm) (g_aDMtoCSTracked[(dm)])
#define DMDCFROMDM(dm) (g_aDMDCfromDragMode[(dm)])

// Trident will flash if you change the zindex, even if it's to the same index,
// so we prevent the no-op call.
HRESULT SafeZOrderSet(IHTMLStyle * pistyle, LONG lNewZIndex)
{
    HRESULT hr = S_OK;
    VARIANT varZ;

    ASSERT(pistyle);
    pistyle->get_zIndex(&varZ);

    // Does the component need to be moved to the top?
    if ((VT_I4 != varZ.vt) || (varZ.lVal != lNewZIndex))
    {
        // Yes.
        varZ.vt = VT_I4;
        varZ.lVal = lNewZIndex;
        hr = pistyle->put_zIndex(varZ);
    }

    return hr;
}

// Keyboard hook is installed when first instance of deskmovr is created.  Used to implement the keyboard
// interface for accessing the deskmovr control.  Hook is removed when there are no more deskmovr's
// being tracked.
LRESULT CALLBACK DeskMovr_KeyboardHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes;
    BOOL fHaveMover = FALSE;

    for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
        if (g_apDM[i])
        {
            g_apDM[i]->OnKeyboardHook(wParam, lParam);
            fHaveMover = TRUE;
        }
    }

    lRes = CallNextHookEx(g_hKeyboardHook, nCode, wParam, lParam);

    if (!fHaveMover)
    {
        UnhookWindowsHookEx(g_hKeyboardHook);
        g_hKeyboardHook = NULL;
    }

    return lRes;
}

// Helper function used to track cdeskmovr intances so that we can turn off the
// timer if the mouse leaves our window.
void TrackMover(PDM pdm, BOOL fAdd)
{
    if (!g_dwHookThreadId)
        g_dwHookThreadId = GetCurrentThreadId();

    if (!g_hKeyboardHook && fAdd)
        g_hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD, DeskMovr_KeyboardHook, NULL, GetCurrentThreadId());

    if (!fAdd || (g_dwHookThreadId == GetCurrentThreadId())) {
        int i = 0;
        PDM pdmFind = fAdd ? NULL : pdm;
        PDM pdmAssign = fAdd ? pdm : NULL;

        while (i < CDESKMOVR_TRACK_COUNT) {
            if (g_apDM[i] == pdmFind) {
                g_apDM[i] = pdmAssign;
                break;
            }
            i++;
        }

        // If we ever fail to track a mover then we'll never be able to optimize
        // again.  Shouldn't happen in practice for the case we care about.
        if (fAdd && (i >= CDESKMOVR_TRACK_COUNT))
            g_dwHookThreadId = 0xffffffff;

        ASSERT(!fAdd || (i < CDESKMOVR_TRACK_COUNT));
    }
}

void AnimateComponent(HWND hwnd, LONG lLeftS, LONG lTopS, LONG lWidthS, LONG lHeightS,
                      LONG lLeftD, LONG lTopD, LONG lWidthD, LONG lHeightD)
{
    RECT rcSource, rcDest;

    SetRect(&rcSource, lLeftS, lTopS, lLeftS + lWidthS, lTopS + lHeightS);
    SetRect(&rcDest, lLeftD, lTopD, lLeftD + lWidthD, lTopD + lHeightD);

    DrawAnimatedRects(hwnd, IDANI_CAPTION, (CONST RECT *)&rcSource, (CONST RECT *)&rcDest);
}

// Hook is installed when we detect we can turn our tracking timer off.  The first
// time we get a mouse event in the hook we reactivate all the movers and unhook
// ourself.
LRESULT CALLBACK DeskMovr_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes;

#ifndef SHDOC401_DLL
    // If we are getting mouse messages then a portion of the window must be
    // visible so enable animations.
    CombView_EnableAnimations(TRUE);
#endif

    for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
        if (g_apDM[i]) 
            g_apDM[i]->SmartActivateMovr(ERROR_SUCCESS);
    }

    lRes = CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);

    UnhookWindowsHookEx(g_hMouseHook);
    g_hMouseHook = NULL;

    return lRes;
}

/////////////////////////////////////////////////////////////////////////////
// CDeskMovr

CDeskMovr::CDeskMovr()
 : m_TimerWnd(_T("STATIC"), this, 1)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::CDeskMovr()");

    m_fEnabled = DEFAULT_ENABLED;
    m_lInterval = DEFAULT_INTERVAL;

    m_cxSMBorder = GetSystemMetrics(SM_CXBORDER);
    m_cySMBorder = GetSystemMetrics(SM_CYBORDER);
    m_cxBorder = m_cxSMBorder;
    m_cyBorder = m_cySMBorder;
    m_cyCaption = 0; 

    m_dmCur = dmNull;
    m_dmTrack = dmNull;

    m_hcursor = LoadCursor(NULL, IDC_ARROW);
    m_CaptionState = 0;
    m_hwndParent;

    m_fTimer = FALSE;
    m_fCaptured = FALSE;
    m_uiTimerID = DETECT_TIMER_ID;
    m_pistyle = NULL;

    m_pistyleTarget = NULL;
    m_pielemTarget = NULL;
    m_iSrcTarget = -1;
    
    m_bstrTargetName = NULL;

    m_dx = m_dy = 0;
    
    m_top = m_left = m_width = m_height = 0;

    // Tell ATL that we don't want to be Windowless
    m_bWindowOnly = TRUE;

    // Track this instance
    TrackMover(this, TRUE);
}

CDeskMovr::~CDeskMovr(void)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::~CDeskMovr() m_bstrTargetName=%ls.", GEN_DEBUGSTRW(m_bstrTargetName));

 // clean up, detach from events, if necessary. 
    DeactivateMovr(TRUE);

    if ( m_bstrTargetName != NULL )
        SysFreeString( m_bstrTargetName );

    TrackMover(this, FALSE);
}


HRESULT CDeskMovr::SmartActivateMovr(HRESULT hrPropagate)
{
    if ((FALSE == m_nFreezeEvents) && m_fEnabled && !m_pielemTarget)
    {
#ifndef SHDOC401_DLL
        // Release our animation timer if it exists and create our regular one
        if (g_fAnimTimer && (m_uiTimerID == ANIMATE_TIMER_ID))
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_uiTimerID = DETECT_TIMER_ID;
            g_fAnimTimer = FALSE;
            m_fTimer = m_TimerWnd.SetTimer(m_uiTimerID, m_lInterval) != 0;
        }
#endif
        hrPropagate = ActivateMovr();
        if (!EVAL(SUCCEEDED(hrPropagate)))
            DeactivateMovr(FALSE);   // Clean up mess.
    }

    return hrPropagate;
}

HRESULT CDeskMovr::FreezeEvents(BOOL fFreeze)
{
    HRESULT hr = IOleControlImpl<CDeskMovr>::FreezeEvents(fFreeze);
    TraceMsg(TF_CUSTOM1, "CDeskMovr::FreezeEvents(fFreeze=%lx) m_nFreezeEvents=%lx; m_fEnabled=%lx, m_bstrTargetName=%ls", (DWORD)fFreeze, m_nFreezeEvents, m_fEnabled, GEN_DEBUGSTRW(m_bstrTargetName));

    m_nFreezeEvents = fFreeze;

    if (fFreeze)
        DeactivateMovr(FALSE);
    else
        hr = SmartActivateMovr(hr);

    return hr;
}

HRESULT CDeskMovr::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    VARIANT var;

    ATLTRACE(_T("IPersistPropertyBagImpl::Load\n"));

    var.vt = VT_BOOL;
    hr = pPropBag->Read(L"Enabled", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BOOL) {
        m_fEnabled = var.boolVal;
    }

    var.vt = VT_I4;
    hr = pPropBag->Read(L"Interval", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_I4) {
        m_lInterval = var.lVal;
    }

    var.vt = VT_BSTR;
    var.bstrVal = NULL;
    hr = pPropBag->Read(L"TargetName", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BSTR) {
        m_bstrTargetName = var.bstrVal;
    }

    // This PARAM determines whether the control will be in the
    // windowed or windowless "layer" of the Trident layout.
    var.vt = VT_BOOL;
    hr = pPropBag->Read(L"WindowOnly", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_BOOL) {
        m_bWindowOnly = var.boolVal;
    }

    hr = _GetZOrderSlot(&m_zIndexTop, TRUE);
    ASSERT(SUCCEEDED(hr));
    hr = _GetZOrderSlot(&m_zIndexBottom, FALSE);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CDeskMovr::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

BOOL CDeskMovr::GetCaptionButtonRect(DragMode dm, LPRECT lprc)
{
    BOOL fSuccess;

    *lprc = m_rectCaption;

    switch (dm) {
        case dmClose:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            fSuccess = (lprc->left > (m_rectCaption.left + m_cyCaption));
            break;

        case dmMenu:
            lprc->right = lprc->left + (m_cyCaption + m_cxSMBorder);
            fSuccess = (m_rectCaption.right > (m_rectCaption.left + m_cyCaption));
            break;

        case dmRestore:
            if (ISNORMAL)
                return FALSE;
            else if (ISSPLIT)
                goto CalcSplit;
            else if (ISFULLSCREEN)
                goto CalcFullScreen;

            ASSERT(FALSE);

        case dmSplit:
            if (ISSPLIT || !m_fCanResizeX || !m_fCanResizeY)
            {
                return FALSE;
            }
CalcSplit:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            OffsetRect(lprc, -(lprc->right - lprc->left), 0);
            fSuccess = (lprc->left > (m_rectCaption.left + 2 * m_cyCaption));
            break;

        case dmFullScreen:
            if (ISFULLSCREEN || !m_fCanResizeX || !m_fCanResizeY)
            {
                return FALSE;
            }
CalcFullScreen:
            lprc->left = m_rectCaption.right - (m_cyCaption + m_cxSMBorder);
            OffsetRect(lprc, -((lprc->right - lprc->left) * 2 - 2 * m_cxSMBorder), 0);
            fSuccess = (lprc->left > (m_rectCaption.left + 2 * m_cyCaption));
            break;

        default:
            ASSERT(FALSE);
            fSuccess = FALSE;
            break;
    }

    // Shrink the button within the caption and position it adjacent to the border
    if (fSuccess) {
        OffsetRect(lprc, ((dm == dmClose) ? m_cxSMBorder : -m_cxSMBorder), -m_cySMBorder);
        InflateRect(lprc, -m_cxSMBorder, -m_cySMBorder);
        lprc->bottom -= m_cySMBorder;  // Take an extra border off the bottom
    }

    return fSuccess;
}

void CDeskMovr::DrawCaptionButton(HDC hdc, LPRECT lprc, UINT uType, UINT uState, BOOL fErase)
{
    RECT rcT;
    HRGN hrgnWnd, hrgnRect;
    int iRet;

    if (fErase)
        FillRect(hdc, lprc, (HBRUSH)(COLOR_3DFACE + 1));

    rcT = *lprc;
    InflateRect(&rcT, -2*m_cxSMBorder, -2*m_cySMBorder);

    switch (uType) {
        case DMDC_CLOSE:
            uType = DFC_CAPTION;
            goto Draw;
        case DMDC_MENU:
            uType = DFC_SCROLL;
Draw:
            // We need to clip the border of the outer edge in order to get the drawing effect we
            // want here...
            if (hrgnWnd = CreateRectRgn(0, 0, 0, 0)) {
                if ((iRet = GetClipRgn(hdc, hrgnWnd)) != -1) {
                    if (hrgnRect = CreateRectRgnIndirect(&rcT)) {
                        SelectClipRgn(hdc, hrgnRect);
                        DeleteObject(hrgnRect);
                    }
                }
            }
    
            DrawFrameControl(hdc, lprc, uType, uState);

            if (hrgnWnd != NULL)
            {
                SelectClipRgn(hdc, (iRet == 1) ? hrgnWnd : NULL);
            }
            if (hrgnWnd)
                DeleteObject(hrgnWnd);
            break;

        case DMDC_FULLSCREEN:
        case DMDC_SPLIT:
        case DMDC_RESTORE:
            {
                if (uState & DFCS_PUSHED)
                    OffsetRect(&rcT, 1, 1);

                DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_RECT);

#ifndef OLD_CODE
                switch (uType) {
                    case DMDC_RESTORE:
                        rcT.right = rcT.left + (rcT.right - rcT.left) * 3 / 4;
                        rcT.bottom = rcT.top + (rcT.bottom - rcT.top) * 3 / 4;
                        rcT.left += (rcT.right - rcT.left) / 2 + 1;
                        rcT.top  += (rcT.bottom - rcT.top) / 2 + 1;
                        FillRect(hdc, &rcT, (HBRUSH)(COLOR_WINDOWFRAME + 1));
                        break;

                    case DMDC_SPLIT:
                        rcT.top += m_cySMBorder;
                        rcT.left += (rcT.right - rcT.left) * 3 / 10;
                        DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_TOP | BF_LEFT);
                        break;

                    case DMDC_FULLSCREEN:
                        rcT.top += m_cySMBorder;
                        DrawEdge(hdc, &rcT, BDR_OUTER, BF_FLAT | BF_MONO | BF_TOP);
                        break;
                }
#else
                switch (uType) {
                    case DMDC_RESTORE:
                        rcT.right = rcT.left + (rcT.right - rcT.left) * 3 / 4;
                        rcT.bottom = rcT.top + (rcT.bottom - rcT.top) * 3 / 4;
                        rcT.left += (rcT.right - rcT.left) / 2 + 1;
                        rcT.top  += (rcT.bottom - rcT.top) / 2 + 1;
                        break;
                    case DMDC_SPLIT:
                        rcT.left += (rcT.right - rcT.left) * 3 / 10;
                        break;
                    case DMDC_FULLSCREEN:
                        break;
                }

                FillRect(hdc, &rcT, (HBRUSH)(COLOR_WINDOWFRAME + 1));
#endif
            }
            break;
    }

    // DFCS_FLAT means no border to us
    if (!(uState & DFCS_FLAT))
        DrawEdge(hdc, lprc, ((uState & DFCS_PUSHED) ? BDR_SUNKENOUTER : BDR_RAISEDINNER), BF_RECT);
}

void CDeskMovr::DrawCaption(HDC hdc, UINT uDrawFlags, int x, int y)
{
    RECT rect;
    UINT uState;
    DragMode dmT;

    // Draw the caption
    if (uDrawFlags & DMDC_CAPTION) {
        rect = m_rectCaption;
        OffsetRect(&rect, x, y);
        FillRect( hdc, &rect, (HBRUSH)(COLOR_3DFACE + 1) );
    }

    // Draw the caption frame controls
    for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1))
    {
        if ((uDrawFlags & DMDCFROMDM(dmT)) && GetCaptionButtonRect(dmT, &rect))
        {
            if (dmT == dmMenu)
                uState = DFCS_SCROLLDOWN;
            else if (dmT == dmClose)
                uState = DFCS_CAPTIONCLOSE;
            else
                uState = 0;

            if ((dmT == dmClose) && SHRestricted(REST_NOCLOSEDESKCOMP))
                uState |= DFCS_INACTIVE | DFCS_FLAT;
            else
            {
                if (m_CaptionState & PUSHED(dmT))
                    uState |= DFCS_PUSHED;
                if (!(m_CaptionState & (TRACKED(dmT) | PUSHED(dmT))))
                    uState |= DFCS_FLAT;
            }
            OffsetRect(&rect, x, y);
            DrawCaptionButton(hdc, &rect, DMDCFROMDM(dmT), uState, !(uDrawFlags & DMDC_CAPTION));
        }
    }
}

HRESULT CDeskMovr::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;

    RECT r;
    HBRUSH  hbrush = (HBRUSH)(COLOR_3DFACE + 1);
    
    // top edge
    r.left = rc.left;
    r.top = rc.top;
    r.right = rc.right;
    r.bottom = rc.top + m_cyBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // left edge
    r.top = rc.top + m_cyBorder;
    r.right = rc.left + m_cxBorder;
    r.bottom = rc.bottom - m_cyBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // right edge
    r.right = rc.right;
    r.left = rc.right - m_cxBorder;
    FillRect( di.hdcDraw, &r, hbrush );
    // bottom edge
    r.left = rc.left;
    r.top = rc.bottom - m_cyBorder;
    r.right = rc.right;
    r.bottom = rc.bottom;
    FillRect( di.hdcDraw, &r, hbrush );

    if ( m_cyCaption != 0 ) {
        DrawCaption(di.hdcDraw, DMDC_ALL, rc.left, rc.top);
    }

    return S_OK;
}

HRESULT CDeskMovr::GetParentWindow(void)
{
    HRESULT hr = S_OK;

    if (!m_hwndParent)
    {
        if (m_spInPlaceSite) 
            hr = m_spInPlaceSite->GetWindow(&m_hwndParent);
        else 
        {
            IOleInPlaceSiteWindowless * poipsw;

            ASSERT(m_spClientSite);
            if (m_spClientSite &&
                SUCCEEDED(hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&poipsw)))
            {
                hr = poipsw->GetWindow(&m_hwndParent);
                poipsw->Release();
            }
        }

        if (!m_hwndParent)
            hr = S_FALSE;   // We failed to get it.
    }

    return hr;
}

void CDeskMovr::DeactivateMovr(BOOL fDestroy)
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::DeactivateMovr() m_fTimer=%lx, m_bstrTargetName=%ls", m_fTimer, GEN_DEBUGSTRW(m_bstrTargetName));

    if (fDestroy || (m_uiTimerID == DETECT_TIMER_ID)) {
        if (m_fTimer)
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_fTimer = FALSE;
        }
        if (m_TimerWnd.m_hWnd)
            m_TimerWnd.DestroyWindow();
#ifndef SHDOC401_DLL
        if (m_uiTimerID == ANIMATE_TIMER_ID)
            g_fAnimTimer = FALSE;
#endif
    }

    // DismissSelfNow();

    ATOMICRELEASE( m_pistyle );
    ATOMICRELEASE( m_pistyleTarget );
    ATOMICRELEASE( m_pielemTarget );

    _ChangeCapture(FALSE);
}


HRESULT CDeskMovr::ActivateMovr()
{
    HRESULT           hr;

    // flush out old interface pointers
    DeactivateMovr(FALSE);
    TraceMsg(TF_CUSTOM2, "CDeskMovr::ActivateMovr() m_fTimer=%lx, m_bstrTargetName=%ls", m_fTimer, GEN_DEBUGSTRW(m_bstrTargetName));

    if (m_fEnabled)
    {        
        if (SUCCEEDED(hr = GetOurStyle()))
        {
            if ((m_bstrTargetName != NULL) && (m_lInterval > 0))
            {
                if (!m_TimerWnd.m_hWnd)
                {
                    // create a new timer.
                    RECT rc = {0, 0, 0 , 0};

                    // We attempt to get our parent HWND (m_hwndParent) now.
                    // If we fail (and we will sometimes), then we will get it later when
                    // we need it and Trident is then ready.
                    GetParentWindow();

                    m_TimerWnd.Create(NULL, rc, _T("Timer"), WS_POPUP);
                }
                if (!m_fTimer)
                    m_fTimer = m_TimerWnd.SetTimer(m_uiTimerID, m_lInterval) != 0;
            }
            else
            {
#ifdef HIDE_ALL_HANDLES
                hr = S_FALSE;
#else
                hr = E_FAIL;
#endif
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CDeskMovr::GetOurStyle(void)
{
    HRESULT           hr;
    IOleControlSite   *pictlsite = 0;
    IDispatch         *pidisp = 0;

    // Reach up to get our extender, who is the custodian of our element style
    if (m_spClientSite &&
        EVAL(SUCCEEDED(hr = m_spClientSite->QueryInterface(IID_IOleControlSite, (LPVOID*)&pictlsite))) &&
        EVAL(SUCCEEDED(hr = pictlsite->GetExtendedControl(&pidisp))))
    {
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VARIANT var;

        VariantInit( &var );

        // Alas, all we have is IDispatch on our extender, so we'll have to use Invoke to get
        // the style object...
        hr = pidisp->Invoke( DISPID_IHTMLELEMENT_STYLE, IID_NULL,
                             LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                             &dispparamsNoArgs, &var, NULL, NULL );

        if ( SUCCEEDED(hr) ) {
            if ( var.vt == VT_DISPATCH )
                hr = var.pdispVal->QueryInterface( IID_IHTMLStyle, (LPVOID*)&m_pistyle );
            else
                hr = E_FAIL; // Try VariantChangeType?????

            VariantClear( &var );
        }
    }

    ATOMICRELEASE( pictlsite );
    ATOMICRELEASE( pidisp );

    return hr;
}



void CDeskMovr::UpdateCaption(UINT uDrawFlags)
{
    HDC hdc;
    int x = 0, y = 0;

    if (m_bWndLess) {
        if (!m_spInPlaceSite || !SUCCEEDED(m_spInPlaceSite->GetDC(NULL, 0, &hdc)))
            return;
    } else {
        hdc = ::GetDC(m_hWnd);
    }

    _MapPoints(&x, &y);

    DrawCaption(hdc, uDrawFlags, -x, -y);

    if (m_bWndLess) {
        m_spInPlaceSite->ReleaseDC(hdc);
    } else {
        ::ReleaseDC(m_hWnd, hdc);
    }
}

void CDeskMovr::CheckCaptionState(int x, int y)
{
    DragMode dm, dmT;
    UINT uDrawFlags = 0;

    _MapPoints (&x, &y);

    POINT pt = { x, y };

    if (m_fCaptured)
        dm = dmNull;
    else
        dm = DragModeFromPoint( pt );

    if (dm >= dmMenu && dm < dmMove)
    {
        if (!(m_CaptionState & (PUSHED(dm) | TRACKED(dm))))
        {
            m_CaptionState |= TRACKED(dm);
            uDrawFlags |= DMDCFROMDM(dm);
        }
    }

    for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1))
    {
        if (dm != dmT && (m_CaptionState & (PUSHED(dmT) | TRACKED(dmT))))
        {
            m_CaptionState &= ~(PUSHED(dmT) | TRACKED(dmT));
            uDrawFlags |= DMDCFROMDM(dmT);
        }
    }

    if (uDrawFlags)
        UpdateCaption(uDrawFlags);
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DoMouseDown   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse down messages in our control. Initiate move/resize.
//
// Parameters:
//    int                - [in]  mouse message key flags
//    int                - [in]  mouse x location in control coords
//    int                - [in]  mouse y location in control coords
//
// Output:
//    <none>
//
// Notes:
BOOL CDeskMovr::HandleNonMoveSize(DragMode dm)
{
    m_dmCur = dm;
    switch (dm) {
        case dmMenu:
        case dmClose:
        case dmRestore:
        case dmFullScreen:
        case dmSplit:
            if (m_dmCur != dmClose || !SHRestricted(REST_NOCLOSEDESKCOMP)) // Special case for Close, check restriction
            {
                m_CaptionState &= ~(TRACKED(m_dmCur));
                m_CaptionState |= PUSHED(m_dmCur);
                UpdateCaption(DMDCFROMDM(m_dmCur));
                // Perform the operation on the up-click of the mouse...
            }
    
            if (m_dmCur == dmMenu && EVAL(S_OK == GetParentWindow())) // Special case for Menu, invoke on the down click
            {
                _DisplayContextMenu();
            }
            return TRUE;
            break;

        default:
            return FALSE;
            break;
    }
}

LRESULT CDeskMovr::OnMouseDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    int x = (short)LOWORD(lParam);
    int y = (short)HIWORD(lParam);

    _MapPoints(&x, &y);

    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() Mouse=<%d,%d>, Inner=<%d,%d,%d,%d>, Caption=<%d,%d,%d,%d>, m_bstrTargetName=%ls", 
        x, y, m_rectInner.left, m_rectInner.top, m_rectInner.right, m_rectInner.bottom,
        m_rectCaption.left, m_rectCaption.top, m_rectCaption.right, m_rectCaption.bottom, GEN_DEBUGSTRW(m_bstrTargetName));

    POINT pt = { x, y };
    m_dmCur = DragModeFromPoint( pt );

    if (HandleNonMoveSize(m_dmCur))
        return 0;

    switch ( m_dmCur ) {
    case dmMove:
        m_dx = -x;
        m_dy = -y;
        break;

    case dmSizeWHBR:
        m_dx = m_rectInner.right - x;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeWHTL:
        m_dx = m_rectInner.left - x;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeWHTR:
        m_dx = m_rectInner.right - x;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeWHBL:
        m_dx = m_rectInner.left - x;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeTop:
        m_dx = 0;
        m_dy = m_rectInner.top + m_cyCaption - y;
        break;
    case dmSizeBottom:
        m_dx = 0;
        m_dy = m_rectInner.bottom - y;
        break;
    case dmSizeLeft:
        m_dx = m_rectInner.left - x;
        m_dy = 0;
        break;
    case dmSizeRight:
        m_dx = m_rectInner.right - x;
        m_dy = 0;
        break;
    default:
        bHandled = FALSE;
        return 1;
    }

#ifdef DEBUG
    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() New DragMode=""%s""", g_szDragModeStr[m_dmCur]);
#endif // DEBUG

    // NOTE: (seanf, 1/31/97) temporary defense against 17902. We really
    // shouldn't ever be in visible and non-targeted at the same time, but
    // the resize trick we pull in CDeskMovr::ActivateMovr() to get us
    // in-place active exposes a 1X1 pixel area, just big enough for StanTak
    // to click on when we don't have a target, which then kills us when
    // we try to move the non-existent target.
    if ( m_pielemTarget != NULL ) {
        _ChangeCapture(TRUE);

        if (m_fCaptured)
        {
            // Move the target to the top and put ourselves just under it
            VARIANT varZ;

            m_pistyleTarget->get_zIndex(&varZ);

            // Does the component need to be moved to the top?
            if (!CAPTION_ONLY && ((VT_I4 != varZ.vt) || (varZ.lVal != m_zIndexTop)))
            {
                // Yes.
                varZ.vt = VT_I4;
                varZ.lVal = ++m_zIndexTop;
                // Move the DeskMover ActiveX Control on top of everything.
                m_pistyle->put_zIndex(varZ);
    
                // Move the Desktop Item on top of the DeskMover
                varZ.lVal = ++m_zIndexTop;
                m_pistyleTarget->put_zIndex(varZ);
            }
        }
#ifdef DEBUG
        if (!m_fCaptured)
            TraceMsg(TF_CUSTOM2, "CDeskMovr::OnMouseDown() Unable to get capture, tracking will fail!");
#endif

    }

    return 0;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DoMouseUp   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse down messages in our control. Terminate move/resize.
//
// Parameters:
//    int                - [in]  mouse message key flags
//    int                - [in]  mouse x location in control coords
//    int                - [in]  mouse y location in control coords
//    UINT               - [in]  from the DeskMovrParts enum
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnMouseUp( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if ( m_fCaptured ) {
        PersistTargetPosition( m_pielemTarget, m_left, m_top, m_width, m_height, m_zIndexTop, FALSE, FALSE, m_ItemState );
        _ChangeCapture(FALSE);
    } else {
        int x = (short)LOWORD(lParam);
        int y = (short)HIWORD(lParam);

        _MapPoints(&x, &y);
    
        POINT pt = { x, y };
        DragMode dm = DragModeFromPoint( pt );

        if ((dm >= dmMenu) && (dm < dmMove) && (m_CaptionState & PUSHED(dm)))
        {
            m_CaptionState &= ~(PUSHED(dm));
            m_CaptionState |= TRACKED(dm);
            UpdateCaption(DMDCFROMDM(dm));

            switch ( dm ) {
                case dmClose:
//                    AnimateToTray(m_hwndParent, m_left, m_top, m_width, m_height);
                    IElemCloseDesktopComp(m_pielemTarget);
                    break;

                case dmRestore:
                    _HandleZoom(IDM_DCCM_RESTORE);
                    break;

                case dmFullScreen:
                    _HandleZoom(IDM_DCCM_FULLSCREEN);
                    break;

                case dmSplit:
                    _HandleZoom(IDM_DCCM_SPLIT);
                    break;
            }

            if (dm != dmMenu)
                DismissSelfNow();
        }
    }

    return 0;
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::DoMouseMove   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse move messages in our control and when moving/sizing.
//
// Parameters:
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    TraceMsg(TF_CUSTOM2, "CDeskMovr::OnPaint() uMsg=%lx, wParam=%lx, lParam=%lx, m_bstrTargetName=%ls", uMsg, wParam, lParam, GEN_DEBUGSTRW(m_bstrTargetName));
    return CComControl<CDeskMovr>::OnPaint( uMsg, wParam, lParam, bHandled );
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::DoMouseMove   [instance method]
//=--------------------------------------------------------------------------=
// Respond to mouse move messages in our control and when moving/sizing.
//
// Parameters:
//
// Output:
//    <none>
//
// Notes:

LRESULT CDeskMovr::OnMouseMove( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    CheckCaptionState((short)LOWORD(lParam), (short)HIWORD(lParam));

    if (m_fCaptured && EVAL(S_OK == GetParentWindow()))
    {
        // Okay, it's a hit on one of our gadgets.
        // We're only interested in mouse moves and mouse ups if we're in the
        // process of a drag or resize
        HRESULT hr;
        POINT   ptDoc; // location in document window coords
        POINT   ptScreen;
        HWND    hwndParent = m_hwndParent;

        int x = (short)LOWORD(lParam);
        int y = (short)HIWORD(lParam);

        ptScreen.x = x;
        ptScreen.y = y;
        ptDoc = ptScreen;
        if ( !m_bWndLess ) 
            ::MapWindowPoints( m_hWnd, hwndParent, &ptDoc, 1 );

        if ( m_dmCur == dmMove )
            hr = MoveSelfAndTarget( ptDoc.x + m_dx + m_cxBorder, ptDoc.y + m_dy + m_cyBorder + m_cyCaption );
        else if ( m_dmCur > dmMove )
            hr = SizeSelfAndTarget( ptDoc );

        ASSERT(SUCCEEDED(hr));
    }

    // Set m_cSkipTimer so that we delay dismissing the mover...
    m_cSkipTimer = GET_SKIP_COUNT;

    return 0;
}

LRESULT CDeskMovr::OnTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    HRESULT hr;
    IHTMLElement *pielem;
    POINT   ptCursor;
    BOOL    fDidWork = FALSE;

#ifndef SHDOC401_DLL
    /*
     * Check our animation timer first.  If we are able to disable animations then
     * blow away the timer.  Otherwise reset the timer for 60 seconds and keep on
     * looking.
     */
    if (wParam == ANIMATE_TIMER_ID)
    {
        if (CombView_EnableAnimations(FALSE))
        {
            m_TimerWnd.SetTimer(ANIMATE_TIMER_ID, ANIMATE_TIMER_INTERVAL);
        }
        else
        {
            m_TimerWnd.KillTimer(m_uiTimerID);
            m_uiTimerID = DETECT_TIMER_ID;
            g_fAnimTimer = FALSE;
            m_fTimer = FALSE;
        }

        return 0;
    }
#endif

    if (!m_fTimer || g_fIgnoreTimers || !GetCursorPos( &ptCursor ) || !m_pistyle)
        return 0;

    if (ptCursor.x == m_ptMouseCursor.x && ptCursor.y == m_ptMouseCursor.y)
        // Mouse stayed still from last time we did a timer so, do nothing
        return 0;

    pielem = NULL;

    if (S_OK == GetParentWindow())
    {
        HWND hwndParent = m_hwndParent;
        HWND hwndCursor = WindowFromPoint(ptCursor);

        if ((hwndCursor != hwndParent) && !::IsChild(hwndParent, hwndCursor))
        {
            // The mouse has drifted out of our window, so lose our target, if any
            if (m_iSrcTarget >= 0)
            {
                hr = MoveSelfToTarget( NULL, NULL );
                ASSERT(SUCCEEDED(hr));
                if (hr != S_FALSE)
                {
                    fDidWork = TRUE;
                }
            }
            if (GetCurrentThreadId() == g_dwHookThreadId) {
#ifndef SHDOC401_DLL
                // Set ourselves up so we can look to see if our animations can be turned off
                if (!g_fAnimTimer)
                {
                    if (m_fTimer)
                        m_TimerWnd.KillTimer(m_uiTimerID);

                    if (g_fAnimTimer = (m_TimerWnd.SetTimer(ANIMATE_TIMER_ID, ANIMATE_TIMER_INTERVAL / 10) != 0))
                        m_uiTimerID = ANIMATE_TIMER_ID;
                    m_fTimer = g_fAnimTimer;
                }
#endif
                DismissSelfNow();
                DeactivateMovr(FALSE);
                if (!g_hMouseHook)
                    g_hMouseHook = SetWindowsHookEx(WH_MOUSE, DeskMovr_MouseHook, NULL, GetCurrentThreadId());
            }
        }
        else if (!(GetDesktopFlags() & COMPONENTS_LOCKED) && SUCCEEDED(hr = _IsInElement(hwndParent, &ptCursor, &pielem)))
        {
            // See if we need to do anything based on the element under the mouse pointer
            hr = _TrackElement(&ptCursor, pielem, &fDidWork);
            // we're done with this particular interface pointer
            pielem->Release();
        }
        else if (m_iSrcTarget != -1) {
            // Check to see if we should expand border to size border width
            if (TrackCaption ( &ptCursor ))
            {
                TrackTarget(NULL);
            }
        }
    }

    if (!fDidWork)
        m_ptMouseCursor = ptCursor;
    
    return 0;
}

LRESULT CDeskMovr::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if (!m_bWndLess) {
        RECT rc;
        ::GetClientRect(m_hWnd, &rc);
        FillRect((HDC)wParam, &rc, (HBRUSH)(COLOR_3DFACE + 1));
    }
    bHandled = TRUE;

    return 0;
}

//
// DismissSelfNow - Little helper function to dismiss the mover immediately
//
// Normally dismissal of the mover is desired to be done on a delayed basis.  However,
// there are situations such as when the user clicks on UI or capture is lost etc. where
// it is desirable to dismiss the mover immediately.
//
void CDeskMovr::DismissSelfNow(void)
{
    HRESULT hr;
    m_cSkipTimer = 0;
    hr = MoveSelfToTarget(NULL, NULL);
    ASSERT(SUCCEEDED(hr) && (hr != S_FALSE));
}

LRESULT CDeskMovr::OnCaptureChanged( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if ( m_fCaptured ) {
        _ChangeCapture(FALSE);
        PersistTargetPosition( m_pielemTarget, m_left, m_top, m_width, m_height, m_zIndexTop, FALSE, FALSE, m_ItemState );
        DismissSelfNow();
    }

    return 0;
}

HRESULT CDeskMovr::InPlaceDeactivate(void)
{
    DeactivateMovr(FALSE);
    TraceMsg(TF_CUSTOM1, "CDeskMovr::InPlaceDeactivate()");
    return CComControl<CDeskMovr>::IOleInPlaceObject_InPlaceDeactivate();
}

LRESULT CDeskMovr::OnSetCursor( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (EVAL(S_OK == GetParentWindow()))
    {
        POINT   ptCursor;
        DragMode dm;

        GetCursorPos( &ptCursor );

        ::ScreenToClient( m_hwndParent, &ptCursor );

        // Get ptCursor into deskmovr local coords
        ptCursor.x -= m_left - (CAPTION_ONLY ? 0 : m_cxBorder);
        ptCursor.y -= m_top - (CAPTION_ONLY ? 0 : (m_cyBorder + m_cyCaption));

        dm = DragModeFromPoint(ptCursor);
        m_hcursor = CursorFromDragMode(dm);

        TraceMsg(TF_CUSTOM2, "CDeskMovr::OnSetCursor() Mouse=<%d,%d>, Inner=<%d,%d,%d,%d>, Caption=<%d,%d,%d,%d>, m_bstrTargetName=%ls", 
            ptCursor.x, ptCursor.y, m_rectInner.left, m_rectInner.top, m_rectInner.right, m_rectInner.bottom,
            m_rectCaption.left, m_rectCaption.top, m_rectCaption.right, m_rectCaption.bottom, GEN_DEBUGSTRW(m_bstrTargetName));

    #ifdef DEBUG
        TraceMsg(TF_CUSTOM2, "CDeskMovr::OnSetCursor() New DragMode=""%s""", g_szDragModeStr[dm]);
    #endif // DEBUG

        if (EVAL(m_hcursor != NULL))
            SetCursor( m_hcursor );
        else
            bHandled = FALSE;
    }

    return !bHandled;
}


void CDeskMovr::TrackTarget(POINT * pptDoc)
{
    HRESULT hr = S_OK;

    if ( m_fEnabled && m_pielemTarget != NULL ) {
        LONG left, top;
        POINT pt;
        VARIANT varZ;
        COMPSTATEINFO CompState;

        varZ.vt = VT_I4;

        CLEANUP_ON_FAILURE(hr = CSSOM_TopLeft(m_pielemTarget, &pt));
        m_top = pt.y;
        m_left = pt.x;

        CLEANUP_ON_FAILURE(hr = m_pielemTarget->get_offsetHeight( &m_height ));
        CLEANUP_ON_FAILURE(hr = m_pielemTarget->get_offsetWidth( &m_width ));
  
        // Hack so we don't get weird painting effect of the window hopping to the new
        // target with the old target's size.
        if (!m_bWndLess && m_cyCaption == 0)
            ::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOACTIVATE);

        // Get our rectangle synced with the target (so TrackCaption works properly)
        SyncRectsToTarget();
        // If we discover we want to display the size-border or caption
        // right now then we need to recalculate our rects.
        if (pptDoc && TrackCaption(pptDoc))
            SyncRectsToTarget();

        CLEANUP_ON_FAILURE(hr = m_pistyleTarget->get_zIndex( &varZ ));
        if (!CAPTION_ONLY || (m_cxBorder == m_cxSMBorder))
            --varZ.lVal;
        else
            ++varZ.lVal;
        CLEANUP_ON_FAILURE(hr = SafeZOrderSet(m_pistyle, varZ.lVal));

        // NTRAID94268-2000/03/14 (stephstm): If this is hosted in a window that
        //         has scrollbars, we don't correctly add the screen to document
        //         offset when changing the location of the component.
        //         This causes us to drag incorrectly.

//  98/10/02 #176729 vtan: Now uses the component left and top to
//  position the caption. Offset the caption if the component is
//  not zoomed. If zoomed then just draw over the component.

        left = m_left;
        top = m_top;
        if (!CAPTION_ONLY)
        {
            left -= m_cxBorder;
            top  -= m_cyBorder;
            top  -= m_cyCaption;
        }
        hr = m_pistyle->put_pixelLeft(left);
        hr = m_pistyle->put_pixelWidth( m_rectOuter.right );
        hr = m_pistyle->put_pixelTop(top);
        hr = m_pistyle->put_pixelHeight( m_rectOuter.bottom );

        hr = m_pistyle->put_visibility((BSTR)s_sstrVisible.wsz);

        // We need to persist the original state of the item out now if the item's current width/height is -1
        // This occurs when we are fitting an image to it's default size, we need to make sure the
        // original size real values so it works properly.
        ObtainSavedStateForElem(m_pielemTarget, &CompState, FALSE);
        if (m_bWndLess && CompState.dwWidth == COMPONENT_DEFAULT_WIDTH && CompState.dwHeight == COMPONENT_DEFAULT_HEIGHT)
            PersistTargetPosition(m_pielemTarget, m_left, m_top, m_width, m_height, varZ.lVal, FALSE, TRUE, CompState.dwItemState);
    }

CleanUp:
    ASSERT(SUCCEEDED(hr));
}

BOOL CDeskMovr::TrackCaption( POINT *pptDoc )
{
    int         cyCaption, cyCaptionNew;
    POINT       ptMovr;
    DragMode    dmNew;
    BOOL        fRetVal = FALSE;

    //TraceMsg(TF_CUSTOM2, "CDeskMovr::TrackCaption() Mouse=<%d,%d>", ptMovr.x, ptMovr.y);

    if (pptDoc)
    {
        ptMovr = *pptDoc;
        // need a hit test of some sort within the deskmovr to control border swelling
        ptMovr.x -= m_left - m_cxBorder;
        ptMovr.y -= m_top - (m_cyBorder + m_cyCaption);

        dmNew = DragModeFromPoint( ptMovr );

        cyCaption = GET_CYCAPTION;

        if (dmNew == dmNull) {
            BOOL fInner;
            int iInflate;
            RECT rc;
            // Treat something near the size border as a size border hit
            // so we expand to the size border as the user nears the edge.
            fInner = PtInRect(&m_rectInner, ptMovr);
    
            if (fInner) {
                rc = m_rectInner;
                iInflate = -cyCaption;
            } else {
                rc = m_rectOuter;
                iInflate = cyCaption;
            }
    
            InflateRect(&rc, iInflate, iInflate);
            if (fInner != PtInRect(&rc, ptMovr))
                dmNew = dmSizeRight;
        }

        if ( (pptDoc->y >= m_top - (m_cyBorder + 2 * m_cyCaption) &&
            pptDoc->y <= (m_top + CAPTIONBAR_HOTAREA(cyCaption, m_cyCaption)) ) )
            cyCaptionNew = cyCaption;
        else
            cyCaptionNew = 0;
    }
    else
    {
        cyCaptionNew = GET_CYCAPTION;
        dmNew = dmSizeRight;
    }

    if ( cyCaptionNew != m_cyCaption ||
        (m_dmTrack != dmNew && !((m_dmTrack > dmMove) && (dmNew > dmMove))) ) {
        m_cyCaption = cyCaptionNew;
        if (m_cyCaption == 0)
            m_CaptionState = 0;
        m_dmTrack = dmNew;
        fRetVal = TRUE;
    } else
        m_cyCaption = cyCaptionNew;

    return fRetVal;
}

int CDeskMovr::CountActiveCaptions()
{
    int iCount = 0;

    if (g_dwHookThreadId == GetCurrentThreadId())
    {
        for (int i = 0; i < CDESKMOVR_TRACK_COUNT; i++) {
            if (g_apDM[i] && g_apDM[i]->m_pistyleTarget)
                iCount++;
        }
    }
    return iCount;
}

HRESULT CDeskMovr::_TrackElement(POINT * ppt, IHTMLElement * pielem, BOOL * fDidWork)
{
    HRESULT hr;
    IHTMLElement *pTargElem = NULL;
    LONG iSrcTarget = -1;

    ASSERT(pielem);

    if ( FFindTargetElement( pielem, &pTargElem ) )
    {
        hr = pTargElem->get_sourceIndex( &iSrcTarget );
        ASSERT(SUCCEEDED(hr));
    }

    // If the m_iSrcTarget isn't the same as the SrcTarget under our cursor,
    // then we should move on top of it.
    if ( m_iSrcTarget != iSrcTarget )
    {
        *fDidWork = TRUE;
    
        if ((CountActiveCaptions() > 1) && (-1 == iSrcTarget))
            m_cSkipTimer = 0;

        // Yes, we need to move on top of it.
        hr = MoveSelfToTarget( pTargElem, ppt );
        ASSERT(SUCCEEDED(hr));
        if (hr != S_FALSE)
            m_iSrcTarget = iSrcTarget;
    } 
    else
    {
        // No, so that means we already have focus...
        if (ppt && TrackCaption(ppt))
        {
            TrackTarget(NULL);
        }
    }

    if ( pTargElem != NULL ) { 
        pTargElem->Release(); // MoveSelfToTarget will have secured our reference
    }

    hr = (m_iSrcTarget == -1) ? S_FALSE : S_OK;

    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::InitAttributes  [instance method]
//=--------------------------------------------------------------------------=
// Finds out if the element is resizeable in X and Y direction and sets the
// BITBOOLs accordingly.
//
// Also determines what state the element is in and sets m_ItemState.
//
// Parameters:
//    IHTMLElement*     [in] - interface on event source element
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
HRESULT CDeskMovr::InitAttributes(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR   szMember[MAX_ID_LENGTH];

    ASSERT(pielem);

    m_fCanResizeX = m_fCanResizeY = FALSE;  //Assume "Can't resize!

    // The resizeable member is not required to be specified, only override defaults if present.
    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szMember, ARRAYSIZE(szMember), (BSTR)(s_sstrResizeableMember.wsz))))
    {
        if(StrChr(szMember, TEXT('X')))
                m_fCanResizeX = TRUE;

        if(StrChr(szMember, TEXT('Y')))
                m_fCanResizeY = TRUE;
    }

    // The ItemState is required, return failure if we fail to find the ID
    if (SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szMember, ARRAYSIZE(szMember), (BSTR)(s_sstrIDMember.wsz))))
        m_ItemState = GetCurrentState(szMember);

    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::MoveSelfToTarget   [instance method]
//=--------------------------------------------------------------------------=
// Handles Trident document events as mouse moves over the desktop.
//
// Parameters:
//    IHTMLElement*     [in] - interface on event source element
//    POINT*            [in] - location of mouse (to determine if caption should be displayed)
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//


HRESULT CDeskMovr::MoveSelfToTarget(IHTMLElement *pielem, POINT * pptDoc)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_CUSTOM2, "CDeskMovr::MoveSelfToTarget(pielem=%lx) %s, m_bstrTargetName=%ls", pielem, (pielem ? "We are GETTING focus." : "We are LOOSING focus."), GEN_DEBUGSTRW(m_bstrTargetName));

    if (!pielem)
    {
        // The m_cSkipTimer variable is used to allow the skipping of timer ticks when determining 
        // if the mover should be dismissed.  By doing this it gives the user more time and thus
        // a better chance to manipulate the target if they are prone to drifting the mouse
        // outside the target by accident.

        // Check the m_cSkipTimer before dismissing the mover.
        if (!m_cSkipTimer)
        {
            _ChangeCapture(FALSE);
            if (m_pistyle)
                hr = m_pistyle->put_visibility((BSTR)s_sstrHidden.wsz);
            ATOMICRELEASE( m_pistyleTarget );
            ATOMICRELEASE( m_pielemTarget );
            m_iSrcTarget = -1;
        }
        else
        {
            m_cSkipTimer--;
            hr = S_FALSE;
        }

        // These are actions we want to happen right away.
        m_hcursor = CursorFromDragMode(dmNull);
        if (m_hcursor != NULL)
            SetCursor(m_hcursor);
    }

    // These are actions we want to happen after the Desktop Item
    // looses focus.
    if (hr != S_FALSE)
    {
        m_cyCaption = 0;
        m_cxBorder = m_cxSMBorder;
        m_cyBorder = m_cySMBorder;
        m_CaptionState = 0;
        m_dmTrack = dmNull;
    }

    if (pielem)
    {
        ASSERT(m_pielemTarget != pielem);

        // exchange our new target ( if any ) for the old target, if any...
        ATOMICRELEASE( m_pistyleTarget );
        ATOMICRELEASE( m_pielemTarget );

        hr = pielem->get_style(&m_pistyleTarget);
        if (SUCCEEDED(hr))
        {
            // We are gaining focus.
            m_pielemTarget = pielem;
            m_pielemTarget->AddRef();

            EVAL(SUCCEEDED(InitAttributes(m_pielemTarget)));

            if (!pptDoc)
                TrackCaption(NULL);
            TrackTarget(pptDoc);
            // Set m_cSkipTimer so that we delay dismissing the mover...
            m_cSkipTimer = GET_SKIP_COUNT;
            if (!m_bWndLess && !m_hWnd)
            {
                // This is all a hack until trident fixes the UIDeactivate stuff, bug 243801
                IOleInPlaceObject_InPlaceDeactivate();
                InPlaceActivate(OLEIVERB_UIACTIVATE);
                SetControlFocus(TRUE);
            }
        }
    }
   
    return hr;
}

//=--------------------------------------------------------------------------=
// CDeskMovrControl::MoveSelfAndTarget   [instance method]
//=--------------------------------------------------------------------------=
// Moves the control and it's target to a new location.
//
// Parameters:
//    LONG    [in] - x location, in document coord's to move to
//    LONG    [in] - y location, in document coord's to move to
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
// Notes:
//      We read back the target's location so that we stay consistent with
//      any constraint's Trident might impose on our movement.

HRESULT CDeskMovr::MoveSelfAndTarget( LONG x, LONG y )
{
    HRESULT hr;

    m_top = y;
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( y  - m_cyBorder - m_cyCaption )));
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelTop( y  )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docTop( &m_top )));
    //CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( m_top )));

    m_left = x;
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( x - m_cxBorder )));
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelLeft( x  )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docLeft( &m_left )));
    //CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( m_left )));

    // if ( !m_bWndLess )
    if (EVAL(S_OK == GetParentWindow()))
        ::UpdateWindow(m_hwndParent);

CleanUp:
    return hr;
}

BOOL CDeskMovr::FFindTargetElement( IHTMLElement *pielem, IHTMLElement **ppielem )
{
    *ppielem = NULL;

    if ( pielem != NULL )
    {
        IDeskMovr   *pidm = NULL;       

        // If it is over the mover return the current target, otherwise
        // find out which component if any we are over.
        if ( m_pielemTarget != NULL && 
               SUCCEEDED(pielem->QueryInterface(IID_IDeskMovr, (LPVOID*)&pidm)))
        {
            m_pielemTarget->AddRef();
            *ppielem = m_pielemTarget;
            ATOMICRELEASE(pidm);
        } else {
            HRESULT hr;
            IHTMLElement *pielem2 = pielem;

            pielem2->AddRef();

            do
            {
                VARIANT     var;
    
                VariantInit( &var );
                
                if ( SUCCEEDED(hr = pielem2->getAttribute( (BSTR)s_sstrNameMember.wsz, TRUE, &var)) ) {
                    if ( var.vt == VT_BSTR && var.bstrVal != NULL ) {
                        if ( StrCmpW( var.bstrVal, m_bstrTargetName ) == 0 )
                            hr = S_OK;
                        else
                            hr = S_FALSE;               
                    } else
                        hr = S_FALSE; // Try VariantChangeType?????
                } else
                    hr = S_FALSE; // not here, maybe in parent.
            
                VariantClear( &var );
    
                if ( hr == S_OK ) { // we found it
                    hr = pielem2->QueryInterface( IID_IHTMLElement, (LPVOID*)ppielem );
                } else if ( hr == S_FALSE ) { // not this one, climb up
                    IHTMLElement *pielemParent = NULL;
                
                    pielem2->get_parentElement( &pielemParent );
                    pielem2->Release();     // we're through at this level
                    pielem2 = pielemParent; // may be null, which just means we've reached the top.
                }
    
            } while ( SUCCEEDED(hr) && *ppielem == NULL && pielem2 != NULL );
        
            ATOMICRELEASE(pielem2);
        }
    }

    return *ppielem != NULL;
}

//=--------------------------------------------------------------------------=
// CDeskMovr::DragModeFromPoint   [instance method]
//=--------------------------------------------------------------------------=
// Moves the control and it's target to a new location.
//
// Parameters:
//    POINT        -  point to test, in local coords
//
// Output:
//    DragMode      - drag mode associated with the point
//
// Notes:
//      This is only a hit testing method. It does not alter state.

CDeskMovr::DragMode CDeskMovr::DragModeFromPoint( POINT pt )
{
    enum DragMode dm = dmNull;
    RECT rc;

    if ( PtInRect( &m_rectInner, pt ) ) 
    { // either no-hit, or on caption
        if ( PtInRect( &m_rectCaption, pt ) ) {
            DragMode dmT;

            for (dmT = dmMenu; dmT < dmMove; dmT = (DragMode)((int)dmT + 1)) {
                if (GetCaptionButtonRect(dmT, &rc) && PtInRect(&rc, pt)) {
                    dm = dmT;
                    break;
                }
            }
            if ((dmT == dmMove) && !CAPTION_ONLY)
                dm = dmMove;
        }
    } else {
        if ( PtInRect( &m_rectOuter, pt ) ) {
            if (!CAPTION_ONLY)
            {
                // a resize border hit
                if ( pt.y <= m_sizeCorner.cy ) {
                    // upper edge or corners
                    if ( pt.x <= m_sizeCorner.cx )
                        dm = dmSizeWHTL;
                    else if ( pt.x >= m_rectOuter.right - m_sizeCorner.cx )
                        dm = dmSizeWHTR;
                    else
                        dm = dmSizeTop;
                } else if ( pt.y >= m_rectOuter.bottom - m_sizeCorner.cy ) {
                    // bottom edge or corners
                    if ( pt.x <= m_sizeCorner.cx )
                        dm = dmSizeWHBL;
                    else if ( pt.x >= m_rectOuter.right - m_sizeCorner.cx )
                    dm = dmSizeWHBR;
                    else
                        dm = dmSizeBottom;
                } else {
                    // side edge hit
                    if ( pt.x > m_rectInner.left )
                        dm = dmSizeRight;
                    else 
                        dm = dmSizeLeft;
                }
            } else {
                if (m_cyCaption == 0)
                {
                    if(IS_BIDI_LOCALIZED_SYSTEM())
                    {
                        dm = dmSizeRight;
                    }
                    else
                    {
                        dm = dmSizeLeft;                        
                    }
                }    
                else
                    dm = dmNull;
            }
        }
        //Check if this element can be sized in both the directions.
        if(!m_fCanResizeX)
        {
            if((dm != dmSizeTop) && (dm != dmSizeBottom))
                dm = dmNull;
        }

        if(!m_fCanResizeY)
        {
            if((dm != dmSizeLeft) && (dm != dmSizeRight))
                dm = dmNull;
        }
    }

    return dm;
}

// Align our member RECTs with the dimensions of the target element.
void CDeskMovr::SyncRectsToTarget(void)
{
    // do the swelling thang
    if ( (m_dmTrack > dmMove) || m_cyCaption ) {
        m_cxBorder = GET_CXSIZE;
        m_cyBorder = GET_CYSIZE;
    } else {
        m_cxBorder = m_cxSMBorder;
        m_cyBorder = m_cySMBorder;
    }

    m_rectOuter.top = m_rectOuter.left = 0;

    if (CAPTION_ONLY)
    {
        if (m_cyCaption != 0)
        {
            // Displaying just caption
            m_rectOuter.bottom = m_cyCaption + m_cyBorder;
            m_rectOuter.right = m_width;
        } else {
            // Displaying just left size border
            m_rectOuter.bottom = m_height;
            if(IS_BIDI_LOCALIZED_SYSTEM())
            {
                m_rectOuter.right = m_width;
                m_rectOuter.left = m_rectOuter.right - m_cxBorder;
            }
            else
            {
                m_rectOuter.right = m_cxBorder;
            }    
        }
    } else {
        // Displaying caption and border
        m_rectOuter.bottom = m_height + 2 * m_cyBorder + m_cyCaption;
        m_rectOuter.right = m_width + 2 * m_cxBorder;
    }

    if (CAPTION_ONLY && m_cyCaption == 0)
    {
        // Displaying just left size border
        SetRectEmpty(&m_rectInner);
        SetRectEmpty(&m_rectCaption);
    } else {
        // Displaying caption and possibly border
        m_rectInner = m_rectOuter;
        InflateRect( &m_rectInner, -m_cxBorder, -m_cyBorder );

        m_rectCaption = m_rectInner;
        m_rectCaption.bottom = m_cyBorder + m_cyCaption;

    }

    if ( m_rectOuter.bottom > 2 * m_cyCaption )
        m_sizeCorner.cy = GET_CYCAPTION;
    else
        m_sizeCorner.cy = m_rectOuter.bottom / 2;

   if ( m_rectOuter.right > 2 * m_cyCaption )
        m_sizeCorner.cx = GET_CYCAPTION;
    else
        m_sizeCorner.cx = m_rectOuter.right / 2;


}

HCURSOR CDeskMovr::CursorFromDragMode( DragMode dm )
{   
    ASSERT( dm >= 0 && dm < cDragModes );
    switch (dm) {
        case dmNull:
        case dmMenu:
        case dmClose:
        case dmMove:
        case dmRestore:
        case dmFullScreen:
        case dmSplit:
        default:
            return LoadCursor(NULL, IDC_ARROW);
        case dmSizeWHBR:
        case dmSizeWHTL:
            return LoadCursor(NULL, IDC_SIZENWSE);
        case dmSizeWHTR:
        case dmSizeWHBL:
            return LoadCursor(NULL, IDC_SIZENESW);
        case dmSizeTop:
        case dmSizeBottom:
            return LoadCursor( NULL, IDC_SIZENS );
        case dmSizeLeft:
        case dmSizeRight:
            return LoadCursor( NULL, IDC_SIZEWE );
    }
}

//=--------------------------------------------------------------------------=
// CDeskMovr::SizeSelfAndTarget   [instance method]
//=--------------------------------------------------------------------------=
// Resizes our control and its target element.
//
// Parameters:
//    LONG    [in] - new width
//    LONG    [in] - new height
//
// Output:
//    HRESULT      - various. S_OK if  operation succeeded.
//
// Notes:
//      We read back the target's dimensions so that we stay consistent with
//      any constraint's Trident might impose on our sizing.

HRESULT CDeskMovr::SizeSelfAndTarget( POINT ptDoc )
{
    HRESULT hr;
    int topOld = m_top;
    int leftOld = m_left;
    int heightOld = m_height;
    int widthOld = m_width;
    int cyCaption = GET_CYCAPTION;

    switch ( m_dmCur ) {
    case dmSizeWHBR:
        m_width = (ptDoc.x + m_dx) - m_left;
        m_height = (ptDoc.y + m_dy) - m_top;
        break;
    case dmSizeWHTL:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeWHTR:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        m_width = (ptDoc.x + m_dx) - m_left;
        break;
    case dmSizeWHBL:
        m_height = (ptDoc.y + m_dy) - m_top;
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeTop:
        m_top = ptDoc.y + m_dy;
        m_height += topOld - m_top;
        break;
    case dmSizeBottom:
        m_height = (ptDoc.y + m_dy) - m_top;
        break;
    case dmSizeLeft:
        m_left = ptDoc.x + m_dx;
        m_width += leftOld - m_left;
        break;
    case dmSizeRight:
        m_width = (ptDoc.x + m_dx) - m_left;
        break;
    default:
        ASSERT(FALSE);
        return E_FAIL;
    }

    // limit shrinkage to keep the handle accessible
    if ( m_height < cyCaption ) {
        m_height = cyCaption;
        if ( m_top != topOld )
            m_top = topOld + heightOld - m_height;
    }
 
    // limit shrinkage to keep the handle accessible
    if ( m_width < (4 * cyCaption) ) {
        m_width = 4 * cyCaption;
        if ( m_left != leftOld )
            m_left = leftOld + widthOld - m_width;
    }

    SyncRectsToTarget();

    if ( m_top != topOld ) {
        CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelTop( m_top )));
        CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelTop( m_top - (m_cyBorder + m_cyCaption) )));
    }

    if ( m_left != leftOld ) {
        CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelLeft( m_left )));
        CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft( m_left - (CAPTION_ONLY ? 0 : m_cxBorder) )));
    }
 
    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelHeight( m_height )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docHeight( &m_height )));
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelHeight( m_rectOuter.bottom )));

    CLEANUP_ON_FAILURE((hr = m_pistyleTarget->put_pixelWidth( m_width )));
    // read it back to catch Trident constraint.
    //CLEANUP_ON_FAILURE((hr = m_pielemTarget->get_docWidth( &m_width )));
    CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelWidth( m_rectOuter.right )));

    if(IS_BIDI_LOCALIZED_SYSTEM() && CAPTION_ONLY)
    {
         CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelLeft(m_rectOuter.left )));
         CLEANUP_ON_FAILURE((hr = m_pistyle->put_pixelWidth(m_rectOuter.right - m_rectOuter.left )));

    }

    if (EVAL(S_OK == GetParentWindow()))
        ::UpdateWindow(m_hwndParent);

CleanUp:
    return hr;
}


// IQuickActivate
HRESULT CDeskMovr::QuickActivate(QACONTAINER *pQACont, QACONTROL *pQACtrl)
{
    HRESULT hr = IQuickActivate_QuickActivate(pQACont, pQACtrl);

    if (pQACont)
    {
        ClearFlag(pQACtrl->dwViewStatus, VIEWSTATUS_OPAQUE);
    }

    return hr;
}


HRESULT CDeskMovr::_GetHTMLDoc(IOleClientSite * pocs, IHTMLDocument2 ** pphd2)
{
    HRESULT hr;
    IOleContainer * poc = NULL;

    if (!EVAL(pocs) || !EVAL(pphd2))
        return E_INVALIDARG;

    *pphd2 = NULL;
    hr = pocs->GetContainer(&poc);
    if (SUCCEEDED(hr))
    {
         hr = poc->QueryInterface(IID_IHTMLDocument2, (LPVOID*) pphd2);
         poc->Release();
    }

    return hr;
}



HRESULT CDeskMovr::_IsInElement(HWND hwndParent, POINT * ppt, IHTMLElement ** pphe)
{
    HRESULT hr = E_FAIL;
    ASSERT(pphe);

    *pphe = NULL;
    if (!ppt || ::ScreenToClient(hwndParent, ppt))
    {
        IHTMLDocument2 * phd2;

        ASSERT(m_spClientSite);
        hr = _GetHTMLDoc(m_spClientSite, &phd2);
        if (SUCCEEDED(hr))
        {
            if (ppt)
                hr = phd2->elementFromPoint(ppt->x, ppt->y, pphe);
            else
                hr = phd2->get_activeElement(pphe);

            if (!*pphe && SUCCEEDED(hr))
                hr = E_FAIL;    // Sometimes Trident returns S_FALSE on error.

            phd2->Release();
        }
    }

    return hr;
}



HRESULT CDeskMovr::_EnumComponents(LPFNCOMPENUM lpfn, LPVOID lpvData, DWORD dwData)
{
    HRESULT hr = E_FAIL;
    IActiveDesktop * padt = NULL;

    hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID *)&padt);
    if (SUCCEEDED(hr))
    {
        int nCount;
        int nIndex;

        hr = padt->GetDesktopItemCount(&nCount, 0);

        if (EVAL(SUCCEEDED(hr)))
        {
            COMPONENT comp;

            for (nIndex = 0; nIndex < nCount; nIndex++)
            {
                comp.dwSize = sizeof(COMPONENT);

                hr = padt->GetDesktopItem(nIndex, &comp, 0);
                if (EVAL(SUCCEEDED(hr)))
                {
                    if ((hr = lpfn(&comp, lpvData, dwData)) != S_OK)
                        break;
                }
            }
        }

        padt->Release();
    }

    return hr;
}

HRESULT CDeskMovr::_EnumElements(LPFNELEMENUM lpfn, LPVOID lpvData, DWORD dwData)
{
    HRESULT hr;
    IHTMLDocument2 * phd2;

    ASSERT(m_spClientSite);

    if (SUCCEEDED(hr = _GetHTMLDoc(m_spClientSite, &phd2)))
    {
        IHTMLElementCollection * pelems;

        if (SUCCEEDED(hr = phd2->get_all(&pelems)))
        {
            VARIANT varIndex;
            VARIANT varDummy;
            IDispatch * pidisp;

            VariantInit(&varDummy);
            varIndex.vt = VT_I4;
            varIndex.lVal = 0;

            // Note:  This loop terminates when trident returns SUCCESS - but with a NULL pidisp.
            while (SUCCEEDED(hr = pelems->item(varIndex, varDummy, &pidisp)) && pidisp)
            {
                IHTMLElement * pielem;

                if (SUCCEEDED(hr = pidisp->QueryInterface(IID_IHTMLElement, (LPVOID *)&pielem)))
                {
                    hr = lpfn(pielem, lpvData, dwData);
                    pielem->Release();
                }

                pidisp->Release();

                if (hr != S_OK)
                    break;

                varIndex.lVal++;
            }

            pelems->Release();
        }
        phd2->Release();
    }
    return hr;
}


HRESULT lpfnZOrderCB(COMPONENT * pcomp, LPVOID lpvData, DWORD dwData)
{
    #define LPZORDERSLOT ((LONG *)lpvData)

    if (dwData ? (pcomp->cpPos.izIndex > *LPZORDERSLOT) : (pcomp->cpPos.izIndex < *LPZORDERSLOT))
        *LPZORDERSLOT = pcomp->cpPos.izIndex;

    return S_OK;
}

HRESULT CDeskMovr::_GetZOrderSlot(LONG * plZOrderSlot, BOOL fTop)
{
    HRESULT hr;

    ASSERT(plZOrderSlot);

    *plZOrderSlot = m_bWindowOnly ? 10000 : 5000;

    hr = _EnumComponents(lpfnZOrderCB, (LPVOID)plZOrderSlot, (DWORD)fTop);

    *plZOrderSlot += fTop ? 2 : -2; // Make sure we are above / below.

    return hr;
}


//=--------------------------------------------------------------------------=
// PersistTargetPosition   [helper function]
//=--------------------------------------------------------------------------=
// Update the registry entries that are the persistence of the desktop HTML.
//
// Parameters:
//    <none>
//
// Output:
//    <none>
//
// Notes:
//      If we fail, we do it quietly.
//=--------------------------------------------------------------------------=

void PersistTargetPosition( IHTMLElement *pielem,
                            int left,
                            int top,
                            int width,
                            int height,
                            int zIndex,
                            BOOL fSaveState,
                            BOOL fSaveOriginal,
                            DWORD dwNewState)
{
    // only do this persistence thing if we're in ( or completing ) an operation
    TCHAR szID[MAX_ID_LENGTH];
    BOOL fOK;

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, ARRAYSIZE(szID), (BSTR)(s_sstrIDMember.wsz))))
    {
        BOOL        bChangedPosition, bChangedSize;
        COMPPOS     compPos;

        // 99/03/23 #266412 vtan: The user has moved the deskmovr to a new position
        // make sure that it is within the work area of the display monitors.
        // ValidateComponentPosition() will do this for us and tell us whether the
        // the component got moved or resized.

        compPos.dwSize = sizeof(compPos);
        compPos.iLeft = left;
        compPos.iTop = top;
        compPos.dwWidth = width;
        compPos.dwHeight = height;

        ValidateComponentPosition(&compPos, dwNewState, COMP_TYPE_HTMLDOC, &bChangedPosition, &bChangedSize);
        if (bChangedPosition || bChangedSize)
        {
            IHTMLStyle  *pIStyle;

            // If the component got moved or resized then tell the object model
            // where the deskmovr is now.

            left = compPos.iLeft;
            top = compPos.iTop;
            width = compPos.dwWidth;
            height = compPos.dwHeight;
            if (SUCCEEDED(pielem->get_style(&pIStyle)))
            {
                pIStyle->put_pixelLeft(left);
                pIStyle->put_pixelTop(top);
                pIStyle->put_pixelWidth(width);
                pIStyle->put_pixelHeight(height);
                pIStyle->Release();
            }
        }
        fOK = UpdateDesktopPosition(szID, left, top, width, height, zIndex, fSaveState, fSaveOriginal, dwNewState);
    }

    TraceMsg(TF_CUSTOM2, "PersistTargetPosition(pielem=%s, <left=%d, top=%d, wid=%d, h=%d>)", szID, left, top, width, height);

}

void ObtainSavedStateForElem( IHTMLElement *pielem,
                       LPCOMPSTATEINFO pCompState, BOOL fRestoredState)
{
    // only do this persistence thing if we're in ( or completing ) an operation
    TCHAR szID[MAX_ID_LENGTH];

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, ARRAYSIZE(szID), (BSTR)(s_sstrIDMember.wsz))))
    {
        GetSavedStateInfo(szID, pCompState, fRestoredState);
    }

    TraceMsg(TF_CUSTOM2, "ObtainSavedStateForElem(pielem=%s, <left=%d, top=%d, wid=%d, h=%d>)", szID, pCompState->iLeft, pCompState->iTop, pCompState->dwWidth, pCompState->dwHeight);

}

// IOleObject
HRESULT CDeskMovr::GetMiscStatus(DWORD  dwAspect, DWORD *pdwStatus)
{
    if (dwAspect == DVASPECT_CONTENT)
    {
        *pdwStatus = OLEMISMOVR;
        return S_OK;
    }
    else
    {
        return DV_E_DVASPECT;
    }

    // dead code
}


HRESULT CDeskMovr::SetClientSite(IOleClientSite * pClientSite)
{
    if (!pClientSite)
        DeactivateMovr(FALSE);

    return CComControlBase::IOleObject_SetClientSite(pClientSite);
}

void HandleRestore(IHTMLElement * pielem, LONG lData)
{
    VARIANT varZ;
    COMPSTATEINFO csiRestore;
    IHTMLStyle * pistyle;

    if (SUCCEEDED(pielem->get_style(&pistyle)))
    {
        csiRestore.dwSize = sizeof(csiRestore);

        ObtainSavedStateForElem(pielem, &csiRestore, TRUE); // TRUE => Get restored state!

        pistyle->put_pixelLeft(csiRestore.iLeft);
        pistyle->put_pixelTop(csiRestore.iTop);
        pistyle->put_pixelWidth(csiRestore.dwWidth);
        pistyle->put_pixelHeight(csiRestore.dwHeight);

        varZ.vt = VT_I4;
        varZ.lVal = lData;
        pistyle->put_zIndex(varZ);

        PersistTargetPosition(pielem, csiRestore.iLeft, csiRestore.iTop, csiRestore.dwWidth, csiRestore.dwHeight, varZ.lVal, FALSE, FALSE, IS_NORMAL);
        pistyle->Release();
    }
}

HRESULT lpfnRestoreCB(IHTMLElement * pielem, LPVOID lpvData, LONG lData)
{
    HRESULT hres = S_OK;
    TCHAR szID[MAX_ID_LENGTH];

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szID, ARRAYSIZE(szID), (BSTR)(s_sstrIDMember.wsz))))
    {
        DWORD dwState = GetCurrentState(szID);

        // Since there is only one in this state we can stop the enumeration if we
        // find a fullscreen/split item on this work area.
        if (dwState & (IS_FULLSCREEN | IS_SPLIT)) {
            POINT pt;
            if (SUCCEEDED(CSSOM_TopLeft(pielem, &pt)) && PtInRect((CONST RECT *)lpvData, pt))
            {
                HandleRestore(pielem, lData);
                hres = S_FALSE;
            }
        }
    }

    return hres;
}


HRESULT CDeskMovr::_HandleZoom(LONG lCommand)
{
    LONG x, y, cx, cy, zIndex;
    VARIANT varZ;
    DWORD   dwOldItemState = m_ItemState, dwNewItemState;
    IHTMLStyle * pistyleTarget = m_pistyleTarget;
    IHTMLElement * pielemTarget = m_pielemTarget;

    // Paranoia
    if (!pistyleTarget || !pielemTarget)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    // Hold on to these guys during this call, they could go away when we yield
    // like during the animation call below.
    pistyleTarget->AddRef();
    pielemTarget->AddRef();

    if (lCommand == IDM_DCCM_RESTORE)
    {
        COMPSTATEINFO   csi;
        csi.dwSize = sizeof(csi);

        // The "Restore" command toggles with the "Reset Original Size" command.
        // Make sure we get the correct Restore or Reset position for the element.
        ObtainSavedStateForElem(pielemTarget, &csi, !ISNORMAL);

        if (ISNORMAL)
        {
            // This is the split case, dont move the item just resize it.
            x = m_left;
            y = m_top;
        }
        else
        {

//  98/07/27 vtan #176721: The following checks restoration of a component
//  position from zoomed to user-specified position. If the component
//  is placed at the default position then it is positioned now using
//  the standard positioning code.

            if ((csi.iLeft == COMPONENT_DEFAULT_LEFT) &&
                (csi.iTop == COMPONENT_DEFAULT_TOP) &&
                (csi.dwWidth == COMPONENT_DEFAULT_WIDTH) &&
                (csi.dwHeight == COMPONENT_DEFAULT_HEIGHT))
            {
                COMPPOS     compPos;

                GetNextComponentPosition(&compPos);
                IncrementComponentsPositioned();
                csi.iLeft = compPos.iLeft;
                csi.iTop  = compPos.iTop;
                csi.dwWidth = compPos.dwWidth;
                csi.dwHeight = compPos.dwHeight;
            }
            // Restore case, go ahead and move it.
            x = csi.iLeft;
            y = csi.iTop;
        }

        cx = csi.dwWidth;
        cy = csi.dwHeight;
        m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_NORMAL;
        dwNewItemState = m_ItemState;

        m_zIndexTop += 2;
        zIndex = m_zIndexTop;
    }
    else
    {
        RECT rcZoom, rcWork;

        GetZoomRect(lCommand == IDM_DCCM_FULLSCREEN, TRUE, m_left, m_top, m_width, m_height, &rcZoom, &rcWork);
        
        x = rcZoom.left;
        y = rcZoom.top;
        cx = rcZoom.right - rcZoom.left;
        cy = rcZoom.bottom - rcZoom.top;

        if (lCommand == IDM_DCCM_FULLSCREEN)
        {
            m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_FULLSCREEN;
            dwNewItemState = m_ItemState;
        }
        else
        {
            m_ItemState = (m_ItemState & ~IS_VALIDSIZESTATEBITS) | IS_SPLIT;
            dwNewItemState = m_ItemState;
        }

        varZ.vt = VT_I4;
        pistyleTarget->get_zIndex(&varZ);

        // We currently only allow 1 component to be either split or full screen per monitor (WorkArea), so
        // restore any other component that is currently in this state.
        _EnumElements(lpfnRestoreCB, (LPVOID)&rcWork, varZ.lVal);

        m_zIndexBottom -= 2;
        zIndex = m_zIndexBottom;
    }

    // We want to do the animation call before we start moving the target, it looks better
    // that way.
    AnimateComponent(m_hwndParent, m_left, m_top, m_width, m_height, x, y, cx, cy);

    pistyleTarget->put_pixelLeft(x);
    pistyleTarget->put_pixelTop(y);
    pistyleTarget->put_pixelWidth(cx);
    pistyleTarget->put_pixelHeight(cy);

    varZ.vt = VT_I4;
    varZ.lVal = zIndex;
    pistyleTarget->put_zIndex(varZ);

    PersistTargetPosition(pielemTarget, x, y, cx, cy, zIndex, 
                            (BOOL)((dwOldItemState & IS_NORMAL) && !(dwNewItemState & IS_NORMAL)),
                            FALSE, dwNewItemState);

    pistyleTarget->Release();
    pielemTarget->Release();

    return S_OK;
}


/************************************************************************\
    FUNCTION: CDeskMovr::_DisplayContextMenu

    PARAMETERS:
        x,y - Coordinates relative to the desktop window.
\************************************************************************/
HRESULT CDeskMovr::_DisplayContextMenu()
{
    HRESULT hr = S_OK;
    HMENU hmenuContext = LoadMenuPopup(MENU_DESKCOMP_CONTEXTMENU);

    TraceMsg(TF_CUSTOM2, "CDeskMovr::DisplayContextMenu(), m_bstrTargetName=%ls", GEN_DEBUGSTRW(m_bstrTargetName));
    if (hmenuContext)
    {
        int nSelection;
        BOOL fSubscribe = FALSE;
        BOOL fRemoveSubscribe = FALSE;
        TCHAR szName[MAX_URL_STRING];
        POINT point;

        if (CAPTION_ONLY)
        {
            point.x = m_left + m_cxBorder;
            point.y = m_top + (m_cyCaption + m_cyBorder) - 4 * m_cySMBorder;
        } else {
            point.x = m_left - m_cxSMBorder;
            point.y = m_top - 4 * m_cySMBorder;
        }

        ::ClientToScreen(m_hwndParent, &point);

        //  This calculation needs to be revisited.  The reason it's so
        //  ugle and HACKy is because to look good, we want the context menu
        //  to appear on top of the 3-D edge below the triangle.


        if (SUCCEEDED(GetHTMLElementStrMember(m_pielemTarget, szName, ARRAYSIZE(szName), (BSTR)(s_sstrSubSRCMember.wsz))))
        {
            int nScheme = GetUrlScheme(szName);

            if ((URL_SCHEME_FILE == nScheme) || (URL_SCHEME_INVALID == nScheme))
                fRemoveSubscribe = TRUE;
        }

        // check to see if we need to turn some things off or on
        // Mainly because we are disabling features Admins don't want users to have.

        hr = IElemCheckForExistingSubscription(m_pielemTarget);
        if (fRemoveSubscribe || FAILED(hr))    // This object/thing cannot be subscribed to. (Channel Changer, Orenge Blob).
        {
            MENUITEMINFO    menuItemInfo;

            DeleteMenu(hmenuContext, IDM_DCCM_OFFLINE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);

            // Is the top item in the list a separator?
            menuItemInfo.cbSize = sizeof(menuItemInfo);
            menuItemInfo.fMask = MIIM_TYPE;
            if ((GetMenuItemInfo(hmenuContext, 0, TRUE, &menuItemInfo) != FALSE) &&
                (menuItemInfo.fType == MFT_SEPARATOR))
            {
                // Yes, it is, so remove it.
                DeleteMenu(hmenuContext, 0, MF_BYPOSITION);
            }
        }
        else if (S_FALSE == hr)      // Not subscribed
        {
            DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);
            fSubscribe = TRUE;
        }
        else if (S_OK == hr)
        {
            if (SHRestricted2(REST_NoManualUpdates, NULL, 0))
                DeleteMenu(hmenuContext, IDM_DCCM_SYNCHRONIZE, MF_BYCOMMAND);
            if (SHRestricted(REST_NOEDITDESKCOMP))
                DeleteMenu(hmenuContext, IDM_DCCM_PROPERTIES, MF_BYCOMMAND);

            CheckMenuItem(hmenuContext, IDM_DCCM_OFFLINE, MF_BYCOMMAND |MF_CHECKED);
        }

        if (SHRestricted(REST_NOCLOSEDESKCOMP))
            EnableMenuItem(hmenuContext, IDM_DCCM_CLOSE, MF_BYCOMMAND | MF_GRAYED);

        // If policy is set to lock down active desktop, don't put up the
        //    menu that invokes the web-tab
        if (SHRestricted(REST_NOACTIVEDESKTOPCHANGES) || SHRestricted(REST_NODISPBACKGROUND))
        {
            EnableMenuItem(hmenuContext, IDM_DCCM_CUSTOMIZE, MF_BYCOMMAND | MF_GRAYED);
        }
        
        if (ISNORMAL)
        {
            COMPSTATEINFO CompState;
            LoadString(HINST_THISDLL, IDS_MENU_RESET, szName, ARRAYSIZE(szName));
            ModifyMenu(hmenuContext, IDM_DCCM_RESTORE, MF_BYCOMMAND | MF_STRING, IDM_DCCM_RESTORE, szName);
            ObtainSavedStateForElem(m_pielemTarget, &CompState, FALSE);
            if ((CompState.dwWidth == COMPONENT_DEFAULT_WIDTH && CompState.dwHeight == COMPONENT_DEFAULT_HEIGHT) ||
                (CompState.dwWidth == (DWORD)m_width && CompState.dwHeight == (DWORD)m_height))
                EnableMenuItem(hmenuContext, IDM_DCCM_RESTORE, MF_BYCOMMAND | MF_GRAYED);
        }
        if (ISSPLIT || !m_fCanResizeX || !m_fCanResizeY)
            EnableMenuItem(hmenuContext, IDM_DCCM_SPLIT, MF_BYCOMMAND | MF_GRAYED);
        if (ISFULLSCREEN || !m_fCanResizeX || !m_fCanResizeY)
            EnableMenuItem(hmenuContext, IDM_DCCM_FULLSCREEN, MF_BYCOMMAND | MF_GRAYED);

        g_fIgnoreTimers |= IGNORE_CONTEXTMENU_UP;

        nSelection = TrackPopupMenu(hmenuContext, TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, point.x, point.y, 0, m_hwndParent, NULL);
        
        DestroyMenu(hmenuContext);

        m_CaptionState &= ~CS_MENUPUSHED;
        UpdateCaption(DMDC_MENU);

        switch (nSelection)
        {
            case IDM_DCCM_OFFLINE:
                if (fSubscribe)
                    hr = IElemSubscribeDialog(m_pielemTarget, m_hWnd);
                else
                    hr = IElemUnsubscribe(m_pielemTarget);
                break;

            case IDM_DCCM_SYNCHRONIZE:
                hr = IElemUpdate(m_pielemTarget);
                break;

            case IDM_DCCM_PROPERTIES:   // Subscriptions Dialog (Don't let the name fool you)
                TraceMsg(TF_CUSTOM2, "CDeskMovr::_DisplayContextMenu() IDM_DCCM_PROPERTIES m_bstrTargetName=%ls.", GEN_DEBUGSTRW(m_bstrTargetName));
                    hr = IElemGetSubscriptionsDialog(m_pielemTarget, NULL);
                break;

            case IDM_DCCM_CUSTOMIZE:   // Show Display Control Panel set to Components Sheet
                LoadString(HINST_THISDLL, IDS_COMPSETTINGS, szName, ARRAYSIZE(szName));
                SHRunControlPanel(szName, NULL);
                hr = S_OK;
                break;

            case IDM_DCCM_CLOSE:
                ASSERT(!SHRestricted(REST_NOCLOSEDESKCOMP));  // We should never be able to get here.
    
                TraceMsg(TF_CUSTOM2, "CDeskMovr::_DisplayContextMenu() IDM_DCCM_CLOSE m_bstrTargetName=%ls", GEN_DEBUGSTRW(m_bstrTargetName));
//                AnimateToTray(m_hwndParent, m_left, m_top, m_width, m_height);
                hr = IElemCloseDesktopComp(m_pielemTarget);
                break;

            case IDM_DCCM_RESTORE:
            case IDM_DCCM_FULLSCREEN:
            case IDM_DCCM_SPLIT:
                hr = _HandleZoom(nSelection);
                break;

            case IDM_DCCM_OPEN:
                {
                    BOOL fShowFrame = (GetKeyState(VK_SHIFT) < 0) ? !(m_fCanResizeX && m_fCanResizeY) : (m_fCanResizeX && m_fCanResizeY);
                    hr = IElemOpenInNewWindow(m_pielemTarget, m_spClientSite, fShowFrame, m_width, m_height);
                }
                break;

        }

        g_fIgnoreTimers &= ~IGNORE_CONTEXTMENU_UP;

        if (nSelection)
            DismissSelfNow();
    }

    return hr;
}

void CDeskMovr::_MapPoints(int * px, int * py)
{
    if (m_bWndLess)
    {
        *px -= m_left - (CAPTION_ONLY ? 0 : m_cxBorder);
        *py -= m_top - (CAPTION_ONLY ? 0 : (m_cyBorder + m_cyCaption));
    }
}

void CDeskMovr::_ChangeCapture(BOOL fSet)
{
    if (m_fCaptured != fSet)
    {
        m_fCaptured = fSet;
        if (fSet)
        {
            ASSERT(m_spInPlaceSite);
            if (m_bWndLess && m_spInPlaceSite)
            {
                m_fCaptured = SUCCEEDED(m_spInPlaceSite->SetCapture(TRUE));
            }
            else
            {
                ::SetCapture( m_hWnd );
                m_fCaptured = (GetCapture() == m_hWnd);
            }
            if (m_fCaptured)
                g_fIgnoreTimers |= IGNORE_CAPTURE_SET;
        }
        else
        {
            ASSERT(m_spInPlaceSite);
            if (m_bWndLess && m_spInPlaceSite)
            {
                m_spInPlaceSite->SetCapture(FALSE);
            }
            else
            {
                ReleaseCapture();
            }
        
            g_fIgnoreTimers &= ~IGNORE_CAPTURE_SET;
        }
    }
}

// Called from our keyboard hook so that we can implement keyboard invocation and dismissal
// of the deskmovr.
void CDeskMovr::OnKeyboardHook(WPARAM wParam, LPARAM lParam)
{
    IHTMLElement * pielem;
    HWND hwndFocus = GetFocus();

    if (!(g_fIgnoreTimers & IGNORE_CONTEXTMENU_UP) && SUCCEEDED(GetParentWindow()) && ((hwndFocus == m_hwndParent) || ::IsChild(m_hwndParent, hwndFocus)))
    {
        switch (wParam) {
            case VK_MENU:
                if (!m_pielemTarget && !(GetDesktopFlags() & COMPONENTS_LOCKED) && SUCCEEDED(SmartActivateMovr(ERROR_SUCCESS)) && SUCCEEDED(_IsInElement(NULL, NULL, &pielem)))
                {
                    BOOL fDummy;
                    _TrackElement(NULL, pielem, &fDummy);
                    pielem->Release();
                }
                break;

            case VK_ESCAPE:
            case VK_TAB:
                if ((lParam >= 0) && m_pielemTarget)  // If key down, dismiss
                    DismissSelfNow();
                break;

            case VK_SPACE:
                if (m_pielemTarget && (GET_CYCAPTION == m_cyCaption) && (HIWORD(lParam) & KF_ALTDOWN))
                {
                    HandleNonMoveSize(dmMenu);
                }
                break;
        }
    }
}


STDAPI CDeskMovr_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppunk)
{
    return CComCreator< CComPolyObject< CDeskMovr > >::CreateInstance( (LPVOID)pUnkOuter, IID_IUnknown, (LPVOID*)ppunk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskstat.h ===
#ifndef _DESKSTAT_H_
#define _DESKSTAT_H_

#include "mshtml.h"



// NOTE: This is NOT a IE4COMPONENTA struct, it is a IE4COMPONENTT struct.
// Note: This is the old COMPONENTA structure used in IE4. It is kept here for compatibility.
typedef struct _tagIE4COMPONENTA
{
    DWORD   dwSize;
    DWORD   dwID; //Don't make this DWORD_PTR. The public version of this struct uses DWORD here.
    int     iComponentType;
    BOOL    fChecked;
    BOOL    fDirty;
    BOOL    fNoScroll;
    COMPPOS cpPos;
    TCHAR   szFriendlyName[MAX_PATH];
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];
} IE4COMPONENTA;
typedef IE4COMPONENTA *LPIE4COMPONENTA;
typedef const IE4COMPONENTA *LPCIE4COMPONENTA;

// NOTE: This is NOT a COMPONENTA struct, it is a COMPONENTT struct.

// Note: This is the new NT5 COMPONENT structure. The old component structure is kept at the 
// begining of this struct and the new fields are added at the end. The dwSize field is used to 
// distinguish between the old and new structures.
//
typedef struct _tagCOMPONENTA
{
    DWORD   dwSize;
    DWORD   dwID; //Don't make this DWORD_PTR. The public version of this struct uses DWORD here.
    int     iComponentType;
    BOOL    fChecked;
    BOOL    fDirty;
    BOOL    fNoScroll;
    COMPPOS cpPos;
    TCHAR   szFriendlyName[MAX_PATH];
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSubscribedURL[INTERNET_MAX_URL_LENGTH];
    // Add the new fields below this point. Everything above must exactly match the 
    // old IE4COMPONENTA structure for compatibility.
    DWORD           dwCurItemState;
    COMPSTATEINFO   csiOriginal;
    COMPSTATEINFO   csiRestored;
} COMPONENTA;
typedef COMPONENTA *LPCOMPONENTA;
typedef const COMPONENTA *LPCCOMPONENTA;

typedef struct _tagTAGENTRYA
{
    LPCSTR pszTag;
    BOOL fSkipPast;
} TAGENTRYA;

typedef struct _tagTAGENTRYW
{
    LPCWSTR pwszTag;
    BOOL fSkipPast;
} TAGENTRYW;

#define c_wszNULL   (L"")

//The following are the possible values for _iCharset field of CReadFileObj
#define ANSI_HTML_CHARSET       1
#define UNICODE_HTML_CHARSET    2

//
//  The following class implements a uniform way to read chars from an ANSI or UNICODE file.
//

class   CReadFileObj 
{
    friend  class CActiveDesktop;
    
    private:
        HANDLE  _hFile;     //File handle
        int     _iCharset;  //ANSI_HTML_CHARSET or UNICODE_HTML_CHARSET

    public:
        //Constructor
        CReadFileObj(LPCTSTR lpszFileName);
        //Destructor
        ~CReadFileObj();
        //Reads the given number of ansi characters, if an ansi file.
        HRESULT FileReadCharsA(LPSTR lpszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead);
        //Reads the given number of UNICODE characters, if a UNICODE file.
        HRESULT FileReadCharsW(LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead);
        //Reads the given number of characters, and convert them if necessary to ANSI or UNICODE based on destCharset.
        HRESULT FileReadAndConvertChars(int iDestCharset, LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead, UINT *puiCharsConverted);
        //Seeks to a given character offset (not byte offset).
        HRESULT FileSeekChars(LONG lCharOffset, DWORD dwOrigin);
        //Gets the offset of the current file pointer from the begining of the file.
        HRESULT FileGetCurCharOffset(LONG  *plCharOffset);
};

interface IShellImageDataFactory;

class CActiveDesktop : public IActiveDesktop, IActiveDesktopP, IADesktopP2, IPropertyBag
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IActiveDesktop ***
    virtual STDMETHODIMP ApplyChanges(DWORD dwFlags);
    virtual STDMETHODIMP GetWallpaper(LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved);
    virtual STDMETHODIMP SetWallpaper(LPCWSTR pwszWallpaper, DWORD dwReserved);
    virtual STDMETHODIMP GetWallpaperOptions(LPWALLPAPEROPT pwpo, DWORD dwReserved);
    virtual STDMETHODIMP SetWallpaperOptions(LPCWALLPAPEROPT pwpo, DWORD dwReserved);
    virtual STDMETHODIMP GetPattern(LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved);
    virtual STDMETHODIMP SetPattern(LPCWSTR pszPattern, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemOptions(LPCOMPONENTSOPT pco, DWORD dwReserved);
    virtual STDMETHODIMP SetDesktopItemOptions(LPCCOMPONENTSOPT pco, DWORD dwReserved);
    virtual STDMETHODIMP AddDesktopItem(LPCCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP AddDesktopItemWithUI(HWND hwnd, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP ModifyDesktopItem(LPCCOMPONENT pcomp, DWORD dwFlags);
    virtual STDMETHODIMP RemoveDesktopItem(LPCCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemCount(LPINT lpiCount, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItem(int nComponent, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GetDesktopItemByID(ULONG_PTR dwID, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP GenerateDesktopItemHtml(LPCWSTR pwszFileName, LPCOMPONENT pcomp, DWORD dwReserved);
    virtual STDMETHODIMP AddUrl(HWND hwnd, LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwFlags);
    virtual STDMETHODIMP GetDesktopItemBySource(LPCWSTR pszSource, LPCOMPONENT pcomp, DWORD dwReserved);
    // *** IActiveDesktopP ***
    virtual STDMETHODIMP SetSafeMode(DWORD dwFlags);
    virtual STDMETHODIMP EnsureUpdateHTML(void);
    virtual STDMETHODIMP SetScheme(LPCWSTR pwszSchemeName, DWORD dwFlags);
    virtual STDMETHODIMP GetScheme(LPWSTR pwszSchemeName, LPDWORD lpdwcchBuffer, DWORD dwFlags);
    // *** IADesktopP2 ***
    virtual STDMETHODIMP ReReadWallpaper(void);
    virtual STDMETHODIMP GetADObjectFlags(LPDWORD lpdwFlags, DWORD dwMask);
    virtual STDMETHODIMP UpdateAllDesktopSubscriptions();
    virtual STDMETHODIMP MakeDynamicChanges(IOleObject *pOleObj);
    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);
   
    //Some Ansi versions of the methods for Internal Use
    BOOL AddComponentPrivate(COMPONENTA *pcomp, DWORD dwID);
    BOOL UpdateComponentPrivate(int iIndex, COMPONENTA *pcomp);
    BOOL RemoveComponentPrivate(int iIndex, COMPONENTA *pcomp);
    BOOL GetComponentPrivate(int nComponent, COMPONENTA *pcomp);

    CActiveDesktop();

protected:
    DWORD                       _cRef;
    DWORD                       _dwNextID;
    HDSA                        _hdsaComponent;
    TCHAR                       _szSelectedWallpaper[MAX_PATH];
    TCHAR                       _szSelectedWallpaperConverted[MAX_PATH];
    TCHAR                       _szBackupWallpaper[MAX_PATH];
    TCHAR                       _szSelectedPattern[MAX_PATH];
    LPTSTR                      _pszScheme;
    WALLPAPEROPT                _wpo;
    COMPONENTSOPT               _co;
    HANDLE                      _hFileHtml;             //File handle of desktop.htt
    CReadFileObj*               _pReadFileObjHtmlBkgd; //Object used to read the background html wallpaper
    int                         _iDestFileCharset;      //Whether the dest file desktop.htt is ANSI or UNICODE.

    // used for the temp wallpaper
    LPWSTR _pszWallpaperInUse;      // If using a temp file, keep the name in use so we don't stomp it while the user is previewing other files.
    FILETIME _ftLastWrite;          // The date that the original file was last written to.
    LPTSTR _pszOrigLastApplied;     // Same as _pszOriginalFile except it doesn't change until apply is pressed.

    //  put the BOOLs together
    BOOL            _fDirty;
    BOOL            _fWallpaperDirty;
    BOOL            _fWallpaperChangedDuringInit;
    BOOL            _fPatternDirty;
    BOOL            _fSingleItem;
    BOOL            _fInitialized;
    BOOL            _fNeedBodyEnd;
    BOOL            _fNoDeskMovr;
    BOOL            _fBackgroundHtml;
    IStream         *_pStream;          //To generate individual components.
    BOOL            _fUseDynamicHtml;   //Indicates if Dynamic Html can be used to make changes.
    BOOL            _fPolicyForWPName;  // A policy exists for the wallpaper to be used.
    BOOL            _fPolicyForWPStyle; // A policy exists for the wallpaper style to be used.
    BOOL            _fIgnoreAddRemovePolicies; //If this is set, ignore the policy to add remove items.

    ~CActiveDesktop();

    int  _FindComponentIndexByID(DWORD dwID);
    int  _FindComponentBySource(LPTSTR lpszSource, COMPONENTA *pComp);
    int  _FindComponentBySrcUrl(LPTSTR lpszSrcUrl, COMPONENTA *pComp);

    void _ReadComponent(HKEY hkey, LPCTSTR pszComp);
    void _SortAndRationalize(void);
    void _ReadComponents(BOOL fActiveDesktop);
    BOOL _ReadWallpaper(BOOL fActiveDesktop);
    void _ReadPattern(void);
    void _Initialize(void);

    void _SaveComponent(HKEY hkey, int iIndex, COMPONENTA *pcomp);
    void _SaveComponents(void);
    void _SaveWallpaper(void);
    void _SavePattern(DWORD dwFlags);
    void _SaveSettings(DWORD dwFlags);

    void _GenerateHtmlHeader(void);
    void _GenerateHtmlPicture(COMPONENTA *pcomp);
    void _GenerateHtmlDoc(COMPONENTA *pcomp);
    void _GenerateHtmlSite(COMPONENTA *pcomp);
    void _GenerateHtmlControl(COMPONENTA *pcomp);
    void _GenerateHtmlComponent(COMPONENTA *pcomp);
    void _GenerateHtmlFooter(void);
    void _GenerateHtml(void);

    void _WriteHtmlFromString(LPCTSTR psz);
    void _WriteHtmlFromId(UINT uid);
    void _WriteHtmlFromIdF(UINT uid, ...);
    void _WriteHtmlFromFile(LPCTSTR pszContents);
    void _WriteHtmlFromReadFileObj(CReadFileObj *pReadFileObj, int iOffsetStart, int iOffsetEnd);
    void _WriteResizeable(COMPONENTA *pcomp);
    void _WriteHtmlW(LPCWSTR pwstr, UINT cchToWrite, UINT *pcchWritten);

    int _ScanTagEntriesA(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYA *pte, int cte);
    int _ScanTagEntriesW(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYW *pte, int cte);
    int _ScanForTagA(CReadFileObj *pReadFileObj, int iOffsetStart, LPCSTR pwszTag);
    int _ScanForTagW(CReadFileObj *pReadFileObj, int iOffsetStart, LPCWSTR pwszTag);
    void _ParseAnsiInputHtmlFile(LPTSTR szSelectedWallpaper, int *piOffsetBase, int *piOffsetComp);
    HRESULT _CopyComponent(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, DWORD dwFlags);    
    HRESULT _ConvertFileToTempBitmap(IN LPWSTR pszFile, IN int cchSize);
    HRESULT _SaveTempWallpaperSettings(void);

private:
    HRESULT _AddDTIWithUIPrivateA(HWND hwnd, LPCCOMPONENT pComp, DWORD dwFlags);
    BOOL _IsDisplayInSafeMode(void);

    // The following are used for manipulating ActiveDesktop using Dynamic HTML.
    HRESULT _InsertNewDesktopItems(IHTMLDocument2   *pDoc);
    HRESULT _UpdateDesktopItemHtmlElements(IHTMLDocument2 *pDoc);
    HRESULT _UpdateHtmlElement(IHTMLElement *pElem);
    BOOL    _UpdateIdOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA);
    void    _UpdateStyleOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA);
    void    _GenerateHtmlBStrForComp(COMPONENTA *pComp, BSTR *pbstr);
};

extern IActiveDesktop *g_pActiveDesk;
int GetIntFromSubkey(HKEY hKey, LPCTSTR lpszValueName, int iDefault);
int GetIntFromReg(HKEY hKey, LPCTSTR lpszSubkey, LPCTSTR lpszNameValue, int iDefault);
BOOL GetStringFromReg(HKEY hkey, LPCTSTR lpszSubkey, LPCTSTR lpszValueName, LPTSTR lpszValue, DWORD cchSizeofValueBuff);
STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid);
HRESULT GetPerUserFileName(LPTSTR pszOutputFileName, DWORD dwSize, LPTSTR pszPartialFileName);
STDAPI CDeskHtmlProp_RegUnReg(BOOL bReg);

//Function to convert components in either direction.
void ConvertCompStruct(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, BOOL fPubToPriv);
void SetStateInfo(COMPSTATEINFO *pCompStateInfo, COMPPOS *pCompPos, DWORD dwItemState);

#define MultiCompToWideComp(MultiComp, WideComp)  ConvertCompStruct((COMPONENTA *)WideComp, MultiComp, FALSE)
#define WideCompToMultiComp(WideComp, MultiComp)  ConvertCompStruct(MultiComp, (COMPONENTA *)WideComp, TRUE)

#define COMPONENT_TOP_WINDOWLESS (COMPONENT_TOP / 2)
#define IsWindowLessComponent(pcomp) (((pcomp)->iComponentType == COMP_TYPE_PICTURE) || ((pcomp)->iComponentType == COMP_TYPE_HTMLDOC))

#define COMPONENT_DEFAULT_WIDTH   ((DWORD)-1)
#define COMPONENT_DEFAULT_HEIGHT  ((DWORD)-1)

#define DESKMOVR_FILENAME       TEXT("\\Web\\DeskMovr.htt")
#define DESKTOPHTML_FILENAME    TEXT("\\Microsoft\\Internet Explorer\\Desktop.htt")
#define PATTERN_FILENAME        TEXT("\\Microsoft\\Internet Explorer\\Pattern.bmp")

#define SAVE_PATTERN_NAME       0x00000001
#define GENERATE_PATTERN_FILE   0x00000002

//Property names 
#define c_wszPropName_TSPerfBGPolicy  L"TSConnectEvent"
#define c_wszPropName_IgnorePolicies  L"IgnorePolicies"

#define SZ_REGKEY_ACTDESKTOP_TSPERFPOLICY   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote")
#define SZ_REGVALUE_ACTDESKTOP_TSPERFPOLICY TEXT("ActiveDesktop")
#define SZ_REGVDATE_ACTDESKTOP_TSPERFPOLICY TEXT("Force Blank")


#define REGSTR_PATH_WP_POLICY   REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_SYSTEM

BOOL ReadPolicyForWallpaper(LPTSTR  lpszPolicyForWallpaper, DWORD dwSizeofBuff);
BOOL ReadPolicyForWPStyle(LPDWORD  lpdwStyle);

#endif // _DESKSTAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dsubscri.cpp ===
#include "stdafx.h"
#pragma hdrstop

// This function checks if a given URL already has a subscription.
// Returns TRUE: if it aleady has a subscription 
//         FALSE: Otherwise.
//
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL)
{
    HRESULT hr;
    ISubscriptionMgr *psm;
    BOOL    fRet = FALSE;  //Assume failure.

    //Create the subscription Manager.
    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(lpcszURL);
        if (bstrURL)
        {
            psm->IsSubscribed(bstrURL, &fRet);
            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

BOOL DeleteFromSubscriptionList(LPCTSTR pszURL)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    ISubscriptionMgr *psm;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(pszURL);     // Call TSTR version
        if (bstrURL)
        {
            //  Looks like all code paths going through this has already
            //  put up some UI.
            if (SUCCEEDED(psm->DeleteSubscription(bstrURL, NULL)))
            {
                fRet = TRUE;
            }

            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

BOOL UpdateSubscription(LPCTSTR pszURL)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    ISubscriptionMgr *psm;

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&psm);

    if (SUCCEEDED(hr))
    {
        BSTR bstrURL = SysAllocStringT(pszURL);     // Call TSTR version
        if (bstrURL)
        {
            if (SUCCEEDED(psm->UpdateSubscription(bstrURL)))
            {
                fRet = TRUE;
            }

            SysFreeString(bstrURL);
        }

        psm->Release();
    }

    return(fRet);
}

//
//
// This function enumerates the URLs of all the desktop components and then
// calls webcheck to see if they are subcribed to and if so asks webcheck to
// deliver those subscriptions right now.
//
//

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *padp2)
{
    IActiveDesktop  *pActiveDesktop;
    ISubscriptionMgr *psm;
    int     iCount; //Count of components.
    HRESULT     hres;
    BOOL        fRet = TRUE;  //Assume success!

    if(padp2 == NULL) //Are we provided a pointer already?
    {
        if(FAILED(hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesktop, IID_IActiveDesktop)))
        {
            TraceMsg(TF_WARNING, "Could not instantiate CActiveDesktop COM object");
            return FALSE;
        }
    }
    else
    {
        if(FAILED(hres = (padp2->QueryInterface(IID_PPV_ARG(IActiveDesktop, &pActiveDesktop)))))
        {
            TraceMsg(TF_WARNING, "Could not get IActiveDesktop * from IADesktopP2 *");
            return FALSE;
        }
    }

    pActiveDesktop->GetDesktopItemCount(&iCount, 0);

    if(iCount <= 0)
    {
        TraceMsg(DM_TRACE, "No desktop components to update!");
        return TRUE; //No components to enumerate!
    }

    //Create the subscription Manager.
    hres = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ISubscriptionMgr,
                            (void**)&psm);

    if(SUCCEEDED(hres))
    {
        int iIndex;
        BSTR bstrURL;

        //Enumerate the desktop components one by one.
        for(iIndex = 0; iIndex < iCount; iIndex++)
        {
            COMPONENT   Comp;   //We are using the public structure here.

            Comp.dwSize = sizeof(COMPONENT);
            if(SUCCEEDED(pActiveDesktop->GetDesktopItem(iIndex, &Comp, 0)) && 
                        Comp.fChecked)  //Is this component enabled?
            {
                BOOL    fSubscribed;

                fSubscribed = FALSE;  //Assume that it is NOT subscribed!

                bstrURL = SysAllocString(Comp.wszSubscribedURL);
                if(!bstrURL)
                {
                    fRet = FALSE;
                    break;  //Out of memory!
                }

                psm->IsSubscribed(bstrURL, &fSubscribed);

                if(fSubscribed)
                    psm->UpdateSubscription(bstrURL);

                SysFreeString(bstrURL);
            }
            else
                TraceMsg(TF_WARNING, "Component# %d either failed or not enabled!", iIndex);
        }
        psm->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "Could not create CLSID_SubscriptionMgr");
    }
        
    pActiveDesktop->Release();

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\deskstat.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "..\deskfldr.h"
#include "dutil.h"

extern "C" char * __cdecl StrTokEx(char ** pstring, const char * control);

#define DXA_GROWTH_CONST 10
#define ZINDEX_START 1000

#define MAXID_LENGTH    10  //Maximum number of digits in ID string plus 1.

#define TF_DESKSTAT     0
#define TF_DYNAMICHTML  0

IActiveDesktop *g_pActiveDesk = NULL;

#define c_szRegStrDesktop REGSTR_PATH_DESKTOP
#define c_szWallpaper  REG_VAL_GENERAL_WALLPAPER
#define c_szBackupWallpaper REG_VAL_GENERAL_BACKUPWALLPAPER
#define c_szPattern TEXT("Pattern")
#define c_szTileWall REG_VAL_GENERAL_TILEWALLPAPER
#define c_szWallpaperStyle REG_VAL_GENERAL_WALLPAPERSTYLE
#define c_szWallpaperTime REG_VAL_GENERAL_WALLPAPERTIME
#define c_szWallpaperLocalTime REG_VAL_GENERAL_WALLPAPERLOCALTIME
#define c_szRefreshDesktop TEXT("RefreshDesktop")
#define c_szBufferedRefresh TEXT("BufferedRefresh")

#define COMP_TYPE               0x00000003
#define COMP_SELECTED           0x00002000
#define COMP_NOSCROLL           0x00004000

#ifdef DEBUG

#define ENTERPROC EnterProcDS
#define EXITPROC ExitProcDS

void EnterProcDS(DWORD dwTraceLevel, LPSTR szFmt, ...);
void ExitProcDS(DWORD dwTraceLevel, LPSTR szFmt, ...);

extern DWORD g_dwDeskStatTrace;

#else
#ifndef CCOVER
#pragma warning(disable:4002)
#define ENTERPROC()
#define EXITPROC()
#else // ccover buildi
// these are needed because of a bug in cl.exe that results in improper processing
// of #pragma when run with cl -P, and then compiling
#define ENTERPROC 1 ? (void) 0 : (void)
#define EXITPROC 1 ? (void) 0 : (void)
#endif //end of ccover 
#endif

MAKE_CONST_BSTR(s_sstrBeforeEnd,       L"BeforeEnd");
MAKE_CONST_BSTR(s_sstrDeskMovr,        L"DeskMovr");
MAKE_CONST_BSTR(s_sstrDeskMovrW,       L"DeskMovrW");
MAKE_CONST_BSTR(s_sstrclassid,         L"classid");
MAKE_CONST_BSTR(s_sstrEmpty,           L"");


STDAPI ParseDesktopComponent(HWND hwndOwner, LPWSTR wszURL, COMPONENT *pInfo);

WCHAR   wUnicodeBOM =  0xfeff; // Little endian unicode Byte Order Mark.First byte:0xff, Second byte: 0xfe.

//extern BOOL  IsWallpaperDesktopV2(LPCTSTR  lpszWallpaper);

CReadFileObj::CReadFileObj(LPCTSTR lpszFileName)
{
    //Open the file 
    if ((_hFile = CreateFile(lpszFileName, GENERIC_READ, FILE_SHARE_READ, 
                             NULL, OPEN_EXISTING, 
                             FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)
    {
        WCHAR  wBOM;
        DWORD  dwBytesRead = 0;
        
        if ((ReadFile(_hFile, (LPVOID)&wBOM, sizeof(WCHAR), &dwBytesRead, NULL)) && 
           (dwBytesRead == sizeof(WCHAR)))
        {
            if (wBOM == wUnicodeBOM)
                _iCharset = UNICODE_HTML_CHARSET;
            else
            {
                //Note: Anything other than the little endian unicode file is treated as ansi.
                _iCharset = ANSI_HTML_CHARSET;
                SetFilePointer(_hFile, 0L, NULL, FILE_BEGIN);  //Seek to the begining of the file
            }
        }
    }
}

CReadFileObj::~CReadFileObj()
{
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = NULL;
    }
}

//
// This will read and if necessary convert between ANSI and UNICODE
//
HRESULT CReadFileObj::FileReadAndConvertChars(int iDestCharset, LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead, UINT *puiCharsConverted)
{
    HRESULT hres = S_OK;
    DWORD dwCharsRead = 0;
    DWORD dwTotalCharsConverted = 0;
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if (_iCharset == UNICODE_HTML_CHARSET)
        {
            if (iDestCharset == UNICODE_HTML_CHARSET)
            {
                hres = FileReadCharsW(lpwszBuff, uiCharsToRead, (UINT *)&dwCharsRead);
                dwTotalCharsConverted = dwCharsRead;
            }
            else
            {
                //Destination is ansi; Read the UNICODE source and convert to ANSI.
                WCHAR  wszBuf[INTERNET_MAX_URL_LENGTH + 1];  //Temp buffer to read the UNICODE chars into.
                LPSTR lpszBuff = (LPSTR)lpwszBuff;

                DWORD  dwTotalCharsToRead = (DWORD)uiCharsToRead;
    
                while(dwTotalCharsToRead)
                {
                    DWORD dwCount;
                    DWORD dwActuallyRead;
                    
                    // - 1 to give room for a null character at the end.
                    dwCount = (DWORD)min(dwTotalCharsToRead, (ARRAYSIZE(wszBuf) - 1));
                    if (ReadFile(_hFile, (LPSTR)wszBuf, dwCount*sizeof(WCHAR), &dwActuallyRead, NULL))
                    {
                        DWORD dwConverted;
                        dwActuallyRead = dwActuallyRead/sizeof(WCHAR);
                        
                        //Null terminate the source buffer.
                        wszBuf[dwActuallyRead] = L'\0';  //UNICODE null terminate the source.
                        //Convert what we just read.
                        dwConverted = SHUnicodeToAnsi(wszBuf, lpszBuff, dwActuallyRead+1); //+1 for null termination

                        //Update the count & stuff.
                        lpszBuff += dwConverted - 1;  //Subtract the null.
                        dwTotalCharsToRead -= dwActuallyRead;
                        dwCharsRead += dwActuallyRead;
                        dwTotalCharsConverted += dwConverted - 1; //Subtract the null.
                    
                        if (dwActuallyRead < dwCount)
                            break;  //We have reached the end of file.
                    }
                    else
                    {
                        hres = E_FAIL;
                        break;
                    }
                }
            }
        }
        else
        {
            //Source file is ANSI. Check the Destination.
            if (iDestCharset == ANSI_HTML_CHARSET)
            {
                //Destination is ANSI too! Cool! No need for conversion!
                hres = FileReadCharsA((LPSTR)lpwszBuff, uiCharsToRead, (UINT *)&dwCharsRead);
                dwTotalCharsConverted = dwCharsRead;
            }
            else
            {
                //Destination is UNICODE!  Read the ansi and convert it to UNICODE!
                char  szBuf[INTERNET_MAX_URL_LENGTH + 1];  //Temp buffer to read the ansi chars into.
                DWORD  dwTotalCharsToRead = (DWORD)uiCharsToRead;

                while(dwTotalCharsToRead)
                {
                    DWORD dwCount;
                    DWORD dwActuallyRead;

                    // - 1 to give room for a null character at the end.
                    dwCount = (DWORD)min(dwTotalCharsToRead, (ARRAYSIZE(szBuf) - 1));

                    if (ReadFile(_hFile, (LPSTR)szBuf, dwCount, &dwActuallyRead, NULL))
                    {
                        DWORD dwConverted;
                        //Null terminate the source buffer.
                        szBuf[dwActuallyRead] = '\0';  //ANSI null terminate the source.
                        //Convert what we just read.
                        dwConverted = SHAnsiToUnicode(szBuf, lpwszBuff, dwActuallyRead+1); //+1 for null termination

                        //Update the count & stuff.
                        lpwszBuff += dwConverted - 1;  //Subtract the null.
                        dwTotalCharsToRead -= dwActuallyRead;
                        dwCharsRead += dwActuallyRead;
                        dwTotalCharsConverted += dwConverted - 1; //Subtract the null.
                    
                        if (dwActuallyRead < dwCount)
                            break;  //We have reached the end of file.
                    }
                    else
                    {
                        hres = E_FAIL;
                        break;
                    }
                } //while
            }
        }
    }
    else
        hres = E_FAIL;  //The file handle is bad.

    *puiCharsActuallyRead = (UINT)dwCharsRead;
    *puiCharsConverted = (UINT)dwTotalCharsConverted;
    return hres; 
}


HRESULT CReadFileObj::FileReadCharsA(LPSTR lpszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead)
{
    HRESULT hres = E_FAIL;
    DWORD dwCharsRead = 0;
    
    if ((_hFile != INVALID_HANDLE_VALUE) && 
        (_iCharset == ANSI_HTML_CHARSET) &&
        ReadFile(_hFile, (LPVOID)lpszBuff, (DWORD)(uiCharsToRead), &dwCharsRead, NULL))
    {
        dwCharsRead = dwCharsRead; //get the number of wchars read.
        hres = S_OK;
    }
    *puiCharsActuallyRead = (UINT)dwCharsRead;
    return hres; 
}

//
// NOTE: The uiCharsToRead must be atleast one less than the size of the buffer (lpwszBuff)
// because one null may be written at the end of the buffer by SHAnsiToUnicode().
//
HRESULT CReadFileObj::FileReadCharsW(LPWSTR lpwszBuff, UINT uiCharsToRead, UINT *puiCharsActuallyRead)
{
    HRESULT hres = E_FAIL;
    DWORD dwCharsRead = 0;
    
    if ((_hFile != INVALID_HANDLE_VALUE) && 
        (_iCharset == UNICODE_HTML_CHARSET) &&
        ReadFile(_hFile, (LPVOID)lpwszBuff, (DWORD)(uiCharsToRead*sizeof(WCHAR)), &dwCharsRead, NULL))
    {
        dwCharsRead = dwCharsRead/sizeof(WCHAR); //get the number of wchars read.
        hres = S_OK;
    }
    *puiCharsActuallyRead = (UINT)dwCharsRead;
    return hres; 
}

HRESULT CReadFileObj::FileSeekChars(LONG  lCharOffset, DWORD dwOrigin)
{
    HRESULT hres = E_FAIL;

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(_hFile, 
                    lCharOffset*((_iCharset == UNICODE_HTML_CHARSET) ? sizeof(WCHAR) : sizeof(char)),
                    NULL,
                    dwOrigin) != INVALID_SET_FILE_POINTER)
            hres = S_OK;
    }

    return hres;
}

HRESULT CReadFileObj::FileGetCurCharOffset(LONG  *plCharOffset)
{
    HRESULT hres = E_FAIL;
    DWORD   dwByteOffset = 0;

    *plCharOffset = 0;
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        if ((dwByteOffset = SetFilePointer(_hFile, 
                                            0L,
                                            NULL,
                                            FILE_CURRENT)) != INVALID_SET_FILE_POINTER)
        {
            *plCharOffset = dwByteOffset/((_iCharset == UNICODE_HTML_CHARSET) ? sizeof(WCHAR) : sizeof(char));
            hres = S_OK;
        }
    }

    return hres;
}

BOOL GetStringFromReg(HKEY    hkey,
                      LPCTSTR lpszSubkey,
                      LPCTSTR lpszValueName,
                      LPTSTR  lpszValue,
                      DWORD   cchSizeofValueBuff)
{
    DWORD cb = cchSizeofValueBuff * sizeof(lpszValue[0]);
    return (ERROR_SUCCESS == SHGetValue(hkey, lpszSubkey, lpszValueName, NULL, lpszValue, &cb));
}

void GetWallpaperFileTime(LPCTSTR pszWallpaper, LPFILETIME lpftFileTime)
{
    HANDLE   hFile;
    BOOL fRet = FALSE;

    if ((hFile = CreateFile(pszWallpaper, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, 0)) != INVALID_HANDLE_VALUE)
    {
        fRet = GetFileTime(hFile, NULL, NULL, lpftFileTime);

        CloseHandle(hFile);
    }

    if (!fRet)
    {
        ZeroMemory(lpftFileTime, sizeof(FILETIME));
    }

    //  no return value
}

BOOL  HasWallpaperReallyChanged(LPCTSTR pszRegKey, LPTSTR pszOldWallpaper, LPTSTR pszBackupWallpaper, DWORD dwOldWallpaperStyle, DWORD dwNewWallpaperStyle)
{
    //  we default to TRUE here.
    
    if ((dwOldWallpaperStyle == dwNewWallpaperStyle)
    && (0 == lstrcmpi(pszOldWallpaper, pszBackupWallpaper)))
    {
        // The wallpaper filename and style hasn't changed. 
        //  But, the content of this file could have changed. 
        //  See if the content has changed by looking at the 
        // last-written date and time stamp on this file.
        FILETIME ftOld, ftBack;
        DWORD cbBack = sizeof(ftBack);

        //  if either of these fail, then they will
        //  remain Zero  so the compare will
        //  be successful.
        GetWallpaperFileTime(pszOldWallpaper, &ftOld);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperTime, NULL, &ftBack, &cbBack))
        {
            ZeroMemory(&ftBack, sizeof(ftBack));
        }

        //Get the last written time of the backup wallpaper from registry
        if (0 == CompareFileTime(&ftOld, &ftBack))
            return FALSE;   //  everything is the same!

        // Win2K QFE bug 10689 (AndrewGr)
        // same check, but instead of checking UTC time, check local time converted to UTC time
        // this is because FAT disks store local time, not UTC time
        FILETIME ftLocalBack, ftLocalBackUtc;

            cbBack = sizeof(ftLocalBack);

        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperLocalTime, NULL, &ftLocalBack, &cbBack))
        {
            ZeroMemory(&ftLocalBack, sizeof(ftLocalBack));
        }

        LocalFileTimeToFileTime(&ftLocalBack, &ftLocalBackUtc);
            
        if (ftOld.dwLowDateTime == ftLocalBackUtc.dwLowDateTime
        && (ftOld.dwHighDateTime == ftLocalBackUtc.dwHighDateTime))
            // everything is the same!
            return FALSE;


    }
    
    return TRUE;
}

//-------------------------------------------------------------------------------------------------------------//
//  Function: ReadWallpaperStyleFromReg()
//
// This function reads the "TileWallpaper" and the "WallpaperStyle" from the given location
// in the registry.
//
//-------------------------------------------------------------------------------------------------------------//

int GetIntFromReg(HKEY    hKey,
                  LPCTSTR lpszSubkey,
                  LPCTSTR lpszNameValue,
                  int     iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = sizeof(szValue);
    int iRetValue = iDefault;
    DWORD dwType;

    if ((SHGetValue(hKey, lpszSubkey, lpszNameValue, &dwType, szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToInt(szValue);
        }
    }

    return iRetValue;
}

void ReadWallpaperStyleFromReg(LPCTSTR pszRegKey, DWORD *pdwWallpaperStyle, BOOL fIgnorePlatforms)
{
    if (GetIntFromReg(HKEY_CURRENT_USER, pszRegKey, c_szTileWall, WPSTYLE_TILE))
    {
        // "Tile" overrides the "Stretch" style.
        *pdwWallpaperStyle = WPSTYLE_TILE;
    }
    else
    {
        // else, STRETCH or CENTER.
        *pdwWallpaperStyle = GetIntFromReg(HKEY_CURRENT_USER, pszRegKey, c_szWallpaperStyle, WPSTYLE_CENTER);
    }
}

BOOL CActiveDesktop::_IsDisplayInSafeMode(void)
{
    WCHAR wszDisplay[MAX_PATH];
    DWORD dwcch = MAX_PATH;

    return (SUCCEEDED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)) 
            && (0 == StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L)));
}


BOOL ReadPolicyForWallpaper(LPTSTR  pszPolicy, DWORD cchPolicy)
{
    BOOL fPolicySet = FALSE;
    DWORD cb = cchPolicy * sizeof(pszPolicy[0]);
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_WP_POLICY, c_szWallpaper, NULL, pszPolicy, &cb) == ERROR_SUCCESS) && cb)
    {
        //  even if this value was originally REG_SZ it may still
        //  have environment vars in it for legacy reasons!
        if (SUCCEEDED(PathExpandEnvStringsWrap(pszPolicy, cchPolicy)))
        {
            fPolicySet = TRUE;  //Policy is there!
        }
        else
        {
            pszPolicy[0] = 0; // if we couldn't expand correctly, null it out to be safe
        }
    }
    else
    {
        // See if the TS Perf policy is set to turn it off for perf.
        fPolicySet = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)); //No policy is set!
    }

    return fPolicySet;
}

HRESULT GetWallpaperPath(HKEY hKey, LPCTSTR pszKey, LPCTSTR pszValue, LPCTSTR pszFallback, LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr;

    if (GetStringFromReg(hKey, pszKey, pszValue, pszPath, cchSize))
    {
        hr = PathExpandEnvStringsWrap(pszPath, cchSize);
    }
    else if (pszFallback)
    {
        hr = StringCchCopy(pszPath, cchSize, pszFallback);
    }
    else
    {
        pszPath[0] = 0;
        hr = S_FALSE; // couldn't get it from registry, we null the output buffer, but this is not catastrophic
    }

    return hr;
}

BOOL ReadPolicyForWPStyle(LPDWORD  lpdwStyle)
{
    DWORD   dwStyle;
    DWORD   dwType;
    TCHAR   szValue[20];
    DWORD   dwSizeofValueBuff = sizeof(szValue);
    BOOL    fRet = FALSE;

    // The caller can passin a NULL, if they are not interested in the actual value and they just
    // want to know if this policy is set or not.
    if (!lpdwStyle)  
        lpdwStyle = &dwStyle;

    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_WP_POLICY, c_szWallpaperStyle, &dwType, szValue,
                   &dwSizeofValueBuff) == ERROR_SUCCESS) && dwSizeofValueBuff)
    {
        if (dwType == REG_SZ)
        {
            *lpdwStyle = (DWORD)StrToInt(szValue);
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CActiveDesktop::_ReadWallpaper(BOOL fActiveDesktop)
{
    ENTERPROC(2, "DS ReadWallpaper()");

    TCHAR szDeskcomp[MAX_PATH];
    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);

    _fPolicyForWPName = ReadPolicyForWallpaper(_szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper));
    _fPolicyForWPStyle = ReadPolicyForWPStyle(&_wpo.dwStyle);
    
    //
    // Read in the wallpaper and style from the appropriate registry location.
    //
    LPCTSTR pszRegKey;
    if (fActiveDesktop)
    {
        pszRegKey = szDeskcomp;
        TCHAR   szOldWallpaper[MAX_PATH];
        DWORD   dwOldWallpaperStyle;

        // Read the Wallpaper from the Old location.
        if (S_OK != GetWallpaperPath(HKEY_CURRENT_USER, c_szRegStrDesktop, c_szWallpaper, NULL, szOldWallpaper, ARRAYSIZE(szOldWallpaper)))
        {
            return FALSE;
        }

        // Read wallpaper style from the old location.
        ReadWallpaperStyleFromReg((LPCTSTR)c_szRegStrDesktop, &dwOldWallpaperStyle, FALSE);

        // Read the wallpaper from the new location too!
        if ((!_fPolicyForWPName) || (_IsDisplayInSafeMode()))
        {
            HRESULT hrPath = GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szWallpaper, szOldWallpaper, _szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper));
            if (S_FALSE == hrPath)
            {
                pszRegKey = c_szRegStrDesktop;
            }
            else if (FAILED(hrPath))
            {
                return FALSE;
            }
        }

        //Read wallpaper style from the new location too!
        if (!_fPolicyForWPStyle)
        {
            ReadWallpaperStyleFromReg(pszRegKey, &_wpo.dwStyle, FALSE);
        }
        
        //If there is a Safe mode scheme here do NOT attempt to change wallpaper
        if ((!_IsDisplayInSafeMode()) && (!_fPolicyForWPName))
        {
            //Read what is stored as "Backup" wallpaper.
            if (S_OK != GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szBackupWallpaper, szOldWallpaper, _szBackupWallpaper, ARRAYSIZE(_szBackupWallpaper)))
            {
                return FALSE;
            }
            else
            {
                //See if the Old wallpaper is differnet from the backed up wallpaper
                if (HasWallpaperReallyChanged(pszRegKey, szOldWallpaper, _szBackupWallpaper, dwOldWallpaperStyle, _wpo.dwStyle))
                {
                    //They are different. This means that some other app has changed the "Old" wallpaper
                    //after the last time we backed it up in the registry.
                    // Make this wallpaper as the Selected wallpaper!

                    if (FAILED(StringCchCopy(_szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper), szOldWallpaper)))
                    {
                        return FALSE;
                    }
                    else
                    {
                        _wpo.dwStyle = dwOldWallpaperStyle;

                        _fWallpaperDirty = TRUE;
                        _fWallpaperChangedDuringInit = TRUE;
                    }
                }
            }

        }
        
        //Make a backup of the "Old" wallpaper from szOldWallpaper
        if (FAILED(StringCchCopy(_szBackupWallpaper, ARRAYSIZE(_szBackupWallpaper), szOldWallpaper)))
        {
            _szBackupWallpaper[0] = 0; // on failure null it out, this value is just an optimization

        }
    }
    else
    {
        pszRegKey = c_szRegStrDesktop; //Get it from the old location!

        //Since active desktop is not available, read wallpaper from old location.
        if (!_fPolicyForWPName)
        {
            if (S_OK != GetWallpaperPath(HKEY_CURRENT_USER, pszRegKey, c_szWallpaper, NULL, _szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper)))
            {
                return FALSE;
            }
        }

        //Read the wallpaper style
        if (!_fPolicyForWPStyle)
            ReadWallpaperStyleFromReg(pszRegKey, &_wpo.dwStyle, TRUE);

        //Make a backup of the "Old" wallpaper from _szSelectedWallpaper
        if (FAILED(StringCchCopy(_szBackupWallpaper, ARRAYSIZE(_szBackupWallpaper), _szSelectedWallpaper)))
        {
            _szBackupWallpaper[0] = 0; // on failure null it out, this value is just an optimization

        }
    }

    EXITPROC(2, "DS ReadWallpaper! (_szSelectedWP=>%s<)", _szSelectedWallpaper);

    return TRUE;
}

void CActiveDesktop::_ReadPattern(void)
{
    ENTERPROC(2, "DS ReadPattern()");

    GetStringFromReg(HKEY_CURRENT_USER, c_szRegStrDesktop, c_szPattern, _szSelectedPattern, ARRAYSIZE(_szSelectedPattern));

    EXITPROC(2, "DS ReadPattern! (_szSelectedPattern=>%s<)", _szSelectedPattern);
}

void CActiveDesktop::_ReadComponent(HKEY hkey, LPCTSTR pszComp)
{
    ENTERPROC(2, "DS ReadComponent(hk=%08X,pszComp=>%s<)", hkey, pszComp);

    HKEY hkeyComp;

    if (RegOpenKeyEx(hkey, pszComp, 0, KEY_READ, &hkeyComp) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        COMPONENTA comp;
        comp.dwSize = sizeof(COMPONENTA);

        //
        // Read in the source string.
        //
        cbSize = sizeof(comp.szSource);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_SOURCE, NULL, NULL, (LPBYTE)&comp.szSource, &cbSize) != ERROR_SUCCESS)
        {
            comp.szSource[0] = TEXT('\0');
        }

        //
        // Read in the SubscribedURL string.
        //
        cbSize = sizeof(comp.szSubscribedURL);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_SUBSCRIBED_URL, NULL, NULL, (LPBYTE)&comp.szSubscribedURL, &cbSize) != ERROR_SUCCESS)
        {
            comp.szSubscribedURL[0] = TEXT('\0');
        }

        //
        // Read in the Friendly name string.
        //
        cbSize = sizeof(comp.szFriendlyName);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_NAME, NULL, NULL, (LPBYTE)&comp.szFriendlyName, &cbSize) != ERROR_SUCCESS)
        {
            comp.szFriendlyName[0] = TEXT('\0');
        }

        //
        // Read in and parse the flags.
        //
        DWORD dwFlags;
        cbSize = sizeof(dwFlags);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_FLAGS, NULL, NULL, (LPBYTE)&dwFlags, &cbSize) != ERROR_SUCCESS)
        {
            dwFlags = 0;
        }
        comp.iComponentType = dwFlags & COMP_TYPE;
        comp.fChecked = (dwFlags & COMP_SELECTED) != 0;
        comp.fNoScroll = (dwFlags & COMP_NOSCROLL) != 0;
        comp.fDirty = FALSE;    //Reading it fresh from registry; Can't be dirty!

        //
        // Read in the location.
        //
        cbSize = sizeof(comp.cpPos);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_POSITION, NULL, NULL, (LPBYTE)&comp.cpPos, &cbSize) != ERROR_SUCCESS)
        {
            ZeroMemory(&comp.cpPos, sizeof(comp.cpPos));
        }

        //
        // In IE4.x, we have a very huge positive number (0x7fffffff) as the COMPONENT_TOP;
        // As a result some component's z-index overflowed into the negative range (0x80000003)
        // To fix this, we halved the COMPONENT_TOP (0x3fffffff) and also check for negative z-index
        // values and covert them to postive values.
        if (comp.cpPos.izIndex < 0)
            comp.cpPos.izIndex = COMPONENT_TOP;

        //
        // Make sure the cpPos.dwSize is set to correct value
        //
        comp.cpPos.dwSize = sizeof(COMPPOS);

        //
        //  Read in the current ItemState
        //
        cbSize = sizeof(comp.dwCurItemState);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_CURSTATE, NULL, NULL, (LPBYTE)&comp.dwCurItemState, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, we must be reading from IE4 machine.
            comp.dwCurItemState = IS_NORMAL;
        }

        //
        //  Read in the Original state info.
        //
        cbSize = sizeof(comp.csiOriginal);
        if ((SHQueryValueEx(hkeyComp, REG_VAL_COMP_ORIGINALSTATEINFO, NULL, NULL, (LPBYTE)&comp.csiOriginal, &cbSize) != ERROR_SUCCESS) ||
            (comp.csiOriginal.dwSize != sizeof(comp.csiOriginal)))
        {
            //If the item state is missing, we must be reading from IE4 machine.
            // Set the OriginalState to the default info.
            SetStateInfo(&comp.csiOriginal, &comp.cpPos, IS_NORMAL);
            comp.csiOriginal.dwHeight = comp.csiOriginal.dwWidth = COMPONENT_DEFAULT_WIDTH;
        }

        //
        //  Read in the Restored state info.
        //
        cbSize = sizeof(comp.csiRestored);
        if (SHQueryValueEx(hkeyComp, REG_VAL_COMP_RESTOREDSTATEINFO, NULL, NULL, (LPBYTE)&comp.csiRestored, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, we must be reading from IE4 machine.
            // Set the restored State to the default info.
            SetStateInfo(&comp.csiRestored, &comp.cpPos, IS_NORMAL);
        }

        //
        // Add the component to the component list.
        //
        AddComponentPrivate(&comp, StrToInt(pszComp));

        //
        // Increment our counter so we know where to add any new
        // components after we're done.
        //
        _dwNextID++;

        RegCloseKey(hkeyComp);
    }

    EXITPROC(2, "DS ReadComponent!");
}

typedef struct _tagSortStruct {
    int ihdsaIndex;
    int izIndex;
} SORTSTRUCT;

int CALLBACK pfnComponentSort(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    SORTSTRUCT * pss1 = (SORTSTRUCT *)p1;
    SORTSTRUCT * pss2 = (SORTSTRUCT *)p2;

    if (pss1->izIndex > pss2->izIndex)
        return 1;

    if (pss1->izIndex < pss2->izIndex)
        return -1;

    return(0);
}

//
// ModifyZIndex
//
// Little helper function to put the zindex of the windowed and windowless components
// into correct buckets so that zorting will produce a correct order by zindex.
//
// If we don't do this then windowless components may end up zordering above windowed ones.
//
void ModifyZIndex(COMPONENTA * pcomp)
{
    if (pcomp->cpPos.izIndex != COMPONENT_TOP) {
        if (!IsWindowLessComponent(pcomp))
            pcomp->cpPos.izIndex += COMPONENT_TOP_WINDOWLESS;
    }
    else
    {
        if (IsWindowLessComponent(pcomp))
            pcomp->cpPos.izIndex = COMPONENT_TOP_WINDOWLESS;
    }
}

//
// SortAndRationalize
//
// SortAndRationalize will take an unsorted component list and sort it such that the components
// come out in the correct z-index indicated order.  It will also rebase the z-index values at
// a known constant so that the z-index values will not grow endlessly.  SortAndRationalize also
// imposes windowed vs. windowless criteria to the zindex values such that windowless components
// always zorder under windowed ones.
//
void CActiveDesktop::_SortAndRationalize(void)
{
    int icComponents;
    HDPA hdpa;

    if (_hdsaComponent && ((icComponents = DSA_GetItemCount(_hdsaComponent)) > 1) && (hdpa = DPA_Create(0))) {
        COMPONENTA * pcomp;
        SORTSTRUCT * pss;
        int i, iCur = ZINDEX_START;
        BOOL fInsertFailed = FALSE;
        HDSA hdsaOld;

        // Go through each component and insert it's hdsa-index and zindex into the hdpa
        for (i = 0; i < icComponents; i++)
        {
            if (!(pss = (SORTSTRUCT *)LocalAlloc(LPTR, sizeof(SORTSTRUCT))))
                break;

            pcomp = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i);
            ModifyZIndex(pcomp);
            pss->ihdsaIndex = i;
            pss->izIndex = pcomp->cpPos.izIndex;
            if (DPA_AppendPtr(hdpa, (void FAR *)pss) == -1) {
                LocalFree((HANDLE)pss);
                break;
            }
        }

        // Sort the hdpa by zindex
        DPA_Sort(hdpa, pfnComponentSort, 0);

        // Save old values
        hdsaOld = _hdsaComponent;

        // Null out the old hdsa, so AddComponentPrivate will create a new one
        _hdsaComponent = NULL;

        // Now go through the sorted hdpa and update the component zindex with a ZINDEX_START based zindex, then
        // add the component to the new hdsa in sorted order.
        for (i = 0; i < icComponents; i++) {
            if (!(pss = (SORTSTRUCT *)DPA_GetPtr(hdpa, i)))
                break;
            // Get component and update it's zIndex and id
            pcomp = (COMPONENTA *)DSA_GetItemPtr(hdsaOld, pss->ihdsaIndex);
            pcomp->cpPos.izIndex = iCur;
            iCur += 2;

            // Free ptr
            LocalFree((HANDLE)pss);

            // Add to new hdsa in sorted order
            if (!fInsertFailed) {
                fInsertFailed = !AddComponentPrivate(pcomp, pcomp->dwID);
            }
        }

        // If we're completely successfull then destroy the old hdsa.  Otherwise we need
        // to destroy the new one and restore the old one.
        if ((i == icComponents) && !fInsertFailed) {
            DSA_Destroy(hdsaOld);
        } else {
            if (_hdsaComponent)
            DSA_Destroy(_hdsaComponent);
            _hdsaComponent = hdsaOld;
        }

        DPA_Destroy(hdpa);
    }
}

void CActiveDesktop::_ReadComponents(BOOL fActiveDesktop)
{
    ENTERPROC(2, "DS ReadComponents()");

    HKEY hkey;
    TCHAR szDeskcomp[MAX_PATH];

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, _pszScheme);
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbSize;
        int i = 0;
        TCHAR lpszSubkey[MAX_PATH];

        //
        // Read in the general settings.
        //
        DWORD dwSettings;
        cbSize = sizeof(dwSettings);
        if (SHQueryValueEx(hkey, REG_VAL_COMP_SETTINGS, NULL, NULL, (LPBYTE)&dwSettings, &cbSize) == ERROR_SUCCESS)
        {
            _co.fEnableComponents = (dwSettings & COMPSETTING_ENABLE) != 0;
        }
        _co.fActiveDesktop = fActiveDesktop;

        //
        // Read in all the desktop components
        //
        while (RegEnumKey(hkey, i, lpszSubkey, ARRAYSIZE(lpszSubkey)) == ERROR_SUCCESS)
        {
            _ReadComponent(hkey, lpszSubkey);
            i++;
        }

        _SortAndRationalize();

        RegCloseKey(hkey);
    }

    EXITPROC(2, "DS ReadComponents!");
}

void CActiveDesktop::_Initialize(void)
{
    ENTERPROC(2, "DS Initialize()");

    if (!_fInitialized)
    {
        _fInitialized = TRUE;
        InitDeskHtmlGlobals();

        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        
        BOOL fActiveDesktop = BOOLIFY(ss.fDesktopHTML);
        
        _co.dwSize = sizeof(_co);
        _wpo.dwSize = sizeof(_wpo);

        //
        // This per-user registry branch may not exist for this user. Or, even if
        // it does exist, it may have some stale info. So ensure that atlreast the 
        // default components are there and that the html version is current for this
        // branch of the registry!
        //  If everything is current, the following function does nothing!
        //
        CDeskHtmlProp_RegUnReg(TRUE);  //TRUE => install.

        _ReadWallpaper(fActiveDesktop);
        _ReadPattern();
        _ReadComponents(fActiveDesktop);

        // If we are in safemode, the we can not use Dynamic Html to make updates because
        // updates involve complete change of background Html.
        if (_IsDisplayInSafeMode())
            _fUseDynamicHtml = FALSE;
        else
            _fUseDynamicHtml = TRUE;        //Any component added after the initialization must go through dynamic html.

        _fDirty = FALSE;
        _fNeedBodyEnd = FALSE;
    }

    EXITPROC(2, "DS Initialize!");
}


void CActiveDesktop::_SaveWallpaper(void)
{
    ENTERPROC(2, "DS SaveWallpaper");
    TCHAR szDeskcomp[MAX_PATH];
    BOOL    fNormalWallpaper;

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);

    //
    // Compute tiling string.
    //
    TCHAR szTiled[2];
    szTiled[0] = TEXT('0') + (TCHAR)(_wpo.dwStyle & WPSTYLE_TILE);
    szTiled[1] = NULL;

    //
    // Compute the Wallpaper styling string
    //
    TCHAR       szWPStyle[2];
    //
    // NOTE: If WPSTYLE_TILE is set, we still want to say WallpaperStyle="0"; This won't hurt
    // because TileWallpaper="1" will over-ride this anyway.
    // The reason for this hack is that during memphis setup, they put a tiled wallpaper. Then we
    // write WallpaperStyle=1 and TileWallpaper=1 in new and old locations. Then, then change
    // the wallpaper and set TileWallpaper=0. Since the WallpaperStyle continues to be 1, they 
    // get a tiled wallpaper finally. The following is to avoid this problem!
    // 
    szWPStyle[0] = TEXT('0') + (TCHAR)(_wpo.dwStyle & WPSTYLE_STRETCH);
    szWPStyle[1] = NULL;
    

    //
    // Write out wallpaper settings in new active desktop area.
    //
    if (_fWallpaperDirty || _fWallpaperChangedDuringInit)
    {
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
                c_szTileWall, REG_SZ, szTiled, CbFromCch(lstrlen(szTiled)+1));
        }

        //
        // Note: We do not write the Wallpaper Style string for older systems because we do not
        // want to over-write what PlusPack writes. However, for newer Operating systems, we 
        // want to write the WallpaperStyle also.
        //
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
                c_szWallpaperStyle, REG_SZ, szWPStyle, CbFromCch(lstrlen(szWPStyle)+1));
        }

        if (!_fPolicyForWPName)
        {
            SHRegSetPath(HKEY_CURRENT_USER, szDeskcomp, c_szWallpaper, _szSelectedWallpaper, 0);
        }
    }

    if (fNormalWallpaper = IsNormalWallpaper(_szSelectedWallpaper))
    {
        if (FAILED(StringCchCopy(_szBackupWallpaper, ARRAYSIZE(_szBackupWallpaper), _szSelectedWallpaper)))
        {
            _szBackupWallpaper[0] = 0;
        }
    }

    if (!_fPolicyForWPName)
    {
        FILETIME ft, ftLocal;
        GetWallpaperFileTime(_szBackupWallpaper, &ft);
        FileTimeToLocalFileTime(&ft, &ftLocal);  // for FAT systems to track across DST changes

        // Backup the "Old type" wallpaper's name here in the new location
        // sothat we can detect when this gets changed by some other app.
        SHRegSetPath(HKEY_CURRENT_USER, szDeskcomp, c_szBackupWallpaper, _szBackupWallpaper, 0);

        SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
                c_szWallpaperTime, REG_BINARY, &ft,
                sizeof(ft));    

        SHSetValue(HKEY_CURRENT_USER, szDeskcomp,
                c_szWallpaperLocalTime, REG_BINARY, &ftLocal,
                sizeof(ftLocal));      // AndrewGr save local time not UTC time   
    }
    
    //
    // Even if this wallpaper is not valid in normal desktop (i.e., even if it is not a .BMP),
    // write it out in normal desktop registry area.
    //
    if (_fWallpaperDirty)
    {
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, c_szRegStrDesktop,
                    c_szTileWall, REG_SZ, szTiled, CbFromCch(lstrlen(szTiled)+1));
        }
        //
        // Note: We do not write the Wallpaper Style string for older systems because we do not
        // want to over-write what PlusPack writes. However, for newer Operating systems, we 
        // want to write the WallpaperStyle also.
        //
        if (!_fPolicyForWPStyle)
        {
            SHSetValue(HKEY_CURRENT_USER, c_szRegStrDesktop,
                        c_szWallpaperStyle, REG_SZ, szWPStyle, CbFromCch(lstrlen(szWPStyle)+1));
        }

        if (!_fPolicyForWPName)
        {
            SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, 
                    (fNormalWallpaper ? _szSelectedWallpaper : _szBackupWallpaper),
                    SPIF_UPDATEINIFILE);
        }
    }

    EXITPROC(2, "DS SaveWallpaper");
}

void CActiveDesktop::_SaveComponent(HKEY hkey, int iIndex, COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS SaveComponent(hkey=%08X,iIndex=%d,pcomp=%08X)", hkey, iIndex, pcomp);

    TCHAR szSubKey[8];
    HKEY hkeySub;

    if (SUCCEEDED(StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), iIndex)))
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(hkey, szSubKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeySub, 0))
        {
            pcomp->fDirty = FALSE; //Since we are saving in the registry, reset this!
            //
            // Write out the source string and Friendly name string.
            //
            RegSetValueEx(hkeySub, REG_VAL_COMP_SOURCE, 0, REG_SZ, (LPBYTE)pcomp->szSource, (lstrlen(pcomp->szSource)+1)*sizeof(TCHAR));
            RegSetValueEx(hkeySub, REG_VAL_COMP_SUBSCRIBED_URL, 0, REG_SZ, (LPBYTE)pcomp->szSubscribedURL, (lstrlen(pcomp->szSubscribedURL)+1)*sizeof(TCHAR));
            RegSetValueEx(hkeySub, REG_VAL_COMP_NAME, 0, REG_SZ, (LPBYTE)pcomp->szFriendlyName, (lstrlen(pcomp->szFriendlyName)+1)*sizeof(TCHAR));

            //
            // Compute and write out flags.
            //
            DWORD dwFlags = 0;
            dwFlags |= pcomp->iComponentType;
            if (pcomp->fChecked)
            {
                dwFlags |= COMP_SELECTED;
            }
            if (pcomp->fNoScroll)
            {
                dwFlags |= COMP_NOSCROLL;
            }
            RegSetValueEx(hkeySub, REG_VAL_COMP_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));

            //
            // Write out the position.
            //
            RegSetValueEx(hkeySub, REG_VAL_COMP_POSITION, 0, REG_BINARY, (LPBYTE)&pcomp->cpPos, sizeof(pcomp->cpPos));

            //  Write out the Current state
            RegSetValueEx(hkeySub, REG_VAL_COMP_CURSTATE, 0, REG_DWORD, (LPBYTE)&pcomp->dwCurItemState, sizeof(pcomp->dwCurItemState));

            //  Write out the Original State Info
            RegSetValueEx(hkeySub, REG_VAL_COMP_ORIGINALSTATEINFO, 0, REG_BINARY, (LPBYTE)&pcomp->csiOriginal, sizeof(pcomp->csiOriginal));
        
            //  Write out the Restored State Info
            RegSetValueEx(hkeySub, REG_VAL_COMP_RESTOREDSTATEINFO, 0, REG_BINARY, (LPBYTE)&pcomp->csiRestored, sizeof(pcomp->csiRestored));

            RegCloseKey(hkeySub);
        }
    }
    EXITPROC(2, "DS SaveComponent!");
}


void CActiveDesktop::_SaveComponents(void)
{
    ENTERPROC(2, "DS SaveComponents");
    DWORD dwFlags = 0, dwDataLength = sizeof(dwFlags);
    int i;
    TCHAR szDeskcomp[MAX_PATH];

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, _pszScheme);

    //
    // We need to preserve the old GENFLAGS, so read them now before we roach them.
    //
    SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_GENFLAGS, NULL,
                            &dwFlags, &dwDataLength);

    //
    // Delete the entire registry key.
    //
    SHDeleteKey(HKEY_CURRENT_USER, szDeskcomp);

    //
    // Recreate the registry key.
    //
    HKEY hkey;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkey, 0))
    {
        //
        // Write out the version number.
        //
        DWORD dw = CUR_DESKHTML_VERSION;
        RegSetValueEx(hkey, REG_VAL_COMP_VERSION, 0, REG_DWORD, (LPBYTE)(&dw), sizeof(dw));

        dw = CUR_DESKHTML_MINOR_VERSION;
        RegSetValueEx(hkey, REG_VAL_COMP_MINOR_VERSION, 0, REG_DWORD, (LPBYTE)(&dw), sizeof(dw));

        //
        // Write out the general settings.
        //
        DWORD dwSettings = 0;
        if (_co.fEnableComponents)
        {
            dwSettings |= COMPSETTING_ENABLE;
        }
        RegSetValueEx(hkey, REG_VAL_COMP_SETTINGS, 0, REG_DWORD, (LPBYTE)&dwSettings, sizeof(dwSettings));

        //
        // Write out the general flags
        //
        RegSetValueEx(hkey, REG_VAL_COMP_GENFLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));

        if (_hdsaComponent)
        {
            //
            // Write out the settings for each component
            //
            for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
            {
                COMPONENTA * pcomp;

                if (pcomp = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i))
                {
                    pcomp->dwID = i;
                    _SaveComponent(hkey, i, pcomp);
                }
            }
        }

        RegCloseKey(hkey);
    }   

    EXITPROC(2, "DS SaveComponents");
}

void CActiveDesktop::_SavePattern(DWORD dwFlags)
{
    ENTERPROC(2, "DS SavePattern()");

    if (_fPatternDirty && (dwFlags & SAVE_PATTERN_NAME))
    {
        //
        // Write out the pattern to the registry and INI files.
        //
        SystemParametersInfo(SPI_SETDESKPATTERN, 0, _szSelectedPattern, SPIF_UPDATEINIFILE);
    }

    if (IsValidPattern(_szSelectedPattern) && (dwFlags & GENERATE_PATTERN_FILE))
    {
        //
        // Write out the pattern as a BMP file for use in HTML.
        //
        TCHAR szBitmapFile[MAX_PATH];
        HANDLE hFileBitmap = INVALID_HANDLE_VALUE;

        if (SUCCEEDED(GetPerUserFileName(szBitmapFile, ARRAYSIZE(szBitmapFile), PATTERN_FILENAME)))
        {
            hFileBitmap = CreateFile(szBitmapFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        }

        if (hFileBitmap != INVALID_HANDLE_VALUE)
        {
            DWORD cbWritten;

            BITMAPFILEHEADER bmfh = {0};
            bmfh.bfType = 0x4D42;   // 'BM'
            bmfh.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 2*sizeof(RGBQUAD) + 8*sizeof(DWORD);
            bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + 2*sizeof(RGBQUAD);
            WriteFile(hFileBitmap, &bmfh, sizeof(bmfh), &cbWritten, NULL);

            BITMAPINFOHEADER bmih = {0};
            bmih.biSize = sizeof(BITMAPINFOHEADER);
            bmih.biWidth = 8;
            bmih.biHeight = 8;
            bmih.biPlanes = 1;
            bmih.biBitCount = 1;
            bmih.biCompression = BI_RGB;
            WriteFile(hFileBitmap, &bmih, sizeof(bmih), &cbWritten, NULL);

            RGBQUAD argbTable[2] = {0};
            DWORD rgb;
            rgb = GetSysColor(COLOR_BACKGROUND);
            argbTable[0].rgbBlue = GetBValue(rgb);
            argbTable[0].rgbGreen = GetGValue(rgb);
            argbTable[0].rgbRed = GetRValue(rgb);
            rgb = GetSysColor(COLOR_WINDOWTEXT);
            argbTable[1].rgbBlue = GetBValue(rgb);
            argbTable[1].rgbGreen = GetGValue(rgb);
            argbTable[1].rgbRed = GetRValue(rgb);
            WriteFile(hFileBitmap, argbTable, sizeof(argbTable), &cbWritten, NULL);

            DWORD adwBits[8];
            PatternToDwords(_szSelectedPattern, adwBits);
            WriteFile(hFileBitmap, adwBits, sizeof(adwBits), &cbWritten, NULL);

            CloseHandle(hFileBitmap);
        }
    }

    EXITPROC(2, "DS SavePattern!");
}

void CActiveDesktop::_WriteHtmlFromString(LPCTSTR psz)
{
    ENTERPROC(3, "DS WriteHtmlFromString(psz=>%s<)", psz);
    LPCWSTR  pwsz;
    WCHAR   szBuf[INTERNET_MAX_URL_LENGTH];
    UINT    uiLen;
    int     cch;

    if ((_pStream == NULL) && (_iDestFileCharset == ANSI_HTML_CHARSET))
    {
        cch = SHUnicodeToAnsi(psz, (LPSTR)szBuf, ARRAYSIZE(szBuf));
        ASSERT(cch == lstrlenW((LPWSTR)psz)+1);
        pwsz = (LPCWSTR)szBuf;
        uiLen = lstrlenA((LPSTR)szBuf);
    }
    else
    {
        pwsz = psz;
        uiLen = lstrlenW(pwsz);
    }

    UINT cbWritten;

    _WriteHtmlW(pwsz, uiLen, &cbWritten);
    
    EXITPROC(3, "DS WriteHtmlFromString!");
}

void CActiveDesktop::_WriteHtmlFromId(UINT uid)
{
    ENTERPROC(3, "DS WriteHtmlFromId(uid=%d)", uid);

    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    LoadString(HINST_THISDLL, uid, szBuf, ARRAYSIZE(szBuf));
    _WriteHtmlFromString(szBuf);

    EXITPROC(3, "DS WriteHtmlFromId!");
}

void CActiveDesktop::_WriteHtmlFromIdF(UINT uid, ...)
{
    ENTERPROC(3, "DS WriteHtmlFromIdF(uid=%d,...)", uid);

    TCHAR szBufFmt[INTERNET_MAX_URL_LENGTH];
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];

    LoadString(HINST_THISDLL, uid, szBufFmt, ARRAYSIZE(szBufFmt));

    va_list arglist;
    va_start(arglist, uid);
    HRESULT hr = StringCchVPrintf(szBuf, ARRAYSIZE(szBuf), szBufFmt, arglist);
    va_end(arglist);


    if (SUCCEEDED(hr))
    {
        _WriteHtmlFromString(szBuf);
    }

    EXITPROC(3, "DS WriteHtmlFromIdF!");
}

void CActiveDesktop::_WriteHtmlFromFile(LPCTSTR pszContents)
{
    ENTERPROC(3, "DS WriteHtmlFromFile(pszContents=>%s<)", pszContents);
    
    CReadFileObj *pReadFileObj = new CReadFileObj(pszContents);

    if (pReadFileObj)
    {
        if (pReadFileObj->_hFile != INVALID_HANDLE_VALUE)
        {
            WCHAR wcBuf[INTERNET_MAX_URL_LENGTH + 1];
            UINT uiCharCount = ARRAYSIZE(wcBuf) -1; //Leave room for null termination.
            UINT uiCharsRead;
            UINT uiCharsConverted;
            int iDestCharset = (_pStream ? UNICODE_HTML_CHARSET : _iDestFileCharset);
            while (SUCCEEDED(pReadFileObj->FileReadAndConvertChars(iDestCharset, wcBuf, uiCharCount, &uiCharsRead, &uiCharsConverted)) && uiCharsRead)
            {
                UINT cbWritten;
            
                _WriteHtmlW(wcBuf, uiCharsConverted, &cbWritten);
            
                if (uiCharsRead < uiCharCount)
                {
                    break;
                }
            }
        }
        delete pReadFileObj;
    }
    
    EXITPROC(3, "DS WriteHtmlFromFile!");
}

void CActiveDesktop::_WriteHtmlFromReadFileObj(CReadFileObj *pFileObj, int iOffsetStart, int iOffsetEnd)
{
    ENTERPROC(3, "DS WriteHtmlFromReadFileObj(pFileObj=%08X,iOffsetStart=%d,iOffsetEnd=%d)", pFileObj, iOffsetStart, iOffsetEnd);

    if (iOffsetStart != -1)
    {
        pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    }
    else
    {
        ASSERT(iOffsetEnd == -1);
        iOffsetEnd = -1;
    }

    //Get the number of WIDECHARs to be written
    UINT cchWrite = (iOffsetEnd == -1) ? 0xFFFFFFFF : (iOffsetEnd - iOffsetStart);

    while (cchWrite)
    {
        WCHAR wcBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Read a chunk.
        //
        UINT cchTryRead = (UINT)min(cchWrite, (ARRAYSIZE(wcBuf) - 1));
        UINT cchActualRead;
        HRESULT hres;

        //Note: if we are reading ANSI, we still use the unicode buff; but cast it!
        if (_iDestFileCharset == ANSI_HTML_CHARSET)
            hres = pFileObj->FileReadCharsA((LPSTR)wcBuf, cchTryRead, &cchActualRead);
        else
            hres = pFileObj->FileReadCharsW(wcBuf, cchTryRead, &cchActualRead);
            
        if (SUCCEEDED(hres) && cchActualRead)
        {
            //
            // Write a chunk.
            //
            UINT cchWritten;
            
            _WriteHtmlW(wcBuf, cchActualRead, &cchWritten);
            
            if (cchActualRead < cchTryRead)
            {
                //
                // End of file, all done.
                //
                break;
            }

            cchWrite -= cchActualRead;
        }
        else
        {
            //
            // Error reading from file, all done.
            //
            break;
        }
    }

    EXITPROC(3, "DS WriteHtmlFromHfile!");
}

int CActiveDesktop::_ScanForTagA(CReadFileObj *pFileObj, int iOffsetStart, LPCSTR pszTag)
{
    ENTERPROC(2, "DS ScanForTagA(pFileObj=%08X,iOffsetStart=%d,pszTagA=>%s<)",
    pFileObj, iOffsetStart, pszTag);

    int iRet = -1;
    BOOL fDoneReading = FALSE;
    int iOffset;
    DWORD cchTag = lstrlenA(pszTag);

    pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    iOffset = iOffsetStart;

    DWORD cchBuf = 0;
    while (!fDoneReading)
    {
        char szBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Fill in the buffer.
        //
        UINT cchTryRead = ARRAYSIZE(szBuf) - cchBuf - 1;
        UINT cchRead;
        if (SUCCEEDED(pFileObj->FileReadCharsA(&szBuf[cchBuf], cchTryRead, &cchRead)) && cchRead)
        {
            cchBuf += cchRead;

            //
            // Terminate the string.
            //
            szBuf[cchBuf] = '\0';

            //
            // Scan for the tag.
            //
            LPSTR pszTagInBuf = StrStrIA(szBuf, pszTag);

            if (pszTagInBuf)
            {
                //
                // Found the tag, compute the offset.
                //
                iRet = (int) (iOffset + pszTagInBuf - szBuf);
                fDoneReading = TRUE;
            }
            else if (cchRead < cchTryRead)
            {
                //
                // Ran out of file without finding tag.
                //
                fDoneReading = TRUE;
            }
            else
            {
                //
                // Compute how many bytes we want to throw away
                // from this buffer so we can read in more data.
                // We don't want to throw away all the bytes because
                // the tag we want may span two buffers.
                //
                DWORD cchSkip = cchBuf - cchTag;

                //
                // Advance the file offset.
                //
                iOffset += cchSkip;

                //
                // Reduce the buffer size.
                //
                cchBuf -= cchSkip;

                //
                // Move the kept bytes to the beginning of the buffer.
                //
                MoveMemory(szBuf, szBuf + cchSkip, cchBuf * sizeof(szBuf[0]));
            }
        }
        else
        {
            fDoneReading = TRUE;
        }
    }

    EXITPROC(2, "DS ScanForTagA=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanForTagW(CReadFileObj *pFileObj, int iOffsetStart, LPCWSTR pwszTag)
{
    ENTERPROC(2, "DS ScanForTag(pFileObj=%08X,iOffsetStart=%d,pszTagA=>%s<)",
    pFileObj, iOffsetStart, pwszTag);

    int iRet = -1;
    BOOL fDoneReading = FALSE;
    int iOffset;
    DWORD cchTag = lstrlenW(pwszTag);

    pFileObj->FileSeekChars(iOffsetStart, FILE_BEGIN);
    iOffset = iOffsetStart;

    DWORD cchBuf = 0;
    while (!fDoneReading)
    {
        WCHAR wszBuf[INTERNET_MAX_URL_LENGTH+1];

        //
        // Fill in the buffer.
        //
        UINT cchTryRead = ARRAYSIZE(wszBuf) - cchBuf - 1;
        UINT cchRead;
        if (SUCCEEDED(pFileObj->FileReadCharsW(&wszBuf[cchBuf], cchTryRead, &cchRead)) && cchRead)
        {
            cchBuf += cchRead;

            //
            // Terminate the string.
            //
            wszBuf[cchBuf] = L'\0';

            //
            // Scan for the tag.
            //
            LPWSTR pwszTagInBuf = StrStrIW(wszBuf, pwszTag);

            if (pwszTagInBuf)
            {
                //
                // Found the tag, compute the offset.
                //
                iRet = (int) (iOffset + pwszTagInBuf - wszBuf);
                fDoneReading = TRUE;
            }
            else if (cchRead < cchTryRead)
            {
                //
                // Ran out of file without finding tag.
                //
                fDoneReading = TRUE;
            }
            else
            {
                //
                // Compute how many bytes we want to throw away
                // from this buffer so we can read in more data.
                // We don't want to throw away all the bytes because
                // the tag we want may span two buffers.
                //
                DWORD cchSkip = cchBuf - cchTag;

                //
                // Advance the file offset.
                //
                iOffset += cchSkip;

                //
                // Reduce the buffer size.
                //
                cchBuf -= cchSkip;

                //
                // Move the kept bytes to the beginning of the buffer.
                //
                MoveMemory(wszBuf, wszBuf + cchSkip, cchBuf*sizeof(wszBuf[0]));
            }
        }
        else
        {
            fDoneReading = TRUE;
        }
    }

    EXITPROC(2, "DS ScanForTag=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanTagEntriesA(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYA *pte, int cte)
{
    ENTERPROC(2, "DS ScanTagEntriesA(pReadFileObj=%08X,iOffsetStart=%d,pte=%08X,cte=%d)",
                pReadFileObj, iOffsetStart, pte, cte);

    int iRet = -1;
    int i;

    for (i=0; i<cte; i++,pte++)
    {
        iRet = _ScanForTagA(pReadFileObj, iOffsetStart, pte->pszTag);
        if (iRet != -1)
        {
            if (pte->fSkipPast)
            {
                iRet += lstrlenA(pte->pszTag);
            }
            break;
        }
    }

    EXITPROC(2, "DS ScanTagEntriesA=%d", iRet);
    return iRet;
}

int CActiveDesktop::_ScanTagEntriesW(CReadFileObj *pReadFileObj, int iOffsetStart, TAGENTRYW *pte, int cte)
{
    ENTERPROC(2, "DS ScanTagEntriesW(pReadFileObj=%08X,iOffsetStart=%d,pte=%08X,cte=%d)",
                pReadFileObj, iOffsetStart, pte, cte);

    int iRet = -1;
    int i;

    for (i=0; i<cte; i++,pte++)
    {
        iRet = _ScanForTagW(pReadFileObj, iOffsetStart, pte->pwszTag);
        if (iRet != -1)
        {
            if (pte->fSkipPast)
            {
                iRet += lstrlenW(pte->pwszTag);
            }
            break;
        }
    }

    EXITPROC(2, "DS ScanTagEntriesW=%d", iRet);
    return iRet;
}

void CActiveDesktop::_ParseAnsiInputHtmlFile( LPTSTR szSelectedWallpaper, int *piOffsetBase, int *piOffsetComp)
{
    //
    // Figure out where to insert the base href tag.
    //
    int     iOffsetBase = 0, iBaseTagStart;
    BOOL    fUseBaseHref;
    LONG    lOffsetDueToBOM = 0; //Character Offset due to the Byte Order Mark.
                                 //1 for UNICODE and 0 for ANSI files.

//  98/11/11 #248047 vtan: This code looks for a <BASE HREF=...> tag.
//  It used to use a scan for "<BASE" and assume that this was the
//  desired tag. HTML allows a "<BASEFONT>" tag which was being
//  mistaken for a "<BASE HREF=...>" tag. The code now looks for the
//  same string but looks at the character following the "<BASE" to
//  see if it's a white-space character.

    fUseBaseHref = TRUE;
    _pReadFileObjHtmlBkgd->FileGetCurCharOffset(&lOffsetDueToBOM);
    iOffsetBase = (int)lOffsetDueToBOM;
    iBaseTagStart = _ScanForTagA(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, "<BASE");
                
    if (iBaseTagStart != -1)
    {
        UINT   uiCountChars, uiTryToRead;
        char   szBaseTagBuffer[6+1];     // allow for "<BASEx" plus a NULL.

        _pReadFileObjHtmlBkgd->FileSeekChars(iBaseTagStart, FILE_BEGIN);
        uiTryToRead = ARRAYSIZE(szBaseTagBuffer) - 1;
        if (SUCCEEDED(_pReadFileObjHtmlBkgd->FileReadCharsA(szBaseTagBuffer, uiTryToRead, &uiCountChars)) && uiCountChars)
        {
            char    ch;

            ch = szBaseTagBuffer[5];
            fUseBaseHref = ((ch != ' ') &&
                            (ch != '\r') &&
                            (ch != '\n') &&      // this covers the UNIX line break scheme
                            (ch != '\t'));
        }
    }
    if (fUseBaseHref)
    {
        TAGENTRYA rgteBase[] = {
                                   { "<HEAD>", TRUE, },
                                   { "<BODY", FALSE, },
                                   { "<HTML>", TRUE, },
                               };
        iOffsetBase = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, rgteBase, ARRAYSIZE(rgteBase));
        if (iOffsetBase == -1)
        {
            iOffsetBase = (int)lOffsetDueToBOM;
        }
    }

    //
    // Figure out where to insert the components.
    //
    TAGENTRYA rgteComponents[] = {
                                     { "</BODY>", FALSE, },
                                     { "</HTML>", FALSE, },
                                 };
    int iOffsetComponents = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteComponents, ARRAYSIZE(rgteComponents));

    //
    // Write out the initial HTML up to the <HEAD> tag.
    //
    _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, iOffsetBase);

    //
    // Write out the base tag.
    //
    if (fUseBaseHref)
    {
        //BASE tag must point to the base "URL". So, don't strip out the filename.
        _WriteHtmlFromIdF(IDS_BASE_TAG, szSelectedWallpaper);
    }

    // Figure out where to insert the DIV clause
    TAGENTRYA rgteBodyStart[] = {
                                    { "<BODY", FALSE, },
                                };
    int iOffsetBodyStart = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteBodyStart, ARRAYSIZE(rgteBodyStart));
    // Write out HTML until after the <BODY ......>
    if (iOffsetBodyStart == -1)
    {   // the <BODY> tag is not found, so we need to insert it.
        // Copy over stuff until </HEAD>
        TAGENTRYA rgteHeadEnd[] = {
                                      { "</HEAD>", TRUE, },
                                  };
        int iOffsetHeadEnd = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBase, rgteHeadEnd, ARRAYSIZE(rgteHeadEnd));
        if (iOffsetHeadEnd != -1)
        {
            _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetHeadEnd);
            iOffsetBase = iOffsetHeadEnd;
        }
        _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2); // "<BODY>"
        _fNeedBodyEnd = TRUE;
    }
    else
    {
        TAGENTRYA rgteBodyEnd[] = {
                                       { ">", TRUE, },
                                  };
        int iOffsetBodyEnd = _ScanTagEntriesA(_pReadFileObjHtmlBkgd, iOffsetBodyStart, rgteBodyEnd, ARRAYSIZE(rgteBodyEnd));
        if (iOffsetBodyEnd == -1)
        {   // An error in the HTML.
            iOffsetBodyEnd = iOffsetBodyStart;  // FEATURE: We need a better recovery idea.
        }
        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetBodyEnd);
        iOffsetBase = iOffsetBodyEnd;
    }

    *piOffsetBase = iOffsetBase;
    *piOffsetComp = iOffsetComponents;
}

void CActiveDesktop::_GenerateHtmlHeader(void)
{
    ENTERPROC(2, "DS GenerateHtmlHeader()");

    EnumMonitorsArea ema;
    GetMonitorSettings(&ema);

    RECT rcViewAreas[LV_MAX_WORKAREAS];  // WorkArea minus toolbar/tray areas
    int nViewAreas = ARRAYSIZE(rcViewAreas);
    // Get the ViewAreas
    if (!GetViewAreas(rcViewAreas, &nViewAreas))
    {
        nViewAreas = 0;
    }

    //Assume that the final Deskstat.htt that we generate is going to be in UNICODE.
    //This will change to ANSI only if the background html wallpaper is ANSI (determined later)
    _iDestFileCharset = UNICODE_HTML_CHARSET;
    //
    // Write out the background and color.
    //
    TCHAR szSelectedWallpaper[INTERNET_MAX_URL_LENGTH];
    // If the wallpaper does not have a directory specified (this may happen if other apps. change this value),
    // we have to figure it out.
    if (!GetWallpaperWithPath(_szSelectedWallpaper, szSelectedWallpaper, ARRAYSIZE(szSelectedWallpaper)))
    {
        return; // gross, but probably cleanest way
    }
    
    BOOL fValidWallpaper = GetFileAttributes(szSelectedWallpaper) != 0xFFFFFFFF;
    if (_fSingleItem || IsWallpaperPicture(szSelectedWallpaper) || !fValidWallpaper)
    {
        //
        //  Write the BOM for UNICODE
        //
        if (_hFileHtml)
        {
            DWORD cbWritten;
            
            WriteFile(_hFileHtml, (LPCSTR)&wUnicodeBOM, sizeof(wUnicodeBOM), &cbWritten, NULL);
        }
    
        // To account for the vagaries of the desktop browser (it's TopLeft starts from the TopLeft
        // of the Desktop ViewArea instead of the TopLeft of the monitor, as might be expected)
        // which happens only in the case of one active monitor systems, we add the width of the
        // tray/toolbars to the co-ordinates of the DIV section of each monitor's wallpaper.
        int iLeft, iTop;
        if (nViewAreas == 1)
        {
            iLeft = rcViewAreas[0].left - ema.rcVirtualMonitor.left;
            iTop = rcViewAreas[0].top - ema.rcVirtualMonitor.top;
        }
        else
        {
            iLeft = 0;
            iTop = 0;
        }

        //
        // Write out the standard header.
        //
        UINT i;
        for (i=IDS_COMMENT_BEGIN; i<IDS_BODY_BEGIN; i++)
        {
            _WriteHtmlFromIdF(i);
        }

        //
        // Write out the body tag, with background bitmap.
        //
        DWORD rgbDesk;
        rgbDesk = GetSysColor(COLOR_DESKTOP);

        TCHAR szBitmapFile[MAX_PATH];
        if (FAILED(GetPerUserFileName(szBitmapFile, ARRAYSIZE(szBitmapFile), PATTERN_FILENAME)))
        {
            szBitmapFile[0] = 0;
        }

        if (!_fSingleItem && _szSelectedWallpaper[0] && fValidWallpaper)
        {
            TCHAR szWallpaperUrl[INTERNET_MAX_URL_LENGTH];
            DWORD cch = ARRAYSIZE(szWallpaperUrl);
            UrlCreateFromPath(szSelectedWallpaper, szWallpaperUrl, &cch, URL_INTERNAL_PATH);

            switch (_wpo.dwStyle)
            {
                case WPSTYLE_TILE:
                    //
                    // Ignore the pattern, tile the wallpaper as background.
                    //
                    _WriteHtmlFromIdF(IDS_BODY_BEGIN2, szWallpaperUrl, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                    break;

                case WPSTYLE_CENTER:
                    if (IsValidPattern(_szSelectedPattern))
                    {
                        //
                        // Tile the pattern as the main background.
                        //
                        _WriteHtmlFromIdF(IDS_BODY_BEGIN2, szBitmapFile, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                        if (_fBackgroundHtml)   // We are generating the HTML for preview
                        {
                            _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP, szWallpaperUrl);
                        }
                        else
                        {
                            //
                            // Write out a DIV section for a centered, untiled wallpaper.
                            //
                            // write it out for each monitor.
                            for(int i = 0; i < ema.iMonitors; i++)
                            {
                                _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP2,
                                            ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                            ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                            ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                            ema.rcMonitor[i].bottom - ema.rcMonitor[i].top,
                                            szWallpaperUrl);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Write out a non-tiled, centered wallpaper as background.
                        //
                        if (_fBackgroundHtml)   // We are generating the HTML for preview
                        {
                            _WriteHtmlFromIdF(IDS_BODY_CENTER_WP, szWallpaperUrl, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                        }
                        else
                        {
                            _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                            // write it out for each monitor.
                            for(int i = 0; i < ema.iMonitors; i++)
                            {
                                _WriteHtmlFromIdF(IDS_BODY_PATTERN_AND_WP2,
                                                    ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                                    ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                                    ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                                    ema.rcMonitor[i].bottom - ema.rcMonitor[i].top,
                                                    szWallpaperUrl);
                            }
                        }
                    }
                    break;

                case WPSTYLE_STRETCH:
                    //
                    // Ignore the pattern, create a DIV section of the wallpaper
                    // stretched to 100% of the screen.
                    //
                    _WriteHtmlFromIdF(IDS_BODY_BEGIN2, c_szNULL, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
                    if (_fBackgroundHtml)   // We are generating the HTML for preview
                    {
                        _WriteHtmlFromIdF(IDS_STRETCH_WALLPAPER, szWallpaperUrl);
                    }
                    else
                    {
                        // stretch it for each monitor.
                        for(int i = 0; i < ema.iMonitors; i++)
                        {
                            _WriteHtmlFromIdF(IDS_DIV_START3, ema.rcMonitor[i].left - ema.rcVirtualMonitor.left - iLeft,
                                                ema.rcMonitor[i].top - ema.rcVirtualMonitor.top - iTop,
                                                ema.rcMonitor[i].right - ema.rcMonitor[i].left,
                                                ema.rcMonitor[i].bottom - ema.rcMonitor[i].top);
                            _WriteHtmlFromIdF(IDS_STRETCH_WALLPAPER, szWallpaperUrl);
                            _WriteHtmlFromId(IDS_DIV_END);
                        }
                    }
                    break;
            }
        }
        else
        {
            //
            // Ignore the wallpaper, generate either a tiled pattern
            // or solid color background.
            //
            _WriteHtmlFromIdF(IDS_BODY_BEGIN2, !_fSingleItem && IsValidPattern(_szSelectedPattern) ? szBitmapFile : c_szNULL, GetRValue(rgbDesk), GetGValue(rgbDesk), GetBValue(rgbDesk));
        }
    }
    else
    {
        if ((_pReadFileObjHtmlBkgd = new CReadFileObj(szSelectedWallpaper)) &&
            (_pReadFileObjHtmlBkgd->_hFile != INVALID_HANDLE_VALUE))
        {
            //The final Desktop.htt will be in ANSI only if the source html file is also in ansi.
            //So, get the type from the selected wallpaper object.
            _iDestFileCharset = _pReadFileObjHtmlBkgd->_iCharset;
            //
            //  Write the BOM for UNICODE
            //
            if (_hFileHtml && (_iDestFileCharset == UNICODE_HTML_CHARSET))
            {
                DWORD cbWritten;
            
                WriteFile(_hFileHtml, (LPCSTR)&wUnicodeBOM, sizeof(wUnicodeBOM), &cbWritten, NULL);
            }
    
            //
            // Figure out where to insert the base href tag.
            //
            int     iOffsetBase = 0;
            int     iOffsetComponents;
//  98/11/11 #248047 vtan: This code looks for a <BASE HREF=...> tag.
//  It used to use a scan for "<BASE" and assume that this was the
//  desired tag. HTML allows a "<BASEFONT>" tag which was being
//  mistaken for a "<BASE HREF=...>" tag. The code now looks for the
//  same string but looks at the character following the "<BASE" to
//  see if it's a white-space character.

            if (_iDestFileCharset == ANSI_HTML_CHARSET)
            {
                //The following function parses the ANSI input html file and finds various offsets
                _ParseAnsiInputHtmlFile(szSelectedWallpaper, &iOffsetBase, &iOffsetComponents);
            }
            else
            {
                //The following code parses the UNICODE input html wallpaper file.
                int iBaseTagStart;
                BOOL    fUseBaseHref;
                LONG    lOffsetDueToBOM = 0; //Character Offset due to the Byte Order Mark.
                                         //1 for UNICODE and 0 for ANSI files.
                fUseBaseHref = TRUE;
                _pReadFileObjHtmlBkgd->FileGetCurCharOffset(&lOffsetDueToBOM);
                iOffsetBase = (int)lOffsetDueToBOM;
                iBaseTagStart = _ScanForTagW(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, L"<BASE");
                
                if (iBaseTagStart != -1)
                {
                    UINT   uiCountChars, uiTryToRead;
                    WCHAR  wszBaseTagBuffer[6+1];     // allow for "<BASEx" plus a NULL.

                    _pReadFileObjHtmlBkgd->FileSeekChars(iBaseTagStart, FILE_BEGIN);
                    uiTryToRead = ARRAYSIZE(wszBaseTagBuffer) - 1;
                    if (SUCCEEDED(_pReadFileObjHtmlBkgd->FileReadCharsW(wszBaseTagBuffer, uiTryToRead, &uiCountChars)) && uiCountChars)
                    {
                        WCHAR    wc;

                        wc = wszBaseTagBuffer[5];
                        fUseBaseHref = ((wc != L' ') &&
                                        (wc != L'\r') &&
                                        (wc != L'\n') &&      // this covers the UNIX line break scheme
                                        (wc != L'\t'));
                    }
                }
                if (fUseBaseHref)
                {
                    TAGENTRYW rgteBase[] = {
                                            { L"<HEAD>", TRUE, },
                                            { L"<BODY", FALSE, },
                                            { L"<HTML>", TRUE, },
                                           };
                    iOffsetBase = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, rgteBase, ARRAYSIZE(rgteBase));
                    if (iOffsetBase == -1)
                    {
                        iOffsetBase = (int)lOffsetDueToBOM;
                    }
                }

                //
                // Figure out where to insert the components.
                //
                TAGENTRYW rgteComponents[] = {
                                                { L"</BODY>", FALSE, },
                                                { L"</HTML>", FALSE, },
                                             };
                iOffsetComponents = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteComponents, ARRAYSIZE(rgteComponents));

                //
                // Write out the initial HTML up to the <HEAD> tag.
                //
                _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, (int)lOffsetDueToBOM, iOffsetBase);

                //
                // Write out the base tag.
                //
                if (fUseBaseHref)
                {
                    //BASE tag must point to the base "URL". So, don't strip out the filename.
                    _WriteHtmlFromIdF(IDS_BASE_TAG, szSelectedWallpaper);
                }

                // Figure out where to insert the DIV clause
                TAGENTRYW rgteBodyStart[] = {
                                                { L"<BODY", FALSE, },
                                            };
                int iOffsetBodyStart = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteBodyStart, ARRAYSIZE(rgteBodyStart));
                // Write out HTML until after the <BODY ......>
                if (iOffsetBodyStart == -1)
                {   // the <BODY> tag is not found, so we need to insert it.
                    // Copy over stuff until </HEAD>
                    TAGENTRYW rgteHeadEnd[] = {
                                                { L"</HEAD>", TRUE, },
                                              };
                    int iOffsetHeadEnd = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBase, rgteHeadEnd, ARRAYSIZE(rgteHeadEnd));
                    if (iOffsetHeadEnd != -1)
                    {
                        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetHeadEnd);
                        iOffsetBase = iOffsetHeadEnd;
                    }
                    _WriteHtmlFromIdF(IDS_BODY_CENTER_WP2); // "<BODY>"
                    _fNeedBodyEnd = TRUE;
                }
                else
                {
                    TAGENTRYW rgteBodyEnd[] = {
                                                { L">", TRUE, },
                                              };
                    int iOffsetBodyEnd = _ScanTagEntriesW(_pReadFileObjHtmlBkgd, iOffsetBodyStart, rgteBodyEnd, ARRAYSIZE(rgteBodyEnd));
                    if (iOffsetBodyEnd == -1)
                    {   // An error in the HTML.
                        iOffsetBodyEnd = iOffsetBodyStart;  // FEATURE: We need a better recovery idea.
                    }
                    _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetBodyEnd);
                    iOffsetBase = iOffsetBodyEnd;
                }

            }
            // Insert the DIV clause
            if (ema.iMonitors > 1)
            {
                int         iIndexPrimaryMonitor;
                HMONITOR    hMonitorPrimary;
                MONITORINFO monitorInfo;

                // 99/03/23 #275429 vtan: We used GetViewAreas() to fill in rcViewAreas above.
                // The code here used to assume that [0] ALWAYS referred to the primary monitor.
                // This isn't the case if the monitor settings are changed without a restart.
                // In order to compensate for this and always render the wallpaper into the
                // primary monitor, a search is performed to find a (left, top) that matches
                // one of the work areas and this is used as the primary monitor. If none can
                // be found then default to the old algorithm.

                hMonitorPrimary = GetPrimaryMonitor();
                monitorInfo.cbSize = sizeof(monitorInfo);
                TBOOL(GetMonitorInfo(hMonitorPrimary, &monitorInfo));
                iIndexPrimaryMonitor = -1;
                for (int i = 0; (iIndexPrimaryMonitor < 0) && (i < nViewAreas); ++i)
                {
                    if ((monitorInfo.rcWork.left == rcViewAreas[i].left) && (monitorInfo.rcWork.top == rcViewAreas[i].top))
                    {
                        iIndexPrimaryMonitor = i;
                    }
                }
                if (iIndexPrimaryMonitor < 0)
                    iIndexPrimaryMonitor = 0;
                if ((nViewAreas <= 0) || (rcViewAreas[iIndexPrimaryMonitor].right == rcViewAreas[iIndexPrimaryMonitor].left))
                // The second case could occur on bootup
                {
                    // Some error occured when getting the ViewAreas. Recover from the error by using the workarea.
                    // Get the workarea of the primary monitor, since HTML wallpapers are displayed only there.
                    GetMonitorWorkArea(hMonitorPrimary, &rcViewAreas[iIndexPrimaryMonitor]);
                }
                _WriteHtmlFromIdF(IDS_DIV_START3,
                                  rcViewAreas[iIndexPrimaryMonitor].left - ema.rcVirtualMonitor.left,
                                  rcViewAreas[iIndexPrimaryMonitor].top - ema.rcVirtualMonitor.top,
                                  rcViewAreas[iIndexPrimaryMonitor].right - rcViewAreas[iIndexPrimaryMonitor].left,
                                  rcViewAreas[iIndexPrimaryMonitor].bottom - rcViewAreas[iIndexPrimaryMonitor].top);
            }

            //
            // Write out HTML from after <HEAD> tag to just before </BODY> tag.
            //
            _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, iOffsetBase, iOffsetComponents);

            if (ema.iMonitors > 1)
            {
                _WriteHtmlFromId(IDS_DIV_END);
            }
        }
        else
        {
            if (_pReadFileObjHtmlBkgd)
                delete _pReadFileObjHtmlBkgd;
            _pReadFileObjHtmlBkgd = NULL;
        }
    }

    EXITPROC(2, "DS GenerateHtmlHeader!");
}

void CActiveDesktop::_WriteResizeable(COMPONENTA *pcomp)
{
    TCHAR szResizeable[3];

    //If Resize is set, then the comp is resizeable in both X and Y directions!
    if (pcomp->cpPos.fCanResize || (pcomp->cpPos.fCanResizeX && pcomp->cpPos.fCanResizeY))
    {
        szResizeable[0] = TEXT('X');
        szResizeable[1] = TEXT('Y');
        szResizeable[2] = TEXT('\0');
    }
    else if (pcomp->cpPos.fCanResizeX)
    {
        szResizeable[0] = TEXT('X');
        szResizeable[1] = TEXT('\0');
    }
    else if (pcomp->cpPos.fCanResizeY)
    {
        szResizeable[0] = TEXT('Y');
        szResizeable[1] = TEXT('\0');
    }

    _WriteHtmlFromIdF(IDS_RESIZEABLE, szResizeable);
}

void CActiveDesktop::_WriteHtmlW(LPCWSTR wcBuf, UINT cchToWrite, UINT *pcchWritten)
{
    ULONG    cchWritten = 0;
    UINT     uiSize;
    
    if (_pStream)
    {
        uiSize = sizeof(WCHAR);
        _pStream->Write((LPVOID)wcBuf, cchToWrite * uiSize, &cchWritten);
    }
    else
    {
        ASSERT(_hFileHtml);
        uiSize = (_iDestFileCharset == ANSI_HTML_CHARSET) ? sizeof(char) : sizeof(WCHAR);
        WriteFile(_hFileHtml, (LPCVOID)wcBuf, cchToWrite * uiSize, &cchWritten, NULL);
    }
    *pcchWritten = (UINT)(cchWritten/uiSize);  //Convert to number of chars.
}

void CActiveDesktop::_GenerateHtmlPicture(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlPicture(pcomp=%08X)");

    //
    // Write out the image src HTML.
    //
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cch = ARRAYSIZE(szUrl);
    HRESULT hr = UrlCreateFromPath(pcomp->szSource, szUrl, &cch, 0);
    if (FAILED(hr))
    {
        hr = StringCchCopy(szUrl, ARRAYSIZE(szUrl), pcomp->szSource);
    }

    if (SUCCEEDED(hr))
    {
        _WriteHtmlFromIdF(IDS_IMAGE_BEGIN2, pcomp->dwID, szUrl);

        //
        // Write out whether this image is resizeable or not!
        //
        _WriteResizeable(pcomp);

        //
        // Write out the URL that must be used for subscription purposes.
        //
        _WriteHtmlFromIdF(IDS_SUBSCRIBEDURL, pcomp->szSubscribedURL);

        //
        // Write out the image location HTML.
        //
        if ((pcomp->cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH) &&
            (pcomp->cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT))
        {
            _WriteHtmlFromIdF(IDS_IMAGE_LOCATION, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.izIndex);
        }
        else
        {
            _WriteHtmlFromIdF(IDS_IMAGE_SIZE, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop,
                                pcomp->cpPos.dwWidth, pcomp->cpPos.dwHeight, pcomp->cpPos.izIndex);
        }
    }

    EXITPROC(2, "DS GenerateHtmlPicture!");
}

void CActiveDesktop::_GenerateHtmlDoc(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlDoc(pcomp=%08X)");
    
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD   dwSize = ARRAYSIZE(szUrl);
    LPTSTR  lpszUrl = szUrl;

    if (FAILED(UrlCreateFromPath(pcomp->szSource, szUrl, &dwSize, 0)))
        lpszUrl = pcomp->szSource;

    //
    // Write out the DIV header HTML.
    //
    _WriteHtmlFromIdF(IDS_DIV_START2, pcomp->dwID, lpszUrl);

    //
    // Write out whether this component is resizeable or not!
    //
    _WriteResizeable(pcomp);

    //
    // Write out the DIV location HTML.
    //
    _WriteHtmlFromIdF(IDS_DIV_SIZE, pcomp->cpPos.dwHeight, _fSingleItem ? 0 : pcomp->cpPos.iLeft,
        _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.dwWidth, pcomp->cpPos.izIndex);

    //
    // Extract the doc contents directly into the HTML.
    //
    _WriteHtmlFromFile(pcomp->szSource);

    //
    // Close the DIV section.
    //
    _WriteHtmlFromId(IDS_DIV_END);

    EXITPROC(2, "DS GenerateHtmlDoc!");
}

void CActiveDesktop::_GenerateHtmlSite(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlSite(pcomp=%08X)");

    //
    // Write out the frame src HTML.
    //
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cch=ARRAYSIZE(szUrl);
    if (FAILED(UrlCreateFromPath(pcomp->szSource, szUrl, &cch, 0)))
    {
        if (FAILED(StringCchCopy(szUrl, ARRAYSIZE(szUrl), pcomp->szSource)))
        {
            return;
        }
    }

    DWORD currentURLLength, maximumURLLength;
    LPTSTR pszURL = NULL;
    TCHAR szFormatBuffer[0x0100];

//  98/09/29 #211384 vtan: There is a limitation in wvsprintf.
//  It only allows 2048 bytes in its buffer. If the URL is
//  longer than 1024 characters less the IDS_IFRAME_BEGIN2
//  string length less the component ID less "scrolling=no"
//  if the component cannot be scrolled then the URL string
//  will not be correctly inserted into the IDS_IFRAME_BEGIN2
//  string and there will be a missing end-quote and trident
//  will fail to render desktop.htt correctly.

//  To correct against this the followING limits the length of
//  the URL to this maximum and truncates any characters
//  beyond the limit so that the IDS_IFRAME_BEGIN2 string
//  contains its end-quote and trident does not barf.

//  The above condition is a boundary condition and this
//  check is quick so that the calculations that follow do
//  not have to be executed repeatedly.

    currentURLLength = lstrlen(szUrl);
    if (currentURLLength > 768)                                 // a hard-coded limit
    {
        maximumURLLength = 1024;                                // wvsprintf limit
        LoadString(HINST_THISDLL, IDS_IFRAME_BEGIN2, szFormatBuffer, ARRAYSIZE(szFormatBuffer));
        maximumURLLength -= lstrlen(szFormatBuffer);              // IDS_IFRAME_BEGIN2
        maximumURLLength -= 16;                                 // pcomp->dwID
        maximumURLLength -= lstrlen(TEXT("scrolling=no"));      // pcomp->fNoScroll
        if (currentURLLength > maximumURLLength)
            szUrl[maximumURLLength] = static_cast<TCHAR>('\0');
    }
    _WriteHtmlFromIdF(IDS_IFRAME_BEGIN2, pcomp->dwID, szUrl, pcomp->fNoScroll ? TEXT("scrolling=no") : c_szNULL);

    //
    // Write out whether this Component is resizeable or not!
    //
    _WriteResizeable(pcomp);

//  98/09/29 #211384 vtan: See above.

    currentURLLength = lstrlen(pcomp->szSubscribedURL);
    if (currentURLLength > 768)
    {
        if (SUCCEEDED(StringCchCopy(szUrl, ARRAYSIZE(szUrl), pcomp->szSubscribedURL)))
        {
            maximumURLLength = 1024;
            LoadString(HINST_THISDLL, IDS_SUBSCRIBEDURL, szFormatBuffer, ARRAYSIZE(szFormatBuffer));
            maximumURLLength -= lstrlen(szFormatBuffer);              // IDS_SUBSCRIBEDURL
            if (currentURLLength > maximumURLLength)
                szUrl[maximumURLLength] = static_cast<TCHAR>('\0');
            pszURL = szUrl;
        }
    }
    else
    {
        pszURL = pcomp->szSubscribedURL;
    }

    if (pszURL)
    {
        //
        // Write out the URL that must be used for subscription purposes.
        //
        _WriteHtmlFromIdF(IDS_SUBSCRIBEDURL, pszURL);

        //
        // Write out the frame location HTML.
        //
        _WriteHtmlFromIdF(IDS_IFRAME_SIZE, _fSingleItem ? 0 : pcomp->cpPos.iLeft, _fSingleItem ? 0 : pcomp->cpPos.iTop,
            pcomp->cpPos.dwWidth, pcomp->cpPos.dwHeight, pcomp->cpPos.izIndex);
    }

    EXITPROC(2, "DS GenerateHtmlSite!");
}

void CActiveDesktop::_GenerateHtmlControl(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlControl(pcomp=%08X)");
    ASSERT(pcomp);
    
    // Did the Administrator restrict "Channel UI"?
    if (SHRestricted2W(REST_NoChannelUI, NULL, 0))
    {
        TCHAR szChannelOCGUID[GUIDSTR_MAX];

        SHStringFromGUID(CLSID_ChannelOC, szChannelOCGUID, ARRAYSIZE(szChannelOCGUID));
        if (!StrCmpNI(pcomp->szSource, &(szChannelOCGUID[1]), lstrlen(pcomp->szSource)-3))
        {
            // Yes, so we need to hide the Channel Desktop Component.
            // Return here before we generate it.
            return;
        }        
    }
    
    //
    // Write out the control HTML.
    //

    // First the control header
    _WriteHtmlFromIdF(IDS_CONTROL_1, pcomp->dwID);
    // then the size
    _WriteHtmlFromIdF(IDS_CONTROL_2, pcomp->cpPos.dwHeight, _fSingleItem ? 0 : pcomp->cpPos.iLeft,
        _fSingleItem ? 0 : pcomp->cpPos.iTop, pcomp->cpPos.dwWidth, pcomp->cpPos.izIndex);
    //
    // Write out whether this Control is resizeable or not!
    //
    _WriteResizeable(pcomp);

    // Finally the rest of the control
    _WriteHtmlFromIdF(IDS_CONTROL_3, pcomp->szSource);

    EXITPROC(2, "DS GenerateHtmlControl!");
}

void CActiveDesktop::_GenerateHtmlComponent(COMPONENTA *pcomp)
{
    ENTERPROC(2, "DS GenerateHtmlComponent(pcomp=%08X)");

    switch(pcomp->iComponentType)
    {
        case COMP_TYPE_PICTURE:
            _GenerateHtmlPicture(pcomp);
            break;

        case COMP_TYPE_HTMLDOC:
            _GenerateHtmlDoc(pcomp);
            break;

        case COMP_TYPE_WEBSITE:
            _GenerateHtmlSite(pcomp);
            break;

        case COMP_TYPE_CONTROL:
            _GenerateHtmlControl(pcomp);
            break;
    }

    EXITPROC(2, "DS GenerateHtmlComponent!");
}

void CActiveDesktop::_GenerateHtmlFooter(void)
{
    ENTERPROC(2, "DS GenerateHtmlFooter()");

    //
    // Write out the deskmovr object.
    //
    if (!_fNoDeskMovr)
    {
        TCHAR szDeskMovrFile[MAX_PATH];

        if (GetWindowsDirectory(szDeskMovrFile, ARRAYSIZE(szDeskMovrFile)) &&
            PathAppend(szDeskMovrFile, DESKMOVR_FILENAME))
        {
            _WriteHtmlFromFile(szDeskMovrFile);
        }
    }

    //
    // Write out the concluding HTML tags.
    //
    if (_pReadFileObjHtmlBkgd)
    {
        if (_fNeedBodyEnd)
        {    // We had introduced the <BODY> tag by ourselves.
            _WriteHtmlFromId(IDS_BODY_END2);
            _fNeedBodyEnd = FALSE;
        }
        _WriteHtmlFromReadFileObj(_pReadFileObjHtmlBkgd, -1, -1);
        delete _pReadFileObjHtmlBkgd;   //Close the file and cleanup!
        _pReadFileObjHtmlBkgd = NULL;
    }
    else
    {
        _WriteHtmlFromId(IDS_BODY_END);
    }

    EXITPROC(2, "DS GenerateHtmlFooter!");
}

void CActiveDesktop::_GenerateHtml(void)
{
    ENTERPROC(2, "DS GenerateHtml()");

    TCHAR szHtmlFile[MAX_PATH];

    //
    // Compute the filename.
    //
    szHtmlFile[0] = TEXT('\0');

    if (SUCCEEDED(GetPerUserFileName(szHtmlFile, ARRAYSIZE(szHtmlFile), DESKTOPHTML_FILENAME)))
    {
        // Recreate the file.
        _hFileHtml = CreateFile(szHtmlFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (_hFileHtml != INVALID_HANDLE_VALUE)
        {
            _GenerateHtmlHeader();

            if (_co.fEnableComponents && _hdsaComponent && DSA_GetItemCount(_hdsaComponent) &&
                !SHRestricted(REST_NODESKCOMP))
            {
                int i;

                for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
                {
                    COMPONENTA comp;
                    comp.dwSize = sizeof(COMPONENTA);

                    if ((DSA_GetItem(_hdsaComponent, i, &comp) != -1) && (comp.fChecked))
                    {
                        _GenerateHtmlComponent(&comp);
                    }
                }
            }

            _GenerateHtmlFooter();
            CloseHandle(_hFileHtml);
            SetDesktopFlags(COMPONENTS_DIRTY, 0);
        }
        else
        {

            // 99/05/19 #340772 vtan: If unable to open desktop.htt it's probably
            // in use by another process or task (perhaps trident is trying to
            // render it). In this case mark it dirty so that it will get recreated
            // - yet again but this time with more current data.

            SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);
        }
    }

    EXITPROC(2, "DS GenerateHtml!");
}

HRESULT CActiveDesktop::GenerateDesktopItemHtml(LPCWSTR pwszFileName, COMPONENT *pcomp, DWORD dwReserved)
{
    HRESULT hres = E_FAIL;
    ENTERPROC(2, "DS GenerateComponentHtml(pcomp=%08X)", pcomp);

    //Check for the input parameters
    if (!pwszFileName || (pcomp && (pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    ASSERT(!dwReserved);     // These should be 0

    //
    // Create the file.
    //
    _hFileHtml = CreateFile(pwszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFileHtml != INVALID_HANDLE_VALUE)
    {
        _fNoDeskMovr = TRUE;
        _fBackgroundHtml = TRUE;
        //Check if we need to add a component
        if (pcomp)
        {
            COMPONENTA  CompA;

            CompA.dwSize = sizeof(CompA);
            WideCompToMultiComp(pcomp, &CompA);

            _fSingleItem = TRUE;
            _GenerateHtmlHeader();

            _GenerateHtmlComponent(&CompA);
            _GenerateHtmlFooter();
            _fSingleItem = FALSE;
        }
        else
        {
            //generate just the header and the footer with proper
            // wallpaper and pattern info!
            _GenerateHtmlHeader();
            _GenerateHtmlFooter();
        }
        _fBackgroundHtml = FALSE;
        _fNoDeskMovr = FALSE;

        CloseHandle(_hFileHtml);

        hres = S_OK;
    }
    _hFileHtml = NULL;

    EXITPROC(2, "DS GenerateComponentHtml=%d", hres);
    return hres;
}

//
// AddUrl
//
//

HRESULT CActiveDesktop::AddUrl(HWND hwnd, LPCWSTR pszSourceW, LPCOMPONENT pcomp, DWORD dwFlags)
{
    LPTSTR pszExt;
    HRESULT fOkay = TRUE;
    BOOL fExtIsCdf,fPathIsUrl;
    BOOL fSubscribed = FALSE;
    COMPONENT   compLocal;
    COMPONENTA  compA;
    TCHAR szSource[INTERNET_MAX_URL_LENGTH];

//  98/08/28 vtan #202777: The following if statement sanitizes parameters
//  passed to AddUrl(). The statements following the "||" are executed
//  despite the for pcomp against NULL. This causes an access violation
//  and an exception to be thrown.

#if     0
    //Check for the input parameters.
    if (!pszSourceW || (pcomp &&
       ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pcomp->dwSize == sizeof(*pcomp)) && !VALIDATESTATE(pcomp->dwCurItemState))))
        return E_INVALIDARG;
#else

//  The following performs the same comparison but is spread into three
//  separate comparisons. As performance is not a critical issue here
//  but correctness is this makes the tests clear and understandable.
//  The invalid conditions are described.

//  Validate input parameters. Invalid parameters are:
//      1) NULL pszSourceW
//      2) pcomp->dwSize for a COMPONENT struct but invalid pcomp->dwCurItemState
//      3) pcomp->dwSize is not for a COMPONENT struct nor for a IE4COMPONENT struct

    if (pszSourceW == NULL)
        return(E_INVALIDARG);
    if (pcomp != NULL)
    {
        if ((pcomp->dwSize == sizeof(*pcomp)) && !VALIDATESTATE(pcomp->dwCurItemState))
            return(E_INVALIDARG);
        if ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT)))
            return(E_INVALIDARG);
    }
#endif

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if (SHIsRestricted(NULL, REST_NOADDDESKCOMP))
        return E_ACCESSDENIED;

    if (!pcomp)
    {
        pcomp = &compLocal;
        pcomp->dwSize = sizeof(compLocal);
        pcomp->dwCurItemState = IS_NORMAL;
    }

    // Attempt to come up with a reasonable window handle if none is passed in.  ParseDesktopComponent
    // will fail to attempt to create a subscription if a NULL window handle is passed in.
    if (!hwnd)
        hwnd = GetLastActivePopup(GetActiveWindow());

    compA.dwSize = sizeof(compA);
    compA.dwCurItemState = (pcomp->dwSize != sizeof(IE4COMPONENT)) ? pcomp->dwCurItemState : IS_NORMAL;

    SHUnicodeToTChar(pszSourceW, szSource, ARRAYSIZE(szSource));
    pszExt = PathFindExtension(szSource);
    fExtIsCdf = lstrcmpi(pszExt, TEXT(".CDF")) == 0;
    fPathIsUrl = PathIsURL(szSource) && !UrlIsFileUrl(szSource);

    if (FindComponent(szSource, (g_pActiveDesk ? g_pActiveDesk : this)))
    {
        if (dwFlags & ADDURL_SILENT)  
        {
            if (FAILED(StringCchCopy(compA.szSource, ARRAYSIZE(compA.szSource), szSource)))
            {
                compA.szSource[0] = 0;
            }

            
            MultiCompToWideComp(&compA, pcomp);
            RemoveDesktopItem(pcomp, 0);
        }
        else  
        {
            // This is a long string. So,...
            TCHAR szMsg[512];
            TCHAR szMsg2[256];
            TCHAR szTitle[128];
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS, szMsg, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS_2, szMsg2, ARRAYSIZE(szMsg2));
            StringCchCat(szMsg, ARRAYSIZE(szMsg), szMsg2); // display, truncation fine
            LoadString(HINST_THISDLL, IDS_COMP_TITLE, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hwnd, szMsg, szTitle, MB_OK);

            fOkay = FALSE;
        }
    }

    if (fOkay && CheckForExistingSubscription(szSource))
    {
        if ((dwFlags & ADDURL_SILENT) ||
            (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_SUBSCRIBED), 
                 MAKEINTRESOURCE(IDS_COMP_TITLE), MB_YESNO) == IDYES))
        {
            DeleteFromSubscriptionList(szSource);
        }
        else
        {
            fOkay = FALSE;
        }
    }

    if (fOkay)
    {
        if (fPathIsUrl || fExtIsCdf)
        {
            HRESULT hr;
            IProgressDialog * pProgressDlg = NULL;
            DECLAREWAITCURSOR;

//  98/12/16 vtan #250938: Cannot add new components that are not
//  local with ICW run to completion. Tell the user and launch ICW.

            if (!IsICWCompleted())
            {
                if ((dwFlags & ADDURL_SILENT) == 0)
                {
                    ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_ICW_ADD), MAKEINTRESOURCE(IDS_COMP_ICW_TITLE), MB_OK);
                    LaunchICW();
                }
                fOkay = FALSE;
            }
            else
            {
                SetWaitCursor();
                // ParseDesktopComponent can hang for a long time, we need some sort of progress
                // UI up before we call it.
                if (!(dwFlags & ADDURL_SILENT) && !fExtIsCdf)
                {
                    if (pProgressDlg = CProgressDialog_CreateInstance(IDS_COMP_TITLE, IDA_ISEARCH, g_hinst))
                    {
                        TCHAR szConnecting[80];
                        LoadString(HINST_THISDLL, IDS_CONNECTING, szConnecting, ARRAYSIZE(szConnecting));
                        pProgressDlg->SetLine(1, szConnecting, FALSE, NULL);
                        pProgressDlg->SetLine(2, szSource, TRUE, NULL);
                        pProgressDlg->StartProgressDialog(hwnd, NULL, PROGDLG_AUTOTIME | PROGDLG_NOPROGRESSBAR, NULL);
                    }
                }

                hr = ParseDesktopComponent(hwnd, szSource, pcomp);

                if (pProgressDlg)
                {
                    pProgressDlg->StopProgressDialog();
                    fOkay = !pProgressDlg->HasUserCancelled();  //  User may have cancelled the progress dialog
                    pProgressDlg->Release();
                }
                ResetWaitCursor();

                if (hr == S_FALSE) // User cancelled operation via subscription download dialog
                    fOkay = FALSE;

                if (fOkay)
                {
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Convert ed's wide thinggy to multi.
                        //
                        WideCompToMultiComp(pcomp, &compA);
    
                        fSubscribed = TRUE;
                    }
                    else if (!fExtIsCdf)
                    {
                        //
                        // This is some non-CDF url.
                        //
                        CreateComponent(&compA, szSource);
                    }
                    else
                    {
                        //
                        // We barfed on a CDF, bring up an error message.
                        //
                        if (!(dwFlags & ADDURL_SILENT))
                        {
                            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_BADURL), 
                                            MAKEINTRESOURCE(IDS_COMP_TITLE), MB_OK);
                        }
                        fOkay = FALSE;
                    }
                }
            }
        }
        else
        {
            //
            // This is just some local file.
            //
            CreateComponent(&compA, szSource);
        }
    }

    if (fOkay && fPathIsUrl && !fSubscribed)
    {
        //
        // Run subscription code on URLs if CDF code hasn't already.
        //
        if (dwFlags & ADDURL_SILENT)
        {
            ISubscriptionMgr *psm;

            if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
            {
                //We need to zero init this structure except the cbSize field.
                SUBSCRIPTIONINFO siDefault = {sizeof(SUBSCRIPTIONINFO)};
                //This field is already initialized above.
                //siDefault.cbSize = sizeof(siDefault);
                psm->CreateSubscription(hwnd, szSource, szSource, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &siDefault);
                psm->UpdateSubscription(szSource);
                psm->Release();
            }
        }
        else
        {
            HRESULT hres = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, szSource, NULL, hwnd);
            if (!SUCCEEDED(hres))  //Some error, or the user chose Cancel - we should fail.
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_COMP_BADSUBSCRIBE), 
                                MAKEINTRESOURCE(IDS_COMP_TITLE), MB_OK);
            }
            fOkay = (hres == S_OK);    //could be S_FALSE, which means CreateSubscription was cancelled
            //so we don't display the above error, but we don't create the DTI
        }
    }

    MultiCompToWideComp(&compA, pcomp);
 
    if (fOkay)
    {
        AddDesktopItem(pcomp, 0);
        return S_OK;
    }
    else  
    {
        return E_FAIL;
    }
}

void CActiveDesktop::_SaveSettings(DWORD dwFlags)
{
    ENTERPROC(2, "DS SaveSettings()");

    if (dwFlags & AD_APPLY_SAVE)
    {
        // Don't ever modify the safemode settings
        TCHAR szDeskcomp[MAX_PATH];
        
        GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, _pszScheme);
        if (!StrStr(szDeskcomp, REG_DESKCOMP_SAFEMODE_SUFFIX))
        {
            //
            // Write out registry settings.
            //
            _SaveWallpaper();
            _SaveComponents();
            _SavePattern(SAVE_PATTERN_NAME);
        }
    };

    if (dwFlags & AD_APPLY_HTMLGEN)
    {
        //We need to generate the Patten.bmp file too!
        _SavePattern(GENERATE_PATTERN_FILE);

        //
        // Write out HTML file.
        //
        _GenerateHtml();
    }

// The 3rd largest hang found by WindowsUpdate crash uploader has been that the Desktop hwnd hangs
    // and the display CPYU
#define SENDMESSAGE_TIMEOUT         (10 * 1000)

    if (dwFlags & AD_APPLY_REFRESH)
    {
        HWND    hwndShell = GetShellWindow();
        SHELLSTATE ss = {0};
        DWORD_PTR pdwTemp = 0;

        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        BOOL fWasActiveDesktop = BOOLIFY(ss.fDesktopHTML);
        BOOL fIsActiveDesktop = BOOLIFY(_co.fActiveDesktop);

        if (fIsActiveDesktop && !IsICWCompleted())
            TBOOL(DisableUndisplayableComponents(this));
        if (fIsActiveDesktop != fWasActiveDesktop)
        {
            if (hwndShell)
            {

                SendMessageTimeout(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, (LPARAM)TEXT("ToggleDesktop"), SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }

            //Force a SHRefresh with this dummy call
            SHGetSetSettings(NULL, 0, TRUE);
        }
        else if (fIsActiveDesktop && hwndShell)
        {
            //See if we can simply make the changes dynamically instead of refreshing the whole page

//  98/09/22 #182982 vtan: Use dynamic HTML to refresh only if specifically told by a flag.

            if (_fUseDynamicHtml && (dwFlags & AD_APPLY_DYNAMICREFRESH))
            {
                SendMessageTimeout(hwndShell, DTM_MAKEHTMLCHANGES, (WPARAM)0, (LPARAM)0L, SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }
            else
            {
                //Can't use dynamic html. We have to refresh the whole page.
                SendMessageTimeout(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, 
                    (LPARAM)((dwFlags & AD_APPLY_BUFFERED_REFRESH) ? c_szBufferedRefresh : c_szRefreshDesktop), SMTO_NORMAL, SENDMESSAGE_TIMEOUT, &pdwTemp);
            }
        }

        _fUseDynamicHtml = TRUE;
    }

    //
    // Data is no longer dirty.
    //
    _fDirty = FALSE;
    _fWallpaperDirty = FALSE;
    _fWallpaperChangedDuringInit = FALSE;
    _fPatternDirty = FALSE;

    EXITPROC(2, "DS SaveSettings!");
}

ULONG CActiveDesktop::AddRef(void)
{
    ENTERPROC(1, "DS AddRef()");

    _cRef++;

    EXITPROC(1, "DS AddRef=%d", _cRef);
    return _cRef;
}

// pwzPath: The path where the temp files go (%userprofile%/windows)
// pszFile: The original file name ("Joe's Vacation Picture.jpg")
// pszInUse: The wallpaper in use.
HRESULT _DeleteUnusedTempFiles(IN LPCWSTR pwzPath, IN LPCTSTR pszFile)
{
    TCHAR szTemplate[MAX_PATH];
    WIN32_FIND_DATA findFileData;
    LPCTSTR pszFileName = PathFindFileName(pszFile);

    HRESULT hr = StringCchPrintf(szTemplate, ARRAYSIZE(szTemplate), TEXT("%ls\\Wallpaper*.bmp"), pwzPath);
    if (SUCCEEDED(hr))
    {
        HANDLE hFindFile = FindFirstFile(szTemplate, &findFileData);

        if (INVALID_HANDLE_VALUE != hFindFile)
        {
            do
            {
                // Is this an old template? (Different name than we are currently using?
                // Also, don't delete the wallpaper that is in use.
                if (StrCmpI(findFileData.cFileName, pszFileName))
                {
                    DeleteFile(szTemplate); // Yes so delete it.
                }
            }
            while (FindNextFile(hFindFile, &findFileData));

            FindClose(hFindFile);
        }
    }

    return hr;
}


// nIndex: The file to try.
// pszInUse: This is the file we should skip because it's in use.
// pwzPath: On the way in, this is the selected wallpaper to convert.
//          On the way out, this is is the converted file.
HRESULT _ConvertToTempFile(IN int nIndex, IN LPCWSTR pwzTempPath, IN LPTSTR pwzPath, IN int cchSize)
{
    HRESULT hr = E_FAIL;
    WCHAR wzNewFile[MAX_PATH];
    LPCWSTR pszFileName = PathFindFileName(pwzPath);

    if (pszFileName)
    {
        hr = StringCchPrintf(wzNewFile, ARRAYSIZE(wzNewFile), L"%s\\Wallpaper%d.bmp", pwzTempPath, nIndex);
        if (SUCCEEDED(hr))
        {
            hr = SHConvertGraphicsFile(pwzPath, wzNewFile, SHCGF_REPLACEFILE);

            // This may fail for one of many reasons, and we just fall back to the old behavior if it fails.
            // This may fail if they don't have write permission of the disk, run out of disk space, or
            // this is a file type that we don't support.
            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(pwzPath, cchSize, wzNewFile);
            }
        }
    }

    return hr;
}


// pszFile: On the way in, this will contain the full path to the original file.
//          On the way out, if we succeed, it will be modified to the temp file
//          that is the converted equivalent of the file on the way in.
HRESULT CActiveDesktop::_ConvertFileToTempBitmap(IN LPWSTR pszFile, IN int cchSize)
{
    HRESULT hr = E_FAIL;
    WCHAR wzPath[MAX_PATH];

    if (S_OK == SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, NULL, SHGFP_TYPE_CURRENT, wzPath) &&
        PathAppend(wzPath, TEXT("Microsoft")))
    {
        CreateDirectoryW(wzPath, NULL);

        // Let's try the modified names to come up with something we can use.
        for (int nIndex = 1; FAILED(hr) && (nIndex < 100); nIndex++)
        {
            hr = _ConvertToTempFile(nIndex, wzPath, pszFile, cchSize);
        }

        if (SUCCEEDED(hr))
        {
            _DeleteUnusedTempFiles(wzPath, pszFile);
        }
    }

    return hr;
}

#define SZ_REGKEY_CONTROLPANEL_DESKTOP      TEXT("Control Panel\\Desktop")
#define SZ_REGVALUE_CONVERTED_WALLPAPER     TEXT("ConvertedWallpaper")
#define SZ_REGVALUE_ORIGINAL_WALLPAPER      TEXT("OriginalWallpaper")               // We store this to find when someone changed the wallpaper around us
#define SZ_REGVALUE_WALLPAPER               TEXT("Wallpaper")
#define SZ_REGVALUE_CONVERTED_WP_LASTWRITE  TEXT("ConvertedWallpaper Last WriteTime")

HRESULT CActiveDesktop::_SaveTempWallpaperSettings(void)
{
    HRESULT hr = E_FAIL;

    // When we converted a non-.BMP wallpaper to a .bmp temp file,
    // we keep the name of the original wallpaper path stored in _szSelectedWallpaper.
    // We need to save that.
    if (_szSelectedWallpaper)
    {
        hr = S_OK;

        DWORD cbSize = sizeof(_szSelectedWallpaper[0]) * (lstrlen(_szSelectedWallpaper) + 1);

        Str_SetPtr(&_pszOrigLastApplied, _szSelectedWallpaper);

        // ISSUE: CONVERTED and ORIGINAL are backwards, but we shipped beta1 like this so we can't change it... blech
        DWORD dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WALLPAPER, REG_SZ, _szSelectedWallpaper, cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            Str_SetPtrW(&_pszWallpaperInUse, _szSelectedWallpaper);
            cbSize = sizeof(_szSelectedWallpaperConverted[0]) * (lstrlen(_szSelectedWallpaperConverted) + 1);

            Str_SetPtr(&_pszOrigLastApplied, _szSelectedWallpaper);

            dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_ORIGINAL_WALLPAPER, REG_SZ, (void *) _szSelectedWallpaperConverted, cbSize);
            hr = HRESULT_FROM_WIN32(dwError);

            if (SUCCEEDED(hr)) 
            {
                dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_WALLPAPER, REG_SZ, (void *) _szSelectedWallpaperConverted, cbSize);
                hr = HRESULT_FROM_WIN32(dwError);
            }

            // Set date/time stamp of the original file (_szSelectedWallpaper) so we can later determine if the user changed the original.
            if (_szSelectedWallpaper[0])
            {
                HANDLE hFile = CreateFile(_szSelectedWallpaper, GENERIC_READ, (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE), 
                                          NULL, OPEN_EXISTING, 0, NULL);

                if (INVALID_HANDLE_VALUE != hFile)
                {
                    if (GetFileTime(hFile, NULL, NULL, &_ftLastWrite))
                    {
                        dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_CONTROLPANEL_DESKTOP, SZ_REGVALUE_CONVERTED_WP_LASTWRITE, REG_BINARY, &_ftLastWrite, sizeof(_ftLastWrite));
                        hr = HRESULT_FROM_WIN32(dwError);
                    }

                    CloseHandle(hFile);
                }
            }
            else
            {
                ULARGE_INTEGER * puli = (ULARGE_INTEGER *) &_ftLastWrite;
                puli->QuadPart = 0;
            }
        }
    }

    return hr;
}

HRESULT CActiveDesktop::ApplyChanges(DWORD dwFlags)
{
    HRESULT hres = S_OK;
    ENTERPROC(1, "DS Apply(dwFlags=%08X)", dwFlags);

    BOOL fActiveDesktop = FALSE; // default to disable active desktop

    // determine if we should enable active desktop
    if (SHRestricted(REST_FORCEACTIVEDESKTOPON))
    {
        // if policy requires active desktop, then use that
        fActiveDesktop = TRUE;
    }
    else
    {
        // if desktop components are locked -> active desktop is on
        DWORD dwDesktopFlags = GetDesktopFlags();
        if (dwDesktopFlags & COMPONENTS_LOCKED)
        {        
            fActiveDesktop = TRUE;
        } 
        else
        {        
            // if desktop icons are hidden -> active desktop is on
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_HIDEICONS, FALSE);
            if (ss.fHideIcons)
            {
                fActiveDesktop = TRUE;
            }
        }
    }

    // Convert the background if needed.
    // if background is not a .bmp --> active desktop is on if we can't auto-convert
    if (!IsNormalWallpaper(_szSelectedWallpaper))
    {
        BOOL fBitmapWallpaper = FALSE;
        
        // create the factory
        
        IShellImageDataFactory* pImgFact;
        
        hres = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, 
                                IID_PPV_ARG(IShellImageDataFactory, &pImgFact));
        if (SUCCEEDED(hres))
        {
            IShellImageData * pImage;

            hres = pImgFact->CreateImageFromFile(_szSelectedWallpaper, &pImage);
            if (SUCCEEDED(hres))
            {
                // PERF: cache decoded data
                hres = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
                if (SUCCEEDED(hres))
                {
                    if (S_FALSE == pImage->IsTransparent() &&
                        S_FALSE == pImage->IsAnimated())
                    {
                        hres = StringCchCopy(_szSelectedWallpaperConverted, ARRAYSIZE(_szSelectedWallpaperConverted), _szSelectedWallpaper);
                        if (SUCCEEDED(hres))
                        {
                            HRESULT hrConvert = _ConvertFileToTempBitmap(_szSelectedWallpaperConverted, ARRAYSIZE(_szSelectedWallpaperConverted));
                            if (SUCCEEDED(hrConvert))
                            {
                                if (S_OK == hrConvert) // if we actually had to convert (we may have already done the conversion)
                                {
                                    _fDirty = TRUE; // if we converted, then we have changed the background and must persist it
                                    _SaveTempWallpaperSettings();
                                    hres = StringCchCopy(_szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper), _szSelectedWallpaperConverted);
                                }
                                fBitmapWallpaper = TRUE;                                        
                            }
                        }
                    }
                }
                pImage->Release();
            }
            pImgFact->Release();
        }

        if (!fBitmapWallpaper)
        {
            fActiveDesktop = TRUE;
        }
    }

    if (!fActiveDesktop)
    {
        // if any elements are checked --> active desktop is on
        if (_hdsaComponent)
        {
            INT cComponents = DSA_GetItemCount(_hdsaComponent);
            for (INT i = 0; i < cComponents; i++)
            {
                COMPONENTA* pComponent = (COMPONENTA*)DSA_GetItemPtr(_hdsaComponent, i);
                if (pComponent && pComponent->fChecked)
                {
                    fActiveDesktop = TRUE;
                    break;
                }                        
            }
        }
    }

    if (_co.fActiveDesktop != fActiveDesktop)
    {
        _co.fActiveDesktop = fActiveDesktop;
        _fDirty = TRUE;
    }

    if (dwFlags & AD_APPLY_FORCE)
    {
        _fDirty = TRUE;
        _fWallpaperDirty = TRUE;
        _fPatternDirty = TRUE;
    }

    if (_fDirty || _fWallpaperChangedDuringInit)
    {
        _SaveSettings(dwFlags);
    }

    EXITPROC(1, "DS ApplyChanges=%d", hres);

    return S_OK;
}

ULONG CActiveDesktop::Release(void)
{
    UINT nRet = --_cRef;
    ENTERPROC(1, "DS Release()");

    if (_cRef == 0)
    {
        delete this;
    }

    EXITPROC(1, "DS Release=%d", nRet);
    return nRet;
}

CActiveDesktop::CActiveDesktop()
{
    _cRef = 1;
    _fNoDeskMovr = FALSE;
    _fBackgroundHtml = FALSE;
    _fUseDynamicHtml = TRUE;
    _hdsaComponent = NULL;
    _pszScheme = NULL;

    DllAddRef();
}

CActiveDesktop::~CActiveDesktop()
{
    if (_hdsaComponent)
    {
        DSA_Destroy(_hdsaComponent);
    }
    if (_pszScheme)
    {
        LocalFree((HANDLE)_pszScheme);
    }

    DllRelease();
}

HRESULT CActiveDesktop::GetWallpaper(LPWSTR pwszWallpaper, UINT cchWallpaper, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetWallpaper(pszWallpaper=%08X,cchWallpaper=%d)", pwszWallpaper, cchWallpaper);

    ASSERT(!dwReserved);     // These should be 0

    if (pwszWallpaper && cchWallpaper)
    {
        hres = StringCchCopy(pwszWallpaper, cchWallpaper, _szSelectedWallpaper);
        if (SUCCEEDED(hres))
        {
            if ( cchWallpaper < wcslen(_szSelectedWallpaper) )
            {
                hres = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_MORE_DATA );
            }
            else
            {
                hres = S_OK;
            }
        }
    }
    
    if (FAILED(hres))
    {
        TraceMsg(TF_WARNING, "DS GetWallpaper unable to return wallpaper");
    }

    EXITPROC(1, "DS GetWallpaper=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetWallpaper(LPCWSTR pwszWallpaper, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    WCHAR szTemp[MAX_PATH];

    ASSERT(!dwReserved);     // These should be 0

    if (_fPolicyForWPName)    // If a policy exists, the caller can not change the wallpaper.
        return S_FALSE;  
        
    if (pwszWallpaper)
    {
        hres = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pwszWallpaper);
        if (SUCCEEDED(hres))
        {
            hres = PathExpandEnvStringsWrap(szTemp, ARRAYSIZE(szTemp));    // We unexpand only when we persist.
            if (SUCCEEDED(hres))
            {
                if (lstrcmp(_szSelectedWallpaper, szTemp) != 0)
                {
                    hres = StringCchCopy(_szSelectedWallpaper, ARRAYSIZE(_szSelectedWallpaper), szTemp);
                    if (SUCCEEDED(hres))
                    {
                        _fWallpaperDirty = TRUE;
                        _fDirty = TRUE;
                        _fUseDynamicHtml = FALSE;  //Setting wallpaper causes a lot of change; So, can't use dynamic html
                    }
                }
            }
        }
    }
    ENTERPROC(1, "DS SetWallpaper(pszWallpaper=>%s<)", pwszWallpaper ? szTemp : TEXT("(NULL)"));

    EXITPROC(1, "DS SetWallpaper=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetWallpaperOptions(WALLPAPEROPT *pwpo, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetWallpaperOptions(pwpo=%08X)");

    ASSERT(!dwReserved);     // These should be 0

    if ((pwpo) && (pwpo->dwSize == sizeof(*pwpo)))
    {
        *pwpo = _wpo;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetWallpaperOptions could not return options");
    }

    EXITPROC(1, "DS GetWallpaperOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetWallpaperOptions(LPCWALLPAPEROPT pwpo, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS SetWallpaperOptions(pwpo=%08X)", pwpo);

    ASSERT(!dwReserved);     // These should be 0

    if (_fPolicyForWPStyle)  //If a policy exists for wallpaper style, the caller can not change it.
        return S_FALSE;
        

    if ((pwpo) && (pwpo->dwSize == sizeof(*pwpo)))
    {
        _wpo = *pwpo;
        _fWallpaperDirty = TRUE;
        _fDirty = TRUE;
        _fUseDynamicHtml = FALSE; //Changing wallpaper options causes us to regenerate the whole thing.
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS SetWallpaperOptions could not set options");
    }

    EXITPROC(1, "DS SetWallpaperOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetPattern(LPWSTR pwszPattern, UINT cchPattern, DWORD dwReserved)
{
    HRESULT hres;
    ENTERPROC(1, "DS GetPattern(psz=%08X,cch=%d)", pwszPattern, cchPattern);

    ASSERT(!dwReserved);     // These should be 0

    if (!pwszPattern || (cchPattern == 0))
    {
        hres = E_INVALIDARG;
    }
    else
    {
        hres = StringCchCopy(pwszPattern, cchPattern, _szSelectedPattern);
    }

    EXITPROC(1, "DS GetPattern=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetPattern(LPCWSTR pwszPattern, DWORD dwReserved)
{
    ENTERPROC(1, "DS SetPattern(psz=>%s<)", pwszPattern ? pwszPattern : TEXT("(NULL)"));

    HRESULT hres = E_INVALIDARG;

    ASSERT(!dwReserved);     // These should be 0

    if (pwszPattern)
    {
        if (lstrcmp(_szSelectedPattern, pwszPattern) != 0)
        {
            hres = StringCchCopy(_szSelectedPattern, ARRAYSIZE(_szSelectedPattern), pwszPattern);
            if (SUCCEEDED(hres))
            {
                _fPatternDirty = TRUE;
                _fDirty = TRUE;
                _fUseDynamicHtml = FALSE; //Setting pattern causes us to regenerate the whole thing.
            }
        }
        else
        {
            hres = E_FAIL;
        }
    }

    EXITPROC(1, "DS SetPattern=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::GetDesktopItemOptions(COMPONENTSOPT *pco, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS GetComponentsOptions(pco=%08X)", pco);

    ASSERT(!dwReserved);     // These should be 0

    if (pco && (pco->dwSize == sizeof(*pco)))
    {
        *pco = _co;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponentsOptions unable to return options");
    }

    EXITPROC(1, "DS GetComponentsOptions=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::SetDesktopItemOptions(LPCCOMPONENTSOPT pco, DWORD dwReserved)
{
    HRESULT hres = E_INVALIDARG;
    ENTERPROC(1, "DS SetComponentsOptions(pco=%08X)", pco);

    ASSERT(!dwReserved);     // These should be 0

    if (pco && (pco->dwSize == sizeof(*pco)))
    {
        _co = *pco;
        _fDirty = TRUE;
        hres = S_OK;
    }
    else
    {
        TraceMsg(TF_WARNING, "DS SetComponentsOptions unable to set options");
    }

    EXITPROC(1, "DS SetComponentsOptions=%d", hres);
    return hres;
}

//
// SetStateInfo()
//      This function simply sets up the COMPSTATEINFO structure passed using the current
// position and size from the COMPPOS structure and the itemState passed.
//
void SetStateInfo(COMPSTATEINFO *pCompStateInfo, COMPPOS *pCompPos, DWORD dwItemState)
{
    pCompStateInfo->dwSize   = sizeof(*pCompStateInfo);
    pCompStateInfo->iLeft    = pCompPos->iLeft;
    pCompStateInfo->iTop     = pCompPos->iTop;
    pCompStateInfo->dwWidth  = pCompPos->dwWidth;
    pCompStateInfo->dwHeight = pCompPos->dwHeight;
    pCompStateInfo->dwItemState = dwItemState;
}

void ConvertCompStruct(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, BOOL fPubToPriv)
{
    pCompDest -> dwID = pCompSrc -> dwID;
    pCompDest -> iComponentType = pCompSrc -> iComponentType;
    pCompDest -> fChecked = pCompSrc -> fChecked;
    pCompDest -> fDirty = pCompSrc -> fDirty;
    pCompDest -> fNoScroll = pCompSrc -> fNoScroll;
    pCompDest -> cpPos = pCompSrc -> cpPos;

    if (fPubToPriv)
    {
        COMPONENT *pComp = (COMPONENT *)pCompSrc;

        pCompDest->dwSize = sizeof(COMPONENTA);
        SHUnicodeToTChar(pComp->wszSource, pCompDest->szSource, ARRAYSIZE(pCompDest->szSource));
        SHUnicodeToTChar(pComp->wszFriendlyName, pCompDest->szFriendlyName, ARRAYSIZE(pCompDest->szFriendlyName));
        SHUnicodeToTChar(pComp->wszSubscribedURL, pCompDest->szSubscribedURL, ARRAYSIZE(pCompDest->szSubscribedURL));
        
        //Check to see if the public component is from IE4 app (old size)
        if (pCompSrc->dwSize == sizeof(COMPONENT))
        {
            // Since the dest component is the same size as the most current structure, all fields
            // are valid.
            // CAUTION: The following fields are at a different offset in public and private 
            // structures. So, you need to use pcomp instead of pCompSrc for example.
            pCompDest->dwCurItemState = pComp->dwCurItemState;
            pCompDest->csiOriginal = pComp->csiOriginal;
            pCompDest->csiRestored = pComp->csiRestored;
        }
        else
        {
            // Since the size did not match, we assume that this is an older structure.
            // Since the older struct does not have any Original and Restored sizes, let's copy 
            // the default values.
            IE4COMPONENT   *pIE4Comp = (IE4COMPONENT *)pCompSrc;
            pCompDest->dwCurItemState = IS_NORMAL;
            SetStateInfo(&pCompDest->csiOriginal, &pIE4Comp->cpPos, IS_NORMAL);
            SetStateInfo(&pCompDest->csiRestored, &pIE4Comp->cpPos, IS_NORMAL);
        }
    }
    else
    {
        COMPONENT *pComp = (COMPONENT *)pCompDest;
        
        if (pCompDest->dwSize != sizeof(COMPONENT))
            pCompDest->dwSize = sizeof(IE4COMPONENT);
        SHTCharToUnicode(pCompSrc->szSource, pComp->wszSource, ARRAYSIZE(pComp->wszSource));
        SHTCharToUnicode(pCompSrc->szFriendlyName, pComp->wszFriendlyName, ARRAYSIZE(pComp->wszFriendlyName));
        SHTCharToUnicode(pCompSrc->szSubscribedURL, pComp->wszSubscribedURL, ARRAYSIZE(pComp->wszSubscribedURL));
        
        //Check to see if the public component is from IE4 app (old size)
        if (pComp->dwSize == sizeof(COMPONENT))
        {
            // Since the dest component is the same size as the most current structure, all fields
            // are valid.
            // CAUTION: The following fields are at a different offset in public and private 
            // structures. So, you need to use pcomp instead of pCompDest for example.
            pComp->dwCurItemState = pCompSrc->dwCurItemState;
            pComp->csiOriginal = pCompSrc->csiOriginal;
            pComp->csiRestored = pCompSrc->csiRestored;
        }
        // else, the dest component is IE4COMPONENT and the additional fields are not there.
    }
}


HRESULT CActiveDesktop::_AddDTIWithUIPrivateA(HWND hwnd, LPCCOMPONENT pComp, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;
    PCWSTR pszUrl = pComp->wszSource;
    int nScheme = GetUrlScheme(pszUrl);
    DWORD dwCurItemState;
    if ((URL_SCHEME_INVALID == nScheme) || (URL_SCHEME_UNKNOWN == nScheme))
    {
        TCHAR szFullyQualified[INTERNET_MAX_URL_LENGTH];
        DWORD cchSize = ARRAYSIZE(szFullyQualified);

        if (SUCCEEDED(ParseURLFromOutsideSource(pszUrl, szFullyQualified, &cchSize, NULL)))
            nScheme = GetUrlScheme(szFullyQualified);
    }

    // Is this URL valid to subscribe to?  Did the caller specify they want use
    // to try to subscribe to it?
    if ((URL_SCHEME_FILE != nScheme) && (URL_SCHEME_ABOUT != nScheme) && 
        IsFlagSet(dwFlags, DTI_ADDUI_DISPSUBWIZARD) && hwnd)
    {
        //Create a subscription.
        hres = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, pszUrl, NULL, hwnd);
        if (hres != S_OK)
        {
            return hres;
        }
    }

    //
    // Add the component to the registry.
    //

    // PERF: This function creates a second COM objects.  
    //         We need to Inline the functionality.
    if (pComp->dwSize == sizeof(IE4COMPONENT))
        dwCurItemState = IS_NORMAL;
    else
        dwCurItemState = pComp->dwCurItemState;
    hres = AddRemoveDesktopComponentNoUI(TRUE, AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH, pszUrl, NULL, pComp->iComponentType, 
        pComp->cpPos.iLeft, pComp->cpPos.iTop, pComp->cpPos.dwWidth, pComp->cpPos.dwHeight, TRUE, dwCurItemState) ? S_OK : E_FAIL;

    return hres;
}



#define     STC_DESKTOPCOMPONENT    0x00000002
STDAPI SubscribeToCDF(HWND hwndParent, LPCWSTR pwzUrl, DWORD dwCDFTypes);

HRESULT CActiveDesktop::AddDesktopItemWithUI(HWND hwnd, LPCOMPONENT pComp, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp ||
       ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pComp->dwSize == sizeof(*pComp)) && !VALIDATESTATE(pComp->dwCurItemState)) ||
       ((pComp->iComponentType < 0) || (pComp->iComponentType > COMP_TYPE_MAX)))  //Validate the component type
        return E_INVALIDARG;

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if (SHIsRestricted(NULL, REST_NOADDDESKCOMP))
        return E_ACCESSDENIED;

    // Check if the component already exists.
    BOOL fCompExists = FALSE;
    int cComp;
    GetDesktopItemCount(&cComp, 0);
    int i;
    COMPONENT comp;
    comp.dwSize = sizeof(COMPONENT);  //This needs to be initialized for ConvertCompStruc to work!
    COMPONENTA compA;
    TCHAR   szSource[INTERNET_MAX_URL_LENGTH];
    SHUnicodeToTChar(pComp->wszSource, szSource, ARRAYSIZE(szSource));

    for (i=0; i<cComp && !fCompExists; i++)
    {
        compA.dwSize = sizeof(compA);
        if (GetComponentPrivate(i, &compA)
                && lstrcmpi(szSource, compA.szSource) == 0)
        {
            fCompExists = TRUE;
            ConvertCompStruct((COMPONENTA *)&comp, &compA, FALSE);
            break;
        }
    }

    BOOL fAskToInstall;
    if (ZoneCheckUrlW(pComp->wszSource, URLACTION_SHELL_INSTALL_DTITEMS, (PUAF_NOUI), NULL) == S_OK)
    {
        fAskToInstall = TRUE;
    }
    else
    {
        fAskToInstall = FALSE;
    }

    if (S_OK != ZoneCheckUrlW(pComp->wszSource, URLACTION_SHELL_INSTALL_DTITEMS, (hwnd ? (PUAF_FORCEUI_FOREGROUND | PUAF_WARN_IF_DENIED) : PUAF_NOUI), NULL))
        return E_ACCESSDENIED;

    BOOL fCompSubDeleted = FALSE;
    SUBSCRIPTIONINFO si = {sizeof(SUBSCRIPTIONINFO)};
    // si.bstrUserName = NULL;
    // si.bstrPassword = NULL;
    // si.bstrFriendlyName = NULL;
    //
    // Confirmation dialog.
    //
    if (hwnd)
    {
        if (fCompExists)
        {
            //Prompt the user to delete the existing ADI.
            // This is a long string. So,...
            TCHAR szMsg[512];
            TCHAR szMsg2[256];
            TCHAR szTitle[128];
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS, szMsg, ARRAYSIZE(szMsg));
            LoadString(HINST_THISDLL, IDS_COMP_EXISTS_2, szMsg2, ARRAYSIZE(szMsg2));
            StringCchCat(szMsg, ARRAYSIZE(szMsg), szMsg2); // truncation is fine, this is display text
            LoadString(HINST_THISDLL, IDS_COMP_TITLE, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hwnd, szMsg, szTitle, MB_OK);

            return E_FAIL;
        }
        else if (fAskToInstall)
        {
            if (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_CONFIRM_ADD), 
                                MAKEINTRESOURCE(IDS_INTERNET_EXPLORER), MB_YESNO) != IDYES)
            {
                return E_FAIL; //User choses not to install this desktop component!
            }
        }
    }

    hres = SubscribeToCDF(hwnd, pComp->wszSubscribedURL, STC_DESKTOPCOMPONENT);
    switch(hres)
    {
        case E_INVALIDARG:
        {
            // E_UNEXPECTED is returned from SubscribeToCDFUrlA() when the URL doesn't point to
            // a CDF file, so we assume it's a web page.

            hres = _AddDTIWithUIPrivateA(hwnd, pComp, dwFlags);
            if (hres != S_OK && fCompSubDeleted)    // Restore the old component
            {
                hres = AddDesktopItem(&comp, 0);
                if (SUCCEEDED(hres))
                {
                    ISubscriptionMgr *psm;
                    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                            CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, (void**)&psm)))
                    {
                        si.cbSize = sizeof(si);
                        psm->CreateSubscription(hwnd, comp.wszSubscribedURL, si.bstrFriendlyName, CREATESUBS_NOUI, SUBSTYPE_DESKTOPURL, &si);
                        psm->Release();
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "CActiveDesktop::AddDesktopItemWithUI : CoCreateInstance for CLSID_SubscriptionMgr failed.");
                    }
                }
            }
            ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
        }
        break;

        case E_ACCESSDENIED:
            // The file was a CDF but didn't contain Desktop Component Information
            if (hwnd)
            {
                TCHAR szMsg[MAX_PATH];
                TCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ADDCOMP_ERROR_CDFNODTI, szMsg, ARRAYSIZE(szMsg));
                LoadString(HINST_THISDLL, IDS_INTERNET_EXPLORER, szTitle, ARRAYSIZE(szTitle));
                MessageBox(hwnd, szMsg, szTitle, MB_OK);
            }
            break;
        case E_UNEXPECTED:      
            // This was a CDF but it was misauthored.
            if (hwnd)
            {
                TCHAR szMsg[MAX_PATH];
                TCHAR szTitle[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_ADDCOMP_ERROR_CDFINALID, szMsg, ARRAYSIZE(szMsg));
                LoadString(HINST_THISDLL, IDS_INTERNET_EXPLORER, szTitle, ARRAYSIZE(szTitle));
                MessageBox(hwnd, szMsg, szTitle, MB_OK);
            }
            break;
        default:
            break;
    }

    if (hwnd && SUCCEEDED(hres))
    {
        // If the active desktop is currently OFF, we need to turn it ON
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
        if (!ss.fDesktopHTML)
        {
            COMPONENTSOPT co;
            co.dwSize = sizeof(COMPONENTSOPT);
            GetDesktopItemOptions(&co, 0);
            co.fActiveDesktop = TRUE;
            SetDesktopItemOptions(&co, 0);
            ApplyChanges(AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH);
        }
    }

    if (fCompSubDeleted)
    {
        if (si.bstrUserName)
        {
            SysFreeString(si.bstrUserName);
        }
        if (si.bstrPassword)
        {
            SysFreeString(si.bstrPassword);
        }
        if (si.bstrFriendlyName)
        {
            SysFreeString(si.bstrFriendlyName);
        }
    }
    return hres;
}

void RestoreComponent(HDSA hdsaComponents, COMPONENTA * pcomp)
{
    int i;

    // If we are split then set the bit saying that the listview needs to be adjusted.  This is done
    // when we check the state of desktop.htm in EnsureUpdateHtml.
    //  Note: Do this only if this component is enabled.
    if ((pcomp->dwCurItemState & IS_SPLIT) && (pcomp->fChecked))
    {
        pcomp->dwCurItemState |= IS_ADJUSTLISTVIEW;
        SetDesktopFlags(COMPONENTS_ZOOMDIRTY, COMPONENTS_ZOOMDIRTY);
    }

    for (i = 0; i < DSA_GetItemCount(hdsaComponents); i++)
    {
        COMPONENTA * pcompT;
    
        if (pcompT = (COMPONENTA *)DSA_GetItemPtr(hdsaComponents, i))
        {
            // If this component is split/fullscreen and is different from the source component
            // but it is at the same location then it must be on this monitor (work area) so restore it.
            if (ISZOOMED(pcompT) &&
                lstrcmpi(pcomp->szSource, pcompT->szSource) &&
                (pcomp->cpPos.iTop  == pcompT->cpPos.iTop) &&
                ((pcomp->cpPos.iLeft + pcomp->cpPos.dwWidth) == (pcompT->cpPos.iLeft + pcompT->cpPos.dwWidth)))
                {
                    pcompT->dwCurItemState = pcompT->csiRestored.dwItemState;
                    pcompT->cpPos.iLeft = pcompT->csiRestored.iLeft;
                    pcompT->cpPos.iTop = pcompT->csiRestored.iTop;
                    pcompT->cpPos.dwWidth = pcompT->csiRestored.dwWidth;
                    pcompT->cpPos.dwHeight = pcompT->csiRestored.dwHeight;
                    pcompT->cpPos.izIndex = COMPONENT_TOP;
                    pcompT->fDirty = TRUE;
                    break;
                }
        }
    }
}

HRESULT CActiveDesktop::AddDesktopItem(LPCCOMPONENT pComp, DWORD dwReserved)
{
    HRESULT     hres = E_FAIL;
    COMPONENTA  CompA;
    CompA.dwSize = sizeof(CompA);

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp ||
       ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))) ||
       ((pComp->dwSize == sizeof(*pComp)) && !VALIDATESTATE(pComp->dwCurItemState)))
        return E_INVALIDARG;

    // Catch folks that call our API's to add components and prevent them from doing
    // so if the restriction is in place.
    if ((!_fIgnoreAddRemovePolicies) && (SHIsRestricted(NULL, REST_NOADDDESKCOMP)))
        return E_ACCESSDENIED;

    // Convert the external structure to the internal format
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);
 
    // If the component is already present, then fail the call!
    if (_FindComponentBySource(CompA.szSource, &CompA) > -1) 
        return hres;

    //Make sure that the COMPPOS size field is set before we add it!
    CompA.cpPos.dwSize = sizeof(COMPPOS);

    PositionComponent(&CompA, &CompA.cpPos, CompA.iComponentType, TRUE);

    if (_hdsaComponent && ISZOOMED(&CompA))
        RestoreComponent(_hdsaComponent, &CompA);

    //Make sure the this component's fDirty flag is off.
    CompA.fDirty = FALSE;

    // Set the dummy bit here - this forces folks to do bitwise testing on the dwCurItemState field
    // instead of testing for equality.  This will allow us to expand use of the field down the
    // road without compatibility problems.
    CompA.dwCurItemState |= IS_INTERNALDUMMYBIT;

    if (AddComponentPrivate(&CompA, _dwNextID++))
    {
        // It might be cheaper to attempt to insert the component in the
        // correct z-order but it's less code to just call _SortAndRationalize
        // after the insertion is done.
        _SortAndRationalize();
        hres = S_OK;
    }

    return(hres);
}

BOOL CActiveDesktop::AddComponentPrivate(COMPONENTA *pcomp, DWORD dwID)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS AddComponent(pcomp=%08X)", pcomp);

    if (pcomp)
    {
        if (_hdsaComponent == NULL)
        {
            _hdsaComponent = DSA_Create(sizeof(COMPONENTA), DXA_GROWTH_CONST);
        }

        if (_hdsaComponent)
        {
            pcomp->dwID = dwID;

            if (DSA_AppendItem(_hdsaComponent, pcomp) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS AddComponent unable to append DSA");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS AddComponent unable to create DSA");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS AddComponent unable to add a component");
    }

    EXITPROC(1, "DS AddComponent=%d", fRet);
    return fRet;
}

//
// This finds out if a given component already exists by comparing the szSource
// If so, it fills out the correct dwID and returns the index.
//
int CActiveDesktop::_FindComponentBySource(LPTSTR lpszSource, COMPONENTA *pComp)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentIdBySource(pComp=%8X)", pComp);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                if (!lstrcmpi(comp.szSource, lpszSource))
                {
                    *pComp = comp;
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentIndexByID unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponentIdBySource=%d", iRet);
    return iRet;
}

int CActiveDesktop::_FindComponentIndexByID(DWORD dwID)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentIndexByID(dwID=%d)", dwID);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                if (comp.dwID == dwID)
                {
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentIndexByID unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponent=%d", iRet);
    return iRet;
}


//
// This function is to be used only in special situations. Given a Url, it finds a component
// that has the src= pointed to that url. Note that what we have is szSource is something like
// "c:\foo\bar.bmp"; But, what is passed to this function is "file://c:/foo/bar.htm"
//
// Warning: This function does a conversion from Path to Url for every component before
// comparing with the given Url. This is in-efficient. We do it this way because converting
// the given Url ,which was converted to url from path, back to Path may not result in the 
// original path. In other words a round-trip from path to Url and back to path may not result
// in the path that was originally entered by the end-user.
//
int CActiveDesktop::_FindComponentBySrcUrl(LPTSTR lpszSrcUrl, COMPONENTA *pComp)
{
    int iRet = -1;
    ENTERPROC(2, "DS FindComponentBySrcUrl(pComp=%8X)", pComp);

    if (_hdsaComponent)
    {
        int i;

        for (i=0; i<DSA_GetItemCount(_hdsaComponent); i++)
        {
            COMPONENTA comp;
            comp.dwSize = sizeof(COMPONENTA);

            if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
            {
                TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
                LPTSTR  lpszUrl = szUrl;
                DWORD   dwSize;

                //Convert the szSource to Url
                dwSize = ARRAYSIZE(szUrl);
                
                if (FAILED(UrlCreateFromPath(comp.szSource, lpszUrl, &dwSize, 0)))
                    lpszUrl = comp.szSource;
                    
                if (!lstrcmpi(lpszUrl, lpszSrcUrl))
                {
                    *pComp = comp;
                    iRet = i;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "DS FindComponentBySrcUrl unable to get a component");
            }
        }
    }

    EXITPROC(2, "DS FindComponentBySrcUrl=%d", iRet);
    return iRet;
}

HRESULT CActiveDesktop:: GetDesktopItemByID(ULONG_PTR dwID, COMPONENT *pcomp, DWORD dwReserved)
{
    HRESULT hres = E_FAIL;
    ENTERPROC(1, "DS GetComponentByID(dwID=%d,pcomp=%08X)", dwID, pcomp);
    COMPONENTA  CompA;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pcomp || ((pcomp->dwSize != sizeof(*pcomp)) && (pcomp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    if (pcomp)
    {
        int index = _FindComponentIndexByID((DWORD)dwID);
        if (index != -1)
        {
            if (DSA_GetItem(_hdsaComponent, index, &CompA) != -1)
            {
                hres = S_OK;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS GetComponentByID unable to get component");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS GetComponentByID unable to find component");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponentByID given NULL pcomp");
    }

    if (SUCCEEDED(hres))
    {
        MultiCompToWideComp(&CompA, pcomp);
    }

    EXITPROC(1, "DS GetComponentByID=%d", hres);
    return hres;
}

HRESULT CActiveDesktop::RemoveDesktopItem(LPCCOMPONENT pComp, DWORD dwReserved)
{
    COMPONENTA  CompA, CompToDelete;
    int         iIndex;
    HRESULT     hres = E_FAIL;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(CompA);
    CompToDelete.dwSize = sizeof(CompToDelete);

    //Convert the struct to internal struct.
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);

    // See if the component already exists.
    iIndex = _FindComponentBySource(CompA.szSource, &CompToDelete);

    if (iIndex > -1)
    {
        if (RemoveComponentPrivate(iIndex, &CompToDelete))
        {
            hres = S_OK;
        }
    }

    return(hres);
}

BOOL CActiveDesktop::RemoveComponentPrivate(int iIndex, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS RemoveComponent(pcomp=%08X)", pcomp);

    if (_hdsaComponent)
    {
        if (iIndex == -1)
            iIndex = _FindComponentIndexByID(pcomp->dwID);
        if (iIndex != -1)
        {
            if (DSA_DeleteItem(_hdsaComponent, iIndex) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS RemoveComponent could not remove an item");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS RemoveComponent could not find item to remove");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS RemoveComponent has no components to remove");
    }

    EXITPROC(1, "DS RemoveComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::_CopyComponent(COMPONENTA *pCompDest, COMPONENTA *pCompSrc, DWORD dwFlags)
{
    HRESULT hrTemp, hr = S_OK;

    //Copy only those elements mentioned in the flag!

//    if (dwFlags & COMP_ELEM_ID)
//        pCompDest->dwID = pCompSrc->dwID;
    if (dwFlags & COMP_ELEM_TYPE)
        pCompDest-> iComponentType = pCompSrc->iComponentType;
    if (dwFlags & COMP_ELEM_CHECKED)
        pCompDest-> fChecked = pCompSrc->fChecked;
    if (dwFlags & COMP_ELEM_DIRTY)
        pCompDest-> fDirty = pCompSrc-> fDirty;
    if (dwFlags & COMP_ELEM_NOSCROLL)
        pCompDest-> fNoScroll = pCompSrc-> fNoScroll;
    if (dwFlags & COMP_ELEM_POS_LEFT)
        pCompDest-> cpPos.iLeft= pCompSrc->cpPos.iLeft;
    if (dwFlags & COMP_ELEM_POS_TOP)
        pCompDest-> cpPos.iTop= pCompSrc->cpPos.iTop;
    if (dwFlags & COMP_ELEM_SIZE_WIDTH)
        pCompDest-> cpPos.dwWidth= pCompSrc->cpPos.dwWidth;
    if (dwFlags & COMP_ELEM_SIZE_HEIGHT)
        pCompDest-> cpPos.dwHeight= pCompSrc->cpPos.dwHeight;
    if (dwFlags & COMP_ELEM_POS_ZINDEX)
        pCompDest-> cpPos.izIndex= pCompSrc->cpPos.izIndex;
    
    if (dwFlags & COMP_ELEM_SOURCE)
    {
        hrTemp = StringCchCopy(pCompDest->szSource, ARRAYSIZE(pCompDest->szSource), pCompSrc->szSource);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    
    if (dwFlags & COMP_ELEM_FRIENDLYNAME)        
    {
        hrTemp = StringCchCopy(pCompDest->szFriendlyName, ARRAYSIZE(pCompDest->szFriendlyName), pCompSrc->szFriendlyName);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }

    if (dwFlags & COMP_ELEM_SUBSCRIBEDURL)
    {
        hrTemp = StringCchCopy(pCompDest->szSubscribedURL, ARRAYSIZE(pCompDest->szSubscribedURL), pCompSrc->szSubscribedURL);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    
    if (dwFlags & COMP_ELEM_ORIGINAL_CSI)
        pCompDest->csiOriginal = pCompSrc->csiOriginal;
    
    if (dwFlags & COMP_ELEM_RESTORED_CSI)
    {
        pCompDest->csiRestored = pCompSrc->csiRestored;

//  98/08/21 vtan #174542: When changing csiRestored using the Active
//  Desktop API and the component is zoomed the csiRestored information
//  needs to be copied to the cpPos field as well as this is where the
//  actual information is stored when the component is restored. This
//  is only applicable to the case when the component is zoomed.

        if (ISZOOMED(pCompDest))
        {
            pCompDest->cpPos.iLeft = pCompSrc->csiRestored.iLeft;
            pCompDest->cpPos.iTop = pCompSrc->csiRestored.iTop;
            pCompDest->cpPos.dwWidth = pCompSrc->csiRestored.dwWidth;
            pCompDest->cpPos.dwHeight = pCompSrc->csiRestored.dwHeight;
        }
    }
    if (dwFlags & COMP_ELEM_CURITEMSTATE)  // Only allow the modification of the public bits - propagate the internal bits unchanged.
        pCompDest->dwCurItemState = (pCompDest->dwCurItemState & IS_VALIDINTERNALBITS) | (pCompSrc->dwCurItemState & ~IS_VALIDINTERNALBITS);

    return hr;
}

HRESULT CActiveDesktop::GetDesktopItemBySource(LPCWSTR lpcwszSource, LPCOMPONENT pComp, DWORD dwFlags)
{
    COMPONENTA CompNew; 
    HRESULT   hres = E_FAIL;
    int       iIndex;

    //Passing a NULL to SHUnicodeToTChar causes a fault. So, let's fail it.
    if (lpcwszSource == NULL)
        return E_INVALIDARG;
        
    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompNew.dwSize = sizeof(COMPONENTA);

    SHUnicodeToTChar(lpcwszSource, CompNew.szSource, ARRAYSIZE(CompNew.szSource));

    iIndex = _FindComponentBySource(CompNew.szSource, &CompNew);

    if (iIndex > -1)
    {
        MultiCompToWideComp(&CompNew, pComp);
        hres = S_OK;
    }

    return(hres);
}

HRESULT CActiveDesktop::ModifyDesktopItem(LPCCOMPONENT pComp, DWORD dwFlags)
{
    COMPONENTA  CompA, CompNew;
    HRESULT     hres = E_FAIL;
    int         iIndex = -1;

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if (!pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(COMPONENTA);
    CompNew.dwSize = sizeof(COMPONENTA);

    //Convert public param structure to private param structure.
    ConvertCompStruct(&CompA, (COMPONENTA *)pComp, TRUE);

    //See if this component already exists.
    iIndex = _FindComponentBySource(CompA.szSource, &CompNew);
    if (iIndex > -1)
    {
        hres = _CopyComponent(&CompNew, &CompA, dwFlags);
        if (SUCCEEDED(hres))
        {
            if (dwFlags & (COMP_ELEM_POS_LEFT | COMP_ELEM_POS_TOP | COMP_ELEM_SIZE_WIDTH | COMP_ELEM_SIZE_HEIGHT | COMP_ELEM_CHECKED | COMP_ELEM_CURITEMSTATE))
                PositionComponent(&CompNew, &CompNew.cpPos, CompNew.iComponentType, FALSE);
            if (ISZOOMED(&CompNew))
                RestoreComponent(_hdsaComponent, &CompNew);

            CompNew.fDirty = TRUE; //Since the component is modified, we set the dirty bit!
            if (UpdateComponentPrivate(iIndex, &CompNew))
                hres = S_OK;
        }
    }

    return(hres);
}

BOOL CActiveDesktop::UpdateComponentPrivate(int iIndex, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS UpdateComponentPrivate(pcomp=%08X)", pcomp);

    if (_hdsaComponent)
    {
        if (iIndex == -1)
            iIndex = _FindComponentIndexByID(pcomp->dwID);

        if (iIndex != -1)
        {
            if (DSA_SetItem(_hdsaComponent, iIndex, pcomp) != -1)
            {
                _fDirty = TRUE;
                fRet = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "DS UpdateComponent could not update an item");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "DS UpdateComponent could not find item to update");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS UpdateComponent has no components to update");
    }

    EXITPROC(1, "DS UpdateComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::GetDesktopItemCount(LPINT lpiCount, DWORD dwReserved)
{
    if (!lpiCount)
        return (E_INVALIDARG);

    *lpiCount = 0;

    ENTERPROC(1, "DS GetComponentsCount()");

    ASSERT(!dwReserved);     // These should be 0

    if (_hdsaComponent)
    {
        *lpiCount = DSA_GetItemCount(_hdsaComponent);
    }

    EXITPROC(1, "DS GetComponentsCount=%d", *lpiCount);
    return S_OK;
}

HRESULT CActiveDesktop::GetDesktopItem(int nComponent, COMPONENT *pComp, DWORD dwReserved)
{
    COMPONENTA  CompA;

    ASSERT(!dwReserved);     // These should be 0

    // We need to support IE4 apps calling with the old component structure too!
    // We use the size field to detect IE4 v/s newer apps!
    if ((nComponent < 0) || !pComp || ((pComp->dwSize != sizeof(*pComp)) && (pComp->dwSize != sizeof(IE4COMPONENT))))
        return E_INVALIDARG;

    CompA.dwSize = sizeof(COMPONENTA);

    if (GetComponentPrivate(nComponent, &CompA))
    {
        //Convert the structure to the Public form.
        ConvertCompStruct((COMPONENTA *)pComp, &CompA, FALSE);
        return(S_OK);
    }
    else
        return(E_FAIL);
}

BOOL CActiveDesktop::GetComponentPrivate(int nComponent, COMPONENTA *pcomp)
{
    BOOL fRet = FALSE;
    ENTERPROC(1, "DS GetComponent(nComponent=%d,pcomp=%08X)", nComponent, pcomp);

    if (_hdsaComponent && pcomp && (nComponent < DSA_GetItemCount(_hdsaComponent)))
    {
        if (DSA_GetItem(_hdsaComponent, nComponent, pcomp) != -1)
        {
            fRet = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "DS GetComponent unable to get a component");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "DS GetComponent does not have a DSA");
    }

    EXITPROC(1, "DS GetComponent=%d", fRet);
    return fRet;
}

HRESULT CActiveDesktop::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IActiveDesktop))
    {
        *ppvObj = (IActiveDesktop *)this;
        _Initialize();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IActiveDesktop *)this;
    }
    else if (IsEqualIID(riid, IID_IActiveDesktopP))
    {
        *ppvObj = (IActiveDesktopP *)this;
    }
    else if (IsEqualIID(riid, IID_IADesktopP2))
    {
        *ppvObj = (IADesktopP2 *)this;
    }
    else if (IsEqualIID(riid, IID_IPropertyBag))
    {
        *ppvObj = (IPropertyBag *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// Helper function so that it's easy to create one internally
// Actually, it's not ver much help any more...
STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid)
{
    return CActiveDesktop_CreateInstance(NULL, riid, (void **)ppunk);
}

// Our class factory create instance code
STDAPI CActiveDesktop_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    TraceMsg(TF_DESKSTAT, "CActiveDesktop- CreateInstance");

    CActiveDesktop *pad = new CActiveDesktop();

    if (pad)
    {
        HRESULT hres = pad->QueryInterface(riid, ppvOut);
        pad->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}


#ifdef DEBUG

//
// FEATURE - Move g_dwDeskStatTrace into ccshell.ini to prevent recompiles.
//
DWORD g_dwDeskStatTrace = 2;
static DWORD g_dwIndent = 0;
static const TCHAR c_szDotDot[] = TEXT("..");

#define MAX_INDENTATION_VALUE    0x20

void EnterProcDS(DWORD dwTraceLevel, LPSTR pszFmt, ...)
{
    TCHAR szFmt[1000];
    va_list arglist;

    SHAnsiToTChar(pszFmt, szFmt, ARRAYSIZE(szFmt));
    if (dwTraceLevel <= g_dwDeskStatTrace)
    {
        TCHAR szOutput[1000];
        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StringCchCat(szOutput, ARRAYSIZE(szOutput), c_szDotDot); // truncation fine, this is debug spew
        }

        int cchOutput = lstrlen(szOutput);
        va_start(arglist, pszFmt);
        StringCchVPrintf(szOutput + cchOutput, ARRAYSIZE(szOutput) - cchOutput, szFmt, arglist); // truncation fine, this is debug spew
        va_end(arglist);

        TraceMsg(TF_DESKSTAT, "%s", szOutput);

        // We don't want this value to get out of hand because of 
        // unmatched Enter and Exit calls in functions (which will 
        // trash the stack).
        if (g_dwIndent < MAX_INDENTATION_VALUE)
            g_dwIndent++;
    }
}

void ExitProcDS(DWORD dwTraceLevel, LPSTR pszFmt, ...)
{
    TCHAR szFmt[1000];
    TCHAR szOutput[1000];
    va_list arglist;


    SHAnsiToTChar(pszFmt, szFmt, ARRAYSIZE(szFmt));
    if (dwTraceLevel <= g_dwDeskStatTrace)
    {
        //This can happen if the Enter and Exit procs are unmatched.
        if (g_dwIndent > 0)
            g_dwIndent--;

        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StringCchCat(szOutput, ARRAYSIZE(szOutput), c_szDotDot); // truncation fine, this is debug spew
        }

        int cchOutput = lstrlen(szOutput);
        va_start(arglist, pszFmt);
        StringCchVPrintf(szOutput + cchOutput, ARRAYSIZE(szOutput) - cchOutput, szFmt, arglist); // truncation fine, this is debug spew
        va_end(arglist);

        

        TraceMsg(TF_DESKSTAT, "%s", szOutput);
    }
}

#endif

/*************************************************************************
 *
 *  IActiveDesktopP methods and helper functions
 *
 *  IActiveDesktopP is a private interface used to implement helper
 *  functionality that is used internally by the various shell binaries.
 *
 *  Notes:
 *      Getting an interface to IActiveDesktopP does not initialize the state
 *  of the object such that member functions are able to call IActiveDesktop
 *  member functions.  This is so that it is a more lightweight implementation
 *  and also simplifies the implementation of SetScheme.  If a subsequent QI for
 *  IActiveDesktop is performed then it will initialize properly and any member
 *  function can then be called.
 *
 *************************************************************************/

//
// SetScheme
//
// Used to set the current scheme that the object will read and write to
// when it is initialized.  This method must be called before a subsequent
// QI to IActiveDesktop is made.
//
HRESULT CActiveDesktop::SetScheme(LPCWSTR pwszSchemeName, DWORD dwFlags)
{
    LPTSTR pszSchemeName, pszAlloc;
    int icch;

    // Can't set the local scheme after we've been initialized...we can fix this
    // later if necessary but for now it's simplest this way.
    if (_fInitialized && (dwFlags & SCHEME_LOCAL))
        return E_FAIL;

    // Sanity checks
    if (!pwszSchemeName || ((icch = lstrlenW(pwszSchemeName)) > MAX_PATH - 1))
        return E_INVALIDARG;

    pszSchemeName = (LPTSTR)pwszSchemeName;

    if (dwFlags & SCHEME_CREATE)
    {
        LONG lRet;
        HKEY hkey, hkey2;

        lRet = RegCreateKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME_LOCATION, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkey, NULL);
        if (ERROR_SUCCESS == lRet)
        {
            lRet = RegCreateKeyEx(hkey, pszSchemeName, 0, NULL, 0, KEY_WRITE, NULL, &hkey2, NULL);
            if (ERROR_SUCCESS == lRet)
            {
                RegCloseKey(hkey2);
            }
            RegCloseKey(hkey);
        }
        if (ERROR_SUCCESS != lRet)
        {
            return E_FAIL;
        }
    }

    if (dwFlags & SCHEME_LOCAL)
    {
        // The local case is easy - just copy the string to our local variable,
        // it will be used when IActiveDesktop is initialized.
        if (!(pszAlloc = (LPTSTR)LocalAlloc(LPTR, (icch + 1) * sizeof(TCHAR))))
            return E_OUTOFMEMORY;

        if (_pszScheme)
            LocalFree((HANDLE)_pszScheme);

        _pszScheme = pszAlloc;

        HRESULT hr = StringCchCopy(_pszScheme, icch + 1, pszSchemeName);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (dwFlags & SCHEME_GLOBAL)
    {
        // Update the registry with the new global scheme value
        if (dwFlags & SCHEME_DISPLAY)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY,
                        REG_SZ, pszSchemeName, CbFromCch(lstrlen(pszSchemeName) + 1));
        if (dwFlags & SCHEME_EDIT)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_EDIT,
                        REG_SZ, pszSchemeName, CbFromCch(lstrlen(pszSchemeName) + 1));
    }

    if (dwFlags & (SCHEME_REFRESH | SCHEME_UPDATE))
    {
        DWORD dwUpdateFlags = AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_SAVE;
        if (dwFlags & SCHEME_REFRESH)
            dwUpdateFlags |= (AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH);
        _Initialize();
        _fUseDynamicHtml=FALSE;  
        ApplyChanges(dwUpdateFlags);
    }

    return S_OK;
}


HRESULT GetGlobalScheme(LPWSTR pwszScheme, LPDWORD lpdwcchBuffer, DWORD dwFlags)
{
    DWORD cbScheme = *lpdwcchBuffer * sizeof(pwszScheme[0]);
    LONG lret = SHGetValueW(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME,
                    (dwFlags & SCHEME_EDIT) ? REG_VAL_SCHEME_EDIT : REG_VAL_SCHEME_DISPLAY, NULL,
                    pwszScheme, &cbScheme);
    
    if (ERROR_SUCCESS == lret)
    {
        *lpdwcchBuffer = lstrlenW(pwszScheme);
    }
    return (lret == ERROR_SUCCESS ? S_OK : E_FAIL);
}


//
// GetScheme
//
//
HRESULT CActiveDesktop::GetScheme(LPWSTR pwszSchemeName, LPDWORD lpdwcchBuffer, DWORD dwFlags)
{
    // Sanity checks
    if (!pwszSchemeName || *lpdwcchBuffer == 0)
        return E_INVALIDARG;

    if (dwFlags & SCHEME_LOCAL)
    {
        if (!_pszScheme)
        {
            HRESULT hres;
            // Special case if no local scheme has explicitly been selected yet.
            // The default scheme is the global display scheme in this case.
            if (SUCCEEDED(hres = GetGlobalScheme(pwszSchemeName, lpdwcchBuffer, SCHEME_DISPLAY)))
            {
                hres = SetScheme(pwszSchemeName, SCHEME_LOCAL);
            }
            return hres;
        }

        SHTCharToUnicode(_pszScheme, pwszSchemeName, *lpdwcchBuffer);
        
        *lpdwcchBuffer = lstrlenW(pwszSchemeName);
        return S_OK;
    }


    if (dwFlags & SCHEME_GLOBAL)
    {
        return GetGlobalScheme(pwszSchemeName, lpdwcchBuffer, dwFlags);
    }

    return E_INVALIDARG;
}

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *);
HRESULT CActiveDesktop::UpdateAllDesktopSubscriptions()
{
    ::UpdateAllDesktopSubscriptions(this);
    return S_OK;
}

void CActiveDesktop::_GenerateHtmlBStrForComp(COMPONENTA *pComp, BSTR *pbstr)
{
    ENTERPROC(2, "DS _GenerateHtmlBstrForComp");
    
    if (_pStream = SHCreateMemStream(NULL, 0)) //Create a mem stream.
    {
        LARGE_INTEGER libMove = {0};
        ULARGE_INTEGER libCurPos;
        // Since _pStream is setup, the following call will generate the component HTML into
        // that stream.
        _GenerateHtmlComponent(pComp);

        //Get the size of the stream generated.
        if (SUCCEEDED(_pStream->Seek(libMove, STREAM_SEEK_CUR, &libCurPos)))
        {
            //Allocare a BSTR big enough to hold our component HTML code.
            if (*pbstr = SysAllocStringLen(NULL, (libCurPos.LowPart)/sizeof(WCHAR)))
            {
                _pStream->Seek(libMove, STREAM_SEEK_SET, NULL);
                _pStream->Read(*pbstr, libCurPos.LowPart, NULL);
            }
        }

        //NOTE: The bStr is released by the caller.
        
        ATOMICRELEASE(_pStream);
    }
    else
        TraceMsg(TF_WARNING, "DS _GenerateHtmlBstrForComp unable to create a mem stream");
        
    EXITPROC(2, "DS _GenerateHtmlBstrForComp");
}


void CActiveDesktop::_UpdateStyleOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA)
{
    IHTMLStyle  *pHtmlStyle;
    
    if (SUCCEEDED(pElem->get_style(&pHtmlStyle)))
    {
        long    lPixelVal;
        VARIANT vVal;
        VARIANT vValNew;

        
        if (SUCCEEDED(pHtmlStyle->get_pixelLeft(&lPixelVal)) && (lPixelVal != lpCompA->cpPos.iLeft))
        {
            TraceMsg(TF_DYNAMICHTML, "iLeft changes from %d to %d", lPixelVal, lpCompA->cpPos.iLeft);
            pHtmlStyle->put_pixelLeft((long)(lpCompA->cpPos.iLeft));
        }
        
        if (SUCCEEDED(pHtmlStyle->get_pixelTop(&lPixelVal)) && (lPixelVal != lpCompA->cpPos.iTop))
        {
            TraceMsg(TF_DYNAMICHTML, "iTop changes from %d to %d", lPixelVal, lpCompA->cpPos.iTop);
            pHtmlStyle->put_pixelTop((long)(lpCompA->cpPos.iTop));
        }

        VariantInit(&vVal);
       
        if (SUCCEEDED(pHtmlStyle->get_width(&vVal))) //Get the width as BSTR to see if width attribute exists
        {
            //See if the width attribute exists now.
            if ((vVal.vt == VT_BSTR) && (vVal.bstrVal == NULL))
            {
                // Width attribute does not exist for this element; This means that
                // this element has the default width (may be a picture shown in it's original width).
                if (lpCompA->cpPos.dwWidth != COMPONENT_DEFAULT_WIDTH)
                {
                    //Component's new width is different from the default width. So, set the new width.
                    TraceMsg(TF_DYNAMICHTML, "dwWidth changes from default to %d", lpCompA->cpPos.dwWidth);
                    pHtmlStyle->put_pixelWidth((long)(lpCompA->cpPos.dwWidth));
                }
                //else, nothing to do! (the widths match exactly).
                
            }
            else
            {
                // Width attribute exists! That means that this element has a width other than the
                // default width.
                // See if the new width is the default width.
                if (lpCompA->cpPos.dwWidth == COMPONENT_DEFAULT_WIDTH)
                {
                    // The old width is NOT default; But, the new width is default. So, let's just
                    // remove the width attribute.
                    VariantInit(&vValNew);
                    vValNew.vt = VT_BSTR;
                    vValNew.bstrVal = NULL;
                    pHtmlStyle->put_width(vValNew);

                    VariantClear(&vValNew);
                }
                else
                {
                    //Get the existing width in pixels.
                    if (SUCCEEDED(pHtmlStyle->get_pixelWidth(&lPixelVal)) && (((DWORD)lPixelVal) != lpCompA->cpPos.dwWidth))
                    {
                        TraceMsg(TF_DYNAMICHTML, "dwWidth changes from %d to %d", lPixelVal, lpCompA->cpPos.dwWidth);
                        pHtmlStyle->put_pixelWidth((long)(lpCompA->cpPos.dwWidth));
                    }
                    //else, nothing else to do because the widths match!
                }
                
            }
            VariantClear(&vVal);
        }
        
        if (SUCCEEDED(pHtmlStyle->get_height(&vVal))) //Get the height as BSTR to see if height attribute exists
        {
            // See if the height attribute exists.
            if ((vVal.vt == VT_BSTR) && (vVal.bstrVal == NULL))
            {
                // Height attribute does not exist for this element; This means that
                // this element has the default height (may be a picture shown in it's original height).
                if (lpCompA->cpPos.dwHeight != COMPONENT_DEFAULT_HEIGHT)
                {
                    //Component's new height is different from the default height. So, set the new height.
                    TraceMsg(TF_DYNAMICHTML, "dwHeight changes from default to %d", lpCompA->cpPos.dwHeight);
                    pHtmlStyle->put_pixelHeight((long)(lpCompA->cpPos.dwHeight));
                }
                //else, nothing to do! (the heights match exactly).
                
            }
            else
            {
                // Height attribute exists! That means that this element has a height other than the
                // default height.
                // See if the new height is the default height.
                if (lpCompA->cpPos.dwHeight == COMPONENT_DEFAULT_HEIGHT)
                {
                    // The old height is NOT default; But, the new height is default. So, let's just
                    // remove the height attribute.
                    VariantInit(&vValNew);
                    vValNew.vt = VT_BSTR;
                    vValNew.bstrVal = NULL;
                    pHtmlStyle->put_height(vValNew);  //remove the height attribute!

                    VariantClear(&vValNew);
                }
                else
                {
                    //Get the existing height in pixels and see if it is different.
                    if (SUCCEEDED(pHtmlStyle->get_pixelHeight(&lPixelVal)) && (((DWORD)lPixelVal) != lpCompA->cpPos.dwHeight))
                    {
                        //Since the new height is different, let's use set the new height!
                        TraceMsg(TF_DYNAMICHTML, "dwHeight changes from %d to %d", lPixelVal, lpCompA->cpPos.dwHeight);
                        pHtmlStyle->put_pixelHeight((long)(lpCompA->cpPos.dwHeight));
                    }
                    //else, nothing else to do because the heights match!
                }
                
            }
            VariantClear(&vVal);
        }
        
        
        if (SUCCEEDED(pHtmlStyle->get_zIndex(&vVal)) && (vVal.vt == VT_I4) && (vVal.lVal != lpCompA->cpPos.izIndex))
        {
            TraceMsg(TF_DYNAMICHTML, "ZIndex changes from %d to %d", vVal.lVal, lpCompA->cpPos.izIndex);
            vVal.lVal = lpCompA->cpPos.izIndex;
            pHtmlStyle->put_zIndex(vVal);
        }
        
        VariantClear(&vVal);
        
        pHtmlStyle->Release();
    }

    //FEATURE: Should we check for and set the other attributes like "resizeable" etc.,?
}

BOOL  CActiveDesktop::_UpdateIdOfElement(IHTMLElement *pElem, LPCOMPONENTA lpCompA)
{
    BSTR    bstrId;
    BOOL    fWholeElementReplaced = FALSE;  //Assume that the item id does not change.
            
    //Check if the Id of the component and the element matches.
    if (SUCCEEDED(pElem->get_id(&bstrId)))   //get the old id
    {

        if (((DWORD)StrToIntW(bstrId)) != lpCompA->dwID)
        {
            // The following technic does not work in some versions of MSHTML.DLL
            // because IHTMLElement->put_id() does not work unless the doc
            // is in "design mode".
            TCHAR   szNewId[MAXID_LENGTH];
            BSTR    bstrNewId;
            HRESULT hr = StringCchPrintf(szNewId, ARRAYSIZE(szNewId), TEXT("%d"), lpCompA->dwID);
            if (SUCCEEDED(hr))
            {

#ifdef DEBUG
                {
                    TCHAR szOldId[MAXID_LENGTH];
                    if (SUCCEEDED(StringCchPrintf(szOldId, ARRAYSIZE(szOldId), TEXT("%d"), StrToIntW(bstrId))))
                    {
                        TraceMsg(TF_DYNAMICHTML, "DHTML: Id changes from %s to %s", szOldId, szNewId);
                    }
                }
#endif //DEBUG
                
            //The Ids do not match. So, let's set the new ID.
                
                if (bstrNewId = SysAllocStringT(szNewId))
                {
                    hr = pElem->put_id(bstrNewId);
                    SysFreeString(bstrNewId);
                }

                if (FAILED(hr))
                {
                    //Replace the whole element's HTML with the newly generated HTML
                    BSTR    bstrComp = 0;
            
                    _GenerateHtmlBStrForComp(lpCompA, &bstrComp);
                    if (bstrComp)
                    {
                        if (FAILED(hr = pElem->put_outerHTML(bstrComp)))
                            TraceMsg(TF_DYNAMICHTML, "DHTML: put_outerHTML failed");
                        fWholeElementReplaced = TRUE;
                        SysFreeString(bstrComp);
                    }
                    else
                    {
                        AssertMsg(FALSE, TEXT("DHTML: Unable to create html for comp"));
                    }
                }
            }
        }
        //else the ids match; nothing to do!
        SysFreeString(bstrId);      //free the old id.
    }
    else
    {
        AssertMsg(FALSE, TEXT("DS Unable to get the id of the element"));
    }

    return fWholeElementReplaced;
}

HRESULT CActiveDesktop::_UpdateHtmlElement(IHTMLElement *pElem)
{
    VARIANT vData;
    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR   szSrcPath[INTERNET_MAX_URL_LENGTH];
    LPTSTR  lpszSrcPath;
    COMPONENTA  CompA;
    int         iIndex;

    //If all components are disabled, then we nuke this component from HTML page.
    if (!_co.fEnableComponents)
    {
        TraceMsg(TF_DYNAMICHTML, "DHTML: No item shown in this mode; so, deleting items");
        pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);
        
        return S_OK; //Nothing else to do!
    }

    VariantInit(&vData);
    
    //First determine if the given element is currently a desktop item. (It could have been deleted)
    //Get the element's "src" attribute.
    if (FAILED(pElem->getAttribute((BSTR)s_sstrSRCMember.wsz, VARIANT_FALSE, &vData)) ||
            (vData.vt == VT_NULL) ||
            (vData.bstrVal == NULL))
    {
        //If the subscribed_url is not present, then it could be an object with a classid.
        if (FAILED(pElem->getAttribute((BSTR)s_sstrclassid.wsz, VARIANT_FALSE, &vData)) ||
            (vData.vt == VT_NULL))
        {
            //This element is does not have "src=" or "classid=" attributes. How did this ever
            // become a desktop item with "name=deskmovr" or "name=deskmovrw"?? Hmmmmmm....!!!
#ifdef DEBUG
            {
                BSTR    bstrHtmlForElem;
                // Get the HTML corresponding to the element that does not have a subscribed URL
                if (SUCCEEDED(pElem->get_outerHTML(&bstrHtmlForElem)))
                {
                    TraceMsg(TF_DYNAMICHTML, "DHTML: Rogue element: %s", bstrHtmlForElem);
                    SysFreeString(bstrHtmlForElem);
                }
            }
            TraceMsg(TF_WARNING, "DHTML: Unable to get the subscribed_url or classid");
#endif
            //Since this element does not seem to be a valid desktop item, let's nuke it!
            pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);  //delete this element.
            
            return (E_FAIL);  //Nothing else to for this element! It's gone!!! 
        }
        
        if ((vData.vt == VT_NULL) || (vData.bstrVal == NULL))
            return E_FAIL;
            
        ASSERT(vData.vt == VT_BSTR);
        ASSERT(StrCmpNW(vData.bstrVal, L"clsid:", lstrlen(TEXT("clsid:"))) == 0);
        SHUnicodeToTChar(vData.bstrVal + lstrlen(TEXT("clsid:")), szUrl, ARRAYSIZE(szUrl));
        lpszSrcPath = szUrl;  //For classid, the SrcPath and the Url are the same.
    }
    else
    {
        DWORD dwSize; 
        
        if (vData.bstrVal == NULL)
            return (E_FAIL);
            
        ASSERT(vData.vt == VT_BSTR);
        SHUnicodeToTChar(vData.bstrVal, szUrl, ARRAYSIZE(szUrl));

        dwSize = ARRAYSIZE(szSrcPath);
        lpszSrcPath = szSrcPath;
        if (FAILED(PathCreateFromUrl(szUrl, lpszSrcPath, &dwSize, 0)))
        {
            lpszSrcPath = szUrl;
        }
    }

    VariantClear(&vData); //We made a TCHAR copy above. So, ok to free this.

    CompA.dwSize = sizeof(CompA);

    // First use the Source path to Find the component; This is much more efficient because it
    // involves no conversion from Path to Url and vice-versa.
    if ((iIndex = _FindComponentBySource(lpszSrcPath, &CompA)) < 0)
    {
        // Could not find component using SrcPath!
        // Let's try using the SrcUrl; This is less efficient.
        iIndex = _FindComponentBySrcUrl(szUrl, &CompA);
    }
    
    if ((iIndex>= 0) && (CompA.fChecked))
    {
        //The component is found and it is enabled.
        TraceMsg(TF_DYNAMICHTML, "DHTML:Updating desktop item with URL: %s", szUrl);

        // If the id changes, we replace the whole HTML for that element, so, no need to check for
        // the individual styles.
        if (!_UpdateIdOfElement(pElem, &CompA))
            _UpdateStyleOfElement(pElem, &CompA);
        CompA.fDirty = TRUE; //Mark the component sothat we know that it had been updated.
        UpdateComponentPrivate(iIndex, &CompA);
    }
    else
    {
        ASSERT((iIndex == -1) || (!CompA.fChecked));  //Component not found OR it is disabled!

        TraceMsg(TF_DYNAMICHTML, "DHTML: Deleting desktop item with URL: %s, SrcPath:%s", szUrl, lpszSrcPath);

        //The component is not present now. So, delete this element from the html page.
        pElem->put_outerHTML((BSTR)s_sstrEmpty.wsz);
    }

    return S_OK;
}

//
// This code enumerates and then updates all the desktop item elements in the active desktop based 
// on the current status of the active desktop items in the CActiveDesktop object (The current 
// status is initialized by reading from the registry when ActiveDesktop object is initialized).
//
HRESULT CActiveDesktop::_UpdateDesktopItemHtmlElements(IHTMLDocument2 *pDoc)
{
    HRESULT hres = S_OK;
    
    IHTMLElementCollection  *pAllElements;

    TraceMsg(TF_DYNAMICHTML, "DHTML: Updating Desktop html elements dynamically");

    if (!_fInitialized)  //If not yet initialized, initialize now because we need _co.fEnableComponents.
        _Initialize();

    // We need to check for a change in the background color only if there is no wallpaper or
    // the wallpaper is a picture.
    if (IsWallpaperPicture(_szSelectedWallpaper))
    {
        COLORREF    rgbDesktop;
        TCHAR       szRgbDesktop[10];
        VARIANT     vColor;
        
        //Check to see if the background color has changed
        rgbDesktop = GetSysColor(COLOR_DESKTOP);

        hres = StringCchPrintf(szRgbDesktop, ARRAYSIZE(szRgbDesktop),
                               TEXT("#%02lx%02lx%02lx"), GetRValue(rgbDesktop), GetGValue(rgbDesktop), GetBValue(rgbDesktop));
        if (SUCCEEDED(hres))
        {
            hres = pDoc->get_bgColor(&vColor);
            if (SUCCEEDED(hres) && (vColor.vt == VT_BSTR))
            {
                BSTR    bstrNewBgColor = SysAllocStringT(szRgbDesktop);

                //Compare the new and the old strings.
                if (StrCmpW(vColor.bstrVal, bstrNewBgColor))
                {
                    BSTR bstrOldBgColor = vColor.bstrVal;  //Save the old bstr.
                    //So, the colors are different. Set the new color.
                    vColor.bstrVal = bstrNewBgColor;
                    bstrNewBgColor = bstrOldBgColor;   //Set it here sothat it is freed later.

                    if (FAILED(pDoc->put_bgColor(vColor)))
                    {
                        TraceMsg(TF_DYNAMICHTML, "DHTML: Unable to change the background color");
                    }
                }

                if (bstrNewBgColor)
                    SysFreeString(bstrNewBgColor);
        
                VariantClear(&vColor);
            }
        }
    }

    //Get a collection of All elements in the Document
    if (SUCCEEDED(hres))
    {
        hres = pDoc->get_all(&pAllElements);
        if (SUCCEEDED(hres))
        {
            VARIANT vName, vIndex;
            IDispatch   *pDisp;
            int     i; 
            long    lItemsEnumerated = 0;
            long    lLength = 0;


    #ifdef DEBUG
            pAllElements->get_length(&lLength);
            TraceMsg(TF_DYNAMICHTML, "DHTML: Length of All elements:%d", lLength);
    #endif

            for(i = 0; i <= 1; i++)
            {
                //Collect all the elements that have the name="DeskMovr" and then name="DeskMovrW"
                vName.vt = VT_BSTR;
                vName.bstrVal = (BSTR)((i == 0) ? s_sstrDeskMovr.wsz : s_sstrDeskMovrW.wsz);

                VariantInit(&vIndex); //We want to get all elements. So, vIndex is set to VT_EMPTY
        
                if (SUCCEEDED(pAllElements->item(vName, vIndex, &pDisp)) && pDisp) //Collect all elements we want
                {
                    IHTMLElementCollection  *pDeskCollection;
                    if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pDeskCollection)))
                    {
                        IUnknown    *pUnk;
                        IEnumVARIANT    *pEnumVar;
                
                        if (SUCCEEDED(pDeskCollection->get_length(&lLength)))  //Number of elements.
                            lItemsEnumerated += lLength; //Total number of items enumerated.

                        TraceMsg(TF_DYNAMICHTML, "DHTML: Enumerated %d number of elements", lLength);
                    
                        //Get the enumerator
                        if (SUCCEEDED(pDeskCollection->get__newEnum(&pUnk)))
                        {
                            if (SUCCEEDED(pUnk->QueryInterface(IID_IEnumVARIANT, (void **)&pEnumVar)))
                            {
                                VARIANT vElem;
                                long    lEnumCount = 0;
                                DWORD   cElementsFetched;
                        
                                while(SUCCEEDED(pEnumVar->Next(1, &vElem, &cElementsFetched)) && (cElementsFetched == 1))
                                {
                                    IHTMLElement *pElem;
                                    lEnumCount++;
                                    //  Access the element from the variant.....!
                                    if ((vElem.vt == VT_DISPATCH) && SUCCEEDED(vElem.pdispVal->QueryInterface(IID_IHTMLElement, (void **)&pElem)))
                                    {
                                        _UpdateHtmlElement(pElem); //Update the desktop element's attributes.
                                        pElem->Release();
                                    }
                                    VariantClear(&vElem);
                                }
                                //Number of items enumerated must be the same as the length
                                ASSERT(lEnumCount == lLength);
                            
                                pEnumVar->Release();
                            }
                            pUnk->Release();
                        }
                
                        pDeskCollection->Release();
                    }
                    else
                    {
                        IHTMLElement    *pElem;
                    
                        // The QI(IID_IHTMLElementCollection) has failed. It may be because only one item 
                        // was returned rather than a collection.
                        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElement, (void **)&pElem)))
                        {
                            _UpdateHtmlElement(pElem); //Update the desktop element's attributes.
                            pElem->Release();
                        }
                        else
                            TraceMsg(TF_WARNING, "DHTML: Unable to get a collection or a single element");
                    }
                    pDisp->Release();
                }
            } // for loop enumeating "DeskMovr" and "DeskMovrW" items.
        
            pAllElements->Release();
        }
    }

    // All the elements already present in the Doc have been updated. Now, let's add the
    // new elements, if any.
    if (_co.fEnableComponents)
        _InsertNewDesktopItems(pDoc);
    else
    {
        TraceMsg(TF_DYNAMICHTML, "DHTML: No components are to be shown in this mode;");
    }

    return hres;
}

HRESULT CActiveDesktop::_InsertNewDesktopItems(IHTMLDocument2  *pDoc)
{
    IHTMLElement    *pBody;
    
    if (SUCCEEDED(pDoc->get_body(&pBody)))
    {
        if (_hdsaComponent)
        {
            int i, iCount;

            iCount = DSA_GetItemCount(_hdsaComponent);
            for (i=0; i<iCount; i++)
            {
                COMPONENTA comp;
                comp.dwSize = sizeof(comp);

                if (DSA_GetItem(_hdsaComponent, i, &comp) != -1)
                {
                    //Check if this is a newly added component AND it is enabled.
                    if ((!comp.fDirty) && comp.fChecked)
                    {
                        TraceMsg(TF_DYNAMICHTML, "DHTML: Inserted comp: %s", comp.szSource);
                        
                        //Yup! This is a newly added component!
                        BSTR  bstrComp = 0;
                        //This is a new component. Generate the HTML for the component.
                        _GenerateHtmlBStrForComp(&comp, &bstrComp);

                        //Insert the component.
                        pBody->insertAdjacentHTML((BSTR)s_sstrBeforeEnd.wsz, (BSTR)bstrComp);

                        //Free the string.
                        SysFreeString(bstrComp);
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "DHTML: InsertNewComp: Unable to get component %d.", i);
                }
            }
        }
        
        pBody->Release();
    }

    return S_OK;
}

//
// This function takes a pointer to the ActiveDesktop's ole obj, reads all the changes to be done
// from the registry and makes those changes to the various elements through dynamic HTML interfaces.
//
HRESULT CActiveDesktop::MakeDynamicChanges(IOleObject *pOleObj)
{

    IHTMLDocument2  *pDoc;
    HRESULT         hres = E_FAIL;

    ENTERPROC(2, "MakeDynamicChanges");

    if (pOleObj && SUCCEEDED(pOleObj->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc)))
    {
        // Enumerate all the active desktop components and ensure they are up to date.
        _UpdateDesktopItemHtmlElements(pDoc);

        pDoc->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "DHTML: MakeDynamicChanges: Unable to get IHTMLDocument2");
    }
    
    EXITPROC(2, "MakeDynamicChanges");

    return(hres);
}

//
// SetSafeMode
//
// Either puts the active desktop in safemode or restores it to the previous
// scheme before safemode was entered.
//
HRESULT CActiveDesktop::SetSafeMode(DWORD dwFlags)
{
    //
    // Make sure we are in active desktop mode.
    //
    SHELLSTATE ss = {0};
    BOOL fSetSafeMode = (dwFlags & SSM_SET) != 0;

    SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
    if (ss.fDesktopHTML)
    {
        //
        // All we need to do is switch the "display" scheme to "safemode" in order to
        // go into safemode.  To go out, we just switch the "display" scheme back to the
        // previous "edit" scheme.
        //
        WCHAR wszEdit[MAX_PATH];
        WCHAR wszDisplay[MAX_PATH];
        DWORD dwcch = MAX_PATH;

        if (SUCCEEDED(GetScheme(wszEdit, &dwcch, SCHEME_GLOBAL | SCHEME_EDIT)))
        {
            dwcch = MAX_PATH;
            if (SUCCEEDED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)))
            {
                BOOL fInSafeMode = (StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L) == 0);

                if (fSetSafeMode != fInSafeMode)
                {
                    LPWSTR lpwstr;
                    DWORD dwSchemeFlags = SCHEME_GLOBAL | SCHEME_DISPLAY;
                    if (dwFlags & SSM_REFRESH)
                        dwSchemeFlags |= SCHEME_REFRESH;
                    if (dwFlags & SSM_UPDATE)
                        dwSchemeFlags |= SCHEME_UPDATE;

                    lpwstr = fSetSafeMode ? REG_DESKCOMP_SAFEMODE_SUFFIX_L : wszEdit;

                    SetScheme(lpwstr, dwSchemeFlags);
                }
            }
        }
    }
    return S_OK;
}

//
// EnsureUpdateHTML
//
// Ensures that the current html file present on the disk is in sync
// with the registry information for the current active desktop scheme.  If
// it is not in sync then a fresh copy of the file is generated from the
// registry for the current scheme.
//
HRESULT CActiveDesktop::EnsureUpdateHTML(void)
{
    DWORD dwFlags = 0;
    DWORD dwDataLength = sizeof(DWORD);
    LONG lRet;
    TCHAR szDeskcomp[MAX_PATH];
    TCHAR szDesktopFile[MAX_PATH];
    DWORD dwRestrictUpdate;
    DWORD dwRestrict = SHRestricted2W(REST_NoChannelUI, NULL, 0);
    DWORD dwSize = sizeof(dwRestrictUpdate);
    BOOL  fComponentsDirty = FALSE;  //Assume that the components are NOT dirty!
    DWORD dwVersion;
    DWORD dwMinorVersion;
    BOOL  fStaleInfoInReg = FALSE;
    BOOL  fComponentsZoomDirty = FALSE;
    static BOOL s_fNoDeskComp = (BOOL)-1;
    static BOOL s_fNoWallpaper = (BOOL)-1;
    BOOL fNoDeskComp = SHRestricted(REST_NODESKCOMP);
    BOOL fNoWallpaper = SHRestricted(REST_NOHTMLWALLPAPER);
    BOOL fAdminComponent = FALSE;
    HKEY hkey = NULL;
    HKEY hkeyTime;
    FILETIME ftAdminCompKey;


    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT, REG_VAL_GENERAL_RESTRICTUPDATE, NULL, &dwRestrictUpdate, &dwSize))
    {
        dwRestrictUpdate = 0;
    }

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);

    //See if this branch of registry is old
    if ((lRet = SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_VERSION, NULL,
                            &dwVersion, &dwDataLength)) == ERROR_SUCCESS)
    {
        if (dwVersion < CUR_DESKHTML_VERSION)
        {
            fStaleInfoInReg = TRUE;
        }
        else
        {
            //Major versions are equal. Check minor versions.
            if ((lRet = SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_MINOR_VERSION, NULL,
                                    &dwMinorVersion, &dwDataLength)) == ERROR_SUCCESS)
            {
                if (dwMinorVersion != CUR_DESKHTML_MINOR_VERSION)
                    fStaleInfoInReg = TRUE;
            }
            else
            {
                fStaleInfoInReg = TRUE;
            }
        }
    }
    else
    {
        fStaleInfoInReg = TRUE;
    }

    dwDataLength = sizeof(DWORD);

    //Check the dirty bit to see if we need to re-generate the desktop html
    if ((lRet = SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_GENFLAGS, NULL,
                            &dwFlags, &dwDataLength)) == ERROR_SUCCESS)
    {
        if (IsFlagSet(dwFlags, COMPONENTS_DIRTY))
            fComponentsDirty = TRUE;
        if (IsFlagSet(dwFlags, COMPONENTS_ZOOMDIRTY))
            fComponentsZoomDirty = TRUE;
    }

    // See if we need to add/delete an administrator added desktop component now
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_ADMINCOMP_ROOT, 0, KEY_READ, &hkey))
    {
        FILETIME ftLast;
        DWORD cbData = sizeof(ftLast);
        DWORD dwType;

        ZeroMemory(&ftLast, sizeof(ftLast));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP, 0, KEY_READ, &hkeyTime))
        {
            SHQueryValueEx(hkeyTime, TEXT("LastSyncedTime"), NULL, &dwType, (LPBYTE)&ftLast, &cbData);
            RegCloseKey(hkeyTime);
        }

        RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &ftAdminCompKey);

        if (CompareFileTime(&ftAdminCompKey, &ftLast) == 1) {
            WCHAR wszDisplay[MAX_PATH];
            DWORD dwcch = MAX_PATH;

            if (FAILED(GetScheme(wszDisplay, &dwcch, SCHEME_GLOBAL | SCHEME_DISPLAY)) ||
                     (StrCmpW(wszDisplay, REG_DESKCOMP_SAFEMODE_SUFFIX_L) != 0))
            {
                // We're not in safe mode, it's OK to add the components
                fAdminComponent = TRUE;
            }
        }
    }

    // 99/03/23 #237632 vtan: If the monitor arrangement has been changed from underneath
    // the user (perhaps by another user) then make sure that the components are in valid
    // positions. If not then snap them back into the visible space and mark them as dirty
    // so that the desktop.htt file is regenerated.

    _Initialize();
    if (_hdsaComponent)
    {
        int     i, iComponentCount;;

        iComponentCount = DSA_GetItemCount(_hdsaComponent);
        for (i = 0; i < iComponentCount; ++i)
        {
            COMPONENTA  *pComponent;

            pComponent = reinterpret_cast<COMPONENTA*>(DSA_GetItemPtr(_hdsaComponent, i));
            if (pComponent != NULL)
            {
                BOOL    bChangedPosition = FALSE, bChangedSize = FALSE;

                if (!SHIsTempDisplayMode()) //Modify the positions only if we are not in a temp mode change.
                    ValidateComponentPosition(&pComponent->cpPos, pComponent->dwCurItemState, pComponent->iComponentType, &bChangedPosition, &bChangedSize);
                if (bChangedPosition || bChangedSize)
                {
                    TBOOL(UpdateComponentPrivate(i, pComponent));
                    fComponentsDirty = TRUE;
                }
            }
        }
    }

    if (FAILED(GetPerUserFileName(szDesktopFile, ARRAYSIZE(szDesktopFile), DESKTOPHTML_FILENAME)))
    {
        szDesktopFile[0] = 0;
    }

    if (fComponentsDirty ||
         fComponentsZoomDirty ||
         fStaleInfoInReg ||
         fAdminComponent ||
         fNoDeskComp != s_fNoDeskComp ||
         fNoWallpaper != s_fNoWallpaper ||
         (dwRestrictUpdate != dwRestrict) ||
         !PathFileExistsAndAttributes(szDesktopFile, NULL))  //See if the file exists!
    {

        // Clear out any html wallpaper if it exists and the restriction is set
        if (fNoWallpaper != s_fNoWallpaper)
        {
            if (fNoWallpaper && !IsWallpaperPicture(_szSelectedWallpaper))
                SetWallpaper(L"", 0);
            s_fNoWallpaper = fNoWallpaper;
        }

        // Disable components if the restriction is set
        if (fNoDeskComp != s_fNoDeskComp)
        {
            // We can't set fEnableComponents to FALSE because there is no way via the UI
            // for the user to turn it back on again if the restriction is lifted.  Instead we add
            // special case code to _GenerateHtml that checks the restriction too.

            // _co.fEnableComponents = !fNoDeskComp; 
            s_fNoDeskComp = fNoDeskComp;
        }

        if (fAdminComponent)
        {
            COMPONENT comp;
            TCHAR pszAdminComp[INTERNET_MAX_URL_LENGTH];
            CHAR szUrl[INTERNET_MAX_URL_LENGTH];
            CHAR * pszUrl;
            CHAR * pszUrlList;
            TCHAR * aszAdminComp[] = {REG_VAL_ADMINCOMP_ADD, REG_VAL_ADMINCOMP_DELETE, NULL};
            int i = 0;

            comp.dwSize = sizeof(comp);
            comp.dwCurItemState = IS_SPLIT | IS_ADJUSTLISTVIEW;

            while (aszAdminComp[i])
            {
                dwDataLength = sizeof(pszAdminComp);
                // The reg value contains an array of space separated urls - currently we support adding and deleting
                // a desktop item via this mechanism.
                if (SHQueryValueEx(hkey, aszAdminComp[i], NULL, NULL, (LPBYTE)pszAdminComp, &dwDataLength) == ERROR_SUCCESS)
                {
                    SHTCharToAnsi(pszAdminComp, szUrl, ARRAYSIZE(szUrl));
                    pszUrlList = szUrl;
                    while (pszUrl = StrTokEx(&pszUrlList, " ")) {
                        SHAnsiToUnicode(pszUrl, comp.wszSource, ARRAYSIZE(comp.wszSource));
                        dwDataLength = ARRAYSIZE(comp.wszSource);
                        ParseURLFromOutsideSourceW(comp.wszSource, comp.wszSource, &dwDataLength, NULL);
                        if (lstrcmp(aszAdminComp[i], REG_VAL_ADMINCOMP_ADD) == 0)
                        {
                            AddUrl(NULL, (LPCWSTR)comp.wszSource, &comp, ADDURL_SILENT);
                            fComponentsZoomDirty = TRUE;
                        }
                        else
                        {
                            RemoveDesktopItem((LPCOMPONENT)&comp, 0);
                        }
                    }
                }
                i++;
            }
            
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP, TEXT("LastSyncedTime"), REG_BINARY, (LPVOID)&ftAdminCompKey, sizeof(ftAdminCompKey));

        }

        // Go through the entire list of desktop components and ensure any split/fullscreen
        // components are at their correct size/location.
        if (fComponentsZoomDirty)
        {
            if (_hdsaComponent)
            {
                int i;
                for (i = 0; i < DSA_GetItemCount(_hdsaComponent); i++)
                {
                    COMPONENTA * pcompT;
                
                    if (pcompT = (COMPONENTA *)DSA_GetItemPtr(_hdsaComponent, i))
                    {
                        if (ISZOOMED(pcompT))
                        {
                            BOOL fAdjustListview = (pcompT->dwCurItemState & IS_ADJUSTLISTVIEW);
                            ZoomComponent(&pcompT->cpPos, pcompT->dwCurItemState, fAdjustListview);
                            if (fAdjustListview)
                                pcompT->dwCurItemState &= ~IS_ADJUSTLISTVIEW;
                        }
                    }
                }
                SetDesktopFlags(COMPONENTS_ZOOMDIRTY, 0);
            }
        }

        // NOTE #1: The above initialization would have changed the Z-order because of
        // SortAndRationalize and so we need to APPLY_SAVE here.
        // Warning: APPLY_SAVE changes the dwID field of components. This should not
        // be a problem because we do this just before generating a new HTML file.
        // NOTE #2: Do NOT use AD_APPLY_FORCE here. That sets the _fPatternDirty too and
        // that causes a SystemParametersInfo() call which results in WM_SYSCOLORCHANGE
        // and this causes a refresh. So, we set the dirty bit explicitly here.

        _fDirty = TRUE;  // See Note#2 above.

        ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN);
        lRet = ERROR_SUCCESS;
        if (dwRestrictUpdate != dwRestrict)
            SHSetValue(HKEY_CURRENT_USER, REG_DESKCOMP_COMPONENTS_ROOT, REG_VAL_GENERAL_RESTRICTUPDATE, NULL, &dwRestrict, sizeof(dwRestrict));
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    return (lRet == ERROR_SUCCESS ? S_OK : E_FAIL);
}

//
//  ReReadWallpaper()
//      If the wallpaper was read when the active desktop was disabled, we would have read it from
//  the old location. Now, if the active desktop is turned ON, then we need to re-read the wallpaper
//  from the new location. We need to do this iff the wallpaper has not been changed in the mean-while
//
HRESULT CActiveDesktop::ReReadWallpaper(void)
{
    if ((!_fDirty) || (!_co.fActiveDesktop))  //If nothing has changed OR if active desktop is OFF, 
        return(S_FALSE);                        // then nothing to do!

    //ActiveDesktop is ON in our object. Read current shell state.
    SHELLSTATE ss = {0};
    
    SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);
    if (ss.fDesktopHTML)
        return(S_FALSE);        // Active Desktop state hasn't changed. So, nothing to do!

    //So, Active desktop was originally OFF and now it is turned ON.
    //If if someone changed the wallpaper, we should not mess with it.
    if (_fWallpaperDirty || _fWallpaperChangedDuringInit)
        return(S_FALSE); 

    // No one has changed the wallpaper. So, we must re-read it from the new wallpaper location
    // sothat we get the correct wallpaper for the active desktop mode.
    _ReadWallpaper(TRUE);

    return(S_OK);
}

//
//  GetADObjectFlags()
//
//      Get the Active Desktop object's internal flags
//
HRESULT CActiveDesktop::GetADObjectFlags(LPDWORD lpdwFlags, DWORD dwMask)
{
    ASSERT(lpdwFlags);
    
    *lpdwFlags = 0; //Init the flags
    
    if ((dwMask & GADOF_DIRTY) && _fDirty)
        *lpdwFlags |= GADOF_DIRTY;

    return(S_OK);
}


HRESULT ForceFullRefresh(void)
{
    HWND hwndShell = GetShellWindow();

    //Force a SHRefresh with this dummy call
    SHGetSetSettings(NULL, 0, TRUE);
    SendMessage(hwndShell, DTM_MAKEHTMLCHANGES, (WPARAM)0, (LPARAM)0L);
    //Can't use dynamic html. We have to refresh the whole page.
    SendMessage(hwndShell, WM_WININICHANGE, SPI_SETDESKWALLPAPER, (LPARAM)c_szRefreshDesktop);

    return S_OK;
}


HRESULT CActiveDesktop::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        hr = E_FAIL;

        if (StrCmpIW(pszPropName, c_wszPropName_IgnorePolicies) == 0)
        {
            pVar->vt = VT_BOOL;
            pVar->boolVal = (_fIgnoreAddRemovePolicies ? VARIANT_TRUE : VARIANT_TRUE);
            hr = S_OK;
        }
        else if (StrCmpIW(pszPropName, c_wszPropName_TSPerfBGPolicy) == 0)
        {
            BOOL fPolicySet = (IsTSPerfFlagEnabled(TSPerFlag_NoADWallpaper) || IsTSPerfFlagEnabled(TSPerFlag_NoWallpaper)); //No policy is set!

            pVar->vt = VT_BOOL;
            pVar->boolVal = (fPolicySet ? VARIANT_TRUE : VARIANT_TRUE);
            hr = S_OK;
        }
    }
    
    return hr;
}

HRESULT CActiveDesktop::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        hr = E_FAIL;
    
        if ((StrCmpIW(pszPropName, c_wszPropName_IgnorePolicies) == 0) && (VT_BOOL == pVar->vt))
        {
            _fIgnoreAddRemovePolicies = (VARIANT_TRUE == pVar->boolVal);
            hr = S_OK;
        }
        else if ((StrCmpIW(pszPropName, c_wszPropName_TSPerfBGPolicy) == 0) && (VT_BOOL == pVar->vt))
        {
            ForceFullRefresh();
            hr = S_OK;
        }
    }

    return hr;
}


/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*       copied from iert.lib
*******************************************************************************/

extern "C" char * __cdecl StrTokEx(char ** spstring, const char * scontrol)
{
        unsigned char **pstring = (unsigned char**) spstring;
        unsigned char *control = (unsigned char*) scontrol;

        unsigned char *str;
        const unsigned char *ctrl = control;
        unsigned char map[32];
        int count;

        unsigned char *tokenstr;

        if (*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = *pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = str;

        /* Determine if a token has been found. */
        if ( tokenstr == str )
            return NULL;
        else
            return (char*)tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\desktop.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "bitbuck.h"
#include <iethread.h>
#include "apithk.h"
#include "mtpt.h"
#include "..\util.h"
#include "fassoc.h"
#include "..\filetbl.h"

#define DM_FOCUS        0           // focus
#define DM_SHUTDOWN     DM_TRACE    // shutdown 
#define TF_SHDAUTO      0
#define DM_MISC         DM_TRACE    // misc/tmp

#define IDT_STARTBACKGROUNDSHELLTASKS 7
#define IDT_TASKBARWAKEUP 8

#define ENABLE_CHANNELS

#define DESKTOPCLASS        

STDAPI_(void) CheckWinIniForAssocs();

BOOL GetOldWorkAreas(LPRECT lprc, DWORD* pdwNoOfOldWA);
void SaveOldWorkAreas(LPCRECT lprc, DWORD nOldWA);

BOOL UpdateAllDesktopSubscriptions(IADesktopP2 *);

//This is in deskreg.cpp
BOOL AdjustDesktopComponents(LPCRECT prcNewWorkAreas, int nNewWorkAreas, 
                             LPCRECT prcOldMonitors, LPCRECT prcOldWorkAreas, int nOldWorkAreas);

// in defview.cpp
BOOL IsFolderWindow(HWND hwnd);

// copied from tray.c if changing here, change there also
#define GHID_FIRST 500

#define g_xVirtualScreen GetSystemMetrics(SM_XVIRTUALSCREEN)
#define g_yVirtualScreen GetSystemMetrics(SM_YVIRTUALSCREEN)
#define g_cxVirtualScreen GetSystemMetrics(SM_CXVIRTUALSCREEN)
#define g_cyVirtualScreen GetSystemMetrics(SM_CYVIRTUALSCREEN)
#define g_cxEdge GetSystemMetrics(SM_CXEDGE)
#define g_cyEdge GetSystemMetrics(SM_CYEDGE)

//  TOID_Desktop 6aec6a60-b7a4-11d1-be89-0000f805ca57 is the id for ShellTasks added by the desktop 
const GUID TOID_Desktop = { 0x6aec6a60, 0xb7a4, 0x11d1, {0xbe, 0x89, 0x00, 0x00, 0xf8, 0x05, 0xca, 0x57} };


// these are the CLSIDs that are supported for creating LocalServer thread
// objects.   the shell supports these in the RunDll32 and then the
// invocation of a thread on the desktop object.

CLSID const *c_localServers[] = 
{
    &CLSID_ShellDesktop,
    &CLSID_NetCrawler,
    &CLSID_HWShellExecute,
    &CLSID_ShellAutoplay,
};

typedef struct 
{
    INT iLocalServer;                   // index into the local server table
    DWORD *pdwThreadID;                 // where to stash the thread id
} LOCALSERVERDATA;


// Private interface to talk to explorer.exe
IDeskTray* g_pdtray = NULL;

void FireEventSz(LPCTSTR szEvent)
{
    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, szEvent);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

#define PERF_ENABLESETMARK
#ifdef PERF_ENABLESETMARK
void DoSetMark(LPCSTR pszMark, ULONG cbSz);
#define PERFSETMARK(text)   DoSetMark(text, sizeof(text))
#else
#define PERFSETMARK(text)
#endif  // PERF_ENABLESETMARK


#ifdef PERF_ENABLESETMARK
#include <wmistr.h>
#include <ntwmi.h>  // PWMI_SET_MARK_INFORMATION is defined in ntwmi.h
#include <wmiumkm.h>
#define NTPERF
#include <ntperf.h>

void DoSetMark(LPCSTR pszMark, ULONG cbSz)
{
    PWMI_SET_MARK_INFORMATION MarkInfo;
    HANDLE hTemp;
    ULONG cbBufferSize;
    ULONG cbReturnSize;

    cbBufferSize = FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark) + cbSz;

    MarkInfo = (PWMI_SET_MARK_INFORMATION) LocalAlloc(LPTR, cbBufferSize);

    // Failed to init, no big deal
    if (MarkInfo == NULL)
        return;

    BYTE *pMarkBuffer = (BYTE *) (&MarkInfo->Mark[0]);

    memcpy(pMarkBuffer, pszMark, cbSz);

    // WMI_SET_MARK_WITH_FLUSH will flush the working set when setting the mark
    MarkInfo->Flag = PerformanceMmInfoMark;

    hTemp = CreateFile(WMIDataDeviceName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL |
                           FILE_FLAG_OVERLAPPED,
                           NULL);

    if (hTemp != INVALID_HANDLE_VALUE)
    {
        // here's the piece that actually puts the mark in the buffer
        BOOL fIoctlSuccess = DeviceIoControl(hTemp,
                                       IOCTL_WMI_SET_MARK,
                                       MarkInfo,
                                       cbBufferSize,
                                       NULL,
                                       0,
                                       &cbReturnSize,
                                       NULL);

        CloseHandle(hTemp);
    }
    LocalFree(MarkInfo);
}
#endif  // PERF_ENABLESETMARK


// MISC stuff duplicated in browseui {
HRESULT _ConvertPathToPidlW(IBrowserService2 *pbs, HWND hwnd, LPCWSTR pszPath, LPITEMIDLIST * ppidl)
{
    WCHAR wszCmdLine[MAX_URL_STRING]; // must be with pszPath
    TCHAR szFixedUrl[MAX_URL_STRING];
    TCHAR szParsedUrl[MAX_URL_STRING] = {'\0'};
    DWORD dwUrlLen = ARRAYSIZE(szParsedUrl);

    // Copy the command line into a temporary buffer
    // so we can remove the surrounding quotes (if 
    // they exist)
    SHUnicodeToTChar(pszPath, szFixedUrl, ARRAYSIZE(szFixedUrl));
    PathUnquoteSpaces(szFixedUrl);
    
    HRESULT hr = S_OK;

    if (ParseURLFromOutsideSource(szFixedUrl, szParsedUrl, &dwUrlLen, NULL))
        SHTCharToUnicode(szParsedUrl, wszCmdLine, ARRAYSIZE(wszCmdLine));
    else
        hr = StringCchCopy(wszCmdLine, ARRAYSIZE(wszCmdLine), pszPath);
    
    if (SUCCEEDED(hr))
    {
        hr = pbs->IEParseDisplayName(CP_ACP, wszCmdLine, ppidl);
    }
    pbs->DisplayParseError(hr, wszCmdLine);
    return hr;
}
// END of MISC stuff duplicated in browseui }

// Several places rely on the fact that IShellBrowser is the first interface
// we inherit (and therefore is what we use as our canonical IUnknown).
// Grep for IUnknownIdentity to find them.

class CDesktopBrowser :
    public IShellBrowser
   ,public IServiceProvider
   ,public IOleCommandTarget
   ,public IDockingWindowSite
   ,public IInputObjectSite
   ,public IDropTarget
   ,public IDockingWindowFrame
   ,public IMultiMonitorDockingSite
   ,public IBrowserService2
   ,public IShellBrowserService
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void * *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    virtual STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDockingWindowSite (also IOleWindow)
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    // IDropTarget
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IDockingWindowFrame (also IOleWindow)
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc, DWORD dwFlags);
    virtual STDMETHODIMP FindToolbar(LPCWSTR pwszItem, REFIID riid, void **ppvObj);

    // IMultiMonitorDockingSite
    virtual STDMETHODIMP GetMonitor(IUnknown* punkSrc, HMONITOR * phMon);
    virtual STDMETHODIMP RequestMonitor(IUnknown* punkSrc, HMONITOR * phMon);
    virtual STDMETHODIMP SetMonitor(IUnknown* punkSrc, HMONITOR hMon, HMONITOR * phMonOld);
    
    static LRESULT CALLBACK DesktopWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK RaisedWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    void _MessageLoop();
    HWND GetTrayWindow(void) { return _hwndTray; }
    HWND GetDesktopWindow(void) { return _pbbd->_hwnd; }

    // IBrowserService
    // *** IBrowserService specific methods ***
    virtual STDMETHODIMP GetParentSite(IOleInPlaceSite** ppipsite);
    virtual STDMETHODIMP SetTitle(IShellView* psv, LPCWSTR pszName);
    virtual STDMETHODIMP GetTitle(IShellView* psv, LPWSTR pszName, DWORD cchName);
    virtual STDMETHODIMP GetOleObject( IOleObject** ppobjv);
    virtual STDMETHODIMP GetTravelLog(ITravelLog** pptl);
    virtual STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    virtual STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    virtual STDMETHODIMP IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags);
    virtual STDMETHODIMP IEParseDisplayName(UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut);
    virtual STDMETHODIMP DisplayParseError(HRESULT hres, LPCWSTR pwszPath);
    virtual STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF);
    virtual STDMETHODIMP SetNavigateState(BNSTATE bnstate);
    virtual STDMETHODIMP GetNavigateState (BNSTATE *pbnstate);
    virtual STDMETHODIMP NotifyRedirect ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse);
    virtual STDMETHODIMP UpdateWindowList ();
    virtual STDMETHODIMP UpdateBackForwardState ();
    virtual STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    virtual STDMETHODIMP GetFlags(DWORD *pdwFlags);
    virtual STDMETHODIMP CanNavigateNow ();
    virtual STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    virtual STDMETHODIMP SetReferrer (LPITEMIDLIST pidl);
    virtual STDMETHODIMP_(DWORD) GetBrowserIndex();
    virtual STDMETHODIMP GetBrowserByIndex(DWORD dwID, IUnknown **ppunk);
    virtual STDMETHODIMP GetHistoryObject(IOleObject **ppole, IStream **pstm, IBindCtx **ppbc);
    virtual STDMETHODIMP SetHistoryObject(IOleObject *pole, BOOL fIsLocalAnchor);
    virtual STDMETHODIMP CacheOLEServer(IOleObject *pole);
    virtual STDMETHODIMP GetSetCodePage(VARIANT* pvarIn, VARIANT* pvarOut);
    virtual STDMETHODIMP OnHttpEquiv(IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut);
    virtual STDMETHODIMP GetPalette( HPALETTE * hpal);
    virtual STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc);
    virtual STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnSize(WPARAM wParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    virtual STDMETHODIMP ReleaseShellView();
    virtual STDMETHODIMP ActivatePendingView();
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP GetBaseBrowserData(LPCBASEBROWSERDATA* ppbd);
    virtual STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData();
    virtual STDMETHODIMP SetAsDefFolderSettings() { ASSERT(FALSE); return E_NOTIMPL;}
    virtual STDMETHODIMP SetTopBrowser();
    virtual STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP InitializeDownloadManager();
    virtual STDMETHODIMP InitializeTransitionSite();
    virtual STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { *pfsd = _fsd; return S_OK; };
    virtual STDMETHODIMP _OnFocusChange(UINT itb);
    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual STDMETHODIMP CreateBrowserPropSheetExt(THIS_ REFIID riid, void **ppvObj);
    virtual STDMETHODIMP SetActivateState(UINT uActivate);
    virtual STDMETHODIMP AllowViewResize(BOOL f);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    virtual STDMETHODIMP_(UINT) _get_itbLastFocus();
    virtual STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus);
    virtual STDMETHODIMP _UIActivateView(UINT uState);
    virtual STDMETHODIMP _CancelPendingNavigationAsync();
    virtual STDMETHODIMP _MaySaveChanges(); 
    virtual STDMETHODIMP _PauseOrResumeView(BOOL fPaused);
    virtual STDMETHODIMP _DisableModeless();
    virtual STDMETHODIMP _NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP _TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _SwitchActivationNow();
    virtual STDMETHODIMP _CancelPendingView();
    virtual STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
        const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd);
    virtual STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _GetViewBorderRect(RECT* prc);
    virtual STDMETHODIMP _UpdateViewRectSize();
    virtual STDMETHODIMP _ResizeNextBorder(UINT itb);
    virtual STDMETHODIMP _ResizeView();
    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);
    virtual STDMETHODIMP GetCurrentFolderSettings(DEFFOLDERSETTINGS *pdfs, int cbDfs) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP GetViewRect(RECT* prc);
    virtual STDMETHODIMP GetViewWindow(HWND * phwndView);
    virtual STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);

        //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv);

    // Desktop needs to override these:
    virtual STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // Desktop needs access to these:
    virtual STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam) { ASSERT(FALSE); return 0; };
    virtual STDMETHODIMP SetAcceleratorMenu(HACCEL hacc) { ASSERT(FALSE); return E_FAIL; }
    virtual STDMETHODIMP_(int) _GetToolbarCount(THIS) { ASSERT(FALSE); return 0; }
    virtual STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(THIS_ int itb) { ASSERT(FALSE); return NULL; }
    virtual STDMETHODIMP _SaveToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _LoadToolbars(IStream* pstm) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc) { ASSERT(FALSE); return (UINT)-1; };
    virtual STDMETHODIMP v_MayTranslateAccelerator(MSG* pmsg) { ASSERT(FALSE); return E_NOTIMPL; }
    virtual STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) { ASSERT(FALSE); return E_NOTIMPL; }

    // Shell browser overrides this.
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // Desktop and basesb need access to these:
    virtual STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor);

    //  it just for us of course!
    void StartBackgroundShellTasks(void);
    void TaskbarWakeup(void);

protected:
    CDesktopBrowser();
    ~CDesktopBrowser();

    friend HRESULT CDesktopBrowser_CreateInstance(HWND hwnd, void **ppsb);
    HRESULT SetInner(IUnknown* punk);

    long _cRef;
    
    // cached pointers on inner object
    IUnknown* _punkInner;
    IBrowserService2* _pbsInner;
    IShellBrowser* _psbInner;
    IServiceProvider* _pspInner;
    IOleCommandTarget* _pctInner;
    IDockingWindowSite* _pdwsInner;
    IDockingWindowFrame* _pdwfInner;
    IInputObjectSite* _piosInner;
    IDropTarget* _pdtInner;

    LPCBASEBROWSERDATA _pbbd;

    LRESULT _RaisedWndProc(UINT msg, WPARAM wParam, LPARAM lParam);

    void _SetViewArea();

    void _GetViewBorderRects(int nRects, LPRECT prc);  // does not have the tool bars
    void _SetWorkAreas(int nWorkAreas, RECT * prcWork);
    
    void _SubtractBottommostTray(LPRECT prc);
    void _SaveState();
    void _InitDeskbars();
    void _SaveDesktopToolbars();
    
    void _OnRaise(WPARAM wParam, LPARAM lParam);
    void _SetupAppRan(WPARAM wParam, LPARAM lParam);
    BOOL _QueryHKCRChanged(HWND hwnd, LPDWORD pdwCookie);
    void _Lower();
    void _Raise();
    void _SwapParents(HWND hwndOldParent, HWND hwndNewParent);
    
    BOOL _OnCopyData(PCOPYDATASTRUCT pcds);
    void _OnAddToRecent(HANDLE hMem, DWORD dwProcId);
    BOOL _InitScheduler(void);
    HRESULT _AddDesktopTask(IRunnableTask *ptask, DWORD dwPriority);

    BOOL _PtOnDesktopEdge(POINTL* ppt, LPUINT puEdge);
#ifdef DEBUG
    void _CreateDeskbars();
#endif

    HRESULT _CreateDeskBarForBand(UINT uEdge, IUnknown *punk, POINTL *pptl, IBandSite **pbs);

    virtual void    v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend);
    HRESULT _OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    HRESULT _CreateDesktopView();
    HRESULT _GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv);
    HWND _GetDesktopListview();
    UINT _PeekForAMessage();
    
    void _InitMonitors();  

#ifdef ENABLE_CHANNELS
    void _MaybeLaunchChannelBand(void);
#endif
    
    virtual void    _ViewChange(DWORD dwAspect, LONG lindex);

    HWND _hwndTray;
    int _iWaitCount;
    ULONG _uNotifyID;
    DWORD _dwThreadIdTray; // Used to wakeup tray thread when the machine is really stressed
    int _iTrayPriority;

    
    DWORD _grfKeyState;
    DWORD _dwEffectOnEdge; // what's the drop effect that desktop should return on dragging over the edge
    
    BOOL _fRaised;
    HWND _hwndRaised;  // this is the parent of all of desktop's children when raised

    struct tagFolderSetData _fsd;

    int _nMonitors;                         // number of monitors on this desktop
    HMONITOR _hMonitors[LV_MAX_WORKAREAS]; // the order of these hmonitors need to be preserved
    RECT _rcWorkArea;       // cached work-area
    RECT _rcOldWorkAreas[LV_MAX_WORKAREAS];  // Old work areas before settings change
    DWORD _nOldWork;
    RECT _rcOldMonitors[LV_MAX_WORKAREAS];  // Old monitor sizes before settings change

    //  for _OnAddToRecent()
    IShellTaskScheduler *_psched;

    DWORD _idLocalServerThreads[ARRAYSIZE(c_localServers)];

    DWORD _cChangeEvents;
    HANDLE _rghChangeEvents[2];  // we watch HKCR and HKCR\CLSID 
    DWORD _dwChangeCookie;
    DWORD _rgdwQHKCRCookies[QHKCRID_MAX - QHKCRID_MIN];
    HKEY _hkClsid;

    WCHAR _wzDesktopTitle[64];  // Localized Title 

    //  IUnknownIdentity - for uniformity w.r.t. aggregation
    //  We are not aggregatable, so we are our own Outer.
    IUnknown *_GetOuter() { return SAFECAST(this, IShellBrowser*); }

};

HRESULT CDesktopBrowser_CreateInstance(HWND hwnd, void **ppsb)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDesktopBrowser *pdb = new CDesktopBrowser();

    if (pdb)
    {
        hr = pdb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr))
            ATOMICRELEASE(pdb);
    }
    
    *ppsb = pdb;
    return hr;
}

CDesktopBrowser::CDesktopBrowser() : _cRef(1)
{
    TraceMsg(TF_LIFE, "ctor CDesktopBrowser %x", this);

    for (INT i = 0; i < ARRAYSIZE(_idLocalServerThreads); i++)
        _idLocalServerThreads[i] = -1;
}

CDesktopBrowser::~CDesktopBrowser()
{
    SaveOldWorkAreas(_rcOldWorkAreas, _nOldWork);

    //  cleanup for QueryHKCRChanged()
    for (int i = 0; i < ARRAYSIZE(_rghChangeEvents); i++)
    {
        if (_rghChangeEvents[i])
            CloseHandle(_rghChangeEvents[i]);
    }

    if (_hkClsid)
        RegCloseKey(_hkClsid);

    // close down the local server threads that may be running 
    for (i = 0; i < ARRAYSIZE(_idLocalServerThreads); i++)
    {
        if (_idLocalServerThreads[i] != -1)
            PostThreadMessage(_idLocalServerThreads[i], WM_QUIT, 0, 0);
    }

    TraceMsg(TF_LIFE, "dtor CDesktopBrowser %x", this);
}


HRESULT CDesktopBrowser::_Initialize(HWND hwnd, IUnknown* pauto)
{
    IUnknown* punk;
    
    HRESULT hres = CoCreateInstance(CLSID_CCommonBrowser, _GetOuter(), CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hres))
    {
        hres = SetInner(punk); // paired w/ Release in outer (TBS::Release)
        if (SUCCEEDED(hres))
        {
            // we must initialize the inner guy BEFORE we call through any of these pointers.
            hres = _pbsInner->_Initialize(hwnd, pauto);
            if (SUCCEEDED(hres))
            {
                _pbsInner->GetBaseBrowserData(&_pbbd);
                ASSERT(_pbbd);
            
                // Restore the old settings from the registry that we persist.
                if (!GetOldWorkAreas(_rcOldWorkAreas, &_nOldWork) || _nOldWork == 0)
                {
                    // We didn't find it in the registry
                    _nOldWork = 0;  // Since this is 0, we don't have to set _rcOldWorkAreas.
                    //We will recover from this in _SetWorkAreas()
                }
            
                SetTopBrowser();
                _put_itbLastFocus(ITB_VIEW);    // focus on desktop (w95 compat)
            
                HACCEL hacc = LoadAccelerators(HINST_THISDLL, MAKEINTRESOURCE(ACCEL_DESKTOP));
                ASSERT(hacc);
                _pbsInner->SetAcceleratorMenu(hacc);
            
                // Perf: never fire events from the desktop.
                ASSERT(_pbbd->_pautoEDS);
                ATOMICRELEASE(const_cast<IExpDispSupport *>(_pbbd->_pautoEDS));
            
                _InitMonitors();
            
                // Initialise _rcOldMonitors
                for (int i = 0; i < _nMonitors; i++)
                {
                    GetMonitorRect(_hMonitors[i], &_rcOldMonitors[i]);
                }
                //  NOTE:  if we have any more keys to watch, then 
                //  we should create a static struct to walk
                //  so that it is easier to add more event/key pairs
                _rghChangeEvents[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
                _rghChangeEvents[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
                if (_rghChangeEvents[0] && _rghChangeEvents[1])
                {
                    if (ERROR_SUCCESS == RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE, 
                        REG_NOTIFY_CHANGE_LAST_SET  |REG_NOTIFY_CHANGE_NAME, _rghChangeEvents[0], TRUE))
                    {
                        _cChangeEvents = 1;
                        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, MAXIMUM_ALLOWED, &_hkClsid)
                        &&  ERROR_SUCCESS == RegNotifyChangeKeyValue(_hkClsid, TRUE, REG_NOTIFY_CHANGE_LAST_SET |REG_NOTIFY_CHANGE_NAME, _rghChangeEvents[1], TRUE))
                        {
                            //  we need to leave the key open, 
                            //  or the event is signaled right away
                            _cChangeEvents++;
                        }
                    }
                }
            }

        }
    } 
    
    return hres;
}


//
//  The refcount in the punk is transferred to us.  We do not need to
//  and indeed should not AddRef it.
//
//  If any of these steps fails, we will clean up in our destructor.
//
HRESULT CDesktopBrowser::SetInner(IUnknown* punk)
{
    HRESULT hres;

    ASSERT(_punkInner == NULL);

    _punkInner = punk;

#define INNERCACHE(iid, p) do { \
    hres = SHQueryInnerInterface(_GetOuter(), punk, iid, (void **)&p); \
    if (!EVAL(SUCCEEDED(hres))) return E_FAIL; \
    } while (0)

    INNERCACHE(IID_IBrowserService2, _pbsInner);
    INNERCACHE(IID_IShellBrowser, _psbInner);
    INNERCACHE(IID_IServiceProvider, _pspInner);
    INNERCACHE(IID_IOleCommandTarget, _pctInner);
    INNERCACHE(IID_IDockingWindowSite, _pdwsInner);
    INNERCACHE(IID_IDockingWindowFrame, _pdwfInner);
    INNERCACHE(IID_IInputObjectSite, _piosInner);
    INNERCACHE(IID_IDropTarget, _pdtInner);

#undef INNERCACHE

    return S_OK;
}

ULONG CDesktopBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDesktopBrowser::Release()
{
    ASSERT( 0 != _cRef );
    
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        _cRef = 1000;               // guard against recursion

        RELEASEINNERINTERFACE(_GetOuter(), _pbsInner);
        RELEASEINNERINTERFACE(_GetOuter(), _psbInner);
        RELEASEINNERINTERFACE(_GetOuter(), _pspInner);
        RELEASEINNERINTERFACE(_GetOuter(), _pctInner);
        RELEASEINNERINTERFACE(_GetOuter(), _pdwsInner);
        RELEASEINNERINTERFACE(_GetOuter(), _pdwfInner);
        RELEASEINNERINTERFACE(_GetOuter(), _piosInner);
        RELEASEINNERINTERFACE(_GetOuter(), _pdtInner);

        // this must come last
        ATOMICRELEASE(_punkInner); // paired w/ CCI aggregation
    
        ASSERT(_cRef == 1000);

        delete this;
    }
    return cRef;
}

HRESULT CDesktopBrowser::QueryInterface(REFIID riid, void **ppvObj)
{
    // IUnknownIdentity - The interface we use for IUnknown must come first.
    static const QITAB qit[] = {
        QITABENT(CDesktopBrowser, IShellBrowser),
        QITABENT(CDesktopBrowser, IBrowserService2),
        QITABENTMULTI(CDesktopBrowser, IBrowserService, IBrowserService2),
        QITABENTMULTI(CDesktopBrowser, IOleWindow, IShellBrowser),
        QITABENTMULTI2(CDesktopBrowser, SID_SShellDesktop, IShellBrowser), // effectively an IUnknown supported only by this class
        QITABENT(CDesktopBrowser, IServiceProvider),
        QITABENT(CDesktopBrowser, IShellBrowserService),
        QITABENT(CDesktopBrowser, IOleCommandTarget),
        QITABENT(CDesktopBrowser, IDockingWindowSite),
        QITABENT(CDesktopBrowser, IInputObjectSite),
        QITABENT(CDesktopBrowser, IMultiMonitorDockingSite),
        QITABENT(CDesktopBrowser, IDropTarget),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres)) 
    {
        if (_punkInner)
        {
            // don't let these get through to our base class...
            // IID_IOleCommandTarget, IID_IOleInPlaceUIWindow
            // 970414 adp: spoke to SatoNa, these *can* go thru
            // i'll remove this week
            // It's been working like this for a while now.
            if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
            {
                *ppvObj = NULL;
                hres = E_NOINTERFACE;
            }
            else
            {
                hres = _punkInner->QueryInterface(riid, ppvObj);
            }
        }
    }
    
    return hres;
}


void _InitDesktopMetrics(WPARAM wParam, LPCTSTR pszSection)
{
    BOOL fForce = (!pszSection || !*pszSection);

    if (fForce || (wParam == SPI_SETNONCLIENTMETRICS) || !lstrcmpi(pszSection, TEXT("WindowMetrics")))
    {
        FileIconInit(TRUE); // Tell the shell we want to play with a full deck
    }
}

typedef struct
{
    int iMonitors;
    HMONITOR * phMonitors;
} EnumMonitorsData;

BOOL CALLBACK MultiMonEnumCallBack(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData)
{
    EnumMonitorsData * pEmd = (EnumMonitorsData *)lData;
    
    if (pEmd->iMonitors > LV_MAX_WORKAREAS - 1)
        //ignore the other monitors because we can only handle up to LV_MAX_WORKAREAS
        //REARCHITECT: should we dynamically allocated this?
        return FALSE;

    pEmd->phMonitors[pEmd->iMonitors++] = hMonitor;
    return TRUE;
}

// Initialize the number of monitors and the hmonitors array

void CDesktopBrowser::_InitMonitors()
{
    HMONITOR hMonPrimary = GetPrimaryMonitor();
    
    EnumMonitorsData emd;
    emd.iMonitors = 0;
    emd.phMonitors = _hMonitors;

    EnumDisplayMonitors(NULL, NULL, MultiMonEnumCallBack, (LPARAM)&emd);
    _nMonitors = GetNumberOfMonitors();
    
    // Always move the primary monitor to the first location.
    if (_hMonitors[0] != hMonPrimary)
    {
        for (int iMon = 1; iMon < _nMonitors; iMon++)
        {
            if (_hMonitors[iMon] == hMonPrimary)
            {
                _hMonitors[iMon] = _hMonitors[0];
                _hMonitors[0] = hMonPrimary;
                break;
            }
        }
    }
}

// Gets the persisted old work areas, from the registry
BOOL GetOldWorkAreas(LPRECT lprc, DWORD* pdwNoOfOldWA)
{
    BOOL fRet = FALSE;
    *pdwNoOfOldWA = 0;
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_DESKCOMP_OLDWORKAREAS, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType, cbSize = sizeof(*pdwNoOfOldWA);
        // Read in the no of old work areas
        if (SHQueryValueEx(hkey, REG_VAL_OLDWORKAREAS_COUNT, NULL, &dwType, (LPBYTE)pdwNoOfOldWA, &cbSize) == ERROR_SUCCESS)
        {
            // Read in the old work area rects
            cbSize = sizeof(*lprc) * (*pdwNoOfOldWA);
            if (SHQueryValueEx(hkey, REG_VAL_OLDWORKAREAS_RECTS, NULL, &dwType, (LPBYTE)lprc, &cbSize) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }
        }
        RegCloseKey(hkey);
    }
    return fRet;
}
        
// Saves the old work areas into the registry
void SaveOldWorkAreas(LPCRECT lprc, DWORD nOldWA)
{
    // Recreate the registry key.
    HKEY hkey;
    if (RegCreateKey(HKEY_CURRENT_USER, REG_DESKCOMP_OLDWORKAREAS, &hkey) == ERROR_SUCCESS)
    {
        // Write out the no. of old work areas
        RegSetValueEx(hkey, REG_VAL_OLDWORKAREAS_COUNT, 0, REG_DWORD, (LPBYTE)&nOldWA, sizeof(nOldWA));
        // Write out the no work area rectangles
        RegSetValueEx(hkey, REG_VAL_OLDWORKAREAS_RECTS, 0, REG_BINARY, (LPBYTE)lprc, sizeof(*lprc) * nOldWA);
        // Close out the reg key
        RegCloseKey(hkey);
    }
}

//***   CDesktopBrowser::IOleCommandTarget::* {

STDMETHODIMP CDesktopBrowser::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case SHDVID_RAISE:
            // n.b.: DTRF_RAISE/DTRF_LOWER go down; DTRF_QUERY goes up
            ASSERT(pvarargIn != NULL && pvarargIn->vt == VT_I4);
            if (pvarargIn->vt == VT_I4 && pvarargIn->lVal == DTRF_QUERY) 
            {
                ASSERT(pvarargOut != NULL);
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _fRaised ? DTRF_RAISE : DTRF_LOWER;
                return S_OK;
            }
            // o.w. let parent handle it
            break;

        case SHDVID_UPDATEOFFLINEDESKTOP:
            UpdateAllDesktopSubscriptions(NULL);
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID)
        {
        case SBCMDID_OPTIONS:
        case SBCMDID_ADDTOFAVORITES:
            return _pctInner->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    // do *not* forward up to SUPERCLASS::Exec (see QI's cryptic commment
    // about "don't let these get thru to our base class")
    return OLECMDERR_E_NOTSUPPORTED;
}

// }

STDMETHODIMP CDesktopBrowser::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // Force SBSP_NEWBROWSER, SBSP_ABSOLUTE, and SBSP_NOTRANSFERHIST
    wFlags &= ~(SBSP_DEFBROWSER | SBSP_SAMEBROWSER | SBSP_RELATIVE | SBSP_PARENT);
    wFlags |= (SBSP_NEWBROWSER | SBSP_ABSOLUTE | SBSP_NOTRANSFERHIST);
    return _psbInner->BrowseObject(pidl, wFlags);
}

IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName)
{
    HKEY hkStreams;

    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams"), &hkStreams) == ERROR_SUCCESS)
    {
        IStream *pstm = OpenRegStream(hkStreams, TEXT("Desktop"), pszName, grfMode);
        RegCloseKey(hkStreams);
        return pstm;
    }
    return NULL;
}

void DeleteDesktopViewStream(LPCTSTR pszName)
{
    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams\\Desktop"), pszName);
}

IStream *CDesktopBrowser::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pszName)
{
    return GetDesktopViewStream(grfMode, pszName);
}

HRESULT CDesktopBrowser::_GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv)
{
    return SHGetViewStatePropertyBag(pidl, VS_BAGSTR_DESKTOP, dwFlags | SHGVSPB_ROAM, riid, ppv);
}

HRESULT CDesktopBrowser::GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv)
{
    HRESULT hr;

    LPITEMIDLIST pidl;
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pidl);

    if (SUCCEEDED(hr))
    {
        hr = _GetPropertyBag(pidl, dwFlags, riid, ppv);

        ILFree(pidl);
    }

    return hr;
}

LRESULT CDesktopBrowser::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case FCIDM_FINDFILES:
        SHFindFiles(_pbbd->_pidlCur, NULL);
        break;
        
    case FCIDM_REFRESH:
    {
        VARIANT v = {0};
        v.vt = VT_I4;
        v.lVal = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
        // Our Exec is neutered (on purpose), so call our parent
        _pctInner->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, &v, NULL);
        break;
    }

    case IDC_KBSTART:
    case FCIDM_NEXTCTL:
        if (_hwndTray)
        {
            // n.b. VK_TAB handled this way (among other things)
            SendMessage(_hwndTray, WM_COMMAND, wParam, lParam);
        }
        break;

    case IDM_CLOSE:
        PostMessage(_hwndTray, TM_DOEXITWINDOWS, 0, 0);
        break;

    default:
        _pbsInner->OnCommand(wParam, lParam);
        break;
    }
    
    return S_OK;
}


// Create desktop IShellView instance

HRESULT CDesktopBrowser::_CreateDesktopView()
{
    LPCITEMIDLIST pidl = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, TRUE);
    if (pidl)
    {
        IPropertyBag* ppb;
        if (0 == GetSystemMetrics(SM_CLEANBOOT) &&
            SUCCEEDED(_GetPropertyBag(pidl, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_FFLAGS, reinterpret_cast<DWORD*>(&_fsd._fs.fFlags), FWF_DESKTOP | FWF_NOCLIENTEDGE |  FWF_SNAPTOGRID);
            ppb->Release();
        }
        else
        {
            _fsd._fs.fFlags = FWF_DESKTOP | FWF_NOCLIENTEDGE | FWF_SNAPTOGRID;  // default
        }

        _fsd._fs.ViewMode = FVM_ICON;  // can't change this, sorry

        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_HIDEICONS, FALSE);
        if (ss.fHideIcons)
            _fsd._fs.fFlags |= FWF_NOICONS;
        else
            _fsd._fs.fFlags &= ~FWF_NOICONS;

        // We keep the active desktop in offline mode!
        ASSERT(_pbbd->_pautoWB2);
        _pbbd->_pautoWB2->put_Offline(TRUE);

        return _psbInner->BrowseObject(pidl, SBSP_SAMEBROWSER);
    }
    else
    {
        TCHAR szYouLoose[256];

        LoadString(HINST_THISDLL, IDS_YOULOSE, szYouLoose, ARRAYSIZE(szYouLoose));
        MessageBox(NULL, szYouLoose, NULL, MB_ICONSTOP);
        return E_FAIL;
    }
}

HRESULT CDesktopBrowser::ActivatePendingView(void)
{
    HRESULT hres = _pbsInner->ActivatePendingView();
    if (SUCCEEDED(hres))
    {
        // calling SetShellWindow will cause the desktop
        // to initially paint white, then the background window.
        // This causes an ugly white trail when you move windows 
        // around until the desktop finally paints.
        // 
        // Calling SetShellWindowEx resolves this problem.
        //
        SHSetShellWindowEx(_pbbd->_hwnd, _GetDesktopListview());
    }
    
    return hres;
}

#ifdef DEBUG

void CDesktopBrowser::_CreateDeskbars()
{
    HRESULT hres;
    BOOL fCreate = FALSE;
    HKEY hkey;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\DeskBar\\Bands"), &hkey)) 
    {
        fCreate = TRUE;
        RegCloseKey(hkey);
    }
    
    if (fCreate) 
    {
        IPersistStreamInit *ppstm;
        hres = CoCreateInstance(CLSID_DeskBarApp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistStreamInit, &ppstm));
        if (SUCCEEDED(hres)) {
            hres = ppstm->InitNew();
            AddToolbar(ppstm, L"test", NULL);    // "Microsoft.DeskBarApp"
            ppstm->Release();
        }
    }
}
#endif

void CDesktopBrowser::_InitDeskbars()
{
    //
    // Load toolbars
    //

    // 1st, try persisted state
    IStream* pstm = GetDesktopViewStream(STGM_READ, TEXT("Toolbars"));
    HRESULT hres = E_FAIL;
    if (pstm) 
    {
        hres = _pbsInner->_LoadToolbars(pstm);
        pstm->Release();
    }

    // 2nd, if there is none (or if version mismatch or other failure),
    // try settings from setup
    // NOTE: this works fine for ie4 where we have no old toolbars,
    // but for future releases we'll need some kind of merging scheme,
    // so we probably want to change this after ie4-beta-1.
    if (FAILED(hres)) 
    {
        // n.b. HKLM not HKCU
        // like GetDesktopViewStream but for HKLM
        HKEY hk = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Streams\\Desktop"), TRUE); 
        if (hk)
        {
            pstm = OpenRegStream(hk, NULL, TEXT("Default Toolbars"), STGM_READ);
            if (pstm) 
            {
                hres = _pbsInner->_LoadToolbars(pstm);
                pstm->Release();
            }
            RegCloseKey(hk);
        }
    }

    // o.w., throw up our hands
    if (FAILED(hres)) 
    {
        ASSERT(0);
#ifdef DEBUG
        // but for debug, need a way to bootstrap the entire process
        _CreateDeskbars();
#endif
    }
}

// Handle creation of a new Desktop folder window. Creates everything except
// the viewer part.
// Returns -1 if something goes wrong.
HWND g_hwndTray = NULL;

HRESULT CDesktopBrowser::OnCreate(CREATESTRUCT *pcs)
{
    LRESULT lr;

    g_pdtray->GetTrayWindow(&_hwndTray);
    g_hwndTray = _hwndTray;
    g_pdtray->SetDesktopWindow(_pbbd->_hwnd);

    SetTimer(_pbbd->_hwnd, IDT_ENUMHKCR, 5 * 60 * 1000, NULL);
    //
    // Notify IEDDE that the automation services are now available.
    //
    IEOnFirstBrowserCreation(NULL);

    ASSERT(_hwndTray);

    // REARCHITECT: we need to split out "ie registry settings" into a
    // browser component and a shell component.
    //
    //EnsureWebViewRegSettings();

    if (SUCCEEDED(_CreateDesktopView()))
    {
        lr = _pbsInner->OnCreate(pcs);   // success

        PostMessage(_pbbd->_hwnd, DTM_CREATESAVEDWINDOWS, 0, 0);
        
        return (HRESULT) lr;
    }

    return (LRESULT)-1;   // failure
}

UINT GetDDEExecMsg()
{
    static UINT uDDEExec = 0;

    if (!uDDEExec)
        uDDEExec = RegisterWindowMessage(TEXT("DDEEXECUTESHORTCIRCUIT"));

    return uDDEExec;
}

LRESULT CDesktopBrowser::OnNotify(NMHDR * pnm)
{
    switch (pnm->code) 
    {
    case SEN_DDEEXECUTE:
        if (pnm->idFrom == 0) 
        {
            // short cut notifier around the dde conv.
            
            LPNMVIEWFOLDER pnmPost = DDECreatePostNotify((LPNMVIEWFOLDER)pnm);

            if (pnmPost)
            {
                PostMessage(_pbbd->_hwnd, GetDDEExecMsg(), 0, (LPARAM)pnmPost);
                return TRUE;
            }
        }
        break;

    case NM_STARTWAIT:
    case NM_ENDWAIT:
        _iWaitCount += (pnm->code == NM_STARTWAIT ? 1 :-1);

        ASSERT(_iWaitCount >= 0);

        // Don't let it go negative or we'll never get rid of it.
        if (_iWaitCount < 0)
            _iWaitCount = 0;

        // what we really want is for user to simulate a mouse move/setcursor
        SetCursor(LoadCursor(NULL, _iWaitCount ? IDC_APPSTARTING : IDC_ARROW));
        break;

    default:
        return _pbsInner->OnNotify(pnm);
    }
    return 0;
}

// HACKHACK: this hard codes in that we know a listview is the child
// of the view.
HWND CDesktopBrowser::_GetDesktopListview()
{
    HWND hwndView = _pbbd->_hwndView ? _pbbd->_hwndView : _pbbd->_hwndViewPending;
    
    if (!hwndView)
        return NULL;
    
    return FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL);
}

#ifndef ENUM_REGISTRY_SETTINGS
#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)
#endif


STDAPI_(BOOL) SHIsTempDisplayMode()
{
    BOOL fTempMode = FALSE;

    DEVMODE dm = {0};
    dm.dmSize = sizeof(dm);

    if (EnumDisplaySettings(NULL, ENUM_REGISTRY_SETTINGS, &dm) &&
        dm.dmPelsWidth > 0 && dm.dmPelsHeight > 0)
    {
        HDC hdc = GetDC(NULL);
        int xres = GetDeviceCaps(hdc, HORZRES);
        int yres = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(NULL, hdc);

        if (xres != (int)dm.dmPelsWidth || yres != (int)dm.dmPelsHeight)
            fTempMode = TRUE;
    }
    return fTempMode;
}

// NOTE: this is the hack andyp put in
// (dli) Currently, bottommost Tray is really wierd, it is not treated as toolbars.
// In a sense, it has higher priority than those toolbars. So they should be taken 
// off the EffectiveClientArea

void CDesktopBrowser::_SubtractBottommostTray(LPRECT prc)
{
    LRESULT lTmp;
    APPBARDATA abd;
    
    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwndTray;

    // lTmp = SHAppBarMessage(ABM_GETSTATE, &abd);
    lTmp = g_pdtray->AppBarGetState();

    if ((lTmp & (ABS_ALWAYSONTOP|ABS_AUTOHIDE)) == 0) {
        // tray is on bottom and takes 'real' space
        RECT rcTray = {0};
        
        GetWindowRect(_hwndTray, &rcTray);
        IntersectRect(&rcTray, prc, &rcTray);
        SubtractRect(prc, prc, &rcTray);
    }   
}

HRESULT CDesktopBrowser::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    //
    // Cache the work area if
    //  (1) this is the very first call
    //  (2) cached value is blew off by WM_SIZE (in _OnSize)
    //
    if (hmon) {
        GetMonitorWorkArea(hmon, lprectBorder);
    }
    else {
        if (::IsRectEmpty(&_rcWorkArea)) {
            ::SystemParametersInfo(SPI_GETWORKAREA, 0, &_rcWorkArea, 0);
        }
        *lprectBorder = _rcWorkArea;
    }

    _SubtractBottommostTray(lprectBorder);
    MapWindowPoints(NULL, _pbbd->_hwnd, (LPPOINT)lprectBorder, 2);
    return S_OK;
}


BOOL EqualRects(LPRECT prcNew, LPRECT prcOld, int nRects)
{
    int i;
    for (i = 0; i < nRects; i++)
        if (!EqualRect(&prcNew[i], &prcOld[i]))
            return FALSE;
    return TRUE;
}

//
// When Snap-To-Grid is on, we want to reduce the size of gutter space around the primary monitor.
// We achieve that by adding a few pixels to the grid size sothat the gutter size  left out is
// as small as possible.
// Note: This is currently done only for Desktop listview.
//
// fMinimizeCutterSpace == FALSE  => Nothing to do. Just return.
// fMinimizeGutterSpace == TRUE   => We calculate and set the icon spacing so as to minimize gutter.
//
void UpdateGridSizes(BOOL fDesktop, HWND hwndListview, int nWorkAreas, LPRECT prcWork, BOOL fMinimizeGutterSpace)
{
    if(!fDesktop)   //If this is not desktop, we do not change any of this.
        return;

    // Trying to reset the icon spacing to system icon spacing results in ReComputing everything.
    // So, just return without doing anything!
    if(!fMinimizeGutterSpace)
        return;     //If we don't have to minimize the gutter space, nothing to do!
        
    int cxSysIconSpacing = GetSystemMetrics(SM_CXICONSPACING);
    if (cxSysIconSpacing <= 0) cxSysIconSpacing = 1; // avoid div0

    int cySysIconSpacing = GetSystemMetrics(SM_CYICONSPACING);
    if (cySysIconSpacing <= 0) cySysIconSpacing = 1; // avoid div0

    int cxNewIconSpacing = 0, cyNewIconSpacing = 0;

    RECT rcWorkAreas[LV_MAX_WORKAREAS];

    //If the work areas are not given, we need to get them.
    if(prcWork == NULL)
    {
        prcWork = &rcWorkAreas[0];
        ListView_GetNumberOfWorkAreas(hwndListview, &nWorkAreas);
        if(nWorkAreas > 0)
            ListView_GetWorkAreas(hwndListview, nWorkAreas, prcWork);
        else
            ListView_GetViewRect(hwndListview, prcWork);
    }

    //Get the primary work area.
    for(int iPrimary = 0; iPrimary < nWorkAreas; iPrimary++)
    {
        //LATER: Is this check enough! What about when tray is at the top or left?
        if((prcWork[iPrimary].left == 0) && (prcWork[iPrimary].top == 0))
            break;
    }

    if(iPrimary == nWorkAreas)
        iPrimary = 0; //Assume that the first work area is primary work area.

    //Find the number of columns based on current system horizontal icon spacing.
    int nCols = (prcWork[iPrimary].right - prcWork[iPrimary].left)/cxSysIconSpacing;
    if (nCols <= 0) nCols = 1; // avoid div0

    //Divide the remaining pixels and add them to each column to minimize the reminder area.
    cxNewIconSpacing = cxSysIconSpacing + ((prcWork[iPrimary].right - prcWork[iPrimary].left)%cxSysIconSpacing)/nCols;
    if (cxNewIconSpacing <= 0) cxNewIconSpacing = 1; // avoid div0

    //Find the number of Rows based on current system vertical icon spacing.
    int nRows = (prcWork[iPrimary].bottom - prcWork[iPrimary].top)/cySysIconSpacing;
    if (nRows <= 0) nRows = 1; // avoid div0

    //Divide the remaining pixles  and add them to each row to minimize the reminder area.
    cyNewIconSpacing = cySysIconSpacing + ((prcWork[iPrimary].bottom - prcWork[iPrimary].top)%cySysIconSpacing)/nRows;
    if (cyNewIconSpacing <= 0) cyNewIconSpacing = 1; // avoid div0

    //Set the new icon spacing to the desktop's listview.
    ListView_SetIconSpacing(hwndListview, cxNewIconSpacing, cyNewIconSpacing);
}

void CDesktopBrowser::_SetWorkAreas(int nWorkAreas, LPRECT prcWork)
{
    RECT rcListViewWork[LV_MAX_WORKAREAS];
    RECT rcNewWork[LV_MAX_WORKAREAS];
    int  nListViewWork = 0;
    HWND hwndList;
    int  i;

    ASSERT(prcWork);
    ASSERT(nWorkAreas <= LV_MAX_WORKAREAS);
    ASSERT(nWorkAreas > 0);

    if (nWorkAreas <= 0)
        return;

    if (SHIsTempDisplayMode())
        return;
    
    hwndList = _GetDesktopListview();
    ASSERT(IsWindow(hwndList));

    ListView_GetNumberOfWorkAreas(hwndList, &nListViewWork);

    BOOL fUpgradeGridSize = (BOOL)((ListView_GetExtendedListViewStyle(hwndList)) & LVS_EX_SNAPTOGRID);
    BOOL fRedraw = FALSE;

    if (nListViewWork > 0)
    {
        ListView_GetWorkAreas(hwndList, nListViewWork, rcListViewWork);
        // Map these rects back to DESKTOP coordinate
        // We need to convert the following only if WorkAreas > 1
        if (nListViewWork > 1)
        {
            // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
            for(i = 0; i < nListViewWork; i++)
            {
                MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)(&rcListViewWork[i]), 2);
            }    
        }    
        if(nListViewWork == nWorkAreas && EqualRects(prcWork, rcListViewWork, nWorkAreas))
            return;
    }
    else if (_nOldWork > 1)
        // In single monitor case, listview workares always starts from (0,0)
        // It will be wrong to set the persisted workarea. 
    {
        for (nListViewWork = 0; nListViewWork < (int)_nOldWork && nListViewWork < LV_MAX_WORKAREAS; nListViewWork++)
            CopyRect(&rcListViewWork[nListViewWork], &_rcOldWorkAreas[nListViewWork]);

        // This may not be needed, because at this point, ListView is in Desktop coordinate
        // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
        for(i = 0; i < nListViewWork; i++)
        {
            MapWindowPoints(HWND_DESKTOP, hwndList, (LPPOINT)(&rcListViewWork[i]), 2);
        }    
        //Before setting the WorkAreas, change the grid-size if needed.
        if(fUpgradeGridSize)
        {
            // We set the grid size based on the new work area. This way Recycle-Bin gets snapped
            // to the correct location just once and we don't need to change it later.
            SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
            fRedraw = TRUE;
            UpdateGridSizes(TRUE, hwndList, nWorkAreas, prcWork, TRUE);
            fUpgradeGridSize = FALSE; //Don't need to do it again!
        }
        // This call to SetWorkAreas sets the old work areas in the listview, which is not persisted there.
        ListView_SetWorkAreas(hwndList, nListViewWork, rcListViewWork);
    }
    
    //Make a copy of the new work area array because it gets modified by
    // the MapWindowPoints below.
    for(i = 0; i < nWorkAreas; i++)
        rcNewWork[i] = *(prcWork + i);

    // It's already in ListView coordinate if we just have one monitor
    if (nWorkAreas > 1)
    {
        for(i = 0; i < nWorkAreas; i++)
        {
            MapWindowPoints(HWND_DESKTOP, hwndList, (LPPOINT)(&prcWork[i]), 2);
        }    
    }

    //Because the work areas change, update the grid size to reduce the gutter area.
    if(fUpgradeGridSize) //If we haven't done already!
    {
        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
        fRedraw = TRUE;
        UpdateGridSizes(TRUE, hwndList, nWorkAreas, prcWork, TRUE);
    }
    
    // We need to set the new work area before we call AdjustDesktopComponents below
    // because that function results in a refresh and that ends up setting
    // the work areas again to the same values.
    ListView_SetWorkAreas(hwndList, nWorkAreas, prcWork);

    if (fRedraw)
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);

    if (nWorkAreas == 1)
        MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)rcNewWork, 2 * nWorkAreas);

    //Move and size desktop components based on the new work areas.
    AdjustDesktopComponents((LPCRECT)rcNewWork, nWorkAreas, (LPCRECT)_rcOldMonitors, (LPCRECT)_rcOldWorkAreas, _nOldWork);

    // Backup the new Monitor rect's in _rcOldMonitors
    for (i = 0; i < _nMonitors; i++)
    {
        GetMonitorRect(_hMonitors[i], &_rcOldMonitors[i]);
    }
    // Backup the new workareas in _rcOldWorkAreas
    for (i = 0; i < nWorkAreas; i++)
    {
        _rcOldWorkAreas[i] = rcNewWork[i];
    }
    _nOldWork = nWorkAreas;

    static const LPTSTR lpszSubkey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ScreenResFixer");
    static const LPTSTR lpszValue = TEXT("AdjustRecycleBinPosition");
    //Check if we need to change the recycle bin position because of this work-area change
    // 0 => Recycle-bin hasn't been positioned because of resolution fixer.
    // 1 => Recycle-bin needs to be repositioned. It has't happened yet!
    // 2 => Recycle-bin has already been re-positioned. Nothing needs to be done here!
    DWORD dwAdjustPos = 2; //Assume that Recycle-bin has been already positioned.
    DWORD dwSize = sizeof(dwAdjustPos);
    
    SHRegGetUSValue(lpszSubkey, lpszValue, NULL, &dwAdjustPos, &dwSize, FALSE, &dwAdjustPos, dwSize);
    //If the AdjustRecycleBinPosition value has 1, that means we need to reposition recyclebin.
    if(dwAdjustPos == 1)
    {
        //Move the recycle-bin to default position
        SendMessage(_pbbd->_hwndView, WM_DSV_ADJUSTRECYCLEBINPOSITION, 0, 0);
        dwAdjustPos = 2; //We have moved this just now! No need to move it anymore!
        SHRegSetUSValue(lpszSubkey, lpszValue, REG_DWORD, &dwAdjustPos, sizeof(dwAdjustPos), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
    }
}

// Get all the view border rectangles (not including toolbars) for the monitors
// this is used for multi-monitor case only.  
void CDesktopBrowser::_GetViewBorderRects(int nRects, LPRECT prcBorders)
{
    int iMon;
    HMONITOR hmonTray;
    Tray_GetHMonitor(_hwndTray, &hmonTray);
    for (iMon = 0; iMon < min(_nMonitors, nRects); iMon++)
    {
        GetMonitorWorkArea(_hMonitors[iMon], &prcBorders[iMon]);
        if (hmonTray == _hMonitors[iMon])
        {
            _SubtractBottommostTray(&prcBorders[iMon]);
        }

        // Extract the border taken by all "frame" toolbars
        for (int itb=0; itb < _pbsInner->_GetToolbarCount(); itb++)
        {
            LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
            if (ptbi && ptbi->hMon == _hMonitors[iMon])
            {
                prcBorders[iMon].left += ptbi->rcBorderTool.left;
                prcBorders[iMon].top += ptbi->rcBorderTool.top;
                prcBorders[iMon].right -= ptbi->rcBorderTool.right;
                prcBorders[iMon].bottom -= ptbi->rcBorderTool.bottom;
            }
        }       
    }
}
HRESULT  CDesktopBrowser::_UpdateViewRectSize()
{
    HWND hwndView = _pbbd->_hwndView;
    if (!hwndView && ((hwndView = _pbbd->_hwndViewPending) == NULL))
        return S_FALSE;

    _pbsInner->_UpdateViewRectSize();

    if (_nMonitors <= 1)
    {
        RECT rcView, rcWork;
        GetViewRect(&rcView);
        rcWork.top = rcWork.left = 0;
        rcWork.right = RECTWIDTH(rcView);
        rcWork.bottom = RECTHEIGHT(rcView);
        _SetWorkAreas(1, &rcWork);
    }
    else
    {
        RECT rcWorks[LV_MAX_WORKAREAS];
        _GetViewBorderRects(_nMonitors, rcWorks);
        _SetWorkAreas(_nMonitors, rcWorks);
    }   

    return S_OK;
}

void CDesktopBrowser::_SetViewArea()
{
    //
    // Invalidate the cached work area size
    //
    ::SetRectEmpty(&_rcWorkArea);

    v_ShowHideChildWindows(FALSE);
}

// we get called here when new drives come and go;
// things like net connections, hot insertions, etc.

void _OnDeviceBroadcast(HWND hwnd, ULONG_PTR code, DEV_BROADCAST_HDR *pbh)
{
    // do a bunch of this stuff here in desktop so it only happens
    // once...

    switch (code)
    {
    case DBT_DEVICEREMOVECOMPLETE:      // drive or media went away
    case DBT_DEVICEARRIVAL:             // new drive or media (or UNC) has arrived
    case DBT_DEVICEQUERYREMOVE:         // drive or media about to go away
    case DBT_DEVICEQUERYREMOVEFAILED:   // drive or media didn't go away
    {
        BOOL fFilteredOut = FALSE;
        // Don't process if we are being shutdown...
        if (!IsWindowVisible(hwnd))
            break;

        // Filter this one out
        if (DBT_DEVICEARRIVAL == code)
        {
            if (DBT_DEVTYP_NET == pbh->dbch_devicetype)
            {
                LPITEMIDLIST pidl;
                // Tell the hood to update as things have probably changed!
                // PERF: this can be slow in the case of the nethood FS folder
                // no longer exists. this hangs the desktop/tray. this is a robustness bug
                if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETHOOD, &pidl)))
                {
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, NULL);
                    SHFree(pidl);
                }
                // use UNCToNetID(loop if (pbn->dbcn_resource)             

                fFilteredOut = TRUE;
            }
        }

        if (!fFilteredOut)
        {
            CMountPoint::HandleWMDeviceChange(code, pbh);
        }

        break;
    }
    }
}

// Note: this overrides the one in CBaseBrowser
HRESULT CDesktopBrowser::GetViewRect(RECT* prc)
{
    //
    // Check if we are on a multiple-monitor system.  In multiple monitors the
    // view needs to cover all displays (ie the size of _pbbd->_hwnd) while on
    // single-monitor systems the view just needs to cover the work area (like
    // in Win95).
    //
    if (_nMonitors <= 1)
        _pbsInner->GetViewRect(prc);
    else
        GetClientRect(_pbbd->_hwnd, prc);

    return S_OK;
}

HRESULT CDesktopBrowser::ReleaseShellView()
{
    _SaveState();

    return _pbsInner->ReleaseShellView();
}

void CDesktopBrowser::_ViewChange(DWORD dwAspect, LONG lindex)
{
    // do nothing here...
}

void CDesktopBrowser::_SaveDesktopToolbars()
{
    IStream * pstm = GetDesktopViewStream(STGM_WRITE, TEXT("Toolbars"));
    if (pstm) 
    {
        _pbsInner->_SaveToolbars(pstm);
        pstm->Release();
    }
}

void CDesktopBrowser::_SaveState()
{
    // save off the Recycle Bin information to the registry
    SaveRecycleBinInfo();

    if (!SHRestricted(REST_NOSAVESET) && _pbbd->_psv)
    {
        if (0 == GetSystemMetrics(SM_CLEANBOOT))
        {
            FOLDERSETTINGS fs;
            _pbbd->_psv->GetCurrentInfo(&fs);

            IPropertyBag* ppb;
            if (SUCCEEDED(GetPropertyBag(SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                SHPropertyBag_WriteInt(ppb, VS_PROPSTR_FFLAGS, fs.fFlags);
                ppb->Release();
            }
        }
        _pbbd->_psv->SaveViewState();

        _SaveDesktopToolbars();
    }
}

HRESULT CDesktopBrowser::OnSize(WPARAM wParam)
{
    if (wParam == SIZE_MINIMIZED)
    {
        TraceMsg(DM_TRACE, "c.dwp: Desktop minimized by somebody!");
        // Put it back.
        ShowWindow(_pbbd->_hwnd, SW_RESTORE);
    }
    _SetViewArea();
    
    return S_OK;
}

HRESULT CDesktopBrowser::OnDestroy()
{
    TraceMsg(DM_SHUTDOWN, "cdtb._od (WM_DESTROY)");

    if (_uNotifyID)
    {
        SHChangeNotifyDeregister(_uNotifyID);
        _uNotifyID = 0;
    }

    if (_hwndRaised) 
        DestroyWindow(_hwndRaised);

    //  get rid of the scheduler and the desktop tasks
    if (_psched)
    {
        _psched->RemoveTasks(TOID_Desktop, 0, TRUE);
        ATOMICRELEASE(_psched);
    }

    _pbsInner->OnDestroy();

    _pbsInner->_CloseAndReleaseToolbars(TRUE);
    
    return S_OK;
}

#define DM_SWAP DM_TRACE

void CDesktopBrowser::_SwapParents(HWND hwndOldParent, HWND hwndNewParent)
{
    HWND hwnd = ::GetWindow(hwndOldParent, GW_CHILD);
    while (hwnd) 
    {
        //
        //  Note that we must get the next sibling BEFORE we set the new
        // parent.
        //
        HWND hwndNext = ::GetWindow(hwnd, GW_HWNDNEXT);
        ::SetParent(hwnd, hwndNewParent);
        hwnd = hwndNext;
    }
}

LRESULT CDesktopBrowser::RaisedWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);

    return psb->_RaisedWndProc(uMsg, wParam, lParam);
}

LRESULT CDesktopBrowser::_RaisedWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
    case WM_ACTIVATE:
        break;
        
    case WM_SIZE:
        if (wParam == SIZE_MINIMIZED) 
            ShowWindow(_hwndRaised, SW_RESTORE);
        break;
        
    case WM_NOTIFY:
    case WM_ERASEBKGND:
        goto SendToDesktop;



    default:
        
        if (uMsg >= WM_USER) 
        {
SendToDesktop:
            return SendMessage(_pbbd->_hwnd, uMsg, wParam, lParam);
        } 
        else 
        {
            return ::SHDefWindowProc(_hwndRaised, uMsg, wParam, lParam);
        }
    }
    
    return 0;
}


void CDesktopBrowser::_Raise()
{
    RECT rc;
    HWND hwndDesktop = GetDesktopWindow();
    BOOL fLocked;
    HWND hwndLastActive = GetLastActivePopup(_pbbd->_hwnd);
    
    if (SHIsRestricted(NULL, REST_NODESKTOP))
        return;

    if (hwndLastActive != _pbbd->_hwnd) 
    {
        SetForegroundWindow(hwndLastActive);
        return;
    }

    if (!_hwndRaised)
        _hwndRaised = SHCreateWorkerWindow(RaisedWndProc, NULL, WS_EX_TOOLWINDOW, WS_POPUP | WS_CLIPCHILDREN, NULL, this);

    //SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    //rc.left = 0;  // need to always start from 0, 0 to get the wallpaper centered right
    //rc.top = 0;
    fLocked = LockWindowUpdate(hwndDesktop);
    _SwapParents(_pbbd->_hwnd, _hwndRaised);
    
    // set the view window to the bottom of the z order
    SetWindowPos(_pbbd->_hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    GetWindowRect(_pbbd->_hwnd, &rc);
    SetWindowPos(_hwndRaised, HWND_TOP, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_SHOWWINDOW);
    SetForegroundWindow(_hwndRaised);

    if (fLocked)
        LockWindowUpdate(NULL);

    THR(RegisterDragDrop(_hwndRaised, (IDropTarget *)this));
    SetFocus(_pbbd->_hwndView);
    //SetWindowPos(_hwndTray, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
    _fRaised = TRUE;
}

void CDesktopBrowser::_Lower()
{
    BOOL fLocked;

    fLocked = LockWindowUpdate(_hwndRaised);
    _SwapParents(_hwndRaised, _pbbd->_hwnd);

    // set the view window to the bottom of the z order
    SetWindowPos(_pbbd->_hwndView, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    ShowWindow(_hwndRaised, SW_HIDE);
    if (fLocked)
        LockWindowUpdate(NULL);
    RevokeDragDrop(_hwndRaised);
    _fRaised = FALSE;
}

void CDesktopBrowser::_OnRaise(WPARAM wParam, LPARAM lParam)
{
    VARIANTARG vaIn;

    VariantInit(&vaIn);
    vaIn.vt = VT_I4;
    vaIn.lVal = (DWORD) lParam;

    switch (lParam) {
        
    case DTRF_RAISE:
        _Raise();
        _ExecChildren(NULL, TRUE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
        break;
        
    case DTRF_LOWER:
        _ExecChildren(NULL, TRUE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
        _Lower();
        break;
    }

    VariantClear(&vaIn);

    if (!wParam) {
        wParam = (WPARAM)_hwndTray;
    }
    
    PostMessage((HWND)wParam, TM_DESKTOPSTATE, 0, _fRaised ? DTRF_RAISE : DTRF_LOWER);
}

BOOL CDesktopBrowser::_QueryHKCRChanged(HWND hwnd, DWORD *pdwCookie)
{
    //  we assume that the key has changed if 
    //  we were unable to init correctly
    BOOL fRet = TRUE;

    ASSERT(pdwCookie);
    
    if (_cChangeEvents)
    {
        DWORD dw = WaitForMultipleObjects(_cChangeEvents, _rghChangeEvents, FALSE, 0);

        dw -= WAIT_OBJECT_0;

        // Note: Since "dw" is a DWORD, an underflow in the line above
        // will result in dw becoming a huge value, so the test below will
        // fail.
        if (dw < _cChangeEvents)
        {

            //  this means the key changed...
            ResetEvent(_rghChangeEvents[dw]);
            _dwChangeCookie = GetTickCount();

            PostMessage(hwnd, DTM_SETUPAPPRAN, 0, NULL);
        }

        //
        //  if nothing has changed yet, or if nothing has changed
        //  since the client last checked,
        //  than this client doesnt need to update its cache
        //
        if (!_dwChangeCookie ||  (*pdwCookie && *pdwCookie  == _dwChangeCookie))
            fRet = FALSE;

        //  update the cookie
        *pdwCookie = _dwChangeCookie;
    }

    return fRet;
}

// This msg gets posted to us after a setup application runs so that we can
// fix things up.

void CDesktopBrowser::_SetupAppRan(WPARAM wParam, LPARAM lParam)
{
    // Lotus 123R5 sometimes gets confused when installing over IE4 and
    // they leave their country setting blank. Detect this case and put
    // in USA so that they at least boot.       
    {
        TCHAR szPath[MAX_PATH];
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        if (PathAppend(szPath, TEXT("123r5.ini")) && PathFileExistsAndAttributes(szPath, NULL))
        {
            TCHAR szData[100];
        
            GetPrivateProfileString(TEXT("Country"), TEXT("driver"), TEXT(""), szData, ARRAYSIZE(szData), TEXT("123r5.ini"));
            if (!szData[0])
            {
                WritePrivateProfileString(TEXT("Country"), TEXT("driver"), TEXT("L1WUSF"), TEXT("123r5.ini"));
            }
        }
    }

    //  this location in the registry is a good place to cache info
    //  that needs to be invalided once 
    SHDeleteKey(HKEY_CURRENT_USER, STRREG_DISCARDABLE STRREG_POSTSETUP);

    HKEY hk = SHGetShellKey(SHELLKEY_HKCULM_MUICACHE, NULL, FALSE);
    if (hk)
    {
        SHDeleteKeyA(hk, NULL);
        RegCloseKey(hk);
    }

    //  Take this opportunity to freshen our component categories cache:
    IShellTaskScheduler* pScheduler ;
    if(SUCCEEDED(CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                     IID_PPV_ARG(IShellTaskScheduler, &pScheduler))))
    {
#ifdef _WIN64
        // Before creating 64-bit component cache, we should delete the 32-bit cache,
        // because we used to erroneously cache 64-bit components in the 32-bit cache,
        // and it won't get rebuilt with correc 32-bit components unless we delete it now.
        SHDeleteKey(HKEY_CURRENT_USER, STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories"));
#endif
        IRunnableTask* pTask ;
        if(SUCCEEDED(CoCreateInstance(CLSID_ComCatCacheTask, NULL, CLSCTX_INPROC_SERVER,
                                         IID_PPV_ARG(IRunnableTask, &pTask))))
        {
            pScheduler->AddTask(pTask, CLSID_ComCatCacheTask, 0L, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();  // Scheduler has AddRef'd him
        }

        if (SUCCEEDED(CTaskEnumHKCR_Create(&pTask)))
        {   
            pScheduler->AddTask(pTask, CLSID_QueryAssociations, 0L, ITSAT_DEFAULT_PRIORITY);
            pTask->Release();  // Scheduler has AddRef'd him
        }

        pScheduler->Release(); // OK to release global task scheduler.
    }


    // We get this notification from the OS that a setup app ran.
    //  Legacy app support for freshly written entries under [extensions] section;
    //  Scoop these up and shove into registry.   (re: bug 140986)
    CheckWinIniForAssocs();
}


//-----------------------------------------------------------------------------
struct propagatemsg
{
    UINT   uMsg;
    WPARAM wParam;
    LPARAM lParam;
    BOOL   fSend;
};

BOOL PropagateCallback(HWND hwndChild, LPARAM lParam)
{
    struct propagatemsg *pmsg = (struct propagatemsg*)lParam;
    if (pmsg->fSend)
        SendMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);
    else
        PostMessage(hwndChild, pmsg->uMsg, pmsg->wParam, pmsg->lParam);

    return TRUE;
}

void PropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    if (!hwndParent)
        return;

    struct propagatemsg msg = { uMsg, wParam, lParam, fSend };

    EnumChildWindows(hwndParent, PropagateCallback, (LPARAM)&msg);
}

void CDesktopBrowser::v_PropagateMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend)
{
    // WARNING: We can't propagate the message to a NULL hwnd because it will
    // turn into a broadcast.  This will come back to us and we will re-send it
    // causing an infinite loop.  BryanSt.
    if (_fRaised && _hwndRaised)
        PropagateMessage(_hwndRaised, uMsg, wParam, lParam, fSend);
    else if (_pbbd->_hwnd)
        PropagateMessage(_pbbd->_hwnd, uMsg, wParam, lParam, fSend);
}

//***
// NOTES
//  in the tray case, we actually do SetFocus etc.
HRESULT CDesktopBrowser::v_MayGetNextToolbarFocus(LPMSG lpMsg,
    UINT itbCur, int citb,
    LPTOOLBARITEM * pptbi, HWND * phwnd)
{
    HRESULT hr;

    // _fTrayHack?

    if (itbCur == ITB_VIEW) {
        if (citb == -1) {
            TraceMsg(DM_FOCUS, "cdtb.v_mgntf: ITB_VIEW,-1 => tray");
            goto Ltray;
        }
    }

    hr = _pbsInner->v_MayGetNextToolbarFocus(lpMsg, itbCur, citb, pptbi, phwnd);
    TraceMsg(DM_FOCUS, "cdtb.v_mgntf: SUPER hr=%x", hr);
    if (SUCCEEDED(hr)) {
        // S_OK: we got and handled a candidate
        // S_FALSE: we got a candidate and our parent will finish up
        ASSERT(hr != S_OK);  // currently never happens (but should work)
        return hr;
    }

    // E_xxx: no candidate
    ASSERT(citb == 1 || citb == -1);
    *pptbi = NULL;
    if (citb == 1) {
Ltray:
        *phwnd = _hwndTray;
        // AndyP REVIEW: why do we do this here instead of overriding
        // _SetFocus and letting commonsb call that function? Sure, this
        // is one less override, but why have different code paths?
        SendMessage(_hwndTray, TM_UIACTIVATEIO, TRUE, citb);
        return S_OK;
    }
    else 
    {
//Lview:
        *phwnd = _pbbd->_hwndView;
        return S_FALSE;
    }
    /*NOTREACHED*/
    ASSERT(0);
}

//
// NOTE: Please think before calling this function, in a multi-monitor system this function
// returns TRUE if you are within a certain edge for any monitor, so puEdge means puEdge
// of a certain monitor instead of the whole desktop. -- dli
//
BOOL CDesktopBrowser::_PtOnDesktopEdge(POINTL* ppt, LPUINT puEdge)
{
    RECT rcMonitor;
    POINT pt = {ppt->x, ppt->y};
    HMONITOR hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL);
    // We got this point from drop, so it definitely should belong to a valid monitor -- dli
    ASSERT(hMon);
    GetMonitorRect(hMon, &rcMonitor); 

    // if it's near/on the edge on this monitor
    if (ppt->x < rcMonitor.left + g_cxEdge) {
        *puEdge = ABE_LEFT;
    } else if (ppt->x > rcMonitor.right - g_cxEdge) {
        *puEdge = ABE_RIGHT;
    } else if (ppt->y < rcMonitor.top + g_cyEdge) {
        *puEdge = ABE_TOP;
    } else if (ppt->y > rcMonitor.bottom - g_cyEdge) {
        *puEdge = ABE_BOTTOM;
    } else {
        *puEdge = (UINT)-1;
        return FALSE;
    }
    return TRUE;
}

UINT g_cfDeskBand = 0;

HRESULT CDesktopBrowser::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    if (!g_cfDeskBand)
        g_cfDeskBand = RegisterClipboardFormat(TEXT("DeskBand"));

    FORMATETC fmte = { (CLIPFORMAT) g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
    if (pdtobj->QueryGetData(&fmte) == S_OK) {
        _dwEffectOnEdge = DROPEFFECT_COPY | DROPEFFECT_MOVE;
    } else {
        _dwEffectOnEdge = DROPEFFECT_NONE;
    }
    
    _grfKeyState = grfKeyState;

    HRESULT hr;

    if (_pdtInner)
        hr = _pdtInner->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
    else
    {
        DAD_DragEnterEx3(_pbbd->_hwndView, ptl, pdtobj);
        hr = S_OK;
    }

    return hr;
}

HRESULT CDesktopBrowser::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    HRESULT hr = S_OK;
    DAD_DragMoveEx(_pbbd->_hwndView, ptl);
    _grfKeyState = grfKeyState;
    
    if (_dwEffectOnEdge != DROPEFFECT_NONE) {
        *pdwEffect &= _dwEffectOnEdge;
        return S_OK;
    }

    if (_pdtInner)
        hr = _pdtInner->DragOver(grfKeyState, ptl, pdwEffect);
    
    return hr;
    
}

HRESULT DeskBarApp_Create(IUnknown** ppunkBar, IUnknown** ppunkBandSite)
{
    IDeskBar* pdb;
    HRESULT hres = CoCreateInstance(CLSID_DeskBarApp, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBar, &pdb));
    *ppunkBar = pdb;
    if (SUCCEEDED(hres)) 
    {
        pdb->GetClient(ppunkBandSite);
    }
    return hres;
}

//***
// ENTRY/EXIT
//  hres        AddBand result on success; o.w. failure code
// NOTES
//  n.b. on success we *must* return AddBand's hres (which is a dwBandID)
HRESULT CDesktopBrowser::_CreateDeskBarForBand(UINT uEdge, IUnknown *punk, POINTL *pptl, IBandSite **ppbsOut)
{
    IBandSite *pbs;
    IUnknown *punkBar;
    IUnknown *punkBandSite;
    HRESULT hres;
#ifdef DEBUG
    HRESULT hresRet = -1;
#endif

    if (ppbsOut)
        *ppbsOut = NULL;

    hres = DeskBarApp_Create(&punkBar, &punkBandSite);
    if (SUCCEEDED(hres))
    {
        IDockingBarPropertyBagInit* ppbi;

        if (SUCCEEDED(CoCreateInstance(CLSID_CDockingBarPropertyBag, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IDockingBarPropertyBagInit, &ppbi))))
        {
            if ((UINT)uEdge != -1) 
            {
                ppbi->SetDataDWORD(PROPDATA_MODE, WBM_BOTTOMMOST);
                ppbi->SetDataDWORD(PROPDATA_SIDE, uEdge);
            }
            else 
            {
                ppbi->SetDataDWORD(PROPDATA_MODE, WBM_FLOATING);
            }

            ppbi->SetDataDWORD(PROPDATA_X, pptl->x);
            ppbi->SetDataDWORD(PROPDATA_Y, pptl->y);
            
            IPropertyBag * ppb;
            if (SUCCEEDED(ppbi->QueryInterface(IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                SHLoadFromPropertyBag(punkBar, ppb);

                punkBandSite->QueryInterface(IID_PPV_ARG(IBandSite, &pbs));

                if (pbs) 
                {
                    hres = pbs->AddBand(punk);
#ifdef DEBUG
                    hresRet = hres;
#endif
                    AddToolbar(punkBar, L"", NULL);

                    if (ppbsOut) 
                    {
                        // IUnknown_Set (sort of...)
                        *ppbsOut = pbs;
                        (*ppbsOut)->AddRef();
                    }

                    pbs->Release();

                    if (_fRaised) 
                    {
                        VARIANTARG vaIn = { 0 };

                        vaIn.vt = VT_I4;
                        vaIn.lVal = DTRF_RAISE;

                        ASSERT(punkBar != NULL);    // o.w. we'd do a broadcast
                        _ExecChildren(punkBar, FALSE, &CGID_ShellDocView, SHDVID_RAISE, 0, &vaIn, NULL);
                    }
                }

                ppb->Release();
            }

            ppbi->Release();
        }

        punkBandSite->Release();
        punkBar->Release();        
    }
    
    ASSERT(hres == hresRet || FAILED(hres));
    return hres;
}

HRESULT CDesktopBrowser::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    UINT uEdge;
    HRESULT hres = E_FAIL;
    
    if (((_PtOnDesktopEdge(&pt, &uEdge) && (_grfKeyState & MK_LBUTTON)) ||
        (_dwEffectOnEdge != DROPEFFECT_NONE)) && !SHRestricted(REST_NOCLOSE_DRAGDROPBAND)) 
    {
        // if the point is on the edge of the desktop and the item dropped was 
        // a single url object, then create a webbar
        // TODO: (reuse) w/ a little restructuring we might share this code
        // w/ CBandSite::Drop etc.

        FORMATETC fmte = {(CLIPFORMAT)g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        STGMEDIUM stg;
        LPITEMIDLIST pidl;
        IUnknown* punk = NULL;

        // we can move a band from bar to bar, but we can only copy or link a folder
        // because the creation of a band relies on the source still abeing there
        if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE)) &&
            SUCCEEDED(pdtobj->GetData(&fmte, &stg))) 
        {
            // this is a drag of a band from another bar, create it!
            hres = OleLoadFromStream(stg.pstm, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hres)) 
            {
                if (*pdwEffect & DROPEFFECT_COPY)
                    *pdwEffect = DROPEFFECT_COPY;
                else 
                    *pdwEffect = DROPEFFECT_MOVE;
            }
            ReleaseStgMedium(&stg);

        } 
        else if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK)) &&
                   SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0))) 
        {
            hres = SHCreateBandForPidl(pidl, &punk, (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT));
            ILFree(pidl);

            if (SUCCEEDED(hres)) 
            {
                if (*pdwEffect & DROPEFFECT_LINK)
                    *pdwEffect = DROPEFFECT_LINK;
                else
                    *pdwEffect = DROPEFFECT_COPY;
            }

        }

        if (SUCCEEDED(hres)) 
        {
            if (punk) 
            {
                BOOL fCreateRebarWindow = TRUE;

                IDeskBandEx* pdbex;
                if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBandEx, &pdbex))))
                {
                    fCreateRebarWindow = (pdbex->MoveBand() == S_OK) ? TRUE : FALSE;
                    pdbex->Release();
                }

                if (fCreateRebarWindow)
                {
                    IBandSite *pbs;
                    hres = _CreateDeskBarForBand(uEdge, punk, &pt, &pbs);
                    if (SUCCEEDED(hres)) 
                    {
                        DWORD dwState = IDataObject_GetDeskBandState(pdtobj);
                        pbs->SetBandState(ShortFromResult(hres), BSSF_NOTITLE, dwState & BSSF_NOTITLE);
                        pbs->Release();
                    }
                    punk->Release();
                }
            }

            IDropTarget *pdtView;
            HRESULT hr = E_FAIL;

            //Get the view's drop target 
            if (_pbbd->_psv)
            {
                hr = _pbbd->_psv->QueryInterface(IID_PPV_ARG(IDropTarget, &pdtView));
                if (SUCCEEDED(hr))
                {
                   pdtView->DragLeave();
                   pdtView->Release();
                }
            }
            return hres; 
        }


        // if we failed, pass this on to our child.
        // this allows things like d/d of wallpaper to the edge to do 
        // right thing
    } 
    
    if (_pdtInner)
        hres = _pdtInner->Drop(pdtobj, grfKeyState, pt, pdwEffect);
    
    return hres;
} 

BOOL CDesktopBrowser::_OnCopyData(PCOPYDATASTRUCT pcds)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, (ULONG)pcds->dwData, NULL, NULL);
    if (piei)
    {
        LPCWSTR pwszSrc = (LPCWSTR)pcds->lpData;
        LPCWSTR pwszDdeRegEvent = NULL;
        LPCWSTR pwszCloseEvent = NULL;
        DWORD cchSrc = pcds->cbData / sizeof(WCHAR);

        piei->uFlags = COF_NORMAL | COF_WAITFORPENDING | COF_IEXPLORE;

        //
        // Remember where the command line parameters are.
        //
        LPCWSTR pszCmd = pwszSrc;
        int cch = lstrlenW(pwszSrc) + 1;
        pwszSrc += cch;
        cchSrc -= cch;

        TraceMsg(TF_SHDAUTO, "CDB::_OnCopyData got %hs", pszCmd);

        //
        // Get the dde reg event name into piei->szDdeRegEvent.
        //

        // NOTE: this is now conditional because we now launch the channel band from the desktop
        // NOTE: as a fake WM_COPYDATA command
        if (cchSrc)
        {
            ASSERT(cchSrc);
            pwszDdeRegEvent = pwszSrc;
            StrCpyNW(piei->szDdeRegEvent, pwszSrc, ARRAYSIZE(piei->szDdeRegEvent));
            cch = lstrlenW(pwszSrc) + 1;
            pwszSrc += cch;
            cchSrc -= cch;
            piei->uFlags |= COF_FIREEVENTONDDEREG;
            
            //
            // Get the name of the event to fire on close, if any.
            //
            if (cchSrc)
            {
                pwszCloseEvent = pwszSrc;
                StrCpyNW(piei->szCloseEvent, pwszSrc, ARRAYSIZE(piei->szCloseEvent));
                cch = lstrlenW(pwszSrc) + 1;
                pwszSrc += cch;
                cchSrc -= cch;
                piei->uFlags |= COF_FIREEVENTONCLOSE;
                
            }
        }
        
        ASSERT(cchSrc == 0);

        if (pszCmd && pszCmd[0])
        {
            // for compatibility with apps that spawn the browser with a command line
            // tell wininet to refresh its proxy settings. (this is particularly needed
            // for TravelSoft WebEx)
            MyInternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
            
            if (SHParseIECommandLine(&pszCmd, piei))
                piei->uFlags |= COF_NOFINDWINDOW;
            
            if (pszCmd[0] && FAILED(_ConvertPathToPidlW(_pbsInner, _pbbd->_hwnd, pszCmd, &piei->pidl)))
                piei->pidl = NULL;
        }
        else
        {
            piei->fCheckFirstOpen = TRUE;
        }

        // SHOpenFolderWindow takes ownership of piei
        BOOL fRes = SHOpenFolderWindow(piei);
        if (!fRes)
        {
            //
            // Something went wrong creating the browser,
            // let's fire all the events ourselves.
            //
            if (pwszDdeRegEvent) 
                FireEventSz(pwszDdeRegEvent);
            if (pwszCloseEvent) 
                FireEventSz(pwszCloseEvent);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "OnCopyData unable to create IETHREADPARAM");
    }

    return TRUE;
}

BOOL CDesktopBrowser::_InitScheduler(void)
{
    if (!_psched)
    {
        // get the system background scheduler thread
        CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC,
                         IID_PPV_ARG(IShellTaskScheduler, &_psched));

    }
    return (_psched != NULL);
}
    

HRESULT CDesktopBrowser::_AddDesktopTask(IRunnableTask *ptask, DWORD dwPriority)
{
    if (_InitScheduler())
        return _psched->AddTask(ptask, TOID_Desktop, 0, dwPriority);

    return E_FAIL;
}

void CDesktopBrowser::_OnAddToRecent(HANDLE hMem, DWORD dwProcId)
{
    IRunnableTask *ptask;
    if (SUCCEEDED(CTaskAddDoc_Create(hMem, dwProcId, &ptask)))
    {
        _AddDesktopTask(ptask, ITSAT_DEFAULT_PRIORITY);
        ptask->Release();
    }
}

//
// local server handling
//

DWORD WINAPI _LocalServerThread(void *pv)
{
    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)pv;
    CLSID clsid = *c_localServers[ptd->iLocalServer];

    IUnknown *punk;
    if (SUCCEEDED(DllGetClassObject(clsid, IID_PPV_ARG(IUnknown, &punk))))
    {
        DWORD dwReg;
        if (SUCCEEDED(CoRegisterClassObject(clsid, punk, CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &dwReg)))
        {
            __try 
            {
                MSG msg;
            
                while(GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                //  we only send the message on an exception,
                //  because otherwise we got a WM_QUIT which 
                //  means the desktop is being destroyed.
                PostMessage(GetShellWindow(), CWM_CREATELOCALSERVER, FALSE, ptd->iLocalServer);
            }

            CoRevokeClassObject(dwReg);
        }
    }

    LocalFree(ptd);
    return 0;
}

DWORD WINAPI _SetThreadID(void *pv)
{
    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)pv;
    *ptd->pdwThreadID = GetCurrentThreadId();
    return 0;
}


STDAPI_(HWND) SCNGetWindow(BOOL fUseDesktop);

LRESULT CDesktopBrowser::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INSTRUMENT_WNDPROC(SHCNFI_DESKTOP_WNDPROC, _pbbd->_hwnd, uMsg, wParam, lParam);
    ASSERT(IsWindowTchar(hwnd));

    switch (uMsg)
    {
#ifdef DEBUG
    case WM_QUERYENDSESSION:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_QUERYENDSESSION");
        goto DoDefault;
#endif

    case WM_ENDSESSION:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_ENDSESSION wP=%d lP=%d", wParam, lParam);
        if (wParam)
        {
#ifdef DEBUG
            // call out inner an give him a chance to set _fMightBeShuttingDown so we
            // don't assert later on in the case where the system is shutting down
            _pbsInner->WndProcBS(hwnd, uMsg, wParam, lParam);
#endif
            SHELLSTATE ss = {0};
            // When we shut down, if the desktop is in WebView, we leave some temp
            // files undeleted because we never get the WM_DESTROY message below.
            // So, I just destroy the shellview which in turn destroys the temp
            // file here. Note: This is done only if we are in web view.

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); //Get the desktop_html flag
            if (ss.fDesktopHTML)
            {
                ReleaseShellView();
            }

            g_pdtray->SetVar(SVTRAY_EXITEXPLORER, FALSE);   // don't exit process

            // flush log before we exit
            if (StopWatchMode())
            {
                StopWatchFlush();
            }

            // Kill this window so that we free active desktop threads properly
            DestroyWindow(hwnd);
        }
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: WM_ENDSESSION return 0");
        break;

    case WM_ERASEBKGND:
        PaintDesktop((HDC)wParam);
        return 1;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_DDETIMEOUT:
            DDEHandleTimeout(_pbbd->_hwnd);
            break;

        case IDT_ENUMHKCR:
            KillTimer(_pbbd->_hwnd, IDT_ENUMHKCR);
            {
                IShellTaskScheduler* pScheduler ;
                if(SUCCEEDED(CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                                 IID_PPV_ARG(IShellTaskScheduler, &pScheduler))))
                {
                    IRunnableTask* pTask ;
                    if (SUCCEEDED(CTaskEnumHKCR_Create(&pTask)))
                    {   
                        pScheduler->AddTask(pTask, CLSID_QueryAssociations, 0L, ITSAT_DEFAULT_PRIORITY);
                        pTask->Release();  // Scheduler has AddRef'd him
                    }

                    pScheduler->Release(); // OK to release global task scheduler.
                }
            }
            break;
        default:
            goto DoDefault;
            break;
        }
        break;

    case WM_SHELLNOTIFY:
        switch(wParam)
        {
        case SHELLNOTIFY_WALLPAPERCHANGED:
            // this is done only to the shell window when someone sets
            // the wall paper but doesn't specify to broadcast
            _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
        //
        // in Win95 the desktop wndproc will invalidate the shell window when
        // a palette change occurs so we didn't have to do anything here before
        //
        // in Nashville the desktop can be HTML and needs the palette messages
        //
        // so now we fall through and propagate...
        //
    case WM_ACTIVATEAPP:
        if (!_pbbd->_hwndView)
            goto DoDefault;

        return _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);

    case WM_DEVICECHANGE:
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        _OnDeviceBroadcast(_pbbd->_hwnd, wParam, (DEV_BROADCAST_HDR *)lParam);
        goto DoDefault;

    case WM_WINDOWPOSCHANGING:
        #define ppos ((LPWINDOWPOS)lParam)
        ppos->x = g_xVirtualScreen;
        ppos->y = g_yVirtualScreen;
        ppos->cx = g_cxVirtualScreen;
        ppos->cy = g_cyVirtualScreen;
        break;

    case WM_HOTKEY:
        // NOTE: forward hotkeys to the tray. This fixes the logitech mouseman who sends 
        // NOTE: hotkeys directly to the desktop. 
        // SPECIAL NOTE: the offset for GHID_FIRST is added because hotkeys that are sent to the
        // SPECIAL NOTE: desktop are not proper hotkeys generated from the keyboard, they are
        // SPECIAL NOTE: sent by an app, and the IDs have changed since win95....
        ASSERT(g_hwndTray);
        ASSERT(wParam < GHID_FIRST);
        PostMessage(g_hwndTray, uMsg, wParam + GHID_FIRST, lParam);
        return 0;
        
    case WM_SYSCOMMAND:
        switch (wParam & 0xFFF0) {
        // NB Dashboard 1.0 sends a WM_SYSCOMMAND SC_CLOSE to the desktop when it starts up.
        // What it was trying to do was to close down any non-shell versions of Progman. The
        // proper shell version would just ignore the close. Under Chicago, they think that
        // the desktop is Progman and send it the close, so we put up the exit windows dialog!
        // Dashboard 2.0 has been fixed to avoid this bogisity.
        case SC_CLOSE:
            break;

        // America alive tries to minimise Progman after installing - they end up minimising
        // the desktop on Chicago!
        case SC_MINIMIZE:
            break;

        default:
            goto DoDefault;
        }
        break;

    case WM_SETCURSOR:
        // REVIEW: is this really needed?
        if (_iWaitCount)
        {
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        }
        else
            goto DoDefault;

    case WM_CLOSE:
        SendMessage(_hwndTray, TM_DOEXITWINDOWS, 0, 0);
        return 0;

        // REVIEW: do we need this, can all of these cases be the same?
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (!_pbsInner->ForwardViewMsg(uMsg, wParam, lParam))
            goto DoDefault;
        break;

    case WM_INITMENUPOPUP:
    case WM_ENTERMENULOOP:
    case WM_EXITMENULOOP:
        // let the fsview deal with any popup menus it created
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        break;

    // Looking at messages to try to capture when the workarea may
    // have changed...
    case WM_DISPLAYCHANGE:
        lParam = 0;
        if (GetNumberOfMonitors() != _nMonitors)
            _InitMonitors();
        
        // fall through

    case WM_WININICHANGE:
        _InitDesktopMetrics(wParam, (LPCTSTR)lParam);

        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            VARIANTARG varIn;
            VARIANTARG varOut = {0};
            varIn.vt = VT_BOOL;
            varIn.boolVal = VARIANT_TRUE;

            _pctInner->Exec(&CGID_Explorer, SBCMDID_CACHEINETZONEICON, OLECMDEXECOPT_DODEFAULT , &varIn, &varOut);
        }

        if (lParam)
        {
            if (lstrcmpi((LPCTSTR)lParam, TEXT("Extensions")) == 0)
            {
                // Post a message to our selves so we can do more stuff
                // slightly delayed.
                PostMessage(hwnd, DTM_SETUPAPPRAN, 0, 0);
            }
            else if (lstrcmpi((LPCTSTR)lParam, TEXT("ShellState")) == 0)
            {
                //  this should cover external apps changing
                //  our settings.
                SHRefreshSettings();
            }
            else
            {
                // SPI_GETICONTITLELONGFONT is broadcast from IE when the home page is changed.  We look for that so
                // we can be sure to update the MyCurrentHomePage component.
                if((wParam == SPI_SETDESKWALLPAPER) || (wParam == SPI_SETDESKPATTERN) || (wParam == SPI_GETICONTITLELOGFONT))
                {
                    // Some desktop attribute has changed. So, regenerate desktop.
                    if(lstrcmpi((LPCTSTR)lParam, TEXT("ToggleDesktop")) &&
                       lstrcmpi((LPCTSTR)lParam, TEXT("RefreshDesktop")) &&
                       lstrcmpi((LPCTSTR)lParam, TEXT("BufferedRefresh")))
                    {
                        DWORD dwFlags = AD_APPLY_HTMLGEN | AD_APPLY_REFRESH;

                        switch (wParam)
                        {
                            case SPI_SETDESKPATTERN:
                                dwFlags |= (AD_APPLY_FORCE | AD_APPLY_DYNAMICREFRESH);
                                break;
                            case SPI_SETDESKWALLPAPER:
                                dwFlags |= AD_APPLY_SAVE;
                                break;
                            case SPI_GETICONTITLELOGFONT:
                                dwFlags |= AD_APPLY_FORCE;
                                break;
                        }       

                        PokeWebViewDesktop(dwFlags);
                        
                        // If we are not currently in ActiveDesktop Mode, then we need to set the dirty bit
                        // sothat a new HTML file will be generated showing the new wallpaper,
                        // the next time the active desktop is turned ON!
                        if (wParam == SPI_SETDESKWALLPAPER)
                        {
                            SHELLSTATE ss = {0};
                            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); //Get the desktop_html flag
                            if (!ss.fDesktopHTML)
                                SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);
                        }
                    }
                }
            }
            
        }

        // control panel applet that allows users to change the
        // environment with-which to spawn new applications.  On NT, we need
        // to pick up that environment change so that anything we spawn in
        // the future will pick up those updated environment values.
        //
        if (lParam && (lstrcmpi((LPTSTR)lParam, TEXT("Environment")) == 0))
        {
            void *pv;
            RegenerateUserEnvironment(&pv, TRUE);
        }

        v_PropagateMessage(uMsg, wParam, lParam, TRUE);
        SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER);
        if ((uMsg == WM_DISPLAYCHANGE) || (wParam == SPI_SETWORKAREA))
            _SetViewArea();

        SHSettingsChanged(wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        //
        // In memphis, when apps go into low-res mode, we get this message. We should not re-generate
        // desktop.htt in this scenario, or else the centered wallpaper gets messed up because we do not
        // get the message when the app exists and the resoultion goes up. So, we make the following check.
        //
        if(!SHIsTempDisplayMode())
            OnDesktopSysColorChange();
        //This is done sothat the defview can set the listview in proper
        //colors.
        _pbsInner->ForwardViewMsg(uMsg, wParam, lParam);
        break;

    // Don't go to default wnd proc for this one...
    case WM_INPUTLANGCHANGEREQUEST:
        if (wParam)
            goto DoDefault;
        else
            return 0;

    case WM_COPYDATA:
        return _OnCopyData((PCOPYDATASTRUCT)lParam);

    case CWM_COMMANDLINE:
        SHOnCWMCommandLine(lParam);
        break;

    case CWM_GETSCNWINDOW:
        return (LRESULT) SCNGetWindow(FALSE);
        break;
        
    case CWM_ADDTORECENT:
        _OnAddToRecent((HANDLE)wParam, (DWORD) lParam);
        return 0;

    case CWM_WAITOP:
        SHWaitOp_Operate((HANDLE)wParam, (DWORD)lParam);
        return 0;

    case CWM_CREATELOCALSERVER:
    {
        // wParam = TRUE to create, FALSE to mark as terminated
        // lParam = (INT) index into LocalServer table

        INT i = (INT)lParam;
        if ((i >= 0) && (i < ARRAYSIZE(_idLocalServerThreads)))
        {
            if (wParam)
            {
                if (_idLocalServerThreads[i] == -1)
                {
                    LOCALSERVERDATA *ptd = (LOCALSERVERDATA *)LocalAlloc(LPTR, sizeof(*ptd));
                    if (ptd)
                    {
                        ptd->iLocalServer = i;
                        ptd->pdwThreadID = &_idLocalServerThreads[i];
                        if (!SHCreateThread(_LocalServerThread, ptd, CTF_COINIT, _SetThreadID))
                        {
                            LocalFree(ptd);
                        }
                    }
                }
            }
            else
            {
                _idLocalServerThreads[i] = -1;
            }
        }
        return 0;
    }

    case CWM_SHOWFOLDEROPT:
        switch (wParam)
        {
        case CWMW_FOLDEROPTIONS:  // appwiz.cpl used to send this message to us
                                  // now it's done by FolderOptionsRunDll
            DoGlobalFolderOptions();
            break;

        case CWMW_TASKBAROPTIONS: // TaskbarOptionsRunDll sends this message
            PostMessage(_hwndTray, TM_DOTRAYPROPERTIES, 0, 0);
            break;

        default:
            break;
        }
        return 0;

    case CWM_TASKBARWAKEUP:
        _dwThreadIdTray = (DWORD)wParam;
        if (_dwThreadIdTray)
        {
            _iTrayPriority = HIWORD(lParam);
            SetTimer(hwnd, IDT_TASKBARWAKEUP, LOWORD(lParam), NULL);
        }
        break;

    case DTM_CREATESAVEDWINDOWS:
        _InitDeskbars();
        SHCreateSavedWindows();
#ifdef ENABLE_CHANNELS
        _MaybeLaunchChannelBand();
#endif
        // we need to update the recycle bin icon because the recycle bin
        // is per user on NTFS, and thus the state could change w/ each new user
        // who logs in.
        SHUpdateRecycleBinIcon();
        break;
        
    case DTM_SAVESTATE:
        TraceMsg(DM_SHUTDOWN, "cdtb.wp: DTM_SAVESTATE");
        _SaveState();
        break;

    case DTM_RAISE:
        _OnRaise(wParam, lParam);
        break;
    
#ifdef DEBUG
    case DTM_NEXTCTL:
#endif
    case DTM_UIACTIVATEIO:
    case DTM_ONFOCUSCHANGEIS:
        _OnFocusMsg(uMsg, wParam, lParam);
        break;

    case DTM_SETUPAPPRAN:
        _SetupAppRan(wParam, lParam);
        break;

    case DTM_QUERYHKCRCHANGED:
        //  some clients are out of process, so we
        //  can cache their cookies for them.
        if (!lParam && wParam > QHKCRID_NONE && wParam < QHKCRID_MAX)
            lParam = (LPARAM)&_rgdwQHKCRCookies[wParam - QHKCRID_MIN];
            
        return _QueryHKCRChanged(hwnd, (LPDWORD)lParam);
        
    case DTM_UPDATENOW:
        UpdateWindow(hwnd);
        break;

    case DTM_GETVIEWAREAS:
        {
            // wParam is an in/out param. in - the max. # of areas, out - the actual # of areas.
            // if "in" value < "out" value, lParam is not set.
            // The ViewAreas are already stored in the desktop Listview.
            int* pnViewAreas = (int*) wParam;
            LPRECT lprcViewAreas = (LPRECT) lParam;

            if (pnViewAreas)
            {
                int nMaxAreas = *pnViewAreas;
                HWND hwndList = _GetDesktopListview();

                ASSERT(IsWindow(hwndList));
                ListView_GetNumberOfWorkAreas(hwndList, pnViewAreas);
                if (*pnViewAreas >= 0 && *pnViewAreas <= nMaxAreas && lprcViewAreas)
                {
                    ListView_GetWorkAreas(hwndList, *pnViewAreas, lprcViewAreas);
                    // These are in Listview co-ordinates. We have to map them to screen co-ordinates.
                    // [msadek]; MapWindowPoints() is mirroring-aware only if you pass two points
                    for (int i = 0; i <  *pnViewAreas; i++)
                    {
                        MapWindowPoints(hwndList, HWND_DESKTOP, (LPPOINT)(&lprcViewAreas[i]), 2);
                    }    
                }
            }
        }
        break;

    case DTM_MAKEHTMLCHANGES:
        //Make changes to desktop's HTML using Dynamic HTML
        SendMessage(_pbbd->_hwndView, WM_DSV_DESKHTML_CHANGES, wParam, lParam);
        break;

    case DTM_STARTPAGEONOFF:
        SendMessage(_pbbd->_hwndView, WM_DSV_STARTPAGE_TURNONOFF, wParam, lParam);
        break;

    case DTM_REFRESHACTIVEDESKTOP:
        // This message is posted to refresh active desktop in a delayed fashion.
        REFRESHACTIVEDESKTOP();
        break;

    case DTM_SETAPPSTARTCUR:
        {
            INotifyAppStart * pnasTop;
            HRESULT hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(INotifyAppStart, &pnasTop));
            if (SUCCEEDED(hr))
            {
                pnasTop->AppStarting();
                pnasTop->Release();
            }
        }
        break;


    // Handle DDE messages for badly written apps (that assume the shell's
    // window is of class Progman and called Program Manager.
    case WM_DDE_INITIATE:
    case WM_DDE_TERMINATE:
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_ACK:
    case WM_DDE_DATA:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_EXECUTE:
        return DDEHandleMsgs(_pbbd->_hwnd, uMsg, wParam, lParam);
        break;

    default:
        if (uMsg == GetDDEExecMsg())
        {
            ASSERT(lParam && 0 == ((LPNMHDR)lParam)->idFrom);

            DDEHandleViewFolderNotify(NULL, _pbbd->_hwnd, (LPNMVIEWFOLDER)lParam);
            LocalFree((LPNMVIEWFOLDER)lParam);
            return TRUE;
        }

DoDefault:
        return _pbsInner->WndProcBS(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

#ifdef ENABLE_CHANNELS
// launch the channelbar, this is called when the desktop has finished starting up.
const WCHAR c_szwChannelBand[] = L"-channelband";

void CDesktopBrowser::_MaybeLaunchChannelBand()
{
    DWORD dwType = REG_SZ;
    TCHAR  szYesOrNo[20];
    DWORD  cbSize = sizeof(szYesOrNo);
    
    BOOL bLaunchChannelBar = FALSE;
    
    if(SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("Show_ChannelBand"),
                           &dwType, (void *)szYesOrNo, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        bLaunchChannelBar = !lstrcmpi(szYesOrNo, TEXT("yes"));
    }
    // Don't launch by default post IE4
    //else if (IsOS(OS_WINDOWS))
    //{
    //    bLaunchChannelBar = TRUE;    // launch channel bar by default on Memphis and win95
    //}

    if (bLaunchChannelBar)
    {
         // fake up a WM_COPYDATA struct 
        COPYDATASTRUCT cds;
        cds.dwData = SW_NORMAL;
        cds.cbData = sizeof(c_szwChannelBand);
        cds.lpData = (void *) c_szwChannelBand;

        // fake it as if we had launched iexplore.exe, it saves us a whole process doing it this way....
        _OnCopyData(&cds);
    }
}
#endif // ENABLE_CHANNELS

//***
// NOTES
//  REARCHITECT should this be CBaseBrowser::IInputObject::UIActIO etc.?
HRESULT CDesktopBrowser::_OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fActivate = (BOOL) wParam;

    switch (uMsg) {
    case DTM_UIACTIVATEIO:
        fActivate = (BOOL) wParam;
        TraceMsg(DM_FOCUS, "cdtb.oxiois: DTM_UIActIO fAct=%d dtb=%d", fActivate, (int) lParam);

        if (fActivate) 
        {
            MSG msg = {_pbbd->_hwnd, WM_KEYDOWN, VK_TAB, 0xf0001};
            BOOL bShift = (GetAsyncKeyState(VK_SHIFT) < 0);
            if (bShift) 
            {
                int cToolbars = _pbsInner->_GetToolbarCount();
                while (--cToolbars >= 0) 
                {
                    // activate last toolbar in tab order
                    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(cToolbars);
                    if (ptbi && ptbi->ptbar) 
                    {
                        IInputObject* pio;
                        if (SUCCEEDED(ptbi->ptbar->QueryInterface(IID_PPV_ARG(IInputObject, &pio)))) 
                        {
                            pio->UIActivateIO(TRUE, &msg);
                            pio->Release();
                            return S_OK;
                        }
                    }
                }
            }

#ifdef KEYBOARDCUES
            // Since we are Tab or Shift Tab we should turn the focus rect on.
            SendMessage(_pbbd->_hwnd, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
                UISF_HIDEFOCUS), 0);
#endif

            // activate view
            if (bShift && _pbbd->_psv)
            {
                _pbbd->_psv->TranslateAccelerator(&msg);
            }
            else
            {
                _pbsInner->_SetFocus(NULL, _pbbd->_hwndView, NULL);
            }
        }
        else {
Ldeact:
            // if we don't have focus, we're fine;
            // if we do have focus, there's nothing we can do about it...
            /*NOTHING*/
            ;
#ifdef DEBUG
            TraceMsg(DM_FOCUS, "cdtb.oxiois: GetFocus()=%x _pbbd->_hwnd=%x _pbbd->_hwndView=%x", GetFocus(), _pbbd->_hwnd, _pbbd->_hwndView);
#endif
        }

        break;

    case DTM_ONFOCUSCHANGEIS:
        TraceMsg(DM_FOCUS, "cdtb.oxiois: DTM_OnFocChgIS hwnd=%x fAct=%d", (HWND) lParam, fActivate);

        if (fActivate) {
            // someone else is activating, so we need to deactivate
            goto Ldeact;
        }

        break;

    default:
        ASSERT(0);
        break;
    }

    return S_OK;
}

LRESULT CALLBACK CDesktopBrowser::DesktopWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_CREATE:
#ifdef KEYBOARDCUES
        // Initialize our keyboard cues bits
        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
#endif

        // Set the localized name of the Desktop so it can be used in Error messages
        // that have the desktop window as the title.
        if (EVAL(LoadStringW(HINST_THISDLL, IDS_DESKTOP, psb->_wzDesktopTitle, ARRAYSIZE(psb->_wzDesktopTitle))))
        {
            EVAL(SetProp(hwnd, TEXT("pszDesktopTitleW"), (HANDLE)psb->_wzDesktopTitle));
        }

        if (psb)
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam); // known charset

#ifdef KEYBOARDCUES
    case WM_ACTIVATE:
        if (WA_INACTIVE == LOWORD(wParam))
        {
            SendMessage(hwnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }

        goto DoDefault;
        break;
#endif

    case WM_NCCREATE:

        ASSERT(psb == NULL);

        CDesktopBrowser_CreateInstance(hwnd, (void **)&psb);

        if (psb)
        {
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)psb);
            goto DoDefault;
        }
        else
        {
            return FALSE;
        }
        break;

    case WM_TIMER:
        if (psb)
        {
            switch(wParam)
            {
                case IDT_STARTBACKGROUNDSHELLTASKS:
                    KillTimer(hwnd, IDT_STARTBACKGROUNDSHELLTASKS);
                    psb->StartBackgroundShellTasks();
                    break;
                case IDT_TASKBARWAKEUP:
                    KillTimer(hwnd, IDT_TASKBARWAKEUP);
                    psb->TaskbarWakeup();
                    break;
                default:
                    return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
                    break;
            }
        }
        break;

    case WM_NCDESTROY:

        if (psb)
        {
            RemoveProp(hwnd, TEXT("pszDesktopTitleW"));
            // In case someone does a get shell window and post a WM_QUIT, we need to 
            //  make sure that we also close down our other thread.
            TraceMsg(DM_SHUTDOWN, "cdtb.wp(WM_NCDESTROY): ?post WM_QUIT hwndTray=%x(IsWnd=%d)", psb->_hwndTray, IsWindow(psb->_hwndTray));
            if (psb->_hwndTray && IsWindow(psb->_hwndTray))
                PostMessage(psb->_hwndTray, WM_QUIT, 0, 0);
            psb->ReleaseShellView();
            psb->Release();
        }

        PostQuitMessage(0); // exit out message loop
        break;

    default:
        if (psb)
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        else {
DoDefault:
            return DefWindowProc(hwnd, uMsg, wParam, lParam); // known charset
        }
    }

    return 0;
}

void RegisterDesktopClass()
{
    WNDCLASS wc = {0};

    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CDesktopBrowser::DesktopWndProc;
    //wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(void *);
    wc.hInstance = HINST_THISDLL;
    //wc.hIcon = NULL;
    wc.hCursor = GetClassCursor(GetDesktopWindow());
    wc.hbrBackground = (HBRUSH)(COLOR_DESKTOP + 1);
    //wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT(STR_DESKTOPCLASS);

    RegisterClass(&wc);
}

#define PEEK_NORMAL     0
#define PEEK_QUIT       1
#define PEEK_CONTINUE   2
#define PEEK_CLOSE      3


// RETURNS BOOL whehter to continue the search or not.
// so FALSE means we've found one.
// TRUE means we haven't.
BOOL CALLBACK FindBrowserWindow_Callback(HWND hwnd, LPARAM lParam)
{
    if (IsExplorerWindow(hwnd) || IsFolderWindow(hwnd) || IsTrayWindow(hwnd)) 
    {
        DWORD dwProcID;
        GetWindowThreadProcessId(hwnd, &dwProcID);
        if (dwProcID == GetCurrentProcessId()) 
        {
            if (lParam)
                *((BOOL*)lParam) = TRUE;    // found one!
            return FALSE;   // stop search
        }
    }
    return TRUE;            // continue search
}

#define IsBrowserWindow(hwnd)  !FindBrowserWindow_Callback(hwnd, NULL)

BOOL CALLBACK CloseWindow_Callback(HWND hwnd, LPARAM lParam)
{
    if (IsBrowserWindow(hwnd)) {
        TraceMsg(DM_SHUTDOWN, "s.cw_cb: post WM_CLOSE hwnd=%x", hwnd);
        PostMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return TRUE;
}


UINT CDesktopBrowser::_PeekForAMessage()
{
    MSG  msg;
    BOOL fPeek;

    fPeek =  PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    if (fPeek)
    {
        if (msg.message == WM_QUIT)
        {
            TraceMsg(DM_SHUTDOWN, "cdtb.pfam: WM_QUIT wP=%d [lP=%d]", msg.wParam, msg.lParam);
            if (msg.lParam == 1) 
            {
                return PEEK_CLOSE;
            }
            TraceMsg(DM_TRACE, "c.ml: Got quit message for %#08x", GetCurrentThreadId());
            return PEEK_QUIT;  // break all the way out of the main loop
        }

        if (_pbbd->_hwnd)
        {
            if (S_OK == _pbsInner->v_MayTranslateAccelerator(&msg))
                return PEEK_CONTINUE;
        }

        TranslateMessage(&msg);
        DispatchMessage(&msg);

        return PEEK_CONTINUE;   // Go back and get the next message
    }
    return PEEK_NORMAL;
}

void CDesktopBrowser::_MessageLoop()
{
    for (; ;)
    {
        switch (_PeekForAMessage())
        {
        case PEEK_QUIT:
            return;

        case PEEK_NORMAL:
        {
            static  BOOL    s_fSignaled = FALSE;

            if (!s_fSignaled)
            {
                FireEventSz(TEXT("msgina: ShellReadyEvent"));
                s_fSignaled = TRUE;
                PERFSETMARK("ExplorerDesktopReady");
            }
            WaitMessage();
            break;
        }
        case PEEK_CONTINUE:
            break;
            
        case PEEK_CLOSE:
            // we need to close all the shell windows too
            TraceMsg(DM_SHUTDOWN, "cdtb._ml: PEEK_CLOSE, close/wait all");
            EnumWindows(CloseWindow_Callback, 0);
            {
#define MAXIMUM_DESKTOP_WAIT 15000
                DWORD iStartTime = GetTickCount();
                // block until all other browser windows are closed
                for (;;) 
                {
                    BOOL f = FALSE;
                    EnumWindows(FindBrowserWindow_Callback, (LPARAM)&f);
                    if (!f || (GetTickCount() - iStartTime > MAXIMUM_DESKTOP_WAIT))
                        return;

                    switch (_PeekForAMessage()) 
                    {
                    case PEEK_NORMAL:
                        // don't do a waitmessage because we want to exit when thelast other window is gone
                        // and we don't get a message to signal that
                        Sleep(100);
                        break;
                    }
                }
            }
            return;
        }
    }
}

HRESULT CDesktopBrowser::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SShellDesktop))
        return QueryInterface(riid, ppvObj);

    return _pspInner->QueryService(guidService, riid, ppvObj);
}

void CDesktopBrowser::StartBackgroundShellTasks(void)
{
    HKEY hkey = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("SharedTaskScheduler"), FALSE);
    if (hkey)
    {
        TCHAR szClass[GUIDSTR_MAX];
        DWORD cchClass, dwType;
        int i = 0;
        while (cchClass = ARRAYSIZE(szClass),
               ERROR_SUCCESS == RegEnumValue(hkey, i++, szClass, &cchClass, NULL, &dwType, NULL, NULL))
        {
            CLSID clsid;
            if (SUCCEEDED(SHCLSIDFromString(szClass, &clsid)))
            {
                IRunnableTask* ptask;
                if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC, IID_PPV_ARG(IRunnableTask, &ptask))))
                {
                    // Personally I think the start menu should have priority
                    // over itbar icon extraction, so set this priority list
                    // a tad lower than the default priority (which start menu is at)
                    _AddDesktopTask(ptask, ITSAT_DEFAULT_PRIORITY-1);
                    ptask->Release();
                }
            }
        }
        RegCloseKey(hkey);
    }
}

void CDesktopBrowser::TaskbarWakeup(void)
{
    if (_dwThreadIdTray)
    {
        HANDLE hThread = OpenThread(THREAD_SET_INFORMATION, FALSE, _dwThreadIdTray);
        SetThreadPriority(hThread, _iTrayPriority);
        CloseHandle(hThread);
        _dwThreadIdTray = 0;
    }
}
    

// create the desktop window and its shell view
DWORD_PTR DesktopWindowCreate(CDesktopBrowser **ppBrowser)
{
    *ppBrowser = NULL;
    DWORD dwExStyle = WS_EX_TOOLWINDOW;

    OleInitialize(NULL);
    RegisterDesktopClass();

    _InitDesktopMetrics(0, NULL);

    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    //
    // NB This windows class is Progman and it's title is Program Manager. This makes
    // sure apps (like ATM) think that program is running and don't fail their install.
    //
    HWND hwnd = CreateWindowEx(dwExStyle, TEXT(STR_DESKTOPCLASS), TEXT("Program Manager"),
        WS_POPUP | WS_CLIPCHILDREN,
        g_xVirtualScreen, g_yVirtualScreen,
        g_cxVirtualScreen, g_cyVirtualScreen,
        NULL, NULL, HINST_THISDLL, NULL);

    // The returned hwnd can already be bogus if the system is shutting
    // down and user has somehow already called xxxDestroyWindow on us
    // even though we never even received a WM_NCCREATE!!
    // CreateWindowEx ends up returning a handle to a window that
    // has already been destroyed.  So in that case, act as if
    // CreateWindowEx failed (because it did!)
    if (!IsWindow(hwnd)) hwnd = NULL;

    if (hwnd)
    {
        CDesktopBrowser *psb = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);
        ASSERT(psb);

        if (!SHRestricted(REST_NODESKTOP))
        {
            // do this here to avoid painting the desktop, then repainting
            // when the tray appears and causes everything to move
            ShowWindow(hwnd, SW_SHOW);
            UpdateWindow(hwnd);
        }

        SetTimer(hwnd, IDT_STARTBACKGROUNDSHELLTASKS, 5 * 1000, NULL);
      
        *ppBrowser = (CDesktopBrowser*)GetWindowLongPtr(hwnd, 0);
    }

    return (DWORD_PTR)hwnd;
}

STDAPI_(HANDLE) SHCreateDesktop(IDeskTray* pdtray)
{
    if (g_dwProfileCAP & 0x00000010)
        StartCAP();

    ASSERT(pdtray);
    ASSERT(g_pdtray==NULL);
    g_pdtray = pdtray;
    pdtray->AddRef();   // this is no-op, but we want to follow the COM rule.

    // put the desktop on the main thread (this is needed for win95 so that
    // the DDeExecuteHack() in user.exe works, it needs the desktop and the 
    // DDE window on the mainthread
    CDesktopBrowser *pBrowser;
    if (DesktopWindowCreate(&pBrowser))
    {
        if (g_dwProfileCAP & 0x00040000)
            StopCAP();
    
        // hack, cast the object to a handle (otherwise we have to export the class
        // declaration so that explorer.exe can use it)
        return (HANDLE) pBrowser;
    }
    return NULL;
}

// nash:49485 (IME focus) and nash:nobug (win95 compat)
// make sure keyboard input goes to the desktop.  this is
// a) win95 compat: where focus was on win95 and
// b) nash:49485: focus was in the empty taskband on login so
// the keys went into the bitbucket
//
// If some other process has stolen the foreground window,
// don't be rude and grab it back.

void FriendlySetForegroundWindow(HWND hwnd)
{
    HWND hwndOld = GetForegroundWindow();
    if (hwndOld)
    {
        DWORD dwProcessId;
        
        GetWindowThreadProcessId(hwndOld, &dwProcessId);
        if (dwProcessId == GetCurrentProcessId())
            hwndOld = NULL;
    }
    if (!hwndOld)
        SetForegroundWindow(hwnd);
}

STDAPI_(BOOL) SHDesktopMessageLoop(HANDLE hDesktop)
{
    CDesktopBrowser *pBrowser = (CDesktopBrowser *) hDesktop;
    if (pBrowser)
    {
        // We must AddRef the pBrowser because _MessageLoop() will
        // Release() it if another app initiated a system shutdown.
        // We will do our own Release() when we don't need the pointer
        // any more.

        pBrowser->AddRef();

        FriendlySetForegroundWindow(pBrowser->GetDesktopWindow());

        pBrowser->_MessageLoop();

        IconCacheSave();

        // In case someone posted us a WM_QUIT message, before terminating
        // the thread, make sure it is properly destroyed so that trident etc
        // gets properly freed up.
        HWND hwnd = pBrowser->GetDesktopWindow();
        if (hwnd)
        {
            DestroyWindow(hwnd);
        }
        pBrowser->Release();
        OleUninitialize();

    }
    return BOOLFROMPTR(pBrowser);
}

//
// Whenever we remove the toolbar from the desktop, we persist it.
//
HRESULT CDesktopBrowser::RemoveToolbar(IUnknown* punkSrc, DWORD dwRemoveFlags)
{
    HRESULT hres = E_FAIL;
    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) 
    {
        return E_INVALIDARG;
    }

    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
    if (ptbi && ptbi->pwszItem) 
    {
        LPCWSTR szItem = ptbi->pwszItem;
        if (dwRemoveFlags & STFRF_DELETECONFIGDATA) 
        {
            DeleteDesktopViewStream(szItem);
        }
        else
        {
            IStream* pstm = GetDesktopViewStream(STGM_WRITE, szItem);
            if (pstm) 
            {
                IPersistStreamInit* ppstm;
                HRESULT hresT = punkSrc->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &ppstm));
                if (SUCCEEDED(hresT)) {
                    ppstm->Save(pstm, TRUE);
                    ppstm->Release();
                }
                pstm->Release();
            }
        }
    }

    hres = _pdwfInner->RemoveToolbar(punkSrc, dwRemoveFlags);
    _UpdateViewRectSize();
    return hres;
}

HRESULT CDesktopBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    BOOL bUseHmonitor = (GetNumberOfMonitors() > 1);
    return _pbsInner->_GetBorderDWHelper(punkSrc, lprectBorder, bUseHmonitor);    
}

HRESULT CDesktopBrowser::_ResizeNextBorder(UINT itb)
{
    _ResizeNextBorderHelper(itb, TRUE);
    return S_OK;
}

HRESULT CDesktopBrowser::GetMonitor(IUnknown* punkSrc, HMONITOR * phMon)
{
    ASSERT(phMon);
    *phMon = NULL;              // just in case

    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }

    LPTOOLBARITEM ptbi = _pbsInner->_GetToolbarItem(itb);
    if (ptbi) {
        *phMon = ptbi->hMon;
        return S_OK;
    } else {
        return E_FAIL;
    }
}

HRESULT CDesktopBrowser::RequestMonitor(IUnknown* punkSrc, HMONITOR * phMonitor)
{
    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }

    ASSERT(phMonitor);
    if (IsMonitorValid(*phMonitor))
        return S_OK;
    else
    {
        *phMonitor = GetPrimaryMonitor();
        return S_FALSE;
    }
}

HRESULT CDesktopBrowser::SetMonitor(IUnknown* punkSrc, HMONITOR hMonNew, HMONITOR * phMonOld)
{
    ASSERT(phMonOld);
    *phMonOld = NULL;           // just in case

    UINT itb = _pbsInner->_FindTBar(punkSrc);
    if (itb==(UINT)-1) {
        return E_INVALIDARG;
    }
    
    LPTOOLBARITEM ptbThis = _pbsInner->_GetToolbarItem(itb);
    if (ptbThis) {
        *phMonOld = ptbThis->hMon;
        ptbThis->hMon = hMonNew;
        return S_OK;
    } else {
        return E_FAIL;
    }
}

///////////////////////////////////////////////////////////////////////
//
// CDesktopBrowser FORWARDERS to commonsb
//

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _psbInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IShellBrowser (same as IOleInPlaceFrame)
CALL_INNER_HRESULT(GetWindow, (HWND * lphwnd), (lphwnd));
CALL_INNER_HRESULT(ContextSensitiveHelp, (BOOL fEnterMode), (fEnterMode));
CALL_INNER_HRESULT(InsertMenusSB, (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths), (hmenuShared, lpMenuWidths));
CALL_INNER_HRESULT(SetMenuSB, (HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd), (hmenuShared, holemenu, hwnd));
CALL_INNER_HRESULT(RemoveMenusSB, (HMENU hmenuShared), (hmenuShared));
CALL_INNER_HRESULT(SetStatusTextSB, (LPCOLESTR lpszStatusText), (lpszStatusText));
CALL_INNER_HRESULT(EnableModelessSB, (BOOL fEnable), (fEnable));
CALL_INNER_HRESULT(TranslateAcceleratorSB, (LPMSG lpmsg, WORD wID), (lpmsg, wID));
CALL_INNER_HRESULT(GetViewStateStream, (DWORD grfMode, LPSTREAM  *ppStrm), (grfMode, ppStrm));
CALL_INNER_HRESULT(GetControlWindow, (UINT id, HWND * lphwnd), (id, lphwnd));
CALL_INNER_HRESULT(SendControlMsg, (UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret), (id, uMsg, wParam, lParam, pret));
CALL_INNER_HRESULT(QueryActiveShellView, (struct IShellView ** ppshv), (ppshv));
CALL_INNER_HRESULT(OnViewWindowActive, (struct IShellView * ppshv), (ppshv));
CALL_INNER_HRESULT(SetToolbarItems, (LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags), (lpButtons, nButtons, uFlags));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdwsInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IDockingWindowSite
    // TODO: move these up from basesb to commonsb - requires toolbars
CALL_INNER_HRESULT(RequestBorderSpaceDW, (IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths), (punkSrc, pborderwidths));
CALL_INNER_HRESULT(SetBorderSpaceDW, (IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths), (punkSrc, pborderwidths));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }


// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdwfInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IDockingWindowFrame
CALL_INNER_HRESULT(AddToolbar, (IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved), (punkSrc, pwszItem, dwReserved));
CALL_INNER_HRESULT(FindToolbar, (LPCWSTR pwszItem, REFIID riid, void **ppvObj), (pwszItem, riid, ppvObj));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _piosInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IInputObjectSite
CALL_INNER_HRESULT(OnFocusChangeIS, (IUnknown* punkSrc, BOOL fSetFocus), (punkSrc, fSetFocus));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pdtInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // *** IDropTarget ***
CALL_INNER_HRESULT(DragLeave, (void), ());

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CDesktopBrowser:: _function _arglist { return _pbsInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)
 

// *** IBrowserService2 specific methods ***
CALL_INNER_HRESULT(GetParentSite, ( IOleInPlaceSite** ppipsite), ( ppipsite));
CALL_INNER_HRESULT(SetTitle, (IShellView* psv, LPCWSTR pszName), (psv, pszName));
CALL_INNER_HRESULT(GetTitle, (IShellView* psv, LPWSTR pszName, DWORD cchName), (psv, pszName, cchName));
CALL_INNER_HRESULT(GetOleObject, ( IOleObject** ppobjv), ( ppobjv));

// think about this one.. I'm not sure we want to expose this -- Chee
// My impression is that we won't document this whole interface???
CALL_INNER_HRESULT(GetTravelLog, (ITravelLog** pptl), (pptl));

CALL_INNER_HRESULT(ShowControlWindow, (UINT id, BOOL fShow), (id, fShow));
CALL_INNER_HRESULT(IsControlWindowShown, (UINT id, BOOL *pfShown), (id, pfShown));
CALL_INNER_HRESULT(IEGetDisplayName, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags), (pidl, pwszName, uFlags));
CALL_INNER_HRESULT(IEParseDisplayName, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut), (uiCP, pwszPath, ppidlOut));
CALL_INNER_HRESULT(DisplayParseError, (HRESULT hres, LPCWSTR pwszPath), (hres, pwszPath));
CALL_INNER_HRESULT(NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF), (pidl, grfHLNF));

CALL_INNER_HRESULT(SetNavigateState, (BNSTATE bnstate), (bnstate));
CALL_INNER_HRESULT(GetNavigateState,  (BNSTATE *pbnstate), (pbnstate));

CALL_INNER_HRESULT(NotifyRedirect,  ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse), ( psv, pidl, pfDidBrowse));
CALL_INNER_HRESULT(UpdateWindowList,  (), ());

CALL_INNER_HRESULT(UpdateBackForwardState,  (), ());

CALL_INNER_HRESULT(SetFlags, (DWORD dwFlags, DWORD dwFlagMask), (dwFlags, dwFlagMask));
CALL_INNER_HRESULT(GetFlags, (DWORD *pdwFlags), (pdwFlags));

// Tells if it can navigate now or not.
CALL_INNER_HRESULT(CanNavigateNow,  (), ());

CALL_INNER_HRESULT(GetPidl,  (LPITEMIDLIST *ppidl), (ppidl));
CALL_INNER_HRESULT(SetReferrer,  (LPITEMIDLIST pidl), (pidl));
CALL_INNER(DWORD,  GetBrowserIndex ,(), ());
CALL_INNER_HRESULT(GetBrowserByIndex, (DWORD dwID, IUnknown **ppunk), (dwID, ppunk));
CALL_INNER_HRESULT(GetHistoryObject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc), (ppole, pstm, ppbc));
CALL_INNER_HRESULT(SetHistoryObject, (IOleObject *pole, BOOL fIsLocalAnchor), (pole, fIsLocalAnchor));

CALL_INNER_HRESULT(CacheOLEServer, (IOleObject *pole), (pole));

CALL_INNER_HRESULT(GetSetCodePage, (VARIANT* pvarIn, VARIANT* pvarOut), (pvarIn, pvarOut));
CALL_INNER_HRESULT(OnHttpEquiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut), (psv, fDone, pvarargIn, pvarargOut));

CALL_INNER_HRESULT(GetPalette, ( HPALETTE * hpal), ( hpal));

CALL_INNER_HRESULT(OnSetFocus, (), ());
CALL_INNER_HRESULT(OnFrameWindowActivateBS, (BOOL fActive), (fActive));

CALL_INNER_HRESULT(RegisterWindow, (BOOL fUnregister, int swc), (fUnregister, swc));
CALL_INNER_HRESULT(GetBaseBrowserData,(LPCBASEBROWSERDATA* ppbd), (ppbd));
CALL_INNER(LPBASEBROWSERDATA, PutBaseBrowserData,(), ());
CALL_INNER_HRESULT(CreateViewWindow, (IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd), (psvNew, psvOld, prcView, phwnd));;
CALL_INNER_HRESULT(SetTopBrowser, (), ());
CALL_INNER_HRESULT(InitializeDownloadManager, (), ());
CALL_INNER_HRESULT(InitializeTransitionSite, (), ());
CALL_INNER_HRESULT(Offline, (int iCmd), (iCmd));
CALL_INNER_HRESULT(AllowViewResize, (BOOL f), (f));
CALL_INNER_HRESULT(SetActivateState, (UINT u), (u));
CALL_INNER_HRESULT(UpdateSecureLockIcon, (int eSecureLock), (eSecureLock));
CALL_INNER_HRESULT(CreateBrowserPropSheetExt, (REFIID riid, void **ppvObj), (riid, ppvObj));

CALL_INNER_HRESULT(GetViewWindow,(HWND * phwnd), (phwnd));
CALL_INNER_HRESULT(InitializeTravelLog,(ITravelLog* ptl, DWORD dw), (ptl, dw));

CALL_INNER_HRESULT(_UIActivateView, (UINT uState), (uState));

CALL_INNER_HRESULT(_ResizeView,(), ());

CALL_INNER_HRESULT(_ExecChildren, (IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut),
        (punkBar, fBroadcast, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
CALL_INNER_HRESULT(_SendChildren,
        (HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam),
        (hwndBar, fBroadcast, uMsg, wParam, lParam));

CALL_INNER_HRESULT(_OnFocusChange, (UINT itb), (itb));
CALL_INNER_HRESULT(v_ShowHideChildWindows, (BOOL fChildOnly), (fChildOnly));

CALL_INNER_HRESULT(_GetViewBorderRect, (RECT* prc), (prc));


    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
CALL_INNER_HRESULT(_CancelPendingNavigationAsync, (), ());
CALL_INNER_HRESULT(_MaySaveChanges, (), ()); 
CALL_INNER_HRESULT(_PauseOrResumeView, (BOOL fPaused), (fPaused));
CALL_INNER_HRESULT(_DisableModeless, (), ());
    
    // rethink these... are all of these necessary?
CALL_INNER_HRESULT(_NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags), (pidl, grfHLNF, dwFlags));
CALL_INNER_HRESULT(_TryShell2Rename, (IShellView* psv, LPCITEMIDLIST pidlNew), (psv, pidlNew));
CALL_INNER_HRESULT(_SwitchActivationNow, () , ());
CALL_INNER_HRESULT(_CancelPendingView, (), ());

    //END REVIEW:

CALL_INNER(UINT, _get_itbLastFocus, (), ());
CALL_INNER_HRESULT(_put_itbLastFocus, (UINT itbLastFocus), (itbLastFocus));

CALL_INNER_HRESULT(_ResizeNextBorderHelper, (UINT itb, BOOL bUseHmonitor), (itb, bUseHmonitor));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }



// RunDll32 entry point to create a new local server on the desktop
// thread.  We convert the CLSID to the index into the LocalServer list
// and then send it to the desktop, which inturn spins the thread off.

STDAPI_(void) SHCreateLocalServerRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    CLSID clsidLocalServer;
    if (GUIDFromStringA(pszCmdLine, &clsidLocalServer))
    {
        for (int i = 0; i < ARRAYSIZE(c_localServers); i++)
        {
            if (IsEqualCLSID(clsidLocalServer, *c_localServers[i]))
            {
                PostMessage(GetShellWindow(), CWM_CREATELOCALSERVER, (WPARAM)TRUE, (LPARAM)i);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dsubscri.h ===
BOOL DeleteFromSubscriptionList(LPCTSTR pszURL);
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL);
BOOL UpdateSubscription(LPCTSTR pszURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dutil.h ===
#ifndef _DUTIL_H_
#define _DUTIL_H_

#include "local.h"
#include "deskstat.h"

extern "C" LONG g_cRefThisDll;

typedef struct _EnumMonitorsArea
{
    int iMonitors;
    RECT rcWorkArea[LV_MAX_WORKAREAS];
    RECT rcMonitor[LV_MAX_WORKAREAS];
    RECT rcVirtualMonitor;
    RECT rcVirtualWorkArea;         //Excluding the tray/toolbar areas
} EnumMonitorsArea;

void SaveDefaultFolderSettings();
BOOL GetFileName(HWND hdlg, LPTSTR pszFileName, int iSize, int iTypeId[], DWORD dwFlags[]);
void PatternToDwords(LPTSTR psz, DWORD *pdwBits);
void PatternToWords(LPTSTR psz, WORD *pwBits);
BOOL IsValidPattern(LPCTSTR pszPat);
BOOL IsNormalWallpaper(LPCTSTR pszFileName);
BOOL IsWallpaperPicture(LPCTSTR pszWallpaper);
BOOL CheckAndResolveLocalUrlFile(LPTSTR pszFileName, int cchFileName);
void GetMyCurHomePageStartPos(int *piLeft, int *piTop, DWORD *pdwWidth, DWORD *pdwHeight);
BOOL AddRemoveDesktopComponentNoUI(BOOL fAdd, DWORD dwApplyFlags, LPCTSTR pszUrl, LPCTSTR pszFriendlyName, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, BOOL fChecked, DWORD dwCurItemState, BOOL fNoScroll = FALSE, BOOL fCanResize = TRUE);
void InitDeskHtmlGlobals(void);
HBITMAP LoadMonitorBitmap(void);
void PositionComponent(COMPONENTA *pcomp, COMPPOS *pcp, int iCompType, BOOL fCheckItemState);
BOOL UpdateDesktopPosition(LPTSTR pszCompId, int iLeft, int iTop, DWORD dwWidth, DWORD dwHeight, int izIndex, BOOL fSaveState, BOOL fSaveOriginal, DWORD dwNewState);
BOOL GetSavedStateInfo(LPTSTR pszCompId, LPCOMPSTATEINFO    pCompState, BOOL fRestoredState);
DWORD GetCurrentState(LPTSTR pszCompId);
BOOL UpdateComponentFlags(LPCTSTR pszCompId, DWORD dwMask, DWORD dwNewFlags);
void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme);
BOOL ValidateFileName(HWND hwnd, LPCTSTR pszFilename, int iTypeString);

void EnableADifHtmlWallpaper(HWND hwnd);
BOOL GetWallpaperDirName(LPTSTR lpszWallPaperDir, int iBuffSize);
BOOL _AddDesktopComponentA(HWND hwnd, LPCSTR pszUrlA, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, DWORD dwFlags);
void GetMonitorSettings(EnumMonitorsArea* ema);
int GetWorkAreaIndexFromPoint(POINT pt, LPCRECT prect, int crect);
void ReadWallpaperStyleFromReg(LPCTSTR pszRegKey, DWORD *pdwWallpaperStyle, BOOL fIgnorePlatforms);
BOOL GetWallpaperWithPath(LPCTSTR szWallpaper, LPTSTR szWallpaperWithPath, int iBufSize);
BOOL GetViewAreas(LPRECT lprcViewAreas, int* pnViewAreas);
BOOL GetZoomRect(BOOL fFullScreen, BOOL fAdjustListview, int tridentLeft, int tridentTop, DWORD componentWidth, DWORD componentHeight, LPRECT prcZoom, LPRECT prcWork);
void GetNextComponentPosition(COMPPOS *pcp);
void IncrementComponentsPositioned(void);
void ValidateComponentPosition(COMPPOS *pcp, DWORD dwComponentState, int iComponentType, BOOL *pbChangedPosition, BOOL *pbChangedSize);
int GetcyCaption();
BOOL IsICWCompleted(void);
void LaunchICW(void);
BOOL IsLocalPicture(LPCTSTR pszURL);
BOOL DisableUndisplayableComponents(IActiveDesktop *pIAD);

HRESULT PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize);

// Top level reg keys
#define REG_DESKCOMP                        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop")
#define REG_DESKCOMP_GENERAL                TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sGeneral")
#define REG_DESKCOMP_GENERAL_SUFFIX         TEXT("General")
#define REG_DESKCOMP_COMPONENTS             TEXT("Software\\Microsoft\\Internet Explorer\\Desktop%sComponents")
#define REG_DESKCOMP_COMPONENTS_SUFFIX      TEXT("Components")
#define REG_DESKCOMP_SAFEMODE               TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\SafeMode")
#define REG_DESKCOMP_SAFEMODE_SUFFIX        TEXT("SafeMode")
#define REG_DESKCOMP_SAFEMODE_SUFFIX_L      L"SafeMode"
#define REG_DESKCOMP_SCHEME                 TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme")
#define REG_DESKCOMP_SCHEME_LOCATION        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Scheme\\Location")
#define REG_DESKCOMP_SCHEME_SUFFIX          TEXT("Scheme")
#define REG_DESKCOMP_COMPONENTS_ROOT        TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Components")
#define REG_DESKCOMP_GENERAL_ROOT           TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\General")
#define REG_DESKCOMP_OLDWORKAREAS           TEXT("Software\\Microsoft\\Internet Explorer\\Desktop\\Old WorkAreas")
#define REG_DESKCOMP_ADMINCOMP_ROOT         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\ActiveDesktop\\AdminComponent")

// values for toplevel (misc)
#define REG_VAL_MISC_CHANNELSIZE            TEXT("ChannelSize")

// values for General
#define REG_VAL_GENERAL_CCOMPPOS            TEXT("ComponentsPositioned")
#define REG_VAL_GENERAL_DESKTOPFILE         TEXT("HTMLFile")
#define REG_VAL_GENERAL_TILEWALLPAPER       TEXT("TileWallpaper")
#define REG_VAL_GENERAL_WALLPAPER           TEXT("Wallpaper")
#define REG_VAL_GENERAL_BACKUPWALLPAPER     TEXT("BackupWallpaper")
#define REG_VAL_GENERAL_WALLPAPERTIME       TEXT("WallpaperFileTime")
#define REG_VAL_GENERAL_WALLPAPERLOCALTIME  TEXT("WallpaperLocalFileTime")
#define REG_VAL_GENERAL_WALLPAPERSTYLE      TEXT("WallpaperStyle")
#define REG_VAL_GENERAL_VISITGALLERY        TEXT("VisitGallery")
#define REG_VAL_GENERAL_RESTRICTUPDATE      TEXT("RestrictChannelUI")

// values for Components
#define REG_VAL_COMP_VERSION                TEXT("DeskHtmlVersion")
#define REG_VAL_COMP_MINOR_VERSION          TEXT("DeskHtmlMinorVersion")
#define REG_VAL_COMP_GENFLAGS               TEXT("GeneralFlags")
#define REG_VAL_COMP_SETTINGS               TEXT("Settings")
#define REG_VAL_COMP_UPGRADED_FROM          TEXT("UpgradedFrom")

// values for each component entry
#define REG_VAL_COMP_FLAGS                  TEXT("Flags")
#define REG_VAL_COMP_NAME                   TEXT("FriendlyName")
#define REG_VAL_COMP_POSITION               TEXT("Position")
#define REG_VAL_COMP_SOURCE                 TEXT("Source")
#define REG_VAL_COMP_SUBSCRIBED_URL         TEXT("SubscribedURL")
#define REG_VAL_COMP_CURSTATE               TEXT("CurrentState")
#define REG_VAL_COMP_ORIGINALSTATEINFO      TEXT("OriginalStateInfo")
#define REG_VAL_COMP_RESTOREDSTATEINFO      TEXT("RestoredStateInfo")

// values for Scheme
#define REG_VAL_SCHEME_DISPLAY              TEXT("Display")
#define REG_VAL_SCHEME_EDIT                 TEXT("Edit")

// values for old work areas
#define REG_VAL_OLDWORKAREAS_COUNT          TEXT("NoOfOldWorkAreas")
#define REG_VAL_OLDWORKAREAS_RECTS          TEXT("OldWorkAreaRects")

// values for Admin Component
#define REG_VAL_ADMINCOMP_ADD               TEXT("Add")
#define REG_VAL_ADMINCOMP_DELETE            TEXT("Delete")

TCHAR g_szNone[];
EXTERN_C const TCHAR c_szPatterns[];
EXTERN_C const TCHAR c_szComponentPreview[];
EXTERN_C const TCHAR c_szRegDeskHtmlProp[];
EXTERN_C const TCHAR c_szBackgroundPreview2[];
EXTERN_C const TCHAR c_szZero[];
EXTERN_C const TCHAR c_szWallpaper[];

#define EnableApplyButton(hdlg) PropSheet_Changed(GetParent(hdlg), hdlg)

// Note: Incrementing the CUR_DESKHTML_VERSION will blow away all the existing
// components already in the registry. So, do this with caution!
#define CUR_DESKHTML_VERSION 0x110

// Note: Incrementing the CUR_DESKHTM_MINOR_VERSION can be used to do two things:
// 1. It will simply set the dirty bit sothat the desktop.htt gets re-generated. 
//    For example, do this whenever template file deskmovr.htt changes.
// 2. It can be used to add a new default component (for example "MyCurrentHome") without
//    destroying any of the existing components in the user's registry.
//
#define CUR_DESKHTML_MINOR_VERSION 0x0005

//The following are the Major and minor version numbers stamped on the registry for IE4.0x
#define IE4_DESKHTML_VERSION        0x010e
#define IE4_DESKHTML_MINOR_VERSION  0x0001

//The following are the Major and minor version numbers stamped on the registry for IE5.0x
#define IE5_DESKHTML_VERSION        0x010f
#define IE5_DESKHTML_MINOR_VERSION  0x0001

//The following are the Major and minor version numbers stamped on the registry for NT5 (W2K)
#define NT5_DESKHTML_VERSION        0x0110
#define NT5_DESKHTML_MINOR_VERSION  0x0003

//The following major & minor version is the only version where desktop v2 was present 
//as a component.
#define DESKV2_DESKHTML_VERSION       0x0110
#define DESKV2_DESKHTML_MINOR_VERSION 0x0004


#define  COMPON_FILENAME              TEXT("\\Web\\Compon.htm")
#define  COMPONENTHTML_FILENAME       TEXT("\\Web\\TryIt.htm")
#define  DESKTOPHTML_DEFAULT_SAFEMODE TEXT("\\Web\\SafeMode.htt")
#define  DESKTOPHTML_DEFAULT_WALLPAPER TEXT("Wallpapr.htm")
#define  DESKTOPHTML_DEFAULT_MEMPHIS_WALLPAPER TEXT("Windows98.htm")
#define  DESKTOPHTML_DEFAULT_NT5_WALLPAPER TEXT("Active Desktop Wallpaper.htm")
//#define  DESKTOPHTML_DEFAULT_NT5_WALLPAPER TEXT("Windows 2000 Wallpaper.bmp")
#define  PREVIEW_PICTURE_FILENAME      TEXT("PrePict.htm")
#define  DESKTOPHTML_WEB_DIR           TEXT("\\Web")

#define GFN_PICTURE         0x00000001
#define GFN_LOCALHTM        0x00000002      // local *.htm and *.html files only
#define GFN_URL             0x00000004
#define GFN_CDF             0x00000008
#define GFN_LOCALMHTML      0x00000010      // local *.mht and *.mhtml files only
#define GFN_ALL             (GFN_PICTURE | GFN_LOCALHTM | GFN_URL | GFN_CDF | GFN_LOCALMHTML)

#define CXYDESKPATTERN 8

// Valid bits for REG_VAL_COMP_SETTINGS
#define COMPSETTING_ENABLE      0x00000001    

//
// Dimensions of the monitor contents in the monitor bitmap.
// Used in the desk property sheet "preview" controls.
//
#define MON_X 16
#define MON_Y 17
#define MON_DX 152
#define MON_DY 112

//
// Attributes of default components.
//
#define EGG_LEFT            130
#define EGG_TOP             180
#define EGG_WIDTH           160
#define EGG_HEIGHT          160

#define CBAR_SOURCE         TEXT("131A6951-7F78-11D0-A979-00C04FD705A2")
#define CBAR_TOP            6
#define CBAR_WIDTH          84
#define CBAR_BUTTON_HEIGHT  35 // height of one button

// My Current Home page component's default values.
#define MY_HOMEPAGE_SOURCE  TEXT("About:Home")
#define MY_HOMEPAGE_SOURCEW L"About:Home"
#define MYCURHOME_TOP       6
#define MYCURHOME_WIDTH     160
#define MYCURHOME_HEIGHT    160

#define COMPONENT_PER_ROW 3
#define COMPONENT_PER_COL 2

int SHLoadString(HINSTANCE hInstance, UINT uID, LPTSTR szBuffer, int nBufferMax);

#define  LoadMenuPopup(id) SHLoadMenuPopup(HINST_THISDLL, id)

#define VALIDATESTATE(x)            ((((x) & ~IS_VALIDSTATEBITS) == 0) && ((((x) & IS_VALIDSIZESTATEBITS) == IS_NORMAL) || (((x) & IS_VALIDSIZESTATEBITS) == IS_SPLIT) || (((x) & IS_VALIDSIZESTATEBITS) == IS_FULLSCREEN)))
#define ISZOOMED(x)                 (((x)->dwCurItemState & IS_SPLIT) || ((x)->dwCurItemState & IS_FULLSCREEN))
#define IsZoomedState(itemState)    ((((itemState) & IS_SPLIT) != 0) || (((itemState) & IS_FULLSCREEN) != 0))

// dvutil.cpp
#include <webcheck.h>
#include <mshtml.h>
typedef struct IHTMLElement IHTMLElement;
HRESULT CSSOM_TopLeft(IHTMLElement * pIElem, POINT * ppt);
HRESULT GetHTMLElementStrMember(IHTMLElement *pielem, LPTSTR pszName, DWORD cchSize, BSTR bstrMember);
HRESULT IElemCheckForExistingSubscription(IHTMLElement *pielem);
HRESULT IElemCloseDesktopComp(IHTMLElement *pielem);
HRESULT IElemGetSubscriptionsDialog(IHTMLElement *pielem, HWND hwnd);
HRESULT IElemSubscribeDialog(IHTMLElement *pielem, HWND hwnd);
HRESULT IElemUnsubscribe(IHTMLElement *pielem);
HRESULT IElemUpdate(IHTMLElement *pielem);
HRESULT IElemOpenInNewWindow(IHTMLElement *pielem, IOleClientSite *piOCSite, BOOL fShowFrame, LONG width, LONG height);
HRESULT ShowSubscriptionProperties(LPCTSTR pszUrl, HWND hwnd);
HRESULT CreateSubscriptionsWizard(SUBSCRIPTIONTYPE subType, LPCTSTR pszUrl, SUBSCRIPTIONINFO *pInfo, HWND hwnd);
BOOL CheckForExistingSubscription(LPCTSTR lpcszURL);
void ZoomComponent(COMPPOS * pcp, DWORD dwItemState, BOOL fAdjustListview);

#define GET_CYCAPTION   (GetcyCaption())
#define GET_CXSIZE      (GetSystemMetrics(SM_CXSIZEFRAME) - GetSystemMetrics(SM_CXBORDER))
#define GET_CYSIZE      (GetSystemMetrics(SM_CYSIZEFRAME) - GetSystemMetrics(SM_CYBORDER))

#endif // _DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dvutil.cpp ===
// Functions stolen from shdocvw\util.cpp

#include "stdafx.h"
#pragma hdrstop
#include "dsubscri.h"


//+-----------------------------------------------------------------
//
// Helper function for getting the TopLeft point of an element from
//      mshtml.dll, and have the point reported in inside relative
//      coordinates (inside margins, borders and padding.)
//-----------------------------------------------------------------
HRESULT CSSOM_TopLeft(IHTMLElement * pIElem, POINT * ppt) 
{
    HRESULT       hr = E_FAIL;
    IHTMLStyle    *pistyle;

    if (SUCCEEDED(pIElem->get_style(&pistyle)) && pistyle) {
        VARIANT var = {0};

        if (SUCCEEDED(pistyle->get_top(&var)) && var.bstrVal) {
            ppt->y = StrToIntW(var.bstrVal);
            VariantClear(&var);

            if (SUCCEEDED(pistyle->get_left(&var)) && var.bstrVal) {
                ppt->x = StrToIntW(var.bstrVal);
                VariantClear(&var);
                hr = S_OK;
            }
        }

        pistyle->Release();
    }

    return hr;
}

HRESULT GetHTMLElementStrMember(IHTMLElement *pielem, LPTSTR pszName, DWORD cchSize, BSTR bstrMember)
{
    HRESULT hr;
    VARIANT var = {0};

    if (!pielem)
        hr = E_INVALIDARG;
    else if (SUCCEEDED(hr = pielem->getAttribute(bstrMember, TRUE, &var)))
    {
        if ((VT_BSTR == var.vt) && (var.bstrVal))
        {
#ifdef UNICODE          
            hr = StringCchCopy(pszName, cchSize, (LPCWSTR)var.bstrVal);
#else // UNICODE
            SHUnicodeToAnsi((BSTR)var.bstrVal, pszName, cchSize);
#endif // UNICODE
        }
        else
            hr = E_FAIL; // Try VariantChangeType?????

        VariantClear(&var);
    }

    return hr;
}

/******************************************************************\
    FUNCTION: IElemCheckForExistingSubscription()

    RETURN VALUE:
    S_OK    - if the IHTMLElement points to a TAG that has a "subscribed_url" property
              that is subscribed. 
    S_FALSE - if the IHTMLElement points to a TAG that has a
              "subscribed_url" property but the URL is not subscribed.
    E_FAIL  - if the IHTMLElement points to a TAG that does not
              have a  "subscribed_url" property.
\******************************************************************/
HRESULT IElemCheckForExistingSubscription(IHTMLElement *pielem)
{
    HRESULT hr = E_FAIL;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    if (!pielem)
        return E_INVALIDARG;

    if (SUCCEEDED(GetHTMLElementStrMember(pielem, szHTMLElementName, ARRAYSIZE(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz))))
        hr = (CheckForExistingSubscription(szHTMLElementName) ? S_OK : S_FALSE);

    return hr;
}

HRESULT IElemCloseDesktopComp(IHTMLElement *pielem)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szHTMLElementID[MAX_URL_STRING];

    ASSERT(pielem);
    if (pielem &&
        SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szHTMLElementID, ARRAYSIZE(szHTMLElementID), (BSTR)(s_sstrIDMember.wsz))))
    {
        hr = UpdateComponentFlags(szHTMLElementID, COMP_CHECKED | COMP_UNCHECKED, COMP_UNCHECKED) ? S_OK : E_FAIL;
        if (SUCCEEDED(hr))
        {
            //
            // This IElemCloseDesktopComp() is called from DeskMovr code when a component is
            // closed. If this component is the only active desktop component, then calling
            // REFRESHACTIVEDESKTOP() here will result in ActiveDesktop being turned off.
            // This will free the DeskMovr, which is an ActiveX control on the desktop web page.
            // So, when IElemCloseDesktopComp() returns to the caller, the DeskMovr code continues
            // to execute; but the object had been freed and hence a fault occurs soon.
            // The fix for this problem is to avoid refreshing the active desktop until a better
            // time. So, we post a private message to the desktop window. When that window receives
            // this message, we call REFRESHACTIVEDESKTOP().
            
            PostMessage(GetShellWindow(), DTM_REFRESHACTIVEDESKTOP, (WPARAM)0, (LPARAM)0);
        }
    }

    return hr;
}

HRESULT IElemGetSubscriptionsDialog(IHTMLElement *pielem, HWND hwnd)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    if (SUCCEEDED(hr = GetHTMLElementStrMember(pielem, szHTMLElementName, ARRAYSIZE(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz))))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = ShowSubscriptionProperties(szHTMLElementName, hwnd);
    }

    return hr;
}

HRESULT IElemSubscribeDialog(IHTMLElement *pielem, HWND hwnd)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, ARRAYSIZE(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(!CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = CreateSubscriptionsWizard(SUBSTYPE_DESKTOPURL, szHTMLElementName, NULL, hwnd);
    }

    return hr;
}

HRESULT IElemUnsubscribe(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, ARRAYSIZE(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = DeleteFromSubscriptionList(szHTMLElementName) ? S_OK : S_FALSE;
    }

    return hr;
}

HRESULT IElemUpdate(IHTMLElement *pielem)
{
    HRESULT hr;
    TCHAR szHTMLElementName[MAX_URL_STRING];

    ASSERT(pielem);
    hr = GetHTMLElementStrMember(pielem, szHTMLElementName, ARRAYSIZE(szHTMLElementName), (BSTR)(s_sstrSubSRCMember.wsz));
    if (SUCCEEDED(hr))
    {
        ASSERT(CheckForExistingSubscription(szHTMLElementName)); // We should not have gotten this far.
        hr = UpdateSubscription(szHTMLElementName) ? S_OK : S_FALSE;
    }

    return hr;
}

void _GetDesktopNavigateURL(LPCWSTR pszUrlSrc, LPWSTR pszUrlDest, DWORD cchUrlDest)
{
    HRESULT hr = E_FAIL;

    if (0 == StrCmpIW(pszUrlSrc, MY_HOMEPAGE_SOURCEW))
    {       
        //  it's about:home so we need to decipher it.  shdocvw knows how to do this.
        HINSTANCE hinstShdocvw = GetModuleHandle(L"shdocvw.dll");

        if (hinstShdocvw)
        {
            typedef HRESULT (STDAPICALLTYPE *_GETSTDLOCATION)(LPWSTR, DWORD, UINT);

            _GETSTDLOCATION _GetStdLocation = (_GETSTDLOCATION)GetProcAddress(hinstShdocvw, (LPCSTR)150);

            if (_GetStdLocation)
            {
                hr = _GetStdLocation(pszUrlDest, cchUrlDest, DVIDM_GOHOME);
            }
        }
    }

    if (FAILED(hr))
    {
        StrCpyNW(pszUrlDest, pszUrlSrc, cchUrlDest);
    }
}

HRESULT IElemOpenInNewWindow(IHTMLElement *pielem, IOleClientSite *piOCSite, BOOL fShowFrame, LONG width, LONG height)
{
    HRESULT hr;
    TCHAR szTemp[MAX_URL_STRING];
    BSTR bstrURL;

    ASSERT(pielem);

    hr = GetHTMLElementStrMember(pielem, szTemp, ARRAYSIZE(szTemp), (BSTR)(s_sstrSubSRCMember.wsz));

    if (SUCCEEDED(hr))
    {
        WCHAR szNavigateUrl[MAX_URL_STRING];

        _GetDesktopNavigateURL(szTemp, szNavigateUrl, ARRAYSIZE(szNavigateUrl));

        bstrURL = SysAllocStringT(szNavigateUrl);

        if (bstrURL)
        {
            if (ShouldNavigateInIE(bstrURL))
            {
                IHTMLWindow2 *pihtmlWindow2, *pihtmlWindow2New = NULL;
                BSTR bstrFeatures = 0;

                if (!fShowFrame)
                {
                    hr = StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("height=%li, width=%li, status=no, toolbar=no, menubar=no, location=no, resizable=no"), height, width);
                    if (SUCCEEDED(hr))
                    {
                        bstrFeatures = SysAllocString((OLECHAR FAR *)szTemp);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = IUnknown_QueryService(piOCSite, SID_SHTMLWindow, IID_IHTMLWindow2, (LPVOID*)&pihtmlWindow2);

                    if (SUCCEEDED(hr) && pihtmlWindow2)
                    {
                        pihtmlWindow2->open(bstrURL, NULL, bstrFeatures, NULL, &pihtmlWindow2New);
                        pihtmlWindow2->Release();
                        ATOMICRELEASE(pihtmlWindow2New);
                    }
                }

                if (bstrFeatures)
                    SysFreeString(bstrFeatures);
            }
            else
            {
                //  IE is not the default browser so we'll ShellExecute the Url for active desktop
                HINSTANCE hinstRet = ShellExecuteW(NULL, NULL, bstrURL, NULL, NULL, SW_SHOWNORMAL);
                
                hr = ((UINT_PTR)hinstRet) <= 32 ? E_FAIL : S_OK;
            }

            SysFreeString(bstrURL);
        }
    }

    return hr;
}

HRESULT ShowSubscriptionProperties(LPCTSTR pszUrl, HWND hwnd)
{
    HRESULT hr;
    ISubscriptionMgr *psm;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                          (void**)&psm)))
    {
        WCHAR wszUrl[MAX_URL_STRING];

        SHTCharToUnicode(pszUrl, wszUrl, ARRAYSIZE(wszUrl));

        hr = psm->ShowSubscriptionProperties(wszUrl, hwnd);
        psm->Release();
    }

    return hr;
}

HRESULT CreateSubscriptionsWizard(SUBSCRIPTIONTYPE subType, LPCTSTR pszUrl, SUBSCRIPTIONINFO *pInfo, HWND hwnd)
{
    HRESULT hr;
    ISubscriptionMgr *psm;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                          CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                          (void**)&psm)))
    {
        WCHAR wzURL[MAX_URL_STRING];
        LPCWSTR pwzURL = wzURL;

#ifndef UNICODE
        SHAnsiToUnicode(pszUrl, wzURL, ARRAYSIZE(wzURL));
#else // UNICODE
        pwzURL = pszUrl;
#endif // UNICODE

        hr = psm->CreateSubscription(hwnd, pwzURL, pwzURL, CREATESUBS_ADDTOFAVORITES, subType, pInfo);
        psm->UpdateSubscription(pwzURL);
        psm->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dutil.cpp ===
#include "stdafx.h"
#include "icwcfg.h"
#pragma hdrstop

EXTERN_C const TCHAR c_szPatterns[] = TEXT("patterns");
EXTERN_C const TCHAR c_szBackgroundPreview2[] = TEXT("BackgroundPreview2");
EXTERN_C const TCHAR c_szComponentPreview[] = TEXT("ComponentPreview");
EXTERN_C const TCHAR c_szRegDeskHtmlProp[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Display\\shellex\\PropertySheetHandlers\\DeskHtmlExt");
EXTERN_C const TCHAR c_szWallPaperDir[] = TEXT("WallPaperDir");

//  98/10/01 vtan: Added local function prototypes.

//  Some of these functions are commented out. The linker may not be smart
//  enough to strip the dead code so this is done manually. These prototypes
//  will allow the code to compile but it won't link. If you get linker
//  errors, uncomment the desired function and recompile. It should then link.

//  Point arithmetic

void    SetPt (POINT& pt, LONG x, LONG y);
void    OffsetPt (POINT& pt, LONG dh, LONG dv);

//  Virtual screen calculation

BOOL    CALLBACK    GDIToTridentEnumProc (HMONITOR hMonitor, HDC hDC, RECT* rcMonitor, LPARAM lpUserData);
void    CalculateVirtualScreen (RECT& rcVirtualScreen);

//  GDI point to Trident point co-ordinate mapping

void    GDIToTrident (int& leftCoordinate, int& topCoordinate);
void    GDIToTrident (POINT& pt);
void    GDIToTrident (RECT& r);
void    GDIToTrident (HRGN hRgn);
void    TridentToGDI (int& leftCoordinate, int& topCoordinate);
void    TridentToGDI (POINT& pt);
void    TridentToGDI (RECT& r);
void    TridentToGDI (HRGN hRgn);

//  Component position validation

BOOL CALLBACK    ValidateComponentPositionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* r, LPARAM lParam);

void GetNextComponentPosition (COMPPOS *pcp)

{
    int     iScreenWidth, iScreenHeight, iBorderSize;
    DWORD   dwComponentPosition, dwComponentLayer, dwRegDataScratch;
    HKEY    hKey;
    RECT    rcScreen;
    TCHAR   szDeskcomp[MAX_PATH];

    TBOOL(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, FALSE));

    // 99/04/13 vtan: A result of zero-width or zero-height occurred on a machine.
    // Make a defensive stand against this and assert that this happened but also
    // handle this cause so that division by zero doesn't happen.

    iScreenWidth = rcScreen.right - rcScreen.left;
    iScreenHeight = rcScreen.bottom - rcScreen.top;
    iBorderSize = GetSystemMetrics(SM_CYSMCAPTION);

    ASSERT(iScreenWidth > 0);       // get vtan
    ASSERT(iScreenHeight > 0);      // if any of
    ASSERT(iBorderSize > 0);        // these occur

    if ((iScreenWidth <= 0) || (iScreenHeight <= 0) || (iBorderSize <= 0))
    {
        pcp->iLeft = pcp->iTop = 0;
        pcp->dwWidth = MYCURHOME_WIDTH;
        pcp->dwHeight = MYCURHOME_HEIGHT;
    }
    else
    {

        // Get the number of components positioned. If no such registry key exists
        // or an error occurs then use 0.

        dwComponentPosition = 0;
        GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, NULL, 0, KEY_QUERY_VALUE, NULL, &hKey, &dwRegDataScratch))
        {
            DWORD   regDataSize;

            regDataSize = sizeof(dwComponentPosition);
            TW32(SHQueryValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, NULL, &dwRegDataScratch, &dwComponentPosition, &regDataSize));
            TW32(RegCloseKey(hKey));
        }

        // Compute the layer we live on (see below).

        dwComponentLayer = dwComponentPosition / (COMPONENT_PER_ROW * COMPONENT_PER_COL);
        if (((dwComponentLayer * iBorderSize) > (DWORD)(iScreenWidth / (COMPONENT_PER_ROW + 1))) ||
            ((dwComponentLayer * iBorderSize) > (DWORD)(iScreenHeight / (COMPONENT_PER_COL + 1))))
        {
            int     iLayerModulo;

            // 99/04/29 vtan: It's possible for SystemParametersInfo(SPI_GETWORKAREA) to
            // return a work area that's small horizontally. Here's a repro scenario for
            // that.

            // 1. Set screen resolution 1280 x 1024.
            // 2. Move the taskbar to the left of the screen.
            // 3. Grow the taskbar to the right until the center of the screen.
            // 4. Open display control panel.
            // 5. Go to "Settings" tab.
            // 6. Change monitor resolution to 640x480.
            // 7. Click either "OK" or "Apply".
            // 8. BOOM - divide zero.

            iLayerModulo = (iScreenWidth / (COMPONENT_PER_ROW + 1) / iBorderSize);
            if (iLayerModulo != 0)
                dwComponentLayer %= iLayerModulo;
        }

        // Compute the position.  Assuming 3 components per row,
        // and 2 per column, we position components thusly:
        //
        //       +-------+
        //       |x 4 2 0|
        //       |x 5 3 1| <-- screen, divided into 4x3 block coordinates
        //       |x x x x|
        //       +-------+
        //
        // The 6th component sits in a new layer, offset down
        // and to the left of component 0 by the amount iBorder.
        //
        // The first calculation for iLeft and iTop determines the
        // block coordinate value (for instance, component 0 would
        // be at block coordinate value [3,0] and component 1 at [3,1]).
        //
        // The second calculation turns the block coordinate into
        // a screen coordinate.
        //
        // The third calculation adjusts for the border (always down and
        // to the right) and the layers (always down and to the left).

        pcp->iLeft = COMPONENT_PER_ROW - ((dwComponentPosition / COMPONENT_PER_COL) % COMPONENT_PER_ROW); // 3 3 2 2 1 1 3 3 2 2 1 1 ...
        pcp->iLeft *= (iScreenWidth / (COMPONENT_PER_ROW + 1));
        pcp->iLeft += iBorderSize - (dwComponentLayer * iBorderSize);

        pcp->iTop = dwComponentPosition % COMPONENT_PER_COL;  // 0 1 0 1 0 1 ...
        pcp->iTop *= (iScreenHeight / (COMPONENT_PER_COL + 1));
        pcp->iTop += iBorderSize + (dwComponentLayer * iBorderSize);
        pcp->iTop += GET_CYCAPTION;          //vtan: Added this to allow for the title area of the component window

        pcp->dwWidth = (iScreenWidth / (COMPONENT_PER_ROW + 1)) - 2 * iBorderSize;
        pcp->dwHeight = (iScreenHeight / (COMPONENT_PER_COL + 1)) - 2 * iBorderSize;
    }

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
       pcp->iLeft = iScreenWidth - (pcp->iLeft + pcp->dwWidth);
    }
    
}

void IncrementComponentsPositioned (void)

{
    DWORD   dwRegDataScratch;
    HKEY    hKey;
    TCHAR   szDeskcomp[MAX_PATH];

    // Increment the registry count. If no such count exists create it.

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_GENERAL, NULL);
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwRegDataScratch))
    {
        DWORD   dwComponentPosition, regDataSize;

        regDataSize = sizeof(dwComponentPosition);
        dwComponentPosition = 0;
        TW32(SHQueryValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, NULL, &dwRegDataScratch, &dwComponentPosition, &regDataSize));
        ++dwComponentPosition;
        TW32(RegSetValueEx(hKey, REG_VAL_GENERAL_CCOMPPOS, 0, REG_DWORD, reinterpret_cast<unsigned char*>(&dwComponentPosition), sizeof(dwComponentPosition)));
        TW32(RegCloseKey(hKey));
    }
}

//  vtan: Point arithmetic functions. Simple. It may be worth
//  converting these to inline C++ functions or macros if they
//  get used a lot.

void    SetPt (POINT& pt, LONG x, LONG y)

{
    pt.x = x;
    pt.y = y;
}

void    OffsetPt (POINT& pt, LONG dh, LONG dv)

{
    pt.x += dh;
    pt.y += dv;
}

BOOL    CALLBACK    GDIToTridentEnumProc (HMONITOR hMonitor, HDC hDC, RECT* rcMonitor, LPARAM lpUserData)

{
    RECT*   prcNew, rcOld;

    prcNew = reinterpret_cast<RECT*>(lpUserData);

    // Documentation for UnionRect does not specify whether the
    // RECT structures passed must be distinct. To be safe they
    // are passed as distinct structures.

    TBOOL(CopyRect(&rcOld, prcNew));
    TBOOL(UnionRect(prcNew, &rcOld, rcMonitor));
    return(TRUE);
}

void    CalculateVirtualScreen (RECT& rcVirtualScreen)

//  vtan: Calculates the virtual screen in GDI co-ordinates for
//  use in converting co-ordinates from trident scheme to GDI
//  scheme.

{
    TBOOL(SetRectEmpty(&rcVirtualScreen));
    TBOOL(EnumDisplayMonitors(NULL, NULL, GDIToTridentEnumProc, reinterpret_cast<LPARAM>(&rcVirtualScreen)));
}

void    GDIToTrident (int& leftCoordinate, int& topCoordinate)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    leftCoordinate -= rcVirtualScreen.left;
    topCoordinate -= rcVirtualScreen.top;
}

/*
void    GDIToTrident (POINT& pt)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    OffsetPt(pt, -rcVirtualScreen.left, -rcVirtualScreen.top);
}
*/

void    GDIToTrident (RECT& rc)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRect(&rc, -rcVirtualScreen.left, -rcVirtualScreen.top));
}

void    GDIToTrident (HRGN hRgn)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRgn(hRgn, -rcVirtualScreen.left, -rcVirtualScreen.top));
}

/*
void    TridentToGDI (int& leftCoordinate, int& topCoordinate)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    leftCoordinate += rcVirtualScreen.left;
    topCoordinate += rcVirtualScreen.top;
}
*/

/*
void    TridentToGDI (POINT& pt)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    OffsetPt(pt, +rcVirtualScreen.left, +rcVirtualScreen.top);
}
*/

void    TridentToGDI (RECT& rc)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    TBOOL(OffsetRect(&rc, +rcVirtualScreen.left, +rcVirtualScreen.top));
}

/*
void    TridentToGDI (HRGN hRgn)

{
    RECT    rcVirtualScreen;

    CalculateVirtualScreen(rcVirtualScreen);
    (BOOL)OffsetRgn(hRgn, +rcVirtualScreen.left, +rcVirtualScreen.top);
}
*/

//  98/08/14 vtan #196180, #196185: The following code validates
//  a new component's position within the current desktop area. This
//  allows a component to have co-ordinates that seem to be unusual
//  on a single monitor system (such as negative co-ordinates).

class   CRGN
{
    public:
                CRGN (void)                     {   mRgn = CreateRectRgn(0, 0, 0, 0);                               }
                CRGN (const RECT& rc)           {   mRgn = CreateRectRgnIndirect(&rc);                              }
                ~CRGN (void)                    {   TBOOL(DeleteObject(mRgn));                                      }

                operator HRGN (void)    const   {   return(mRgn);                                                   }
        void    SetRegion (const RECT& rc)      {   TBOOL(SetRectRgn(mRgn, rc.left, rc.top, rc.right, rc.bottom));  }
    private:
        HRGN    mRgn;
};

typedef struct
{
    BOOL    bAllowEntireDesktopRegion;
    int     iMonitorCount;
    CRGN    hRgn;
    int     iWorkAreaCount;
    RECT    *prcWorkAreaRects;
} tDesktopRegion;

void    ListView_GetWorkAreasAsGDI (HWND hWndListView, int iWorkAreaCount, RECT *prcWorkAreas)

{
    int     i;

    ListView_GetWorkAreas(hWndListView, iWorkAreaCount, prcWorkAreas);
    for (i = 0; i < iWorkAreaCount; ++i)
    {
        TridentToGDI(prcWorkAreas[i]);
    }
}

int     CopyMostSuitableListViewWorkAreaRect (const RECT *pcrcMonitor, int iListViewWorkAreaCount, const RECT *pcrcListViewWorkAreaRects, RECT *prcWorkArea)

{
    int         i, iResult;
    const RECT  *pcrcRects;

    // This function given a rectangle for a GDI monitor (typically the monitor's
    // work area) as well as given the desktop's list view work area rectangle
    // array (obtained by ListView_GetWorkArea()) will search the list view
    // work area array to find a match for the GDI monitor and use the list view
    // work area rectangle instead as this has docked toolbar information which
    // GDI does not have access to.

    // This function works on the principle that the list view rectangle is
    // always a complete subset of the GDI monitor rectangle which is true.
    // The list view rectangle may be smaller but it should never be bigger.

    // It's ok to pass a NULL pcrcListViewWorkAreaRects as long as
    // iListViewWorkAreaCount is 0.

    pcrcRects = pcrcListViewWorkAreaRects;
    iResult = -1;
    i = 0;
    while ((iResult == -1) && (i < iListViewWorkAreaCount))
    {
        RECT    rcIntersection;

        (BOOL)IntersectRect(&rcIntersection, pcrcMonitor, pcrcRects);
        if (EqualRect(&rcIntersection, pcrcRects) != 0)
        {
            iResult = i;
        }
        else
        {
            ++pcrcRects;
            ++i;
        }
    }
    if (iResult < 0)
    {
        TraceMsg(TF_WARNING, "CopyMostSuitableListViewWorkAreaRect() unable to find matching list view rectangle for GDI monitor rectangle");
        TBOOL(CopyRect(prcWorkArea, pcrcMonitor));
    }
    else
    {
        TBOOL(CopyRect(prcWorkArea, &pcrcListViewWorkAreaRects[iResult]));
    }
    return(iResult);
}

BOOL    GetMonitorInfoWithCompensation (int iMonitorCount, HMONITOR hMonitor, MONITORINFO *pMonitorInfo)

{
    BOOL    fResult;

    // 99/05/20 #338585 vtan: Transplanted the logic explained in the
    // comment below for #211510 from GetZoomRect to here so that other
    // functions can share the behavior. Remember that this ONLY applies
    // a single monitor system where there is part of the monitor's
    // rectangle excluded by a docked toolbar on the left or top of the
    // monitor. A very specific case.

    // 98/10/30 #211510 vtan: Oops. If the task bar is at the top of the
    // screen and there is only one monitor then the shell returns a work
    // area starting at (0, 0) instead of (0, 28); the same applies when
    // the task bar is at the left of the screen; this does NOT occur in
    // a multiple monitor setting. In the single monitor case GDI returns
    // a work area starting at (0, 28) so this code checks for the case
    // where there is a single monitor and offsets the GDI information to
    // (0, 0) so that it matches the shell work area which is compared
    // against in the while loop.

    fResult = GetMonitorInfo(hMonitor, pMonitorInfo);
    if ((fResult != 0) && (iMonitorCount == 1))
    {
        TBOOL(OffsetRect(&pMonitorInfo->rcWork, -pMonitorInfo->rcWork.left, -pMonitorInfo->rcWork.top));
    }
    return(fResult);
}

//  MonitorCountEnumProc()'s body is located in adjust.cpp

BOOL    CALLBACK    MonitorCountEnumProc (HMONITOR hMonitor, HDC dc, RECT *rc, LPARAM data);

BOOL    CALLBACK    ValidateComponentPositionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* prc, LPARAM lpUserData)

{
    HRGN            hRgnDesktop;
    HMONITOR        hMonitorTopLeft, hMonitorTopRight;
    POINT           ptAbove;
    RECT            rcMonitor;
    MONITORINFO     monitorInfo;
    tDesktopRegion  *pDesktopRegion;

    pDesktopRegion = reinterpret_cast<tDesktopRegion*>(lpUserData);
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitor, &monitorInfo) != 0)
    {
        TINT(CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, pDesktopRegion->iWorkAreaCount, pDesktopRegion->prcWorkAreaRects, &rcMonitor));
    }
    else
    {
        TBOOL(CopyRect(&rcMonitor, prc));
    }

    // If this monitor does not have a monitor above it then
    // make the monitor rectangle one pixel lower from the
    // top.

    CRGN    hRgnMonitor(rcMonitor);

    if (!pDesktopRegion->bAllowEntireDesktopRegion)
    {

        // This bizarre little algorithm calculates the margins of the current
        // monitor that do not have a monitor above them. The rcExclude is the
        // the final rectangle that contains this information and is one pixel
        // high. This calculation is only valid if the entire desktop region
        // has been DISALLOWED (not zooming a component).

        // Note that the algorithm fails if there is a monitor that is above
        // this one but is contained within the confines of it. For example,
        // this monitor is at 1024x768 and the one above is at 640x480 and
        // centered. In this case it should be possible to drop the component
        // on the exact zero pixel point but this case is disallowed due to
        // this fault. No big deal.

        SetPt(ptAbove, rcMonitor.left, rcMonitor.top - 1);
        hMonitorTopLeft = MonitorFromPoint(ptAbove, MONITOR_DEFAULTTONULL);
        SetPt(ptAbove, rcMonitor.right, rcMonitor.top - 1);
        hMonitorTopRight = MonitorFromPoint(ptAbove, MONITOR_DEFAULTTONULL);
        if ((hMonitorTopLeft == NULL) && (hMonitorTopRight == NULL))
        {

            // No monitor above this one

            ++rcMonitor.top;
            hRgnMonitor.SetRegion(rcMonitor);
        }
        else if (hMonitorTopLeft != hMonitorTopRight)
        {
            RECT    rcExclude;

            // Either one or two different monitors above this one
            // == case is the same monitor completely covers this
            // monitor.

            TBOOL(SetRect(&rcExclude, rcMonitor.left, rcMonitor.top, rcMonitor.right, rcMonitor.top + 1));
            if (hMonitorTopLeft != NULL)
            {
                TBOOL(GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitorTopLeft, &monitorInfo));
                rcExclude.left = monitorInfo.rcWork.right + 1;
            }
            if (hMonitorTopRight != NULL)
            {
                TBOOL(GetMonitorInfoWithCompensation(pDesktopRegion->iMonitorCount, hMonitorTopRight, &monitorInfo));
                rcExclude.right = monitorInfo.rcWork.left;
            }

            CRGN    hRgnExclude(rcExclude);

            TINT(CombineRgn(hRgnMonitor, hRgnMonitor, hRgnExclude, RGN_DIFF));
        }
    }

    hRgnDesktop = pDesktopRegion->hRgn;
    TINT(CombineRgn(hRgnDesktop, hRgnDesktop, hRgnMonitor, RGN_OR));

    return(TRUE);
}

void    ValidateComponentPosition (COMPPOS *pcp, DWORD dwComponentState, int iComponentType, BOOL *pbChangedPosition, BOOL *pbChangedSize)

{
    BOOL            bChangedPosition, bChangedSize;
    HRGN            hRgnDesktop;
    HWND            hWndDesktopListView, hWndShell, hWndShellChild;
    RECT            rcComponent, rcComponentTop;
    tDesktopRegion  desktopRegion;
    COMPPOS         defaultComponentPosition;

    bChangedPosition = bChangedSize = FALSE;
    GetNextComponentPosition(&defaultComponentPosition);
    GDIToTrident(defaultComponentPosition.iLeft, defaultComponentPosition.iTop);

    // If the component has default left or top then give it the next
    // default component position.

    if ((pcp->iLeft == COMPONENT_DEFAULT_LEFT) && (pcp->iTop == COMPONENT_DEFAULT_TOP))
    {
        pcp->iLeft = defaultComponentPosition.iLeft;
        pcp->iTop = defaultComponentPosition.iTop;
        IncrementComponentsPositioned();
        bChangedPosition = TRUE;
    }

    // If the component has default width or height then give it the
    // next default component size unless it is type COMP_TYPE_PICTURE

    // 98/10/02 #222449 vtan: Only change the size of an unpositioned
    // component if it's not a picture.

    if ((pcp->dwWidth == COMPONENT_DEFAULT_WIDTH) && (pcp->dwHeight == COMPONENT_DEFAULT_HEIGHT) && (iComponentType != COMP_TYPE_PICTURE))
    {
        pcp->dwWidth = defaultComponentPosition.dwWidth;
        pcp->dwHeight = defaultComponentPosition.dwHeight;
        bChangedSize = FALSE;
    }

    // Make sure that the top line of the component is visible or at
    // least one pixel below the top most part of a virtual screen.

    // Check to see if the component has a negative width and height or
    // a width and height that is too small. The only exception to this
    // is if the component is a picture.

    desktopRegion.bAllowEntireDesktopRegion = IsZoomedState(dwComponentState);
    if (iComponentType != COMP_TYPE_PICTURE)
    {
        if (static_cast<int>(pcp->dwWidth) < 10)
        {
            pcp->dwWidth = defaultComponentPosition.dwWidth;
            bChangedSize = FALSE;
        }
        if (static_cast<int>(pcp->dwHeight) < 10)
        {
            pcp->dwHeight= defaultComponentPosition.dwHeight;
            bChangedSize = FALSE;
        }
    }
    TBOOL(SetRect(&rcComponent, pcp->iLeft, pcp->iTop, pcp->iLeft + pcp->dwWidth, pcp->iTop + pcp->dwHeight));
    TBOOL(CopyRect(&rcComponentTop, &rcComponent));
    rcComponentTop.bottom = rcComponentTop.top + 1;

    // Before calculating the desktopRegion as a region by using GDI calls
    // get the List View work area which will have information about docked
    // toolbars in addition to the taskbar which is the only thing that GDI
    // has. This will allow this function to invalidate regions occupied by
    // toolbars also.

    desktopRegion.iWorkAreaCount = 0;
    desktopRegion.prcWorkAreaRects = NULL;

    hWndDesktopListView = NULL;
    hWndShell = GetShellWindow();
    if (hWndShell != NULL)
    {
        hWndShellChild = GetWindow(hWndShell, GW_CHILD);
        if (hWndShellChild != NULL)
        {
            hWndDesktopListView = FindWindowEx(hWndShellChild, NULL, WC_LISTVIEW, NULL);
        }
    }
    if (hWndDesktopListView != NULL)
    {
        DWORD   dwProcessID;

        GetWindowThreadProcessId(hWndDesktopListView, &dwProcessID);
        if (GetCurrentProcessId() == dwProcessID)
        {
            ListView_GetNumberOfWorkAreas(hWndDesktopListView, &desktopRegion.iWorkAreaCount);
            desktopRegion.prcWorkAreaRects = reinterpret_cast<RECT*>(LocalAlloc(GPTR, desktopRegion.iWorkAreaCount * sizeof(desktopRegion.prcWorkAreaRects[0])));
            ListView_GetWorkAreasAsGDI(hWndDesktopListView, desktopRegion.iWorkAreaCount, desktopRegion.prcWorkAreaRects);
        }
    }

    CRGN    hRgnComponentTop(rcComponentTop), hRgnResult;

    desktopRegion.iMonitorCount = 0;
    TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCountEnumProc, reinterpret_cast<LPARAM>(&desktopRegion.iMonitorCount)));
    TBOOL(EnumDisplayMonitors(NULL, NULL, ValidateComponentPositionEnumProc, reinterpret_cast<LPARAM>(&desktopRegion)));
    hRgnDesktop = desktopRegion.hRgn;
    GDIToTrident(hRgnDesktop);

    // 99/03/23 #266412 vtan: Make sure that the top pixel of the component is within
    // the visible desktop. This allows the deskmovr to be positioned over the
    // component and therefore allows it to be moved. If the deskmovr cannot be
    // positioned over it then "snap" the component back into the visible region
    // to a maximum best fit algorithm.

    if (CombineRgn(hRgnResult, hRgnDesktop, hRgnComponentTop, RGN_AND) == NULLREGION)
    {
        LONG        lDeltaX, lDeltaY;
        HMONITOR    hMonitorNearest;
        RECT        rcComponentGDI, rcMonitorWork, rcIntersection;
        MONITORINFO monitorInfo;

        TBOOL(CopyRect(&rcComponentGDI, &rcComponent));
        TridentToGDI(rcComponentGDI);
        hMonitorNearest = MonitorFromRect(&rcComponentGDI, MONITOR_DEFAULTTONEAREST);
        ASSERT(hMonitorNearest != NULL);
        monitorInfo.cbSize = sizeof(monitorInfo);
        TBOOL(GetMonitorInfoWithCompensation(desktopRegion.iMonitorCount, hMonitorNearest, &monitorInfo));
        TINT(CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, desktopRegion.iWorkAreaCount, desktopRegion.prcWorkAreaRects, &rcMonitorWork));
        ++rcMonitorWork.top;
        lDeltaX = lDeltaY = 0;
        if (rcComponentGDI.left < rcMonitorWork.left)
            lDeltaX = rcMonitorWork.left - rcComponentGDI.left;
        if (rcComponentGDI.top < rcMonitorWork.top)
            lDeltaY = rcMonitorWork.top - rcComponentGDI.top;
        if (rcComponentGDI.right > rcMonitorWork.right)
            lDeltaX = rcMonitorWork.right - rcComponentGDI.right;
        if (rcComponentGDI.bottom > rcMonitorWork.bottom)
            lDeltaY = rcMonitorWork.bottom - rcComponentGDI.bottom;
        TBOOL(OffsetRect(&rcComponentGDI, lDeltaX, lDeltaY));
        TBOOL(IntersectRect(&rcIntersection, &rcComponentGDI, &rcMonitorWork));
        GDIToTrident(rcIntersection);
        pcp->iLeft = rcIntersection.left;
        pcp->iTop = rcIntersection.top;
        pcp->dwWidth = rcIntersection.right - rcIntersection.left;
        pcp->dwHeight = rcIntersection.bottom - rcIntersection.top;
        bChangedPosition = bChangedSize = TRUE;
    }

    if (desktopRegion.prcWorkAreaRects != NULL)
        LocalFree(desktopRegion.prcWorkAreaRects);

    if (pbChangedPosition != NULL)
        *pbChangedPosition = bChangedPosition;
    if (pbChangedSize != NULL)
        *pbChangedSize = bChangedSize;
}

//  98/12/11 #250938 vtan: these two functions are lifted from
//  SHBrows2.cpp which is part of browseui.dll.

EXTERN_C    DWORD   WINAPI  IsSmartStart (void);


#ifdef NEVER
// For WinMillennium, we do not want to launch the ICW when active desktop is turned on because
// we do not have a "My Current Homepage" desktop component. So, I am disabling the following code
// This is the temporary fix for Mill bug # 98107 also.
BOOL    IsICWCompleted (void)
{
    DWORD   dwICWCompleted, dwICWSize;

    dwICWCompleted = 0;
    dwICWSize = sizeof(dwICWCompleted);
    TW32(SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwICWSize));

    // 99/01/15 #272829 vtan: This is a horrible hack!!! If ICW has
    // not been run but settings have been made manually then values
    // in HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections
    // exists with the values given. Look for the presence of a key
    // to resolve that settings are present but that ICW hasn't been
    // launched.

    // The ideal solution is to get ICW to make this determination
    // for us BUT TO NOT LAUNCH ICWCONN1.EXE IN THE PROCESS.
    // Currently it will only launch. There is no way to get the
    // desired result without a launch.

    // 99/02/01 #280138 vtan: Well the solution put in for #272829
    // doesn't work. So peeking at the CheckConnectionWizard()
    // source in inetcfg\export.cpp shows that it uses a
    // wininet.dll function to determine whether manually configured
    // internet settings exist. It also exports this function so
    // look for it and bind to it dynamically. This uses the
    // DELAY_LOAD macros in dllload.c

    if (dwICWCompleted == 0)
    {
        #define SMART_RUNICW    TRUE
        #define SMART_QUITICW   FALSE

        dwICWCompleted = BOOLIFY(IsSmartStart() == SMART_QUITICW);
    }
    return(dwICWCompleted != 0);
}
#else  //NEVER
BOOL    IsICWCompleted (void)
{
    return TRUE; //For Millennium we want to always return TRUE for this function.
}
#endif //NEVER

void    LaunchICW (void)

{
    static  BOOL    sbCheckedICW = FALSE;

    if (!sbCheckedICW && !IsICWCompleted())
    {
        HINSTANCE   hICWInst;

        // Prevent an error in finding the ICW from causing this to
        // execute again and again and again.

        sbCheckedICW = TRUE;
        hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            PFNCHECKCONNECTIONWIZARD    pfnCheckConnectionWizard;

            pfnCheckConnectionWizard = reinterpret_cast<PFNCHECKCONNECTIONWIZARD>(GetProcAddress(hICWInst, "CheckConnectionWizard"));
            if (pfnCheckConnectionWizard != NULL)
            {
                DWORD   dwICWResult;

                // If the user cancels ICW then it needs to be launched
                // again. Allow this case.

                sbCheckedICW = FALSE;

                pfnCheckConnectionWizard(ICW_LAUNCHFULL | ICW_LAUNCHMANUAL, &dwICWResult);
            }
            TBOOL(FreeLibrary(hICWInst));
        }
    }
}

BOOL    IsLocalPicture (LPCTSTR pszURL)

{
    return(!PathIsURL(pszURL) && IsUrlPicture(pszURL));
}

BOOL    DisableUndisplayableComponents (IActiveDesktop *pIAD)

{
    BOOL    bHasVisibleNonLocalPicture;
    int     iItemCount;

    // 98/12/16 vtan #250938: If ICW has not been run to completion then only
    // allow the user to show components that are local pictures of some sort.
    // If any components are not local pictures then hide these components,
    // tell the user why it happened and launch ICW.

    bHasVisibleNonLocalPicture = FALSE;
    if (SUCCEEDED(pIAD->GetDesktopItemCount(&iItemCount, 0)))
    {
        int     i;

        for (i = 0; i < iItemCount; ++i)
        {
            COMPONENT   component;

            component.dwSize = sizeof(component);
            if (SUCCEEDED(pIAD->GetDesktopItem(i, &component, 0)) && (component.fChecked != 0))
            {
               BOOL    bIsVisibleNonLocalPicture;
               TCHAR   szComponentSource[INTERNET_MAX_URL_LENGTH];

               SHUnicodeToTChar(component.wszSource, szComponentSource, ARRAYSIZE(szComponentSource));
               bIsVisibleNonLocalPicture = !IsLocalPicture(szComponentSource);
               bHasVisibleNonLocalPicture = bHasVisibleNonLocalPicture || bIsVisibleNonLocalPicture;
               if (bIsVisibleNonLocalPicture)
               {
                   component.fChecked = FALSE;
                   THR(pIAD->ModifyDesktopItem(&component, COMP_ELEM_CHECKED));
               }
            }
         }
    }
    if (bHasVisibleNonLocalPicture)
    {

        // Apply the changes. This should recurse to CActiveDesktop::_SaveSettings()
        // but this code path is NOT taken because AD_APPLY_REFRESH is not passed in.
        // CActiveDesktop::_SaveSettings() calls this function!

        bHasVisibleNonLocalPicture = FAILED(pIAD->ApplyChanges(AD_APPLY_SAVE | AD_APPLY_HTMLGEN));

        // Notify the user what happened and launch ICW.

        ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_COMP_ICW_DISABLE), MAKEINTRESOURCE(IDS_COMP_ICW_TITLE), MB_OK);
        LaunchICW();
    }
    return(bHasVisibleNonLocalPicture);
}

int GetIconCountForWorkArea(HWND hwndLV, LPCRECT prect, int crect, int iWorkAreaIndex)
{
    int iCount;

    iCount = ListView_GetItemCount(hwndLV);

    if (crect > 1) 
    {
        int i, iCountWorkArea = 0;

        for (i = 0; i < iCount; i++)
        {
            POINT pt;
            ListView_GetItemPosition(hwndLV, i, &pt);
            if (iWorkAreaIndex == GetWorkAreaIndexFromPoint(pt, prect, crect))
                iCountWorkArea++;
        }

        iCount = iCountWorkArea;
    }

    return iCount;
}

BOOL GetZoomRect(BOOL fFullScreen, BOOL fAdjustListview, int iTridentLeft, int iTridentTop, DWORD dwComponentWidth, DWORD dwComponentHeight, LPRECT prcZoom, LPRECT prcWork)
{
    HWND hwndShell, hwndLV;
    int icWorkAreas = 0, iWAC;
    RECT rcWork[LV_MAX_WORKAREAS];

    hwndLV = NULL;
    hwndShell = GetShellWindow();
    if (hwndShell != NULL)
    {
        HWND    hwndShellChild;

        hwndShellChild= GetWindow(hwndShell, GW_CHILD);
        if (hwndShellChild != NULL)
        {
            hwndLV = FindWindowEx(hwndShellChild, NULL, WC_LISTVIEW, NULL);
        }
    }

    //
    // First calculate the Work Areas and Work Area index for the component, then perform the
    // particular operation based on lCommand.
    //
    if (hwndLV) {
        DWORD dwpid;
        GetWindowThreadProcessId(hwndLV, &dwpid);
        // The listview doesn't thunk these messages so we can't do
        // this inter-process!
        if (dwpid == GetCurrentProcessId())
        {
            ListView_GetNumberOfWorkAreas(hwndLV, &icWorkAreas);
            if (icWorkAreas <= LV_MAX_WORKAREAS)
                ListView_GetWorkAreas(hwndLV, icWorkAreas, &rcWork);
            else
                hwndLV = NULL;
        } else {
            return FALSE;
        }
    }

    // 98/10/07 vtan: This used to use a variable icWorkAreasAdd.
    // Removed this variable and directly increment icWorkAreas.
    // This doesn't affect the call to ListView_SetWorkAreas()
    // below because in this case hwndLV is NULL.

    if (icWorkAreas == 0)
    {
        RECT rc;

        ++icWorkAreas;
        SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rc, 0);
        rcWork[0] = rc;
        hwndLV = NULL;
    }

    // 98/10/02 #212654 vtan: Changed the calculation code to find a
    // rectangle to zoom the component to based on GDI co-ordinates.
    // The component is passed in trident co-ordinates which are
    // stored in a RECT and converted to GDI co-ordinates. The system
    // then locates the monitor which the component is on and if it
    // cannot find the monitor then defaults to the primary. The
    // dimensions of the monitor are used before converting back to
    // trident co-ordinates.

    int             i, iMonitorCount;
    HMONITOR        hMonitor;
    RECT            rcComponentRect;
    MONITORINFO     monitorInfo;

    iMonitorCount = 0;
    TBOOL(EnumDisplayMonitors(NULL, NULL, MonitorCountEnumProc, reinterpret_cast<LPARAM>(&iMonitorCount)));
    TBOOL(SetRect(&rcComponentRect, iTridentLeft, iTridentTop, iTridentLeft + dwComponentWidth, iTridentTop + dwComponentHeight));
    TridentToGDI(rcComponentRect);
    hMonitor = MonitorFromRect(&rcComponentRect, MONITOR_DEFAULTTOPRIMARY);
    ASSERT(hMonitor != NULL);
    monitorInfo.cbSize = sizeof(monitorInfo);
    TBOOL(GetMonitorInfoWithCompensation(iMonitorCount, hMonitor, &monitorInfo));
    GDIToTrident(monitorInfo.rcWork);

    // 99/05/19 #340772 vtan: Always try to key off work areas returned
    // by ListView_GetWorkAreas because these take into account docked
    // toolbars which GDI does not. In this case the listview work areas
    // will always be the same rectangle when intersected with the GDI
    // work area. Use this rule to determine which listview work area
    // to use as the basis for the zoom rectangle.

    i = CopyMostSuitableListViewWorkAreaRect(&monitorInfo.rcWork, icWorkAreas, rcWork, prcZoom);
    if (i < 0)
    {
        i = 0;
    }
    if (prcWork != NULL)
    {
        TBOOL(CopyRect(prcWork, prcZoom));
    }
    iWAC = i;

    if (!fFullScreen)
    {
        // For the split case we shrink the work area down temporarily to the smallest rectangle
        // that can bound the current number of icons.  This will force the icons into that rectangle,
        // then restore it back to the way it was before.  Finally, we set the size of the split
        // component to fill the rest of the space.
        if (hwndLV) {
            int iCount, iItemsPerColumn, icxWidth, iRightOld;
            DWORD dwSpacing;

            iCount = GetIconCountForWorkArea(hwndLV, rcWork, icWorkAreas, iWAC);
            // Decrement the count so that rounding works right
            if (iCount)     
                iCount--;

            // Calculate the new width for the view rectangle
            dwSpacing = ListView_GetItemSpacing(hwndLV, FALSE);
            iItemsPerColumn = (rcWork[iWAC].bottom - rcWork[iWAC].top) / (HIWORD(dwSpacing));
            if (iItemsPerColumn)
                icxWidth = ((iCount / iItemsPerColumn) + 1) * (LOWORD(dwSpacing));
            else
                icxWidth = LOWORD(dwSpacing);

            // Don't let it get smaller than half the screen
            if (icxWidth > ((rcWork[iWAC].right - rcWork[iWAC].left) / 2))
                icxWidth = (rcWork[iWAC].right - rcWork[iWAC].left) / 2;

            if (fAdjustListview)
            {
                // Now take the old work area rectangle and shrink it to our new width
                iRightOld = rcWork[iWAC].right;
                rcWork[iWAC].right = rcWork[iWAC].left + icxWidth;
                ListView_SetWorkAreas(hwndLV, icWorkAreas, &rcWork);

                // Finally restore the old work area
                rcWork[iWAC].right = iRightOld;
                ListView_SetWorkAreas(hwndLV, icWorkAreas, &rcWork);
            }

            // Adjust the left coordinate of the zoom rect to reflect our calculated split amount
            // the rest of the screen.
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {
                prcZoom->right -= icxWidth;
            }
            else
            {
                prcZoom->left += icxWidth;
            }
        } else {
            // Fallback case, if there is no listview use 20% of the screen for the icons.
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {
                prcZoom->right -= ((prcZoom->right - prcZoom->left) * 2 / 10);            
            }
            else
            {
                prcZoom->left += ((prcZoom->right - prcZoom->left) * 2 / 10);
            }    
        }
    }

    return TRUE;
}

void ZoomComponent(COMPPOS * pcp, DWORD dwCurItemState, BOOL fAdjustListview)
{
    RECT rcZoom;

    if (GetZoomRect((dwCurItemState & IS_FULLSCREEN), fAdjustListview, pcp->iLeft, pcp->iTop, pcp->dwWidth, pcp->dwHeight, &rcZoom, NULL))
    {
        // Copy the new Zoom rectangle over and put it on the bottom
        pcp->iLeft = rcZoom.left;
        pcp->iTop = rcZoom.top;
        pcp->dwWidth = rcZoom.right - rcZoom.left;
        pcp->dwHeight = rcZoom.bottom - rcZoom.top;
        pcp->izIndex = 0;
    }
    else
    {
        // Failure implies we couldn't get the zoom rectangle through inter-process calls.  Set the
        // COMPONENTS_ZOOMDIRTY bit here so that when the desktop is refreshed we will recalculate
        // the zoom rectangles in-process inside of EnsureUpdateHTML.
        SetDesktopFlags(COMPONENTS_ZOOMDIRTY, COMPONENTS_ZOOMDIRTY);
    }
}

//
// PositionComponent will assign a screen position and
// make sure it fits on the screen.
//

void PositionComponent(COMPONENTA *pcomp, COMPPOS *pcp, int iCompType, BOOL fCheckItemState)

{

//  vtan: Vastly simplified routine. The work is now done in
//  ValidateComponentPosition.

    if (ISZOOMED(pcomp))
    {
        if (fCheckItemState)
        {
            SetStateInfo(&pcomp->csiRestored, pcp, IS_NORMAL);
            SetStateInfo(&pcomp->csiOriginal, pcp, pcomp->dwCurItemState);
        }
        ZoomComponent(pcp, pcomp->dwCurItemState, FALSE);
    }
    else
    {
        ValidateComponentPosition(pcp, pcomp->dwCurItemState, iCompType, NULL, NULL);
        if (fCheckItemState)
            SetStateInfo(&pcomp->csiOriginal, pcp, pcomp->dwCurItemState);
    }
}

typedef struct _tagFILETYPEENTRY {
    DWORD dwFlag;
    int iFilterId;
} FILETYPEENTRY;

FILETYPEENTRY afte[] = {
    { GFN_URL, IDS_URL_FILTER, },
    { GFN_CDF, IDS_CDF_FILTER, },
    { GFN_LOCALHTM, IDS_HTMLDOC_FILTER, },
    { GFN_PICTURE,  IDS_IMAGES_FILTER, },
    { GFN_LOCALMHTML, IDS_MHTML_FILTER, },
};

//
// Opens either an HTML page or a picture.
//
BOOL GetFileName(HWND hdlg, LPTSTR pszFileName, int iSize, int iTypeId[], DWORD dwFlags[])
{
    BOOL fRet = FALSE;

    if (dwFlags)
    {
        int i, iIndex, cchRead;
        TCHAR szFilter[MAX_PATH*4];

        //
        // Set the friendly name.
        //
        LPTSTR pchFilter = szFilter;
        int cchFilter = ARRAYSIZE(szFilter) - 2;    // room for term chars

        for(iIndex = 0; dwFlags[iIndex]; iIndex++)
        {
            cchRead = LoadString(HINST_THISDLL, iTypeId[iIndex], pchFilter, cchFilter);
            pchFilter += cchRead + 1;
            cchFilter -= cchRead + 1;

            //
            // Append the file filters.
            //
            BOOL fAddedToString = FALSE;
            for (i=0; (cchFilter>0) && (i<ARRAYSIZE(afte)); i++)
            {
                if (dwFlags[iIndex] & afte[i].dwFlag)
                {
                    if (fAddedToString)
                    {
                        *pchFilter++ = TEXT(';');
                        cchFilter--;
                    }
                    cchRead = LoadString(HINST_THISDLL, afte[i].iFilterId,
                                     pchFilter, cchFilter);
                    pchFilter += cchRead;
                    cchFilter -= cchRead;
                    fAddedToString = TRUE;
                }
            }
            *pchFilter++ = TEXT('\0');
        }

        //
        // Double-NULL terminate the string.
        //
        *pchFilter = TEXT('\0');

        TCHAR szBrowserDir[MAX_PATH];
        if (SUCCEEDED(StringCchCopy(szBrowserDir, ARRAYSIZE(szBrowserDir), pszFileName)))
        {
            PathRemoveFileSpec(szBrowserDir);

            TCHAR szBuf[MAX_PATH];
            LoadString(HINST_THISDLL, IDS_BROWSE, szBuf, ARRAYSIZE(szBuf));

            *pszFileName = TEXT('\0');

            OPENFILENAME ofn = {0};
            ofn.lStructSize       = sizeof(ofn);
            ofn.hwndOwner         = hdlg;
            ofn.hInstance         = NULL;
            ofn.lpstrFilter       = szFilter;
            ofn.lpstrCustomFilter = NULL;
            ofn.nFilterIndex      = 1;
            ofn.nMaxCustFilter    = 0;
            ofn.lpstrFile         = pszFileName;
            ofn.nMaxFile          = iSize;
            ofn.lpstrInitialDir   = szBrowserDir;
            ofn.lpstrTitle        = szBuf;
            ofn.Flags             = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
            ofn.lpfnHook          = NULL;
            ofn.lpstrDefExt       = NULL;
            ofn.lpstrFileTitle    = NULL;

            fRet = GetOpenFileName(&ofn);
        }
    }

    return fRet;
}

//
// Convert a pattern string to a bottom-up array of DWORDs,
// useful for BMP format files.
//
void PatternToDwords(LPTSTR psz, DWORD *pdwBits)
{
    DWORD i, dwVal;

    //
    // Get eight groups of numbers separated by non-numeric characters.
    //
    for (i=0; i<8; i++)
    {
        dwVal = 0;

        if (*psz != TEXT('\0'))
        {
            //
            // Skip over any non-numeric characters.
            //
            while (*psz && (!(*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                psz++;
            }

            //
            // Get the next series of digits.
            //
            while (*psz && (*psz >= TEXT('0') && *psz <= TEXT('9')))
            {
                dwVal = dwVal*10 + *psz++ - TEXT('0');
            }
        }

        pdwBits[7-i] = dwVal;
    }
}

//
// Convert a pattern string to a top-down array of WORDs,
// useful for CreateBitmap().
//
void PatternToWords(LPTSTR psz, WORD *pwBits)
{
    WORD i, wVal;

    //
    // Get eight groups of numbers separated by non-numeric characters.
    //
    for (i=0; i<8; i++)
    {
        wVal = 0;

        if (*psz != TEXT('\0'))
        {
            //
            // Skip over any non-numeric characters.
            //
            while (*psz && (!(*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                psz++;
            }

            //
            // Get the next series of digits.
            //
            while (*psz && ((*psz >= TEXT('0') && *psz <= TEXT('9'))))
            {
                wVal = wVal*10 + *psz++ - TEXT('0');
            }
        }

        pwBits[i] = wVal;
    }
}

BOOL IsValidPattern(LPCTSTR pszPat)
{
    BOOL fSawANumber = FALSE;

    //
    // We're mainly trying to filter multilingual upgrade cases
    // where the text for "(None)" is unpredictable.
    // 
    // 
    //
    while (*pszPat)
    {
        if ((*pszPat < TEXT('0')) || (*pszPat > TEXT('9')))
        {
            //
            // It's not a number, it better be a space.
            //
            if (*pszPat != TEXT(' '))
            {
                return FALSE;
            }
        }
        else
        {
            fSawANumber = TRUE;
        }

        //
        // We avoid the need for AnsiNext by only advancing on US TCHARs.
        //
        pszPat++;
    }

    //
    // TRUE if we saw at least one digit and there were only digits and spaces.
    //
    return fSawANumber;
}

//
// Determines if the wallpaper can be supported in non-active desktop mode.
//
BOOL IsNormalWallpaper(LPCTSTR pszFileName)
{
    BOOL fRet = TRUE;

    if (pszFileName[0] == TEXT('\0'))
    {
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszFileName);

        //Check for specific files that can be shown only in ActiveDesktop mode!
        if((StrCmpIC(pszExt, TEXT(".GIF")) == 0) || // 368690: Strange, but we must compare 'i' in both caps and lower case.
           (lstrcmpi(pszExt, TEXT(".JPG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPE")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".JPEG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".PNG")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
           (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
           return FALSE;

        //Everything else (including *.BMP files) are "normal" wallpapers
    }
    return fRet;
}

//
// Determines if the wallpaper is a picture (vs. HTML).
//
BOOL IsWallpaperPicture(LPCTSTR pszWallpaper)
{
    BOOL fRet = TRUE;

    if (pszWallpaper[0] == TEXT('\0'))
    {
        //
        // Empty wallpapers count as empty pictures.
        //
        fRet = TRUE;
    }
    else
    {
        LPTSTR pszExt = PathFindExtension(pszWallpaper);

        if ((lstrcmpi(pszExt, TEXT(".HTM")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTML")) == 0) ||
            (lstrcmpi(pszExt, TEXT(".HTT")) == 0))
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

void OnDesktopSysColorChange(void)
{
    static COLORREF clrBackground = 0xffffffff;
    static COLORREF clrWindowText = 0xffffffff;

    //Get the new colors!
    COLORREF    clrNewBackground = GetSysColor(COLOR_BACKGROUND);
    COLORREF    clrNewWindowText = GetSysColor(COLOR_WINDOWTEXT);

    //Have we initialized these before?
    if(clrBackground != 0xffffffff)  //Have we initialized the statics yet?
    {
        // Our HTML file depends only on these two system colors.
        // Check if either of them has changed!
        // If not, no need to regenerate HTML file. 
        // This avoids infinite loop. And this is a nice optimization.
        if((clrBackground == clrNewBackground) &&
           (clrWindowText == clrNewWindowText))
            return; //No need to do anything. Just return.
    }

    // Remember the new colors in the statics.
    clrBackground = clrNewBackground;
    clrWindowText = clrNewWindowText;

    //
    // The desktop got a WM_SYSCOLORCHANGE.  We need to
    // regenerate the HTML if there are any system colors
    // showing on the desktop.  Patterns and the desktop
    // color are both based on system colors.
    //
    IActiveDesktop *pad;
    if (SUCCEEDED(CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pad, IID_IActiveDesktop)))
    {
        BOOL fRegenerateHtml = FALSE;
        WCHAR szWallpaperW[INTERNET_MAX_URL_LENGTH];

        if (SUCCEEDED(pad->GetWallpaper(szWallpaperW, ARRAYSIZE(szWallpaperW), 0)))
        {
            if (!*szWallpaperW)
            {
                //
                // No wallpaper means the desktop color
                // or a pattern is showing - we need to
                // regenerate the desktop HTML.
                //
                fRegenerateHtml = TRUE;
            }
            else
            {
                TCHAR *pszWallpaper;
#ifdef UNICODE
                pszWallpaper = szWallpaperW;
#else
                CHAR szWallpaperA[INTERNET_MAX_URL_LENGTH];
                SHUnicodeToAnsi(szWallpaperW, szWallpaperA, ARRAYSIZE(szWallpaperA));
                pszWallpaper = szWallpaperA;
#endif
                if (IsWallpaperPicture(pszWallpaper))
                {
                    WALLPAPEROPT wpo = { sizeof(wpo) };
                    if (SUCCEEDED(pad->GetWallpaperOptions(&wpo, 0)))
                    {
                        if (wpo.dwStyle == WPSTYLE_CENTER)
                        {
                            //
                            // We have a centered picture,
                            // the pattern or desktop color
                            // could be leaking around the edges.
                            // We need to regenerate the desktop
                            // HTML.
                            //
                            fRegenerateHtml = TRUE;
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "SYSCLRCHG: Could not get wallpaper options!");
                    }
                }
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "SYSCLRCHG: Could not get selected wallpaper!");
        }

        
        if (fRegenerateHtml)
        {
            DWORD  dwFlags = AD_APPLY_FORCE | AD_APPLY_HTMLGEN | AD_APPLY_REFRESH | AD_APPLY_DYNAMICREFRESH;
            WCHAR   wszPattern[MAX_PATH];
            //If we have a pattern, then we need to force a AD_APPLY_COMPLETEREFRESH
            // because we need to re-generate the pattern.bmp file which can not be 
            // done through dynamic HTML.
            if(SUCCEEDED(pad->GetPattern(wszPattern, ARRAYSIZE(wszPattern), 0)))
            {
#ifdef UNICODE
                LPTSTR  szPattern = (LPTSTR)wszPattern;
#else
                CHAR   szPattern[MAX_PATH];
                SHUnicodeToAnsi(wszPattern, szPattern, sizeof(szPattern));
#endif //UNICODE
                if(IsValidPattern(szPattern))           //Does this have a pattern?
                    dwFlags &= ~(AD_APPLY_DYNAMICREFRESH);  //Then force a complete refresh!
                    
            }
            pad->ApplyChanges(dwFlags);
        }

        pad->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "SYSCLRCHG: Could not create CActiveDesktop!");
    }
}

//
// Convert a .URL file into its target.
//
BOOL CheckAndResolveLocalUrlFile(LPTSTR pszFileName, int cchFileName)
{
    BOOL fRet;

    //
    // Check if the extension of this file is *.URL
    //
    LPTSTR pszExt = PathFindExtension(pszFileName);
    if (pszExt && *pszExt)
    {
        TCHAR  szUrl[15];
    
        LoadString(HINST_THISDLL, IDS_URL_EXTENSION, szUrl, ARRAYSIZE(szUrl));

        if (lstrcmpi(pszExt, szUrl) != 0)
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;

            IUniformResourceLocator *purl;

            HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                                          IID_IUniformResourceLocator,
                                          (LPVOID *)&purl);

            if (SUCCEEDED(hr))
            {
                ASSERT(purl);

                IPersistFile  *ppf;
                hr = purl->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
                if (SUCCEEDED(hr))
                {
                    hr = ppf->Load(pszFileName, STGM_READ);
                    if (SUCCEEDED(hr))
                    {
                        LPTSTR pszTemp;
                        hr = purl->GetURL(&pszTemp);
                        if (SUCCEEDED(hr))
                        {
                            hr = StringCchCopy(pszFileName, cchFileName, pszTemp);
                            if (SUCCEEDED(hr))
                            {
                                fRet = TRUE;
                            }
                            CoTaskMemFree(pszTemp);
                        }
                    }
                    ppf->Release();
                }
                purl->Release();
            }
        }
    }
    else
    {
        fRet = TRUE;
    }
    
    return fRet;
}


//
// Silently adds/removes a specified component to the desktop and use the given
//  apply flags using which you can avoid nested unnecessary HTML generation, 
//  or refreshing which may lead to racing conditions.
// 
//
BOOL AddRemoveDesktopComponentNoUI(BOOL fAdd, DWORD dwApplyFlags, LPCTSTR pszUrl, LPCTSTR pszFriendlyName, int iCompType, int iLeft, int iTop, int iWidth, int iHeight, BOOL fChecked, DWORD dwCurItemState, BOOL fNoScroll, BOOL fCanResize)
{
    COMPONENTA Comp;
    HRESULT hres;

    //
    // Build the pcomp structure.
    //
    Comp.dwSize = sizeof(COMPONENTA);
    Comp.dwID = -1;
    Comp.iComponentType = iCompType;
    Comp.fChecked = fChecked;
    Comp.fDirty = FALSE;
    Comp.fNoScroll = fNoScroll;
    Comp.cpPos.dwSize = sizeof(COMPPOS);
    Comp.cpPos.iLeft = iLeft;
    Comp.cpPos.iTop = iTop;
    Comp.cpPos.dwWidth = iWidth;
    Comp.cpPos.dwHeight = iHeight;
    Comp.cpPos.izIndex = (dwCurItemState & IS_NORMAL) ? COMPONENT_TOP : 0;
    Comp.cpPos.fCanResize = fCanResize;
    Comp.cpPos.fCanResizeX = fCanResize;
    Comp.cpPos.fCanResizeY = fCanResize;
    Comp.cpPos.iPreferredLeftPercent = 0;
    Comp.cpPos.iPreferredTopPercent = 0;
    Comp.dwCurItemState = dwCurItemState;
    
    hres = StringCchCopy(Comp.szSource, ARRAYSIZE(Comp.szSource), pszUrl);
    if (SUCCEEDED(hres))
    {
        hres = StringCchCopy(Comp.szSubscribedURL, ARRAYSIZE(Comp.szSubscribedURL), pszUrl);
        if (SUCCEEDED(hres))
        {
            if (pszFriendlyName)
            {
                hres = StringCchCopy(Comp.szFriendlyName, ARRAYSIZE(Comp.szFriendlyName), pszFriendlyName);
            }
            else
            {
                Comp.szFriendlyName[0] = TEXT('\0');
            }
        
            if (SUCCEEDED(hres))
            {
                IActiveDesktop *pActiveDesk;

                //
                // Add it to the system.
                //
                hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesk, IID_IActiveDesktop);
                if (SUCCEEDED(hres))
                {
                    COMPONENT  CompW;

                    CompW.dwSize = sizeof(CompW);  //Required for the MultiCompToWideComp to work properly.

                    MultiCompToWideComp(&Comp, &CompW);

                    if(fAdd)
                        pActiveDesk->AddDesktopItem(&CompW, 0);
                    else
                        pActiveDesk->RemoveDesktopItem(&CompW, 0);
            
                    pActiveDesk->ApplyChanges(dwApplyFlags);
                    pActiveDesk->Release();
                }
            }
        }
    }

    return SUCCEEDED(hres);
}

//
//  Summary: 
//      On upgrade from W2K, it is possible (under certain conditions) that the Active Desktop  
//  gets turned ON automatically. This is bug #154993. The following function fixes this bug.
//
// Details of why this happens:
//
// In W2K, it is possible to enable active desktop components, hide icons, lock the components
// and then turn off active desktop. But, all the details (like what AD components were ON etc.,)
// was persisted in the registry. When such a machine is upgraded to Whister, bug #154993 surfaces
// because of the following reason:
//  In Whislter, ActiveDesktop is turned on/off silently based on whether any desktop component is 
// on etc., As a result when a W2K machine (with AD off) is upgraded to Whistler, the AD will be
// turned on automatically, if one of the following is true:
//    1. If the desktop icons were off.
//    2. If the active desktop components were locked.
//    3. If any active desktop component is ON; but, not displayed because AD was OFF..
//  Therefore on upgrade from a Win2K or older machine, we check if the AD is OFF. If so, then we 
// need to check for conditions 1, 2 and 3 and change those settings such that AD continues to be 
// OFF even after the upgrade. The following function OnUpgradeDisableActiveDesktopFeatures ()
// does precisely this.
//
// Returns: TRUE, if any setting was modified to keep the active desktop in the turned off state!
//
BOOL   OnUpgradeDisableActiveDesktopFeatures()
{
    IActiveDesktop *pActiveDesk;
    BOOL    fModified = FALSE;

    // Get the ActiveDesktop and HideIcons flags.
    SHELLSTATE  ss = {0};
    SHGetSetSettings(&ss, SSF_DESKTOPHTML | SSF_HIDEICONS, FALSE);

    //Check if ActiveDesktop is already ON.
    if(ss.fDesktopHTML)
        return FALSE;  //ActiveDesktop is already ON. No need to change any settings.

    //Active Desktop is OFF. We may need to change the other settings to be consistent with this!

    // 1. Check if Desktop icons are hidden when ActiveDesktop is on.
    if(ss.fHideIcons)
    {
        //Yes! Turn off this. Otherwise, AD will be turned on to support this!
        ss.fHideIcons = FALSE;
        SHGetSetSettings(&ss, SSF_HIDEICONS, TRUE);
        fModified = TRUE;
    }
    
    // 2. If the ActiveDesktop components are locked, un-lock them.
    DWORD dwDesktopFlags = GetDesktopFlags();
    
    if(dwDesktopFlags & COMPONENTS_LOCKED)
    {
        if(SetDesktopFlags(COMPONENTS_LOCKED, 0)) //Remove the "locked" flag!
            fModified = TRUE;
    }

    // 3. Let's enumerate all active desktop components and make sure they are all off.
    BOOL fModifiedComp = FALSE;

    HRESULT hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pActiveDesk, IID_IActiveDesktop);
    if (SUCCEEDED(hres))
    {
        int iCount = 0;
        pActiveDesk->GetDesktopItemCount(&iCount, 0);

        for(int i = 0; i < iCount; i++)
        {
            COMPONENT Comp;
            Comp.dwSize = sizeof(Comp);
            if(SUCCEEDED(pActiveDesk->GetDesktopItem(i, &Comp, 0)))
            {
                if(Comp.fChecked)           //If this component is enabled.....
                {
                    Comp.fChecked = FALSE;  //...., then disable it!
                    if(SUCCEEDED(pActiveDesk->ModifyDesktopItem(&Comp, COMP_ELEM_CHECKED)))
                        fModifiedComp = TRUE;
                }
            }
        }

        if(fModifiedComp)
            pActiveDesk->ApplyChanges(AD_APPLY_SAVE); //We just need to save the above changes.

        pActiveDesk ->Release();
    }

    //return whether we modified any setting.
    return (fModified || fModifiedComp);
}



// Little helper function used to change the safemode state
void SetSafeMode(DWORD dwFlags)
{
    IActiveDesktopP * piadp;

    if (SUCCEEDED(CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&piadp, IID_IActiveDesktopP)))
    {
        piadp->SetSafeMode(dwFlags);
        piadp->Release();
    }
}

/****************************************************************************
 *
 *  RefreshWebViewDesktop - regenerates desktop HTML from registry and updates
 *                          the screen
 *
 *  ENTRY:
 *      none
 *
 *  RETURNS:
 *      TRUE on success
 *      
 ****************************************************************************/
BOOL PokeWebViewDesktop(DWORD dwFlags)
{
    IActiveDesktop *pad;
    HRESULT     hres;
    BOOL        fRet = FALSE;

    hres = CActiveDesktop_InternalCreateInstance((LPUNKNOWN *)&pad, IID_IActiveDesktop);

    if (SUCCEEDED(hres))
    {
        pad->ApplyChanges(dwFlags);
        pad->Release();

        fRet = TRUE;
    }

    return (fRet);
}

#define CCH_NONE 20 //big enough for "(None)" in german
TCHAR g_szNone[CCH_NONE] = {0};

void InitDeskHtmlGlobals(void)
{
    static fGlobalsInited = FALSE;

    if (fGlobalsInited == FALSE)
    {
        LoadString(HINST_THISDLL, IDS_WPNONE, g_szNone, ARRAYSIZE(g_szNone));

        fGlobalsInited = TRUE;
    }
}

//
// Loads the preview bitmap for property sheet pages.
//
HBITMAP LoadMonitorBitmap(void)
{
    HBITMAP hbm,hbmT;
    BITMAP bm;
    HBRUSH hbrT;
    HDC hdc;
    COLORREF c3df = GetSysColor(COLOR_3DFACE);

    hbm = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MONITOR));
    if (hbm == NULL)
    {
        return NULL;
    }

    //
    // Convert the "base" of the monitor to the right color.
    //
    // The lower left of the bitmap has a transparent color
    // we fixup using FloodFill
    //
    hdc = CreateCompatibleDC(NULL);
    hbmT = (HBITMAP)SelectObject(hdc, hbm);
    hbrT = (HBRUSH)SelectObject(hdc, GetSysColorBrush(COLOR_3DFACE));

    GetObject(hbm, sizeof(bm), &bm);

    ExtFloodFill(hdc, 0, bm.bmHeight-1, GetPixel(hdc, 0, bm.bmHeight-1), FLOODFILLSURFACE);

    //
    // Round off the corners.
    // The bottom two were done by the floodfill above.
    // The top left is important since SS_CENTERIMAGE uses it to fill gaps.
    // The top right should be rounded because the other three are.
    //
    SetPixel( hdc, 0, 0, c3df );
    SetPixel( hdc, bm.bmWidth-1, 0, c3df );

    //
    // Fill in the desktop here.
    //
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, GetSysColorBrush(COLOR_DESKTOP));
    PatBlt(hdc, MON_X, MON_Y, MON_DX, MON_DY, PATCOPY);
    SelectObject(hdc, hbrOld);

    //
    // Clean up after ourselves.
    //
    SelectObject(hdc, hbrT);
    SelectObject(hdc, hbmT);
    DeleteDC(hdc);

    return hbm;
}

STDAPI_(VOID) ActiveDesktop_ApplyChanges()
{
    IActiveDesktop* piad;
    if (SUCCEEDED(CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActiveDesktop, &piad))))
    {        
        piad->ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
        piad->Release();
    }
}

STDAPI_(DWORD) GetDesktopFlags(void)
{
    DWORD dwFlags = 0, dwType, cbSize = sizeof(dwFlags);
    TCHAR szDeskcomp[MAX_PATH];

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);
    SHGetValue(HKEY_CURRENT_USER, szDeskcomp, REG_VAL_COMP_GENFLAGS, &dwType, &dwFlags, &cbSize);

    return dwFlags;
}

STDAPI_(BOOL) SetDesktopFlags(DWORD dwMask, DWORD dwNewFlags)
{
    BOOL  fRet = FALSE;
    HKEY  hkey;
    DWORD dwDisposition;
    TCHAR szDeskcomp[MAX_PATH];

    GetRegLocation(szDeskcomp, ARRAYSIZE(szDeskcomp), REG_DESKCOMP_COMPONENTS, NULL);
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szDeskcomp, 
                                        0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkey,
                                        &dwDisposition))
    {
        DWORD dwFlags;
        DWORD cbSize = sizeof(dwFlags);
        DWORD dwType;

        if (SHQueryValueEx(hkey, REG_VAL_COMP_GENFLAGS, NULL, &dwType,
                            (LPBYTE)&dwFlags, &cbSize) != ERROR_SUCCESS)
        {
            dwFlags = 0;
        }

        dwFlags = (dwFlags & ~dwMask) | (dwNewFlags & dwMask);

        if (RegSetValueEx(hkey, REG_VAL_COMP_GENFLAGS, 0, REG_DWORD,
                          (LPBYTE)&dwFlags, sizeof(dwFlags)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    
        RegCloseKey(hkey);
    }

    return fRet;
}

BOOL UpdateComponentFlags(LPCTSTR pszCompId, DWORD dwMask, DWORD dwNewFlags)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;

    GetRegLocation(szRegPath, ARRAYSIZE(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    if (PathAppend(szRegPath, pszCompId))
    {
        //Don't use RegCreateKeyEx here. It will result in Null components to be added.
        if (RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ | KEY_WRITE, &hkey) == ERROR_SUCCESS)
        {
            DWORD dwType, dwFlags, dwDataLength;

            dwDataLength = sizeof(DWORD);
            if(SHQueryValueEx(hkey, REG_VAL_COMP_FLAGS, NULL, &dwType, (LPBYTE)&dwFlags, &dwDataLength) != ERROR_SUCCESS)
            {
                dwFlags = 0;
            }        

            dwNewFlags = (dwFlags & ~dwMask) | (dwNewFlags & dwMask);

            if (RegSetValueEx(hkey, REG_VAL_COMP_FLAGS, 0, REG_DWORD, (LPBYTE)&dwNewFlags,
                              sizeof(DWORD)) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }

            SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

            RegCloseKey(hkey);
        }
    }

    if (!fRet)
    {
        TraceMsg(TF_WARNING, "DS: Unable to UpdateComponentFlags");
    }

    return fRet;
}

DWORD GetCurrentState(LPTSTR pszCompId)
{
    TCHAR szRegPath[MAX_PATH];
    DWORD cbSize, dwType, dwCurState = IS_NORMAL;

    GetRegLocation(szRegPath, ARRAYSIZE(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    if (PathAppend(szRegPath, pszCompId))
    {
        cbSize = sizeof(dwCurState);

        SHGetValue(HKEY_CURRENT_USER, szRegPath, REG_VAL_COMP_CURSTATE, &dwType, &dwCurState, &cbSize);
    }
    return dwCurState;
}

BOOL GetSavedStateInfo(LPTSTR pszCompId, LPCOMPSTATEINFO    pCompState, BOOL  fRestoredState)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;
    LPTSTR lpValName = (fRestoredState ? REG_VAL_COMP_RESTOREDSTATEINFO : REG_VAL_COMP_ORIGINALSTATEINFO);

    GetRegLocation(szRegPath, ARRAYSIZE(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    if (PathAppend(szRegPath, pszCompId) &&
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hkey))
    {
        DWORD   cbSize, dwType;
        
        cbSize = sizeof(*pCompState);
        dwType = REG_BINARY;
        
        if (SHQueryValueEx(hkey, lpValName, NULL, &dwType, (LPBYTE)pCompState, &cbSize) != ERROR_SUCCESS)
        {
            //If the item state is missing, read the item current position and
            // and return that as the saved state.
            COMPPOS cpPos;

            cbSize = sizeof(cpPos);
            dwType = REG_BINARY;
            if (SHQueryValueEx(hkey, REG_VAL_COMP_POSITION, NULL, &dwType, (LPBYTE)&cpPos, &cbSize) != ERROR_SUCCESS)
            {
                ZeroMemory(&cpPos, sizeof(cpPos));
            }            
            SetStateInfo(pCompState, &cpPos, IS_NORMAL);
        }

        RegCloseKey(hkey);

        fRet = TRUE;
    }

    if (!fRet)
    {
        TraceMsg(TF_WARNING, "DS: Unable to get SavedStateInfo()");
    }

    return fRet;
 }


BOOL UpdateDesktopPosition(LPTSTR pszCompId, int iLeft, int iTop, DWORD dwWidth, DWORD dwHeight, int izIndex,
                            BOOL    fSaveRestorePos, BOOL fSaveOriginal, DWORD dwCurState)
{
    BOOL fRet = FALSE;
    TCHAR szRegPath[MAX_PATH];
    HKEY hkey;

    GetRegLocation(szRegPath, ARRAYSIZE(szRegPath), REG_DESKCOMP_COMPONENTS, NULL);
    if (PathAppend(szRegPath, pszCompId) &&
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegPath, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey))  //Don't use RegCreateKeyEx here; It will result in a NULL component being added.

    {
        COMPPOS         cp;
        DWORD           dwType;
        DWORD           dwDataLength;
        COMPSTATEINFO   csi;

        dwType = REG_BINARY;
        dwDataLength = sizeof(COMPPOS);

        if(SHQueryValueEx(hkey, REG_VAL_COMP_POSITION, NULL, &dwType, (LPBYTE)&cp, &dwDataLength) != ERROR_SUCCESS)
        {
            cp.fCanResize = cp.fCanResizeX = cp.fCanResizeY = TRUE;
            cp.iPreferredLeftPercent = cp.iPreferredTopPercent = 0;
        }

        //Read the current State
        dwType = REG_DWORD;
        dwDataLength = sizeof(csi.dwItemState);
        if (SHQueryValueEx(hkey, REG_VAL_COMP_CURSTATE, NULL, &dwType, (LPBYTE)&csi.dwItemState, &dwDataLength) != ERROR_SUCCESS)
        {
            csi.dwItemState = IS_NORMAL;
        }

        if(fSaveRestorePos)
        {
            //We have just read the current position; Let's save it as the restore position.
            SetStateInfo(&csi, &cp, csi.dwItemState);

            //Now that we know the complete current state, save it as the restore state!
            RegSetValueEx(hkey, REG_VAL_COMP_RESTOREDSTATEINFO, 0, REG_BINARY, (LPBYTE)&csi, sizeof(csi));
        }

        //Save the current state too!
        if(dwCurState)
            RegSetValueEx(hkey, REG_VAL_COMP_CURSTATE, 0, REG_DWORD, (LPBYTE)&dwCurState, sizeof(dwCurState));
            
        cp.dwSize = sizeof(COMPPOS);
        cp.iLeft = iLeft;
        cp.iTop = iTop;
        cp.dwWidth = dwWidth;
        cp.dwHeight = dwHeight;
        cp.izIndex = izIndex;

        if (fSaveOriginal) {
            SetStateInfo(&csi, &cp, csi.dwItemState);
            RegSetValueEx(hkey, REG_VAL_COMP_ORIGINALSTATEINFO, 0, REG_BINARY, (LPBYTE)&csi, sizeof(csi));
        }

        if (RegSetValueEx(hkey, REG_VAL_COMP_POSITION, 0, REG_BINARY, (LPBYTE)&cp,
                          sizeof(cp)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        // Don't need to mark as dirty if we're just saving the original pos
        if (!fSaveOriginal)
            SetDesktopFlags(COMPONENTS_DIRTY, COMPONENTS_DIRTY);

        RegCloseKey(hkey);

    }

    if (!fRet)
    {
        TraceMsg(TF_WARNING, "DS: Unable to UpdateDesktopPosition");
    }

    return fRet;
}


HRESULT GetPerUserFileName(LPTSTR pszOutputFileName, DWORD dwSize, LPTSTR pszPartialFileName)
{
    LPITEMIDLIST    pidlAppData;

    *pszOutputFileName = TEXT('\0');

    if(dwSize < MAX_PATH)
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidlAppData);
    if (SUCCEEDED(hr))
    {
        SHGetPathFromIDList(pidlAppData, pszOutputFileName);
        DWORD err = SHCreateDirectoryEx(NULL, pszOutputFileName, NULL);
        if (ERROR_FILE_EXISTS != err &&
            ERROR_ALREADY_EXISTS != err &&
            ERROR_SUCCESS != err)
        {
            hr = ResultFromLastError();
        }
        else
        {
            if (!PathAppend(pszOutputFileName, pszPartialFileName))
            {
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
            }
        }
        ILFree(pidlAppData);
    }

    return hr;
}


void GetRegLocation(LPTSTR lpszResult, DWORD cchResult, LPCTSTR lpszKey, LPCTSTR lpszScheme)
{
    TCHAR szSubkey[MAX_PATH] = TEXT("\\");
    DWORD dwDataLength = sizeof(szSubkey) - 2 * sizeof(TCHAR);
    DWORD dwType;

    //  use what was given or get it from the registry
    if (lpszScheme)
    {
        StringCchCat(szSubkey, ARRAYSIZE(szSubkey), lpszScheme);
    }
    else
    {
        SHGetValue(HKEY_CURRENT_USER, REG_DESKCOMP_SCHEME, REG_VAL_SCHEME_DISPLAY, &dwType,
                   (LPBYTE)(szSubkey) + sizeof(TCHAR), &dwDataLength);
    }

    if (szSubkey[1])
    {
        StringCchCat(szSubkey, ARRAYSIZE(szSubkey), TEXT("\\"));    
    }

    StringCchPrintf(lpszResult, cchResult, lpszKey, szSubkey);
}

BOOL ValidateFileName(HWND hwnd, LPCTSTR pszFilename, int iTypeString)
{
    BOOL fRet = TRUE;

    DWORD dwAttributes = GetFileAttributes(pszFilename);
    if ((dwAttributes != 0xFFFFFFFF) &&
        (dwAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)))
    {
        TCHAR szType1[64];
        TCHAR szType2[64];

        LoadString(HINST_THISDLL, iTypeString, szType1, ARRAYSIZE(szType1));
        LoadString(HINST_THISDLL, iTypeString+1, szType2, ARRAYSIZE(szType2));
        if (ShellMessageBox(HINST_THISDLL, hwnd,
                            MAKEINTRESOURCE(IDS_VALIDFN_FMT),
                            MAKEINTRESOURCE(IDS_VALIDFN_TITLE),
                            MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2,
                            szType1, szType2) == IDNO)
        {
            fRet = FALSE;
        }
    }

    return fRet;
}

BOOL GetWallpaperDirName(LPTSTR lpszWallPaperDir, int iBuffSize)
{
    BOOL fRet = FALSE;

    TCHAR szExp[MAX_PATH];

    //Compute the default wallpaper name.
    if (GetWindowsDirectory(lpszWallPaperDir, iBuffSize) &&
        SUCCEEDED(StringCchCat(lpszWallPaperDir, iBuffSize, DESKTOPHTML_WEB_DIR)))
    {
        //Read it from the registry key, if it is set!
        DWORD dwType;
        DWORD cbData = (DWORD)iBuffSize;
        SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, c_szWallPaperDir, &dwType, (LPVOID)lpszWallPaperDir, &cbData);

        SHExpandEnvironmentStrings(lpszWallPaperDir, szExp, ARRAYSIZE(szExp));
        if (SUCCEEDED(StringCchCopy(lpszWallPaperDir, iBuffSize, szExp)))
        {
            fRet = TRUE;
        }
    }
    
    return fRet;
}

BOOL CALLBACK MultiMonEnumAreaCallBack(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData)
{
    EnumMonitorsArea* pEMA = (EnumMonitorsArea*)lData;
    
    if (pEMA->iMonitors > LV_MAX_WORKAREAS - 1)
    {
        //ignore the other monitors because we can only handle up to LV_MAX_WORKAREAS
        //REARCHITECT: should we dynamically allocate this?
        return FALSE;
    }
    GetMonitorRect(hMonitor, &pEMA->rcMonitor[pEMA->iMonitors]);
    GetMonitorWorkArea(hMonitor, &pEMA->rcWorkArea[pEMA->iMonitors]);
    if(pEMA->iMonitors == 0)
    {
        pEMA->rcVirtualMonitor.left = pEMA->rcMonitor[0].left;
        pEMA->rcVirtualMonitor.top = pEMA->rcMonitor[0].top;
        pEMA->rcVirtualMonitor.right = pEMA->rcMonitor[0].right;
        pEMA->rcVirtualMonitor.bottom = pEMA->rcMonitor[0].bottom;

        pEMA->rcVirtualWorkArea.left = pEMA->rcWorkArea[0].left;
        pEMA->rcVirtualWorkArea.top = pEMA->rcWorkArea[0].top;
        pEMA->rcVirtualWorkArea.right = pEMA->rcWorkArea[0].right;
        pEMA->rcVirtualWorkArea.bottom = pEMA->rcWorkArea[0].bottom;
    }
    else
    {
        if(pEMA->rcMonitor[pEMA->iMonitors].left < pEMA->rcVirtualMonitor.left)
        {
            pEMA->rcVirtualMonitor.left = pEMA->rcMonitor[pEMA->iMonitors].left;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].top < pEMA->rcVirtualMonitor.top)
        {
            pEMA->rcVirtualMonitor.top = pEMA->rcMonitor[pEMA->iMonitors].top;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].right > pEMA->rcVirtualMonitor.right)
        {
            pEMA->rcVirtualMonitor.right = pEMA->rcMonitor[pEMA->iMonitors].right;
        }
        if(pEMA->rcMonitor[pEMA->iMonitors].bottom > pEMA->rcVirtualMonitor.bottom)
        {
            pEMA->rcVirtualMonitor.bottom = pEMA->rcMonitor[pEMA->iMonitors].bottom;
        }

        if(pEMA->rcWorkArea[pEMA->iMonitors].left < pEMA->rcVirtualWorkArea.left)
        {
            pEMA->rcVirtualWorkArea.left = pEMA->rcWorkArea[pEMA->iMonitors].left;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].top < pEMA->rcVirtualWorkArea.top)
        {
            pEMA->rcVirtualWorkArea.top = pEMA->rcWorkArea[pEMA->iMonitors].top;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].right > pEMA->rcVirtualWorkArea.right)
        {
            pEMA->rcVirtualWorkArea.right = pEMA->rcWorkArea[pEMA->iMonitors].right;
        }
        if(pEMA->rcWorkArea[pEMA->iMonitors].bottom > pEMA->rcVirtualWorkArea.bottom)
        {
            pEMA->rcVirtualWorkArea.bottom = pEMA->rcWorkArea[pEMA->iMonitors].bottom;
        }
    }
    pEMA->iMonitors++;
    return TRUE;
}

void GetMonitorSettings(EnumMonitorsArea* ema)
{
    ema->iMonitors = 0;

    ema->rcVirtualMonitor.left = 0;
    ema->rcVirtualMonitor.top = 0;
    ema->rcVirtualMonitor.right = 0;
    ema->rcVirtualMonitor.bottom = 0;

    ema->rcVirtualWorkArea.left = 0;
    ema->rcVirtualWorkArea.top = 0;
    ema->rcVirtualWorkArea.right = 0;
    ema->rcVirtualWorkArea.bottom = 0;

    EnumDisplayMonitors(NULL, NULL, MultiMonEnumAreaCallBack, (LPARAM)ema);
}

int _GetWorkAreaIndexWorker(POINT pt, LPCRECT prect, int crect)
{
    int iIndex;

    for (iIndex = 0; iIndex < crect; iIndex++)
    {
        if (PtInRect(&prect[iIndex], pt))
        {
            return iIndex;
        }
    }

    return -1;
}

int GetWorkAreaIndexFromPoint(POINT pt, LPCRECT prect, int crect)
{
    ASSERT(crect);

    // Map to correct coords...
    pt.x += prect[0].left;
    pt.y += prect[0].top;

    return _GetWorkAreaIndexWorker(pt, prect, crect);
}

// Prepends the Web wallpaper directory or the system directory to szWallpaper, if necessary
// (i.e., if the path is not specified). The return value is in szWallpaperWithPath, which is iBufSize
// bytes long
BOOL GetWallpaperWithPath(LPCTSTR szWallpaper, LPTSTR szWallpaperWithPath, int iBufSize)
{
    BOOL fRet = FALSE;

    if (szWallpaper[0] && lstrcmpi(szWallpaper, g_szNone) != 0 && !StrChr(szWallpaper, TEXT('\\'))
            && !StrChr(szWallpaper, TEXT(':'))) // The file could be d:foo.bmp
    {
        // If the file is a normal wallpaper, we prepend the windows directory to the filename
        if (IsNormalWallpaper(szWallpaper))
        {
            if (ERROR_SUCCESS == GetWindowsDirectory(szWallpaperWithPath, iBufSize))
            {
                fRet = TRUE;
            }
        }
        // else we prepend the wallpaper directory to the filename
        else
        {
            fRet = GetWallpaperDirName(szWallpaperWithPath, iBufSize);
        }

        if (fRet)
        {
            fRet = PathAppend(szWallpaperWithPath, szWallpaper);
        }
    }
    else
    {
        if (SUCCEEDED(StringCchCopy(szWallpaperWithPath, iBufSize, szWallpaper)))
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

BOOL GetViewAreas(LPRECT lprcViewAreas, int* pnViewAreas)
{
    BOOL bRet = FALSE;
    HWND hwndDesktop = GetShellWindow();    // This is the "normal" desktop
    
    if (hwndDesktop && IsWindow(hwndDesktop))
    {
        DWORD dwProcID, dwCurrentProcID;
        
        GetWindowThreadProcessId(hwndDesktop, &dwProcID);
        dwCurrentProcID = GetCurrentProcessId();
        if (dwCurrentProcID == dwProcID) {
            SendMessage(hwndDesktop, DTM_GETVIEWAREAS, (WPARAM)pnViewAreas, (LPARAM)lprcViewAreas);
            if (*pnViewAreas <= 0)
            {
                bRet = FALSE;
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}

// We need to enforce a minimum size for the deskmovr caption since it doesn't look
// right drawn any smaller
int GetcyCaption()
{
    int cyCaption = GetSystemMetrics(SM_CYSMCAPTION);

    if (cyCaption < 15)
        cyCaption = 15;

    cyCaption -= GetSystemMetrics(SM_CYBORDER);

    return cyCaption;
}


HRESULT PathExpandEnvStringsWrap(LPTSTR pszString, DWORD cchSize)
{    
    HRESULT hr;

    if (!pszString)
    {
        hr = S_OK; // nothing to do!
    }
    else
    {
        TCHAR szTemp[MAX_PATH];

        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), pszString);
        if (SUCCEEDED(hr))
        {
            if (0 == SHExpandEnvironmentStrings(szTemp, pszString, cchSize))
            {
                hr = StringCchCopy(pszString, cchSize, szTemp);
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\dvoc.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "stdenum.h"
#include <mshtmdid.h>
#include "..\util.h"

#define SZ_ATL_SHEMBEDDING_WNDCLASS         TEXT("ATL Shell Embedding")

HRESULT MakeSafeForScripting(IUnknown** ppDisp);

class ATL_NO_VTABLE CWebViewFolderContents
                    : public CComObjectRootEx<CComSingleThreadModel>
                    , public CComCoClass<CWebViewFolderContents, &CLSID_WebViewFolderContents>
                    , public CComControl<CWebViewFolderContents>
                    , public IDispatchImpl<IShellFolderViewDual2, &IID_IShellFolderViewDual2, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
                    , public IProvideClassInfo2Impl<&CLSID_WebViewFolderContents, NULL, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>
                    , public IPersistImpl<CWebViewFolderContents>
                    , public IOleControlImpl<CWebViewFolderContents>
                    , public IOleObjectImpl<CWebViewFolderContents>
                    , public IViewObjectExImpl<CWebViewFolderContents>
                    , public IOleInPlaceActiveObjectImpl<CWebViewFolderContents>
                    , public IDataObjectImpl<CWebViewFolderContents>
                    , public IObjectSafetyImpl<CWebViewFolderContents, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
                    , public IConnectionPointContainer
                    , public IOleInPlaceObject
                    , public IInternetSecurityMgrSite
                    , public IServiceProvider
{
public:
    CWebViewFolderContents();
    ~CWebViewFolderContents();

    DECLARE_POLY_AGGREGATABLE(CWebViewFolderContents);
    DECLARE_NO_REGISTRY();
    DECLARE_WND_CLASS(SZ_ATL_SHEMBEDDING_WNDCLASS)

BEGIN_COM_MAP(CWebViewFolderContents)
    // ATL Uses these in IUnknown::QueryInterface()
    COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IShellFolderViewDual)
    COM_INTERFACE_ENTRY(IShellFolderViewDual2)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IInternetSecurityMgrSite)
END_COM_MAP()

 
// Declare the default message map
BEGIN_MSG_MAP(CWebViewFolderContents)
    MESSAGE_HANDLER(WM_SIZE, _OnSizeMessage) 
    MESSAGE_HANDLER(WM_NOTIFY, _OnMessageForwarder) 
    MESSAGE_HANDLER(WM_CONTEXTMENU, _OnMessageForwarder)
    MESSAGE_HANDLER(WM_SETCURSOR, _OnMessageForwarder)
    MESSAGE_HANDLER(WM_ERASEBKGND, _OnEraseBkgndMessage)
END_MSG_MAP()


    // IDispatch
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);

    // IProvideClassInfo
    STDMETHODIMP GetClassInfo(ITypeInfo** pptinfo);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // IInternetSecurityMgrSite
    // STDMETHODIMP GetWindow(HWND * lphwnd);              // Also in IOleWindow
    STDMETHODIMP EnableModeless(BOOL fEnable) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::EnableModeless(fEnable); };     // Also in IOleInPlaceActiveObject

    // IShellFolderViewDual2
    STDMETHODIMP get_Application(IDispatch **ppid);
    STDMETHODIMP get_Parent(IDispatch **ppid);
    STDMETHODIMP get_Folder(Folder **ppid);
    STDMETHODIMP SelectedItems(FolderItems **ppid);
    STDMETHODIMP get_FocusedItem(FolderItem **ppid);
    STDMETHODIMP SelectItem(VARIANT *pvfi, int dwFlags);
    STDMETHODIMP PopupItemMenu(FolderItem * pfi, VARIANT vx, VARIANT vy, BSTR * pbs);
    STDMETHODIMP get_Script(IDispatch **ppid);
    STDMETHODIMP get_ViewOptions(long *plSetting);
    STDMETHODIMP get_CurrentViewMode(UINT *pViewMode);
    STDMETHODIMP put_CurrentViewMode(UINT ViewMode);
    STDMETHODIMP SelectItemRelative(int iRelative);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::GetWindow(lphwnd); };
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::ContextSensitiveHelp(fEnterMode); };

    // IOleObject
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite)
    {
        if (pClientSite == NULL)
        {
            // Unadvise
            if (m_spClientSite)
            {
                AtlUnadvise(m_spClientSite, IID_IDispatch, _dwHtmlWindowAdviseCookie);
                _dwHtmlWindowAdviseCookie = 0;
            }
        }

        // Call the default impl first
        HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::SetClientSite(pClientSite);

        if (m_spClientSite && SUCCEEDED(hr))
        {
            CComPtr<IOleContainer> spContainer;
            if (m_spClientSite->GetContainer(&spContainer) == S_OK)
            {
                CComPtr<IHTMLDocument2> spDocument2;
                if (spContainer->QueryInterface(&spDocument2) == S_OK)
                {
                    CComPtr<IHTMLWindow2>   spHTMLWindow2;
                    if (spDocument2->get_parentWindow(&spHTMLWindow2) == S_OK)
                    {
                        // Now we AtlAdvise
                        CComPtr<IUnknown> spUnk;
                        ControlQueryInterface(IID_PPV_ARG(IUnknown, &spUnk));
                        AtlAdvise(spHTMLWindow2, spUnk, IID_IDispatch, &_dwHtmlWindowAdviseCookie);
                    }
                }
            }
        }
        return hr;
    }

    // IOleInPlaceObject
    STDMETHODIMP InPlaceDeactivate(void);
    STDMETHODIMP UIDeactivate(void) { return IOleInPlaceObject_UIDeactivate(); };
    STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };

    // IOleInPlaceActiveObject
    // our frame was activated, better do the activation thing.
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate)
    {
        if (_hwndLV && fActivate)
            ::SetFocus(_hwndLV);
        return S_OK;
    };
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

    // IConnectionPointContainer
    STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID riid, IConnectionPoint **ppCP);

    // Over ride ATL functions.
    LRESULT _OnMessageForwarder(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT _OnEraseBkgndMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT _OnSizeMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent);
    HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent);
    STDMETHODIMP Close(DWORD dwSaveOption);

protected:
    // Helper functions;
    HRESULT _SetupAutomationForwarders(void);
    HRESULT _ReleaseAutomationForwarders(void);
    HRESULT _OnInPlaceActivate(void);
    void _ReleaseWindow(void);
    void _ShowWindowLV(HWND hwndLV);
    void _UnadviseAll();

    class CConnectionPointForwarder : public IConnectionPoint
    {
        // IUnknown methods
        STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IConnectionPoint methods
        STDMETHODIMP GetConnectionInterface(IID * pIID);
        STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer ** ppCPC);
        STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
        STDMETHODIMP Unadvise(DWORD dwCookie);
        STDMETHODIMP EnumConnections(LPENUMCONNECTIONS * ppEnum) { return _pcpAuto->EnumConnections(ppEnum); }

        IConnectionPoint *  _pcpAuto;
        HDSA                _dsaCookies;
        IUnknown*           _punkParent;
        friend class CWebViewFolderContents;
    };
    friend class CConnectionPointForwarder;
    CConnectionPointForwarder m_cpEvents;

    IDefViewFrame3*     _pdvf3;   // defview
    BOOL                _fClientEdge;
    BOOL                _fTabRecieved;
    BOOL                _fCalledOnSizeForThisSize;
    HWND                _hwndLV;
    HWND                _hwndLVParent;

    ITypeInfo *         _pClassTypeInfo; // ITypeInfo of class

    DWORD               _dwHtmlWindowAdviseCookie;

    // stuff added to delegate all of our work up to DefViews automation
    IShellFolderViewDual2 *_pdispAuto;
};


LCID g_lcidLocaleUnicpp = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);


CWebViewFolderContents::CWebViewFolderContents()
{
    DllAddRef();

    // This allocator should have zero inited the memory, so assert the member variables are empty.
    ASSERT(!_pdvf3);
    ASSERT(!_hwndLV);
    ASSERT(!_hwndLVParent);
    ASSERT(!_fClientEdge);
    ASSERT(!_fTabRecieved);
    ASSERT(!_pClassTypeInfo);
    ASSERT(!m_cpEvents._dsaCookies);
    ASSERT(!_fCalledOnSizeForThisSize);
    
    m_bWindowOnly = TRUE;
    m_bEnabled = TRUE;
    m_bResizeNatural = TRUE;
    m_cpEvents._punkParent = SAFECAST(this, IViewObjectEx *);
    GetWndClassInfo().m_wc.style &= ~(CS_HREDRAW|CS_VREDRAW);
}

CWebViewFolderContents::~CWebViewFolderContents()
{
    _UnadviseAll();
    ASSERT(NULL == _pdvf3);
    ASSERT(NULL == _hwndLV);

    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();

    ATOMICRELEASE(_pdvf3);
    _ReleaseAutomationForwarders();

    DllRelease();
}


// ATL maintainence functions
LRESULT CWebViewFolderContents::_OnMessageForwarder(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (_hwndLVParent)
    {
        bHandled = TRUE;
        HWND hwnd = NULL;

        // Forward these messages directly to DefView (don't let MSHTML eat them)
        return ::SendMessage(_hwndLVParent, uMsg, wParam, lParam);
    }
    else
        return 0;
}


LRESULT CWebViewFolderContents::_OnEraseBkgndMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    // This function will just tell the default handler not to do anything and we
    // will handle it.

    // This is done in the case of WM_ERASEBKGND to...
    // Avoid flicker by not erasing the background. This OC doesn't care
    // about design-time issues - just usage on a Web View page.
    bHandled = TRUE;
    return 1;
}


LRESULT CWebViewFolderContents::_OnSizeMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    // Now resize the DefView ListView window because ATL isn't very reliable at it.
    if (_hwndLV)
    {
        // During re-parenting of _hwndLV by Trident, the size of the OC is not known to Trident.
        // So, initially we get this message with 1 and 1 for the width and height, from it.
        // And once Trident knows it's correct dimensions, we again get this message with the proper dim.
        // We get a performance gain by not passing the first no-sense 1 x 1 dimension to _hwndLV.
        //
        if (m_rcPos.right - m_rcPos.left != 1 || m_rcPos.bottom - m_rcPos.top != 1)
        {
            ::SetWindowPos(_hwndLV, 0, 0, 0, m_rcPos.right - m_rcPos.left, m_rcPos.bottom - m_rcPos.top, SWP_NOZORDER);
        }
    }

    bHandled = FALSE;
    return 0;
}


HRESULT CWebViewFolderContents::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::DoVerbUIActivate(prcPosRect, hwndParent);

    if (SUCCEEDED(hr))
    {
        hr = _OnInPlaceActivate();
    }

    if (_hwndLV)
    {
        ::SetFocus(_hwndLV);
    }
    return hr;
}


// move from de-active to in-place-active
HRESULT CWebViewFolderContents::_OnInPlaceActivate(void)
{
    HRESULT hr = S_OK;

    if (_pdvf3 == NULL)
    {
        hr = IUnknown_QueryService(m_spClientSite, SID_DefView, IID_PPV_ARG(IDefViewFrame3, &_pdvf3));
        if (EVAL(SUCCEEDED(hr)))
        {
            HWND hwnd;
            hr = _pdvf3->GetWindowLV(&hwnd);
            if (SUCCEEDED(hr))
            {
                _ShowWindowLV(hwnd); // we got it -- show the listview
            }
        }
    }
    return hr;
}

HRESULT CWebViewFolderContents::DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::DoVerbInPlaceActivate(prcPosRect, hwndParent);
    if (EVAL(SUCCEEDED(hr)))
    {
        hr = _OnInPlaceActivate();
    }
    return hr;
}

HRESULT CWebViewFolderContents::InPlaceDeactivate(void)
{
    _ReleaseWindow();
    ATOMICRELEASE(_pdvf3);

    return IOleInPlaceObject_InPlaceDeactivate();
}

HRESULT CWebViewFolderContents::SetObjectRects(LPCRECT prcPosRect, LPCRECT prcClipRect)
{

//  WARNING: Do NOT move the EqualRect() comparison to after the
//  IOleInPlaceObject_SetObjectRects declaration. The EqualRect()
//  will always return an equal result then.

    BOOL    bPositionRectDifferent = (EqualRect(&m_rcPos, prcPosRect) == 0);
    HRESULT hr = IOleInPlaceObject_SetObjectRects(prcPosRect, prcClipRect);

//  99/02/23 #294278 vtan: Trident did not call this routine when
//  marquee selecting but it now does. The jumpy scrolling now
//  manifests. Check that posRect has not changed before making
//  any scroll position adjustments.

    if (_hwndLV && _pdvf3 && (!_fCalledOnSizeForThisSize || bPositionRectDifferent))
    {
        _pdvf3->OnResizeListView();
        _fCalledOnSizeForThisSize = TRUE;
    }

    return hr;
}

// IOleInPlaceActiveObject
HRESULT CWebViewFolderContents::TranslateAccelerator(MSG *pMsg)
{
    HRESULT hr = S_OK;
    if (!_fTabRecieved)
    {
        hr = IOleInPlaceActiveObjectImpl<CWebViewFolderContents>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hr != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            IOleControlSite* pocs;
            if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
            {
                DWORD grfModifiers = 0;
                if (GetKeyState(VK_SHIFT) & 0x8000)
                {
                    grfModifiers |= 0x1;    //KEYMOD_SHIFT
                }
                if (GetKeyState(VK_CONTROL) & 0x8000)
                {
                    grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                }
                if (GetKeyState(VK_MENU) & 0x8000)
                {
                    grfModifiers |= 0x4;    //KEYMOD_ALT;
                }
                _fTabRecieved = TRUE;
                hr = pocs->TranslateAccelerator(pMsg, grfModifiers);
                _fTabRecieved = FALSE;
                pocs->Release();
            }
        }
    }
    return hr;
}

// IProvideClassInfo
HRESULT CWebViewFolderContents::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocaleUnicpp), LIBID_Shell32, 1, 0,
            CLSID_WebViewFolderContents, &_pClassTypeInfo);

    if (EVAL(_pClassTypeInfo))
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    *ppTI = NULL;
    return E_FAIL;
}

HRESULT CWebViewFolderContents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;

    *ppITypeInfo = NULL;

    if (0 != itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    //Load a type lib if we don't have the information already.
    if (NULL == *ppITypeInfo)
    {
        ITypeInfo * pITIDisp;

        hr = GetTypeInfoFromLibId(lcid, LIBID_Shell32, 1, 0,
            IID_IShellFolderViewDual2, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITypeInfo);

            ASSERT(SUCCEEDED(hrT));
            pITIDisp->Release();
        }
    }

    return hr;
}

HRESULT CWebViewFolderContents::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
    UINT cNames, LCID lcid, DISPID* rgdispid)
{
    ITypeInfo* pInfo;
    HRESULT hr = GetTypeInfo(0, lcid, &pInfo);

    if (pInfo != NULL)
    {
        hr = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
        pInfo->Release();
    }

    TraceMsg(TF_DEFVIEW, "CWebViewFolderContents::GetIDsOfNames(DISPID=%ls, lcid=%d, cNames=%d) returned hr=%#08lx", *rgszNames, lcid, cNames, hr);
    return hr;
}

HRESULT CWebViewFolderContents::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {0};

    if (!pdispparams)
        pdispparams = &dispparams;  // otherwise OLE Fails when passed NULL.

    if (dispidMember == DISPID_WINDOWOBJECT)
    {
        IDispatch * pdisp;
        if (SUCCEEDED(get_Script(&pdisp)))
        {
            hr = pdisp->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            pdisp->Release();
            return hr;
        }
        else
            return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure we are connected up to defviews automation.
    hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

    return hr;
}

#define DW_MISC_STATUS (OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT)

HRESULT CWebViewFolderContents::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = DW_MISC_STATUS;
    return S_OK;
}
 
void CWebViewFolderContents::_ShowWindowLV(HWND hwndLV)
{
    if (!hwndLV)
        return;
    _hwndLV = hwndLV;
    _hwndLVParent = ::GetParent(_hwndLV);

    SHSetParentHwnd(_hwndLV, m_hWnd);

    LONG lExStyle = ::GetWindowLong(_hwndLV, GWL_EXSTYLE);
    _fClientEdge = lExStyle & WS_EX_CLIENTEDGE ? TRUE : FALSE;

    UINT uFlags = SWP_NOZORDER;
    if (_fClientEdge)
    {
        lExStyle &= ~WS_EX_CLIENTEDGE;
        ::SetWindowLong(_hwndLV, GWL_EXSTYLE, lExStyle);
        uFlags |= SWP_FRAMECHANGED;
    }

    ::SetWindowPos(_hwndLV, 0, 0, 0, m_rcPos.right - m_rcPos.left
                    , m_rcPos.bottom - m_rcPos.top, uFlags);

    _pdvf3->ShowHideListView();
}

void CWebViewFolderContents::_ReleaseWindow()
{
    if (_hwndLV)
    {
        UINT uFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE;
        if (_fClientEdge)
        {
            SetWindowBits(_hwndLV, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
            uFlags |= SWP_FRAMECHANGED;
        }

        SHSetParentHwnd(_hwndLV, _hwndLVParent);
        ::SetWindowPos(_hwndLV, HWND_BOTTOM, 0, 0, 0, 0, uFlags);
        _pdvf3->ReleaseWindowLV();
        _hwndLV = NULL;
    }
}


// IConnectionPointContainer
HRESULT CWebViewFolderContents::EnumConnectionPoints(IEnumConnectionPoints **ppEnum)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = CreateInstance_IEnumConnectionPoints(ppEnum, 1, SAFECAST(&m_cpEvents, IConnectionPoint*));

    return hr;
}

HRESULT CWebViewFolderContents::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    *ppCP = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
    {
        if (IsEqualIID(iid, DIID_DShellFolderViewEvents) || IsEqualIID(iid, IID_IDispatch))
        {
            *ppCP = SAFECAST(&m_cpEvents, IConnectionPoint*);
            (*ppCP)->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}

// IConnectionPoint
//
// Our IConnectionPoint is really implemented by defview's CFolder's connection point.
// We just need to keep a count of outstanding references so we can force Unadvise
// calls during "implicit unadvise during shutdown" cases like Trident.
// (Is this really the spec?  It doesn't sound very robust...)
//
HRESULT CWebViewFolderContents::CConnectionPointForwarder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CConnectionPointForwarder, IConnectionPoint),                  // IID_IConnectionPoint
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CWebViewFolderContents::CConnectionPointForwarder::AddRef(void)
{
    return _punkParent->AddRef();
}
STDMETHODIMP_(ULONG) CWebViewFolderContents::CConnectionPointForwarder::Release(void)
{
    return _punkParent->Release();
}
        
HRESULT CWebViewFolderContents::CConnectionPointForwarder::GetConnectionInterface(IID * pIID)
{
    HRESULT hr = _pcpAuto->GetConnectionInterface(pIID);
    if (SUCCEEDED(hr))
    {
        ASSERT(IsEqualIID(*pIID, DIID_DShellFolderViewEvents));
    }
    return hr;
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    return _punkParent->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, ppCPC));
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::Advise(IUnknown * pUnkSink, DWORD * pdwCookie)
{
    if (!_dsaCookies)
    {
        _dsaCookies = DSA_Create(sizeof(*pdwCookie), 4);
        if (!_dsaCookies)
        {
            *pdwCookie = 0;
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = _pcpAuto->Advise(pUnkSink, pdwCookie);

    if (SUCCEEDED(hr))
    {
        if (-1 == DSA_AppendItem(_dsaCookies, pdwCookie))
        {
            _pcpAuto->Unadvise(*pdwCookie);
            *pdwCookie = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CWebViewFolderContents::CConnectionPointForwarder::Unadvise(DWORD dwCookie)
{
    if (_dsaCookies)
    {
        int i = 0;
        DWORD dw;
        while (DSA_GetItem(_dsaCookies, i++, &dw))
        {
            if (dw == dwCookie)
            {
                DSA_DeleteItem(_dsaCookies, --i);
                return _pcpAuto->Unadvise(dwCookie);
            }
        }
    }

    return E_FAIL;
}

void CWebViewFolderContents::_UnadviseAll()
{
    if (m_cpEvents._dsaCookies)
    {
        if (m_cpEvents._pcpAuto)
        {
            DWORD dw;
            for (int i = 0; DSA_GetItem(m_cpEvents._dsaCookies, i, &dw); i++)
            {
                m_cpEvents._pcpAuto->Unadvise(dw);
            }
        }
        DSA_Destroy(m_cpEvents._dsaCookies);
        m_cpEvents._dsaCookies = NULL;
    }
}

HRESULT CWebViewFolderContents::Close(DWORD dwSaveOption)
{
    _UnadviseAll();
    HRESULT hr = IOleObjectImpl<CWebViewFolderContents>::Close(dwSaveOption);
    _ReleaseAutomationForwarders();
    return hr;
}

HRESULT CWebViewFolderContents::_SetupAutomationForwarders(void)
{
    HRESULT hr = S_OK;
    if (!m_cpEvents._pcpAuto)
    {
        IShellView *psv;
        hr = IUnknown_QueryService(m_spClientSite, SID_DefView, IID_PPV_ARG(IShellView, &psv));
        if (SUCCEEDED(hr))
        {
            IDispatch *pdisp;
            hr = psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pdisp));
            if (SUCCEEDED(hr))
            {
                hr = pdisp->QueryInterface(IID_PPV_ARG(IShellFolderViewDual2, &_pdispAuto));
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(MakeSafeForScripting((IUnknown**)&_pdispAuto)))
                    {
                        IUnknown_SetSite(_pdispAuto, m_spClientSite);

                        // Need to get the right interfaces
                        IConnectionPointContainer* pcpcAuto;
                        hr = _pdispAuto->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpcAuto));
                        if (SUCCEEDED(hr))
                        {
                            hr = pcpcAuto->FindConnectionPoint(IID_IDispatch, &m_cpEvents._pcpAuto);
                            pcpcAuto->Release();
                        }

                        if (FAILED(hr))
                        {
                            IUnknown_SetSite(_pdispAuto, NULL);
                            ATOMICRELEASE(_pdispAuto);
                        }
                    }
                }
                pdisp->Release();
            }
            psv->Release();
        }
    }
    return hr;
}

HRESULT CWebViewFolderContents::_ReleaseAutomationForwarders(void)
{
    ATOMICRELEASE(m_cpEvents._pcpAuto);
    IUnknown_SetSite(_pdispAuto, NULL);
    ATOMICRELEASE(_pdispAuto);
    return S_OK;
}

// IShellFolderViewDual2

// We will let the folder object get created and have it maintain that we only have one
// application object (with the site) set properly...

HRESULT CWebViewFolderContents::get_Application(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Application(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_Parent(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Parent(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_Folder(Folder **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Folder(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::SelectedItems(FolderItems **ppid)
{
    // We need to talk to the actual window under us
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectedItems(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_FocusedItem(FolderItem **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_FocusedItem(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::SelectItem(VARIANT *pvfi, int dwFlags)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectItem(pvfi, dwFlags);
    return hr;
}

HRESULT CWebViewFolderContents::PopupItemMenu(FolderItem *pfi, VARIANT vx, VARIANT vy, BSTR * pbs)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->PopupItemMenu(pfi, vx, vy, pbs);
    return hr;
}

HRESULT CWebViewFolderContents::get_Script(IDispatch **ppid)
{
    *ppid = NULL;
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_Script(ppid);
    return hr;
}

HRESULT CWebViewFolderContents::get_ViewOptions(long *plSetting)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_ViewOptions(plSetting);
    return hr;
}


HRESULT CWebViewFolderContents::get_CurrentViewMode(UINT *pViewMode)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->get_CurrentViewMode(pViewMode);
    return hr;
}

HRESULT CWebViewFolderContents::put_CurrentViewMode(UINT ViewMode)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->put_CurrentViewMode(ViewMode);
    return hr;
}

HRESULT CWebViewFolderContents::SelectItemRelative(int iRelative)
{
    HRESULT hr = _SetupAutomationForwarders();
    if (SUCCEEDED(hr))
        hr = _pdispAuto->SelectItemRelative(iRelative);
    return hr;
}

HRESULT CWebViewFolderContents::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    return IUnknown_QueryService(m_spClientSite, SID_DefView, riid, ppv);
}


STDAPI CWebViewFolderContents_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    return CComCreator< CComPolyObject< CWebViewFolderContents > >::CreateInstance((void *) punkOuter, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\fldoppsx.cpp ===
//
// fldoppsx - Folder Options Property Sheet Extension
//

#include "stdafx.h"
#pragma hdrstop

CFolderOptionsPsx::CFolderOptionsPsx() : m_cRef(1)
{
    DllAddRef();
}

CFolderOptionsPsx::~CFolderOptionsPsx()
{
    ATOMICRELEASE(m_pbs2);
    ATOMICRELEASE(m_pgfs);
    DllRelease();
}

ULONG CFolderOptionsPsx::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CFolderOptionsPsx::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this; 
    }
    return cRef;
}

HRESULT CFolderOptionsPsx::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CFolderOptionsPsx, IShellPropSheetExt),
        QITABENT(CFolderOptionsPsx, IShellExtInit),
        QITABENT(CFolderOptionsPsx, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

UINT CALLBACK CFolderOptionsPsx::PropCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CFolderOptionsPsx *pfolder = (CFolderOptionsPsx *)ppsp->lParam;

    switch (uMsg)
    {
    case PSPCB_RELEASE:
        pfolder->Release();
        break;
    }

    return TRUE;
}



//
//  We add two pages.
//
//  1. "General"    - options.cpp
//  2. "View"       - advanced.cpp
//
//  The rule for IShellPropSheetExt is that AddPages can be called
//  only once, so we don't have to worry about a second call accidentally
//  screwing up our IBrowserService pointer.
//
//
HRESULT CFolderOptionsPsx::AddPages(LPFNADDPROPSHEETPAGE AddPage, LPARAM lParam)
{
    if (!m_pgfs)
    {
        HRESULT hres = CoCreateInstance(CLSID_GlobalFolderSettings, NULL, CLSCTX_INPROC_SERVER, 
            IID_IGlobalFolderSettings, (void **)&m_pgfs);
        if (FAILED(hres))
            return hres;
    }

    /*
     *  We can limp along without an IBrowserService.  It means that
     *  we are only modifying global settings, not per-folder settings.
     */

    if (!m_pbs2) 
    {
        IUnknown_QueryService(_punkSite, SID_SShellBrowser,
                              IID_IBrowserService2, (void **)&m_pbs2);
    }

    PROPSHEETPAGE psp;

    /*
     *  We used to do this only if we aren't a rooted Explorer,
     *  but TOuzts says to do it always.
     *
     *  The lParam is a pointer back to ourselves so the page
     *  can figure out why it was created and so the two pages
     *  can talk to each other.
     */
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance = HINST_THISDLL;
    psp.pfnCallback = CFolderOptionsPsx::PropCallback;
    psp.lParam = (LPARAM)this;


    // "General" page.
    psp.pszTemplate = MAKEINTRESOURCE(IDD_FOLDEROPTIONS);
    psp.pfnDlgProc = FolderOptionsDlgProc;
    HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
    if (hpage)
    {
        AddRef();
        if (!AddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            Release();
        }
    }

    // "View" page.
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCEDOPTIONS);
    psp.pfnDlgProc = AdvancedOptionsDlgProc;

    hpage = CreatePropertySheetPage(&psp);
    if (hpage)
    {
        AddRef();
        if (!AddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
            Release();
        }
    }

    return S_OK;
}

HRESULT CFolderOptionsPsx::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return S_OK;
}

HRESULT CFolderOptionsPsx::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    return S_OK;
}

STDAPI CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    CFolderOptionsPsx *pfopt = new CFolderOptionsPsx();
    if (pfopt) 
    {
        HRESULT hres = pfopt->QueryInterface(riid, ppvOut);
        pfopt->Release();
        return hres;
    }

    *ppvOut = NULL;
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\local.h ===
//
// Local private header file

#include "deskhtm.h"
#include <regstr.h>
#include "resource.h"
#include "shdocvw.h"

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH


// Use our private version of the OLE task allocator so we don't pull
// in all of OLE32 just to do LocalAlloc and LocalFree!

#ifndef DEBUG
#define CoTaskMemFree       SHFree
#define CoTaskMemAlloc      SHAlloc
#define CoTaskMemRealloc    SHRealloc
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "stdafx.h"
#pragma hdrstop

#include "..\inc\uassist.cpp"       // 'safe' thunks and cache

#ifdef DEBUG
//#define TF_QISTUB ... see shellprv.h ...
#include "..\inc\qistub.cpp"
#include "..\inc\dbutil.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_

#include <iethread.h>

DECLARE_HANDLE(HNFBLOCK);

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
IETHREADPARAM *ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);
BOOL DesktopOnCommandLine(HNFBLOCK hnf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\mimeflt.cpp ===
// CLSID_CWebViewMimeFilter
//
// Mime filter for Web View (.htt) content. Does substitutions on:
//
//   %TEMPLATEDIR%
//   %THISDIRPATH%
//   %THISDIRNAME%
//

#include "stdafx.h"
#pragma hdrstop

#define MAX_VARIABLE_NAME_SIZE 15 // see _Expand

// urlmon uses a 2K buffer size, so match that in retail. To force
// extra iterations and reallocations, use a smaller buffer size
// in debug. To further save on reallocations, we don't read the
// entire buffer to leave room for growth.
#ifdef DEBUG
#define BUFFER_SIZE 512
#define BUFFER_ALLOC_SIZE BUFFER_SIZE
#else
#define BUFFER_SIZE 0x2000
#define BUFFER_ALLOC_SIZE (BUFFER_SIZE+2*MAX_PATH)
#endif
#define BUFFER_SIZE_INC MAX_VARIABLE_NAME_SIZE*2 // must be > MAX_VARIABLE_NAME_SIZE

#define TF_EXPAND 0 // show strings as they are expanded in our mime filter?

#define MAX_HTML_ESCAPE_SEQUENCE 8  // longest string representation of a 16 bit integer is 65535.  So, entire composite escape string has:
                                    // 2 for "&#" + maximum of 5 digits + 1 for ";" = 8 characters


class CWebViewMimeFilter : public IInternetProtocol
                         , public IInternetProtocolSink
                         , public IServiceProvider
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IInternetProtocol methods
    STDMETHOD(Start)(
            LPCWSTR szUrl,
            IInternetProtocolSink *pProtSink,
            IInternetBindInfo *pOIBindInfo,
            DWORD grfSTI,
            HANDLE_PTR dwReserved);
    STDMETHOD(Continue)(PROTOCOLDATA *pStateInfo);
    STDMETHOD(Abort)(HRESULT hrReason,DWORD dwOptions);
    STDMETHOD(Terminate)(DWORD dwOptions);
    STDMETHOD(Suspend)();
    STDMETHOD(Resume)();
    STDMETHOD(Read)(void *pv,ULONG cb,ULONG *pcbRead);
    STDMETHOD(Seek)(
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(LockRequest)(DWORD dwOptions);
    STDMETHOD(UnlockRequest)();

    // IInternetProtocolSink methods
    STDMETHOD(Switch)(PROTOCOLDATA * pProtocolData);
    STDMETHOD(ReportProgress)(ULONG ulStatusCode, LPCWSTR pwszStatusText);
    STDMETHOD(ReportData)(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
    STDMETHOD(ReportResult)(HRESULT hrResult, DWORD dwError, LPCWSTR pwszResult);

    // IServiceProvider methods
    STDMETHOD(QueryService)(REFGUID rsid, REFIID riid, void ** ppvObj);

private:
    CWebViewMimeFilter();
    ~CWebViewMimeFilter();
    friend HRESULT CWebViewMimeFilter_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut);

    int    _StrCmp(LPBYTE pSrc, LPCSTR pAnsi, LPWSTR pUnicode);
    LPBYTE _StrChr(LPBYTE pSrc, char chA, WCHAR chW);
    int    _StrLen(LPBYTE pStr);

    void _QueryForDVCMDID(int dvcmdid, LPBYTE pDst, int cbDst);
    void _EncodeHtml(LPBYTE psz, size_t cbByte);
    HRESULT _IncreaseBuffer(ULONG cbIncrement, LPBYTE * pp1, LPBYTE * pp2);
    int _Expand(LPBYTE pszVar, LPBYTE * ppszExp);
    HRESULT _ReadAndExpandBuffer();

    int _cRef;

    LPBYTE _pBuf;       // our buffer
    ULONG _cbBufSize;   // size of the buffer
    ULONG _nCharSize;   // sizeof(char) or sizeof(WCHAR) depending on data type
    ULONG _cbBuf;       // count of bytes read into the buffer
    ULONG _cbSeek;      // offset to seek position
    BYTE  _szTemplateDirPath[2*MAX_PATH];
    BYTE  _szThisDirPath[MAX_HTML_ESCAPE_SEQUENCE*MAX_PATH];
    BYTE  _szThisDirName[MAX_HTML_ESCAPE_SEQUENCE*MAX_PATH];
    BYTE  _szExpansion[2*MAX_PATH];

    IInternetProtocol*         _pProt;             // incoming
    IInternetProtocolSink*     _pProtSink;         // outgoing
};

CWebViewMimeFilter::CWebViewMimeFilter()
{
    _cRef = 1;
}

CWebViewMimeFilter::~CWebViewMimeFilter()
{
    ATOMICRELEASE(_pProt);

    if (_pBuf)
    {
        LocalFree(_pBuf);
        _pBuf = NULL;
        _cbBufSize = 0;
    }

    ASSERT(NULL == _pProtSink);
}

HRESULT CWebViewMimeFilter_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CWebViewMimeFilter* pObj;

    pObj = new CWebViewMimeFilter();
    if (pObj)
    {
        hres = pObj->QueryInterface(riid, ppvOut);
        pObj->Release();
    }
    else
    {
        *ppvOut = NULL;
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

ULONG CWebViewMimeFilter::AddRef(void)
{
    _cRef++;
    return _cRef;
}


ULONG CWebViewMimeFilter::Release(void)
{
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;

    return 0;
}

HRESULT CWebViewMimeFilter::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CWebViewMimeFilter, IInternetProtocol),
        QITABENTMULTI(CWebViewMimeFilter, IInternetProtocolRoot, IInternetProtocol),
        QITABENT(CWebViewMimeFilter, IInternetProtocolSink),
        QITABENT(CWebViewMimeFilter, IServiceProvider),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

// IInternetProtocol methods
HRESULT CWebViewMimeFilter::Start(
        LPCWSTR szUrl,
        IInternetProtocolSink *pProtSink,
        IInternetBindInfo *pOIBindInfo,
        DWORD grfSTI,
        HANDLE_PTR dwReserved)
{
    HRESULT hr;

    if (!(EVAL(grfSTI & PI_FILTER_MODE)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // get the Prot pointer here
        PROTOCOLFILTERDATA* FiltData = (PROTOCOLFILTERDATA*) dwReserved;
        ASSERT(NULL == _pProt);
        _pProt = FiltData->pProtocol;
        _pProt->AddRef();

        // hold onto the sink as well
        ASSERT(NULL == _pProtSink);
        _pProtSink = pProtSink;
        _pProtSink->AddRef();

        // this filter converts text/webviewhtml to text/html
        _pProtSink->ReportProgress(BINDSTATUS_FILTERREPORTMIMETYPE, L"text/html");

        hr = S_OK;
    }

    return hr;
}
HRESULT CWebViewMimeFilter::Continue(PROTOCOLDATA *pStateInfo)
{
    ASSERT(_pProt);
    return _pProt->Continue(pStateInfo);
}
HRESULT CWebViewMimeFilter::Abort(HRESULT hrReason,DWORD dwOptions)
{
    ATOMICRELEASE(_pProtSink); // probably to remove ref cycle

    ASSERT(_pProt);
    return _pProt->Abort(hrReason, dwOptions);
}
HRESULT CWebViewMimeFilter::Terminate(DWORD dwOptions)
{
    ATOMICRELEASE(_pProtSink); // probably to remove ref cycle

    return _pProt->Terminate(dwOptions);
}
HRESULT CWebViewMimeFilter::Suspend()
{
    return _pProt->Suspend();
}
HRESULT CWebViewMimeFilter::Resume()
{
    return _pProt->Resume();
}

int CWebViewMimeFilter::_StrCmp(LPBYTE pSrc, LPCSTR pAnsi, LPWSTR pUnicode)
{
    if (sizeof(char) == _nCharSize)
    {
        return lstrcmpA(pAnsi, (LPSTR)pSrc);
    }
    else
    {
        ASSERT(_nCharSize == sizeof(WCHAR));

        return StrCmpW(pUnicode, (LPWSTR)pSrc);
    }
}

LPBYTE CWebViewMimeFilter::_StrChr(LPBYTE pSrc, char chA, WCHAR chW)
{
    if (sizeof(char) == _nCharSize)
    {
        return (LPBYTE)StrChrA((LPSTR)pSrc, chA);
    }
    else
    {
        return (LPBYTE)StrChrW((LPWSTR)pSrc, chW);
    }
}

int CWebViewMimeFilter::_StrLen(LPBYTE pStr)
{
    if (sizeof(char) == _nCharSize)
    {
        return lstrlenA((LPSTR)pStr);
    }
    else
    {
        return lstrlenW((LPWSTR)pStr);
    }
}

/*
 * UnicodeToHTMLEscapeStringAnsi
 *
 * Takes a unicode string as the input source and translates it into an ansi string that mshtml can process.  Characters > 127 will be
 * translated into an html escape sequence that has the following syntax:  "&#xxxxx;" where xxxxx is the string representation of the decimal
 * integer which is the value for the unicode character.  In this manner we are able to generate HTML text which represent UNICODE characters.
 */
void UnicodeToHTMLEscapeStringAnsi(LPWSTR pstrSrc, LPSTR pstrDest, int cbDest)
{
    LPSTR pstrDestOriginal = pstrDest;

    while (*pstrSrc && (cbDest > MAX_HTML_ESCAPE_SEQUENCE))
    {
        int iLen;
        ULONG ul = MAKELONG(*pstrSrc, 0);

        // We can optimize the common ansi characters to avoid generating the long escape sequence.  This allows us to fit
        // longer paths in the buffer.
        if (ul < 128)
        {
            *pstrDest = (CHAR)*pstrSrc;
            iLen = 1;
        }
        else
        {
            HRESULT hr = StringCchPrintfA(pstrDest, cbDest, "&#%lu;", ul);
            if (FAILED(hr))
            {
                *pstrDestOriginal = '\0';
                return;
            }
            iLen = lstrlenA(pstrDest);
        }
        pstrDest += iLen;
        cbDest -= iLen;
        pstrSrc++;
    }
    *pstrDest = 0;
}

void CWebViewMimeFilter::_QueryForDVCMDID(int dvcmdid, LPBYTE pDst, int cbDst)
{
    IOleCommandTarget * pct;
    if (SUCCEEDED(QueryService(SID_DefView, IID_IOleCommandTarget, (LPVOID*)&pct)))
    {
        VARIANT v = {0};

        if (S_OK == pct->Exec(&CGID_DefView, dvcmdid, 0, NULL, &v))
        {
            if (v.vt == VT_BSTR)
            {
                if (sizeof(char) == _nCharSize)
                {
                    UnicodeToHTMLEscapeStringAnsi(v.bstrVal, (LPSTR)pDst, cbDst);
                }
                else
                {
                    ASSERT(_nCharSize == sizeof(WCHAR));
            
                    HRESULT hr = StringCbCopy((LPWSTR)pDst, cbDst, v.bstrVal);
                    if (FAILED(hr))
                    {
                        *((LPWSTR)pDst) = L'\0';
                    }
                }
            }

            VariantClear(&v);
        }
        pct->Release();
    }
}

void ConvertTCharToBytes(LPCTSTR psz, UINT nCharSize, LPBYTE pBuf, int nBytes)
{
    if (sizeof(char) == nCharSize)
    {
        SHTCharToAnsi(psz, (LPSTR)pBuf, nBytes/nCharSize);
    }
    else
    {
        ASSERT(nCharSize == sizeof(WCHAR));
        SHTCharToUnicode(psz, (LPWSTR)pBuf, nBytes/nCharSize);
    }
}

void GetMachineTemplateDir(LPBYTE pszTemplateDirPath, int nBytes, UINT nCharSize)
{
    TCHAR szTemplateDir[MAX_PATH];
    szTemplateDir[0] = TEXT('\0');
    SHGetWebFolderFilePath(TEXT(""), szTemplateDir, ARRAYSIZE(szTemplateDir));
    // Remove the trailing back slash, if any
    int len = lstrlen(szTemplateDir);
    if ((len > 0) && (szTemplateDir[len - 1] == TEXT('\\')))
    {
        szTemplateDir[len - 1] = TEXT('\0');
    }

    ConvertTCharToBytes(szTemplateDir, nCharSize, pszTemplateDirPath, nBytes);
}

#define REG_WEBVIEW_TEMPLATE_MACROS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WebView\\TemplateMacros")

void ConvertBytesToTChar(LPCBYTE pBuf, UINT nCharSize, LPTSTR psz, int cch)
{
    if (sizeof(char) == nCharSize)
    {
        SHAnsiToTChar((LPCSTR)pBuf, psz, cch);
    }
    else
    {
        ASSERT(nCharSize == sizeof(WCHAR));
        SHUnicodeToTChar((LPCWSTR)pBuf, psz, cch);
    }
}

void ExpandMacro(LPBYTE pszMacro, LPBYTE pszExpansion, int nBytes, UINT nCharSize)
{
    TCHAR szExpansion[MAX_PATH];
    szExpansion[0] = TEXT('\0');
    
    TCHAR szTCharMacro[MAX_PATH];
    ConvertBytesToTChar(pszMacro, nCharSize, szTCharMacro, ARRAYSIZE(szTCharMacro));
    
    TCHAR szKey[MAX_PATH];
    HRESULT hr = StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%s"), REG_WEBVIEW_TEMPLATE_MACROS, szTCharMacro);
    if (SUCCEEDED(hr))
    {
        HKEY hkMacros;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_QUERY_VALUE, &hkMacros) == ERROR_SUCCESS
                || RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hkMacros) == ERROR_SUCCESS)
        {
            DWORD dwType;
            DWORD cbData = sizeof(szExpansion);
            SHQueryValueEx(hkMacros, NULL, NULL, &dwType, (LPBYTE)szExpansion, &cbData);
            RegCloseKey(hkMacros);
        }
    }
    ConvertTCharToBytes(szExpansion, nCharSize, pszExpansion, nBytes);
}

// Replace the first character of pszDst with the string pszIns.
//
HRESULT StringCchReplaceFirstCharWithStringA(LPSTR psz, size_t cch, LPCSTR pszIns)
{
    HRESULT hr;

    size_t cchIns = lstrlenA(pszIns);

    if (cchIns  < cch )
    {
        MoveMemory(psz + cchIns, psz + 1, cch - cchIns);
        *(psz + cch - 1) = '\0';
        MoveMemory(psz, pszIns, cchIns);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT StringCchReplaceFirstCharWithStringW(LPWSTR psz, size_t cch, LPCWSTR pszIns)
{
    HRESULT hr;

    size_t cchIns = lstrlenW(pszIns);

    if (cchIns  < cch)
    {
        MoveMemory(psz + cchIns, psz + 1, (cch - cchIns) * sizeof(WCHAR));
        *(psz + cch - 1) = L'\0';
        MoveMemory(psz, pszIns, cchIns * sizeof(WCHAR));
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

void CWebViewMimeFilter::_EncodeHtml(LPBYTE psz, size_t cb)
{
    HRESULT hr;
    size_t  length;

    if (sizeof(char) == _nCharSize)
    {
        while (*psz)
        {
            switch (*psz)
            {
            case '<':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&lt");
                length = 3;
                break;

            case '>':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&gt");
                length = 3;
                break;

            case '"':
                hr = StringCchReplaceFirstCharWithStringA((LPSTR)psz, cb, "&quot");
                length = 5;
                break;

            default:
                hr = S_OK;
                length = 1;
                break;
            }

            if (SUCCEEDED(hr))
            {
                psz += length;
                cb  -= length;
            }
            else
            {
                *psz = '\0';
            }
        }
    }
    else
    {
        ASSERT(sizeof(WCHAR) == _nCharSize);

        WCHAR* pszW = (WCHAR*)psz;
        size_t cchW = cb / sizeof(WCHAR);

        while (*pszW)
        {
            switch (*pszW)
            {
            case L'<':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&lt");
                length = 3;
                break;

            case L'>':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&gt");
                length = 3;
                break;

            case L'"':
                hr = StringCchReplaceFirstCharWithStringW(pszW, cchW, L"&quot");
                length = 5;
                break;

            default:
                hr = S_OK;
                length = 1;
                break;
            }

            if (SUCCEEDED(hr))
            {
                pszW += length;
                cchW -= length;
            }
            else
            {
                *pszW = L'\0';
            }
        }
    }
}

int CWebViewMimeFilter::_Expand(LPBYTE pszVar, LPBYTE * ppszExp)
{
    if (!_StrCmp(pszVar, "TEMPLATEDIR", L"TEMPLATEDIR"))
    {
        if (!_szTemplateDirPath[0])
        {
            GetMachineTemplateDir(_szTemplateDirPath, sizeof(_szTemplateDirPath), _nCharSize);
            _EncodeHtml(_szTemplateDirPath, sizeof(_szTemplateDirPath));
        }
        *ppszExp = _szTemplateDirPath;
    }
    else if (!_StrCmp(pszVar, "THISDIRPATH", L"THISDIRPATH"))
    {
        if (!_szThisDirPath[0])
        {
            _QueryForDVCMDID(DVCMDID_GETTHISDIRPATH, _szThisDirPath, sizeof(_szThisDirPath));
            _EncodeHtml(_szThisDirPath, sizeof(_szThisDirPath));
        }
        *ppszExp = _szThisDirPath;
    }
    else if (!_StrCmp(pszVar, "THISDIRNAME", L"THISDIRNAME"))
    {
        if (!_szThisDirName[0])
        {
            _QueryForDVCMDID(DVCMDID_GETTHISDIRNAME, _szThisDirName, sizeof(_szThisDirName));
            _EncodeHtml(_szThisDirName, sizeof(_szThisDirName));
        }
        *ppszExp = _szThisDirName;
    }
    else
    {
        ExpandMacro(pszVar, _szExpansion, sizeof(_szExpansion), _nCharSize);
        _EncodeHtml(_szExpansion, sizeof(_szExpansion));
        *ppszExp = _szExpansion;
    }

    return _StrLen(*ppszExp);
}

//
//  Ensure room for at least cbIncrement more bytes at the end of the buffer.
//  If the memory gets moved or realloced, *pp1 and *pp2 are adjusted to
//  point to the corresponding bytes at their new location(s).
//
HRESULT CWebViewMimeFilter::_IncreaseBuffer(ULONG cbIncrement, LPBYTE * pp1, LPBYTE * pp2)
{
    HRESULT hr = S_OK;

    // first check if there's room at the beginning of the buffer
    if (_cbSeek >= cbIncrement)
    {
        MoveMemory(_pBuf, _pBuf + _cbSeek, _cbBuf - _cbSeek);
        _cbBuf -= _cbSeek;

        if (pp1)
            *pp1 = *pp1 - _cbSeek;
        if (pp2)
            *pp2 = *pp2 - _cbSeek;

        _cbSeek = 0;
    }
    else
    {
        // not enough room, so allocate more memory
        LPBYTE p = (LPBYTE)LocalReAlloc(_pBuf, _cbBufSize + cbIncrement, LMEM_MOVEABLE);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if (pp1)
                *pp1 = p + (int)(*pp1 - _pBuf);
            if (pp2)
                *pp2 = p + (int)(*pp2 - _pBuf);
    
            _pBuf = p;
            _cbBufSize += cbIncrement;
        }
    }

    return hr;
}

HRESULT CWebViewMimeFilter::_ReadAndExpandBuffer()
{
    HRESULT hr;

    _cbBuf = 0;
    _cbSeek = 0;

    if (!_pBuf)
    {
        _pBuf = (LPBYTE)LocalAlloc(LPTR, BUFFER_ALLOC_SIZE);
        if (!_pBuf)
            return E_OUTOFMEMORY;

        _cbBufSize = BUFFER_ALLOC_SIZE;
    }

    // As strings expand, our buffer grows. If we keep reading in the
    // max amount, we'll keep reallocating the more variable expansions
    // we do. By only reading in BUFFER_SIZE, our _pBuf will grow only
    // a few times and then all the variable expansions should fit
    // in the extra room generated. NOTE: for debug builds, always
    // read the most we can, so we reallocate more often.
#ifdef DEBUG
    #define BUFFER_READ_SIZE (_cbBufSize)
#else
    #define BUFFER_READ_SIZE BUFFER_SIZE
#endif
    hr = _pProt->Read(_pBuf, BUFFER_READ_SIZE - sizeof(WCHAR), &_cbBuf); // make sure we have room for NULL
    if (SUCCEEDED(hr) && _cbBuf > 0)
    {
        LPBYTE pchSeek = _pBuf;
        LPBYTE pchEnd;

        if (!_nCharSize)
        {
            // scan buffer and figure out if it's unicode or ansi
            //
            // since we'll always be looking at html and the html header
            // is standard ansi chars, every other byte will be null if
            // we have a unicode buffer. i'm sure 3 checks are enough,
            // so we'll require 8 characters...
            if (_cbBuf > 6 &&
                0 == _pBuf[1] &&
                0 == _pBuf[3] &&
                0 == _pBuf[5])
            {
                TraceMsg(TF_EXPAND, "WebView MIME filter - buffer is UNICODE");
                _nCharSize = sizeof(WCHAR);
            }
            else
            {
                TraceMsg(TF_EXPAND, "WebView MIME filter - buffer is ANSI");
                _nCharSize = sizeof(char);
            }
        }

        // The string had better be null-terminated, for not only are we
        // going to do a StrChr, but our loop control relies on it!
        // The buffer might have leftover goo from a previous go-round, so
        // ensure that the nulls are there.
        _pBuf[_cbBuf] = _pBuf[_cbBuf+1] = 0;

#ifdef DEBUG
        if (sizeof(char)==_nCharSize)
            TraceMsg(TF_EXPAND, "Read A[%hs]", _pBuf);
        else
            TraceMsg(TF_EXPAND, "Read W[%ls]", _pBuf);
#endif

        do {
            LPBYTE pchStart = pchSeek;

            // Assert that the string is still properly null-terminated
            // because we're going to be doing StrChr soon.
            ASSERT(_pBuf[_cbBuf] == 0);
            ASSERT(_pBuf[_cbBuf+1] == 0);

            pchSeek = _StrChr(pchSeek, '%', L'%');
            if (!pchSeek)
                break;

            pchEnd = _StrChr(pchSeek+_nCharSize, '%', L'%');
            if (!pchEnd)
            {
                // no terminator. if there's plenty of space to the end of
                // this buffer then there can't be a clipped variable
                // name to expand.
                if (_cbBuf - (pchSeek - _pBuf) > MAX_VARIABLE_NAME_SIZE*_nCharSize)
                    break;

                // there may be a real variable here we need to expand,
                // so increase our buffer size and read some more data.
                //
                // we may get re-allocated, so update pchStart!
                hr = _IncreaseBuffer(BUFFER_SIZE_INC, &pchStart, NULL);
                if (FAILED(hr))
                    break;
                pchSeek = pchStart;

                // read in more info -- this will be enough to complete
                // any partial variable name expansions
                DWORD dwTmp;
                ASSERT(_cbBufSize - _cbBuf - sizeof(WCHAR) > 0);
                hr = _pProt->Read(_pBuf + _cbBuf, _cbBufSize- _cbBuf - sizeof(WCHAR), &dwTmp);
                if (FAILED(hr) || dwTmp == 0)
                    break;
                _cbBuf += dwTmp;
                // Ensure proper null termination
                _pBuf[_cbBuf] = _pBuf[_cbBuf+1] = 0;
                continue;
            }


            // figure out what to expand to
            LPBYTE pszExp;
            BYTE b[2];

            b[0] = pchEnd[0];
            b[1] = pchEnd[1];
            pchEnd[0] = 0;
            pchEnd[1] = 0;
            int cbExp = _Expand(pchSeek + _nCharSize, &pszExp);
            pchEnd[0] = b[0];
            pchEnd[1] = b[1];

            if (!cbExp)
            {
                // if it's not a recognized variable, use the bytes as they are
                pchSeek = pchEnd;
                continue;
            }

            // cbVar = number of bytes being replaced (sizeof("%VARNAME%"))
            // pchSeek points to the starting percent sign and pchEnd to
            // the trailing percent sign, so we need to add one more
            // _nCharSize to include the trailing percent sign itself.
            int cbVar = (int)(pchEnd - pchSeek) + _nCharSize;

            if (_cbBuf - cbVar + cbExp  > _cbBufSize - sizeof(WCHAR))
            {
                hr = _IncreaseBuffer((_cbBuf - cbVar + cbExp) - (_cbBufSize - sizeof(WCHAR)), &pchSeek, &pchEnd);
                if (FAILED(hr))
                    break;
            }

            // move the bytes around!
            // cbSeek = the number of bytes before the first percent sign
            int cbSeek = (int)(pchSeek - _pBuf);
            ASSERT(_cbBuf - cbVar + cbExp <= _cbBufSize - sizeof(WCHAR));
            // Move the stuff after the %VARNAME% to its final home
            // Don't forget to move the artificial trailing NULLs too!
            MoveMemory(pchSeek + cbExp, pchEnd + _nCharSize, _cbBuf - cbSeek - cbVar + sizeof(WCHAR));

            // Insert the expansion
            MoveMemory(pchSeek, pszExp, cbExp);

            // on to the rest of the buffer...
            pchSeek = pchEnd + _nCharSize;
            _cbBuf = _cbBuf - cbVar + cbExp;

        } while (*pchSeek);

#ifdef DEBUG
        if (sizeof(char)==_nCharSize)
            TraceMsg(TF_EXPAND, "---> A[%s]", _pBuf);
        else
            TraceMsg(TF_EXPAND, "---> W[%hs]", _pBuf);
#endif
    }
    else
    {
        // we're at end of stream
        hr = S_FALSE;
    }

    return hr;
}


HRESULT CWebViewMimeFilter::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    HRESULT hr = S_OK;

    if (!_pProt)
    {
        hr = E_FAIL;
    }
    else
    {
        *pcbRead = 0;

        while (cb)
        {
            // if our buffer is empty, fill it
            if (_cbSeek == _cbBuf)
            {
                hr = _ReadAndExpandBuffer();
            }

            // do we have any data to copy?
            int cbLeft = _cbBuf - _cbSeek;
            if (SUCCEEDED(hr) && cbLeft > 0)
            {
                ULONG cbCopy = min(cb, (ULONG)cbLeft);

                memcpy(pv, &_pBuf[_cbSeek], cbCopy);

                pv = (LPVOID)(((LPBYTE)pv) + cbCopy);
                cb -= cbCopy;
                *pcbRead += cbCopy;
                _cbSeek += cbCopy;

                // do not return S_FALSE if some bytes were left unread
                if (cbCopy < (ULONG)cbLeft)
                    hr = S_OK;
            }
            else
            {
                ASSERT(FAILED(hr) || hr == S_FALSE);

                // nothing left to copy
                break;
            }
        }
    }
    return hr;
}
HRESULT CWebViewMimeFilter::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}
HRESULT CWebViewMimeFilter::LockRequest(DWORD dwOptions)
{
    return S_OK;
}
HRESULT CWebViewMimeFilter::UnlockRequest()
{
    return S_OK;
}

// IInternetProtocolSink methods
HRESULT CWebViewMimeFilter::Switch(PROTOCOLDATA * pProtocolData)
{
    if (_pProtSink)
        return _pProtSink->Switch(pProtocolData);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportProgress(ULONG ulStatusCode, LPCWSTR pwszStatusText)
{
    if (_pProtSink)
        return _pProtSink->ReportProgress(ulStatusCode, pwszStatusText);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    if (_pProtSink)
        return _pProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
    return E_FAIL;
}
HRESULT CWebViewMimeFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR pwszResult)
{
    if (_pProtSink)
        return _pProtSink->ReportResult(hrResult, dwError, pwszResult);
    return E_FAIL;
}


//IServiceProvider methods
HRESULT CWebViewMimeFilter::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    return IUnknown_QueryService(_pProtSink, rsid, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\propbag.cpp ===
#include "stdafx.h"
#include "stddef.h"
#pragma hdrstop


//
// Exported function for creating a IPropertyBag (or variant of) object.
//

STDAPI SHCreatePropertyBag(REFIID riid, void **ppv)
{
    return SHCreatePropertyBagOnMemory(STGM_READWRITE, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\options.h ===
#ifndef _OPTIONS_H_
#define _OPTIONS_H_

#include <iethread.h>
#include <browseui.h>


#include "cowsite.h"

void DoGlobalFolderOptions(void);

class CFolderOptionsPsx :
        public
               IShellPropSheetExt,
               IShellExtInit,
               CObjectWithSite
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(THIS_ LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(THIS_ UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IShellExtInit
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

    void SetNeedRefresh(BOOL fNeedRefresh) { m_fNeedRefresh = fNeedRefresh; }
    BOOL NeedRefresh() { return m_fNeedRefresh; }

    BOOL HasBrowserService() { return m_pbs2 != NULL; }

    void SetAsDefFolderSettings()
    { if (HasBrowserService()) m_pbs2->SetAsDefFolderSettings(); }

    HRESULT GetDefFolderSettings(DEFFOLDERSETTINGS *pdfs, int cbDfs)
                { return m_pgfs->Get(pdfs, cbDfs); }
    HRESULT SetDefFolderSettings(const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags)
                { return m_pgfs->Set(pdfs, cbDfs, flags); }
    HRESULT ResetDefFolderSettings()
                { IUnknown_Exec(m_pbs2, &CGID_DefView, DVID_RESETDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                  return m_pgfs->Set(NULL, 0, GFSS_SETASDEFAULT); }

private:
    CFolderOptionsPsx();
    ~CFolderOptionsPsx();

    LONG m_cRef;
    BOOL m_fNeedRefresh;
    IBrowserService2 *m_pbs2;
    IGlobalFolderSettings *m_pgfs;

    friend HRESULT CFolderOptionsPsx_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut);
    static UINT CALLBACK PropCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
};

BOOL_PTR CALLBACK FolderOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _OPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\unicpp\resource.h ===
// copied from shdocvw\resource.h
// values adjusted to not conflict with shell32\ids.h
//


// IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_NEXTCTL       (FCIDM_BROWSERFIRST + 0x30) // explorer browseui shell32

// IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDFILES     (FCIDM_BROWSERFIRST + 0x85)

#define IDD_BACKGROUND                  0x7500
#define IDD_CUSTOMIZE                   0x7501
#define IDD_CUSTOMIZE_WEB               0x7502
#define IDD_ADDCOMPONENT                0x7503
#define IDD_COLORPICK                   0x7504
#define IDD_DESKCLNR                    0x7505

#define IDD_FOLDEROPTIONS               0x7507 
#define IDD_ADVANCEDOPTIONS             0x7508

#define IDI_BACK_NONE                   200 // shell32 id.h goes to 173 for icons
#define IDI_FOLDEROPTIONS               210
#define IDI_FRAME                       0x0200

//Desktop cleaner dialog
#define IDC_DESKCLNR_MOVEUNUSED         0x7540
#define IDC_DESKCLNR_CHECK              0x7541
#define IDC_DESKCLNR_RUNWIZARD          0x7542

#define IDC_BACK_WPLIST                 0x7560
#define IDC_BACK_BROWSE                 0x7561
#define IDC_BACK_WEB                    0x7562
#define IDC_BACK_WPSTYLE                0x7563
#define IDC_BACK_PREVIEW                0x7565
#define ID